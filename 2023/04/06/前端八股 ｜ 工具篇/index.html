

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端八股">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股 ｜ 工具篇">
<meta property="og:url" content="https://yoonalis.github.io/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20%E5%B7%A5%E5%85%B7%E7%AF%87/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="前端八股">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
<meta property="article:published_time" content="2023-04-06T13:32:15.961Z">
<meta property="article:modified_time" content="2023-04-11T01:41:11.888Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="计算">
<meta property="article:tag" content="工具">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>前端八股 ｜ 工具篇 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端八股 ｜ 工具篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-06 21:32" pubdate>
          2023年4月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          53k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          440 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端八股 ｜ 工具篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前端八股-｜-工具篇"><a href="#前端八股-｜-工具篇" class="headerlink" title="前端八股 ｜ 工具篇"></a>前端八股 ｜ 工具篇</h1><h2 id="1-vite和webpack区别"><a href="#1-vite和webpack区别" class="headerlink" title="1 vite和webpack区别"></a>1 vite和webpack区别</h2><p>最近的vite比较火，而且发布了2.0版本，vue的作者尤雨溪也是在极力推荐的</p>
<p>在之前的文章里面我提到过，vite的缺点在于目前的生态不够webpack成熟，但是只要能弥补这个缺点，便有很大概率能替代目前webpack的大部分市场</p>
<h3 id="全方位对比vite和webpack"><a href="#全方位对比vite和webpack" class="headerlink" title="全方位对比vite和webpack"></a>全方位对比vite和webpack</h3><h4 id="webpack打包过程"><a href="#webpack打包过程" class="headerlink" title="webpack打包过程"></a>webpack打包过程</h4><p>1.识别入口文件</p>
<p>2.通过逐层识别模块依赖。（Commonjs、amd或者es6的import，webpack都会对其进行分析。来获取代码的依赖）</p>
<p>3.webpack做的就是分析代码。转换代码，编译代码，输出代码</p>
<p>4.最终形成打包后的代码</p>
<h4 id="webpack打包原理"><a href="#webpack打包原理" class="headerlink" title="webpack打包原理"></a>webpack打包原理</h4><p>1.先逐级递归识别依赖，构建依赖图谱</p>
<p>2.将代码转化成AST抽象语法树</p>
<p>3.在AST阶段中去处理代码</p>
<p>4.把AST抽象语法树变成浏览器可以识别的代码， 然后输出</p>
<p>重点:这里需要递归识别依赖，构建依赖图谱。图谱对象就是类似下面这种</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123; &#x27;./app<span class="hljs-selector-class">.js</span>&#x27;:<br>   &#123; dependencies: &#123; &#x27;./test1<span class="hljs-selector-class">.js</span>&#x27;: <span class="hljs-string">&#x27;./test1.js&#x27;</span> &#125;,<br>     <span class="hljs-selector-tag">code</span>:<br>      <span class="hljs-string">&#x27;&quot;use strict&quot;;\n\nvar _test = _interopRequireDefault(require(&quot;./test1.js&quot;));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;\n\nconsole.log(test</span><br><span class="hljs-string">1);&#x27;</span> &#125;,<br>  &#x27;./test1<span class="hljs-selector-class">.js</span>&#x27;:<br>   &#123; dependencies: &#123; &#x27;./test2<span class="hljs-selector-class">.js</span>&#x27;: <span class="hljs-string">&#x27;./test2.js&#x27;</span> &#125;,<br>     <span class="hljs-selector-tag">code</span>:<br>      <span class="hljs-string">&#x27;&quot;use strict&quot;;\n\nvar _test = _interopRequireDefault(require(&quot;./test2.js&quot;));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;\n\nconsole.log(&#x27;</span>th<br>is is test1.js <span class="hljs-string">&#x27;, _test[&quot;default&quot;]);&#x27;</span> &#125;,<br>  &#x27;./test2<span class="hljs-selector-class">.js</span>&#x27;:<br>   &#123; dependencies: &#123;&#125;,<br>     <span class="hljs-selector-tag">code</span>:<br>      <span class="hljs-string">&#x27;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123;\n  value: true\n&#125;);\nexports[&quot;default&quot;] = void 0;\n\nfunction test2() &#123;\n  console.log(&#x27;</span>this is test2 <span class="hljs-string">&#x27;);\n&#125;\n\nvar _default = tes</span><br><span class="hljs-string">t2;\nexports[&quot;default&quot;] = _default;&#x27;</span> &#125; &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="vite原理"><a href="#vite原理" class="headerlink" title="vite原理"></a>vite原理</h3><p>当声明一个 script 标签类型为 module 时</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">浏览器就会像服务器发起一个<span class="hljs-variable constant_">GET</span><br><br><span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:3000/src/main.js请求main.js文件：</span><br> <br><span class="hljs-comment">// /src/main.js:</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br>浏览器请求到了main.<span class="hljs-property">js</span>文件，检测到内部含有<span class="hljs-keyword">import</span>引入的包，又会对其内部的 <span class="hljs-keyword">import</span> 引用发起 <span class="hljs-variable constant_">HTTP</span> 请求获取模块的内容文件<br><br>如：<span class="hljs-variable constant_">GET</span> <span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:3000/@modules/vue.js</span><br><br>如：<span class="hljs-variable constant_">GET</span> <span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:3000/src/App.vue</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>Vite 的主要功能就是通过劫持浏览器的这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器,Vite整个过程中没有对文件进行打包编译，所以其运行速度比原始的webpack开发编译速度快出许多！</p>
<h3 id="webpack缺点1-缓慢的服务器启动"><a href="#webpack缺点1-缓慢的服务器启动" class="headerlink" title="webpack缺点1.缓慢的服务器启动"></a>webpack缺点1.缓慢的服务器启动</h3><p>当冷启动开发服务器时，基于打包器的方式是在提供服务前去急切地抓取和构建你的整个应用。</p>
<h3 id="vite改进"><a href="#vite改进" class="headerlink" title="vite改进"></a>vite改进</h3><p>Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。依赖 大多为纯 JavaScript 并在开发时不会变动。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会以某些方式（例如 ESM 或者 CommonJS）被拆分到大量小模块中。Vite 将会使用 esbuild 预构建依赖。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p>
<p>源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载。（例如基于路由拆分的代码模块）。Vite 以 原生 ESM 方式服务源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。</p>
<h3 id="webpack缺点2-使用的是node-js去实现"><a href="#webpack缺点2-使用的是node-js去实现" class="headerlink" title="webpack缺点2.使用的是node.js去实现"></a>webpack缺点2.使用的是node.js去实现</h3><h3 id="vite改进-1"><a href="#vite改进-1" class="headerlink" title="vite改进"></a>vite改进</h3><p>Vite 将会使用 esbuild 预构建依赖。Esbuild 使用 Go 编写，并且比以 Node.js 编写的打包器预构建依赖快 10-100 倍。</p>
<h3 id="webpack致命缺点3-热更新效率低下"><a href="#webpack致命缺点3-热更新效率低下" class="headerlink" title="webpack致命缺点3.热更新效率低下"></a>webpack致命缺点3.热更新效率低下</h3><p>当基于打包器启动时，编辑文件后将重新构建文件本身。显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降。<br>一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[1]，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块 “热替换” 它自己，而对页面其余部分没有影响。这大大改进了开发体验 - 然而，在实践中我们发现，即使是 HMR 更新速度也会随着应用规模的增长而显著下降。</p>
<h3 id="vite改进-2"><a href="#vite改进-2" class="headerlink" title="vite改进"></a>vite改进</h3><p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失效（大多数时候只需要模块本身），使 HMR 更新始终快速，无论应用的大小。Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p>
<h3 id="vite缺点1"><a href="#vite缺点1" class="headerlink" title="vite缺点1"></a>vite缺点1</h3><p>1.生态，生态，生态不如webpack，wepback牛逼之处在于loader和plugin非常丰富,不过我认为生态只是时间问题，现在的vite,更像是当时刚出来的M1芯片Mac，我当时非常看好M1的Mac，毫不犹豫买了，现在也没什么问题</p>
<h3 id="vite缺点2"><a href="#vite缺点2" class="headerlink" title="vite缺点2"></a>vite缺点2</h3><p>1.prod环境的构建，目前用的Rollup，原因在于esbuild对于css和代码分割不是很友好</p>
<h3 id="vite缺点3"><a href="#vite缺点3" class="headerlink" title="vite缺点3"></a>vite缺点3</h3><p>1.还没有被大规模使用,很多问题或者诉求没有真正暴露出来，vite真正崛起那一天，是跟vue3有关系的,当vue3广泛开始使用在生产环境的时候，vite也就大概率意味着被大家慢慢开始接受了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vite，就像刚出来的M1芯片Mac,都说好，但是一开始买的人不多，担心生态问题，后面都说真香，相信vue3作者的大力支持下，vite即将大放异彩！我已经在我自己项目的生产环境中，开始使用vite!还是很好的生态。</p>
<h2 id="2-CommonJS-和-ES-Module-的区别"><a href="#2-CommonJS-和-ES-Module-的区别" class="headerlink" title="2 CommonJS 和 ES Module 的区别"></a>2 CommonJS 和 ES Module 的区别</h2><p>两者的主要区别如下：</p>
<ol>
<li>加载方式不同：CommonJS 使用 <code>require</code> 函数加载模块，而 ES Module 使用 <code>import</code> 语句加载模块。</li>
<li>导出方式不同：CommonJS 使用 <code>module.exports</code> 导出模块，而 ES Module 使用 <code>export</code> 关键字导出模块。</li>
<li>加载时机不同：CommonJS 是同步加载模块，而 ES Module 是异步加载模块。</li>
<li>变量绑定方式不同：CommonJS 是值拷贝，即加载模块时，会将模块中导出的值复制一份给变量。而 ES Module 是动态绑定，即导入变量与导出变量是实时绑定的，相当于建立了一个指针，指向导出变量。</li>
</ol>
<p>需要注意的是，虽然 CommonJS 和 ES Module 有一些差异，但是在现代开发中，两者可以互相转换。Node.js 也已经支持 ES Module，而浏览器端也可以使用打包工具将 ES Module 转换为 CommonJS 或 AMD 规范。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/4/170a35ca2f91c25e~tplv-t2oaga2asx-zoom-crop-mark:1512:1512:1512:851.image" srcset="/blog/img/loading.gif" lazyload alt="CommonJS 和 ES6 Module 究竟有什么区别？"></p>
<p>作为前端开发者，你是否也曾有过疑惑，为什么可以代码中可以直接使用 <code>require</code> 方法加载模块，为什么加载第三方包的时候 Node 会知道选择哪个文件作为入口，以及常被问到的，为什么 ES6 Module export 基础数据类型的时候会有【引用类型】的效果？</p>
<p>带着这些疑问和好奇，希望阅读这篇文章能解答你的疑惑。</p>
<h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><p>在 ES6 之前，ECMAScript 并没有提供代码组织的方式，那时候通常是基于 IIFE 来实现“模块化”，随着 JavaScript 在前端大规模的应用，以及服务端 Javascript 的推动，原先浏览器端的模块规范不利于大规模应用。于是早期便有了 <a href="https://link.juejin.cn/?target=http://www.commonjs.org/">CommonJS 规范</a>，其目标是为了定义模块，提供通用的模块组织方式。</p>
<h4 id="模块定义和使用"><a href="#模块定义和使用" class="headerlink" title="模块定义和使用"></a>模块定义和使用</h4><p>在 Commonjs 中，一个文件就是一个模块。定义一个模块导出通过 <code>exports</code> 或者 <code>module.exports</code> 挂载即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">count</span> = <span class="hljs-number">1</span>;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>导入一个模块也很简单，通过 <code>require</code> 对应模块拿到 <code>exports</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> counter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./counter&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">count</span>);<br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>CommonJS</code> 的模块主要由原生模块 <code>module</code> 来实现，这个类上的一些属性对我们理解模块机制有很大帮助。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Module</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-comment">// 如果是 mainModule id 固定为 &#x27;.&#x27;，如果不是则为模块绝对路径</span><br>  <span class="hljs-attr">exports</span>: &#123;&#125;, <span class="hljs-comment">// 模块最终 exports</span><br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;/absolute/path/to/entry.js&#x27;</span>, <span class="hljs-comment">// 当前模块的绝对路径</span><br>  <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 模块是否已加载完毕</span><br>  <span class="hljs-attr">children</span>: [], <span class="hljs-comment">// 被该模块引用的模块</span><br>  <span class="hljs-attr">parent</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 第一个引用该模块的模块</span><br>  <span class="hljs-attr">paths</span>: [ <span class="hljs-comment">// 模块的搜索路径</span><br>   <span class="hljs-string">&#x27;/absolute/path/to/node_modules&#x27;</span>,<br>   <span class="hljs-string">&#x27;/absolute/path/node_modules&#x27;</span>,<br>   <span class="hljs-string">&#x27;/absolute/node_modules&#x27;</span>,<br>   <span class="hljs-string">&#x27;/node_modules&#x27;</span><br>  ]<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="require-从哪里来？"><a href="#require-从哪里来？" class="headerlink" title="require 从哪里来？"></a>require 从哪里来？</h4><p>在编写 CommonJS 模块的时候，我们会使用 <code>require</code> 来加载模块，使用 <code>exports</code> 来做模块输出，还有 <code>module</code>，<code>__filename</code>, <code>__dirname</code> 这些变量，为什么它们不需要引入就能使用？</p>
<p>原因是 Node 在解析 JS 模块时，会先按文本读取内容，然后将模块内容进行包裹，在外层裹了一个 function，传入变量。再通过 <code>vm.runInThisContext</code> 将字符串转成 <code>Function</code>形成作用域，避免全局污染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> wrap = <span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Module</span>.<span class="hljs-property">wrapper</span>[<span class="hljs-number">0</span>] + script + <span class="hljs-title class_">Module</span>.<span class="hljs-property">wrapper</span>[<span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-keyword">const</span> wrapper = [<br>  <span class="hljs-string">&#x27;(function (exports, require, module, __filename, __dirname) &#123; &#x27;</span>,<br>  <span class="hljs-string">&#x27;\n&#125;);&#x27;</span><br>];<br>复制代码<br></code></pre></td></tr></table></figure>

<p>于是在 CommmonJS 的模块中可以不需要 require，直接访问到这些方法，变量。</p>
<p>参数中的 <code>module</code> 是当前模块的的 <code>module</code> 实例（尽管这个时候模块代码还没编译执行），<code>exports</code> 是 <code>module.exports</code> 的别名，最终被 <code>require</code> 的时候是输出 <code>module.exports</code> 的值。<code>require</code> 最终调用的也是 <code>Module._load</code> 方法。<code>__filename</code>，<code>__dirname</code> 则分别是当前模块在系统中的绝对路径和当前文件夹路径。</p>
<h4 id="模块的查找过程"><a href="#模块的查找过程" class="headerlink" title="模块的查找过程"></a>模块的查找过程</h4><p>开发者在使用 require 时非常简单，但实际上为了兼顾各种写法，不同类型的模块，<code>node_modules</code>packages 等模块的查找过程稍微有点麻烦。</p>
<p>首先，在创建模块对象时，会有 paths 属性，其值是由当前文件路径计算得到的，从当前目录一直到系统根目录的 <code>node_modules</code>。可以在模块中打印 <code>module.paths</code> 看看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[ <br>  <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/node_modules&#x27;</span>,<br>  <span class="hljs-string">&#x27;/Users/evan/Desktop/node_modules&#x27;</span>,<br>  <span class="hljs-string">&#x27;/Users/evan/node_modules&#x27;</span>,<br>  <span class="hljs-string">&#x27;/Users/node_modules&#x27;</span>,<br>  <span class="hljs-string">&#x27;/node_modules&#x27;</span><br>]<br>复制代码<br></code></pre></td></tr></table></figure>

<p>除此之外，还会查找全局路径（如果存在的话）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  execPath/../../lib/node_modules, <span class="hljs-comment">// 当前 node 执行文件相对路径下的 lib/node_modules</span><br>  <span class="hljs-variable constant_">NODE_PATH</span>, <span class="hljs-comment">// 全局变量 NODE_PATH</span><br>  <span class="hljs-variable constant_">HOME</span>/.<span class="hljs-property">node_modules</span>, <span class="hljs-comment">// HOME 目录下的 .node_module</span><br>  <span class="hljs-variable constant_">HOME</span>/.<span class="hljs-property">node_libraries</span><span class="hljs-string">&#x27; // HOME 目录下的 .node-libraries</span><br><span class="hljs-string">]</span><br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure>

<p>按照官方文档给出的<a href="https://link.juejin.cn/?target=https://nodejs.org/dist/latest-v12.x/docs/api/modules.html%23modules_all_together">查找过程</a>已经足够详细，这里只给出大概流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">从 Y 路径运行 <span class="hljs-built_in">require</span>(X)<br><br><span class="hljs-number">1.</span> 如果 X 是内置模块（比如 <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>）)<br>　　a. 返回该模块。<br>　　b. 不再继续执行。<br><br><span class="hljs-number">2.</span> 如果 X 是以 <span class="hljs-string">&#x27;/&#x27;</span> 开头、<br>   a. 设置 Y 为 <span class="hljs-string">&#x27;/&#x27;</span><br><br><span class="hljs-number">3.</span> 如果 X 是以 <span class="hljs-string">&#x27;./&#x27;</span> 或 <span class="hljs-string">&#x27;/&#x27;</span> 或 <span class="hljs-string">&#x27;../&#x27;</span> 开头<br>   a. 依次尝试加载文件，如果找到则不再执行<br>      - (Y + X)<br>      - (Y + X).<span class="hljs-property">js</span><br>      - (Y + X).<span class="hljs-property">json</span><br>      - (Y + X).<span class="hljs-property">node</span><br>   b. 依次尝试加载目录，如果找到则不再执行<br>      - (Y + X + package.<span class="hljs-property">json</span> 中的 main 字段).<span class="hljs-property">js</span><br>      - (Y + X + package.<span class="hljs-property">json</span> 中的 main 字段).<span class="hljs-property">json</span><br>      - (Y + X + package.<span class="hljs-property">json</span> 中的 main 字段).<span class="hljs-property">node</span><br>　　c. 抛出 <span class="hljs-string">&quot;not found&quot;</span><br><span class="hljs-number">4.</span> 遍历 <span class="hljs-variable language_">module</span> paths 查找，如果找到则不再执行<br><span class="hljs-number">5.</span> 抛出 <span class="hljs-string">&quot;not found&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>模块查找过程会将软链替换为系统中的真实路径，例如 <code>lib/foo/node_moduels/bar</code> 软链到 <code>lib/bar</code>，<code>bar</code> 包中又 <code>require(&#39;quux&#39;)</code>，最终运行 <code>foo</code> module 时，<code>require(&#39;quux&#39;)</code> 的查找路径是 <code>lib/bar/node_moduels/quux</code> 而不是 <code>lib/foo/node_moduels/quux</code>。</p>
<h4 id="模块加载相关"><a href="#模块加载相关" class="headerlink" title="模块加载相关"></a>模块加载相关</h4><h5 id="MainModule"><a href="#MainModule" class="headerlink" title="MainModule"></a>MainModule</h5><p>当运行 <code>node index.js</code> 时，Node 调用 Module 类上的静态方法 <code>_load(process.argv[1])</code> 加载这个模块，并标记为主模块，赋值给 <code>process.mainModule</code> 和 <code>require.main</code>，可以通过这两个字段判断当前模块是主模块还是被 <code>require</code> 进来的。</p>
<p><code>CommonJS</code> 规范是在代码运行时同步阻塞性地加载模块，在执行代码过程中遇到 <code>require(X)</code> 时会停下来等待，直到新的模块加载完成之后再继续执行接下去的代码。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/4/170a357e95d4d82b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>虽说是同步阻塞性，但这一步实际上非常快，和浏览器上阻塞性下载、解析、执行 <code>js</code> 文件不是一个级别，硬盘上读文件比网络请求快得多。</p>
<h5 id="缓存和循环引用"><a href="#缓存和循环引用" class="headerlink" title="缓存和循环引用"></a>缓存和循环引用</h5><p>文件模块查找挺耗时的，如果每次 require 都需要重新遍历文件夹查找，性能会比较差；还有在实际开发中，模块可能包含<strong>副作用</strong>代码，例如在模块顶层执行 <code>addEventListener</code> ，如果 require 过程中被重复执行多次可能会出现问题。</p>
<p><code>CommonJS</code> 中的缓存可以解决重复查找和重复执行的问题。模块加载过程中会以模块绝对路径为 <code>key</code>, <code>module</code> 对象为 <code>value</code> 写入 <code>cache</code>。在读取模块的时候会优先判断是否已在缓存中，如果在，直接返回 <code>module.exports</code>；如果不在，则会进入模块查找的流程，找到模块之后再写入 <code>cache</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>&#125;;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> a1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br>a1.<span class="hljs-property">foo</span> = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">const</span> a2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2.<span class="hljs-property">foo</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1 === a2); <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>以上例子中，<code>require a.js</code> 并修改其中的 <code>foo</code> 属性，接着再次 <code>require a.js</code> 可以看到两次 <code>require</code> 结果是一样的。</p>
<p>模块缓存可以打印 <code>require.cache</code> 进行查看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <br>    <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/main.js&#x27;</span>: <br>       <span class="hljs-title class_">Module</span> &#123;<br>         <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;.&#x27;</span>,<br>         <span class="hljs-attr">exports</span>: &#123;&#125;,<br>         <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br>         <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/main.js&#x27;</span>,<br>         <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>,<br>         <span class="hljs-attr">children</span>: [ [<span class="hljs-title class_">Object</span>] ],<br>         <span class="hljs-attr">paths</span>: <br>          [ <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/Users/evan/Desktop/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/Users/evan/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/Users/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/node_modules&#x27;</span><br>          ]<br>       &#125;,<br>  <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/a.js&#x27;</span>: <br>       <span class="hljs-title class_">Module</span> &#123;<br>         <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/a.js&#x27;</span>,<br>         <span class="hljs-attr">exports</span>: &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;,<br>         <span class="hljs-attr">parent</span>: <br>          <span class="hljs-title class_">Module</span> &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;.&#x27;</span>,<br>            <span class="hljs-attr">exports</span>: &#123;&#125;,<br>            <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/main.js&#x27;</span>,<br>            <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">children</span>: [<span class="hljs-title class_">Array</span>],<br>            <span class="hljs-attr">paths</span>: [<span class="hljs-title class_">Array</span>] &#125;,<br>         <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/a.js&#x27;</span>,<br>         <span class="hljs-attr">loaded</span>: <span class="hljs-literal">true</span>,<br>         <span class="hljs-attr">children</span>: [],<br>         <span class="hljs-attr">paths</span>: <br>          [ <span class="hljs-string">&#x27;/Users/evan/Desktop/demo/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/Users/evan/Desktop/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/Users/evan/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/Users/node_modules&#x27;</span>,<br>            <span class="hljs-string">&#x27;/node_modules&#x27;</span> ] &#125; &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>缓存还解决了循环引用的问题。举个例子，现在有模块 a require 模块 b；而模块 b 又 require 了模块 a。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in main, a.a1 = %j, a.a2 = %j&#x27;</span>, a.<span class="hljs-property">a1</span>, a.<span class="hljs-property">a2</span>);<br><br><span class="hljs-comment">// a.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">a1</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in a, b.done = %j&#x27;</span>, b.<span class="hljs-property">done</span>);<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">a2</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in b, a.a1 = %j, a.a2 = %j&#x27;</span>, a.<span class="hljs-property">a1</span>, a.<span class="hljs-property">a2</span>);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">in</span> b, a.<span class="hljs-property">a1</span> = <span class="hljs-literal">true</span>, a.<span class="hljs-property">a2</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">in</span> main, a.<span class="hljs-property">a1</span> = <span class="hljs-literal">true</span>, a.<span class="hljs-property">a2</span> = <span class="hljs-literal">true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>实际上在模块 a 代码执行之前就已经创建了 Module 实例写入了缓存，此时代码还没执行，exports 是个<a href="https://link.juejin.cn/?target=https://github.com/nodejs/node/blob/9085c03806dbc9eb48e14c2afa49080deee0ee3c/lib/internal/modules/cjs/loader.js%23L154">空对象</a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;/Users/evan/Desktop/module/a.js&#x27;</span>: <br>   <span class="hljs-title class_">Module</span> &#123;<br>     <span class="hljs-attr">exports</span>: &#123;&#125;,<br>     <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>代码 <code>exports.a1 = true;</code> 修改了 <code>module.exports</code> 上的 <code>a1</code> 为 <code>true</code>, 这时候 <code>a2</code> 代码还没执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;/Users/evan/Desktop/module/a.js&#x27;</span>: <br>   <span class="hljs-title class_">Module</span> &#123;<br>     <span class="hljs-attr">exports</span>: &#123;<br>      <span class="hljs-attr">a1</span>: <span class="hljs-literal">true</span><br>    &#125;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>进入 <code>b</code> 模块，<code>require a.js</code> 时发现缓存上已经存在了，获取 <code>a</code> 模块上的 <code>exports</code> 。打印 <code>a1, a2</code>分别是 <code>true</code>，和 <code>undefined</code>。</p>
<p>运行完 <code>b</code> 模块，继续执行 <code>a</code> 模块剩余的代码，<code>exports.a2 = true;</code> 又往 <code>exports</code> 对象上增加了 <code>a2</code> 属性，此时 <code>module a</code> 的 <code>export</code> 对象 <code>a1, a2</code> 均为 <code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">exports</span>: &#123; <br>  <span class="hljs-attr">a1</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">a2</span>: <span class="hljs-literal">true</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>再回到 <code>main</code> 模块，由于 <code>require(&#39;./a.js&#39;)</code> 得到的是 <code>module a</code> <code>export</code> 对象的引用，这时候打印 <code>a1, a2</code> 就都为 <code>true</code>。</p>
<p><strong>小结：</strong></p>
<p><code>CommonJS</code> 模块加载过程是同步阻塞性地加载，在模块代码被运行前就已经写入了 <code>cache</code>，同一个模块被多次 <code>require</code> 时只会执行一次，重复的 <code>require</code> 得到的是相同的 <code>exports</code> 引用。</p>
<p><strong>值得留意：</strong> <code>cache key</code> 使用的是模块在系统中的绝对位置，由于<strong>模块调用位置的不同</strong>，相同的 <code>require(&#39;foo&#39;)</code> 代码并不能保证返回的是统一个对象引用。我之前恰巧就遇到过，<a href="https://link.juejin.cn/?target=https://github.com/eggjs/egg/issues/3591%23issuecomment-503515164">两次 require(‘egg-core’) 但是他们并不相等</a>。</p>
<h3 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h3><p><code>ES6</code> 模块是前端开发同学更为熟悉的方式，使用 <code>import</code>, <code>export</code> 关键字来进行模块输入输出。<code>ES6</code>不再是使用闭包和函数封装的方式进行模块化，而是从语法层面提供了模块化的功能。</p>
<p><code>ES6</code> 模块中不存在 <code>require</code>, <code>module.exports</code>, <code>__filename</code> 等变量，<code>CommonJS</code> 中也不能使用 <code>import</code>。两种规范是不兼容的，一般来说平日里写的 <code>ES6</code> 模块代码最终都会经由 <code>Babel</code>, <code>Typescript</code>等工具处理成 <code>CommonJS</code> 代码。</p>
<p>使用 <code>Node</code> 原生 <code>ES6</code> 模块需要将 <code>js</code> 文件后缀改成 <code>mjs</code>，或者 <code>package.json</code> “type” 字段改为 “module”，通过这种形式告知 <code>Node</code> 使用 <code>ES Module</code> 的形式加载模块。</p>
<h4 id="ES6-模块-加载过程"><a href="#ES6-模块-加载过程" class="headerlink" title="ES6 模块 加载过程"></a>ES6 模块 加载过程</h4><p>ES6 模块的加载过程分为三步：</p>
<h5 id="1-查找，下载，解析，构建所有模块实例。"><a href="#1-查找，下载，解析，构建所有模块实例。" class="headerlink" title="1. 查找，下载，解析，构建所有模块实例。"></a>1. 查找，下载，解析，构建所有模块实例。</h5><p>ES6 模块会在程序开始前先根据模块关系查找到所有模块，生成一个无环关系图，并将所有模块实例都创建好，这种方式天然地避免了循环引用的问题，当然也有模块加载缓存，重复 import 同一个模块，只会执行一次代码。</p>
<h5 id="2-在内存中腾出空间给即将-export-的内容（此时尚未写入-export-value）。然后使-import-和-export-指向内存中的这些空间，这个过程也叫连接。"><a href="#2-在内存中腾出空间给即将-export-的内容（此时尚未写入-export-value）。然后使-import-和-export-指向内存中的这些空间，这个过程也叫连接。" class="headerlink" title="2. 在内存中腾出空间给即将 export 的内容（此时尚未写入 export value）。然后使 import 和 export 指向内存中的这些空间，这个过程也叫连接。"></a>2. 在内存中腾出空间给即将 export 的内容（此时尚未写入 export value）。然后使 import 和 export 指向内存中的这些空间，这个过程也叫连接。</h5><p>这一步完成的工作是 <code>living binding import export</code>，借助下面的例子来帮助理解。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// counter.js</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span> () &#123;<br>  count++;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  count,<br>  increment<br>&#125;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> counter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;counter.cjs&#x27;</span>);<br><br>counter.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">count</span>); <span class="hljs-comment">// 1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上面 <code>CommonJS</code> 的例子执行结果很好理解，修改 <code>count++</code> 修改的是模块内的基础数据类型变量，不会改变 <code>exports.count</code>，所以打印结果认为 <code>1</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// counter.mjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span> () &#123;<br>  count++;<br>&#125;<br><br><span class="hljs-comment">// main.mjs</span><br><span class="hljs-keyword">import</span> &#123; increment, count &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter.mjs&#x27;</span><br><br><span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 2</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>从结果上看使用 <code>ES6</code> 模块的写法，当 <code>export</code> 的变量被修改时，会影响 <code>import</code> 的结果。这个功能的实现就是 <code>living binding</code>，具体规范底层如何实现可以暂时不管，但是知道 <code>living binding</code> 比网上文章描述为 “ES6 模块输出的是值的引用” 更好理解。</p>
<p>更接近 <code>ES6</code> 模块的 <code>CommonJS</code> 代码可以是下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">counter</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">increment</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">counter</span>++;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h5 id="3-运行模块代码将变量的实际值填写在第二步生成的空间中。"><a href="#3-运行模块代码将变量的实际值填写在第二步生成的空间中。" class="headerlink" title="3. 运行模块代码将变量的实际值填写在第二步生成的空间中。"></a>3. 运行模块代码将变量的实际值填写在第二步生成的空间中。</h5><p>到第三步，会基于第一步生成的无环图进行深度优先后遍历填值，如果这个过程中访问了尚未初始化完成的空间，会抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.mjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a1 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.mjs&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a2 = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// b.mjs</span><br><span class="hljs-keyword">import</span> &#123; a1, a2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.mjs&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1, a2);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上面的例子会在运行时抛出异常 <code>ReferenceError: Cannot access &#39;a1&#39; before initialization</code>。如果改成 <code>import * as a from &#39;a.mjs&#39;</code> 可以看到 <code>a</code> 模块中 <code>export</code> 的对象已经占好坑了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// b.mjs</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.mjs&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>将输出 <code>&#123; a1: &lt;uninitialized&gt;, a2: &lt;uninitialized&gt; &#125;</code> 可以看出，ES6 模块为 export 的变量预留了空间，不过尚未赋值。这里和 <code>CommonJS</code> 不一样，<code>CommonJS</code> 到这里是知道 <code>a1</code> 为 <code>true</code>, <code>a2</code> 为 <code>undefined</code></p>
<p>除此之外，我们还能推导出一些 ES6 模块和 <code>CommonJS</code> 的差异点：</p>
<ul>
<li><code>CommonJS</code> 可以在运行时使用变量进行 require, 例如 <code>require(path.join(&#39;xxxx&#39;, &#39;xxx.js&#39;))</code>，而静态 <code>import</code> 语法（还有<code>动态 import</code>，返回 <code>Promise</code>）不行，因为 ES6 模块会先解析所有模块再执行代码。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/4/170a358647bac4ac~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><code>require</code> 会将完整的 <code>exports</code> 对象引入，<code>import</code> 可以只 <code>import</code> 部分必要的内容，这也是为什么使用 <code>Tree Shaking</code> 时必须使用 ES6 模块 的写法。</li>
<li><code>import</code> 另一个模块没有 <code>export</code> 的变量，在代码执行前就会报错，而 <code>CommonJS</code> 是在模块运行时才报错。</li>
</ul>
<h4 id="为什么平时开发可以混写？"><a href="#为什么平时开发可以混写？" class="headerlink" title="为什么平时开发可以混写？"></a>为什么平时开发可以混写？</h4><p>前面提到 <code>ES6</code> 模块和 <code>CommonJS</code> 模块有很大差异，不能直接混着写。这和开发中表现是不一样的，原因是开发中写的 ES6 模块最终都会被打包工具处理成 <code>CommonJS</code> 模块，以便兼容更多环境，同时也能和当前社区普通的 <code>CommonJS</code> 模块融合。</p>
<p>在转换的过程中会产生一些困惑，比如说：</p>
<h4 id="esModule-是什么？干嘛用的？"><a href="#esModule-是什么？干嘛用的？" class="headerlink" title="__esModule 是什么？干嘛用的？"></a><code>__esModule</code> 是什么？干嘛用的？</h4><p>使用转换工具处理 ES6 模块的时候，常看到打包之后出现 <code>__esModule</code> 属性，字面意思就是将其标记为 <code>ES6 Module</code>。这个变量存在的作用是为了方便在引用模块的时候加以处理。</p>
<p>例如 ES6 模块中的 <code>export default</code> 在转化成 <code>CommonJS</code> 时会被挂载到 <code>exports[&#39;default&#39;]</code> 上，当运行 <code>require(&#39;./a.js&#39;)</code> 时 是不能直接读取到 <code>default</code> 上的值的，为了和 ES6 中 <code>import a from &#39;./a.js&#39;</code> 的行为一致，会基于 <code>__esModule</code> 判断处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>转化后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">default</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> _a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br><br><span class="hljs-keyword">var</span> _a2 = <span class="hljs-title function_">_interopRequireDefault</span>(_a);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) &#123; <span class="hljs-keyword">return</span> obj &amp;&amp; obj.<span class="hljs-property">__esModule</span> ? obj : &#123; <span class="hljs-attr">default</span>: obj &#125;; &#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_a2.<span class="hljs-property">default</span>);<br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>a</code> 模块 <code>export defualt</code> 会被转换成 <code>exports.default = 1;</code>，这也是平时前端项目开发中使用 <code>require</code> 为什么还常常需要 <code>.default</code> 才能取到目标值的原因。</p>
<p>接着当运行 <code>import a from &#39;./a.js&#39;</code> 时，<code>es module</code> 预期的是返回 <code>export</code> 的内容。工具会将代码转换为 <code>_interopRequireDefault</code> 包裹，在里面判断是否为 <code>esModule</code>，是的话直接返回，如果是 <code>commonjs</code> 模块的话则包裹一层 <code>&#123;default: obj&#125;</code>，最后获取 a 的值时，也会被装换成 <code>_a1.default</code>。</p>
<h2 id="3-iframe"><a href="#3-iframe" class="headerlink" title="3 iframe"></a>3 iframe</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近几年微前端很火，火到有时候项目里面用到了iframe还要偷偷摸摸地藏起来生怕被别人知道了，因为担心被人质疑：你为什么不用微前端方案？直到最近笔者接手一个项目，需要将现有的一个系统整体嵌入到另外一个系统（一共20多个页面），在被微前端坑了几次之后，回过头发现，iframe真香！</p>
<p>qiankun的作者有一篇<a href="https://link.juejin.cn/?target=https://www.yuque.com/kuitos/gky7yw/gesexv?spm=ata.21736010.0.0.25c06df01VID5V">《Why Not Iframe》</a> 介绍了iframe的优缺点（不过作者还有一篇<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/391248835">《你可能并不需要微前端》</a>给微前端降降火），诚然iframe确实存在很多缺点，但是在选择一个方案的时候还是要具体场景具体分析，它可能在当下很流行，但它不一定在任何时候都是最优解：iframe的这些缺点对我来说是否能够接受？它的缺点是否有其它方法可以弥补？使用它到底是利大于弊还是弊大于利？我们需要在优缺点之间找到一个平衡。</p>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ba7b4fe292438c9f84f8d095b032a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="iframe适合的场景"><a href="#iframe适合的场景" class="headerlink" title="iframe适合的场景"></a>iframe适合的场景</h3><p>由于iframe的一些限制，部分场景并不适合用iframe，比如像下面这种iframe只占据页面中间部分区域，由于父页面已经有一个滚动条了，为了避免出现双滚动条，只能动态计算iframe的内容高度赋值给iframe，使得iframe高度完全撑满，但这样带来的问题是弹窗很难处理，如果居中的话一般弹窗都相对的是iframe内容高度而不是屏幕高度，从而导致弹窗可能看不见，如果固定弹窗top又会导致弹窗跟随页面滚动，而且稍有不慎iframe内容高度计算有一点点偏差就会出现双滚动条。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7744c2ded9794f58bb3e9fde13f4c90c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>所以：</p>
<ul>
<li>如果页面本身比较简单，是一个没有弹窗、浮层、高度也是固定的纯信息展示页的话，用iframe一般没什么问题；</li>
<li>如果页面是包含弹窗、信息提示、或者高度不是固定的话，需要看<strong>iframe是否占据了全部的内容区域</strong>，如果是像下图这种经典的导航+菜单+内容结构、并且整个内容区域都是iframe，那么可以放心大胆地尝试iframe，否则，需要慎重考虑方案选型。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/117cf442197848b9a39a9338917a2c0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>为什么一定要满足“iframe占据全部内容区域”这个条件呢？可以想象一下下面这种场景，滚动条出现在页面中间应该大部分人都无法接受：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe05936603d64af49474f44cb8bb6f51~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="实战：A系统接入B系统"><a href="#实战：A系统接入B系统" class="headerlink" title="实战：A系统接入B系统"></a>实战：A系统接入B系统</h3><p>满足“iframe占据全部内容区域”条件的场景，iframe的几个缺点都比较好解决。下面通过一个实际案例来详细介绍将一个线上在运行的系统接入到另外一个系统的全过程。以笔者前段时间刚完成的ACP（全称Alibaba.com Pay，阿里巴巴国际站旗下一站式全球收款平台，下称A系统）接入生意贷（下称B系统）为例，已知：</p>
<ul>
<li>ACP和生意贷都是MPA页面；</li>
<li>ACP系统在此之前没有接入其他系统的先例，生意贷是第一个；</li>
<li>生意贷作为被接入系统，本次需要接入的一共有20多个页面，且服务端包含大量业务逻辑以及跳转控制，有些页面想看看长什么样子都非常困难，需要在Node层mock大量接口；</li>
<li>接入时需要做功能删减，部分接口入参需要调整；</li>
<li>生意贷除了接入到ACP系统中，之前还接入过AMES系统，本次接入需要兼容这部分历史逻辑；</li>
</ul>
<p>我们希望的效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb51daa3fdf44218567982b65ac5517~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>假设我们新增一个页面 <code>/fin/base.html?entry=xxx </code>作为我们A系统承接B系统的地址，A系统有类似如下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    state = &#123;<br>        currentEntry: decodeURIComponent(iutil.getParam(&#x27;entry&#x27;) || &#x27;&#x27;) || &#x27;&#x27;,<br>    &#125;;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> &lt;div&gt;<br>            &lt;iframe id=<span class="hljs-string">&quot;microFrontIframe&quot;</span> src=&#123;<span class="hljs-keyword">this</span>.state.currentEntry&#125;/&gt;<br>        &lt;/div&gt;;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="隐藏原系统导航菜单"><a href="#隐藏原系统导航菜单" class="headerlink" title="隐藏原系统导航菜单"></a>隐藏原系统导航菜单</h4><p>因为是接入到另外一个系统，所以需要将原系统的菜单和导航等都通过一个类似“hideLayout”的参数去隐藏。</p>
<h4 id="前进后退处理"><a href="#前进后退处理" class="headerlink" title="前进后退处理"></a>前进后退处理</h4><p>需要特别注意的是，iframe页面内部的跳转虽然不会让浏览器地址栏发生变化，但是却会产生一个看不见的“history记录”，也就是点击前进或后退按钮（<code>history.forward()</code>或<code>history.back()</code>）可以让iframe页面也前进后退，但是地址栏无任何变化。</p>
<p>所以准确来说前进后退无需我们做任何处理，我们要做的就是让浏览器地址栏同步更新即可。</p>
<blockquote>
<p>如果要禁用浏览器的上述默认行为，一般只能在iframe跳转时通知父页面更新整个<code>&lt;iframe /&gt;DOM</code>节点。</p>
</blockquote>
<h4 id="URL的同步更新"><a href="#URL的同步更新" class="headerlink" title="URL的同步更新"></a>URL的同步更新</h4><p>让URL同步更新需要处理2个问题，一个是什么时候去触发更新的动作，一个是URL更新的规律，即父页面的URL地址（A系统）与iframe的URL地址（B系统）映射关系的维护。</p>
<p>保证URL同步更新功能正常需要满足这3种情况：</p>
<ul>
<li>case1: 页面刷新，iframe能够加载正确页面；</li>
<li>case2: 页面跳转，浏览器地址栏能够正确更新；</li>
<li>case3: 点击浏览器的前进或后退，地址栏和iframe都能够同步变化；</li>
</ul>
<h3 id="什么时候更新URL地址"><a href="#什么时候更新URL地址" class="headerlink" title="什么时候更新URL地址"></a>什么时候更新URL地址</h3><p>首先想到的肯定是在iframe加载完发送一个通知给父页面，父页面通过<code>history.replaceState</code>去更新URL。</p>
<blockquote>
<p>为什么不是<code>history.pushState</code>呢？因为前面提到过，浏览器默认会产生一条历史记录，我们只需要更新地址即可，如果用pushState会产生2条记录。</p>
</blockquote>
<p>B系统：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> postMessage = <span class="hljs-keyword">function</span>(<span class="hljs-params">type, data</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span> !== <span class="hljs-variable language_">window</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: type,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: data,</span><br><span class="language-javascript">        &#125;, <span class="hljs-string">&#x27;*&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-comment">// 为了让URL地址尽早地更新，这段代码需要尽可能前置，例如可以直接放在document.head中</span></span><br><span class="language-javascript"><span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;afterHistoryChange&#x27;</span>, &#123; <span class="hljs-attr">url</span>: location.<span class="hljs-property">href</span> &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>A系统：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; data, <span class="hljs-keyword">type</span> &#125; = e.<span class="hljs-property">data</span> || &#123;&#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;afterHistoryChange&#x27;</span> &amp;&amp; data?.<span class="hljs-property">url</span>) &#123;<br>        <span class="hljs-comment">// 这里先采用一个兜底的URL承接任意地址</span><br>        <span class="hljs-keyword">const</span> entry = <span class="hljs-string">`/fin/base.html?entry=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data.url)&#125;</span>`</span>;<br>        <span class="hljs-comment">// 地址不一样才需要更新</span><br>        <span class="hljs-keyword">if</span> (location.<span class="hljs-property">pathname</span> + location.<span class="hljs-property">search</span> !== entry) &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, entry);<br>        &#125;<br>    &#125;<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="优化URL的更新速度"><a href="#优化URL的更新速度" class="headerlink" title="优化URL的更新速度"></a>优化URL的更新速度</h3><p>按照上面的方法实现后可以发现，URL虽然可以更新但是速度有点慢，点击跳转后一般需要等待7-800毫秒地址栏才会更新，有点美中不足。可以把地址栏的更新在“跳转后”基础之上再加一个“跳转前”。为此我们必须有一个全局的beforeRedirect钩子，先不考虑它的具体实现：</p>
<p>B系统：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beforeRedirect</span>(<span class="hljs-params">href</span>) </span>&#123;<br>    <span class="hljs-title function_ invoke__">postMessage</span>(<span class="hljs-string">&#x27;beforeHistoryChange&#x27;</span>, &#123; <span class="hljs-attr">url</span>: href &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>A系统：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; data, <span class="hljs-keyword">type</span> &#125; = e.<span class="hljs-property">data</span> || &#123;&#125;;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;beforeHistoryChange&#x27;</span> || <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;afterHistoryChange&#x27;</span>) &amp;&amp; data?.<span class="hljs-property">url</span>) &#123;<br>        <span class="hljs-comment">// 这里先采用一个兜底的URL承接任意地址</span><br>        <span class="hljs-keyword">const</span> entry = <span class="hljs-string">`/fin/base.html?entry=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data.url)&#125;</span>`</span>;<br>        <span class="hljs-comment">// 地址不一样才需要更新</span><br>        <span class="hljs-keyword">if</span> (location.<span class="hljs-property">pathname</span> + location.<span class="hljs-property">search</span> !== entry) &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, entry);<br>        &#125;<br>    &#125;<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>加上上述代码之后，点击iframe中的跳转链接，URL会实时更新，浏览器的前进后退功能也正常。</p>
<blockquote>
<p>为什么需要同时保留跳转前和跳转后呢？因为如果只保留跳转前，只能满足前面的case1和case2，case3无法满足，也就是点击后退按钮只有iframe会后退，URL地址不会更新。</p>
</blockquote>
<h3 id="美化URL地址"><a href="#美化URL地址" class="headerlink" title="美化URL地址"></a>美化URL地址</h3><p>简单的使用<code>/fin/base.html?entry=xxx</code>这样的通用地址虽然能用，但是不太美观，而且很容易被人看出来是iframe实现的，比较没有诚意，所以如果被接入系统的页面数量在可枚举范围内，建议给每个地址维护一个新的短地址。</p>
<p>首先，新增一个SPA页面<code>/fin/*.html</code>，和前面的<code>/fin/base.html</code>指向同一个页面，然后维护一个URL地址的映射，类似这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// A系统地址到B系统地址映射</span><br><span class="hljs-keyword">const</span> entryMap = &#123;<br>    <span class="hljs-string">&#x27;/fin/home.html&#x27;</span>: <span class="hljs-string">&#x27;https://fs.alibaba.com/xxx/home.htm?hideLayout=1&#x27;</span>,<br>    <span class="hljs-string">&#x27;/fin/apply.html&#x27;</span>: <span class="hljs-string">&#x27;https://fs.alibaba.com/xxx/apply?hideLayout=1&#x27;</span>,<br>    <span class="hljs-string">&#x27;/fin/failed.html&#x27;</span>: <span class="hljs-string">&#x27;https://fs.aibaba.com/xxx/failed?hideLayout=1&#x27;</span>,<br>    <span class="hljs-comment">// 省略</span><br>&#125;;<br><span class="hljs-keyword">const</span> iframeMap = &#123;&#125;; <span class="hljs-comment">// 同时再维护一个子页面 -&gt; 父页面URL映射</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">in</span> entryMap) &#123;<br>    iframeMap[entryMap[entry].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">0</span>]] = entry;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">currentEntry</span>: <span class="hljs-built_in">decodeURIComponent</span>(iutil.<span class="hljs-title function_">getParam</span>(<span class="hljs-string">&#x27;entry&#x27;</span>) || <span class="hljs-string">&#x27;&#x27;</span>) || entryMap[location.<span class="hljs-property">pathname</span>] || <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;microFrontIframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;this.state.currentEntry&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>同时完善一下更新URL地址部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// base.html继续用作兜底</span><br><span class="hljs-keyword">let</span> entry = <span class="hljs-string">`/fin/base.html?entry=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data.url)&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> [path, search] = data.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>);<br><span class="hljs-keyword">if</span> (iframeMap[path]) &#123;<br>    entry = <span class="hljs-string">`<span class="hljs-subst">$&#123;iframeMap[path]&#125;</span>?<span class="hljs-subst">$&#123;search || <span class="hljs-string">&#x27;&#x27;</span>&#125;</span>`</span>;<br>&#125;<br><span class="hljs-comment">// 地址不一样才需要更新</span><br><span class="hljs-keyword">if</span> (location.<span class="hljs-property">pathname</span> + location.<span class="hljs-property">search</span> !== entry) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, entry);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>省略参数透传部分代码。</p>
</blockquote>
<h3 id="全局跳转拦截"><a href="#全局跳转拦截" class="headerlink" title="全局跳转拦截"></a>全局跳转拦截</h3><p>为什么一定要做全局跳转拦截呢？一个因为我们需要把hideLayout参数一直透传下去，否则就会点着点着突然出现下面这种双菜单的情况：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/110b0f09df6e4f559ff36540fd89f385~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>另一个是有些页面在被嵌入前是当前页面打开的，但是被嵌入后不能继续在当前iframe打开，比如支付宝付款这种第三方页面，想象一下下面这种情况会不会觉得很怪？所以这类页面一定要做特殊处理让它跳出去而不是当前页面打开。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/063c839ca02f452aa7ff77098edba2a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>URL跳转可以分为服务端跳转和浏览器跳转，浏览器跳转又包括A标签跳转、location.href跳转、window.open跳转、historyAPI跳转等；</p>
<p>而根据是否新标签打开又可以分为以下4种场景：</p>
<ol>
<li>继续当前iframe打开，需要隐藏原系统的所有layout；</li>
<li>当前父页面打开第三方页面，不需要任何layout；</li>
<li>新开标签打开第三方页面（如支付宝页面），不需要做特殊处理；</li>
<li>新开标签打开宿主页面，需要把原系统layout替换成新layout；</li>
</ol>
<p>为此，先定义好一个<code>beforeRedirect</code>方法，由于新标签打开有<code>target=&quot;_blank&quot;</code>和<code>window.open</code>等方式，父页面打开有<code>target=&quot;_parent&quot;</code>和<code>window.parent.location.href</code>等方式，为了更好的统一封装，我们把特殊情况的跳转统一在<code>beforeRedirect</code>处理好，并约定只有有返回值的情况才需要后续继续处理跳转：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 维护一个需要做特殊处理的第三方页面列表<br>const <span class="hljs-attr">thirdPageList</span> = [<br>    <span class="hljs-string">&#x27;https://service.alibaba.com/&#x27;</span>,<br>    <span class="hljs-string">&#x27;https://sale.alibaba.com/xxx/&#x27;</span>,<br>    <span class="hljs-string">&#x27;https://alipay.com/xxx/&#x27;</span>,<br>    // ...<br>]<span class="hljs-comment">;</span><br>/**<br> * 封装统一的跳转拦截钩子，处理参数透传和一些特殊情况<br> * @param &#123;*&#125; href 要跳转的地址，允许传入相对路径<br> * @param &#123;*&#125; isNewTab 是否要新标签打开<br> * @param &#123;*&#125; isParentOpen 是否要在父页面打开<br> * @returns 返回处理好的跳转地址，如果没有返回值则表示不需要继续处理跳转<br> */<br>function beforeRedirect(href, isNewTab) &#123;<br>    if (!href) &#123;<br>        return<span class="hljs-comment">;</span><br>    &#125;<br>    // 传过来的href可能是相对路径，为了做统一判断需要转成绝对路径<br>    if (href.indexOf(&#x27;http&#x27;) !== 0) &#123;<br>        var <span class="hljs-attr">a</span> = document.createElement(<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">;</span><br>        <span class="hljs-attr">a.href</span> = href<span class="hljs-comment">;</span><br>        <span class="hljs-attr">href</span> = a.href<span class="hljs-comment">;</span><br>    &#125;<br>    // 如果命中白名单<br>    if (thirdPageList.some(<span class="hljs-attr">item</span> =&gt; href.indexOf(item) === <span class="hljs-number">0</span>)) &#123;<br>        if (isNewTab) &#123;<br>            // _rawOpen参见后面 window.open 拦截<br>            window._rawOpen(href)<span class="hljs-comment">;</span><br>        &#125; else &#123;<br>            // 第三方页面如果不是新标签打开就一定是父页面打开<br>            <span class="hljs-attr">window.parent.location.href</span> = href<span class="hljs-comment">;</span><br>        &#125;<br>        return<span class="hljs-comment">;</span><br>    &#125;<br>    // 需要从当前URL继续往下透传的参数<br>    var <span class="hljs-attr">params</span> = [<span class="hljs-string">&#x27;hideLayout&#x27;</span>, <span class="hljs-string">&#x27;tracelog&#x27;</span>]<span class="hljs-comment">;</span><br>    for (var <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; params.length; i++) &#123;</span><br>        var <span class="hljs-attr">value</span> = getParam(params[i], location.href)<span class="hljs-comment">;</span><br>        if (value) &#123;<br>            <span class="hljs-attr">href</span> = setParam(params[i], value, href)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    if (isNewTab) &#123;<br>        let <span class="hljs-attr">entry</span> = `/fin/base.html?entry=<span class="hljs-variable">$&#123;encodeURIComponent(href)&#125;</span>`<span class="hljs-comment">;</span><br>        const <span class="hljs-section">[path, search]</span> = href.split(&#x27;?&#x27;)<span class="hljs-comment">;</span><br>        if (iframeMap<span class="hljs-section">[path]</span>) &#123;<br>            <span class="hljs-attr">entry</span> = `<span class="hljs-variable">$&#123;iframeMap[path]&#125;</span>?<span class="hljs-variable">$&#123;search || &#x27;&#x27;&#125;</span>`<span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-attr">href</span> = `https://payment.alibaba.com<span class="hljs-variable">$&#123;entry&#125;</span>`<span class="hljs-comment">;</span><br>        window._rawOpen(href)<span class="hljs-comment">;</span><br>        return<span class="hljs-comment">;</span><br>    &#125;<br>    // 如果是以iframe方式嵌入，向父页面发送通知<br>    postMessage(&#x27;beforeHistoryChange&#x27;, &#123; url: href &#125;)<span class="hljs-comment">;</span><br>    return href<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="服务端跳转拦截"><a href="#服务端跳转拦截" class="headerlink" title="服务端跳转拦截"></a>服务端跳转拦截</h3><p>服务端主要是对301或302重定向跳转进行拦截，以Egg为例，只要重写 <code>ctx.redirect</code> 方法即可。</p>
<h3 id="A标签跳转拦截"><a href="#A标签跳转拦截" class="headerlink" title="A标签跳转拦截"></a>A标签跳转拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ini">document.addEventListener(&#x27;click&#x27;, function (e) &#123;<br>    var <span class="hljs-attr">target</span> = e.target || &#123;&#125;<span class="hljs-comment">;</span><br>    // A标签可能包含子元素，点击目标可能不是A标签本身，这里只简单判断2层<br>    if (<span class="hljs-attr">target.tagName</span> === <span class="hljs-string">&#x27;A&#x27;</span> || (target.parentNode &amp;&amp; target.parentNode.tagName === <span class="hljs-string">&#x27;A&#x27;</span>)) &#123;<br>        <span class="hljs-attr">target</span> = target.tagName === <span class="hljs-string">&#x27;A&#x27;</span> ? target : target.parentNode<span class="hljs-comment">;</span><br>        var <span class="hljs-attr">href</span> = target.href<span class="hljs-comment">;</span><br>        // 不处理没有配置href或者指向JS代码的A标签<br>        if (!href || href.indexOf(&#x27;javascript&#x27;) === 0) &#123;<br>            return<span class="hljs-comment">;</span><br>        &#125;<br>        var <span class="hljs-attr">newHref</span> = beforeRedirect(href, target.target === <span class="hljs-string">&#x27;_blank&#x27;</span>)<span class="hljs-comment">;</span><br>        // 没有返回值一般是已经处理了跳转，需要禁用当前A标签的跳转<br>        if (!newHref) &#123;<br>            <span class="hljs-attr">target.target</span> = <span class="hljs-string">&#x27;_self&#x27;</span><span class="hljs-comment">;</span><br>            <span class="hljs-attr">target.href</span> = <span class="hljs-string">&#x27;javascript:;&#x27;</span><span class="hljs-comment">;</span><br>        &#125; else if (newHref !== href) &#123;<br>            <span class="hljs-attr">target.href</span> = newHref<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;, true)<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="location-href拦截"><a href="#location-href拦截" class="headerlink" title="location.href拦截"></a>location.href拦截</h3><p>location.href拦截至今是一个困扰前端界的难题，这里只能采用一个折中的方法：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 由于 location.href 无法重写，只能实现一个 <span class="hljs-attr">location2.href</span> = <span class="hljs-string">&#x27;&#x27;</span><br>if (Object.defineProperty) &#123;<br>    <span class="hljs-attr">window.location2</span> = &#123;&#125;<span class="hljs-comment">;</span><br>    Object.defineProperty(window.location2, &#x27;href&#x27;, &#123;<br>        get: function() &#123;<br>            return location.href<span class="hljs-comment">;</span><br>        &#125;,<br>        set: function(href) &#123;<br>            var <span class="hljs-attr">newHref</span> = beforeRedirect(href)<span class="hljs-comment">;</span><br>            if (newHref) &#123;<br>                <span class="hljs-attr">location.href</span> = newHref<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;,<br>    &#125;)<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>因为我们<strong>不仅实现了location.href的写，location.href的读也一起实现了</strong>，所以可以放心大胆的进行全局替换。找到对应前端工程，首先全局搜索<code>window.location.href</code>，批量替换成<code>(window.location2 || window.location).href</code>，然后再全局搜索<code>location.href</code>，批量替换成<code>(window.location2 || window.location).href</code>（思考一下为什么一定是这个顺序呢）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48ae09523b6f46269362ec9025f51406~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>另外需要注意，有些跳转可能是写在npm包里面的，这种情况只能npm也跟着替换一下了，并没有其它更好办法。</p>
</blockquote>
<h3 id="window-open拦截"><a href="#window-open拦截" class="headerlink" title="window.open拦截"></a>window.open拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">tempOpenName</span> = <span class="hljs-string">&#x27;_rawOpen&#x27;</span><span class="hljs-comment">;</span><br>if (!window<span class="hljs-section">[tempOpenName]</span>) &#123;<br>    window<span class="hljs-section">[tempOpenName]</span> = window.open<span class="hljs-comment">;</span><br>    <span class="hljs-attr">window.open</span> = function(url, name, features) &#123;<br>        <span class="hljs-attr">url</span> = beforeRedirect(url, <span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br>        if (url) &#123;<br>            window<span class="hljs-section">[tempOpenName]</span>(url, name, features)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="history-pushState拦截"><a href="#history-pushState拦截" class="headerlink" title="history.pushState拦截"></a>history.pushState拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">tempName</span> = <span class="hljs-string">&#x27;_rawPushState&#x27;</span><span class="hljs-comment">;</span><br>if (!window.history<span class="hljs-section">[tempName]</span>) &#123;<br>    window.history<span class="hljs-section">[tempName]</span> = window.history.pushState<span class="hljs-comment">;</span><br>    <span class="hljs-attr">window.history.pushState</span> = function(state, title, url) &#123;<br>        <span class="hljs-attr">url</span> = beforeRedirect(url)<span class="hljs-comment">;</span><br>        if (url) &#123;<br>            window.history<span class="hljs-section">[tempName]</span>(state, title, url)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="history-replaceState拦截"><a href="#history-replaceState拦截" class="headerlink" title="history.replaceState拦截"></a>history.replaceState拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">tempName</span> = <span class="hljs-string">&#x27;_rawReplaceState&#x27;</span><span class="hljs-comment">;</span><br>if (!window.history<span class="hljs-section">[tempName]</span>) &#123;<br>    window.history<span class="hljs-section">[tempName]</span> = window.history.replaceState<span class="hljs-comment">;</span><br>    <span class="hljs-attr">window.history.replaceState</span> = function(state, title, url) &#123;<br>        <span class="hljs-attr">url</span> = beforeRedirect(url)<span class="hljs-comment">;</span><br>        if (url) &#123;<br>            window.history<span class="hljs-section">[tempName]</span>(state, title, url)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="全局loading处理"><a href="#全局loading处理" class="headerlink" title="全局loading处理"></a>全局loading处理</h3><p>完成上述步骤后，基本上已经看不出来是iframe了，但是跳转的时候中间有短暂的白屏会有一点顿挫感，体验不算很流畅，这时候可以给iframe加一个全局的loading，开始跳转前显示，页面加载完再隐藏：</p>
<p>B系统：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;iframeDOMContentLoaded&#x27;</span>, &#123; <span class="hljs-attr">url</span>: location.<span class="hljs-property">href</span> &#125;);<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>A系统：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; data, <span class="hljs-keyword">type</span> &#125; = e.<span class="hljs-property">data</span> || &#123;&#125;;<br>    <span class="hljs-comment">// iframe 加载完毕</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;iframeDOMContentLoaded&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>&#125;);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;beforeHistoryChange&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 此时页面并没有立即跳转，需要再稍微等待一下再显示loading</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>&#125;), <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>除此之外还需要利用iframe自带的onload加一个兜底，防止iframe页面没有上报 <code>iframeDOMContentLoaded</code> 事件导致loading不消失：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// iframe自带的onload做兜底</span><br>iframeOnLoad = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>&#125;);<br>&#125;<br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">&#123;this.state.loading&#125;</span> <span class="hljs-attr">tip</span>=<span class="hljs-string">&quot;正在加载...&quot;</span> <span class="hljs-attr">inline</span>=<span class="hljs-string">&#123;false&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;microFrontIframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;this.state.currentEntry&#125;</span> <span class="hljs-attr">onLoad</span>=<span class="hljs-string">&#123;this.iframeOnLoad&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Loading</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>还需要注意，当新标签页打开页面时并不需要显示loading，需要注意区分。</p>
<h3 id="弹窗居中问题"><a href="#弹窗居中问题" class="headerlink" title="弹窗居中问题"></a>弹窗居中问题</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77b8181ef065464580ca0f6480bf66be~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>当前场景下弹窗个人觉得并不需要处理，因为菜单的宽度有限，不仔细看的话甚至都没注意到弹窗没有居中：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b6f64672caa4e3e80b4032e73a5926a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>如果非要处理的话也不麻烦，覆盖一下原来页面弹窗的样式，当包含<code>hideLayout</code>参数时，让弹窗的位置分别向左移动<code>menuWidth/2</code>、向上移动<code>navbarHeight/2</code>即可（遮罩位置不能动、也动不了）。</p>
<p>添加了<code>marginLeft=-120px</code>、<code>marginTop=-30px</code> 后的弹窗效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed44aa14e065408cbe3056441579a5f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>其实不难看出，最终效果和SPA几乎无异，而且菜单和导航本来就是无刷新的，页面跳转没有割裂感：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ef290a47e84bb6ae1e9fa7727a8af1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>上述方案有几个没有提到的点：</p>
<ul>
<li>方案成立的前提是建立在2个系统共用一套用户体系，否则需要对2个系统的登录体系进行打通，一般包括账号绑定、A系统默认免登B系统，等等，这需要一定额外的工作量；</li>
<li>参数的透传与删除，例如我希望除了hideLayout参数之外其它URL参数全部在父子页面之间透传；</li>
<li>埋点，数据上报的时候需要增加一个额外参数来标识流量来自另外一个系统；</li>
</ul>
<p>在第一次摸索方案时可能需要花费一些时间，但是在熟悉之后，如果后续还有类似把B系统接入A系统的需求，在没有特殊情况且顺利的前提下可能花费1-2天时间即可完成，最重要的是大部分工作都是全局生效的，不会随着页面的增多而导致工作量增加，测试回归的成本也非常低，只需要验证所有页面跳转、展示等是否正常，功能本身一般不会有太大问题，而如果是微前端方案的话需要从头到尾全部仔仔细细测试一遍，开发和测试的成本都不可估量。</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7185070739064619068">https://juejin.cn/post/7185070739064619068</a></p>
</blockquote>
<h2 id="4-前端优化"><a href="#4-前端优化" class="headerlink" title="4 前端优化"></a>4 前端优化</h2><p>降低请求量：合并资源，减少 HTTP 请求数，minify &#x2F; gzip 压缩，webP，lazyLoad。 </p>
<p>加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。</p>
<p> 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。 </p>
<p>渲染：JS&#x2F;CSS 优化，加载顺序，服务端渲染，pipeline</p>
<h2 id="5-HTML5新特性"><a href="#5-HTML5新特性" class="headerlink" title="5 HTML5新特性"></a>5 HTML5新特性</h2><ol>
<li><p>语义化标签，例如header，footer，section，article等 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；</p>
</li>
<li><p>新增媒体元素，audio、video audio和video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API<br>更多详细属性参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-cn/docs/web/html/element/audio">MDN audio</a> <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-cn/docs/web/html/element/video">MDN video</a></p>
</li>
<li><p>用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的<strong>canvas</strong>元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。<br>更多详细属性参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">MDN canvas</a></p>
</li>
<li><p>新增本地存储方式：sessionStorage、localStorage sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。<br>localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。</p>
</li>
</ol>
<p> 更多详细属性参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage">MDN sessionStorage</a><br> 更多详细属性参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">MDN localStorage</a></p>
<ol start="5">
<li><p>新的技术：webworker、websocket webworker：用于多线程编程<br>websocket：客户端与服务端双向数据通信协议</p>
</li>
<li><p>新增的表单控件：calendar、date、time、email、url、search 更多详细属性参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input">MDN input</a></p>
</li>
</ol>
<h2 id="6-es6新特性"><a href="#6-es6新特性" class="headerlink" title="6 es6新特性"></a>6 es6新特性</h2><h3 id="1-symbol"><a href="#1-symbol" class="headerlink" title="1. symbol"></a>1. symbol</h3><p>　　在ES6之前，我们知道JavaScript支持8种数据类型：Object，String，Boolean，Number，Null，Undefined、Array、Function。现在，ES6新增了一种原始数据类型：symbol，表示独一无二的值，即每个symbol类型的值都不相同。这让我想起了另一个特殊的值：NaN，想一想，他们是不是有一点类似呢！</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">sy</span> = Symbol(<span class="hljs-string">&#x27;test&#x27;</span>)<span class="hljs-comment">;</span><br>var <span class="hljs-attr">sy1</span> = Symbol(<span class="hljs-string">&#x27;test&#x27;</span>)<span class="hljs-comment">;</span><br>console.log(tepeof sy)<span class="hljs-comment">;   //&#x27;symbol&#x27;</span><br><span class="hljs-attr">sy</span> == sy1<span class="hljs-comment">;   //false</span><br>var <span class="hljs-attr">sy2</span> = new Symbol(<span class="hljs-string">&#x27;test&#x27;</span>)<span class="hljs-comment">;   //error : Symbol is not a constructor</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　创建symbol数据类型的值时，需要给Symbol函数传递一个字符串，并且有一点特殊的是：不能使用new关键字调用它。另外，每个symbol类型值都是独一无二的，即使传递的是相同的字符串。</p>
<h3 id="2-let和const"><a href="#2-let和const" class="headerlink" title="2. let和const"></a>2. let和const</h3><p>　　ES6新增了两个声明变量的关键字：let和const。</p>
<p>　　他们声明的变量仅在let和const关键字所在的代码块内起作用，即在使用let和const的那一对大括号{}内起作用，也称块级作用域（ES6之前只有函数作用域和全局作用域）。</p>
<p>　　let和const声明变量不会在预编译过程中有提升行为(在全局声明也不会变成window的属性)，且同一变量不能重复声明。所以要使用这类变量，只能在let和const关键字之后使用它们。</p>
<p>　　let和const关键字还有一个特性：“暂时性死区”，即在使用了该关键字的块级作用域中，其内部使用let和const关键字声明的变量与外部作用域中的变量相互隔绝，互不影响。即使是同名变量。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#123;<br>   console.log(a)<span class="hljs-comment">;   //error Cannot access &#x27;a&#x27; before initialization</span><br>   let <span class="hljs-attr">a</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>   console.log(a)<span class="hljs-comment">;   //0</span><br>&#125;<br>console.log(a)<span class="hljs-comment">;   //1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　const用来声明一个常量，声明时必须赋值，且一旦声明就不能改变。</p>
<p>　　其实说const变量不能更改是不准确的，请看下面的例子：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">obj</span> = &#123;<br>    name:&#x27;ren&#x27;,<br>    age:12<br>&#125;<span class="hljs-comment">;</span><br><span class="hljs-attr">obj</span> = &#123;&#125;<span class="hljs-comment">;   //error</span><br><span class="hljs-attr">obj.sex</span> = male<span class="hljs-comment">;</span><br>consol.log(obj)<span class="hljs-comment">;   //&#123;name:&#x27;ren&#x27;,age:12;sex:&#x27;male&#x27;&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　const声明的如果是一个原始值，那么上面的说法是准确的，如果const声明的是一个引用值，那么更准确的说法应该是一个不能被重新赋值的变量。</p>
<h3 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3. 解构赋值"></a>3. 解构赋值</h3><p>　　解构赋值是对赋值运算符的扩展。它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">let <span class="hljs-selector-attr">[a,b,c]</span> = <span class="hljs-selector-attr">[1,2,3]</span>;<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,c);    //<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br> <br>let <span class="hljs-selector-attr">[a,b,c]</span> = <span class="hljs-selector-attr">[1,,3]</span>;<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,c);    //<span class="hljs-number">1</span>,undefined,<span class="hljs-number">3</span><br> <br>let <span class="hljs-selector-attr">[a,,b]</span> = <span class="hljs-selector-attr">[1,2,3]</span>;<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>);//<span class="hljs-number">1</span>,<span class="hljs-number">3</span><br> <br>let <span class="hljs-selector-attr">[a,..b]</span> = <span class="hljs-selector-attr">[1,2,3]</span>;    //...是剩余运算符，表示赋值运算符右边除第一个值外剩余的都赋值给<span class="hljs-selector-tag">b</span><br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>);//<span class="hljs-number">1</span>,<span class="hljs-selector-attr">[2,3]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　  事实上所有可枚举（iterable）的对象都可以使用解构赋值，例如数组，字符串对象，以及ES6新增的Map和Set类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> arr = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-built_in">let</span> [a,b,c,d,e] = arr;<br>console.log(a,b,c,d,e);  //<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span><br>　　对象的解构赋值和数组类似，不过左边的变量名需要使用对象的属性名，并且用大括号&#123;&#125;而非中括号[]：<br><br><span class="hljs-built_in">let</span> obj = &#123;name:<span class="hljs-string">&#x27;ren&#x27;</span>,age:12,sex:<span class="hljs-string">&#x27;male&#x27;</span>&#125;;<br><span class="hljs-built_in">let</span> &#123;name,age,sex&#125; = obj;<br>console.log(name,age,sex);  //<span class="hljs-string">&#x27;ren&#x27;</span> 12 <span class="hljs-string">&#x27;male&#x27;</span><br><span class="hljs-built_in">let</span> &#123;name:myName,age:myAge,sex:mySex&#125; = obj;  //自定义变量名<br>console.log(myName,myAge,mySex);  //<span class="hljs-string">&#x27;ren&#x27;</span> 12 <span class="hljs-string">&#x27;male&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="二-新的对象和方法"><a href="#二-新的对象和方法" class="headerlink" title="二　　新的对象和方法"></a>二　　新的对象和方法</h3><h4 id="1，Map和Set"><a href="#1，Map和Set" class="headerlink" title="1，Map和Set"></a>1，Map和Set</h4><p>　　Map对象用于保存键值对，任何值JavaScript支持的值都可以作为一个键或者一个值。这听起来和对象差不多啊？其实它们还是有区别的：</p>
<p>　　　　a) object的键只能是字符串或ES6的symbol值，而Map可以是任何值。</p>
<p>　　　　b) Map对象有一个size属性，存储了键值对的个数，而object对象没有类似属性。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">let myMap = new Map(<span class="hljs-string">[[&#x27;name&#x27;,&#x27;ren&#x27;],[&#x27;age&#x27;,12]]</span>);<br>console.<span class="hljs-built_in">log</span>(myMap);  //&#123;<span class="hljs-string">&#x27;name&#x27;</span>=&gt;<span class="hljs-string">&#x27;ren&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>=&gt;<span class="hljs-number">12</span>&#125;<br>myMap.set(<span class="hljs-string">&#x27;sex&#x27;</span>,<span class="hljs-string">&#x27;male&#x27;</span>);<br>console.<span class="hljs-built_in">log</span>(myMap);  //&#123;<span class="hljs-string">&#x27;name&#x27;</span>=&gt;<span class="hljs-string">&#x27;ren&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>=&gt;<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;sex&#x27;</span>=&gt;<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>myMap.get(<span class="hljs-string">&#x27;name&#x27;</span>);  //<span class="hljs-string">&#x27;ren&#x27;</span><br>myMap.has(<span class="hljs-string">&#x27;age&#x27;</span>);  //<span class="hljs-literal">true</span><br>myMap.delete(<span class="hljs-string">&#x27;age&#x27;</span>);  //<span class="hljs-literal">true</span><br>myMap.has(<span class="hljs-string">&#x27;age&#x27;</span>);  //<span class="hljs-literal">false</span><br>myMap.get(<span class="hljs-string">&#x27;age&#x27;</span>);  //undefined<br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　Map构造函数接收一个二维数组来创建一个Map对象。数组元素的第0位表示Map对象的key，第1位表示Map对象的value。</p>
<p>　　Map对象使用set方法来新增数据，set方法接收两个参数，第一个表示key，第二个表示value。使用get方法获取数据，参数是对象的key。</p>
<p>　　Map对象使用delete方法来删除数据，接收一个参数，表示需要被删除的key。</p>
<p>　　Map对象使用has方法检测是否已经具有某个属性，返回boolean值。</p>
<p>　　Set对象和Map对象类似，但它是用来存储一组唯一值的，而不是键值对。类似数组，但它的每个元素都是唯一的。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">let mySet = new <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br>console<span class="hljs-selector-class">.log</span>(mySet);  <span class="hljs-comment">//&#123;1,2,3&#125;</span><br>mySet<span class="hljs-selector-class">.add</span>(<span class="hljs-number">4</span>);<br>console<span class="hljs-selector-class">.log</span>(mySet);  <span class="hljs-comment">//&#123;1,2,3,4&#125;</span><br>mySet<span class="hljs-selector-class">.delete</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//true</span><br>mySet<span class="hljs-selector-class">.has</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//false</span><br>复制代码<br> 利用Set对象唯一性的特点，可以轻松实现数组的去重：<br>复制代码<br>let arr = <span class="hljs-selector-attr">[1,1,2,3,4,4]</span>;<br>let mySet = new <span class="hljs-built_in">Set</span>(arr);<br>let newArr = Array<span class="hljs-selector-class">.from</span>(mySet);<br>console<span class="hljs-selector-class">.log</span>(newArr);  <span class="hljs-comment">//[1,2,3,4]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2，对象新特性"><a href="#2，对象新特性" class="headerlink" title="2，对象新特性"></a>2，对象新特性</h4><p>　　创建对象的字面量方式可以更加简洁。直接使用变量名作为属性，函数体作为方法，最终变量值变成属性值，函数名变成方法名。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">name</span> = <span class="hljs-string">&#x27;ren&#x27;</span><span class="hljs-comment">;</span><br> let <span class="hljs-attr">age</span> = <span class="hljs-number">12</span><span class="hljs-comment">;</span><br> let <span class="hljs-attr">myself</span> = &#123;<br>     name,<br>     age,<br>     say()&#123;<br>         console.log(this.name)<span class="hljs-comment">;</span><br>     &#125;<br> &#125;<span class="hljs-comment">;</span><br>console.log(myself)<span class="hljs-comment">;  //&#123;name:&#x27;ren&#x27;,age:12,say:fn&#125;</span><br>myself.say()<span class="hljs-comment">;  //&#x27;ren&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　对象的拓展运算符(…)三点。用于拷贝目标对象所有可遍历的属性到当前对象。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">obj</span> = &#123;name:<span class="hljs-string">&#x27;ren&#x27;</span>,age:<span class="hljs-number">12</span>&#125;<span class="hljs-comment">;</span><br>let <span class="hljs-attr">person</span> = &#123;...obj&#125;<span class="hljs-comment">;</span><br>console.log(person)<span class="hljs-comment">;//&#123;name:&#x27;ren&#x27;,age:12&#125;</span><br><span class="hljs-attr">obj</span> == person<span class="hljs-comment">;//false</span><br>let <span class="hljs-attr">another</span> = &#123;sex:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<span class="hljs-comment">;</span><br>let <span class="hljs-attr">someone</span> = &#123;...person,...another&#125;<span class="hljs-comment">;//合并对象</span><br>console.log(someone)<span class="hljs-comment">;//&#123;name:&#x27;ren&#x27;,age:12,sex:&#x27;male&#x27;&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　ES6对象新增了两个方法，assign和is。</p>
<p>　　assign用于浅拷贝源对象可枚举属性到目标对象。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">let source = &#123;<span class="hljs-selector-tag">a</span>:&#123; <span class="hljs-selector-tag">b</span>: <span class="hljs-number">1</span>&#125;,<span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span>&#125;;<br>let target = &#123;c: <span class="hljs-number">3</span>&#125;;<br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.assign</span>(target, source);<br>console<span class="hljs-selector-class">.log</span>(target);  //&#123;c: <span class="hljs-number">3</span>, a: &#123;<span class="hljs-selector-tag">b</span>:<span class="hljs-number">1</span>&#125;, <span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span>&#125;<br>source<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.b</span> = <span class="hljs-number">2</span>;<br>console<span class="hljs-selector-class">.log</span>(target<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.b</span>);  //<span class="hljs-number">2</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　如果有同名属性，那么目标对象的属性值会被源对象的属性值覆盖。所以数组的表现就有一点特别了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Object.assign([1,2,3],[11,22,33,44]);//[11,22,33,44]">复制代码<br></code></pre></td></tr></table></figure>

<p>　　数组的index就是属性名，当使用assign方法时，从第0位开始，目标数组的值便开始被源数组的值覆盖了。</p>
<p>　　is方法和（&#x3D;&#x3D;&#x3D;）功能基本类似，用于判断两个值是否绝对相等。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-type">Object</span>.<span class="hljs-built_in">is</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);//<span class="hljs-literal">true</span><br><span class="hljs-type">Object</span>.<span class="hljs-built_in">is</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">true</span>);//<span class="hljs-literal">false</span><br><span class="hljs-type">Object</span>.<span class="hljs-built_in">is</span>([],[]);//<span class="hljs-literal">false</span><br><span class="hljs-type">Object</span>.<span class="hljs-built_in">is</span>(+<span class="hljs-number">0</span>,-<span class="hljs-number">0</span>);//<span class="hljs-literal">false</span><br><span class="hljs-type">Object</span>.<span class="hljs-built_in">is</span>(NaN,NaN);//<span class="hljs-literal">true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　他们仅有的两点区别是，is方法可以区分+0还是-0，还有就是它认为NaN是相等的。</p>
<h4 id="3，字符串新方法"><a href="#3，字符串新方法" class="headerlink" title="3，字符串新方法"></a>3，字符串新方法</h4><p>　　includes()判断字符串是否包含参数字符串，返回boolean值。如果想要知道参数字符串出现的位置，还是需要indexOf或lastIndexOf方法。</p>
<p>　　startsWith()&#x2F;endsWith()，判断字符串是否以参数字符串开头或结尾。返回boolean值。这两个方法可以有第二个参数，一个数字，表示开始查找的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">str</span> = <span class="hljs-symbol">&#x27;blue</span>,red,orange,white&#x27;;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">includes</span>(<span class="hljs-symbol">&#x27;blue</span>&#x27;);<span class="hljs-comment">//true</span><br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">startsWith</span>(<span class="hljs-symbol">&#x27;blue</span>&#x27;);<span class="hljs-comment">//true</span><br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">endsWith</span>(<span class="hljs-symbol">&#x27;blue</span>&#x27;);<span class="hljs-comment">//false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　repeat()方法按指定次数返回一个新的字符串。如果次数是大于0的小数则向下取整，0到-1之间的小数则向上取整，其他负数将抛出错误。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">2</span>));//<span class="hljs-string">&#x27;hellohello&#x27;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">1.9</span>));//<span class="hljs-string">&#x27;hello&#x27;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">-0.9</span>));//<span class="hljs-string">&#x27;&#x27;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">-1.9</span>));//<span class="hljs-built_in">error</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　padStart()&#x2F;padEnd()，用参数字符串按给定长度从前面或后面补全字符串，返回新字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-string">&#x27;hell&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;o&#x27;</span>));  <span class="hljs-comment">//&#x27;hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;o&#x27;</span>));  <span class="hljs-comment">//&#x27;helloo&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">6</span>));  <span class="hljs-comment">//&#x27;hell  &#x27;,如果没有指定将用空格代替</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;o&#x27;</span>));  <span class="hljs-comment">//&#x27;ohell&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　另外，如果字符串加上补全的字符串超出了给定的长度，那么，超出的部分将被截去。</p>
<h4 id="4，数组的新方法"><a href="#4，数组的新方法" class="headerlink" title="4，数组的新方法"></a>4，数组的新方法</h4><p>　　of()是ES6新增的用于创建数组的方法。of把传入的参数当做数组元素，形成新的数组。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">arr</span> = Array.of(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2&#x27;</span>,[<span class="hljs-number">3</span>],&#123;&#125;)<span class="hljs-comment">;</span><br>console.log(arr)<span class="hljs-comment">;   //[1,&#x27;2&#x27;,[3],&#123;&#125;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　from()方法可以将可迭代对象转换为新的数组。函数可接受3个参数：第一个表示将被转换的可迭代对象，第二个是回调函数，将对每个数组元素应用该回调函数，然后返回新的值到新数组，第三个是回到函数内this的指向。后两个参数是可选的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-title function_">double</span>(<span class="hljs-params">n</span>) &#123;<br>        <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr, <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">double</span>(n);<br>&#125;, obj)); <span class="hljs-comment">// [2, 4, 6]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　find()和findIndex()，查找数组中符合条件的元素值或索引，方法不会修改原数组。</p>
<p>　　接受一个回调函数作为参数，函数可以接受四个参数，分别是当前遍历到的元素，当前遍历到的索引，数组本身以及函数内this的指向。方法会把回调函数作用于每一个遍历到的元素，如果遍历到某一个元素可以使回调函数返回true，那么find方法会立即返回该元素，findIndex方法会返回该元素的索引。并终止继续遍历。</p>
<p>　　如果有多个符合条件的，也将只返回第一个。如果遍历完整个数组也无法是回调函数返回true，那么find方法将返回undefined，findIndex方法将返回-1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> ele === <span class="hljs-number">1</span>;<br>&#125;));<span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> ele &gt; <span class="hljs-number">4</span>;<br>&#125;));  <span class="hljs-comment">//4</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　fill()&#x2F;copyWithin()，替换数组中部分元素，会修改原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>));<span class="hljs-comment">//[0,0,0,4,5]</span><br><span class="hljs-comment">//参数1表示目标值，参数2，3表示替换的始末位置，左闭右开区间。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>));<span class="hljs-comment">//[0,4,0,4,5]</span><br><span class="hljs-comment">//参数1表示修改的起始位置，参数2，3表示用来替换的数据的始末位置，左闭右开区间。</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　fill()用指定的值替换，copyWithin()使用数组中原有的某一部分值替换。</p>
<p>　　includes()用于检测数组是否包含某个值，可以指定开始位置。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]; console.<span class="hljs-built_in">log</span>(arr.includes(<span class="hljs-number">2</span>));//<span class="hljs-literal">true</span> console.<span class="hljs-built_in">log</span>(arr.includes(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));//<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h3 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h3><h4 id="1，参数默认值"><a href="#1，参数默认值" class="headerlink" title="1，参数默认值"></a>1，参数默认值</h4><p>　　ES6首次添加了参数默认值。我们再也不用在函数内部编写容错代码了。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">add</span>(a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>)&#123;<br>    return <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>;<br>&#125;<br><span class="hljs-built_in">add</span>();<span class="hljs-comment">//3</span><br><span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//4</span><br><span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<span class="hljs-comment">//7</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　和参数默认值一起，ES6还带来了不定参。它的功能和使用arguments差不多。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(...num)&#123;<br>    <span class="hljs-keyword">return</span> num.reduce(<span class="hljs-keyword">function</span>(<span class="hljs-keyword">result</span>,<span class="hljs-keyword">value</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">value</span>;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">10</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　下面介绍的箭头函数没有arguments属性，如果箭头函数内要实现不定参，上述方式就是一个不错的选择了。</p>
<h4 id="2，箭头函数"><a href="#2，箭头函数" class="headerlink" title="2，箭头函数"></a>2，箭头函数</h4><p>　　箭头函数实现了一种更加简洁的书写方式，并且也解决了关键字声明方式的一些麻烦事儿。箭头函数内部没有arguments，也没有prototype属性，所以不能用new关键字调用箭头函数。</p>
<p>　　箭头函数的书写方式：参数 &#x3D;&gt; 函数体。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">add</span> = (a,b) =&gt; &#123;<br>    return a+b<span class="hljs-comment">;</span><br>&#125;<br>let <span class="hljs-attr">print</span> = () =&gt; &#123;<br>    console.log(&#x27;hi&#x27;)<span class="hljs-comment">;</span><br>&#125;<br>let <span class="hljs-attr">fn</span> = a =&gt; a * a<span class="hljs-comment">;</span><br>//当只有一个参数时，括号可以省略，函数体只有单行return语句时，大括号也可以省略，强烈建议不要省略它们，是真的难以阅读<br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　当函数需要直接返回对象时，你必须使用小括号把对象包裹起来。否则将抛出错误。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">const fn = () =&gt;&#123;name:&#x27;ren&#x27;,age:12&#125;;<br>// SyntaxError<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">const fn = () =&gt;(&#123;name:&#x27;ren&#x27;,age:12&#125;);</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">复制代码</span></span><br></code></pre></td></tr></table></figure>

<p>　　箭头函数和普通函数最大的区别在于其内部this永远指向其父级AO对象的this。</p>
<p>　　普通函数在预编译环节会在AO对象上添加this属性，保存一个对象（请参照《JavaScript之深入对象（二）》）。每个普通函数在执行时都有一个特定的this对象，而箭头函数执行时并不直接拥有this属性，如果你在箭头函数中使用this，将根据函数作用域链，直接引用父级AO对象上this绑定的对象。普通函数的AO对象只有在函数执行时才产生，换言之，普通函数的this是由函数执行时的环境决定。而箭头函数的特别之处在于，当函数被定义时，就引用了其父级AO对象的this，即箭头函数的this由定义时的环境决定。</p>
<p>　　根据箭头函数的特点，不难推测：如果定义对象的方法直接使用箭头函数，那么函数内的this将直接指向window。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">age</span> = <span class="hljs-number">123</span><span class="hljs-comment">;</span><br> let <span class="hljs-attr">obj</span> = &#123;<br>     age:456,<br>     say:() =&gt; &#123;<br>         console.log(this.age)<span class="hljs-comment">;</span><br>     &#125;<br> &#125;<span class="hljs-comment">;</span><br>obj.say()<span class="hljs-comment">;   //123</span><br>//对象是没有执行期上下文的（AO对象），定义对象的方法实际上是在全局作用域下，即window<br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　如果你一定要在箭头函数中让this指向当前对象，其实也还是有办法的（但是没必要这么麻烦啊，直接使用普通函数不是更好吗？）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">age</span> = <span class="hljs-number">123</span><span class="hljs-comment">;</span><br> let <span class="hljs-attr">obj</span> = &#123;<br>     age:456,<br>     say:function()&#123;<br>         var <span class="hljs-attr">fn</span> = () =&gt; &#123;<br>         console.log(this.age)<span class="hljs-comment">;</span><br>        &#125;<br>         return fn()<span class="hljs-comment">;</span><br>      &#125;<br> &#125;<span class="hljs-comment">;</span><br>obj.say()<span class="hljs-comment">;  //456</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　我们来分析一下这是怎么做到的：首先，我们使用obj调用say方法时，say内创建了AO对象，并且该AO对象的this属性指向了obj（这里不明白的请回去复习一下我的《JavaScript之深入函数&#x2F;对象》），然后，say内部又声明了一个箭头函数。我们说箭头函数在声明时就要强行引用父级AO的this属性，那么现在该箭头函数的父级AO是谁呢？当然就是say的AO啦，所以这里箭头函数的this直接就绑定了obj，最后箭头函数在执行时拿到的this，实际上就是say方法的AO.this，即obj本身。</p>
<p>　　上面是在对象中使用箭头函数，如果那让你难于理解，那么请看下面这种方式：在普通函数中使用箭头函数。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> obj = &#123;name:<span class="hljs-string">&#x27;ren&#x27;</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> = (<span class="hljs-params"></span>) =&gt;</span> &#123;<br>        console.<span class="hljs-title function_ invoke__">log</span>(this);<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">test</span>();  <span class="hljs-comment">//window</span><br>test.<span class="hljs-title function_ invoke__">call</span>(obj);  <span class="hljs-comment">//&#123;name:&#x27;ren&#x27;&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　test函数在全局执行时，其this指向window，这时也产生了箭头函数的定义，于是箭头函数内的this也被指向了window，所以最终打印出window对象。</p>
<p>　　当我们手动改变test函数执行时this的指向时，箭头函数定义所绑定的this实际上也被我们修改了。所以最终打印出obj。</p>
<h3 id="四、class（类）"><a href="#四、class（类）" class="headerlink" title="四、class（类）"></a>四、class（类）</h3><p>　　class 作为对象的模板被引入ES6，你可以通过 class 关键字定义类。class 的本质依然是一个函数。</p>
<h4 id="1，创建类"><a href="#1，创建类" class="headerlink" title="1，创建类"></a>1，创建类</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ex</span> &#123;   <span class="hljs-comment">//关键字声明方式</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">say</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">static</span> m = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//let ex = class&#123;&#125;  字面量方式</span><br><span class="hljs-keyword">var</span> example = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ex</span>(<span class="hljs-string">&#x27;ren&#x27;</span>);<br>example.<span class="hljs-title function_">say</span>();    <span class="hljs-comment">//&#x27;ren&#x27;</span><br><span class="hljs-title class_">Ex</span>.<span class="hljs-title function_">m</span>();   <span class="hljs-comment">//123</span><br>example.<span class="hljs-title function_">methods</span>();  <span class="hljs-comment">//&#x27;hello ren&#x27;</span><br>复制代码<br>constructor是创建类必须的方法，当使用<span class="hljs-keyword">new</span>调用类创建实例时，将自动执行该方法，该方法和构造函数类似，默认返回<span class="hljs-variable language_">this</span>对象。实例的方法和属性都定义在constructor内部。相当于构造函数的<span class="hljs-variable language_">this</span>方式。<br>类保留了prototype属性，类中的方法不需要使用<span class="hljs-keyword">function</span>关键字，并且方法之间不需要逗号隔开。类中定义的方法实际上还是保存在类的prototype属性上。<br></code></pre></td></tr></table></figure>

<p>　　</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 使用static关键字定义类的静态属性和方法。类中不能定义共有属性，要想定义实例的共有属性还是需要使用prototype属性：Ex.prototype.属性名">复制代码<br></code></pre></td></tr></table></figure>

<p>　　创建实例依然使用new关键字。</p>
<h4 id="2、类的继承"><a href="#2、类的继承" class="headerlink" title="2、类的继承"></a>2、类的继承</h4><p>　</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala">类的继承通过<span class="hljs-keyword">extends</span>关键字实现。<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    constructor (name,age)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    say()&#123;<br>        console.log(<span class="hljs-keyword">this</span>.name + &#x27;:&#x27; + <span class="hljs-keyword">this</span>.age);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    constructor (name,age,sex)&#123;<br>        <span class="hljs-keyword">super</span>(name,age);<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(&#x27;ren&#x27;,<span class="hljs-number">12</span>,&#x27;male&#x27;);<br>student.name;  <span class="hljs-comment">//&#x27;ren&#x27;</span><br>student.sex;  <span class="hljs-comment">//&#x27;male&#x27;</span><br>student.say();  <span class="hljs-comment">//&#x27;ren:12&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　子类继承自父类，不会隐式的创建自己的this对象，而是通过super()引用父类的this。这个过程和在子构造函数内使用父构造函数call(this)很像，但他们有本质的区别。另外，ES6规定，super()必须在子类的this之前执行。所以一般我们把super()放在子类constructor方法的第一行，这样准没错！</p>
<h3 id="五、模块导入和导出"><a href="#五、模块导入和导出" class="headerlink" title="五、模块导入和导出"></a>五、模块导入和导出</h3><h4 id="1，导入"><a href="#1，导入" class="headerlink" title="1，导入"></a>1，导入</h4><p>　　ES6使用关键字 import 导入模块（文件），有两种常用的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> ‘模块名称’ <span class="hljs-keyword">from</span> ‘路径’；<br><span class="hljs-keyword">import</span>  ‘路径’；<br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　通过 import…from 的方式引入模块，模块名称实际上相当于定义一个变量，用来接收即将导入的模块。</p>
<p>　　路径可以有很多方式，既可以是绝对路径，也可以是相对路径，甚至只是一个简单的模块名称，更甚至连文件后缀都不需要。当你使用该命令时，系统会自动从配置文件中指定的路径中去寻找并加载正确的文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-comment">//完整路劲其实是 &quot;../node_modules/vue/dist/vue.js&quot;;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　通过 import… 的方式一般用来引入样式文件或预处理文件，因为他们不需要用变量来接收。</p>
<h4 id="2，导出"><a href="#2，导出" class="headerlink" title="2，导出"></a>2，导出</h4><p>　　ES6 通过 export 和export default 导出模块。导出的含义是向外暴露、输出，在一个文件中通过 import 导入另一个文件，通过变量即可以接收到导出的数据了。一般情况下，JS文件可以向外输出变量、函数和对象。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">name</span> = <span class="hljs-string">&#x27;ren&#x27;</span>,age = <span class="hljs-number">12</span><span class="hljs-comment">;</span><br>export &#123;name,age&#125;<span class="hljs-comment">;</span><br>//注意：变量需要用大括号包裹，然后才能向外输出<br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　如果仅需向外暴露一个变量：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">export var <span class="hljs-attr">name</span> = <span class="hljs-string">&#x27;ren&#x27;</span><span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　使用 export 向外输出函数的用法和变量相同，这里不再举例。</p>
<p>　　总结：使用 export 向外输出成员时，可以同时输出多个，并且必须用‘｛｝’大括号包裹，在其他地方使用 import 导入时，接收成员的变量名必须和这里输出的名称一致，同时，可以根据实际情况，仅接收实际需要的的成员（接收的时候也要用大括号包裹）。</p>
<p>　　如果希望通过 export 向外暴露成员，并且在导入的时候自定义接收名称，那么你可以使用 as 关键字重命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;ren&#x27;</span>, age = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">export</span> &#123;name, age&#125;;<br> <br><span class="hljs-keyword">import</span> &#123;name <span class="hljs-keyword">as</span> myName, age <span class="hljs-keyword">as</span> myAge&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;url&#x27;</span>;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　与 export 相比，export default 有以下几点不同：首先，在同一个模块中，export default 只允许向外暴露一次成员；然后，这种方式可以使用任意的名称接收，不像 export 那样有严格的要求；最后，export 和 export default 可以在同一模块中同时存在。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">person</span> = &#123;name:<span class="hljs-string">&#x27;ren&#x27;</span>&#125;<span class="hljs-comment">;</span><br>let <span class="hljs-attr">age</span> = <span class="hljs-number">12</span><span class="hljs-comment">;</span><br>let <span class="hljs-attr">address</span> = <span class="hljs-string">&#x27;cd&#x27;</span><span class="hljs-comment">;</span><br>export default person<span class="hljs-comment">;</span><br>export &#123;age&#125;<span class="hljs-comment">;</span><br>export &#123;address&#125;<span class="hljs-comment">;</span><br> <br>import man,&#123;age,address&#125; from &#x27;url&#x27;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>　　小技巧：通常 import 无法直接被浏览器识别，即如果在HTML文档中引入的 JS 文件直接使用了 import 关键字，浏览器会报错。要想直接在被HTML文档引用的 JS 文件中使用 import，需要给该 </p>
<h3 id="六-异步机制"><a href="#六-异步机制" class="headerlink" title="六　　异步机制"></a>六　　异步机制</h3><p>　　ES6新增了两种实现异步的新机制，Promise和Generator。文笔有限，怕讲的不清楚，误人子弟，请有兴趣的同学去下面的链接继续学习，廖老师的教程也是受很多人推崇的，当然MDN更官方。</p>
<p>　　1，Promise</p>
<p>　　<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;…</a></p>
<p>　　<a href="https://link.juejin.cn/?target=https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544">www.liaoxuefeng.com/wiki/102291…</a></p>
<p>　　2，Generator</p>
<p>　　[developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;…](</p>
<h2 id="7-说说对前端工程化的理解，以及使用过的工程化工具"><a href="#7-说说对前端工程化的理解，以及使用过的工程化工具" class="headerlink" title="7 说说对前端工程化的理解，以及使用过的工程化工具"></a>7 说说对前端工程化的理解，以及使用过的工程化工具</h2><h3 id="什么是前端工程化"><a href="#什么是前端工程化" class="headerlink" title="什么是前端工程化"></a>什么是前端工程化</h3><p>前端工程化，就是<strong>降本提效</strong>的体现</p>
<p>广义上，前端工程化包含一切以<strong>降低成本、提高效率、保障质量</strong>为目的的手段</p>
<p>通过一系列的规范、流程、工具达到<strong>研发提效、自动化、保障质量、服务稳定、预警监控</strong>等</p>
<p>一个优秀的前端工程师，需要对所开发项目的效率、性能、质量等工程化维度，去制定和实施技术优化指标，只有具备这方面能力，才能应对和优化复杂项目，保证团队高效产出</p>
<h3 id="为什么要进行前端工程化"><a href="#为什么要进行前端工程化" class="headerlink" title="为什么要进行前端工程化"></a>为什么要进行前端工程化</h3><p>项目发展过程中，随着项目成员增加，系统复杂度上升，会引发如下问题：</p>
<ol>
<li><strong>系统质量的下降</strong></li>
</ol>
<p>项目开发人员频繁变更，系统功能新增和迭代，都会导致缺陷的增加，需要通过系统上线前的质量监测来尽早发现问题</p>
<p>为降低系统复杂度，到了一定阶段，对系统进行局部或者整体的架构调整，引入新技术，但也可能引发新问题：</p>
<ul>
<li>部分功能无法与新技术兼容</li>
<li>影响面广，可能有缺陷无法及时发现</li>
</ul>
<ol>
<li><strong>开发效率的下降</strong></li>
</ol>
<p>系统上线之后，开发工作内容变得复杂，需要关注的事情更多，不停切换不同工作内容，容易遗漏工作步骤，导致流程出现问题，导致系统质量不稳定，技术债务更多，团队开发效率下降</p>
<p>前端工程化，就是要解决如上两大类问题，提升系统质量和开发效率，提升团队的人工投入产出比</p>
<h3 id="如何进行前端工程化"><a href="#如何进行前端工程化" class="headerlink" title="如何进行前端工程化"></a>如何进行前端工程化</h3><h4 id="系统质量"><a href="#系统质量" class="headerlink" title="系统质量"></a>系统质量</h4><h5 id="设计前端项目"><a href="#设计前端项目" class="headerlink" title="设计前端项目"></a>设计前端项目</h5><p>设计项目时，需明确技术选型的影响因素（具体如下），再具体做对应决策</p>
<ul>
<li><strong>项目规模、功能交互</strong></li>
</ul>
<p>影响框架、工具选型，可考虑使用开源&#x2F;现有框架，目前三大主流框架包含Angular、Vue、React</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c33fa6fdfd40199268d785f7aa3e5e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><strong>用户体系</strong></li>
</ul>
<p>影响兼容性的倾向，比如APP主要群体是老年人，需要考虑旧版本手机的兼容性</p>
<ul>
<li><strong>多人协作、团队规模</strong>：考虑完善规范，尽量使用工具保证规范进行<ul>
<li>使用一致的代码开发规范<ul>
<li>使用 Eslint 监测代码规范</li>
<li>使用 Prettier 自动化格式代码</li>
<li>使用 Git Commit Hooks 拒绝不符合规范的代码提交</li>
<li>使用流水线检测出不规范代码，并拒绝合入主干分支，拒绝进入发布流程</li>
</ul>
</li>
<li>合入代码前，进行 Code Review，遇到分歧时，可通过投票</li>
<li>制定合适的代码流程规范<ul>
<li>关联需求单&#x2F;bug 单的分支命名</li>
<li>检查代码是否符合规范、进行 Code Review</li>
<li>自动化构建和测试代码</li>
<li>灰度发布代码</li>
</ul>
</li>
<li>通过自动化工具确保流程正常进行，比如使用 CI&#x2F;CD</li>
</ul>
</li>
<li><strong>团队技术栈</strong><ul>
<li>考虑团队现有的技术栈、团队成员对框架&#x2F;工具的熟悉程度，团队成员倾向的框架&#x2F;工具</li>
<li>使用团队成员比较熟悉的技术栈，可减少开发问题，提升开发效率</li>
<li>针对新技术方案，则可通过成员讨论和投票</li>
</ul>
</li>
</ul>
<h5 id="搭建前端监控体系"><a href="#搭建前端监控体系" class="headerlink" title="搭建前端监控体系"></a>搭建前端监控体系</h5><p>搭建前端监控体系是为了及时发现问题，快速定位并解决问题，监控页面整体访问情况包括常见的 PV、UV、用户操作行为，监控页面性能</p>
<p><strong>前端监控需关注的数据</strong></p>
<ul>
<li>系统的生命周期数据：包括页面加载的关键时间点，比如页面打开、更新、关闭等<ul>
<li>PerformanceTiming 属性可获取用于页面跳转、加载等数据</li>
<li>document.DOMContentLoader、document.readystatechange，可获取页面加载数据</li>
<li>Vue 的生命周期函数也可进行数据收集</li>
<li>MutationObserver 接口可结合 performance.now() 获取到具体的时间</li>
</ul>
</li>
<li>HTTP 测速数据</li>
</ul>
<p>PerformanceTiming 属性也可获取 HTTP 请求相关数据，比如 HTTP 跳转开始&#x2F;结束，域名查询开始&#x2F;结束等时间戳，用于观察后端服务稳定情况、可优化空间</p>
<ul>
<li>系统异常数据</li>
</ul>
<p>包括逻辑错误、代码健壮性、网络错误、系统错误、页面内容异常等数据</p>
<p>前4种的异常数据，可用 window.onerror、document.addEvenetListener(error)、XMLHttpRequest status 等方法拦截，第5种异常可通过回归测试、UI 界面测试等方式获取</p>
<ul>
<li>用户行为数据</li>
</ul>
<p>包括页面浏览点击量、页面停留时间、访问入口、用户操作、用户链路数据，用于监控页面功能是否正常、分析用户行为，定位问题，以便更好地调整产品功能</p>
<p>可通过 DOM 元素的时间监听、页面加载情况</p>
<ul>
<li>用户日志</li>
</ul>
<p>使用用户日志定位系统异常信息</p>
<p>自动打印日志的方式：添加装饰器、对类方法进行劫持</p>
<p>存放系统输出日志：上报到服务器和本地存储两种方式配合使用</p>
<p><strong>数据采集</strong></p>
<ul>
<li>数据埋点</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13015402916944358214d41f682ed420~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>数据上报<ul>
<li>定期&#x2F;定量上报：收集数据到一定数量之后，再一次性打包，或者按照一定的时间间隔打包上传</li>
<li>关键生命周期上报</li>
<li>用户主动提交：引导用户主动上传异常和使用体验问题</li>
</ul>
</li>
</ul>
<p><strong>搭建可视化管理端</strong></p>
<ul>
<li>日常监控：配置告警阈值，结合邮件、机器人推送，发现问题</li>
<li>版本发布和灰度：关注错误告警、全版本监控观察、分版本监控观察，出现数据异常，配合告警渠道通知负责人</li>
</ul>
<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><p><strong>常见的性能优化方案</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/550ebd54b95a425cb5f098924bc780ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><strong>如何在项目中进行性能优化</strong></p>
<ul>
<li>确定优化的目标和预期</li>
</ul>
<ol>
<li>明确性能数据<ul>
<li>网络资源请求时间</li>
<li>Time To Start Render(TTSR)：浏览器开始渲染的时间</li>
<li>Dom Ready：页面解析完成的时间</li>
<li>Time To Interact(TTI))：页面可交互时间</li>
<li>Total Blocking Time (TBT)：总阻塞时间，代表页面处于不可交互状态的耗时</li>
<li>First Input Delay(FID)：从用户首次交互，到浏览器响应的时间</li>
</ul>
</li>
<li>对性能数据进行目标和预期的确定：比如对比原先数据优化到多少比例，分析竞品确定目标</li>
</ol>
<ul>
<li>确定技术方案<ul>
<li>技术方案调研<ul>
<li>分析项目背景，挖掘项目痛点</li>
<li>分析项目现状</li>
<li>调研业界方案</li>
</ul>
</li>
<li>技术方案设计，方案选型&#x2F;对比<ol>
<li>梳理项目现状：比如项目规模大，开发多</li>
<li>梳理项目痛点：比如不同模块变更导致性能下降，问题往往在测试时才发现</li>
<li>调研性能分析方案：通过 Performace 火焰图、Lighthouse、Chrome Devtools Protocol 等工具</li>
<li>根据对比和分析确定最优方案，并跟领导解释</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h4><p>主要分析项目在开发过程中的效率提升点，学会如何在未来的项目中选择和搭建最适合自己的开发工具</p>
<h5 id="开发构建"><a href="#开发构建" class="headerlink" title="开发构建"></a>开发构建</h5><h5 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h5><p>当本地代码文件发生变化时，浏览器自动更新页面内容</p>
<p>webpack 热更新配置：</p>
<ul>
<li>手动配置</li>
<li>watch 模式，配置 watch:true，无需手动执行打包构建，但需要手动刷新浏览器</li>
<li>Live Reload 模式，配置 contentBase：文件路径，open：true，浏览器内容自动更新，但页面状态无法保存</li>
<li>Hot Module Replacement（HMR、 模块热替换），配置 hot: true</li>
</ul>
<p>模块热替换插件实现热替换功能，主要依赖 module.hot 的属性</p>
<ol>
<li>module.hot.accept(模块名称，回调方法)：当依赖模块发生更新时，执行回调方法</li>
<li>module.hot.dispose(回调方法)：当代码上下文的模块被移除时，执行回调方法</li>
</ol>
<p><strong>webpack 热更新原理</strong>：</p>
<ol>
<li>监控源代码文件内容的变更</li>
<li>进行服务端和网页端的 socket 通信</li>
<li>进行模块解析和替换，依次执行匹配 module.hot 对应 moduleId 的回调函数，进行热替换，若未命中，则触发重新加载</li>
</ol>
<h5 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h5><p>在调试时将产物代码显示回源代码</p>
<p>sourceMap 的基本原理：在编译处理过程中，产物代码在被转换时，与源码生成了映射关系表，利用这映射表来实现调试时的显示与定位源代码功能</p>
<p>在开发环境中，通常关注构建速度快、质量高，以便于提升开发效率，不关注生成文件的大小和访问方式，建议使用 cheap-module-source-map，可以在浏览器下看到正确的错误提示</p>
<p>在生产环境为了防止源码泄露，建议使用 false，不使用 source-map</p>
<h5 id="Mock-工具"><a href="#Mock-工具" class="headerlink" title="Mock 工具"></a>Mock 工具</h5><p>模拟数据的工具，用于测试或者预先联调</p>
<p>选择 Mock 方案需注重：</p>
<ul>
<li>仿真度：尽可能与后端实际提供接口的各方面保持一致</li>
<li>易用性：需要具备将接口文档自动转换为 Mock 接口的能力</li>
<li>灵活性：根据不同条件下返回值的差异做不同的交互处理</li>
</ul>
<p>四种主流 Mock 工具：</p>
<ul>
<li>Mock.js：Mock 数据生成工具<ul>
<li>提供生成模拟数据的规范和方法</li>
<li>Ajax 请求拦截：拦截特定 url 的请求，直接将模拟数据作为响应值返回</li>
<li>数据验证：验证指定数据和数据模板是否匹配</li>
<li>模板导出：将 Mock.js 风格的数据模板转换为 JSONSchema</li>
</ul>
</li>
<li>Faker.js：Mock 数据生成工具<ul>
<li>提供指定类型的随机数据</li>
<li>在 API 的使用方面较直观</li>
<li>支持多种语言的本地化包</li>
</ul>
</li>
<li>YApi：开发、产品、测试人员共同使用的接口管理服务<ul>
<li>支持接口的定义、修改、运行、集合测试等</li>
<li>提供 Mock 服务，以定义的接口可以通过服务直接获取 Mock 数据</li>
<li>支持 Swagger 多种接口描述的数据导入与导出</li>
<li>支持部署到内网服务以及自定义插件</li>
</ul>
</li>
<li>Apifox：桌面应用类的接口管理工具<ul>
<li>支持接口调试工具 Postman 的特色功能</li>
<li>对同一个接口支持多种用例管理</li>
<li>支持自定义期望数据，支持自定义占位符规则等</li>
<li>支持生成自动业务代码和接口请求代码，支持自定义代码模板等</li>
</ul>
</li>
</ul>
<h5 id="编码效率工具"><a href="#编码效率工具" class="headerlink" title="编码效率工具"></a>编码效率工具</h5><p><strong>使用预处理语言和预处理器</strong>：</p>
<ul>
<li>CSS 的主流预处理器：Less&#x2F;Sass&#x2F;Stylus<ul>
<li>使用人数从多到少排序：Sass &gt; Less&gt; Stylus</li>
<li>Less 缺少自定义函数的功能，Stylus 提供了超过 60 个内建函数</li>
<li>Sass 支持 .scss 与 .sass 两种文件格式，Less 的整体语法更接近 .scss，Stylus 则同时支持类似 .sass 的精简语法和普通 CSS 语法</li>
<li>sass-loader 和 stylus-loader 安装时都需要同时安装独立编译包 Sass &#x2F; node-sass 和 Stylus，而 less-loader 则不强制要求</li>
</ul>
</li>
<li>HTML 模板的主流预处理器：Pug</li>
</ul>
<p>功能：简化标签书写、支持迭代、条件、拓展、包含、混合等逻辑功能</p>
<p>Vue 内置 pug-loader 作为预处理器，React 需要通过 babel 插件获得支持</p>
<p><strong>使用代码生成工具</strong>：</p>
<ul>
<li>Snippet</li>
</ul>
<p>开发过程中用户在 IDE 使用的可复用代码片段</p>
<p>可编写自身开发常用的个性预设片段，提升编码效率</p>
<p>可以在团队中共享和共同维护，提升团队效率</p>
<ul>
<li>Emmet</li>
</ul>
<p>面向各类编辑器的 Web 开发插件，用于快速编写和编辑结构化的代码</p>
<p>支持功能：缩写代码块、CSS 缩写、自定义片段</p>
<h5 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h5><p>将开发环境托管至云服务，开发服务器变更为云服务</p>
<p>优点：</p>
<ul>
<li>集成开发环境所需基础设施，提升开发环境准备的效率</li>
<li>流程简化，易上手</li>
<li>统一流程规范、开发工具共享</li>
<li>提升资源利用率，降低硬件资产成本</li>
</ul>
<p>注意点：</p>
<ul>
<li>代码安全问题：设置访问权限，首选支持内部部署的云服务或者搭建自己维护的云服务</li>
<li>服务搭建与维护：考虑成本</li>
<li>服务降级与备份：考虑当系统异常时的策略</li>
</ul>
<h4 id="构建效率"><a href="#构建效率" class="headerlink" title="构建效率"></a>构建效率</h4><p>主要分析影响 webpack 构建时间的关键因素，并分析对应的解决方案和工具</p>
<h5 id="webpack-编译阶段提效"><a href="#webpack-编译阶段提效" class="headerlink" title="webpack 编译阶段提效"></a>webpack 编译阶段提效</h5><p><strong>减少执行构建的模块</strong></p>
<ul>
<li>ignorePlugin：剔除需要被排除的模块</li>
<li>按需引入库模块：减少执行模块，在导入声明时只导入依赖包内的特定模块</li>
<li>将项目依赖的框架等模块单独构建打包<ul>
<li>DllPlugin 和 DllReferencePlugin：独立的配置文件，包含依赖包的独立构建流程，无须更改引用依赖包的子模块</li>
<li>Externals：配置简单，使用已传入 CDN 的依赖包，配置的依赖包需要单独指定依赖模块的加载方式，将引用依赖包的子模块打入项目包中</li>
</ul>
</li>
</ul>
<p><strong>提升单个模块构建的速度</strong></p>
<ul>
<li>include&#x2F;exclude：include 只对符合条件的模块进行 loader 转换，而 exclude 相反，若出现冲突，优先 include</li>
<li>noParse：省略使用 js 模块编译器进行编译的时间</li>
<li>Source Map：本地调试时，显示回源代码的工具</li>
<li>TypeScript 编译优化：ts-loader 配合 transpileOnly: true，babel-loader 配合 @babel&#x2F;preset-typescript，两种形式都可配合使用 ForkTsCheckerWebpackPlugin将检查过程移至单独的进程，加快 TypeScript 的类型检查和 ESLint 插入的速度</li>
</ul>
<p><strong>并发构建（大中型项目的生产环境构建）</strong></p>
<ul>
<li>HappyPack 和 thread-loader：以开启多进程的方式加速编译特定 loader</li>
<li>parallel-webpack：实现不同配置的并行构建</li>
</ul>
<h5 id="webpack-打包阶段提效"><a href="#webpack-打包阶段提效" class="headerlink" title="webpack 打包阶段提效"></a>webpack 打包阶段提效</h5><p><strong>提升当前任务工作效率</strong></p>
<p>主要方式是压缩 Chunk 产物</p>
<ul>
<li>面向 JS 的压缩工具<ul>
<li>UglifyJSWebpackPlugin：早期压缩工具，基于 UglifyJS</li>
<li>TerserWebpackPlugin：基于 Terser，整体效率与质量略胜于 UglifyJSWebpackPlugin<ul>
<li>Cache 选项：默认开启，使用缓存能够极大程度上提升再次构建时的工作效率</li>
<li>Parallel 选项：默认开启，并发选项在大多数情况下能够提升该插件的工作效率</li>
<li>terserOptions 选项：对具体压缩处理过程产生影响，compress 参数用于执行特定的压缩策略，mangle 参数用于对源代码中的变量与函数名称进行压缩</li>
</ul>
</li>
</ul>
</li>
<li>面向 CSS 的压缩工具<ul>
<li>OptimizeCssAssetsPlugin：在 Create-React-App 中使用</li>
<li>OptimizeCssNanoPlugin：在 VUE-CLI 中使用</li>
<li>CSSMinimizerWebpackPlugin：2020 年 Webpack 社区新发布的 CSS 压缩插件，比起前两款压缩工具，它支持缓存和多进程，对项目构建效率影响明显，推荐使用</li>
</ul>
</li>
</ul>
<p><strong>提升后续环节工作效率</strong></p>
<ul>
<li>Split Chunks(分包)：将 Chunks 根据一定的规则分离出子 Chunk，通过分包来抽离多个入口点引用的公共依赖</li>
<li>Tree Shaking：在构建打包过程中，移除那些引入但未被使用的无效代码，影响因素包含:<ul>
<li>ES6 模块：只有 ES6 类型的模块才能进行Tree Shaking</li>
<li>引入方式：以 default 方式引入的模块，无法被 Tree Shaking，而引入单个导出对象的方式则可以</li>
<li>sideEffects：只有 sideEffects 为 false 的依赖包，才能进行Tree Shaking</li>
<li>Babel：在 Babel 7 之前的 babel-preset-env ，modules 选项默认为 commonjs，无法被 Tree Shaking，在 Babel 7 之后的 @babel&#x2F;preset-env，modules 选项默认为 auto，可以 Tree Shaking</li>
</ul>
</li>
</ul>
<h5 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h5><p><strong>基本原理</strong></p>
<p>初次构建的压缩代码过程中，结果会写入缓存目录，再次构建进行到压缩代码阶段时，即可对比读取缓存</p>
<p><strong>编译阶段的缓存优化</strong></p>
<ul>
<li>Babel-loader<ul>
<li>cacheDirectory：开启缓存</li>
<li>cacheIdentifier：计算缓存标识符</li>
<li>cacheCompression：将缓存内容压缩为 gz 包</li>
</ul>
</li>
<li>Cache-loader<ul>
<li>添加在 babel-loader 之前</li>
<li>对比 babel-loader，构建时间更短，存储的 Buffer 形式的数据处理效率更高</li>
</ul>
</li>
</ul>
<p><strong>打包阶段的缓存优化</strong></p>
<ul>
<li>生成 ChunksAsset 时的缓存优化：只有在 watch 模式下且配置开启 cache时才能执行缓存逻辑</li>
<li>代码压缩时的缓存优化<ul>
<li>JS 的压缩：TerserWebpackPlugin 和 UglifyJSPlugin 都支持缓存设置</li>
<li>CSS 的压缩：CSSMinimizerWebpackPlugin 默认开启缓存</li>
</ul>
</li>
<li>减少缓存的失效<ul>
<li>缓存标识符发生变化导致的缓存失效：尽可能地减少标识符变化</li>
<li>优化打包阶段的缓存失效：尽可能地把那些不变的处理成本高昂的模块打入单独的 Chunk 中，使用 splitChunks 优化缓存利用率</li>
</ul>
</li>
</ul>
<p><strong>其他使用缓存的注意事项</strong></p>
<ul>
<li>为保持 CI&#x2F;CD 中的持久化缓存，备份与还原.cache 文件</li>
<li>定期清理缓存区域</li>
</ul>
<h5 id="webpack-增量构建"><a href="#webpack-增量构建" class="headerlink" title="webpack 增量构建"></a>webpack 增量构建</h5><p>webpack 只编译打包改动的文件，并将编译后的代码推送到浏览器端</p>
<p><strong>影响因素</strong></p>
<ul>
<li>watch 配置</li>
</ul>
<p>使用 devServer 时，用于监控文件的变化</p>
<p>实现原理：构建完成并不自动退出，构建上下文的对象都可以保留在内存中，并在 rebuild 时重复使用</p>
<ul>
<li>cache配置</li>
</ul>
<p>用于使用缓存</p>
<p>实现原理：在编译阶段添加模块时，若命中缓存 module，则跳过该模块的编译过程，在创建 chunk 产物代码阶段，若命中缓存 chunk，则跳过该 chunk 的产物代码生成过程</p>
<p><strong>生产环境使用增量构建的阻碍</strong></p>
<ul>
<li>集成部署系统通常不可接受增量构建所需的保留进程和长时间占用内存</li>
<li>在生产环境下提升构建速度，需要将缓存写入到文件系统中，但 webpack4 的 cache 配置并不支持</li>
<li>webpack 5 已正式支持基于文件系统的持久化缓存</li>
</ul>
<h4 id="部署效率"><a href="#部署效率" class="headerlink" title="部署效率"></a>部署效率</h4><p>代码从构建到部署是前端能力的延申，学习如何提升自己前端项目的部署效率</p>
<h5 id="部署工具介绍"><a href="#部署工具介绍" class="headerlink" title="部署工具介绍"></a>部署工具介绍</h5><p>如果所在企业需要选择一款 CI&#x2F;CD 工具，需要考虑选择付费或免费系统，选择云服务还是自运维，是否需要对接上下游系统流程，使用配置是否便捷，对用户是否有学习成本，如下是四款工具简要介绍：</p>
<p><strong>Jenkins</strong></p>
<p>功能特点</p>
<ul>
<li>提供各系统搭建方式，提供基于 Docker 的容器化搭建方式</li>
<li>免费</li>
<li>多类型 Job</li>
<li>插件系统丰富</li>
<li>Job 配置灵活</li>
<li>提供 Restful 的 API 接口</li>
</ul>
<p>胜在插件系统丰富且完全开源免费</p>
<p>缺点是缺少语言环境工作流的模板，使用成本高，服务器需要独立部署和运维</p>
<p><strong>CircleCI</strong></p>
<p>功能特点</p>
<ul>
<li>基于云端的持续集成服务</li>
<li>免费版本受限制，收费提供更多功能</li>
<li>缓存依赖安装的数据</li>
<li>基于 SSH 访问构建容器</li>
<li>开箱即用，配置简化</li>
<li>提供 Restful 的 API 接口</li>
</ul>
<p>胜在对接 Github 中的项目，支持 BitBucket、Heroku 等平台的对接</p>
<p><strong>Github Actions</strong></p>
<p>功能特点</p>
<ul>
<li>多系统</li>
<li>矩阵运行</li>
<li>多语言</li>
<li>多容器测试</li>
<li>社区支持</li>
<li>公开仓库以及自运维执行器免费，私有仓库免费或收费</li>
</ul>
<p>胜在是 Github 内置的 CI&#x2F;CD 工具，使用成本最低，提供矩阵运行，多容器测试，多工作流模板等特色功能</p>
<p><strong>Gitlab CI</strong></p>
<p>功能特点</p>
<ul>
<li>多功能</li>
<li>免费的社区版本和免费或收费的商用版本</li>
<li>内置 CI&#x2F;CD 功能</li>
</ul>
<p>企业比较受欢迎的版本管理工具，Gitlab 内置的 CI&#x2F;CD 工具，使用 yml 的配置文件，但是要独立安装和配置执行器 Gitlab Runner</p>
<h5 id="流程策略优化"><a href="#流程策略优化" class="headerlink" title="流程策略优化"></a>流程策略优化</h5><p>项目部署流程包含获取代码、依赖安装、代码构建、产物打包、推送代码、重启服务，常见的流程策略优化主要是在依赖安装、代码构建、产物打包这三个阶段：</p>
<p><strong>依赖安装阶段的提效</strong></p>
<ul>
<li>提升依赖安装速度<ul>
<li>依赖包下载使用国内镜像</li>
<li>二进制下载源单独配置下载路径</li>
</ul>
</li>
<li>多项目共用缓存，最大化命中缓存<ul>
<li>依赖工具相同的项目使用相同服务器</li>
<li>技术栈相同的项目使用相同服务器</li>
</ul>
</li>
<li>安装目录缓存<ol>
<li>缓存写入：package-lock.json 文件的 hash 值作为缓存目录的 key 值，压缩 node_modules 文件存储在缓存目录中</li>
<li>缓存读取：判断 package-lock.json 文件的 hash 值是否命中缓存目录的 key 值，若命中则解压并使用缓存目录中的 node_modules 文件</li>
</ol>
</li>
<li>检查 lock 文件</li>
</ul>
<p>项目开发人员需保存和维护 lock 文件，在 CI 流程中检测 lock 文件</p>
<p><strong>代码构建阶段的提效</strong></p>
<p>保持 CI 流程中的项目持久化缓存：</p>
<ol>
<li>备份：在项目构建结束时，将 .cache 文件依据其相对项目根目录的路径生成备份目录名称</li>
<li>还原：再次重新构建时，查看备份空间是否存在对应项目的持久化缓存目录，若是则解析目录结构，将 .cache 文件还原到项目响应的目录中</li>
</ol>
<p><strong>产物打包阶段的提效</strong></p>
<p>考虑提升产物压缩效率，使用 Gzip&#x2F;Pigz&#x2F;Zstd</p>
<ul>
<li>压缩体积不大可使用 Gzip</li>
<li>Pigz 和 Zstd 都使用并行处理，CPU 和内存占用都比 Gzip 高</li>
<li>Pigz 产物与 Gzip 格式兼容，较广泛地作为 Gzip 的替代</li>
<li>Zstd 产物与 Gzip 格式不兼容，Zstd 产物在解压时也需要 Zstd，适合压缩和解压流程闭环的场景</li>
</ul>
<h5 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h5><p><strong>容器化基础概念</strong></p>
<ul>
<li>容器化：以 Docker 为代表，将操作系统内核虚拟化的技术</li>
<li>Docker：运行在 Windows&#x2F;linux&#x2F;macOS 中开源的虚拟化引擎，用于管理容器</li>
<li>镜像：用于创建容器实例的虚拟化模板</li>
<li>容器：Docker 的核心功能单元，包含一个或多个应用程序以及运行它们所需要的环境依赖</li>
<li>数据挂载：挂载容器的宿主环境目录</li>
<li>数据卷：由 Docker 创建的宿主环境下的独立磁盘空间</li>
</ul>
<p><strong>容器化构建部署</strong></p>
<p>把原先在部署服务器中执行的项目部署流程中的各个环节，改为使用容器化的技术来完成</p>
<ul>
<li>镜像操作阶段：创建工作镜像，包含特定版本的 node 环境、git、项目构建所需要的依赖库</li>
<li>操作容器阶段：基于工作镜像，创建容器，操作各部署环节</li>
</ul>
<p><strong>容器化部署优势</strong></p>
<ul>
<li>环境隔离：每个项目在独立的容器内执行构建部署过程</li>
<li>多环节构建：可针对同一个项目生成多套不同的构建过程</li>
<li>便于调试：可使用浏览器访问容器环境，有问题则可第一时间进入容器环境调试</li>
<li>环境一致性与迁移效率：工作环境一致，可以一键迁移</li>
</ul>
<p><strong>容器化部署的挑战与建议</strong></p>
<ul>
<li>缓存问题<ul>
<li>依赖缓存：缓存目录不互通，无法持久化缓存，通过挂载宿主环境依赖缓存目录，使用安装目录缓存等方式解决</li>
<li>构建缓存：缓存数据随着新容器部署而消失，通过在宿主环境中创建缓存目录并挂载到容器中，持久化数据的备份与还原等方式解决</li>
</ul>
</li>
<li>性能问题<ul>
<li>容器资源限制：容器创建时，CPU 核心数和内存大小受限制，通过更改设置，分配更多资源的方式解决</li>
<li>修改镜像层数据：如果涉及对镜像层数据的修改，比普通服务器消耗更多时间，所以尽可能避免将可变数据写入镜像中</li>
</ul>
</li>
</ul>
<h2 id="8-babel"><a href="#8-babel" class="headerlink" title="8 babel"></a>8 babel</h2><p>谈到前端工程化，脑海中就会浮现<code>Webpack</code>、<code>Eslint</code>、<code>Babel</code>、<code>Gulp</code>、<code>Rollup</code>等字眼，甚至还有<code>CI/CD</code>（持续集成&#x2F;持续部署）、自动化测试等高深概念。这篇文章将尝试用最简单的白话来了解Babel的概貌，认识Babel在前端工程流中的角色定位，以及基础用法，为之后的前端工程化深入学习做铺垫。</p>
<h3 id="概貌"><a href="#概貌" class="headerlink" title="概貌"></a>概貌</h3><p><strong>Babel 是什么？Babel 是一个 JavaScript 编译器。</strong></p>
<p>上面这句话就是Babel的本质，更简单的说，Babel可以把使用ES6&#x2F;ES7等“高级”语法编写的Javascript代码转换为ES5&#x2F;ES3的“通俗”语法（也可以把JSX语法转为Javascript）。</p>
<p>随着ECMAScript 标准规范发展越来越快，新语法层出不穷，然而浏览器更新却存在着滞后性，对ECMAScript新标准支持程度不一，Web前端开发者眼巴巴看着各种“高大上”、“简洁”、“实用”的语法和API，却不敢在实际项目中直接使用，以免由于浏览器不兼容导致各种问题，于是Babel诞生了！</p>
<p>从此以后，我们也可以尽情地使用“高大上”的ES6+高级语法了，只要经过Babel转换，最终输出的代码是啥样的我们不再那么关心，只要浏览器能读懂并执行就行。</p>
<p>也许你会担心经过Babel转换后的代码太过难以阅读，调试起来会非常困难。幸好Babel支持了一个叫做Source map的特性，使我们调试起来也和直接写ES5&#x2F;ES3代码的调试方式一样简单，而这对我们来说，只需要启用一个配置项就可以做到。</p>
<h3 id="Babel在前端工程流中的角色定位"><a href="#Babel在前端工程流中的角色定位" class="headerlink" title="Babel在前端工程流中的角色定位"></a>Babel在前端工程流中的角色定位</h3><p>我们知道，如今前端工程流中最耳熟能详的一个词是：<code>Webpack</code>. 现在很多前端项目脚手架都内置依赖了webpack，且提供了一套默认配置，做到开箱即用。我们只需要按照官网文档给出的步骤，一个命令一个命令去执行，如<code>npm run serve</code>、<code>npm run build</code>…，即可实现大部分开发场景需求，在需要定制化的情况下，甚至自己建一个<code>vue.config.js</code>文件去按照文档说明扩展配置即可，不再需要了解webpack的具体用法就能“叱咤Vue界”。</p>
<p>这是前端工程化发展的必然，有句话说得好，“懒人改变世界”，技术的发展造福了更多的懒人。在这样的大背景下，Webpack的细节被隐藏和弱化，更别提Babel了。我们可以在项目看到一个<code>.babelrc</code>文件，却大部分时间都不会注意到它，更别说打开它和编辑它了。</p>
<p>但就是这么一个低存在感的小透明，却承担起了巨大的责任，在背后默默工作，辛苦地把你新编写的ES6 <code>class</code>转换成了平凡的构造函数，在你<code>Ctrl + S</code>之后看到浏览器页面焕然一新的瞬间，你可会想到这个小透明做的事情有多么伟大？当然，这一切也离不开老大哥Webpack的提携，在Webpack的Loader机制下，Babel在这里作为<strong>Webpack loader角色</strong>的一员勤勤恳恳工作着。</p>
<p>除了作为Webpack loader，Babel当然也能孤军奋战，独当一面，文章后面将介绍Babel单独使用和结合Webpack使用两种用法。</p>
<h3 id="Babel工具集"><a href="#Babel工具集" class="headerlink" title="Babel工具集"></a>Babel工具集</h3><p>在使用Babel之前，我们先要知道Babel包含哪些东西，是的，它不是一个单一的工具，一开始它确实是一个单一的Javascript转换器，但现在它变成了一个工具集……别慌，它并没有因此变得很复杂，之所以这么设计是有原因的：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在<span class="hljs-keyword">Babel </span><span class="hljs-number">6</span>以前，<span class="hljs-keyword">Babel是一个专注且单一的Javascript转换器，然而Babel团队的志向不仅于此，更想把Babel打造成一个平台，由各个不同的功能模块和可插拔插件组成，用于创建下一代JavaScript工具集。</span><br><span class="hljs-keyword"></span>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>详见<a href="https://link.juejin.cn/?target=http://linyk.me/2017/03/31/babel-usage/">Babel 6.0之babel-cli和babel-core的用法和区别</a></p>
</blockquote>
<p>自Babel 7起，Babel团队改用作用域软件包，因此您现在必须使用<code>@babel/core</code>而不是<code>babel-core</code>.但实质上，<code>@babel/core</code>只是<code>babel-core</code>的较新版本。这样做是为了更好地区分哪些软件包是官方软件包，哪些是第三方软件包。</p>
<p>Babel7包含了核心包<code>@babel/core</code>、终端命令行界面工具<code>@babel/cli</code>以及各种语法转换规则包（官方称之为<code>preset</code>，即“预设”）如<code>@babel/preset-env</code>、<code>@babel/preset-react</code>、<code>@babel/preset-typescript</code>、<code>@babel/preset-flow</code>，这些都是按需安装使用的，后面介绍用法时你将了解它们的用途。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">在Babel 7之前，存在按年度区分的语法预设包如preset-es2015、preset-es2016、preset-es2017等，从Babel 7开始，Babel团队删除（并停止发布）了任何年度的preset（preset-es2015 等）， @babel/preset-env取代了对这些内容的需求，因为它包含了所有年度所添加内容以及针对特定浏览器集兼容的能力。<br>复制代码<br></code></pre></td></tr></table></figure>

<p>Babel工具集还包含一个叫做<code>@babel/polyfill</code>的库，作用是针对ES6+的一些新的内置API使用基础JS语法进行模拟实现，以适用较低版本的浏览器。而<code>@babel/core</code>只做语法（Syntax）转换（如class、箭头函数等），不实现Api polyfill。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript">polyfill在英文中有垫片的意思，意为兜底的东西。<br><br><span class="hljs-meta">@babel</span>/polyfill模拟一个完全的 <span class="hljs-title class_">ES2015</span>+ 的环境，实现了新的特性比如 <span class="hljs-title class_">Promise</span> 或者 <span class="hljs-title class_">WeakMap</span>， 静态方法比如<span class="hljs-title class_">Array</span>.<span class="hljs-property">from</span> 或 <span class="hljs-title class_">Object</span>.<span class="hljs-property">assign</span>, 实例方法 比如 <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">includes</span> 和 generator 函数。<br><br>从babel <span class="hljs-variable constant_">V7</span><span class="hljs-number">.4</span><span class="hljs-number">.0</span>版本开始，已经不建议使用该包，建议使用core-js/stable、regenerator-runtime/runtime替代。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>找个时间另外写一下这块的细节，可以先查阅官网文档<a href="https://link.juejin.cn/?target=https://babeljs.io/docs/en/babel-polyfill">@babel&#x2F;polyfill</a></p>
</blockquote>
<p>除此之外，这里简单提一下Babel插件（Plugin）的概念，不做深入。在Babel中，代码转换功能以插件的形式出现，插件是小型的 JavaScript 程序，用于指导 Babel 如何对代码进行转换。你甚至可以编写自己的插件将你所需要的任何代码转换功能应用到你的代码上。Babel插件分为语法插件和转换插件两种：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">语法插件：大多数语法都可以被 Babel 转换。在极少数情况下（如果转换还没有实现，或者没有默认的方式来实现），你可以使用语法插件，例如<span class="hljs-variable">@babel</span><span class="hljs-operator">/</span>plugin<span class="hljs-operator">-</span>syntax<span class="hljs-operator">-</span><span class="hljs-type">bigint</span>只允许 Babel解析特定类型的语法。<br><br>转换插件：转换您的代码，转换插件将启用相应的语法插件，因此您不必同时指定两者。<br>复制代码<br></code></pre></td></tr></table></figure>

<p>实际上Babel预设（Preset）就是一组Babel插件的集合，比如Babel 6.0中的 <code>babel-preset-es2015</code> 包含所有跟ES6转换有关的插件。如果没有预设，babel转化是需要指定用什么插件的，虽然颗粒度小，效率高，但是插件需要逐个安装，还有严格的配置声明顺序。本文后面不再深入叙述插件相关的概念，等有时间将写一篇文章进一步深入学习Babel的原理。</p>
<h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><h4 id="单独使用Babel"><a href="#单独使用Babel" class="headerlink" title="单独使用Babel"></a>单独使用Babel</h4><h5 id="babel-x2F-core-babel-x2F-cli-babel-x2F-preset-env"><a href="#babel-x2F-core-babel-x2F-cli-babel-x2F-preset-env" class="headerlink" title="@babel&#x2F;core + @babel&#x2F;cli + @babel&#x2F;preset-env"></a>@babel&#x2F;core + @babel&#x2F;cli + @babel&#x2F;preset-env</h5><p>Babel 的核心功能包含在 @babel&#x2F;core 模块中。通过以下命令安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev @babel/core<br>复制代码<br></code></pre></td></tr></table></figure>

<p>你也可以在 JavaScript 程序中直接 require 并使用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>);<br><br>babel.<span class="hljs-title function_">transformSync</span>(<span class="hljs-string">&quot;code&quot;</span>, optionsObject);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>一般情况下，如果单独使用Babel来完成整个工作流，我们会借助<code>@babel/cli</code>实现在终端（命令行）中快速使用babel命令进行代码转换。</p>
<p><code>@babel/cli</code> 是一个能够从终端（命令行）便捷使用<code>@babel/core</code>能力的工具。下面是其安装命令和基本用法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev @babel/core @babel/cli<br><br>./node_modules/.bin/babel src --out-dir lib<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>你可以利用 <a href="https://link.juejin.cn/?target=mailto:npm@5.2.0">npm@5.2.0</a> 所自带的 npm 包运行器将 <code>./node_modules/.bin/babel</code> 命令缩短为 <code>npx babel</code>. 后文将使用<code>npx</code>方式执行，不再赘述</p>
</blockquote>
<p>这将解析 src 目录下的所有 JavaScript 文件，并应用我们所指定的代码转换功能，然后把每个文件输出到 lib 目录下。<strong>由于我们还没有指定任何代码转换功能，所以输出的代码将与输入的代码相同（不保留原代码格式）</strong>。</p>
<p>实际场景中，我们还需要安装其他转换插件作为参数传递进去，将它们集成到 <code>@babel/core</code> 工作流程中，来实现我们所需的指定规则代码转换功能。我们将只使用 <code>@babel/preset-env</code> 这一个插件预设来实现我们的基础功能。</p>
<p>在上面的基础上，继续执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev @babel/preset-env<br><br>npx babel src --out-dir lib --presets=@babel/env<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上面相比于之前的执行多了一个传参<code>--presets=@babel/env</code>，这将告诉 <code>@babel/cli</code> 使用 <code>@babel/core</code> 结合 <code>@babel/preset-env</code> 预设进行代码转换，在通过命令行传递 <code>preset</code> 时，我们也可以指定该 <code>preset</code> 的一些相关参数，对转换后的代码进行细节上的控制（例如可以控制转换后的JS代码版本需要支持哪些浏览器），但是因为这样的话命令会显得很长且十分繁琐，我们更喜欢将这些参数以JSON的格式存放到一个固定的配置文件中。</p>
<p>现在，我们首先创建一个名为 <code>babel.config.json</code> 的文件（需要 v7.8.0 或更高版本），并包含如下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;targets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt; 0.25%, not dead&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>该配置表示仅包含浏览器市场份额 &gt;0.25％ 的用户所需的代码转换。</p>
<p>官方也建议使用.browserslistrc文件来代替targets的配置：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 0.25%</span><br>not dead<br>复制代码<br></code></pre></td></tr></table></figure>

<p>或者package.json：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;browserslist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt; 0.25%, not dead&quot;</span><br><span class="hljs-punctuation">&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>有了上述配置文件之后，我们只需要这么执行就可以了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx babel src --out-dir lib<br>复制代码<br></code></pre></td></tr></table></figure>

<p>Babel支持更多的配置方式，详见<a href="https://link.juejin.cn/?target=https://www.babeljs.cn/docs/usage">配置 Babel</a>，目前来说我们这么用就可以了。</p>
<h4 id="结合Webpack使用Babel"><a href="#结合Webpack使用Babel" class="headerlink" title="结合Webpack使用Babel"></a>结合Webpack使用Babel</h4><p>实际项目中单独使用Babel的命令行工具来实现工作流的情况不是很多，更多的是结合Webpack使用。</p>
<p>在webpack.config.js中添加以下loader配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">module:</span> &#123;<br>    <span class="hljs-attr">rules:</span> [<br>      &#123;<br>        <span class="hljs-attr">test:</span> <span class="hljs-string">/.js$/</span>,<br>        <span class="hljs-attr">exclude:</span> <span class="hljs-string">/node_modules/</span>,<br>        <span class="hljs-attr">use:</span> [<br>          &#123;<br>            <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>            <span class="hljs-attr">options:</span> &#123;<br>              <span class="hljs-attr">presets:</span> [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>]<br>            &#125;<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure>

<p>然后安装相应的依赖：babel-loader、@babel&#x2F;core、@babel&#x2F;preset-env:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev babel-loader @babel/core @babel/preset-env<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面是将babel的preset参数配置在了webpack.config.js中，实际上也可以将它按照babel配置文件的原则提取出来单独一个babel.config.json文件，效果是一样的。</p>
</blockquote>
<p>这样就完成了在webpack项目中添加Babel转换ES6+代码的功能。在webpack打包的过程中，会将源代码经由<code>babel-loader</code>处理转换为目标代码，这一执行过程对我们来只说是打包时“顺势而为”的，我们再也不用关心Babel本身的命令细节了。</p>
<h2 id="9-wasm"><a href="#9-wasm" class="headerlink" title="9 wasm"></a>9 wasm</h2><p>Web Assembly（缩写为WASM）是一种可移植的二进制代码格式，可以在现代Web浏览器中运行。它是一种低级别的汇编语言，可以被编译成适用于浏览器的二进制格式，并且可以在Web平台上与JavaScript一起使用。</p>
<p>Web Assembly的目标是通过提供比JavaScript更快的执行速度来改善Web应用程序的性能。与JavaScript相比，Web Assembly不是解释执行的，而是在浏览器中编译为机器码，并直接在浏览器的虚拟机中运行。这使得Web应用程序可以在近乎原生的速度下运行，从而使得计算密集型任务、游戏和多媒体应用程序等更加高效。</p>
<p>Web Assembly还具有可移植性、安全性和跨平台性等优点，因为它不依赖于特定的操作系统或硬件平台，并且可以与各种编程语言一起使用，包括C、C++、Rust和Python等。</p>
<p>Web Assembly已经被广泛应用于各种Web应用程序和游戏中，并且正在成为Web开发中的一个重要组成部分。</p>
<h2 id="10-esbuild为什么快"><a href="#10-esbuild为什么快" class="headerlink" title="10 esbuild为什么快"></a>10 esbuild为什么快</h2><ol>
<li>使用 Go 语言编写：Go 语言天生具有高并发和高性能的特性，而且它的编译速度非常快，这使得 esbuild 的性能表现非常优秀。</li>
<li>采用增量式的解析和构建：esbuild 在每次增量式地解析和构建时，会尽可能地复用已经存在的缓存，减少了不必要的重复工作，从而提高了构建速度。</li>
<li>并行处理和多线程：esbuild 在构建时会充分利用 CPU 的多核处理能力，将不同的任务分配到不同的线程中执行，从而提高了构建速度。</li>
<li>使用了高效的算法和数据结构：esbuild 在解析和构建时使用了一些高效的算法和数据结构，如字符串哈希表、按位运算等，从而进一步提高了构建速度。</li>
</ol>
<p>总的来说，esbuild 通过优化算法、数据结构、并行处理和多线程等方面，极大地提高了构建速度。同时，由于它使用 Go 语言编写，因此具有天生的高并发和高性能特性。</p>
<p> Vite 使用了 esbuild 进行快速的编译</p>
<h1 id="over-point"><a href="#over-point" class="headerlink" title="over point"></a>over point</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" class="category-chain-item">前端八股</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/blog/tags/%E8%AE%A1%E7%AE%97/">#计算</a>
      
        <a href="/blog/tags/%E5%B7%A5%E5%85%B7/">#工具</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端八股 ｜ 工具篇</div>
      <div>https://yoonalis.github.io/blog/2023/04/06/前端八股 ｜ 工具篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20React%E7%AF%87/" title="前端八股 ｜ react篇">
                        <span class="hidden-mobile">前端八股 ｜ react篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
