

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="react">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股 ｜ js篇">
<meta property="og:url" content="https://yoonalis.github.io/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9Cjs%E7%AF%87/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="react">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
<meta property="article:published_time" content="2023-04-06T13:31:21.932Z">
<meta property="article:modified_time" content="2023-04-12T01:36:20.075Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="计算">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>前端八股 ｜ js篇 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端八股 ｜ js篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-06 21:31" pubdate>
          2023年4月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          87k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          728 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端八股 ｜ js篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前端八股-｜js篇"><a href="#前端八股-｜js篇" class="headerlink" title="前端八股 ｜js篇"></a>前端八股 ｜js篇</h1><h2 id="1-promise的状态"><a href="#1-promise的状态" class="headerlink" title="1 promise的状态"></a>1 promise的状态</h2><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><ul>
<li><p><code>pending</code>准备 <code>fulfilled</code>成功 <code>rejected</code>失败</p>
</li>
<li><p><code>pengding</code>-&gt;<code>fulfilled/pending</code>-&gt;<code>rejected</code></p>
</li>
<li><p>变化是<strong>不可逆</strong>的</p>
</li>
<li><p><code>pending</code>准备, 不会触发<code>then</code>和<code>catch</code></p>
</li>
<li><p><code>fulfilled</code>成功, 会触发后续的<code>then</code>回调函数</p>
</li>
<li><p><code>rejected</code>失败，会触发后续的<code>catch</code>回调函数</p>
</li>
</ul>
<h3 id="promise-then和catch如何影响状态的转换"><a href="#promise-then和catch如何影响状态的转换" class="headerlink" title="promise then和catch如何影响状态的转换"></a>promise then和catch如何影响状态的转换</h3><ul>
<li><p><code>then</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></p>
</li>
<li><p><code>catch</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></p>
</li>
</ul>
<h3 id="详细示例"><a href="#详细示例" class="headerlink" title="详细示例"></a>详细示例</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/051337013f644284b053e0ef1f3027ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="904c4cc6978dae1ee0c0f3c9786f406b.png"></p>
<p>fulfilled成功, 会触发后续的then回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>p1 <span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: 100&#125;</span><br><br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data&#x27;</span>, data) <span class="hljs-comment">//data 100</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err) <span class="hljs-comment">//不会执行</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40b779de13ea43b3a1bbd91fb7c88210~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="52f0601bdab5958237ad3194175a9ff1.png"></p>
<p>rejected失败，会触发后续的catch回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err&#x27;</span>)<br>p2 <span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;err&#x27;&#125;</span><br><br>p2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data&#x27;</span>, data) <span class="hljs-comment">//不会执行</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err) <span class="hljs-comment">//err err</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8e269903b6841edbd620e60dc37f367~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="007fcce32cf178f2da15ae7759a4f23d.png"></p>
<h4 id="promise-then和catch如何影响状态的转换-1"><a href="#promise-then和catch如何影响状态的转换-1" class="headerlink" title="promise then和catch如何影响状态的转换"></a>promise then和catch如何影响状态的转换</h4><ul>
<li><code>then</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>         <span class="hljs-comment">//正常返回resolved</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;123&#x27;</span>)  <span class="hljs-comment">//123</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;then error&#x27;</span>)   <span class="hljs-comment">//then error</span><br>  <span class="hljs-comment">//报错返回rejected</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)  <span class="hljs-comment">//不执行无输出</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err100&#x27;</span>, err)  <span class="hljs-comment">//err100 err</span><br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><code>catch</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;my error&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)         <span class="hljs-comment">//正常返回resolved！触发then回调 </span><br>&#125;)<br>p3.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;123&#x27;</span>)  <span class="hljs-comment">//123</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;my error&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;catch error&#x27;</span>)   <span class="hljs-comment">//catch error</span><br>  <span class="hljs-comment">//报错返回rejected</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)  <span class="hljs-comment">//不执行无输出</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err100&#x27;</span>, err)  <span class="hljs-comment">//err100 err</span><br>&#125;) <span class="hljs-comment">//resolved的promise</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第一题</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//1</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//无报错不执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">//3</span><br>&#125;)<span class="hljs-comment">//resolved状态</span><br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第二题</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;erro1&#x27;</span>)  <span class="hljs-comment">//rejected状态</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//resolved状态</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)  <span class="hljs-comment">//2</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">//3</span><br>&#125;)<span class="hljs-comment">//resolved状态</span><br><br><span class="hljs-comment">//运行结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第三题</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;erro1&#x27;</span>)  <span class="hljs-comment">//rejected状态</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//resolved状态</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)  <span class="hljs-comment">//2</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">//无报错不执行</span><br>&#125;)<br><br><span class="hljs-comment">//运行结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="2-事件循环中的任务队列"><a href="#2-事件循环中的任务队列" class="headerlink" title="2 事件循环中的任务队列"></a>2 事件循环中的任务队列</h2><p>event loop都不陌生，是指主线程从“任务队列”中循环读取任务，比如</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">1</span>：<br><br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">//输出2,1</span><br></code></pre></td></tr></table></figure>

<p>在上述的例子中，我们明白首先执行主线程中的同步任务，当主线程任务执行完毕后，再从event loop中读取任务，因此先输出2，再输出1。</p>
<p>event loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。比如下面一个例子：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">2</span>：<br><br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>Promise.resolve().then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//输出为  1  2 3</span><br></code></pre></td></tr></table></figure>

<p>先输出1，没有问题，因为是同步任务在主线程中优先执行，这里的问题是setTimeout和Promise.then任务的执行优先级是如何定义的。</p>
<h3 id="Job-queue中的执行顺序"><a href="#Job-queue中的执行顺序" class="headerlink" title="Job queue中的执行顺序"></a>Job queue中的执行顺序</h3><p>在Job queue中的队列分为两种类型：macro-task和microTask。我们举例来看执行顺序的规定，我们设</p>
<p>macro-task队列包含任务: <em><strong>a1, a2 , a3</strong></em></p>
<p>micro-task队列包含任务: <em><strong>b1, b2 , b3</strong></em></p>
<p>执行顺序为，首先执行marco-task队列开头的任务，也就是 <em><strong>a1</strong></em> 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行<em><strong>b1, b2 , b3</strong></em>，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。</p>
<p>了解完了macro-task和micro-task两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：</p>
<p>macro-task队列真实包含任务：</p>
<p><em><strong>*script(主程序代码),setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering*</strong></em></p>
<p>micro-task队列真实包含任务：</p>
<p><em><strong>process.nextTick, Promises, Object.observe, MutationObserver</strong></em></p>
<p>由此我们得到的执行顺序应该为：</p>
<p><em><strong>script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I&#x2F;O——&gt;UI rendering</strong></em></p>
<p>在ES6中macro-task队列又称为ScriptJobs，而micro-task又称PromiseJobs</p>
<blockquote>
<p>定义promise的构造部分是同步的</p>
</blockquote>
<h3 id="真实环境中执行顺序的举例"><a href="#真实环境中执行顺序的举例" class="headerlink" title="真实环境中执行顺序的举例"></a>真实环境中执行顺序的举例</h3><h4 id="1-setTimeout和promise"><a href="#1-setTimeout和promise" class="headerlink" title="(1) setTimeout和promise"></a>(1) setTimeout和promise</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">3</span>:<br><br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>Promise.resolve().then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>我们先以第1小节的例子为例，这里遵循的顺序为：</p>
<p><em><strong>script(主程序代码)——&gt;promise——&gt;setTimeout</strong></em><br>对应的输出依次为：1 ——&gt;2————&gt;3</p>
<h4 id="2-process-nextTick和promise、setTimeout"><a href="#2-process-nextTick和promise、setTimeout" class="headerlink" title="(2) process.nextTick和promise、setTimeout"></a>(2) process.nextTick和promise、setTimeout</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例子<span class="hljs-number">4</span>：<br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>   resolve();<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)&#125;);<br><br>process.nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">//输出2,6,5,3,4,1</span><br></code></pre></td></tr></table></figure>

<p>这个例子就比较复杂了，这里要注意的一点在定义promise的时候，promise构造部分是同步执行的，这样问题就迎刃而解了。</p>
<p>首先分析Job queue的执行顺序：</p>
<p><em><strong>script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</strong></em></p>
<p>I) <em><strong>主体部分</strong></em>： 定义promise的构造部分是同步的，<br>因此先输出2 ，主体部分再输出6（同步情况下，就是严格按照定义的先后顺序）</p>
<p>II)<em><strong>process.nextTick</strong></em>: 输出5</p>
<p>III）<em><strong>promise</strong></em>： 这里的promise部分，严格的说其实是promise.then部分，输出的是3,4</p>
<p>IV) <em><strong>setTimeout</strong></em> ： 最后输出1</p>
<p>综合的执行顺序就是： 2——&gt;6——&gt;5——&gt;3——&gt;4——&gt;1</p>
<h4 id="3-更复杂的例子"><a href="#3-更复杂的例子" class="headerlink" title="(3)更复杂的例子"></a>(3)更复杂的例子</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>   setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;resolve()&#125;,<span class="hljs-number">0</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)&#125;);<br><br>process.nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//输出的是  2 6 5 1 3 4</span><br></code></pre></td></tr></table></figure>

<p>这种情况跟我们（2）中的例子，区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p>
<h2 id="2-1-事件循环"><a href="#2-1-事件循环" class="headerlink" title="2.1 事件循环"></a>2.1 事件循环</h2><h3 id="一、什么是事件循环机制？"><a href="#一、什么是事件循环机制？" class="headerlink" title="一、什么是事件循环机制？"></a>一、什么是事件循环机制？</h3><blockquote>
<p>在介绍事件循环机制之前，我们要首先了解以下什么是事件循环机制，我们首先看下下面这段代码的执行顺序，正确的执行顺序应该是序号1&gt;3&gt;2 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c17a2aaa70db4ecc92b809cfcdca68aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
</blockquote>
<h4 id="为什么是上面的顺序呢？"><a href="#为什么是上面的顺序呢？" class="headerlink" title="为什么是上面的顺序呢？"></a>为什么是上面的顺序呢？</h4><p>原因是JS引擎指向代码是从上往下执行的，所以首先会执行序号1这个语句，JS引擎会将这个语句放在调用栈当中，然后执行代码，将序号1打印在控制台当中，当这段代码执行完毕之后，便将这段代码从调用栈中移出去。然后开始执行后续的代码，此时setTimeout这段代码进入调用栈，这段代码，会调用Web API,2秒之后进入callback队列，此时JS引擎将setTimeout移出调用栈，继续执行后面的代码，所以屏幕上会先打印出序号1,3，此时eventLoop登场了，它会不断循环的访问callbackqueue，等2s之后Web API会将要执行的打印序号2这句话放入callbackqueue,eventLoop将callbackQueue中的内容放入调用栈，开始执行，然后屏幕上打印出序号2，这就是eventLoop的基本流程。</p>
<h4 id="执行顺序图解"><a href="#执行顺序图解" class="headerlink" title="执行顺序图解"></a>执行顺序图解</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c6930751a54d9895360c62e3acefef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="引出事件循环是什么"><a href="#引出事件循环是什么" class="headerlink" title="引出事件循环是什么"></a>引出事件循环是什么</h4><blockquote>
<p>JS的运行机制就是事件循环!</p>
</blockquote>
<h3 id="二、JS的执行顺序是什么？"><a href="#二、JS的执行顺序是什么？" class="headerlink" title="二、JS的执行顺序是什么？"></a>二、JS的执行顺序是什么？</h3><ol>
<li>JS是从上到下一行一行执行。</li>
<li>如果某一行执行报错，则停止执行下面的代码。</li>
<li>先执行同步代码，再执行异步代码</li>
</ol>
<h3 id="三、事件循环的执行过程"><a href="#三、事件循环的执行过程" class="headerlink" title="三、事件循环的执行过程"></a>三、事件循环的执行过程</h3><ul>
<li>同步代码，调用栈执行后直接出栈</li>
<li>异步代码，放到Web API中，等待时机，等合适的时候放入回调队列（callbackQueue），等到调用栈空时eventLoop开始工作，轮询</li>
<li>微任务执行时机比宏任务要早 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/470b695effb04555928976504bb518c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></li>
<li>微任务在DOM渲染前触发，宏任务在DOM渲染后触发</li>
</ul>
<h3 id="四、微任务和宏任务的根本区别"><a href="#四、微任务和宏任务的根本区别" class="headerlink" title="四、微任务和宏任务的根本区别"></a>四、微任务和宏任务的根本区别</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26921231cd26436a905314af789d45b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></h4><ul>
<li>微任务是由ES6语法规定的</li>
<li>宏任务是由浏览器规定的</li>
</ul>
<h3 id="五、事件循环的整体流程"><a href="#五、事件循环的整体流程" class="headerlink" title="五、事件循环的整体流程"></a>五、事件循环的整体流程</h3><ol>
<li>先清空call stack中的同步代码</li>
<li>执行微任务队列中的微任务</li>
<li>尝试DOM渲染</li>
<li>触发Event Loop反复询问callbackQueue中是否有要执行的语句，有则放入call back继续执行 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97161f74e2e7494bad644e28e22bcf4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></li>
</ol>
<h3 id="六、事件循环经典案例"><a href="#六、事件循环经典案例" class="headerlink" title="六、事件循环经典案例"></a>六、事件循环经典案例</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd9cfac79eb4e0896b82f2ae4074d6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h2 id="3-箭头函数和普通函数的区别"><a href="#3-箭头函数和普通函数的区别" class="headerlink" title="3 箭头函数和普通函数的区别"></a>3 箭头函数和普通函数的区别</h2><p><strong>1 语法更加简洁、清晰</strong></p>
<p>箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</p>
<p><strong>2 箭头函数没有 prototype (原型)，所以箭头函数本身没有this</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 箭头函数</span><br>let a = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.prototype); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.prototype); <span class="hljs-comment">// &#123;constructor:f&#125;复制代码</span><br></code></pre></td></tr></table></figure>

<p><strong>3 箭头函数不会创建自己的this</strong></p>
<p>箭头函数没有自己的this，箭头函数的this指向在定义（<strong>注意：</strong>是定义时，不是调用时）的时候继承自外层第一个普通函数的this。所以，箭头函数中 <code>this </code>的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// undefined</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this); <span class="hljs-comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span><br>  &#125;,<br>  <span class="hljs-attr">c</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// 10</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this); <span class="hljs-comment">// &#123;a: 10, b: ƒ, c: ƒ&#125;</span><br>  &#125;<br>&#125;<br>obj.b(); <br>obj.c();复制代码<br></code></pre></td></tr></table></figure>

<p><strong>4 call | apply | bind 无法改变箭头函数中this的指向</strong></p>
<p><code>call | apply | bind</code>方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数<code>this</code>的指向。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> id = <span class="hljs-number">10</span>;<br>let <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-params">()</span></span> =&gt; &#123;<br>    console.log(<span class="hljs-keyword">this</span>.id)<br>&#125;;<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 10</span><br><span class="hljs-keyword">fun</span>.call(&#123; id: <span class="hljs-number">20</span> &#125;);     <span class="hljs-comment">// 10</span><br><span class="hljs-keyword">fun</span>.apply(&#123; id: <span class="hljs-number">20</span> &#125;);    <span class="hljs-comment">// 10</span><br><span class="hljs-keyword">fun</span>.bind(&#123; id: <span class="hljs-number">20</span> &#125;)();   <span class="hljs-comment">// 10复制代码</span><br></code></pre></td></tr></table></figure>

<p><strong>5 箭头函数不能作为构造函数使用</strong></p>
<p>我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。</p>
<p>但是！！因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">Fun</span> = (<span class="hljs-params">name, age</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fun</span>(<span class="hljs-string">&#x27;dingFY&#x27;</span>, <span class="hljs-number">24</span>);复制代码<br></code></pre></td></tr></table></figure>

<p><strong>6 箭头函数不绑定arguments，取而代之用rest参数…代替arguments对象，来访问箭头函数的参数列表</strong></p>
<p>箭头函数没有自己的<code>arguments</code>对象。在箭头函数中访问<code>arguments</code>实际上获得的是外层局部（函数）执行环境中的值。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params">a</span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arguments);<br>&#125;<br>A(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);  <span class="hljs-comment">//  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><br><span class="hljs-comment">// 箭头函数</span><br>let B = <span class="hljs-function">(<span class="hljs-params">b</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arguments);<br>&#125;<br>B(<span class="hljs-number">2</span>,<span class="hljs-number">92</span>,<span class="hljs-number">32</span>,<span class="hljs-number">32</span>);   <span class="hljs-comment">// Uncaught ReferenceError: arguments is not defined</span><br><br><span class="hljs-comment">// rest参数...</span><br>let C = <span class="hljs-function">(<span class="hljs-params">...c</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(c);<br>&#125;<br>C(<span class="hljs-number">3</span>,<span class="hljs-number">82</span>,<span class="hljs-number">32</span>,<span class="hljs-number">11323</span>);  <span class="hljs-comment">// [3, 82, 32, 11323]复制代码</span><br></code></pre></td></tr></table></figure>

<p><strong>7 箭头函数不能用作Generator函数，不能使用yield关键字</strong></p>
<h2 id="4-js的设计模式"><a href="#4-js的设计模式" class="headerlink" title="4 js的设计模式"></a>4 js的设计模式</h2><p>我们经常听到一句话，“写代码要有良好的封装，要高内聚，低耦合”。究竟怎样的代码才算得上是良好的代码。</p>
<p><strong>什么是高内聚，低耦合？</strong></p>
<p>即五大基本原则（SOLID）的简写</p>
<ul>
<li><p><strong>高</strong>层模块不依赖底层模块，即为依赖反转原则。</p>
</li>
<li><p><strong>内</strong>部修改关闭，外部扩展开放，即为开放封闭原则。</p>
</li>
<li><p><strong>聚</strong>合单一功能，即为单一功能原则。</p>
</li>
<li><p><strong>低</strong>知识要求，对外接口简单，即为迪米特法则。</p>
</li>
<li><p><strong>耦</strong>合多个接口，不如独立拆分，即为接口隔离原则。</p>
</li>
<li><p><strong>合</strong>成复用，子类继承可替换父类，即为里式替换原则</p>
</li>
</ul>
<p><strong>我们为什么要封装代码？</strong></p>
<p>其实封装代码有这些好处：</p>
<ol>
<li><p>良好的封装，不会让内部变量污染外部</p>
</li>
<li><p>封装好的代码可以作为一个模块给外部调用。外部无需了解细节，只需按约定的规范调用。</p>
</li>
<li><p>对扩展开放，对修改关闭，即开放关闭原则。外部不能修改内部代码，保证了内部的正确性；又留出扩展接口，提高了灵活性。</p>
</li>
</ol>
<p>我们可以观察React、Vue、EventEmitter、Axios等等这些优秀的源码，会发现其实他们封装的模块都是有迹可循的。这些规律总结起来就是设计模式。</p>
<h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a><strong>什么是设计模式？</strong></h3><p>借用鲁迅先生说过的一句话，世上本没有路，走的人多了也便成了路。所谓设计模式，是前辈们总结下来的，在软件设计、开发过程中，针对特定场景、特定问题的较优解决方案。</p>
<h3 id="为什么需要设计模式？"><a href="#为什么需要设计模式？" class="headerlink" title="为什么需要设计模式？"></a><strong>为什么需要设计模式？</strong></h3><p>实际上，不使用设计模式，照样可以进行需求开发。但是这造成的后果是：因设计缺陷、代码实现缺陷，给后期维护、开发、迭代带来了麻烦。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式一共分为3大类23种，主要介绍常用的几种</p>
<table>
<thead>
<tr>
<th>模式类型</th>
<th>设计模式</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式</td>
<td>单例模式、工厂模式、建造者模式</td>
</tr>
<tr>
<td>结构型模式</td>
<td>适配器模式、装饰器模式、代理模式</td>
</tr>
<tr>
<td>行为型模式</td>
<td>策略模式、观察者模式、发布订阅模式、职责链模式、中介者模式</td>
</tr>
</tbody></table>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式：一个类只有一个实例，并提供一个访问他的全局访问点。</p>
<ul>
<li><p><code>Singleton</code> ：特定类，这是我们需要访问的类，访问者要拿到的是它的实例；</p>
</li>
<li><p><code>instance</code> ：单例，是特定类的实例，特定类一般会提供 <code>getInstance</code> 方法来获取该单例；</p>
</li>
<li><p><code>getInstance</code> ：获取单例的方法；</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7033d67edc4d7c813ea723f69a00fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">let</span> _instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Singleton</span>.<span class="hljs-property">_instance</span>) &#123;<br>          <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>()<br>        &#125;<br>        <span class="hljs-comment">// 如果这个唯一的实例已经存在，则直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">_instance</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>()<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)  <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="源码实例"><a href="#源码实例" class="headerlink" title="源码实例"></a>源码实例</h4><p>Vuex 源码中的单例模式</p>
<p>Vuex：实现了一个全局的store用来存储应用的所有状态。这个store的实现就是单例模式的典型应用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 安装vuex插件</span><br>Vue.<span class="hljs-keyword">use</span>(Vuex)<br><br><span class="hljs-comment">// store注入Vue实例</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    el:<span class="hljs-string">&quot;<span class="hljs-subst">$app</span>&quot;</span>,<br>    store<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过调用<code>Vue.use</code>方法，安装Vuex插件。Vuex插件本质上是一个对象，内部实现了一个<code>install</code>方法，这个方法在插件安装时被调用，从而把<code>Store</code>注入到<code>Vue</code>实例中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Vue</span> <span class="hljs-comment">// instance 实例</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">install</span> (_Vue) &#123;<br>  <span class="hljs-comment">// 判断传入的Vue实例对象是否已经被install过（是否有了唯一的state）</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Vue</span> &amp;&amp; _Vue === <span class="hljs-title class_">Vue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<br>        <span class="hljs-string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span><br>      )<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 若没有，则为这个Vue实例对象install一个唯一的Vuex</span><br>  <span class="hljs-title class_">Vue</span> = _Vue<br>  <span class="hljs-comment">// 将Vuex的初始化逻辑写进Vue的钩子函数里</span><br>  <span class="hljs-title function_">applyMixin</span>(<span class="hljs-title class_">Vue</span>)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过这种方式，可以保证一个 Vue 实例只会被 install 一次 Vuex 插件，所以每个 Vue 实例只会拥有一个全局的 Store。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong> 节约资源，保证访问的一致性。</p>
<p><strong>缺点：</strong> 扩展性不友好，因为单例模式一般自行实例化，没有接口。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li><p>如果一个类实例化过程消耗资源比较多，可以使用单例避免性能浪费</p>
</li>
<li><p>需要公共状态，可以使用单例保证访问一致性。</p>
</li>
</ol>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式：根据不同的参数，返回不同类的实例。</p>
<p>核心思想：将对象的创建与对象的实现分离。实现复杂，但使用简单。工厂会给我们提供一个工厂方法，我们直接去调用即可。</p>
<ul>
<li><p>Visitor ：访问者，访问工厂方法。</p>
</li>
<li><p>Factory ：工厂，负责返回产品实例；</p>
</li>
<li><p>Product ：产品，访问者从工厂拿到的产品实例；</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67656a1ee68e4428bfb22517e0ea4174~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="🌰-例子"><a href="#🌰-例子" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>我们去环球影城的餐厅吃饭，点了一份“牛肉拉面”、“馄饨云吞面”，面煮好了，就直接端到桌子上，我们只管吃，不用在乎煮面的过程。</p>
<p>这个过程中，我们扮演访问者的角色，餐厅扮演的就是工厂的角色，“xxx”面就是产品。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Restaurant</span>&#123;<br>    <span class="hljs-keyword">constructor</span>()&#123;<br>        <span class="hljs-keyword">this</span>.menuData = &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 获取菜品</span><br>    getDish(dish)&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.menuData[menu])&#123;<br>            console.log(<span class="hljs-string">&quot;菜品不存在，获取失败&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.menuData[menu];<br>    &#125;,<br>    <span class="hljs-comment">// 添加菜品</span><br>    addMenu(menu,description)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.menuData[menu])&#123;<br>            console.log(<span class="hljs-string">&quot;菜品已存在，请勿重复添加&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.menuData[menu] = menu;<br>    &#125;<br>    <span class="hljs-comment">// 移除菜品</span><br>    removeMenu(menu)&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.menuData[menu])&#123;<br>            console.log(<span class="hljs-string">&quot;菜品不存在，移除失败&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        delete <span class="hljs-keyword">this</span>.menuData[menu];<br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dish</span>&#123;<br>    <span class="hljs-keyword">constructor</span>(name,description)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.description = description;<br>    &#125;<br>    <br>    eat()&#123;<br>        console.log(`I<span class="hljs-string">&#x27;m eating $&#123;this.name&#125;,it&#x27;</span>s $&#123;`<span class="hljs-keyword">this</span>.description);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这些场景都有一些特点：使用者只需要知道产品名字就可以拿到实例，不关心创建过程。所以我们可以把复杂的过程封装在一块，更便于使用。</p>
<h4 id="源码实例-1"><a href="#源码实例-1" class="headerlink" title="源码实例"></a>源码实例</h4><p>Vue、React 源码中的工厂模式</p>
<blockquote>
<p><code>document.createElement</code> 创建 <code>DOM</code> 元素。这个方法采用的就是工厂模式，方法内部很复杂，但外部使用很简单。只需要传递标签名，这个方法就会返回对应的 <code>DOM</code> 元素。</p>
</blockquote>
<p>和原生的 <code>document.createElement</code> 类似，<code>Vue</code> 和 <code>React</code> 这种具有虚拟 <code>DOM</code> 树机制的框架在生成虚拟 <code>DOM</code> 的时候，都提供了 <code>createElement</code> 方法用来生成 <code>VNode</code>，用来作为真实 DOM 节点的映射。上面实现一致，调用<code>createEle``ment</code>后，返回<code>VNode</code>元素。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 使用</span><br><span class="hljs-built_in">ccreateElement</span>(<span class="hljs-string">&#x27;h3&#x27;</span>, &#123; <span class="hljs-keyword">class</span>: <span class="hljs-string">&#x27;main-title&#x27;</span> &#125;, [<br>    <span class="hljs-built_in">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>, &#123; <span class="hljs-keyword">class</span>: <span class="hljs-string">&#x27;main-content&#x27;</span> &#125;, <span class="hljs-string">&#x27;真有意思&#x27;</span>)<br>])<br>复制代码<br><span class="hljs-comment">// 函数大致结构如下</span><br><span class="hljs-function"><span class="hljs-keyword">export</span> function <span class="hljs-title">createElement</span><span class="hljs-params">(tag,data,children)</span></span>&#123;<br>    <span class="hljs-comment">//....各种判断 判断生成什么样的Vnode</span><br>    <span class="hljs-keyword">if</span>(!tag)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">createEmptyVNode</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VNode</span>(tag,data,children);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>Vue-Router 源码中的工厂模式</p>
<p><code>vue-router</code> 中使用了工厂模式的思想来获得响应路由控制类的实例，<code>this.history</code> 用来保存路由实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span>&#123;<br>    <span class="hljs-title function_">constructotr</span>(<span class="hljs-params">options</span>)&#123;<br>        <span class="hljs-keyword">const</span> mode = options.<span class="hljs-property">mode</span> || <span class="hljs-string">&quot;hash&quot;</span>;<br>        <span class="hljs-keyword">switch</span> (mode) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;history&#x27;</span>:<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTML5History</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hash&#x27;</span>:<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashHistory</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">fallback</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;abstract&#x27;</span>:<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractHistory</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-attr">default</span>:<br>                <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>                  <span class="hljs-title function_">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">`invalid mode: <span class="hljs-subst">$&#123;mode&#125;</span>`</span>)<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p>
<ol>
<li><p>良好的封装，访问者无需了解创建过程，代码结构清晰。</p>
</li>
<li><p>扩展性良好，通过工厂方法隔离了用户和创建流程，符合开闭原则。</p>
</li>
<li><p>解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流；</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<p>给系统增加了抽象性，带来了额外的系统复杂度，不能滥用。（合理抽象能提高系统维护性，但可能会提高阅读难度，还是需要合理看待）</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>对象创建比较复杂，访问者无需了解创建过程。</p>
</li>
<li><p>需要处理大量具有相同&#x2F;类似属性的小对象。</p>
</li>
</ul>
<p>滥用只是增加了不必要的系统复杂度，过犹不及。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式：用于解决兼容问题，接口&#x2F;方法&#x2F;数据不兼容，将其转换成访问者期望的格式进行使用。</p>
<p>生活案例：</p>
<ol>
<li><p>耳机转接线。圆孔耳机插不进TypeC的手机里，只需一个TypeC转接头，此时TypeC转接头就是“适配器”。</p>
</li>
<li><p>翻译官。老板张三去国外谈业务，带上翻译官李四，李四这个时候就是作为不同语言的人之间交流的“适配器”。</p>
</li>
</ol>
<p>场景特点：</p>
<ol>
<li><p>同时存在多种格式，旧有接口格式不满足现在需要。</p>
</li>
<li><p>增加适配器可以更好使用旧接口。</p>
</li>
</ol>
<p>适配器模式必须包含目标（Target）、源（Adaptee）和适配器（Adapter）三个角色。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfd83567b2b9432f92eced319ba60064~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="🌰-例子-1"><a href="#🌰-例子-1" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>场景：我们要获取通过多个接口获取列表数据，拼接在一起，在一个组件内进行展示。因历史遗留原因，这些列表数据的格式不太一样。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">格式</span> <span class="hljs-number">1</span><br>&#123;<br>    <span class="hljs-attr">book_id:</span> <span class="hljs-number">1001</span><br>    <span class="hljs-attr">status:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">create:</span> <span class="hljs-string">&#x27;2021-12-12 08:10:20&#x27;</span>,<br>    <span class="hljs-attr">update:</span> <span class="hljs-string">&#x27;2022-01-15 09:00:00&#x27;</span>,<br>&#125;<span class="hljs-string">,</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">格式</span> <span class="hljs-number">2</span><br>&#123;<br>    <span class="hljs-attr">id:</span> <span class="hljs-number">1002</span><br>    <span class="hljs-attr">status:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">createTime:</span> <span class="hljs-number">16782738393022</span>,<br>    <span class="hljs-attr">updateAt:</span> <span class="hljs-string">&#x27;2022-01-15 09:00:00&#x27;</span>,<br>&#125;<span class="hljs-string">,</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">格式</span> <span class="hljs-number">3</span><br>&#123;<br>    <span class="hljs-attr">book_id:</span> <span class="hljs-number">1003</span><br>    <span class="hljs-attr">status:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">createTime:</span> <span class="hljs-number">16782738393022</span>,<br>    <span class="hljs-attr">updateAt:</span> <span class="hljs-number">16782738393022</span>,<br>&#125;<br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure>

<p>三个数据来源，三种时候数据结构，这时候我们有几种实现方式。</p>
<ol>
<li><p>组件针对不同的数据来源分别采用不同的渲染。（需要对数据类型进行区分）</p>
</li>
<li><p>在外部将数据转换成一种数据格式的列表传入，组件单一职责：展示。</p>
</li>
</ol>
<p><strong>对比之下，使用适配器模式</strong> <strong>，将不同的数据结构适配成展示组件所能接受的数据结构。保持了组件的单一职责，更优。</strong></p>
<ol>
<li>定义一个统一的数据结构</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> bookData &#123;<br>  <span class="hljs-attr">book_id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">createAt</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 时间戳</span><br>  <span class="hljs-attr">updateAt</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 时间戳</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<ol>
<li>通过适配器模块，适配成访问者所要数据格式</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> bookDataType1 &#123;<br>  <span class="hljs-attr">book_id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">create</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">update</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> bookDataType2 &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">createTime</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">updateAt</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> bookDataType3 &#123;<br>  <span class="hljs-attr">book_id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">createTime</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">updateAt</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> getTimeStamp = <span class="hljs-keyword">function</span> (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-comment">//.....转化成时间戳</span><br>  <span class="hljs-keyword">return</span> timeStamp;<br>&#125;;<br><br><span class="hljs-comment">//适配器</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bookDataAdapter = &#123;<br>  <span class="hljs-title function_">adapterType1</span>(<span class="hljs-params">list: bookDataType1[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">bookDataList</span>: bookData[] = list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">book_id</span>: item.<span class="hljs-property">book_id</span>,<br>        <span class="hljs-attr">status</span>: item.<span class="hljs-property">status</span>,<br>        <span class="hljs-attr">createAt</span>: <span class="hljs-title function_">getTimeStamp</span>(item.<span class="hljs-property">create</span>),<br>        <span class="hljs-attr">updateAt</span>: <span class="hljs-title function_">getTimeStamp</span>(item.<span class="hljs-property">update</span>),<br>      &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bookDataList;<br>  &#125;,<br><br>  <span class="hljs-title function_">adapterType2</span>(<span class="hljs-params">list: bookDataType2[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">bookDataList</span>: bookData[] = list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">book_id</span>: item.<span class="hljs-property">id</span>,<br>        <span class="hljs-attr">status</span>: item.<span class="hljs-property">status</span>,<br>        <span class="hljs-attr">createAt</span>: item.<span class="hljs-property">createTime</span>,<br>        <span class="hljs-attr">updateAt</span>: <span class="hljs-title function_">getTimeStamp</span>(item.<span class="hljs-property">updateAt</span>),<br>      &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bookDataList;<br>  &#125;,<br><br>  <span class="hljs-title function_">adapterType3</span>(<span class="hljs-params">list: bookDataType3[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">bookDataList</span>: bookData[] = list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">book_id</span>: item.<span class="hljs-property">book_id</span>,<br>        <span class="hljs-attr">status</span>: item.<span class="hljs-property">status</span>,<br>        <span class="hljs-attr">createAt</span>: item.<span class="hljs-property">createTime</span>,<br>        <span class="hljs-attr">updateAt</span>: item.<span class="hljs-property">updateAt</span>,<br>      &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bookDataList;<br>  &#125;,<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<ol>
<li>将数据经过适配器处理后进行整合，组件展示</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini">//整合数据<br>const <span class="hljs-attr">bookDataList</span> = [<br>  ...bookDataAdapter.adapterType1(type1MatailList),<br>  ...bookDataAdapter.adapterType2(type2MatailList),<br>  ...bookDataAdapter.adapterType3(type3MatailList),<br>]<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong> 可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；</p>
<p><strong>缺点：</strong> 会让系统变得零乱，明明调用 A，却被适配到了 B，如果滥用，那么对可阅读性不太友好。</p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>想要使用一个已经存在的对象，但是接口不满足需求，那么可以使用适配器模式转换成你需要的接口。</p>
</li>
<li><p>想要创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式。</p>
</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式：在不改变原对象的基础上，增加新属性&#x2F;方法&#x2F;功能。</p>
<p>一个对象被另一个对象包装，形成一条包装链，在原对象上增加功能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d0be5497afe4939b943d833583734b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="🌰-例子-2"><a href="#🌰-例子-2" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>暂时想不到什么好的例子和实际应用场景。</p>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p>
<ol>
<li>对象的核心职责和装饰功能区分开，可以通过动态增删装饰去除目标对象中的装饰逻辑。</li>
</ol>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式：定义一系列算法，根据输入的参数决定使用哪个算法。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/434302b146e040f4ac562413fb230282~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>重点：算法的实现和算法的使用分开。</strong></p>
<ul>
<li><p>Context ：封装上下文，根据需要调用需要的策略，屏蔽外界对策略的直接调用，只对外提供一个接口，根据需要调用对应的策略；</p>
</li>
<li><p>Strategy ：策略，含有具体的算法，其方法的外观相同，因此可以互相代替；</p>
</li>
<li><p>StrategyMap ：所有策略的合集，供封装上下文调用；</p>
</li>
</ul>
<h4 id="🌰-例子-3"><a href="#🌰-例子-3" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>场景：双十一满减活动。满200-20、满300-50、满500-100。这个需求，怎么写？</p>
<p><strong>if-else暴力法直接梭哈。</strong></p>
<p>通过判断输入的折扣类型来计算商品总价的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">priceCalculate</span>(<span class="hljs-params">discountType,price</span>)&#123;<br>    <span class="hljs-keyword">if</span>(discountType === <span class="hljs-string">&#x27;discount200-20&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">200</span>) * <span class="hljs-number">20</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(discountType === <span class="hljs-string">&#x27;discount300-50&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">300</span>) * <span class="hljs-number">50</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(userType === <span class="hljs-string">&#x27;discount500-100&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">500</span>) * <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li><p>随着折扣类型的增加，<code>if-else</code>会变得越来越臃肿。</p>
</li>
<li><p>折扣活动算法改变或折扣类型增加时，都需要改动<code>priceCalculate</code>方法，违反开闭原则。</p>
</li>
<li><p>复用性差，如果其他地方有类似的算法，但规则不一样，上述代码不能复用。</p>
</li>
</ol>
<p><strong>使用策略模式对代码改写</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 算法的实现</span><br><span class="hljs-keyword">const</span> discountMap = &#123;<br>    <span class="hljs-string">&#x27;discount200-20&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price / <span class="hljs-number">200</span>) * <span class="hljs-number">20</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;discount300-50&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">300</span>) * <span class="hljs-number">50</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;discount500-100&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">500</span>) * <span class="hljs-number">100</span>;<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">// 算法的使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">priceCalculate</span>(<span class="hljs-params">discountType,price</span>)&#123;<br>    <span class="hljs-keyword">return</span> discountMap[discountType] &amp;&amp; discountMap[discountType](price);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>以上代码就将算法的实现和算法的使用分开，以后不管增加或修改了算法，都无需对<code>priceCalculate</code>方法进行改动。</p>
<p>当然以上代码的抽象程度并不高，如果我们想隐藏计算算法，可以借助 IIFE 使用闭包的方式，提供一个添加策略的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> priceCalculate = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> discountMap = &#123;<br>        <span class="hljs-string">&#x27;discount200-20&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>            <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price / <span class="hljs-number">200</span>) * <span class="hljs-number">20</span>;<br>        &#125;,<br>        <span class="hljs-string">&#x27;discount300-50&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>            <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">300</span>) * <span class="hljs-number">50</span>;<br>        &#125;,<br>        <span class="hljs-string">&#x27;discount500-100&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>            <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">500</span>) * <span class="hljs-number">100</span>;<br>        &#125;,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">addStategy</span>(<span class="hljs-params">stategyName,fn</span>)&#123;<br>            <span class="hljs-keyword">if</span>(discountMap[stategyName]) <span class="hljs-keyword">return</span>;<br>            discountMap[stategyName] = fn;<br>        &#125;,<br>        <span class="hljs-title function_">priceCal</span>(<span class="hljs-params">discountType,price</span>)&#123;<br>            <span class="hljs-keyword">return</span> discountMap[discountType] &amp;&amp; discountMap[discountType](price);<br>        &#125;<br>    &#125;<br>&#125;)()<br><br><span class="hljs-comment">// 使用</span><br>priceCalculate.<span class="hljs-title function_">priceCal</span>(<span class="hljs-string">&#x27;discount200-20&#x27;</span>,<span class="hljs-number">250</span>); <span class="hljs-comment">// 230</span><br><br>priceCalculate.<span class="hljs-title function_">addStategy</span>(<span class="hljs-string">&#x27;discount800-200&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>)&#123;<br>    <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">800</span>) * <span class="hljs-number">200</span>;<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样算法就被隐藏起来，并且预留了增加策略的入口，便于扩展。</p>
<p>场景：表单验证。</p>
<p>表单验证项一般会比较复杂，所以需要给每个表单项增加 <code>validator</code> 自定义校验方法。以<code>ElementUI</code> 的 <code>Form</code> 表单为例。</p>
<p>我们可以像官网示例一样把表单验证都写在组件的状态 data 函数中。</p>
<p>缺点：不好复用使用频率比较高的表单验证方法，造成代码冗余。</p>
<p><strong>使用策略模式和函数</strong> <strong>柯里化</strong> <strong>对代码进行改写。</strong></p>
<p><code>utils/validates.js</code>为通用验证规则，即为<code>StrategyMap</code>。</p>
<p><code>utils/index.js</code>中的<code>formValidateGene</code>通过柯里化动态选择表单验证方法，即为<code>Context</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/utils/validates.js</span><br><span class="hljs-comment">// 姓名校验 由2-10位汉字组成 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateUsername</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^[\u4e00-\u9fa5]&#123;2,10&#125;$/</span><br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str)<br>&#125;<br><br><span class="hljs-comment">// 手机号校验 由以1开头的11位数字组成</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateMobile</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^1\d&#123;10&#125;$/</span><br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str)<br>&#125;<br><br><span class="hljs-comment">// 邮箱校验 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateEmail</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$/</span><br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str)<br>&#125;<br><br><span class="hljs-comment">// src/utils/index.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Validates</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./validates.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> formValidateGene = <span class="hljs-function">(<span class="hljs-params">key,msg</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">rule,value,cb</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Validates</span>[key] &amp;&amp; <span class="hljs-title class_">Validates</span>[key](value))&#123;<br>            <span class="hljs-title function_">cb</span>()<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">cb</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(msg))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>&lt;script&gt;<br>  <span class="hljs-keyword">import</span> &#123; formValidateGene &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils&#x27;</span><br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">ruleForm</span>: &#123;<br>          <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">telephone</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        &#125;,<br>        <span class="hljs-attr">rules</span>: &#123;<br>          <span class="hljs-attr">username</span>: [<br>            &#123; <span class="hljs-attr">validator</span>: <span class="hljs-title function_">formValidateGene</span>(<span class="hljs-string">&#x27;validateUsername&#x27;</span>,<span class="hljs-string">&#x27;用户名格式为2～10个汉字，请重新输入&#x27;</span>), <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>          ],<br>          <span class="hljs-attr">telephone</span>: [<br>            &#123; <span class="hljs-attr">validator</span>: <span class="hljs-title function_">formValidateGene</span>(<span class="hljs-string">&#x27;validateMobile&#x27;</span>,<span class="hljs-string">&#x27;手机号格式错误，请重新输入&#x27;</span>), <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>          ],<br>        &#125;<br>      &#125;;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ol>
<li><p>策略相互独立，可以互相切换。提高了灵活性以及复用性。</p>
</li>
<li><p>不需要使用<code>if-else</code>进行策略选择，提高了维护性。</p>
</li>
<li><p>可扩展性好，满足开闭原则。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>策略相互独立，一些复杂的算法逻辑无法共享，造成资源浪费。</p>
</li>
<li><p>用户在使用策略时，需要了解具体的策略实现。不满足最少知识原则，增加了使用成本。</p>
</li>
</ol>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li><p>算法需要自由切换的场景。</p>
</li>
<li><p>多个算法只有行为上有些不同，可以考虑策略模式动态选择算法。</p>
</li>
<li><p>需要多重判断，可以考虑策略模式规避多重条件判断。</p>
</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote>
<p>观察者模式：一个对象（称为subject）维持一系列依赖于它的对象（称为observer），将有关状态的任何变更自动通知给它们（观察者）。</p>
</blockquote>
<p><strong>观察者模式中的角色有两类：观察者和被观察者。</strong></p>
<ul>
<li>观察者必须订阅内容改变的事件，定义一对多的依赖关系。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b58ead6c9f2e49e88c73ecc2b12c57dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>生活中的例子：领导（被观察者）在台上介绍防疫政策，底下的工作人员（观察者）“观察”领导说的防疫政策的变化，当政策变化时，通知（update）到街道。</p>
<p>工作人员（观察者）必须订阅内容改变的事件，即用耳朵去听政策的变化。</p>
<h4 id="🌰-例子-4"><a href="#🌰-例子-4" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>简单的代码基本实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 观察者模式 被观察者Subject 观察者Observer Subject变化 notify观察者</span><br><span class="hljs-keyword">let</span> observerIds = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 被观察者Subject</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];<br>  &#125;<br><br>  <span class="hljs-comment">// 添加观察者</span><br>  <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);<br>  &#125;<br><br>  <span class="hljs-comment">// 移除观察者</span><br>  <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">obs</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> obs.<span class="hljs-property">id</span> !== observer.<span class="hljs-property">id</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 通知notify观察者</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> observer.<span class="hljs-title function_">update</span>(<span class="hljs-variable language_">this</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 观察者Observer</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = observerIds++;<br>  &#125;<br><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params">subject</span>) &#123;<br>    <span class="hljs-comment">// 更新</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：目标变化就会通知观察者，这是观察者模式最大的优点。</p>
<p>缺点： 不灵活。目标和观察者是耦合在一起的，要实现观察者模式，必须同时引入被观察者和观察者才能达到响应式的效果。</p>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><blockquote>
<p>发布&#x2F;订阅模式：基于一个主题&#x2F;事件通道，希望接收通知的对象（称为subscriber）通过自定义事件订阅主题，被激活事件的对象（称为publisher）通过发布主题事件的方式被通知。</p>
</blockquote>
<p><strong>发布-订阅模式的角色有两类：发布者和订阅者</strong></p>
<ul>
<li>使用一个主题通道，这个通道介于发布者和订阅者之间。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa47553e014346f29f0a3f51f11a2dc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"> 容</p>
<h4 id="🌰-例子-5"><a href="#🌰-例子-5" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>我们微信会关注很多公众号，公众号有新文章发布时，就会有消息及时通知我们文章更新了。</p>
<p>这个时候公众号为发布者，用户为订阅者，用户将订阅公众号的事件注册到事件调度中心，当发布者发布新文章时，会发布事件至事件调度中心，调度中心会发消息告诉订阅者。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 订阅</span><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">push</span>(fn);<br>  &#125;<br><br>  <span class="hljs-comment">// 取消订阅</span><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> event !== fn;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 发布</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">event</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="源码实例-2"><a href="#源码实例-2" class="headerlink" title="源码实例"></a>源码实例</h4><p>Vue 双向绑定中的发布订阅模式</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d3e2fcf8f643a2b29cb90941d5cd7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p><code>Vue</code> 双向绑定通过数据劫持和发布-订阅模式实现。</p>
<ol>
<li><p>通过<code>DefineProperty</code>劫持各个数据的<code>setter</code>和<code>getter</code>，并为每个数据添加一个订阅者列表，这个列表将会记录所有依赖这个数据的组件。响应式后的数据相当于消息的发布者。</p>
</li>
<li><p>每个组件都对应一个<code>Watcher</code>订阅者，当组件渲染函数执行时，会将本组件的<code>Watcher</code>加入到所依赖的响应式数据的订阅者列表中。相当于完成了一次订阅，这个过程叫做“依赖收集”。</p>
</li>
<li><p>当响应式数据发生变化时，会出<code>setter</code>，<code>setter</code>负责通知数据的订阅者列表中的<code>Watcher</code>，<code>Watcher</code>触发组件重新渲染来更新视图。视图层相当于消息的订阅者。</p>
</li>
</ol>
<p>EventEmitter</p>
<blockquote>
<p>跟 🌰 差不多，略。</p>
</blockquote>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ol>
<li><p>时间解耦：注册的订阅行为由发布者决定何时调用，订阅者无需持续关注，由发布者负责通知。</p>
</li>
<li><p>对象解耦：发布者无需知道消息的接受者，只需遍历订阅该消息类型的订阅者发送消息，解耦了发布者和订阅者之间的联系，互不持有，都依赖于抽象。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>资源消耗：创建订阅者需要一定的时间和内存。</p>
</li>
<li><p>增加复杂度：弱化了联系，难以维护调用关系，增加了理解成本。</p>
</li>
</ol>
<h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>各模块相互独立</p>
</li>
<li><p>存在一对多的依赖关系</p>
</li>
<li><p>依赖模块不稳定、依赖关系不稳定</p>
</li>
<li><p>各模块由不同的人员开发</p>
</li>
</ul>
<h2 id="5-this的指向"><a href="#5-this的指向" class="headerlink" title="5 this的指向"></a>5 this的指向</h2><h3 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h3><p>在javascript中，this可谓是无处不在，它可以用来指向某些元素、对象，在合适的地方使用this，能让我们减少无用代码的编写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;aclie&quot;</span>,<br>  <span class="hljs-attr">sing</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在唱歌&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">dance</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在跳舞&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">study</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在学习&#x27;</span>)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上这段代码中，每个方法都需要用到user对象中的name属性，如果当user对象名称发生变化，那么所有方法都要改动，这种情况下，使用this是个很好的选择</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;aclie&quot;</span>,<br>  <span class="hljs-attr">sing</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在唱歌&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">dance</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在跳舞&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">study</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在学习&#x27;</span>)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><blockquote>
<p>this的指向和函数在哪里定义无关，和如何调用有关</p>
</blockquote>
<p>以下foo函数调用方式不同，this的值也不同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">foo</span>()<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>() <br><br>obj.<span class="hljs-property">foo</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&quot;hello&quot;</span>)    <br></code></pre></td></tr></table></figure>

<p>执行结果如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104035637-20230411%2010:40:37.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104035637"></p>
<h3 id="this四种绑定方式"><a href="#this四种绑定方式" class="headerlink" title="this四种绑定方式"></a>this四种绑定方式</h3><p><strong>一、默认绑定</strong></p>
<blockquote>
<p>当函数独立调用时，this默认绑定window</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1、直接调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">foo</span>()<br><br><span class="hljs-comment">// 2、对象中的函数</span><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><span class="hljs-keyword">var</span> fn1 = obj1.<span class="hljs-property">foo</span><br><span class="hljs-title function_">fn1</span>()<br><br><span class="hljs-comment">// 3、被全局变量引用</span><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> fn2 = obj2.<span class="hljs-property">bar</span><br><span class="hljs-title function_">fn2</span>()<br><br><span class="hljs-comment">// 4、函数嵌套调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo1&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo2&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>  <span class="hljs-title function_">foo1</span>()<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo3&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>  <span class="hljs-title function_">foo2</span>()<br>&#125;<br><span class="hljs-title function_">foo3</span>()<br><br><span class="hljs-comment">// 5、通过闭包调用</span><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br>&#125;<br>obj2.<span class="hljs-title function_">bar</span>()()<br></code></pre></td></tr></table></figure>

<p>执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104057283-20230411%2010:40:57.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104057283"></p>
<p>以上五种调用方式全都属于默认绑定，因为他们最终都是单独的对函数进行调用</p>
<p><strong>二、隐式绑定</strong></p>
<blockquote>
<p>调用的对象内部有对函数的引用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br>obj1.<span class="hljs-title function_">foo</span>()<br><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj2&#x27;</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>obj2.<span class="hljs-title function_">bar</span>()<br><br><span class="hljs-keyword">var</span> obj3 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj3&#x27;</span>,<br>  <span class="hljs-attr">baz</span>: obj2.<span class="hljs-property">bar</span><br>&#125;<br>obj3.<span class="hljs-title function_">baz</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104112732-20230411%2010:41:12.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104112732"></p>
<p>以上三种都属于隐式绑定，他们都是通过对象调用，this就指向了该对象</p>
<p><strong>三、显式绑定</strong></p>
<blockquote>
<p>不希望在对象内部包含这个函数的引用，但又希望通过对象强制调用，使用call&#x2F;apply&#x2F;bind进行显式绑定</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>,<br>&#125;<br><br>foo.<span class="hljs-title function_">call</span>(obj)<br>foo.<span class="hljs-title function_">apply</span>(obj)<br>foo.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;xxx&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104134131-20230411%2010:41:34.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104134131"></p>
<p>foo函数直接调用this应该指向window，这里通过call&#x2F;apply来改变了this的指向</p>
<p><strong>四、new绑定</strong></p>
<blockquote>
<p>通过new关键字来创建构造函数的实例，绑定this</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">20</span>)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;mogan&#x27;</span>, <span class="hljs-number">24</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104147865-20230411%2010:41:48.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104147865"></p>
<p>此时this指向的是通过new创建的实例对象</p>
<h3 id="this绑定的优先级"><a href="#this绑定的优先级" class="headerlink" title="this绑定的优先级"></a>this绑定的优先级</h3><p><strong>一、隐式绑定高于默认绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104203699-20230411%2010:42:03.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104203699"></p>
<p>foo函数默认绑定window对象，当同时存在隐式绑定和默认绑定时，隐式绑定优先级高于默认绑定</p>
<p><strong>二、显示绑定高于隐式绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 案例一</span><br><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>user.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;kiki&#x27;</span>)<br><br><span class="hljs-comment">// 案例二</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span>,<br>  <span class="hljs-attr">foo</span>: foo.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&quot;aclie&quot;</span>)<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104220954-20230411%2010:42:21.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104220954"></p>
<p>如果隐式绑定优先级更高的话，this的指向应该都为对象，但根据以上执行结果得知this绑定为显示绑定的结果，所以当同时存在隐式绑定和显示绑定时，显示绑定的优先级高于隐式绑定</p>
<p><strong>三、new高于隐式绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lisa&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">new</span> user.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104232426-20230411%2010:42:32.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104232426"></p>
<p>当同时存在于new关键字绑定和隐式绑定时，this绑定了foo构造函数，所以new关键字的优先级高于隐式绑定</p>
<p><strong>四、new高于显示绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> fn = bar.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104243338-20230411%2010:42:43.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104243338"></p>
<p>当同时存在于new关键字绑定和显示绑定时，this绑定了bar构造函数，所以new关键字的优先级高于显示绑定</p>
<p><strong>综上，以上四种绑定的优先级顺序为</strong></p>
<blockquote>
<p>new关键字 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
</blockquote>
<h3 id="规则之外"><a href="#规则之外" class="headerlink" title="规则之外"></a>规则之外</h3><p>还有几种特殊的绑定方式，不在上述四种绑定规则中</p>
<p><strong>一、忽略显示绑定</strong></p>
<blockquote>
<p>当显示绑定的值为 null&#x2F;undefined 时，this直接绑定window</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alice&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>user.<span class="hljs-title function_">foo</span>()<br>user.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>)<br>user.<span class="hljs-property">foo</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">undefined</span>)<br></code></pre></td></tr></table></figure>

<p>以上代码执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104256708-20230411%2010:42:56.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104256708"></p>
<p><strong>二、间接函数引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj2&#x27;</span><br>&#125;;<br>obj2.<span class="hljs-property">baz</span> = obj1.<span class="hljs-property">foo</span>;<br>obj2.<span class="hljs-title function_">baz</span>();<br><br>(obj2.<span class="hljs-property">bar</span> = obj1.<span class="hljs-property">foo</span>)()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104313515-20230411%2010:43:13.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104313515"></p>
<p>两种方式所绑定的this不同，第二种方式进行了赋值调用，实际上是间接函数引用，（obj2.bar &#x3D; obj1.foo）这里返回了赋值的结果，再加上一个小括号，就直接调用赋值的结果函数</p>
<p><strong>三、箭头函数</strong></p>
<blockquote>
<p>箭头函数是不绑定this的，它的this来源于上级作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kiki&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数中的this&#x27;</span>,<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>user.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104326432-20230411%2010:43:26.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104326432"></p>
<p>这里调用foo函数，因为箭头函数不绑定this，所以去foo函数的上级查找this，找到了全局对象window</p>
<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><p><strong>1、考察间接函数引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;window&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;person&quot;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> sss = person.<span class="hljs-property">sayName</span>;<br>  <span class="hljs-title function_">sss</span>(); <br>  person.<span class="hljs-title function_">sayName</span>(); <br>  (person.<span class="hljs-property">sayName</span>)(); <br>  (b = person.<span class="hljs-property">sayName</span>)();<br>&#125;<br><span class="hljs-title function_">sayName</span>();<br></code></pre></td></tr></table></figure>

<p>执行sayName函数</p>
<ul>
<li>变量sss 被person.sayName方法赋值，执行sss函数，此时是独立函数调用，this指向全局window，全局中变量name被绑定到了window中，所以this.name为”window”</li>
<li>person.sayName() 为隐式绑定，this指向person对象，所以this.name为person.name，即”person”</li>
<li>(person.sayName)() 与前一个本质是一样的，隐式绑定，this指向person对象，所以this.name为person.name，即”person”</li>
<li>(b &#x3D; person.sayName)() 是间接函数引用，person.sayName赋值给b变量，而小括号括起来的代表赋值的结果，this指向window，this.name为window.name，即”window”</li>
</ul>
<p>所以执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104341809-20230411%2010:43:42.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104341809"></p>
<p><strong>2、定义对象时是不产生作用域的</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person1&#x27;</span>,<br>  <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-attr">foo2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-attr">foo3</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">foo4</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person2&#x27;</span> &#125;<br><br>person1.<span class="hljs-title function_">foo1</span>();<br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2);<br><br>person1.<span class="hljs-title function_">foo2</span>();<br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2);<br><br>person1.<span class="hljs-title function_">foo3</span>()();<br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)();<br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2);<br><br>person1.<span class="hljs-title function_">foo4</span>()();<br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)();<br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2);<br></code></pre></td></tr></table></figure>

<p>调用过程分析</p>
<ol>
<li>foo1函数<ul>
<li>person1.foo1() 隐式绑定，this指向person1，this.name为person1.name，即 “person1”</li>
<li>person1.foo1.call(person2) 隐式绑定+显示绑定person2，显示绑定优先级更高，所以this指向person2，this.name为person2.name，即 “person2”</li>
</ul>
</li>
<li>foo2函数<ul>
<li>person1.foo2() 隐式绑定， 箭头函数没有自己的this，所以向上层作用域查找，找到了全局window（person1是对象，定义它的时候不产生作用域），全局变量name被绑定到了window中，this.name为window.name，即 “window”</li>
<li>person1.foo2.call(person) 隐式绑定+显示绑定，但是 箭头函数不绑定this，这里的显示绑定无效，没有自己的this，向上层作用域查找，找到全局window，this.name为window.name，即 “window”</li>
</ul>
</li>
<li>foo3函数<ul>
<li>person1.foo3()() 这里相当于执行person1.foo()的返回函数，这里是独立函数调用，this指向全局window，this.name为window.name，即 “window”</li>
<li>person1.foo3.call(person2)() 这里通过call改变的是foo3函数中this的指向，但最终执行的是foo3函数返回的闭包，闭包作为独立函数调用，this仍然指向全局window，this.name为window.name，即’window”</li>
<li>person1.foo3().call(person2) 这里将foo3函数返回的闭包显示绑定了person2对象，this指向person2，this.name为person2.name，即”person2”</li>
</ul>
</li>
<li>foo4函数<ul>
<li>person1.foo4()() 执行person1.foo()的返回值，返回的闭包是箭头函数没有this的，向上层作用域查找，找到了foo4函数，foo4的this指向person1，所以闭包的this也指向person1，thiss.name为person1.name，即 “person1”</li>
<li>person1.foo4.call(person2)() 返回的闭包没有this，向上层作用域找到了foo4函数，foo4函数的this通过显示绑定变成了person2，所以闭包的this也指向person2，this.name为person2.name，即”person2”</li>
<li>person1.foo4().call(person) 返回的闭包是箭头函数，无法通过call进行显示绑定，直接向上级作用域查找，找到foo4函数，foo4的this指向person1，所以闭包的this指向person1，this.name为person1.name，即”person1”</li>
</ul>
</li>
</ol>
<p>上述代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104355086-20230411%2010:43:55.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104355086"></p>
<p><strong>3、构造函数中定义函数，该函数的上级作用域是构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-title function_">foo1</span>()<br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo2</span>() <br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo3</span>()()<br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)()<br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo4</span>()()<br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)()<br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <br></code></pre></td></tr></table></figure>

<p>调用分析过程</p>
<ol>
<li>foo1函数<ul>
<li>person1.foo1() 隐式绑定，this指向person1，person1创建实例时传入name为person1，所以this.name为person1</li>
<li>person1.foo1.call(person2) 隐式绑定+显示绑定，显示绑定优先级更高，绑定person2，person2创建实例时传入的name为person2，所以this.name为person2</li>
</ul>
</li>
<li>foo2函数<ul>
<li>person1.foo2() 隐式绑定，但foo2是箭头函数，没有自己的this，向上层作用域查找，找到了Person构造函数，此时this是指向person1这个对象的，而person1实例化时传入的name为person1，所以this.name为person1</li>
<li>person1.foo2.call(person2) 隐式绑定+显式绑定，但foo2是箭头函数，不绑定this，所以this仍然需要向上层作用域查找，找到Person构造函数，this指向person1对象，所以this.name为person1</li>
</ul>
</li>
<li>foo3函数<ul>
<li>person1.foo3()() 执行person1.foo3的返回值，返回的函数是独立调用，this指向window，全局的name变量被绑定到window中，this.name为window.name，即 “window”</li>
<li>person1.foo3.call(person2)() 显式绑定更改的是foo3函数的this，最终执行的是foo3函数的返回值，仍然是函数的独立调用，所以this指向window，this.name为window.name，即 “window”</li>
<li>person1.foo3().call(person2) foo3函数的返回函数通过显示绑定将this绑定到了person2中，person2创建实例时传入的name为person2，所以this.name为person2</li>
</ul>
</li>
<li>foo4函数<ul>
<li>person1.foo4()() 执行foo4函数的返回值，返回函数为箭头函数，没有this，所以向上层作用域查找，找到foo4函数的this指向person1，所以箭头函数的this也指向person1，所以this.name为person1</li>
<li>person1.foo4.call(person2)() foo4通过显示绑定将this绑定成了person2，返回的函数为箭头函数，this与父级作用域foo4一致，所以箭头函数的this也指向person2，所以this.name为person2</li>
<li>person1.foo4().call(person2) foo4函数的返回值为箭头函数，不绑定this，这里显示绑定无效，向上级作用域查找this，找到foo4函数，this指向person1</li>
</ul>
</li>
</ol>
<p>执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104409934-20230411%2010:44:10.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104409934"></p>
<p><strong>4、区分作用域</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>    <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">foo2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>().<span class="hljs-title function_">call</span>(person2) <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>().<span class="hljs-title function_">call</span>(person2) <br></code></pre></td></tr></table></figure>

<ol>
<li>foo1函数<ul>
<li>person1.obj.foo1()() 执行foo1函数的返回函数，此时该函数为独立函数调用，this指向window，全局变量name被添加到window中，这里的this.name指向window.name，即 “window”</li>
<li>person1.obj.foo1.call(person2)() 这里显示绑定改变foo1中this的指向，但最终执行的是foo1函数的返回值，返回函数作为独立函数调用，this仍然指向window，所以this.name为window.name，即 “window”</li>
<li>person1.obj.foo1().call(person2) 这里通过显示绑定更改foo1函数的返回函数中this的指向， 所以该函数this指向person2，而person2在实例化的时候传入name值为person2，所以this.name为person2</li>
</ul>
</li>
<li>foo2函数<ul>
<li>person1.obj.foo2()() 执行foo2的返回函数，此时该函数为独立函数调用，但它自己没有this，要向上级作用域查找，找到foo2函数的this指向obj，所以该函数的this也指向obj，this.name为obj.name，即 “obj”</li>
<li>person1.obj.foo2.call(person2)() 执行foo2的返回函数，此时该函数为独立函数调用，但它自己没有this，要向上级作用域查找，foo2函数的this通过显示绑定变成person2，所以该函数的this也为person2，而person2在实例化的时候传入name值为person2，所以this.name为person2</li>
<li>person1.obj.foo2().call(person2) foo2的返回函数为箭头函数，不绑定this，显式绑定无效，也没有自己的this，要向上级作用域查找，找到foo2函数的this指向obj，所以该函数的this也指向obj，this.name为obj.name，即 “obj”</li>
</ul>
</li>
</ol>
<p>所以执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104425836-20230411%2010:44:26.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104425836"></p>
<h2 id="6-原型链"><a href="#6-原型链" class="headerlink" title="6 原型链"></a>6 原型链</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个前端开发工程师，熟练掌握JS这门语言是必须要的。无论是日常的工作中，亦或者是出去面试找工作，JS掌握的多深多好，很大程度上决定了你能走的多远。今天本人就来介绍一下JS的<code>原型</code>以及<code>原型链</code>，基于本人的一些认识。因为本人也在学习的阶段，所以如果文章中有什么不对的或者不好的地方，烦请大家指出。</p>
<h3 id="JS原型"><a href="#JS原型" class="headerlink" title="JS原型"></a>JS原型</h3><p>众所周知，JS的复杂类型都是对象类型（<strong>Object</strong>），而JS不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>因为JS中没有类（<strong>Class</strong>）这个概念，所以JS的设计者使用了<code>构造函数</code>来实现继承机制。</p>
<blockquote>
<p>ES6中的<code>class</code>可以看作只是一个语法糖，它的绝大部分的功能，ES5都可以做到，新的<code>class</code>写法只是让原型的写法更加的清晰、更像面向对象编程的语法而已。下文也会进一步的说明。（摘自阮一峰的ES6入门）</p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 构造函数<br>function Person(name, age) &#123;<br>    <span class="hljs-attr">this.name</span> = name<span class="hljs-comment">;</span><br>    <span class="hljs-attr">this.age</span> = age<span class="hljs-comment">;</span><br>&#125;<br><br>// 生成实例<br>const <span class="hljs-attr">p</span> = new Person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如上述代码所示，JS通过<code>构造函数</code>来生成<code>实例</code>。但是又出现了一个新的问题，在<code>构造函数</code>中通过<code>this</code>赋值的属性或者方法，是每个实例的<code>实例属性</code>以及<code>实例方法</code>，无法共享公共属性。所以又设计出了一个<code>原型对象</code>，来存储这个<code>构造函数</code>的公共属性以及方法。</p>
<h4 id="补充知识：构造函数创建一个实例的过程"><a href="#补充知识：构造函数创建一个实例的过程" class="headerlink" title="补充知识：构造函数创建一个实例的过程"></a>补充知识：构造函数创建一个实例的过程</h4><ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（这样this就指向了新对象）</li>
<li>执行构造函数中的代码（为新对象添加实例属性和实例方法）</li>
<li>返回新对象</li>
</ol>
<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>说了这么久，终于说到了JS的<code>原型对象</code>了。JS的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5aaae37b7094aaaad14daa910c61775~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h3><p>讲清楚了JS的<code>原型对象</code>，来就是介绍JS的<code>原型链</code>了。既然有了<code>构造函数</code>，那么就可以通过该<code>构造函数</code>，来创建一个实例对象了。此时，完善一下我们的<code>Preson</code>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Preson</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 所有实例共享的公共方法</span><br><span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br>p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法 打印：张三说：hello world</span><br><br></code></pre></td></tr></table></figure>

<p>这里就要思考了，为什么我们构造的<code>p1</code>这个<code>实例对象</code>，它可以调用到<code>Person</code>这个<code>构造函数</code>的<code>原型对象</code>上的方法呢？明明只有在<code>构造函数</code>内部通过<code>this</code>来赋值的属性或者方法才会被实例所继承，为什么在<code>构造函数</code>的<code>原型对象</code>上定义的<code>say</code>方法也能通过实例来调用到呢？这里就引出了<code>原型链</code>这个概念。</p>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em><em>proto</em></em></h4><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>，这么说好像有点绕，我们看下图</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1141452b532f4e9cab03ba48f58beade~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的<code>私有属性</code>，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法&#x2F;属性。（摘自阮一峰的ES6入门）</p>
</blockquote>
<p>现在我们知道了，当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p>
<p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Preson</span>(<span class="hljs-params">name, age</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-comment">// 所有实例共享的公共方法</span><br>    <span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br>    <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 新创建一个Proson实例对象</span><br>    p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法</span><br>    p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>    p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">do</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;往原型对象中添加方法&#x27;</span>);<br>    &#125;<br>    p2.<span class="hljs-title function_">do</span>(); <span class="hljs-comment">// 打印出了-往原型对象中添加方法</span><br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>所以，我们在开发的时候，要注意不要通过<code>实例对象</code>去改变其<code>构造函数</code>的<code>原型对象</code>，这样会对其他通过该<code>构造函数</code>生成的<code>实例对象</code>造成影响。</p>
</blockquote>
<p>说到这里，有的读者可能又会产生疑问了，再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找是什么意思？我们继续往下看。</p>
<h4 id="补充知识：原型链的尽头"><a href="#补充知识：原型链的尽头" class="headerlink" title="补充知识：原型链的尽头"></a>补充知识：原型链的尽头</h4><p>既然我们之前构造的<code>p1实例对象</code>有<code>__proto__</code>属性指向其<code>构造函数</code>的<code>原型对象</code>，那么该<code>构造函数</code>的<code>原型对象</code>有这个<code>__proto__</code>属性吗？如果有，那么其又指向谁呢？我们不妨打印一下。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2750863007534407b542d38ea5259cdf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>我们随便创建了一个<code>A</code>的<code>构造函数</code>，通过打印它的<code>prototype</code>属性，我们可以看到，在浏览器中，它有个<code>__proto__</code>属性指向了一个<code>Object</code>对象。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2cda9bce64b41339f411a9c974000d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>而进一步展开后，我们会发现，该对象的<code>构造函数</code>为<code>function Object</code>，我们由此可以得知，<strong>所有的<code>原型对象</code>的<code>__proto__</code>属性都是指向<code>function Object</code>的<code>原型对象</code>。</strong> 而<code>function Object</code>的<code>原型对象</code>在上图中我们可以得知是不存在<code>__proto__</code>这个属性的，它指向了<code>null</code>。我们就得知了<code>原型链</code>的尽头是<code>null</code>。</p>
<h4 id="补充知识：所有对象的原型链"><a href="#补充知识：所有对象的原型链" class="headerlink" title="补充知识：所有对象的原型链"></a>补充知识：所有对象的原型链</h4><p>既然JS的复杂类型都是<code>对象</code>，那么，函数作为一个<code>对象</code>，是否也存在<code>原型链</code>呢？ 我们在浏览器中创建一个<code>构造函数</code>，打印它的<code>__proto__</code>属性，一探究竟：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/818ed8034ed54aa9aa6591d8be8a70ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>我们可以看到，它的<code>__proto__</code>属性指向了一个<code>function Function</code>的<code>原型对象</code>，该<code>原型对象</code>为JS中所有函数的<code>原型对象</code>，而其<code>__proto__</code>属性也还是指向了<code>function Object</code>的<code>原型对象</code>，所以验证了<code>原型链</code>的尽头为<code>null</code>，这一说法。</p>
<p>最后，奉上神图一张，祝大家理解JS的<code>原型链</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0815c8f7fa544cf4a33fd7defdc6c1f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">   你可以将它想象成一个链条，连接着实例对象和原型对象。每个函数都有一个prototype属性，<br>   这就是我们所说的原型对象。如果这个函数用new 构建出了一个实例对象，这个实例对象会有<br>   一个<span class="hljs-strong">__proto__</span>指针指向他的构造函数的原型对象，这样构造函数和实例对象之间就通过<br>   (<span class="hljs-strong">__proto__</span>)连接在一起，形成了一个链子。     <br>   <br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b004a98f32e40e19da293add4b690c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="原型链的作用"><a href="#原型链的作用" class="headerlink" title="原型链的作用"></a>原型链的作用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">JS有一个原型查找机制，把原来定义在实例上的方法，放到原型对象上去，通过构造函数的new操作，会把原型对<br>象赋值给实例的<span class="hljs-strong">__proto__</span>属性，那么当使用返回的实例去调用某一个方法的时候，如果实例本身上没有，就去自<br>动去实例的<span class="hljs-strong">__proto__</span>上去查找，这样达到方法的复用，减少内存开销。   <br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="prototype-和-proto"><a href="#prototype-和-proto" class="headerlink" title="prototype 和 proto"></a>prototype 和 <strong>proto</strong></h3><ul>
<li><p>prototype</p>
<p>显式原型，是构造函数的原型对象，函数的独有属性</p>
</li>
<li><p><strong>proto</strong></p>
<p>是实例对象指向原型对象的指针，隐式原型，是每一个对象都有的属性</p>
</li>
<li><p>示例</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b70d1d571e7a47478ecd08892fbae7c9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78b281e66df644dbb693a026f0dbd50f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">由上面的示例可知，构造函数和prototype对象，<span class="hljs-strong">__proto__</span>指针是有关联的，在实例对象中用<span class="hljs-strong">__proto__</span>指针调<br>用方法，而在原型对象中则用prototype ，这两种相等，则说明原型链将被 <span class="hljs-strong">__proto__</span> 指针连接起来。<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><p>constructor</p>
<p>原型对象中，还有一个指向函数的 constructor 属性</p>
<p>每个函数都有一个原型对象，该原型对象有一个constructor属性，指向创建对象的函数本身。</p>
</li>
</ul>
<p>所有的实例对象都可以访问 constructor 属性 ， 可以使用 constructor 属性来判断是否在一个原型链上</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c064ed668cc40748b9be48fbabf7854~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68f12e9cf5434f9795a04881eabfc3d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>示例</p>
<p>两者的 constructor 值相等，说明他们在同一个原型链上</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>1.实例化对象中查询使用__proto__ 指针 ，它指向prototype 对象</p>
<p>2.prototype 是函数独有的属性，定义构造函数时自动被创建，可以给函数和对象添加可共享的（继承的）方法和属性</p>
<p>3.constructor 属性能使原型对象和实例对象找到其创建他们的构造函数。</p>
<h2 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7 闭包"></a>7 闭包</h2><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong></p>
<p>先了解一些变量的作用域：</p>
<p>变量的作用域包括两种：全局变量和局部变量。</p>
<p>全局变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br><span class="hljs-title function_">f1</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>局部变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<span class="hljs-comment">//局部变量</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<span class="hljs-comment">//n is not defined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="一、简单理解闭包"><a href="#一、简单理解闭包" class="headerlink" title="一、简单理解闭包"></a>一、简单理解闭包</h3><p>先看一下MDN关于闭包的定义：</p>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
</blockquote>
<p>重点的一句：<strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</strong></p>
<p>现在不理解也没关系，继续往下看：</p>
<p>学习一个概念时，最好的方法就是找它的demo，从demo中理解和分析，下面先看一段代码，这是一个最简单的闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> f2<span class="hljs-comment">//返回内部函数f2，这样在f1中就能读取f2的数据和函数等价于window.f2 = f2;</span><br>  <br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>首先定义个普通函数f1；</li>
<li>在f1中再定义一个普通函数f2、和在f1函数中的内部变量n;</li>
<li>在f1中返回函数f2(确切说，在f1中返回了f2的引用);</li>
<li>将f1的返回值赋值给变量result；</li>
<li>执行result</li>
</ul>
<p>在上边的代码中，f1函数里面嵌套了一个函数f2，并且f2调用了f1的变量，那么变量n和函数f2组合就成了一个闭包。</p>
<p>那为什么是闭包呢？我们可以根据上边MDN对闭包的定义这句话（<strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</strong>）进行分析，我们再看一张图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e69a7ec327436d8aedf7b92828e961~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>f1是一个外部函数，变量n是外部函数的局部变量，f2是嵌套在f1中的一个内部函数，在<strong>内部函数f2中调用了外部函数f1的变量n</strong>,所以f2和变量n就组成了一个闭包。</p>
<p>那么，我们就可以得出产生闭包的条件：</p>
<ul>
<li>一个<strong>外部函数里面嵌套着一个内部函数</strong>；比如外部函数f1里面嵌套了一个内部函数f2</li>
<li>一个嵌套的<strong>内部函数调用了外部函数的内部变量或函数</strong>；比如f2内部函数调用了外部函数f1的变量n 只要满足以上两个条件，就产生了闭包。</li>
</ul>
<p>那你可能会问为什么要return f1呢？</p>
<p>因为在JS中，只要内部函数才能够读取外部函数的内部变量或数据，反之则不行，如果你不return f2，那你将无法使用f2这个闭包，return f2是为了在f1中能使用f2的变量和数据，与闭包没有关系的。</p>
<p>那到底什么是闭包呢？</p>
<p>可以通俗理解成：<strong>闭包就是有权访问另一个函数作用域中内部变量或数据的函数</strong>，因为在JS中，只要内部函数能能够读取外部函数的变量或数据，反之就不行，所有可以将<strong>闭包简单理解成，定义在一个函数内部的函数。</strong></p>
<p>总结：</p>
<p><strong>闭包就是有权访问另一个函数内部变量的函数。</strong></p>
<p><strong>闭包产生的原因：内部函数存在对外部函数局部变量的引用就会导致闭包。</strong></p>
<p>到这里相信你也已经对闭包有了一个简单的了解了，但是单单是了解还是不够的，我们学学习一样技术，最重要的就是要学以致用，那我们继续往下了解吧。</p>
<h3 id="二、闭包的经典使用场景"><a href="#二、闭包的经典使用场景" class="headerlink" title="二、闭包的经典使用场景"></a>二、闭包的经典使用场景</h3><h4 id="1、return一个内部函数，读取内部函数的变量；"><a href="#1、return一个内部函数，读取内部函数的变量；" class="headerlink" title="1、return一个内部函数，读取内部函数的变量；"></a>1、return一个内部函数，读取内部函数的变量；</h4><p>最大的一个用途就是前面提到的可以：读取内部函数的变量；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2；<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2、函数作为参数"><a href="#2、函数作为参数" class="headerlink" title="2、函数作为参数"></a>2、函数作为参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f3</span>(<span class="hljs-params">p</span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1001</span>;<br>  <span class="hljs-title function_">p</span>();<br>&#125;<br><br><span class="hljs-title function_">f3</span>(<span class="hljs-title function_">f1</span>());<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3、IIFE（自执行函数）"><a href="#3、IIFE（自执行函数）" class="headerlink" title="3、IIFE（自执行函数）"></a>3、IIFE（自执行函数）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;)()<br><span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边的代码中f1( )是一个闭包，调用了全局变量n（即调用了window下的变量n）;</p>
<h4 id="4、循环赋值"><a href="#4、循环赋值" class="headerlink" title="4、循环赋值"></a>4、循环赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;,<span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br><span class="hljs-comment">//1,2,3,4,5,6,7,8,9,10依次打印</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5、使用回调函数就是在使用闭包"><a href="#5、使用回调函数就是在使用闭包" class="headerlink" title="5、使用回调函数就是在使用闭包"></a>5、使用回调函数就是在使用闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">n</span> = <span class="hljs-number">999</span>;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">n</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="6、将外部函数创建的变量值始终保持在内存中；"><a href="#6、将外部函数创建的变量值始终保持在内存中；" class="headerlink" title="6、将外部函数创建的变量值始终保持在内存中；"></a>6、将外部函数创建的变量值始终保持在内存中；</h4><p>可以看下下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n++);<br>  &#125;<br>  result f2<br>&#125;<br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码中f1的内部变量n一直存在内存中，不会在f1调用结束后被自动清除。 再看另一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  nAdd = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    n+=<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  result f2<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br><span class="hljs-title function_">nAdd</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码中函数f1的返回值赋值给了全局变量result，函数f1的返回值实际上就是f2函数，可以理解为f2被赋值给了全局变量result，这就导致了f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束之后，被垃圾回收机制(GC机制)回收，所有很容易造成<strong>内存泄漏</strong>。</p>
<p>内存泄漏，就是一些你访问不到或用不到的变量，还占据着内存空间，不能被再次利用起来。</p>
<h4 id="7、封装对象的私有对象和私有方法；"><a href="#7、封装对象的私有对象和私有方法；" class="headerlink" title="7、封装对象的私有对象和私有方法；"></a>7、封装对象的私有对象和私有方法；</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>)&#123;<br>     privateCounter += val;<br>   &#125;<br>   <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">increment</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">decrement</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">value</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> privateCounter;<br>      &#125;<br>   &#125;<br> &#125;)();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="三、-使用闭包需要注意什么？"><a href="#三、-使用闭包需要注意什么？" class="headerlink" title="三、 使用闭包需要注意什么？"></a>三、 使用闭包需要注意什么？</h3><p>因为使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制（简称GC机制）回收，多度使用闭包会过度占用内存，造成内存泄漏。</p>
<h3 id="形成闭包的原因"><a href="#形成闭包的原因" class="headerlink" title="形成闭包的原因"></a>形成闭包的原因</h3><blockquote>
<p><strong>内部的函数存在外部作用域的引用就会导致闭包</strong>。从上面介绍的上级作用域的概念中其实就有闭包的例子 <code>return f</code>就是一个表现形式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b =<span class="hljs-number">14</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>    &#125;<br>    <span class="hljs-title function_">fo</span>()<br>&#125;<br><span class="hljs-title function_">foo</span>()<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的子函数 <code>fo</code> 内存就存在外部作用域的引用 <code>a, b</code>，所以这就会产生闭包</p>
</blockquote>
<h3 id="闭包变量存储的位置"><a href="#闭包变量存储的位置" class="headerlink" title="闭包变量存储的位置"></a>闭包变量存储的位置</h3><blockquote>
<p>直接说明：<strong>闭包中的变量存储的位置是堆内存。</strong></p>
</blockquote>
<ul>
<li>假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。</li>
</ul>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul>
<li>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。</li>
<li>保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li>
</ul>
<h3 id="JS-堆栈内存释放"><a href="#JS-堆栈内存释放" class="headerlink" title="JS 堆栈内存释放"></a>JS 堆栈内存释放</h3><ul>
<li>堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。</li>
<li>堆内存释放：将引用类型的空间地址变量赋值成 <code>null</code>，或没有变量占用堆内存了浏览器就会释放掉这个地址</li>
<li>栈内存：提供代码执行的环境和存储基本类型值。</li>
<li>栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。</li>
</ul>
<h3 id="闭包经典使用场景"><a href="#闭包经典使用场景" class="headerlink" title="闭包经典使用场景"></a>闭包经典使用场景</h3><ul>
<li><ol>
<li><code>return</code> 回一个函数</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> n =<span class="hljs-number">20</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>       n++;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>     &#125;<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">x</span>() <span class="hljs-comment">// 21</span><br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的 return <code>f</code>, <code>f()</code>就是一个闭包，存在上级作用域的引用。</p>
</blockquote>
<ul>
<li><ol start="2">
<li>函数作为参数</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;foo&#x27;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fo<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">p</span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;f&#x27;</span><br>    <span class="hljs-title function_">p</span>()<br>&#125;<br><span class="hljs-title function_">f</span>(<span class="hljs-title function_">foo</span>())<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   foo</span><br><span class="hljs-comment">/ </span><br><span class="hljs-comment">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用 return <code>fo</code> 返回回来，<code>fo()</code> 就是闭包，<code>f(foo())</code> 执行的参数就是函数 <code>fo</code>，因为 <code>fo() 中的 a</code> 的上级作用域就是函数<code>foo()</code>，所以输出就是<code>foo</code></p>
</blockquote>
<ul>
<li><ol start="3">
<li>IIFE（自执行函数）</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-string">&#x27;林一一&#x27;</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">p</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>&#125;)()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   林一一</span><br><span class="hljs-comment">/ </span><br><span class="hljs-comment">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>同样也是产生了闭包<code>p()</code>，存在 <code>window</code>下的引用 <code>n</code>。</p>
</blockquote>
<ul>
<li><ol start="4">
<li>循环赋值</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;, <span class="hljs-number">1000</span>) <br>  &#125;)(i)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 <code>i++</code> 到 10时，异步代码才开始执行此时的 <code>i=10</code> 输出的都是 10。</p>
</blockquote>
<ul>
<li><ol start="5">
<li>使用回调函数就是在使用闭包</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeHandler</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>);<br>&#125;, <span class="hljs-number">100</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><ol start="6">
<li>节流防抖</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...arg</span>) &#123;<br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-keyword">return</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, timeout)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, timeout</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>        &#125;, timeout)<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><ol start="7">
<li>柯里化实现</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, len = fn.length</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_curry</span>(fn, len)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry</span>(<span class="hljs-params">fn, len, ...arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...params</span>) &#123;<br>        <span class="hljs-keyword">let</span> _arg = [...arg, ...params]<br>        <span class="hljs-keyword">if</span> (_arg.<span class="hljs-property">length</span> &gt;= len) &#123;<br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, _arg)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, len, ..._arg)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b + c + d + e)<br>&#125;)<br><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 15</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="使用闭包需要注意什么"><a href="#使用闭包需要注意什么" class="headerlink" title="使用闭包需要注意什么"></a>使用闭包需要注意什么</h3><blockquote>
<p>容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。</p>
</blockquote>
<h4 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h4><ul>
<li>performance 面板 和 memory 面板可以找到泄露的现象和位置</li>
</ul>
<p>详细可以查看：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904048961781774#comment">js 内存泄漏场景、如何监控以及分析</a></p>
<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><ul>
<li>for 循环和闭包(号称必刷题)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">/</span><br><span class="hljs-comment">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>i</code> 是全局下的 <code>i</code>，共用一个作用域，当函数被执行的时候这时的 <code>i=3</code>，导致输出的结构都是3。</p>
</blockquote>
<ul>
<li>使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>      <span class="hljs-built_in">setTimeout</span>( data[j] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;)(i)<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>写法2：使用 <code>let</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>let</code> 具有块级作用域，形成的3个私有作用域都是互不干扰的。</p>
</blockquote>
<h3 id="思考题和上面有何不同-字节"><a href="#思考题和上面有何不同-字节" class="headerlink" title="思考题和上面有何不同 (字节)"></a>思考题和上面有何不同 (字节)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        result[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            total += i * a;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br>result[<span class="hljs-number">0</span>]();  <span class="hljs-comment">// 3</span><br>result[<span class="hljs-number">1</span>]();  <span class="hljs-comment">// 6</span><br>result[<span class="hljs-number">2</span>]();  <span class="hljs-comment">// 9</span><br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tip：这里也形成了闭包。total 被外层引用没有被销毁。</p>
</blockquote>
<p>1、简述什么是闭包，闭包的作用是什么？写出一个简单的闭包例子。</p>
<p>2、闭包会造成内存泄漏吗？</p>
<blockquote>
<p>会，因为使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制回收，多度使用闭包会过度占用内存，造成内存泄漏。</p>
</blockquote>
<p>3、for循环和闭包(必刷题)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<span class="hljs-comment">//3</span><br>data[<span class="hljs-number">1</span>]();<span class="hljs-comment">//3</span><br>data[<span class="hljs-number">2</span>]();<span class="hljs-comment">//3</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码的变量i属于一个全局变量，公用一个作用域，所有输出是3个3； 使用闭包改善上边的写法达到预期的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(data[j] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;,<span class="hljs-number">0</span>)<br>  &#125;)(i)<br>&#125;<br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br>复制代码<br></code></pre></td></tr></table></figure>

<p>4、请写出以下代码的输出结果：</p>
<p>第一题4-1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    n++<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-title function_">f2</span>();<br>  <span class="hljs-keyword">return</span> f2<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<span class="hljs-comment">//21</span><br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//22</span><br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//23</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<span class="hljs-comment">//10</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第二题4-2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">x</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>)&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> add5 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> add10 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">10</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add5</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">//7</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add10</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">//12</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第三题4-3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>)&#123;<br>     privateCounter += val;<br>   &#125;<br>   <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">increment</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">decrement</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">value</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> privateCounter;<br>      &#125;<br>   &#125;<br> &#125;)();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第四题4-4：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> makeCounter = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>) &#123;<br>    privateCounter += val;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>    &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>    &#125;,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> privateCounter;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter1</span> = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter2</span> = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter2</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>

<p>Counter1和Counter2是两个独立的闭包，一个闭包变量的值改变不会影响到另一个闭包的变量。</p>
<p>第五题4-5：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">//10 10 10 10 10 10 10 10 10 10每隔1秒输出10，一共10个10</span><br></code></pre></td></tr></table></figure>

<p>因为setTimeout是异步的，for循环是同步的，同步代码执行完，i已经是10了，异步代码才开始执行，所以i最后打印的是10。</p>
<p>如果将var换成let，打印的结果也不一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<span class="hljs-comment">//1,2,3,4,5,6,7,8,9,10</span><br></code></pre></td></tr></table></figure>

<p>在for循环中使用var,那i就是一个全局变量，循环结束之后i的值为10。</p>
<h2 id="8-diff"><a href="#8-diff" class="headerlink" title="8 diff"></a>8 diff</h2><blockquote>
<p>diff算法：对于update的组件，他会将当前组件与该组件在上次更新是对应的Fiber节点比较，将比较的结果生成新的Fiber节点。</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">! 为了防止概念混淆，强调</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>一个DOM节点，在某一时刻最多会有4个节点和他相关。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">- <span class="hljs-number">1.</span>current <span class="hljs-title class_">Fiber</span>。如果该<span class="hljs-variable constant_">DOM</span>节点已在页面中，current <span class="hljs-title class_">Fiber</span>代表该<span class="hljs-variable constant_">DOM</span>节点对应的<span class="hljs-title class_">Fiber</span>节点。<br>- <span class="hljs-number">2.</span>workInProgress <span class="hljs-title class_">Fiber</span>。如果该<span class="hljs-variable constant_">DOM</span>节点将在本次更新中渲染到页面中，workInProgress <span class="hljs-title class_">Fiber</span>代表该<span class="hljs-variable constant_">DOM</span>节点对应的<span class="hljs-title class_">Fiber</span>节点。<br>- <span class="hljs-number">3.</span><span class="hljs-variable constant_">DOM</span>节点本身。<br>- <span class="hljs-number">4.</span><span class="hljs-variable constant_">JSX</span>对象。即<span class="hljs-title class_">ClassComponent</span>的render方法的返回结果，或者<span class="hljs-title class_">FunctionComponent</span>的调用结果，<span class="hljs-variable constant_">JSX</span>对象中包含描述<span class="hljs-variable constant_">DOM</span>节点信息。<br>复制代码<br>diff算法的本质上是对比<span class="hljs-number">1</span>和<span class="hljs-number">4</span>，生成<span class="hljs-number">2</span>。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="Diff的瓶颈以及React如何应对"><a href="#Diff的瓶颈以及React如何应对" class="headerlink" title="Diff的瓶颈以及React如何应对"></a>Diff的瓶颈以及React如何应对</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">由于diff操作本身也会带来性能损耗，<span class="hljs-title class_">React</span>文档中提到，即使在最前沿的算法中<br>将前后两棵树完全比对的算法的复杂程度为 <span class="hljs-title function_">O</span>(n <span class="hljs-number">3</span> )，其中 n 是树中元素的数量。<br><br>如果在<span class="hljs-title class_">React</span>中使用了该算法，那么展示<span class="hljs-number">1000</span>个元素所需要执行的计算量将在十亿的量级范围。<br>这个开销实在是太过高昂。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="所以为了降低算法复杂度，React的diff会预设3个限制："><a href="#所以为了降低算法复杂度，React的diff会预设3个限制：" class="headerlink" title="所以为了降低算法复杂度，React的diff会预设3个限制："></a>所以为了降低算法复杂度，React的diff会预设3个限制：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-number">1</span>.同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。<br> <span class="hljs-number">2</span>.不同类型的元素会产生出不同的树。如果元素由<span class="hljs-selector-tag">div</span>变为<span class="hljs-selector-tag">p</span>，React会销毁<span class="hljs-selector-tag">div</span>及其子孙节点，并新建<span class="hljs-selector-tag">p</span>及其子孙节点。<br> <span class="hljs-number">3</span>.者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="那么我们接下来看一下Diff是如何实现的"><a href="#那么我们接下来看一下Diff是如何实现的" class="headerlink" title="那么我们接下来看一下Diff是如何实现的"></a>那么我们接下来看一下Diff是如何实现的</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d640e75281b64f8695c89d5882ac2c50~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="我们可以从同级的节点数量将Diff分为两类："><a href="#我们可以从同级的节点数量将Diff分为两类：" class="headerlink" title="我们可以从同级的节点数量将Diff分为两类："></a>我们可以从同级的节点数量将Diff分为两类：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-number">1.</span>当newChild类型为<span class="hljs-built_in">object</span>、<span class="hljs-built_in">number</span>、<span class="hljs-built_in">string</span>，代表同级只有一个节点<br>- <span class="hljs-number">2.</span>当newChild类型为<span class="hljs-title class_">Array</span>，同级有多个节点<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>单节点diff</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">以类型<span class="hljs-selector-tag">Object</span>为例，会进入这个函数reconcileSingleElement<br>复制代码<br></code></pre></td></tr></table></figure>

<p>参考 <a href="https://link.juejin.cn/?target=https://thoughts.teambition.com/share/638dda0502499a004515dc65">前端进阶面试题详细解答</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef216f1c4ed04a399f93b07638ee16d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这个函数会做如下事情：<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63f964815cd542eebaf613c194f198bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">让我们看看第二步判断DOM节点是否可以复用是如何实现的。<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/125009f3e191483ab5b5288c51d9559d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从代码可以看出，React通过先判断key是否相同，如果key相同则判断type是否相同，只有都相同时一个DOM节点才能复用。</p>
<p>这里有个细节需要关注下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><span class="hljs-string">.当child</span> <span class="hljs-type">!==</span> <span class="hljs-literal">null</span><span class="hljs-string">且key相同且type不同时执行deleteRemainingChildren将child及其兄弟fiber都标记删除。</span><br><br><span class="hljs-number">2</span><span class="hljs-string">.当child</span> <span class="hljs-type">!==</span> <span class="hljs-literal">null</span><span class="hljs-string">且key不同时仅将child标记删除。</span><br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>例子：当前页面有3个li，我们要全部删除，再插入一个p。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a985d0ba5b4b435cacc4ab9b2624c67f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>由于本次更新时只有一个p，属于单一节点的Diff，会走上面介绍的代码逻辑。</p>
<blockquote>
<p>解释：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">在reconcileSingleElement中遍历之前的<span class="hljs-number">3</span>个fiber（对应的DOM为<span class="hljs-number">3</span>个<span class="hljs-selector-tag">li</span>），寻找本次更新的<span class="hljs-selector-tag">p</span>是否可以复用之前的<span class="hljs-number">3</span>个fiber中某个的DOM。<br><br>当key相同且type不同时，代表我们已经找到本次更新的<span class="hljs-selector-tag">p</span>对应的上次的fiber，但是 <span class="hljs-selector-tag">p</span> 与 <span class="hljs-selector-tag">li</span> 的type不同，不能复用。<br>既然唯一的可能性已经不能复用，则剩下的fiber都没有机会了，所以都需要标记删除。<br><br>当key不同时只代表遍历到的该fiber不能被<span class="hljs-selector-tag">p</span>复用，后面还有兄弟fiber还没有遍历到。所以仅仅标记该fiber删除。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>练习题：</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d63fbcd0419e4830b5beb25a576ee240~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript">习题<span class="hljs-number">1</span>: 未设置key prop默认 key = <span class="hljs-literal">null</span>;，所以更新前后key相同，都为<span class="hljs-literal">null</span>，但是更新前<span class="hljs-keyword">type</span>为div，更新后为p，<span class="hljs-keyword">type</span>改变则不能复用。<br><br>习题<span class="hljs-number">2</span>: 更新前后key改变，不需要再判断<span class="hljs-keyword">type</span>，不能复用。<br><br>习题<span class="hljs-number">3</span>: 更新前后key没变，但是<span class="hljs-keyword">type</span>改变，不能复用。<br><br>习题<span class="hljs-number">4</span>: 更新前后key与<span class="hljs-keyword">type</span>都未改变，可以复用。children变化，<span class="hljs-variable constant_">DOM</span>的子元素需要更新。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>多节点diff</p>
</blockquote>
<p>同级多个节点的Diff，一定属于下面3中情况的一种或多种。</p>
<ul>
<li>情况1：节点更新</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b64fd4dd9c9448cd82302fa8f54a55d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>情况2：节点新增或减少</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e1977f0b6b44900a1f7164a0b28f344~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>情况3：节点位置变化</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a0fa6ded7254be79e6bb7e401510a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe">注意在这里diff算法无法使用双指针优化<br>在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。<br>复制代码<br>虽然本次更新的JSX对象 <span class="hljs-keyword">new</span><span class="hljs-type">Children</span>为数组形式，但是和<span class="hljs-keyword">new</span><span class="hljs-type">Children</span>中每个组件进行比较的是current fiber<br>同级的Fiber节点是由sibling指针链接形成的单链表。<br><br>即 <span class="hljs-keyword">new</span><span class="hljs-type">Children</span>[<span class="hljs-number">0</span>]与fiber比较，<span class="hljs-keyword">new</span><span class="hljs-type">Children</span>[<span class="hljs-number">1</span>]与fiber.sibling比较。<br>复制代码<br>所以无法使用双指针优化。<br>复制代码<br></code></pre></td></tr></table></figure>

<p>基于以上原因，Diff算法的整体逻辑会经历两轮遍历：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.第一轮遍历：处理更新的节点。<br>2.第二轮遍历：处理剩下的不属于更新的节点<br>复制代码<br></code></pre></td></tr></table></figure>

<p>第一轮遍历：</p>
<p>第一轮遍历步骤如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">let <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>，遍历newChildren，将newChildren<span class="hljs-selector-attr">[i]</span>与oldFiber比较，判断DOM节点是否可复用。<br><br>如果可复用，<span class="hljs-selector-tag">i</span>++，继续比较newChildren<span class="hljs-selector-attr">[i]</span>与oldFiber<span class="hljs-selector-class">.sibling</span>，可以复用则继续遍历。<br><br>如果不可复用，立即跳出整个遍历，第一轮遍历结束。<br><br>如果newChildren遍历完（即<span class="hljs-selector-tag">i</span> === newChildren<span class="hljs-selector-class">.length</span> - <span class="hljs-number">1</span>）或者oldFiber遍历完（即oldFiber<span class="hljs-selector-class">.sibling</span> === null）<br>跳出遍历，第一轮遍历结束。<br><br>上面<span class="hljs-number">3</span>跳出的遍历<br><br>此时newChildren没有遍历完，oldFiber也没有遍历完。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">前<span class="hljs-number">2</span>个节点可复用，遍历到key === <span class="hljs-number">2</span>的节点发现type改变，不可复用，跳出遍历。<br><br>此时oldFiber剩下key === <span class="hljs-number">2</span>未遍历，newChildren剩下key === <span class="hljs-number">2</span>、key === <span class="hljs-number">3</span>未遍历。<br><br>上面<span class="hljs-number">4</span>跳出的遍历<br><br>可能newChildren遍历完，或oldFiber遍历完，或他们同时遍历完。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上例子：</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ad899f9e68492eab0192e2cce3a079~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>带着第一轮遍历的结果，我们开始第二轮遍历。</p>
<p>第一轮遍历：（4种情况）</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- 1.newChildren与oldFiber同时遍历完 </span><br><br>那就是最理想的情况：只有组件更新。此时Diff结束。<br>复制代码<br><span class="hljs-deletion">- 2.newChildren没遍历完，oldFiber遍历完</span><br><br>已有的DOM节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入<br>我们只需要遍历剩下的newChildren为生成的workInProgress fiber依次标记Placement。<br>复制代码<br><span class="hljs-deletion">- 3.newChildren遍历完，oldFiber没遍历完</span><br><br>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的oldFiber，依次标记Deletion。<br>复制代码<br><span class="hljs-deletion">- 4.newChildren与oldFiber都没遍历完</span><br><br>这意味着有节点在这次更新中改变了位置。<br><br>改变了位置就需要我们处理移动的节点<br><br>由于有节点改变了位置，所以不能再用位置索引i对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？<br>我们需要使用key。<br><br>为了快速的找到key对应的oldFiber，我们将所有还未处理的oldFiber存入以key为key，oldFiber为value的Map中。<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ee1f48567714489a78fc9551e4f2c2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">接下来遍历剩余的newChildren，通过newChildren[i].<span class="hljs-keyword">key</span>就能在existingChildren中找到<span class="hljs-keyword">key</span>相同的oldFiber<br><br>标记节点是否移动<br>复制代码<br>!既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？<br>我们的参照物是：最后一个可复用的节点在oldFiber中的位置索引（用变量lastPlacedIndex表示）。<br>复制代码<br>由于本次更新中节点是按newChildren的顺序排列。<br>在遍历newChildren过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个<br>即一定在lastPlacedIndex对应的可复用的节点在本次更新中位置的后面。<br><br>那么我们只需要比较遍历到的可复用节点在上次更新时是否也在lastPlacedIndex对应的oldFiber后面<br>就能知道两次更新中这两个节点的相对位置改变没有。<br><br>我们用变量oldIndex表示遍历到的可复用节点在oldFiber中的位置索引。<br><br>如果oldIndex &lt; lastPlacedIndex，代表本次更新该节点需要向右移动。<br><br>lastPlacedIndex初始为<span class="hljs-number">0</span>，每遍历一个可复用的节点，如果oldFiber &gt;= lastPlacedIndex，则lastPlacedIndex = oldFiber。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="下面通过两个demo来看一下react团队的diff算法精髓"><a href="#下面通过两个demo来看一下react团队的diff算法精髓" class="headerlink" title="下面通过两个demo来看一下react团队的diff算法精髓"></a>下面通过两个demo来看一下react团队的diff算法精髓</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 之前 abcd` `<span class="hljs-regexp">//</span> 之后 acdb<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>（之后）vs <span class="hljs-selector-tag">a</span>（之前）  <br><br>key不变，可复用<br><br>此时 <span class="hljs-selector-tag">a</span> 对应的oldFiber（之前的<span class="hljs-selector-tag">a</span>）在之前的数组（abcd）中索引为<span class="hljs-number">0</span><br><br>所以 lastPlacedIndex = <span class="hljs-number">0</span>;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续第一轮遍历…</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">c（之后）vs b（之前）  <br><br>key改变，不能复用，跳出第一轮遍历<br><br>此时 lastPlacedIndex === <span class="hljs-number">0</span>;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">newChildren === cdb，没用完，不需要执行删除旧节点<br><br>oldFiber === bcd，没用完，不需要执行插入新节点<br><br>将剩余oldFiber（bcd）保存为map<br>复制代码<br><span class="hljs-comment">// 当前oldFiber：bcd</span><br><span class="hljs-comment">// 当前newChildren：cdb</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">key === c 在 oldFiber中存在<br><br><span class="hljs-keyword">const</span> oldIndex = c（之前）.<span class="hljs-property">index</span>;<br><br>此时 oldIndex === <span class="hljs-number">2</span>;  <span class="hljs-comment">// 之前节点为 abcd，所以c.index === 2</span><br><br>比较 oldIndex 与 lastPlacedIndex;<br><br>如果 oldIndex &gt;= lastPlacedIndex 代表该可复用节点不需要移动<br><br>并将 lastPlacedIndex = oldIndex;<br><br>如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动<br><br>在例子中，oldIndex <span class="hljs-number">2</span> &gt; lastPlacedIndex <span class="hljs-number">0</span>，<br><br>则 lastPlacedIndex = <span class="hljs-number">2</span>;<br><br>c节点位置不变<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：bd<br>// 当前newChildren：db<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> d 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> d（之前）.index<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">3</span> &gt; lastPlacedIndex <span class="hljs-number">2</span> // 之前节点为 abcd，所以d.index <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><br>则 lastPlacedIndex <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br><br>d节点位置不变<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：b<br>// 当前newChildren：b<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> b 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> b（之前）.index<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">1</span> &lt; lastPlacedIndex <span class="hljs-number">3</span> // 之前节点为 abcd，所以b.index <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><br>则 b节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">!最终acd <span class="hljs-number">3</span>个节点都没有移动，<span class="hljs-selector-tag">b</span>节点被标记为移动<br></code></pre></td></tr></table></figure>

<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 之前 abcd<br><span class="hljs-regexp">//</span> 之后 dabc<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">d（之后）vs <span class="hljs-selector-tag">a</span>（之前）  <br>key改变，不能复用，跳出遍历<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">newChildren === dabc，没用完，不需要执行删除旧节点<br><br>oldFiber === abcd，没用完，不需要执行插入新节点<br><br>将剩余oldFiber（abcd）保存为map<br><br>继续遍历剩余newChildren<br>复制代码<br><span class="hljs-comment">// 当前oldFiber：abcd</span><br><span class="hljs-comment">// 当前newChildren dabc</span><br>key === d 在 oldFiber中存在<br><br><span class="hljs-keyword">const</span> oldIndex = d（之前）.<span class="hljs-property">index</span>;<br><br>此时 oldIndex === <span class="hljs-number">3</span>; <span class="hljs-comment">// 之前节点为 abcd，所以d.index === 3</span><br><br>比较 oldIndex 与 lastPlacedIndex;<br><br>oldIndex <span class="hljs-number">3</span> &gt; lastPlacedIndex <span class="hljs-number">0</span><br><br>则 lastPlacedIndex = <span class="hljs-number">3</span>;<br><br>d节点位置不变<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：abc<br>// 当前newChildren abc<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> a 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> a（之前）.index<span class="hljs-comment">; // 之前节点为 abcd，所以a.index === 0</span><br><br>此时 oldIndex <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><br>比较 oldIndex 与 lastPlacedIndex<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">0</span> &lt; lastPlacedIndex <span class="hljs-number">3</span><br><br>则 a节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：bc<br>// 当前newChildren bc<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> b 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> b（之前）.index<span class="hljs-comment">; // 之前节点为 abcd，所以b.index === 1</span><br><br>此时 oldIndex <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><br>比较 oldIndex 与 lastPlacedIndex<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">1</span> &lt; lastPlacedIndex <span class="hljs-number">3</span><br><br>则 b节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：c<br>// 当前newChildren c<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> c 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> c（之前）.index<span class="hljs-comment">; // 之前节点为 abcd，所以c.index === 2</span><br><br>此时 oldIndex <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br><br>比较 oldIndex 与 lastPlacedIndex<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">2</span> &lt; lastPlacedIndex <span class="hljs-number">3</span><br><br>则 c节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">!可以看到，我们以为从 abcd 变为 dabc，只需要将d移动到前面。` `!但实际上React保持d不变，将abc分别移动到了d的后面。<br></code></pre></td></tr></table></figure>

<blockquote>
<p>用张老生常谈的图</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6d65e26b2a4b24be86f06a873852f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h2 id="9-继承"><a href="#9-继承" class="headerlink" title="9 继承"></a>9 继承</h2><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<p>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>(); <br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>()); <span class="hljs-comment">// true</span><br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></a></p>
<p>img</p>
<p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span></span>()&#123;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span></span>()&#123;&#125;<br><br>SubType.prototype = <span class="hljs-keyword">new</span> <span class="hljs-type">SuperType</span>();<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-type">SubType</span>();<br>instance1.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br>alert(instance1.colors); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-type">SubType</span>(); <br>alert(instance2.colors); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<h3 id="2、借用构造函数继承"><a href="#2、借用构造函数继承" class="headerlink" title="2、借用构造函数继承"></a>2、借用构造函数继承</h3><p>使用父类的构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类（不使用原型）</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">SuperType</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">this</span>.color=[<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>];<br>&#125;<br><span class="hljs-keyword">function</span>  <span class="hljs-title function_">SubType</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//继承自SuperType</span><br>    SuperType.call(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> SubType();<br>instance1.color.push(<span class="hljs-string">&quot;black&quot;</span>);<br>alert(instance1.color);<span class="hljs-comment">//&quot;red,green,blue,black&quot;</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> SubType();<br>alert(instance2.color);<span class="hljs-comment">//&quot;red,green,blue&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将SuperType中的属性复制一份。</p>
<p>缺点：</p>
<ul>
<li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性&#x2F;方法</li>
<li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<h3 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-comment">// 继承属性</span><br>  <span class="hljs-comment">// 第二次调用SuperType()</span><br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-comment">// 构建原型链</span><br><span class="hljs-comment">// 第一次调用SuperType()</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>(); <br><span class="hljs-comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">SubType</span>; <br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-title function_">alert</span>(instance1.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br>instance1.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">//&quot;Nicholas&quot;;</span><br>instance1.<span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">//29</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-title function_">alert</span>(instance2.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green&quot;</span><br>instance2.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">//&quot;Greg&quot;;</span><br>instance2.<span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">//27</span><br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c010c537ff8~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c010c537ff8~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></a></p>
<p>img</p>
<p>缺点：</p>
<ul>
<li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性name，color。</li>
<li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性name，color。</li>
</ul>
<p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性&#x2F;方法。</p>
<h3 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h3><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(obj)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title">F</span>()&#123;&#125;<br>  F.prototype = obj;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">new</span> F();<br>&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>object()对传入其中的对象执行了一次<code>浅复制</code>，将构造函数F的原型直接指向传入的对象。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-keyword">var</span> anotherPerson = object(person);<br>anotherPerson.name = <span class="hljs-string">&quot;Greg&quot;</span>;<br>anotherPerson.friends.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;Rob&quot;</span>);<br><br><span class="hljs-keyword">var</span> yetAnotherPerson = object(person);<br>yetAnotherPerson.name = <span class="hljs-string">&quot;Linda&quot;</span>;<br>yetAnotherPerson.friends.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;Barbie&quot;</span>);<br><br>alert(person.friends);   <span class="hljs-comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<p>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。</p>
<h3 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h3><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">clone</span> = <span class="hljs-keyword">object</span>(original); <span class="hljs-comment">// 通过调用 object() 函数创建一个新对象</span><br>  <span class="hljs-keyword">clone</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// 以某种方式来增强对象</span><br>    <span class="hljs-title function_ invoke__">alert</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">clone</span>; <span class="hljs-comment">// 返回这个对象</span><br>&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> person = &#123;<br>  <span class="hljs-built_in">na</span><span class="hljs-symbol">me:</span> <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>  frien<span class="hljs-symbol">ds:</span> [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><span class="hljs-built_in">var</span> anotherPerson = createAnother(person);<br>anotherPerson.sayHi(); //<span class="hljs-string">&quot;hi&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>缺点（同原型式继承）：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<h3 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h3><p>结合借用构造函数传递参数和寄生模式实现继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>)&#123;<br>  <span class="hljs-keyword">var</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span><br>  prototype.<span class="hljs-property">constructor</span> = subType;                    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br>  subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;                      <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span><br>&#125;<br><br><span class="hljs-comment">// 父类初始化实例属性和原型属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 将父类原型指向子类</span><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>, <span class="hljs-title class_">SuperType</span>);<br><br><span class="hljs-comment">// 新增子类原型属性</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;xyc&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;lxy&quot;</span>, <span class="hljs-number">23</span>);<br><br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span><br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span><br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></a></p>
<p>img</p>
<p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p>
<p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p>
<h3 id="7、混入方式继承多个对象"><a href="#7、混入方式继承多个对象" class="headerlink" title="7、混入方式继承多个对象"></a>7、混入方式继承多个对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyClass</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title class_">SuperClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>     <span class="hljs-title class_">OtherSuperClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继承一个类</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">SuperClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 混合其它</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">OtherSuperClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 重新指定constructor</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">MyClass</span>;<br><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">// do something</span><br>&#125;;<br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><code>Object.assign</code>会把 <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>
<h3 id="8、ES6类继承extends"><a href="#8、ES6类继承extends" class="headerlink" title="8、ES6类继承extends"></a>8、ES6类继承extends</h3><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-comment">// constructor</span><br>    <span class="hljs-keyword">constructor</span>(height, width) &#123;<br>        <span class="hljs-keyword">this</span>.height = height;<br>        <span class="hljs-keyword">this</span>.width = width;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Getter</span><br>    <span class="hljs-keyword">get</span> area() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calcArea()<br>    &#125;<br>    <br>    <span class="hljs-comment">// Method</span><br>    calcArea() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> rectangle = new Rectangle(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>console.log(rectangle.area);<br><span class="hljs-comment">// 输出 200</span><br><br>-----------------------------------------------------------------<br><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-title">extends</span> <span class="hljs-title">Rectangle</span> &#123;<br><br>  <span class="hljs-keyword">constructor</span>(length) &#123;<br>    <span class="hljs-keyword">super</span>(length, length);<br>    <br>    <span class="hljs-comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;Square&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> area() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> square = new Square(<span class="hljs-number">10</span>);<br>console.log(square.area);<br><span class="hljs-comment">// 输出 100</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_inherits(<span class="hljs-params">subType</span>, <span class="hljs-params">superType</span>)</span> &#123;<br>  <br>    <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span><br>    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br>    <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span><br>    subType.prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(superType<span class="hljs-operator"> &amp;&amp; </span>superType.prototype, &#123;<br>        constructor: &#123;<br>            value: subType,<br>            enumerable: <span class="hljs-literal">false</span>,<br>            writable: <span class="hljs-literal">true</span>,<br>            configurable: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">if</span> (superType) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>setPrototypeOf <br>            ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">subType</span>, <span class="hljs-params">superType</span>)</span> <br>            : subType.__proto__ = superType;<br>    &#125;<br>&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、函数声明和类声明的区别</p>
<p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let p = <span class="hljs-keyword">new</span> <span class="hljs-type">Rectangle</span>(); <br><span class="hljs-comment">// ReferenceError</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>2、ES5继承和ES6继承的区别</p>
<ul>
<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li>
<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>
</ul>
<h2 id="10-实用的BOM属性对象方法"><a href="#10-实用的BOM属性对象方法" class="headerlink" title="10 实用的BOM属性对象方法"></a>10 实用的BOM属性对象方法</h2><p>什么是Bom?Bom是浏览器对象。有哪些常用的Bom属性呢？ </p>
<h3 id="1-location对象"><a href="#1-location对象" class="headerlink" title="(1)location对象"></a>(1)location对象</h3><p>location.href–返回或设置当前文档的URL </p>
<p>location.search – 返回 URL 中的查询字符串部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu">http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu</a> 返回包括(?)后面的 内容 ?id&#x3D;5&amp;name&#x3D;dreamdu location.hash – 返回 URL#后面的内容，如果没有#，返回空 </p>
<p>location.host – 返回 URL 中的域名部分，例如<a target="_blank" rel="noopener" href="http://www.dreamdu.com/">www.dreamdu.com</a> </p>
<p>location.hostname – 返回 URL 中的主域名部分，例如 dreamdu.com </p>
<p>location.pathname – 返回 URL 的域名后的部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com/xhtml/">http://www.dreamdu.com/xhtml/</a> 返回&#x2F;xhtml&#x2F; </p>
<p>location.port – 返回 URL 中的端口部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com:8080/xhtml/">http://www.dreamdu.com:8080/xhtml/</a> </p>
<p>location.protocol – 返回 URL 中的协议部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com:8080/xhtml/">http://www.dreamdu.com:8080/xhtml/</a> 返回(&#x2F;&#x2F;)前面的内容 http: location.assign –设置当前文档的 URL </p>
<p>location.replace()– 设置当前文档的 URL，并且在 history 对象的地址列表中移除 这个 URL location.replace(url); </p>
<p>location.reload() – 重载当前页面</p>
<p><strong>在JavaScript中，可以通过以下几种方式获取URL中的参数值：</strong></p>
<ol>
<li>使用<code>window.location.search</code>属性获取URL的查询字符串，然后解析成对象，再获取指定参数的值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 假设当前URL为 http://example.com/?name=John&amp;age=30</span><br><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><span class="hljs-keyword">const</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// 获取 name 参数的值，值为 &quot;John&quot;</span><br><span class="hljs-keyword">const</span> age = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;age&#x27;</span>); <span class="hljs-comment">// 获取 age 参数的值，值为 &quot;30&quot;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>使用正则表达式获取URL中指定参数的值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 假设当前URL为 http://example.com/?name=John&amp;age=30</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getQueryParam</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">const</span> match = <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;[?&amp;]&#x27;</span> + name + <span class="hljs-string">&#x27;=([^&amp;]*)&#x27;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br>  <span class="hljs-keyword">return</span> match &amp;&amp; <span class="hljs-built_in">decodeURIComponent</span>(match[<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\+/g</span>, <span class="hljs-string">&#x27; &#x27;</span>));<br>&#125;<br><br><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">getQueryParam</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// 获取 name 参数的值，值为 &quot;John&quot;</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-title function_">getQueryParam</span>(<span class="hljs-string">&#x27;age&#x27;</span>); <span class="hljs-comment">// 获取 age 参数的值，值为 &quot;30&quot;</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，第二种方式只适用于获取单个参数的值，而第一种方式可以获取所有参数的值，如果需要获取多个参数的值，可以使用循环或其他方式遍历查询字符串中的所有参数。</p>
<h3 id="2-history对象"><a href="#2-history对象" class="headerlink" title="(2)history对象"></a>(2)history对象</h3><p>history.go() – 前进或后退指定的页面数 history.go(num); </p>
<p>history.back() – 后退一页 </p>
<p>history.forward() – 前进一页 </p>
<h3 id="3-Navigator对象"><a href="#3-Navigator对象" class="headerlink" title="(3)Navigator对象"></a>(3)Navigator对象</h3><p>navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) </p>
<p>navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie</p>
<h2 id="11-HTML5-drag-api"><a href="#11-HTML5-drag-api" class="headerlink" title="11 HTML5 drag api"></a>11 HTML5 drag api</h2><p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 </p>
<p>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 </p>
<p>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</p>
<p>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 </p>
<p>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 </p>
<p>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 </p>
<p>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</p>
<p><strong>接下来我们看一个简单的例子：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc0b0b0bd1b4dfab7db7fcb7dca12ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="DnD-1.gif"></p>
<p>代码地址：<a href="https://link.juejin.cn/?target=https://codepen.io/wuzhengyan2015/pen/abwxVEV">codepen.io&#x2F;wuzhengyan2…</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drop-area&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drag-el&quot;</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>window.onload = () =&gt; &#123;<br>  const dragEl = document.querySelector(&#x27;#drag-el&#x27;)<br>  const dropArea = document.querySelector(&#x27;#drop-area&#x27;)<br><br>  dragEl.addEventListener(&#x27;dragstart&#x27;, (event) =&gt; &#123;<br>    event.dataTransfer.setData(&#x27;text/plain&#x27;, event.target.id)<br>  &#125;)<br>  dropArea.addEventListener(&#x27;dragover&#x27;, (event) =&gt; &#123;<br>    event.preventDefault()<br>  &#125;)<br>  dropArea.addEventListener(&#x27;drop&#x27;, (event) =&gt; &#123;<br>    const id = event.dataTransfer.getData(&#x27;text/plain&#x27;)<br>    dropArea.appendChild(document.getElementById(id))<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述例子就一个简单的拖放操作，让我们看下例子中拖放的三个重要点都是怎么实现的。</p>
<ol>
<li>元素可拖拽：DOM 属性上设置 draggable&#x3D;true</li>
<li>元素可放置：监听 dragover 事件，事件中调用 preventDefault</li>
<li>拖放数据传递；可拖拽元素监听 dragstart 事件，调用 dataTransfer 对象的 setData 方法，可放置元素监听 drop 事件，使用 dataTransfer 对象的 getData 方法获取设置的数据。</li>
</ol>
<p>可以看到，一个拖放操作实现起来还是很简洁的。</p>
<h2 id="12-序列化-x2F-反序列化"><a href="#12-序列化-x2F-反序列化" class="headerlink" title="12 序列化&#x2F;反序列化"></a>12 序列化&#x2F;反序列化</h2><h3 id="序列化：js中的object转化为字符串"><a href="#序列化：js中的object转化为字符串" class="headerlink" title="序列化：js中的object转化为字符串"></a>序列化：js中的object转化为字符串</h3><p>1.使用toJSONString</p>
<p><code>var last=obj.toJSONString(); //将JSON对象转化为JSON字符</code></p>
<p>2.使用stringify</p>
<p><code>var last=JSON.stringify(obj); //将JSON对象转化为JSON字符  </code></p>
<p>3.json转字符串函数</p>
<pre><code class="hljs">    var json = &#123;a:1,b:2,c:3&#125;;
    var arr = [];
    for ( name in json) &#123;
        arr.push(name+&#39;:&#39;+json[name]);
    &#125;
    var str = arr.join(&#39;,&#39;);
    alert(str);
</code></pre>
<h3 id="反序列化：json字符串转化为object"><a href="#反序列化：json字符串转化为object" class="headerlink" title="反序列化：json字符串转化为object"></a>反序列化：json字符串转化为object</h3><p>1.eval</p>
<p><code>var obj=eval(&quot;(&quot;+data+&quot;)&quot;);  </code></p>
<p>2.使用parseJSON</p>
<p><code>var obj = data.parseJSON(); //由JSON字符串转换为JSON对象  </code></p>
<p>3.使用parse</p>
<p><code>var obj = JSON.parse(data); //由JSON字符串转换为JSON对象 </code></p>
<p>4.使用封装函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convertCartStrToObj</span>(<span class="hljs-params">cartStr</span>)&#123;        <br>         <span class="hljs-keyword">var</span> obj =&#123;&#125;;<br>        <span class="hljs-comment">//将字符串name:17dian,key:123456,tel:18810701077 按“,”拆分成数组[&quot;name:17dian&quot;, &quot;key:123456&quot;, &quot;tel:18810701077&quot;]</span><br>         <span class="hljs-keyword">var</span> arrVal = cartStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);  <br>         <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arrVal.<span class="hljs-property">length</span> ;i++)&#123;<br>                  data = arrVal[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>); <span class="hljs-comment">// 在将每一项拆分 例如arrVal[0]时 data =[&quot;name&quot;, &quot;17dian&quot;]</span><br>                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>                  obj[data[<span class="hljs-number">0</span>]] = data[<span class="hljs-number">1</span>]; <span class="hljs-comment">//给对象添加属性</span><br>         &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-web-worker"><a href="#13-web-worker" class="headerlink" title="13 web worker"></a>13 web worker</h2><p>Web Worker (工作线程) 是 HTML5 中提出的概念，分为两种类型，专用线程（Dedicated Web Worker） 和共享线程（Shared Web Worker）。专用线程仅能被创建它的脚本所使用（一个专用线程对应一个主线程），而共享线程能够在不同的脚本中使用（一个共享线程对应多个主线程）。</p>
<p>专用线程可以看做是默认情况的 Web Worker，其加上修饰词的目的是为了与共享线程进行区分。本文会较为严格地区分两者，可能较为累赘，但个人认为这是必要的。如果单纯以 <code>Web Worker</code> 字样出现的地方指的是两者都会有的情况。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Web Worker 的意义在于可以将一些耗时的数据处理操作从主线程中剥离，使主线程更加专注于页面渲染和交互。</p>
<ul>
<li>懒加载</li>
<li>文本分析</li>
<li>流媒体数据处理</li>
<li>canvas 图形绘制</li>
<li>图像处理</li>
<li>…</li>
</ul>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ul>
<li>有同源限制</li>
<li>无法访问 DOM 节点</li>
<li>运行在另一个上下文中，无法使用Window对象</li>
<li>Web Worker 的运行不会影响主线程，但与主线程交互时仍受到主线程单线程的瓶颈制约。换言之，如果 Worker 线程频繁与主线程进行交互，主线程由于需要处理交互，仍有可能使页面发生阻塞</li>
<li>共享线程可以被多个浏览上下文（Browsing context）调用，但所有这些浏览上下文必须同源（相同的协议，主机和端口号）</li>
</ul>
<h3 id="浏览器支持度"><a href="#浏览器支持度" class="headerlink" title="浏览器支持度"></a>浏览器支持度</h3><p>根据 CanI Use 网站的统计，目前约有 93.05% 的浏览器支持专用线程。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af51cf353eb148529ba8041ad484e5bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image"></p>
<p>而对于共享线程，则仅有大约 41.66% 的浏览器支持。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d24fb447b7e340e1b186ec890dfdef54~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image"></p>
<p>由于专用线程和共享线程的构造方法都包含在 window 对象中，我们在使用两者之前可以对浏览器的支持性进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">Worker</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>复制代码<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">SharedWorker</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>专用线程由 <code>Worker()</code>方法创建，可以接收两个参数，第一个参数是必填的脚本的位置，第二个参数是可选的配置对象，可以指定 <code>type</code>、<code>credentials</code>、<code>name</code> 三个属性。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>)<br>// var <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>, &#123; name: <span class="hljs-string">&#x27;dedicatedWorker&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>共享线程使用 <code>Shared Worker()</code> 方法创建，同样支持两个参数，用法与 <code>Worker()</code> 一致。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> SharedWorker(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>值得注意的是，因为 Web Worker 有同源限制，所以在本地调试的时候也需要通过启动本地服务器的方式访问，使用 <code>file://</code> 协议直接打开的话将会抛出异常。</p>
<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>Worker 线程和主线程都通过 <code>postMessage()</code> 方法发送消息，通过 <code>onmessage</code> 事件接收消息。在这个过程中数据并不是被共享的，而是被复制的。值得注意的是 <code>Error</code> 和 <code>Function</code> 对象不能被结构化克隆算法复制，如果尝试这么做的话会导致抛出 <code>DATA_CLONE_ERR</code> 的异常。另外，<code>postMessage()</code> 一次只能发送一个对象， 如果需要发送多个参数可以将参数包装为数组或对象再进行传递。</p>
<p>关于 <code>postMessage()</code> 和结构化克隆算法（The structured clone algorithm）将在本文最后进行阐述。</p>
<p>下面是专用线程数据传递的示例。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 主线程</span><br><span class="hljs-selector-tag">var</span> worker = new <span class="hljs-built_in">Worker</span>(&#x27;worker.js&#x27;)<br>worker<span class="hljs-selector-class">.postMessage</span>([<span class="hljs-number">10</span>, <span class="hljs-number">24</span>])<br>worker<span class="hljs-selector-class">.onmessage</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>    console<span class="hljs-selector-class">.log</span>(e.data)<br>&#125;<br><br><span class="hljs-comment">// Worker 线程</span><br>onmessage = function (e) &#123;<br>    if (e.data.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">postMessage</span>(e.data[<span class="hljs-number">1</span>] - e.data[<span class="hljs-number">0</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Worker 线程中，<code>self</code> 和 <code>this</code> 都代表子线程的全局对象。对于监听 <code>message</code> 事件，以下的四种写法是等同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法 1</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 2</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 3</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 4</span><br>onmessage = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>主线程通过 <code>MessagePort</code> 访问专用线程和共享线程。专用线程的 port 会在线程创建时自动设置，并且不会暴露出来。与专用线程不同的是，共享线程在传递消息之前，端口必须处于打开状态。MDN 上的 <code>MessagePort</code> 关于 <code>start()</code> 方法的描述是：</p>
<blockquote>
<p>Starts the sending of messages queued on the port (only needed when using EventTarget.addEventListener; it is implied when using MessagePort.onmessage.)</p>
</blockquote>
<p>这句话经过试验，可以理解为 <code>start()</code> 方法是与 <code>addEventListener</code> 配套使用的。如果我们选择 <code>onmessage</code> 进行事件监听，那么将隐含调用 <code>start()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 业务逻辑</span><br>&#125;<br>复制代码<br><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 业务逻辑</span><br>&#125;, <span class="hljs-literal">false</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">start</span>() <span class="hljs-comment">// 需要显式打开</span><br></code></pre></td></tr></table></figure>

<p>在传递消息时，<code>postMessage()</code> 方法和 <code>onmessage</code> 事件必须通过端口对象调用。另外，在 Worker 线程中，需要使用 <code>onconnect</code> 事件监听端口的变化，并使用端口的消息处理函数进行响应。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 主线程<br>sharedWorker.port.postMessage(<span class="hljs-section">[10, 24]</span>)<br><span class="hljs-attr">sharedWorker.port.onmessage</span> = function (e) &#123;<br>    console.log(e.data)<br>&#125;<br><br>// Worker 线程<br><span class="hljs-attr">onconnect</span> = function (e) &#123;<br>    let <span class="hljs-attr">port</span> = e.ports[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-attr">port.onmessage</span> = function (e) &#123;<br>        if (e.data.length &gt; 1) &#123;<br>            port.postMessage(e.data<span class="hljs-section">[1]</span> - e.data<span class="hljs-section">[0]</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="关闭-Worker"><a href="#关闭-Worker" class="headerlink" title="关闭 Worker"></a>关闭 Worker</h3><p>可以在主线程中使用 <code>terminate()</code> 方法或在 Worker 线程中使用 <code>close()</code> 方法关闭 worker。这两种方法是等效的，但比较推荐的用法是使用 <code>close()</code>，防止意外关闭正在运行的 Worker 线程。Worker 线程一旦关闭 Worker 后 Worker 将不再响应。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 主线程</span><br>worker<span class="hljs-selector-class">.terminate</span>()<br><br><span class="hljs-comment">// Dedicated Worker 线程中</span><br>self<span class="hljs-selector-class">.close</span>()<br><br><span class="hljs-comment">// Shared Worker 线程中</span><br>self<span class="hljs-selector-class">.port</span><span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>可以通过在主线程或 Worker 线程中设置 <code>onerror</code> 和 <code>onmessageerror</code> 的回调函数对错误进行处理。其中，<code>onerror</code> 在 Worker 的 <code>error</code> 事件触发并冒泡时执行，<code>onmessageerror</code> 在 Worker 收到的消息不能进行反序列化时触发(本人经过尝试没有办法触发 <code>onmessageerror</code> 事件，如果在 worker 线程使用 <code>postMessage</code> 方法传递一个 Error 或 Function 对象会因为无法序列化优先被 <code>onerror</code> 方法捕获，而根本不会进入反序列化的过程)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程</span><br>worker.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 主线程使用专用线程</span><br>worker.<span class="hljs-property">onmessageerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 主线程使用共享线程</span><br>worker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessageerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// worker 线程</span><br>onerror = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="加载外部脚本"><a href="#加载外部脚本" class="headerlink" title="加载外部脚本"></a>加载外部脚本</h3><p>Web Worker 提供了 <code>importScripts()</code> 方法，能够将外部脚本文件加载到 Worker 中。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">importScripts</span>(&#x27;script1.js&#x27;)<br><span class="hljs-built_in">importScripts</span>(&#x27;script2.js&#x27;)<br><br><span class="hljs-comment">// 以上写法等价于</span><br><span class="hljs-built_in">importScripts</span>(&#x27;script1.js&#x27;, &#x27;script2.js&#x27;)<br></code></pre></td></tr></table></figure>

<h3 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h3><p>Worker 可以生成子 Worker，但有两点需要注意。</p>
<ul>
<li>子 Worker 必须与父网页同源</li>
<li>子 Worker 中的 URI 相对于父 Worker 所在的位置进行解析</li>
</ul>
<h3 id="嵌入式-Worker"><a href="#嵌入式-Worker" class="headerlink" title="嵌入式 Worker"></a>嵌入式 Worker</h3><p>目前没有一类标签可以使 Worker 的代码像 <code>&lt;script&gt;</code> 元素一样嵌入网页中，但我们可以通过 <code>Blob()</code> 将页面中的 Worker 代码进行解析。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;worker&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;javascript/worker&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 这段代码不会被 JS 引擎直接解析，因为类型是 &#x27;javascript/worker&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 在这里写 Worker 线程的逻辑</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> workerScript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#worker&#x27;</span>).<span class="hljs-property">textContent</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([workerScript], &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/javascript&quot;</span>&#125;)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="关于-postMessage"><a href="#关于-postMessage" class="headerlink" title="关于 postMessage"></a>关于 postMessage</h3><p>Web Worker 中，Worker 线程和主线程之间使用结构化克隆算法（The structured clone algorithm）进行数据通信。结构化克隆算法是一种通过递归输入对象构建克隆的算法，算法通过保存之前访问过的引用的映射，避免无限遍历循环。这一过程可以理解为，在发送方使用类似 <code>JSON.stringfy()</code> 的方法将参数序列化，在接收方采用类似 <code>JSON.parse()</code> 的方法反序列化。</p>
<p>但是，一次数据传输就需要同时经过序列化和反序列化，如果数据量大的话，这个过程本身也可能造成性能问题。因此， Worker 中提出了 <code>Transferable Objects</code> 的概念，当数据量较大时，我们可以选择在将主线程中的数据直接移交给 Worker 线程。值得注意的是，这种转移是彻底的，一旦数据成功转移，主线程将不能访问该数据。这个移交的过程仍然通过 <code>postMessage</code> 进行传递。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">postMessage</span>(message, transferList)<br></code></pre></td></tr></table></figure>

<p>例如，传递一个 ArrayBuffer 对象</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">aBuffer</span> = new ArrayBuffer(<span class="hljs-number">1</span>)<br>worker.postMessage(&#123; data: aBuffer &#125;, <span class="hljs-section">[aBuffer]</span>)<br></code></pre></td></tr></table></figure>

<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>Worker 工作在一个 <code>WorkerGlobalDataScope</code> 的上下文中。每一个 <code>WorkerGlobalDataScope</code> 对象都有不同的 <code>event loop</code>。这个 <code>event loop</code> 没有关联浏览器上下文（browsing context），它的任务队列也只有事件（events）、回调（callbacks）和联网的活动（networking activity）。</p>
<p>每一个 <code>WorkerGlobalDataScope</code> 都有一个 <code>closing</code> 标志，当这个标志设为 <code>true</code> 时，任务队列将丢弃之后试图加入任务队列的任务，队列中已经存在的任务不受影响（除非另有指定）。同时，定时器将停止工作，所有挂起（pending）的后台任务将会被删除。</p>
<h3 id="Worker-中可以使用的函数和类"><a href="#Worker-中可以使用的函数和类" class="headerlink" title="Worker 中可以使用的函数和类"></a>Worker 中可以使用的函数和类</h3><p>由于 Worker 工作的上下文不同于普通的浏览器上下文，因此不能访问 window 以及 window 相关的 API，也不能直接操作 DOM。Worker 中提供了 <code>WorkerNavigator</code> 和 <code>WorkerLocation</code> 接口，它们分别是 window 中 <code>Navigator</code> 和 <code>Location</code> 的子集。除此之外，Worker 还提供了涉及时间、存储、网络、绘图等多个种类的接口，以下列举了其中的一部分，更多的接口可以参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers">MDN 文档</a>。</p>
<h4 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h4><ul>
<li>clearInterval()</li>
<li>clearTimeout()</li>
<li>setInterval()</li>
<li>setTimeout</li>
</ul>
<h4 id="Worker-相关"><a href="#Worker-相关" class="headerlink" title="Worker 相关"></a>Worker 相关</h4><ul>
<li>importScripts()</li>
<li>close()</li>
<li>postMessage()</li>
</ul>
<h4 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h4><ul>
<li>Cache</li>
<li>IndexedDB</li>
</ul>
<h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><ul>
<li>Fetch</li>
<li>WebSocket</li>
<li>XMLHttpRequest</li>
</ul>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">使用 Web Workers - Web APIs | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker">Worker | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort">MessagePort | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://html.spec.whatwg.org/multipage/workers.html">HTML Standard - Web workers</a></li>
<li><a href="https://link.juejin.cn/?target=https://www.html5rocks.com/zh/tutorials/workers/basics/">Web Workers 的基本信息</a></li>
</ul>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://fed.taobao.org/blog/taofed/do71ct/canvas-performance">Canvas 最佳实践 - 淘宝FED</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Worklet">Worklet</a></li>
</ul>
<h2 id="14-addEventListener参数"><a href="#14-addEventListener参数" class="headerlink" title="14 addEventListener参数"></a>14 addEventListener参数</h2><p><code>element.addEventListener(event, function, useCapture)</code></p>
<h3 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>event</em></td>
<td align="left">必须。字符串，指定事件名。  <strong>注意:</strong> 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。  <strong>提示：</strong> 所有 HTML DOM 事件，可以查看我们完整的 <a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM Event 对象参考手册</a>。</td>
</tr>
<tr>
<td align="left"><em>function</em></td>
<td align="left">必须。指定要事件触发时执行的函数。  当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</td>
</tr>
<tr>
<td align="left"><em>useCapture</em></td>
<td align="left">可选。布尔值，指定事件是否在捕获或冒泡阶段执行。  可能值:true - 事件句柄在捕获阶段执行false- false- 默认。事件句柄在冒泡阶段执行</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myBtn&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;Hello World&quot;</span>;<br> <br>&#125;);<br> <br></code></pre></td></tr></table></figure>

<p>提示： 使用 removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄。</p>
<p>参数值</p>
<p>event 必须。字符串，指定事件名。</p>
<p>注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。</p>
<p>function 必须。指定要事件触发时执行的函数。</p>
<p>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</p>
<p>useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。</p>
<p>可能值:</p>
<p>true - 事件句柄在捕获阶段执行</p>
<p>false- false- 默认。事件句柄在冒泡阶段执行</p>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>click 当用户点击某个对象时调用的事件句柄。</p>
<p>contextmenu 在用户点击鼠标右键打开上下文菜单时触发</p>
<p>dblclick 当用户双击某个对象时调用的事件句柄。</p>
<p>mousedown 鼠标按钮被按下。</p>
<p>mouseenter 当鼠标指针移动到元素上时触发。</p>
<p>mouseleave 当鼠标指针移出元素时触发</p>
<p>mousemove 鼠标被移动。</p>
<p>mouseover 鼠标移到某元素之上。</p>
<p>mouseout 鼠标从某元素移开。</p>
<p>mouseup 鼠标按键被松开。</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>属性 描述 DOM</p>
<p>keydown 某个键盘按键被按下。</p>
<p>keypress 某个键盘按键被按下并松开。</p>
<p>keyup 某个键盘按键被松开。</p>
<p>框架&#x2F;对象（Frame&#x2F;Object）事件</p>
<p>abort 图像的加载被中断。 ( )</p>
<p>beforeunload 该事件在即将离开页面（刷新或关闭）时触发</p>
<p>error 在加载文档或图像时发生错误。 ( , 和 )</p>
<p>hashchange 该事件在当前 URL 的锚部分发生修改时触发。</p>
<p>load 一张页面或一幅图像完成加载。</p>
<p>pageshow 该事件在用户访问页面时触发</p>
<p>pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发</p>
<p>resize 窗口或框架被重新调整大小。</p>
<p>scroll 当文档被滚动时发生的事件。</p>
<p>unload 用户退出页面。 ( 和 )</p>
<h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><p>blur 元素失去焦点时触发</p>
<p>change 该事件在表单元素的内容改变时触发( , , , 和 )</p>
<p>focus 元素获取焦点时触发</p>
<p>focusin 元素即将获取焦点是触发</p>
<p>focusout 元素即将失去焦点是触发</p>
<p>input 元素获取用户输入是触发</p>
<p>reset 表单重置时触发</p>
<p>search 用户向搜索域输入文本时触发 (</p>
<h4 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h4><p>copy 该事件在用户拷贝元素内容时触发</p>
<p>cut 该事件在用户剪切元素内容时触发</p>
<p>paste 该事件在用户粘贴元素内容时触发</p>
<h4 id="打印事件"><a href="#打印事件" class="headerlink" title="打印事件"></a>打印事件</h4><p>afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发</p>
<p>beforeprint 该事件在页面即将开始打印时触发</p>
<h4 id="拖动事件"><a href="#拖动事件" class="headerlink" title="拖动事件"></a>拖动事件</h4><p>drag 该事件在元素正在拖动时触发</p>
<p>dragend 该事件在用户完成元素的拖动时触发</p>
<p>dragenter 该事件在拖动的元素进入放置目标时触发</p>
<p>dragleave 该事件在拖动元素离开放置目标时触发</p>
<p>dragover 该事件在拖动元素在放置目标上时触发</p>
<p>dragstart 该事件在用户开始拖动元素时触发</p>
<p>drop 该事件在拖动元素放置在目标区域时触发</p>
<h4 id="多媒体（Media）事件"><a href="#多媒体（Media）事件" class="headerlink" title="多媒体（Media）事件"></a>多媒体（Media）事件</h4><p>abort 事件在视频&#x2F;音频（audio&#x2F;video）终止加载时触发。</p>
<p>canplay 事件在用户可以开始播放视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>canplaythrough 事件在视频&#x2F;音频（audio&#x2F;video）可以正常播放且无需停顿和缓冲时触发。</p>
<p>durationchange 事件在视频&#x2F;音频（audio&#x2F;video）的时长发生变化时触发。</p>
<p>emptied The event occurs when the current playlist is empty</p>
<p>ended 事件在视频&#x2F;音频（audio&#x2F;video）播放结束时触发。</p>
<p>error 事件在视频&#x2F;音频（audio&#x2F;video）数据加载期间发生错误时触发。</p>
<p>loadeddata 事件在浏览器加载视频&#x2F;音频（audio&#x2F;video）当前帧时触发触发。</p>
<p>loadedmetadata 事件在指定视频&#x2F;音频（audio&#x2F;video）的元数据加载后触发。</p>
<p>loadstart 事件在浏览器开始寻找指定视频&#x2F;音频（audio&#x2F;video）触发。</p>
<p>pause 事件在视频&#x2F;音频（audio&#x2F;video）暂停时触发。</p>
<p>play 事件在视频&#x2F;音频（audio&#x2F;video）开始播放时触发。</p>
<p>playing 事件在视频&#x2F;音频（audio&#x2F;video）暂停或者在缓冲后准备重新开始播放时触发。</p>
<p>progress 事件在浏览器下载指定的视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>ratechange 事件在视频&#x2F;音频（audio&#x2F;video）的播放速度发送改变时触发。</p>
<p>seeked 事件在用户重新定位视频&#x2F;音频（audio&#x2F;video）的播放位置后触发。</p>
<p>seeking 事件在用户开始重新定位视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。</p>
<p>suspend 事件在浏览器读取媒体数据中止时触发。</p>
<p>timeupdate 事件在当前的播放位置发送改变时触发。</p>
<p>volumechange 事件在音量发生改变时触发。</p>
<p>waiting 事件在视频由于要播放下一帧而需要缓冲时触发。</p>
<h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><p>animationend 该事件在 CSS 动画结束播放时触发</p>
<p>animationiteration 该事件在 CSS 动画重复播放时触发</p>
<p>animationstart 该事件在 CSS 动画开始播放时触发</p>
<h4 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h4><p>transitionend 该事件在 CSS 完成过渡后触发。</p>
<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发</p>
<p>online 该事件在浏览器开始在线工作时触发。</p>
<p>offline 该事件在浏览器开始离线工作时触发。</p>
<p>popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。</p>
<h2 id="15-cookie、sessionStorage和localStorage的区别"><a href="#15-cookie、sessionStorage和localStorage的区别" class="headerlink" title="15 cookie、sessionStorage和localStorage的区别"></a>15 cookie、sessionStorage和localStorage的区别</h2><p>一、 概念的理解</p>
<h3 id="webstorage本地存储"><a href="#webstorage本地存储" class="headerlink" title="webstorage本地存储"></a>webstorage本地存储</h3><p>1）webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage</p>
<p>2）localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信</p>
<p>3）sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>
<p>4）WebStorage的目标</p>
<p>提供一种在cookie之外存储会话数据的路径</p>
<p>提供一种存储大量可以跨会话存在的数据的机制</p>
<p>HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）</p>
<p>5）作用域的不同：</p>
<p>不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p>
<p>6）存储大小：</p>
<p>localStorage和sessionStorage的存储数据大小一般都是：5MB</p>
<p>7）存储位置：</p>
<p>localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信</p>
<p>8）存储内容类型：</p>
<p>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p>
<p>9）获取方式：</p>
<p>localStorage：window.localStorage;；sessionStorage：window.sessionStorage;</p>
<p>10）应用场景：</p>
<p>localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据，而sessionStorage：敏感账号一次性登录</p>
<p>11）WebStorage的优点：</p>
<p>存储空间更大：cookie为4KB，而WebStorage是5MB</p>
<p>节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量</p>
<p>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便</p>
<p>快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快</p>
<p>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题</p>
<p>WebStorage提供了一些方法，数据操作比cookie方便</p>
<p>setItem (key, value) —— 保存数据，以键值对的方式储存信息。</p>
<p>getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。</p>
<p>removeItem (key) —— 删除单个数据，根据键值移除对应的信息。</p>
<p>clear () —— 删除所有的数据</p>
<p>key (index) —— 获取某个索引的key</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>1）HTTP Cookie简称cookie,在HTTP请求发送Set-Cookie HTTP头作为响应的一部分。通过name&#x3D;value的形式存储</p>
<p>2）cookie的构成：</p>
<p>名称：name(不区分大小写,但最好认为它是区分的)</p>
<p>值:value(通过URL编码:encodeURIComponent)</p>
<p>域</p>
<p>路径</p>
<p>失效时间:一般默认是浏览器关闭失效,可以自己设置失效时间</p>
<p>安全标志:设置安全标志后只有SSL连接的时候才发送到服务器</p>
<p>3）cookie的作用:主要用于保存登录信息</p>
<p>4）生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>
<p>5）cookie的优点：具有极高的扩展性和可用性</p>
<p>通过良好的编程，控制保存在cookie中的session对象的大小</p>
<p>通过加密和安全传输技术，减少cookie被破解的可能性</p>
<p>只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失</p>
<p>控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie</p>
<p>6）cookie的缺点：</p>
<p>cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉</p>
<p>安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用</p>
<p>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用</p>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>1）sessionStorage是Storage类型的一个对象，拥有clear(),getItem(name),key(index),removeItem(name),setItem(name,value)方法</p>
<p>2）sessionStorage对象存储特定于某个会话的数据,也就是该数据只保持到浏览器关闭</p>
<p>3）将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据</p>
<p>4）sessionStorage为临时保存</p>
<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>1）localStorage也是Storage类型的一个对象</p>
<p>2）在HTML5中localStorage作为持久保存在客户端数据的方案取代了globalStorage(globalStorage必须指定域名)</p>
<p>3）localStorage会永久存储会话数据，除非removeItem,否则会话数据一直存在</p>
<p>4）将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用</p>
<p>5）localStorage为永久保存</p>
<p>图示说明：</p>
<p>注意：时刻注意XSS注入的风险，因为可以在控制台直接访问它们，所以不要存入敏感数据</p>
<h3 id="区别的比较"><a href="#区别的比较" class="headerlink" title="区别的比较"></a>区别的比较</h3><p>本地储存localStorage与cookie的区别</p>
<p>1）cookie在浏览器与服务器之间来回传递</p>
<p>sessionStorage和localStorage不会把数据发给服务器，仅在本地保存</p>
<p>2）数据有效期不同</p>
<p>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<p>sessionStorage：仅在当前浏览器窗口关闭前有效</p>
<p>localStorage 始终有效，长期保存</p>
<p>3）cookie数据还有路径的概念，可以限制cookie只属于某个路径下</p>
<p>存储大小也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>4）作用域不用</p>
<p>sessionStorage不在不同的浏览器窗口中共享</p>
<p>localStorage在所有同源窗口中都是共享的</p>
<p>cookie也是在所有同源窗口中都是共享的</p>
<p>WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便</p>
<h4 id="cookie、session和localStorage的区别"><a href="#cookie、session和localStorage的区别" class="headerlink" title="cookie、session和localStorage的区别"></a>cookie、session和localStorage的区别</h4><p>1）cookie的内容主要包括：名字、值、过期时间、路径和域，路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失，这种生命期为浏览器会话期的cookie被称为会话cookie</p>
<p>2）会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。</p>
<p>3）当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</p>
<h4 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h4><p>1）cookie数据存放在客户的浏览器上，session数据放在服务器上</p>
<p>2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</p>
<p>3）session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</p>
<p>4）单个cookie保存的数*据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</p>
<p>5）建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中</p>
<p>6）session保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息</p>
<p>7）session中保存的是对象，cookie中保存的是字符串</p>
<p>8）session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的</p>
<h4 id="web-Storage和cookie的区别"><a href="#web-Storage和cookie的区别" class="headerlink" title="web Storage和cookie的区别"></a>web Storage和cookie的区别</h4><p>1）Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用</p>
<p>2）web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie</p>
<p>3）但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生</p>
<p>sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的</p>
<p>4）Web Storage的好处</p>
<p>减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递</p>
<p>快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示</p>
<p>临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便</p>
<h4 id="浏览器本地存储与服务器端存储的区别"><a href="#浏览器本地存储与服务器端存储的区别" class="headerlink" title="浏览器本地存储与服务器端存储的区别"></a>浏览器本地存储与服务器端存储的区别</h4><p>1）数据既可以在浏览器本地存储，也可以在服务器端存储</p>
<p>2）浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据</p>
<p>3）服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据</p>
<p>4）服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端 ，服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上</p>
<p>5）服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期</p>
<p>6）服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据</p>
<h4 id="sessionStorage、localStorage和cookie的区别"><a href="#sessionStorage、localStorage和cookie的区别" class="headerlink" title="sessionStorage、localStorage和cookie的区别"></a>sessionStorage、localStorage和cookie的区别</h4><p>1）相同点是都是保存在浏览器端、且同源的</p>
<p>2）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
<p>3）存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>4）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>5）作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
<p>6）web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p>
<p>7）web Storage的api接口使用更方便</p>
<h4 id="sessionStorage与页面js数据对象的区别"><a href="#sessionStorage与页面js数据对象的区别" class="headerlink" title="sessionStorage与页面js数据对象的区别"></a>sessionStorage与页面js数据对象的区别</h4><p>1）页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了</p>
<p>2）sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在</p>
<h2 id="16-js中的垃圾回收机制"><a href="#16-js中的垃圾回收机制" class="headerlink" title="16 js中的垃圾回收机制"></a>16 js中的垃圾回收机制</h2><p>本文主要围绕JS引擎相关知识，来深入了解底层运行逻辑，这对于日常开发维护高性能Javascript代码以及排查代码性能问题有着很好的帮助。关于JS引擎底层的垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化，实现对JS内存管理以及内存溢出的处理。</p>
<p>那么我们需要考虑几个问题：</p>
<ul>
<li>什么是垃圾回收机制（GC）？</li>
<li>垃圾是怎样产生的？</li>
<li>为什么要进行垃圾回收？</li>
<li>Javascript的内存是如何管理的？</li>
<li>Chrome浏览器又是如何进行垃圾回收的？</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在Javascript编程中，内存管理大概分成三个步骤，也是内存的生命周期：</p>
<ul>
<li>分配你所需系统内存的空间</li>
<li>使用分配到的内存进行读写操作</li>
<li>不需要使用内存时，将空间进行释放和归还</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ca5e11ded7433cbf09a98a70856d29~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (4).png"></p>
<p>与其它手动管理内存的语言不一样的是，在Javascript中，当我们创建变量时，系统会给对象进行自动分配对应的内存空间以及闲置资源回收，也就是不需要我们手动进行分配。但是，正是因为垃圾回收机制导致开发者有着错误的感觉，就是他们不用关心内存管理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;yichuan&quot;</span>;<span class="hljs-comment">//给字符串分配栈内存</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;<span class="hljs-comment">//给数值分配栈内存</span><br><br><span class="hljs-comment">//给对象以及包含的值分配堆内存</span><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;onechuan&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">19</span><br>&#125;<br><span class="hljs-comment">//给数组以及包含的值分配堆内存</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;yichuan&quot;</span>,<span class="hljs-string">&quot;onechuan&quot;</span>,<span class="hljs-number">18</span>];<br><span class="hljs-comment">//给函数对象分配堆内存</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">x,y</span>)&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在前面《Javascript的数据类型知多少》文中，我们知道了基础数据类型和引用数据类型的分配机制，即：</p>
<ul>
<li>简单数据类型内存保存在固定的栈空间中，可直接通过值进行访问</li>
<li>引用数据类型的值大小不固定，其引用地址保存在栈空间、引用所指向的值保存在堆空间中，需要通过引用进行访问</li>
</ul>
<p>栈内存中的基本数据类型，可以直接通过操作系统进行处理，而堆内存中的引用数据类型的值大小不确定，因此需要JS的引擎通过垃圾回收机制进行处理。</p>
<h3 id="内存回收机制（GC）"><a href="#内存回收机制（GC）" class="headerlink" title="内存回收机制（GC）"></a>内存回收机制（GC）</h3><p>Javascript的V8引擎被限制了内存的使用，因此根据不同操作系统的内存大小会不一样。</p>
<p>V8引擎最初设计是作为浏览器的引擎，并未考虑占据过多的内存空间，随着web技术工程化的发展，占据了越来越多的内存空间。又由于被v8的会回收机制所限制，这样就引起了js执行的线程被挂起，会影响当前执行的页面应用性能。</p>
<p><strong>垃圾回收算法：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清楚或释放内存。</strong> 但是垃圾回收算法是个不完美的方案，因为某块内存是否还可用，属于不可预判的问题，也就意味着单纯依靠算法是解决不了的。还有为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了。</p>
<p>我们知道了垃圾是如何产生的，那么我们应该如何清除呢？在浏览器的发展历史上有两种解决策略：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除分为：标记阶段和清除阶段。</p>
<p>首先它会遍历堆内存上所有的对象，分别给它们打上标记，然后在代码执行过程结束之后，对所使用过的变量取消标记。在清除阶段再把具有标记的内存对象进行整体清除，从而释放内存空间。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae628622e794fcdaba8012668c44385~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (5).png"></p>
<p>整个标记清除算法大致过程就像下面这样</p>
<ul>
<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记</li>
<li>然后从各个根对象开始遍历，把还在被上下文变量引用的变量标记去掉标记</li>
<li>清理所有带有标牌机的变量，销毁并回收它们所占用的内存空间</li>
<li>最后垃圾回收程序做一次内存清理</li>
</ul>
<p>使用标记清除策略的最重要的优点在于简单，无非是标记和不标记的差异。通过标记清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，这就造成出现内存碎片的问题。内存碎片多了后，如果要存储一个新的需要占据较大内存空间的对象，就会造成影响。对于通过标记清除产生的内存碎片，还是需要通过标记整理策略进行解决。</p>
<p>简而言之：</p>
<ul>
<li>优点：简单</li>
<li>缺点：内存碎片化、分配速度慢</li>
</ul>
<h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>经过标记清除策略整理后，老生代内存中因此产生了许多内存碎片，如果不进行清理内存碎片，就会对存储造成影响。</p>
<p><strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决标记清除的两个缺点。它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00446ce9546a4194832617a5fb7b07c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (6).png"></p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数是一种不常见的垃圾回收策略，其思路就是对每个值都记录其的引用次数。具体的：</p>
<ul>
<li>当变量进行声明并赋值后，值的引用数为1。</li>
<li>当同一个值被赋值给另一个变量时，引用数+1</li>
<li>当保存该值引用的变量被其它值覆盖时，引用数-1</li>
<li>当该值的引用数为0时，表示无法再访问该值了，此时就可以放心地将其清除并回收内存。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() 	<span class="hljs-comment">// 此对象的引用计数为 1（a引用）</span><br><span class="hljs-keyword">let</span> b = a 		<span class="hljs-comment">// 此对象的引用计数是 2（a,b引用）</span><br>a = <span class="hljs-literal">null</span>  		<span class="hljs-comment">// 此对象的引用计数为 1（b引用）</span><br>b = <span class="hljs-literal">null</span> 	 	<span class="hljs-comment">// 此对象的引用计数为 0（无引用）</span><br>...			<span class="hljs-comment">// GC 回收此对象</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这种回收策略看起来很方便，但是当其进行循环引用时就会出现问题，会造成大量的内存不会被释放。当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一。</p>
<h3 id="V8对于垃圾回收机制的优化"><a href="#V8对于垃圾回收机制的优化" class="headerlink" title="V8对于垃圾回收机制的优化"></a>V8对于垃圾回收机制的优化</h3><p>大多数浏览器都是基于标记清除算法，不同的只是在运行垃圾回收的频率具有差异。V8 对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化。</p>
<h4 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h4><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。</p>
<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。</p>
<p>V8 整个堆内存的大小就等于新生代加上老生代的内存，对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51af8d575c54ea9bccfccacf828144b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (7).png"></p>
<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4><p>在64操作系统下分配为32MB，因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是能够理解。</p>
<p>对于新生代内存的回收，通常是通过Scavenge 的算法进行垃圾回收，就是将新生代内存进行一分为二，正在被使用的内存空间称为使用区，而限制状态的内存空间称为空闲区。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dac4e1334124e048f0e8a69126e2d7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (8).png"> 新生代内存回收的原理是：</p>
<ul>
<li>新加入的对象都会存放在使用区，当使用区快写满时就进行一次垃圾清理操作。</li>
<li>在开始进行垃圾回收时，新生代回收器会对使用区内的对象进行标记</li>
<li>标记完成后，需要对使用区内的活动对象拷贝到空闲区进行排序</li>
<li>而后进入垃圾清理阶段，将非活动对象占用的内存空间进行清理</li>
<li>最后对使用区和空闲区进行交换，使用区-&gt;空闲区，空闲区-&gt;使用区</li>
</ul>
<p>新生代中的变量如果经过回收之后依然一直存在，那么会放入到老生代内存中，只要是已经经历过一次Scavenge算法回收的，就可以晋升为老生代内存的对象。</p>
<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4><p>当然，Scavenge算法也有其适用场景范围，对于内存空间较大的就不适合使用Scavenge算法。此时应该使用Mark-Sweep（标记清除）和Mark-Compact（标记整理）的策略进行老生代内存中的垃圾回收。</p>
<p>首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。</p>
<p>同样的标记清除策略会产生内存碎片，因此还需要进行标记整理策略进行优化。</p>
<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3><p>内存泄漏，指在JS中已经分配内存地址的对象由于长时间未进行内存释放或无法清除，造成了长期占用内存，使得内存资源浪费，最终导致运行的应用响应速度变慢以及最终崩溃的情况。</p>
<p>在代码中创建对象和变量时会占据内存，但是<strong>JS基于自己的内存回收机制是可以确定哪些变量不再需要，并将其进行清除</strong>。但是，当你的代码中存在逻辑缺陷时，你以为你已经不需要，但是程序中还存在这引用，这就导致程序运行完后并没有进行合适的回收所占有的内存空间。运行时间越长占用内存越多，随之出现的问题就是：性能不佳、高延迟、频繁崩溃。</p>
<p>造成内存泄漏的常见原因有：</p>
<ul>
<li><strong>过多的缓存</strong>。及时清理过多的缓存。</li>
<li><strong>滥用闭包</strong>。尽量避免使用大量的闭包。</li>
<li><strong>定时器或回调太多</strong>。与节点或数据相关联的计时器不再需要时，DOM节点对象可以清除，整个回调函数也不再需要。可是，计时器回调函数仍然没有被回收（计时器停止才会被回收）。当不需要setTimeout或setInterval时，<strong>定时器没有被清除</strong>，定时器的糊掉函数以及其内部依赖的变量都不能被回收，<strong>会造成内存泄漏</strong>。解决方法：在定时器完成工作时，需要手动清除定时器。</li>
<li><strong>太多无效的DOM引用</strong>。DOM删除了，但是节点的引用还在，导致GC无法实现对其所占内存的回收。解决方法：给删除的DOM节点引用设置为null。</li>
<li><strong>滥用全局变量。</strong>全局变量是根据定义无法被垃圾回收机制进行收集的，因此需要特别注意临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，请确保将其指定为null或在完成后重新分配它。解决方法：使用严格模式。</li>
<li><strong>从外到内执行appendChild。</strong>此时即使调用removeChild也无法进行释放内存。解决方法：从内到外appendChild。</li>
<li><strong>反复重写同一个数据会造成内存大量占用</strong>，但是IE浏览器关闭后会被释放。</li>
<li><strong>注意程序逻辑</strong>，避免编写『死循环』之类的代码。</li>
<li><strong>DOM对象和JS对象相互引用</strong>。</li>
</ul>
<p>关于内存泄漏，如果你想要更好地排查以及提前避免问题的发生，最好的解决方法是通过熟练使用Chrome的内存剖析工具，多分析多定位Chrome帮你分析保留的内存快照，来查看持续占用大量内存的对象。</p>
<h2 id="17-eval"><a href="#17-eval" class="headerlink" title="17 eval"></a>17 eval</h2><p>解析成js并执行。</p>
<p>语法：<code>eval(string)</code></p>
<h2 id="18-setTimeout、setInterval和requestAnimationFrame的不同"><a href="#18-setTimeout、setInterval和requestAnimationFrame的不同" class="headerlink" title="18 setTimeout、setInterval和requestAnimationFrame的不同"></a>18 setTimeout、setInterval和requestAnimationFrame的不同</h2><p>与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔，大多数电 脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。大多数浏览器都 会对重绘 操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验 也不会有 提升。因此，最平滑动画的最佳循环间隔是 1000ms&#x2F;60，约等于 16.6ms。 RAF 采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的 任 务多的话， 会响应setTimeout和setInterval真正运行时的时间间隔。 </p>
<p>特点： </p>
<p>（1）requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或 回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 </p>
<p>（2）在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这 当 然就意味着更少的 CPU、GPU 和内存使用量 </p>
<p>（3）requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会 自 动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节 省了 CPU 开销</p>
<h2 id="19-深入理解JS中的事件发射器（Event-Emitters）"><a href="#19-深入理解JS中的事件发射器（Event-Emitters）" class="headerlink" title="19 深入理解JS中的事件发射器（Event Emitters）"></a>19 深入理解JS中的事件发射器（Event Emitters）</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>先看一个<code>DOM</code>事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-comment">/* do something with the event */</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>以上代码在<code>button</code>上添加了一个事件监听器，每当点击<code>button</code>的时候，点击事件被触发出去并且同时调用<code>callback</code>函数。</p>
<p>有很多时候可能会有需要触发自定义事件的需求，不单单只是一个点击事件，假设有这样一个需要触发一个基于其他触发器的事件，并且需要有一个事件响应的，可以自定义一个<code>event emitter</code>来实现。</p>
<p>一个<code>event emitter</code>就是监听一个<code>event</code>，触发一个回调函数，然后<code>emit</code>一个带有<code>value</code>的事件的一种模式，有时候也称为<code>pub/sub</code>模型或者监听器。</p>
<p>在JavaScript中的一种实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">event</span> = <span class="hljs-keyword">new</span> EventEmitter();<br><br><span class="hljs-keyword">event</span>.subscribe(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-keyword">value</span> =&gt; (n = <span class="hljs-keyword">value</span>));<br><br><span class="hljs-keyword">event</span>.emit(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">// n: 18</span><br><br><span class="hljs-keyword">event</span>.emit(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// n: 5</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们订阅了一个叫做 <code>THUNDER_ON_THE_MOUNTAIN</code>的事件，并且当事件被 <code>emitted</code> 的时候，回调函数 <code>value =&gt; (n = value)</code> 也会被触发，可以调用 <code>emit()</code>来<code>emit</code>该事件。</p>
<p>这在与异步代码交互的时候，如果有不在当前模块下的值需要更新时十分有用。</p>
<p>一个真实的例子就是<a href="https://link.juejin.cn/?target=https://react-redux.js.org/">React Redux</a>， <code>Redux</code>需要一种通知外部其内部的值已经更新的机制，其允许<code>React</code>调用<code>setState()</code>并重新渲染UI来获取哪些值已经改变，这个地方也是使用<code>event emitter</code>来实现的。 <code>Redux store</code>有一个传入一个提供新的<code>store</code>的回调函数作为参数的订阅函数，在这个订阅函数中，调用了 <code>React Redux</code>的以新<code>store</code>的值调用了<code>setState()</code>方法的 <code>&lt;Provider&gt;</code> 组件，可以<a href="https://link.juejin.cn/?target=https://github.com/reduxjs/react-redux/blob/master/src/components/Provider.js%23L36">在此</a>查看。</p>
<p>现在我们的应用有了两个不同的部分，一部分是<code>React UI</code>，另一部分是<code>Redux store</code>，谁也说不清楚事件究竟是被那一部分触发的。</p>
<h3 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h3><p>先看一个简单的<code>event emitter</code>，其中使用了<code>class</code>，在这个<code>class</code>中跟踪事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  public <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>事件</li>
</ul>
<p>定义一个事件接口，用来存储一个每一个<code>key</code>都是一个事件名并且各自的值都是回调函数组成的数组的空白对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Events</span> &#123;<br>  [<span class="hljs-attr">key</span>: string]: <span class="hljs-title class_">Function</span>[];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &quot;event&quot;: [fn],</span><br><span class="hljs-comment">  &quot;event_two&quot;: [fn]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>使用数组的原因是因为每一个事件都可能有多个<code>subscriber</code>，因为<code>element.addEventLister(&quot;click&quot;)</code>可能会被多次调用。</p>
<ul>
<li>订阅</li>
</ul>
<p>现在需要处理订阅的事件，在上面的例子中，<code>subscribe()</code>函数接收两个参数：一个<code>name</code>和一个<code>callback</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">event.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;named event&quot;</span>, <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br></code></pre></td></tr></table></figure>

<p>定义一个<code>subscribe</code>方法来接收这两个参数，只需把这两个参数添加到类内部的<code>this.events</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>发射</li>
</ul>
<p>到此可以订阅事件了，接下来，当一个新事件发射的时候需要触发回调函数，当触发的时候，将使用<code>(emit(&quot;event&quot;))</code>中存储的事件名和需要传递到回调函数<code>(emit(&quot;event&quot;, value))</code>的任意值，我们可以简单地传递任意参数到回调函数在第一个参数后面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">emit</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">void</span> &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然我们知道了我们希望发射的事件，可以使用<code>this.events[name]</code>来查看，返回的是一个回调函数的数组。</p>
<ul>
<li>取消订阅</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: string, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>  (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码返回一个带有<code>unsubscribe</code>方法的对象，可以使用箭头函数<code>() =&gt;</code>来获取传递给父对象参数的作用域，在这个函数中，使用<code>&gt;&gt;&gt;</code><a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it">操作符</a>可以找到传递给父级回调函数的索引，在这里使用可以保证我们每次在回调函数数组上调用<code>splice()</code> 的时候总是可以取到一个真正的数字，即使<code>indexOf()</code> 都不能返回数字也行。 可以这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> subscription = event.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;event&quot;</span>, <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br><br>subscription.<span class="hljs-title function_">unsubscribe</span>();<br></code></pre></td></tr></table></figure>

<p>到此，我们就可以取消这一个特别的订阅了，而且不影响其他的订阅。</p>
<ul>
<li>完整实现</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Events</span> &#123;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Function</span>[];<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">emit</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">void</span> &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>实例</li>
</ul>
<p><a href="https://link.juejin.cn/?target=https://codepen.io/charliewilco/pen/gEoErR">codepen.io&#x2F;charliewilc…</a></p>
<p>上述代码中，首先在另外一个事件回调中使用了<code>event emitter</code>，在这种情况下，一个<code>event emitter</code>是用来清除一些逻辑，在GitHub上选择一个仓库，获取详情，缓存详情，并更新DOM去显示这些详情。在订阅回调函数中从网络或者缓存中获取结果并更新，可以这样做的原因是当我们发射时间的时候从列表中给了回调函数一个随机的仓库。</p>
<p>现在来考虑一些不太一样的东西，在一个应用中，可能会有许多状态需要登录之后才可以触发，并且可能会有多个订阅器来处理用户试图退出的操作。因为已经发射了一个带<code>false</code>值的事件，每一个订阅器都可以使用这个值，并且需要判断是否需要重定向页面，移除cookie或者禁用表单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> events = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br><br>events.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-literal">false</span>);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  buttonEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;disabled&quot;</span>, !isLogged);<br>&#125;);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">replace</span>(!isLoggedIn ? <span class="hljs-string">&quot;/login&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>&#125;);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  !isLoggedIn &amp;&amp; cookies.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;auth_token&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>最后</li>
</ul>
<p>要让<code>emitters</code>能工作，有几点需要考虑：</p>
<ul>
<li>需要在<code>emit()</code>函数中使用<code>forEach</code>或者<code>map</code>来确保我们能创建新的订阅器或者取消订阅。</li>
<li>当一个<code>EventEmitter</code>类被实例化之后，可以传递一个预定义的事件到事件接口。</li>
<li>可以不需要使用<code>class</code>，来实现，个人喜好，但是使用<code>class</code>使事件存储在哪里会更加清晰。 可以在一个函数中实现，如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">emitter</span>(<span class="hljs-params">e?: Events</span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span> = e || &#123;&#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    events,<br>    <span class="hljs-attr">subscribe</span>: <span class="hljs-function">(<span class="hljs-params">name: string, cb: <span class="hljs-built_in">Function</span></span>) =&gt;</span> &#123;<br>      (events[name] || (events[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>          events[name] &amp;&amp; events[name].<span class="hljs-title function_">splice</span>(events[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;;<br>    &#125;,<br>    <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">name: string, ...args: any[]</span>) =&gt;</span> &#123;<br>      (events[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>














<h1 id="over-point"><a href="#over-point" class="headerlink" title="over point"></a>over point</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" class="category-chain-item">前端八股</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/blog/tags/%E8%AE%A1%E7%AE%97/">#计算</a>
      
        <a href="/blog/tags/javascript/">#javascript</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端八股 ｜ js篇</div>
      <div>https://yoonalis.github.io/blog/2023/04/06/前端八股 ｜js篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9Cjs%E7%AF%872/" title="前端八股 ｜ js篇2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前端八股 ｜ js篇2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20css%E7%AF%87/" title="前端八股 ｜ css篇">
                        <span class="hidden-mobile">前端八股 ｜ css篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
