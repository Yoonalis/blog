

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="react">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股 ｜ js篇">
<meta property="og:url" content="https://yoonalis.github.io/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9Cjs%E7%AF%87/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="react">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
<meta property="article:published_time" content="2023-04-06T13:31:21.932Z">
<meta property="article:modified_time" content="2023-04-11T02:44:32.125Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="计算">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>前端八股 ｜ js篇 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端八股 ｜ js篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-06 21:31" pubdate>
          2023年4月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          155k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          1295 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端八股 ｜ js篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前端八股-｜js篇"><a href="#前端八股-｜js篇" class="headerlink" title="前端八股 ｜js篇"></a>前端八股 ｜js篇</h1><h2 id="1-promise的状态"><a href="#1-promise的状态" class="headerlink" title="1 promise的状态"></a>1 promise的状态</h2><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><ul>
<li><p><code>pending</code>准备 <code>fulfilled</code>成功 <code>rejected</code>失败</p>
</li>
<li><p><code>pengding</code>-&gt;<code>fulfilled/pending</code>-&gt;<code>rejected</code></p>
</li>
<li><p>变化是<strong>不可逆</strong>的</p>
</li>
<li><p><code>pending</code>准备, 不会触发<code>then</code>和<code>catch</code></p>
</li>
<li><p><code>fulfilled</code>成功, 会触发后续的<code>then</code>回调函数</p>
</li>
<li><p><code>rejected</code>失败，会触发后续的<code>catch</code>回调函数</p>
</li>
</ul>
<h3 id="promise-then和catch如何影响状态的转换"><a href="#promise-then和catch如何影响状态的转换" class="headerlink" title="promise then和catch如何影响状态的转换"></a>promise then和catch如何影响状态的转换</h3><ul>
<li><p><code>then</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></p>
</li>
<li><p><code>catch</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></p>
</li>
</ul>
<h3 id="详细示例"><a href="#详细示例" class="headerlink" title="详细示例"></a>详细示例</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/051337013f644284b053e0ef1f3027ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="904c4cc6978dae1ee0c0f3c9786f406b.png"></p>
<p>fulfilled成功, 会触发后续的then回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>p1 <span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: 100&#125;</span><br><br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data&#x27;</span>, data) <span class="hljs-comment">//data 100</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err) <span class="hljs-comment">//不会执行</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40b779de13ea43b3a1bbd91fb7c88210~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="52f0601bdab5958237ad3194175a9ff1.png"></p>
<p>rejected失败，会触发后续的catch回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err&#x27;</span>)<br>p2 <span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;err&#x27;&#125;</span><br><br>p2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data&#x27;</span>, data) <span class="hljs-comment">//不会执行</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err) <span class="hljs-comment">//err err</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8e269903b6841edbd620e60dc37f367~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="007fcce32cf178f2da15ae7759a4f23d.png"></p>
<h4 id="promise-then和catch如何影响状态的转换-1"><a href="#promise-then和catch如何影响状态的转换-1" class="headerlink" title="promise then和catch如何影响状态的转换"></a>promise then和catch如何影响状态的转换</h4><ul>
<li><code>then</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>         <span class="hljs-comment">//正常返回resolved</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;123&#x27;</span>)  <span class="hljs-comment">//123</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;then error&#x27;</span>)   <span class="hljs-comment">//then error</span><br>  <span class="hljs-comment">//报错返回rejected</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)  <span class="hljs-comment">//不执行无输出</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err100&#x27;</span>, err)  <span class="hljs-comment">//err100 err</span><br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><code>catch</code>正常返回<code>resolved</code>,里面有报错则返回<code>rejected</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;my error&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)         <span class="hljs-comment">//正常返回resolved！触发then回调 </span><br>&#125;)<br>p3.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;123&#x27;</span>)  <span class="hljs-comment">//123</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;my error&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;catch error&#x27;</span>)   <span class="hljs-comment">//catch error</span><br>  <span class="hljs-comment">//报错返回rejected</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;456&#x27;</span>)  <span class="hljs-comment">//不执行无输出</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;err100&#x27;</span>, err)  <span class="hljs-comment">//err100 err</span><br>&#125;) <span class="hljs-comment">//resolved的promise</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第一题</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//1</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//无报错不执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">//3</span><br>&#125;)<span class="hljs-comment">//resolved状态</span><br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第二题</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;erro1&#x27;</span>)  <span class="hljs-comment">//rejected状态</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//resolved状态</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)  <span class="hljs-comment">//2</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">//3</span><br>&#125;)<span class="hljs-comment">//resolved状态</span><br><br><span class="hljs-comment">//运行结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第三题</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//1</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;erro1&#x27;</span>)  <span class="hljs-comment">//rejected状态</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">//resolved状态</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)  <span class="hljs-comment">//2</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">//无报错不执行</span><br>&#125;)<br><br><span class="hljs-comment">//运行结果</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="2-事件循环中的任务队列"><a href="#2-事件循环中的任务队列" class="headerlink" title="2 事件循环中的任务队列"></a>2 事件循环中的任务队列</h2><p>event loop都不陌生，是指主线程从“任务队列”中循环读取任务，比如</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">1</span>：<br><br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">//输出2,1</span><br></code></pre></td></tr></table></figure>

<p>在上述的例子中，我们明白首先执行主线程中的同步任务，当主线程任务执行完毕后，再从event loop中读取任务，因此先输出2，再输出1。</p>
<p>event loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。比如下面一个例子：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">2</span>：<br><br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>Promise.resolve().then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//输出为  1  2 3</span><br></code></pre></td></tr></table></figure>

<p>先输出1，没有问题，因为是同步任务在主线程中优先执行，这里的问题是setTimeout和Promise.then任务的执行优先级是如何定义的。</p>
<h3 id="Job-queue中的执行顺序"><a href="#Job-queue中的执行顺序" class="headerlink" title="Job queue中的执行顺序"></a>Job queue中的执行顺序</h3><p>在Job queue中的队列分为两种类型：macro-task和microTask。我们举例来看执行顺序的规定，我们设</p>
<p>macro-task队列包含任务: <em><strong>a1, a2 , a3</strong></em></p>
<p>micro-task队列包含任务: <em><strong>b1, b2 , b3</strong></em></p>
<p>执行顺序为，首先执行marco-task队列开头的任务，也就是 <em><strong>a1</strong></em> 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行<em><strong>b1, b2 , b3</strong></em>，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。</p>
<p>了解完了macro-task和micro-task两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：</p>
<p>macro-task队列真实包含任务：</p>
<p><em><strong>*script(主程序代码),setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering*</strong></em></p>
<p>micro-task队列真实包含任务：</p>
<p><em><strong>process.nextTick, Promises, Object.observe, MutationObserver</strong></em></p>
<p>由此我们得到的执行顺序应该为：</p>
<p><em><strong>script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I&#x2F;O——&gt;UI rendering</strong></em></p>
<p>在ES6中macro-task队列又称为ScriptJobs，而micro-task又称PromiseJobs</p>
<blockquote>
<p>定义promise的构造部分是同步的</p>
</blockquote>
<h3 id="真实环境中执行顺序的举例"><a href="#真实环境中执行顺序的举例" class="headerlink" title="真实环境中执行顺序的举例"></a>真实环境中执行顺序的举例</h3><h4 id="1-setTimeout和promise"><a href="#1-setTimeout和promise" class="headerlink" title="(1) setTimeout和promise"></a>(1) setTimeout和promise</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">3</span>:<br><br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>Promise.resolve().then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>我们先以第1小节的例子为例，这里遵循的顺序为：</p>
<p><em><strong>script(主程序代码)——&gt;promise——&gt;setTimeout</strong></em><br>对应的输出依次为：1 ——&gt;2————&gt;3</p>
<h4 id="2-process-nextTick和promise、setTimeout"><a href="#2-process-nextTick和promise、setTimeout" class="headerlink" title="(2) process.nextTick和promise、setTimeout"></a>(2) process.nextTick和promise、setTimeout</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例子<span class="hljs-number">4</span>：<br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>   resolve();<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)&#125;);<br><br>process.nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">//输出2,6,5,3,4,1</span><br></code></pre></td></tr></table></figure>

<p>这个例子就比较复杂了，这里要注意的一点在定义promise的时候，promise构造部分是同步执行的，这样问题就迎刃而解了。</p>
<p>首先分析Job queue的执行顺序：</p>
<p><em><strong>script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</strong></em></p>
<p>I) <em><strong>主体部分</strong></em>： 定义promise的构造部分是同步的，<br>因此先输出2 ，主体部分再输出6（同步情况下，就是严格按照定义的先后顺序）</p>
<p>II)<em><strong>process.nextTick</strong></em>: 输出5</p>
<p>III）<em><strong>promise</strong></em>： 这里的promise部分，严格的说其实是promise.then部分，输出的是3,4</p>
<p>IV) <em><strong>setTimeout</strong></em> ： 最后输出1</p>
<p>综合的执行顺序就是： 2——&gt;6——&gt;5——&gt;3——&gt;4——&gt;1</p>
<h4 id="3-更复杂的例子"><a href="#3-更复杂的例子" class="headerlink" title="(3)更复杂的例子"></a>(3)更复杂的例子</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>   setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;resolve()&#125;,<span class="hljs-number">0</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)&#125;);<br><br>process.nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//输出的是  2 6 5 1 3 4</span><br></code></pre></td></tr></table></figure>

<p>这种情况跟我们（2）中的例子，区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p>
<h2 id="2-1-事件循环"><a href="#2-1-事件循环" class="headerlink" title="2.1 事件循环"></a>2.1 事件循环</h2><h3 id="一、什么是事件循环机制？"><a href="#一、什么是事件循环机制？" class="headerlink" title="一、什么是事件循环机制？"></a>一、什么是事件循环机制？</h3><blockquote>
<p>在介绍事件循环机制之前，我们要首先了解以下什么是事件循环机制，我们首先看下下面这段代码的执行顺序，正确的执行顺序应该是序号1&gt;3&gt;2 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c17a2aaa70db4ecc92b809cfcdca68aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
</blockquote>
<h4 id="为什么是上面的顺序呢？"><a href="#为什么是上面的顺序呢？" class="headerlink" title="为什么是上面的顺序呢？"></a>为什么是上面的顺序呢？</h4><p>原因是JS引擎指向代码是从上往下执行的，所以首先会执行序号1这个语句，JS引擎会将这个语句放在调用栈当中，然后执行代码，将序号1打印在控制台当中，当这段代码执行完毕之后，便将这段代码从调用栈中移出去。然后开始执行后续的代码，此时setTimeout这段代码进入调用栈，这段代码，会调用Web API,2秒之后进入callback队列，此时JS引擎将setTimeout移出调用栈，继续执行后面的代码，所以屏幕上会先打印出序号1,3，此时eventLoop登场了，它会不断循环的访问callbackqueue，等2s之后Web API会将要执行的打印序号2这句话放入callbackqueue,eventLoop将callbackQueue中的内容放入调用栈，开始执行，然后屏幕上打印出序号2，这就是eventLoop的基本流程。</p>
<h4 id="执行顺序图解"><a href="#执行顺序图解" class="headerlink" title="执行顺序图解"></a>执行顺序图解</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c6930751a54d9895360c62e3acefef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="引出事件循环是什么"><a href="#引出事件循环是什么" class="headerlink" title="引出事件循环是什么"></a>引出事件循环是什么</h4><blockquote>
<p>JS的运行机制就是事件循环!</p>
</blockquote>
<h3 id="二、JS的执行顺序是什么？"><a href="#二、JS的执行顺序是什么？" class="headerlink" title="二、JS的执行顺序是什么？"></a>二、JS的执行顺序是什么？</h3><ol>
<li>JS是从上到下一行一行执行。</li>
<li>如果某一行执行报错，则停止执行下面的代码。</li>
<li>先执行同步代码，再执行异步代码</li>
</ol>
<h3 id="三、事件循环的执行过程"><a href="#三、事件循环的执行过程" class="headerlink" title="三、事件循环的执行过程"></a>三、事件循环的执行过程</h3><ul>
<li>同步代码，调用栈执行后直接出栈</li>
<li>异步代码，放到Web API中，等待时机，等合适的时候放入回调队列（callbackQueue），等到调用栈空时eventLoop开始工作，轮询</li>
<li>微任务执行时机比宏任务要早 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/470b695effb04555928976504bb518c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></li>
<li>微任务在DOM渲染前触发，宏任务在DOM渲染后触发</li>
</ul>
<h3 id="四、微任务和宏任务的根本区别"><a href="#四、微任务和宏任务的根本区别" class="headerlink" title="四、微任务和宏任务的根本区别"></a>四、微任务和宏任务的根本区别</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26921231cd26436a905314af789d45b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></h4><ul>
<li>微任务是由ES6语法规定的</li>
<li>宏任务是由浏览器规定的</li>
</ul>
<h3 id="五、事件循环的整体流程"><a href="#五、事件循环的整体流程" class="headerlink" title="五、事件循环的整体流程"></a>五、事件循环的整体流程</h3><ol>
<li>先清空call stack中的同步代码</li>
<li>执行微任务队列中的微任务</li>
<li>尝试DOM渲染</li>
<li>触发Event Loop反复询问callbackQueue中是否有要执行的语句，有则放入call back继续执行 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97161f74e2e7494bad644e28e22bcf4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></li>
</ol>
<h3 id="六、事件循环经典案例"><a href="#六、事件循环经典案例" class="headerlink" title="六、事件循环经典案例"></a>六、事件循环经典案例</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd9cfac79eb4e0896b82f2ae4074d6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h2 id="3-箭头函数和普通函数的区别"><a href="#3-箭头函数和普通函数的区别" class="headerlink" title="3 箭头函数和普通函数的区别"></a>3 箭头函数和普通函数的区别</h2><p><strong>1 语法更加简洁、清晰</strong></p>
<p>箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</p>
<p><strong>2 箭头函数没有 prototype (原型)，所以箭头函数本身没有this</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 箭头函数</span><br>let a = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.prototype); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.prototype); <span class="hljs-comment">// &#123;constructor:f&#125;复制代码</span><br></code></pre></td></tr></table></figure>

<p><strong>3 箭头函数不会创建自己的this</strong></p>
<p>箭头函数没有自己的this，箭头函数的this指向在定义（<strong>注意：</strong>是定义时，不是调用时）的时候继承自外层第一个普通函数的this。所以，箭头函数中 <code>this </code>的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// undefined</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this); <span class="hljs-comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span><br>  &#125;,<br>  <span class="hljs-attr">c</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// 10</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this); <span class="hljs-comment">// &#123;a: 10, b: ƒ, c: ƒ&#125;</span><br>  &#125;<br>&#125;<br>obj.b(); <br>obj.c();复制代码<br></code></pre></td></tr></table></figure>

<p><strong>4 call | apply | bind 无法改变箭头函数中this的指向</strong></p>
<p><code>call | apply | bind</code>方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数<code>this</code>的指向。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> id = <span class="hljs-number">10</span>;<br>let <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-params">()</span></span> =&gt; &#123;<br>    console.log(<span class="hljs-keyword">this</span>.id)<br>&#125;;<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 10</span><br><span class="hljs-keyword">fun</span>.call(&#123; id: <span class="hljs-number">20</span> &#125;);     <span class="hljs-comment">// 10</span><br><span class="hljs-keyword">fun</span>.apply(&#123; id: <span class="hljs-number">20</span> &#125;);    <span class="hljs-comment">// 10</span><br><span class="hljs-keyword">fun</span>.bind(&#123; id: <span class="hljs-number">20</span> &#125;)();   <span class="hljs-comment">// 10复制代码</span><br></code></pre></td></tr></table></figure>

<p><strong>5 箭头函数不能作为构造函数使用</strong></p>
<p>我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。</p>
<p>但是！！因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">Fun</span> = (<span class="hljs-params">name, age</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fun</span>(<span class="hljs-string">&#x27;dingFY&#x27;</span>, <span class="hljs-number">24</span>);复制代码<br></code></pre></td></tr></table></figure>

<p><strong>6 箭头函数不绑定arguments，取而代之用rest参数…代替arguments对象，来访问箭头函数的参数列表</strong></p>
<p>箭头函数没有自己的<code>arguments</code>对象。在箭头函数中访问<code>arguments</code>实际上获得的是外层局部（函数）执行环境中的值。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params">a</span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arguments);<br>&#125;<br>A(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);  <span class="hljs-comment">//  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><br><span class="hljs-comment">// 箭头函数</span><br>let B = <span class="hljs-function">(<span class="hljs-params">b</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arguments);<br>&#125;<br>B(<span class="hljs-number">2</span>,<span class="hljs-number">92</span>,<span class="hljs-number">32</span>,<span class="hljs-number">32</span>);   <span class="hljs-comment">// Uncaught ReferenceError: arguments is not defined</span><br><br><span class="hljs-comment">// rest参数...</span><br>let C = <span class="hljs-function">(<span class="hljs-params">...c</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(c);<br>&#125;<br>C(<span class="hljs-number">3</span>,<span class="hljs-number">82</span>,<span class="hljs-number">32</span>,<span class="hljs-number">11323</span>);  <span class="hljs-comment">// [3, 82, 32, 11323]复制代码</span><br></code></pre></td></tr></table></figure>

<p><strong>7 箭头函数不能用作Generator函数，不能使用yield关键字</strong></p>
<h2 id="4-js的设计模式"><a href="#4-js的设计模式" class="headerlink" title="4 js的设计模式"></a>4 js的设计模式</h2><p>我们经常听到一句话，“写代码要有良好的封装，要高内聚，低耦合”。究竟怎样的代码才算得上是良好的代码。</p>
<p><strong>什么是高内聚，低耦合？</strong></p>
<p>即五大基本原则（SOLID）的简写</p>
<ul>
<li><p><strong>高</strong>层模块不依赖底层模块，即为依赖反转原则。</p>
</li>
<li><p><strong>内</strong>部修改关闭，外部扩展开放，即为开放封闭原则。</p>
</li>
<li><p><strong>聚</strong>合单一功能，即为单一功能原则。</p>
</li>
<li><p><strong>低</strong>知识要求，对外接口简单，即为迪米特法则。</p>
</li>
<li><p><strong>耦</strong>合多个接口，不如独立拆分，即为接口隔离原则。</p>
</li>
<li><p><strong>合</strong>成复用，子类继承可替换父类，即为里式替换原则</p>
</li>
</ul>
<p><strong>我们为什么要封装代码？</strong></p>
<p>其实封装代码有这些好处：</p>
<ol>
<li><p>良好的封装，不会让内部变量污染外部</p>
</li>
<li><p>封装好的代码可以作为一个模块给外部调用。外部无需了解细节，只需按约定的规范调用。</p>
</li>
<li><p>对扩展开放，对修改关闭，即开放关闭原则。外部不能修改内部代码，保证了内部的正确性；又留出扩展接口，提高了灵活性。</p>
</li>
</ol>
<p>我们可以观察React、Vue、EventEmitter、Axios等等这些优秀的源码，会发现其实他们封装的模块都是有迹可循的。这些规律总结起来就是设计模式。</p>
<h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a><strong>什么是设计模式？</strong></h3><p>借用鲁迅先生说过的一句话，世上本没有路，走的人多了也便成了路。所谓设计模式，是前辈们总结下来的，在软件设计、开发过程中，针对特定场景、特定问题的较优解决方案。</p>
<h3 id="为什么需要设计模式？"><a href="#为什么需要设计模式？" class="headerlink" title="为什么需要设计模式？"></a><strong>为什么需要设计模式？</strong></h3><p>实际上，不使用设计模式，照样可以进行需求开发。但是这造成的后果是：因设计缺陷、代码实现缺陷，给后期维护、开发、迭代带来了麻烦。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式一共分为3大类23种，主要介绍常用的几种</p>
<table>
<thead>
<tr>
<th>模式类型</th>
<th>设计模式</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式</td>
<td>单例模式、工厂模式、建造者模式</td>
</tr>
<tr>
<td>结构型模式</td>
<td>适配器模式、装饰器模式、代理模式</td>
</tr>
<tr>
<td>行为型模式</td>
<td>策略模式、观察者模式、发布订阅模式、职责链模式、中介者模式</td>
</tr>
</tbody></table>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式：一个类只有一个实例，并提供一个访问他的全局访问点。</p>
<ul>
<li><p><code>Singleton</code> ：特定类，这是我们需要访问的类，访问者要拿到的是它的实例；</p>
</li>
<li><p><code>instance</code> ：单例，是特定类的实例，特定类一般会提供 <code>getInstance</code> 方法来获取该单例；</p>
</li>
<li><p><code>getInstance</code> ：获取单例的方法；</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7033d67edc4d7c813ea723f69a00fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">let</span> _instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Singleton</span>.<span class="hljs-property">_instance</span>) &#123;<br>          <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>()<br>        &#125;<br>        <span class="hljs-comment">// 如果这个唯一的实例已经存在，则直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">_instance</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>()<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1 === s2)  <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="源码实例"><a href="#源码实例" class="headerlink" title="源码实例"></a>源码实例</h4><p>Vuex 源码中的单例模式</p>
<p>Vuex：实现了一个全局的store用来存储应用的所有状态。这个store的实现就是单例模式的典型应用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 安装vuex插件</span><br>Vue.<span class="hljs-keyword">use</span>(Vuex)<br><br><span class="hljs-comment">// store注入Vue实例</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    el:<span class="hljs-string">&quot;<span class="hljs-subst">$app</span>&quot;</span>,<br>    store<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过调用<code>Vue.use</code>方法，安装Vuex插件。Vuex插件本质上是一个对象，内部实现了一个<code>install</code>方法，这个方法在插件安装时被调用，从而把<code>Store</code>注入到<code>Vue</code>实例中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Vue</span> <span class="hljs-comment">// instance 实例</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">install</span> (_Vue) &#123;<br>  <span class="hljs-comment">// 判断传入的Vue实例对象是否已经被install过（是否有了唯一的state）</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Vue</span> &amp;&amp; _Vue === <span class="hljs-title class_">Vue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<br>        <span class="hljs-string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span><br>      )<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 若没有，则为这个Vue实例对象install一个唯一的Vuex</span><br>  <span class="hljs-title class_">Vue</span> = _Vue<br>  <span class="hljs-comment">// 将Vuex的初始化逻辑写进Vue的钩子函数里</span><br>  <span class="hljs-title function_">applyMixin</span>(<span class="hljs-title class_">Vue</span>)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过这种方式，可以保证一个 Vue 实例只会被 install 一次 Vuex 插件，所以每个 Vue 实例只会拥有一个全局的 Store。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong> 节约资源，保证访问的一致性。</p>
<p><strong>缺点：</strong> 扩展性不友好，因为单例模式一般自行实例化，没有接口。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li><p>如果一个类实例化过程消耗资源比较多，可以使用单例避免性能浪费</p>
</li>
<li><p>需要公共状态，可以使用单例保证访问一致性。</p>
</li>
</ol>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式：根据不同的参数，返回不同类的实例。</p>
<p>核心思想：将对象的创建与对象的实现分离。实现复杂，但使用简单。工厂会给我们提供一个工厂方法，我们直接去调用即可。</p>
<ul>
<li><p>Visitor ：访问者，访问工厂方法。</p>
</li>
<li><p>Factory ：工厂，负责返回产品实例；</p>
</li>
<li><p>Product ：产品，访问者从工厂拿到的产品实例；</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67656a1ee68e4428bfb22517e0ea4174~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="🌰-例子"><a href="#🌰-例子" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>我们去环球影城的餐厅吃饭，点了一份“牛肉拉面”、“馄饨云吞面”，面煮好了，就直接端到桌子上，我们只管吃，不用在乎煮面的过程。</p>
<p>这个过程中，我们扮演访问者的角色，餐厅扮演的就是工厂的角色，“xxx”面就是产品。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Restaurant</span>&#123;<br>    <span class="hljs-keyword">constructor</span>()&#123;<br>        <span class="hljs-keyword">this</span>.menuData = &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 获取菜品</span><br>    getDish(dish)&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.menuData[menu])&#123;<br>            console.log(<span class="hljs-string">&quot;菜品不存在，获取失败&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.menuData[menu];<br>    &#125;,<br>    <span class="hljs-comment">// 添加菜品</span><br>    addMenu(menu,description)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.menuData[menu])&#123;<br>            console.log(<span class="hljs-string">&quot;菜品已存在，请勿重复添加&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.menuData[menu] = menu;<br>    &#125;<br>    <span class="hljs-comment">// 移除菜品</span><br>    removeMenu(menu)&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.menuData[menu])&#123;<br>            console.log(<span class="hljs-string">&quot;菜品不存在，移除失败&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        delete <span class="hljs-keyword">this</span>.menuData[menu];<br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dish</span>&#123;<br>    <span class="hljs-keyword">constructor</span>(name,description)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.description = description;<br>    &#125;<br>    <br>    eat()&#123;<br>        console.log(`I<span class="hljs-string">&#x27;m eating $&#123;this.name&#125;,it&#x27;</span>s $&#123;`<span class="hljs-keyword">this</span>.description);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这些场景都有一些特点：使用者只需要知道产品名字就可以拿到实例，不关心创建过程。所以我们可以把复杂的过程封装在一块，更便于使用。</p>
<h4 id="源码实例-1"><a href="#源码实例-1" class="headerlink" title="源码实例"></a>源码实例</h4><p>Vue、React 源码中的工厂模式</p>
<blockquote>
<p><code>document.createElement</code> 创建 <code>DOM</code> 元素。这个方法采用的就是工厂模式，方法内部很复杂，但外部使用很简单。只需要传递标签名，这个方法就会返回对应的 <code>DOM</code> 元素。</p>
</blockquote>
<p>和原生的 <code>document.createElement</code> 类似，<code>Vue</code> 和 <code>React</code> 这种具有虚拟 <code>DOM</code> 树机制的框架在生成虚拟 <code>DOM</code> 的时候，都提供了 <code>createElement</code> 方法用来生成 <code>VNode</code>，用来作为真实 DOM 节点的映射。上面实现一致，调用<code>createEle``ment</code>后，返回<code>VNode</code>元素。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 使用</span><br><span class="hljs-built_in">ccreateElement</span>(<span class="hljs-string">&#x27;h3&#x27;</span>, &#123; <span class="hljs-keyword">class</span>: <span class="hljs-string">&#x27;main-title&#x27;</span> &#125;, [<br>    <span class="hljs-built_in">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>, &#123; <span class="hljs-keyword">class</span>: <span class="hljs-string">&#x27;main-content&#x27;</span> &#125;, <span class="hljs-string">&#x27;真有意思&#x27;</span>)<br>])<br>复制代码<br><span class="hljs-comment">// 函数大致结构如下</span><br><span class="hljs-function"><span class="hljs-keyword">export</span> function <span class="hljs-title">createElement</span><span class="hljs-params">(tag,data,children)</span></span>&#123;<br>    <span class="hljs-comment">//....各种判断 判断生成什么样的Vnode</span><br>    <span class="hljs-keyword">if</span>(!tag)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">createEmptyVNode</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VNode</span>(tag,data,children);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>Vue-Router 源码中的工厂模式</p>
<p><code>vue-router</code> 中使用了工厂模式的思想来获得响应路由控制类的实例，<code>this.history</code> 用来保存路由实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span>&#123;<br>    <span class="hljs-title function_">constructotr</span>(<span class="hljs-params">options</span>)&#123;<br>        <span class="hljs-keyword">const</span> mode = options.<span class="hljs-property">mode</span> || <span class="hljs-string">&quot;hash&quot;</span>;<br>        <span class="hljs-keyword">switch</span> (mode) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;history&#x27;</span>:<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTML5History</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hash&#x27;</span>:<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashHistory</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">fallback</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;abstract&#x27;</span>:<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractHistory</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-attr">default</span>:<br>                <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>                  <span class="hljs-title function_">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">`invalid mode: <span class="hljs-subst">$&#123;mode&#125;</span>`</span>)<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p>
<ol>
<li><p>良好的封装，访问者无需了解创建过程，代码结构清晰。</p>
</li>
<li><p>扩展性良好，通过工厂方法隔离了用户和创建流程，符合开闭原则。</p>
</li>
<li><p>解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流；</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<p>给系统增加了抽象性，带来了额外的系统复杂度，不能滥用。（合理抽象能提高系统维护性，但可能会提高阅读难度，还是需要合理看待）</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>对象创建比较复杂，访问者无需了解创建过程。</p>
</li>
<li><p>需要处理大量具有相同&#x2F;类似属性的小对象。</p>
</li>
</ul>
<p>滥用只是增加了不必要的系统复杂度，过犹不及。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式：用于解决兼容问题，接口&#x2F;方法&#x2F;数据不兼容，将其转换成访问者期望的格式进行使用。</p>
<p>生活案例：</p>
<ol>
<li><p>耳机转接线。圆孔耳机插不进TypeC的手机里，只需一个TypeC转接头，此时TypeC转接头就是“适配器”。</p>
</li>
<li><p>翻译官。老板张三去国外谈业务，带上翻译官李四，李四这个时候就是作为不同语言的人之间交流的“适配器”。</p>
</li>
</ol>
<p>场景特点：</p>
<ol>
<li><p>同时存在多种格式，旧有接口格式不满足现在需要。</p>
</li>
<li><p>增加适配器可以更好使用旧接口。</p>
</li>
</ol>
<p>适配器模式必须包含目标（Target）、源（Adaptee）和适配器（Adapter）三个角色。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfd83567b2b9432f92eced319ba60064~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="🌰-例子-1"><a href="#🌰-例子-1" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>场景：我们要获取通过多个接口获取列表数据，拼接在一起，在一个组件内进行展示。因历史遗留原因，这些列表数据的格式不太一样。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">格式</span> <span class="hljs-number">1</span><br>&#123;<br>    <span class="hljs-attr">book_id:</span> <span class="hljs-number">1001</span><br>    <span class="hljs-attr">status:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">create:</span> <span class="hljs-string">&#x27;2021-12-12 08:10:20&#x27;</span>,<br>    <span class="hljs-attr">update:</span> <span class="hljs-string">&#x27;2022-01-15 09:00:00&#x27;</span>,<br>&#125;<span class="hljs-string">,</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">格式</span> <span class="hljs-number">2</span><br>&#123;<br>    <span class="hljs-attr">id:</span> <span class="hljs-number">1002</span><br>    <span class="hljs-attr">status:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">createTime:</span> <span class="hljs-number">16782738393022</span>,<br>    <span class="hljs-attr">updateAt:</span> <span class="hljs-string">&#x27;2022-01-15 09:00:00&#x27;</span>,<br>&#125;<span class="hljs-string">,</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">格式</span> <span class="hljs-number">3</span><br>&#123;<br>    <span class="hljs-attr">book_id:</span> <span class="hljs-number">1003</span><br>    <span class="hljs-attr">status:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">createTime:</span> <span class="hljs-number">16782738393022</span>,<br>    <span class="hljs-attr">updateAt:</span> <span class="hljs-number">16782738393022</span>,<br>&#125;<br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure>

<p>三个数据来源，三种时候数据结构，这时候我们有几种实现方式。</p>
<ol>
<li><p>组件针对不同的数据来源分别采用不同的渲染。（需要对数据类型进行区分）</p>
</li>
<li><p>在外部将数据转换成一种数据格式的列表传入，组件单一职责：展示。</p>
</li>
</ol>
<p><strong>对比之下，使用适配器模式</strong> <strong>，将不同的数据结构适配成展示组件所能接受的数据结构。保持了组件的单一职责，更优。</strong></p>
<ol>
<li>定义一个统一的数据结构</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> bookData &#123;<br>  <span class="hljs-attr">book_id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">createAt</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 时间戳</span><br>  <span class="hljs-attr">updateAt</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 时间戳</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<ol>
<li>通过适配器模块，适配成访问者所要数据格式</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> bookDataType1 &#123;<br>  <span class="hljs-attr">book_id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">create</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">update</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> bookDataType2 &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">createTime</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">updateAt</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> bookDataType3 &#123;<br>  <span class="hljs-attr">book_id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">createTime</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">updateAt</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> getTimeStamp = <span class="hljs-keyword">function</span> (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-comment">//.....转化成时间戳</span><br>  <span class="hljs-keyword">return</span> timeStamp;<br>&#125;;<br><br><span class="hljs-comment">//适配器</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bookDataAdapter = &#123;<br>  <span class="hljs-title function_">adapterType1</span>(<span class="hljs-params">list: bookDataType1[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">bookDataList</span>: bookData[] = list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">book_id</span>: item.<span class="hljs-property">book_id</span>,<br>        <span class="hljs-attr">status</span>: item.<span class="hljs-property">status</span>,<br>        <span class="hljs-attr">createAt</span>: <span class="hljs-title function_">getTimeStamp</span>(item.<span class="hljs-property">create</span>),<br>        <span class="hljs-attr">updateAt</span>: <span class="hljs-title function_">getTimeStamp</span>(item.<span class="hljs-property">update</span>),<br>      &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bookDataList;<br>  &#125;,<br><br>  <span class="hljs-title function_">adapterType2</span>(<span class="hljs-params">list: bookDataType2[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">bookDataList</span>: bookData[] = list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">book_id</span>: item.<span class="hljs-property">id</span>,<br>        <span class="hljs-attr">status</span>: item.<span class="hljs-property">status</span>,<br>        <span class="hljs-attr">createAt</span>: item.<span class="hljs-property">createTime</span>,<br>        <span class="hljs-attr">updateAt</span>: <span class="hljs-title function_">getTimeStamp</span>(item.<span class="hljs-property">updateAt</span>),<br>      &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bookDataList;<br>  &#125;,<br><br>  <span class="hljs-title function_">adapterType3</span>(<span class="hljs-params">list: bookDataType3[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">bookDataList</span>: bookData[] = list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">book_id</span>: item.<span class="hljs-property">book_id</span>,<br>        <span class="hljs-attr">status</span>: item.<span class="hljs-property">status</span>,<br>        <span class="hljs-attr">createAt</span>: item.<span class="hljs-property">createTime</span>,<br>        <span class="hljs-attr">updateAt</span>: item.<span class="hljs-property">updateAt</span>,<br>      &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bookDataList;<br>  &#125;,<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<ol>
<li>将数据经过适配器处理后进行整合，组件展示</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini">//整合数据<br>const <span class="hljs-attr">bookDataList</span> = [<br>  ...bookDataAdapter.adapterType1(type1MatailList),<br>  ...bookDataAdapter.adapterType2(type2MatailList),<br>  ...bookDataAdapter.adapterType3(type3MatailList),<br>]<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong> 可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；</p>
<p><strong>缺点：</strong> 会让系统变得零乱，明明调用 A，却被适配到了 B，如果滥用，那么对可阅读性不太友好。</p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>想要使用一个已经存在的对象，但是接口不满足需求，那么可以使用适配器模式转换成你需要的接口。</p>
</li>
<li><p>想要创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式。</p>
</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式：在不改变原对象的基础上，增加新属性&#x2F;方法&#x2F;功能。</p>
<p>一个对象被另一个对象包装，形成一条包装链，在原对象上增加功能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d0be5497afe4939b943d833583734b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="🌰-例子-2"><a href="#🌰-例子-2" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>暂时想不到什么好的例子和实际应用场景。</p>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p>
<ol>
<li>对象的核心职责和装饰功能区分开，可以通过动态增删装饰去除目标对象中的装饰逻辑。</li>
</ol>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式：定义一系列算法，根据输入的参数决定使用哪个算法。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/434302b146e040f4ac562413fb230282~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>重点：算法的实现和算法的使用分开。</strong></p>
<ul>
<li><p>Context ：封装上下文，根据需要调用需要的策略，屏蔽外界对策略的直接调用，只对外提供一个接口，根据需要调用对应的策略；</p>
</li>
<li><p>Strategy ：策略，含有具体的算法，其方法的外观相同，因此可以互相代替；</p>
</li>
<li><p>StrategyMap ：所有策略的合集，供封装上下文调用；</p>
</li>
</ul>
<h4 id="🌰-例子-3"><a href="#🌰-例子-3" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>场景：双十一满减活动。满200-20、满300-50、满500-100。这个需求，怎么写？</p>
<p><strong>if-else暴力法直接梭哈。</strong></p>
<p>通过判断输入的折扣类型来计算商品总价的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">priceCalculate</span>(<span class="hljs-params">discountType,price</span>)&#123;<br>    <span class="hljs-keyword">if</span>(discountType === <span class="hljs-string">&#x27;discount200-20&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">200</span>) * <span class="hljs-number">20</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(discountType === <span class="hljs-string">&#x27;discount300-50&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">300</span>) * <span class="hljs-number">50</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(userType === <span class="hljs-string">&#x27;discount500-100&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">500</span>) * <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li><p>随着折扣类型的增加，<code>if-else</code>会变得越来越臃肿。</p>
</li>
<li><p>折扣活动算法改变或折扣类型增加时，都需要改动<code>priceCalculate</code>方法，违反开闭原则。</p>
</li>
<li><p>复用性差，如果其他地方有类似的算法，但规则不一样，上述代码不能复用。</p>
</li>
</ol>
<p><strong>使用策略模式对代码改写</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 算法的实现</span><br><span class="hljs-keyword">const</span> discountMap = &#123;<br>    <span class="hljs-string">&#x27;discount200-20&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price / <span class="hljs-number">200</span>) * <span class="hljs-number">20</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;discount300-50&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">300</span>) * <span class="hljs-number">50</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;discount500-100&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">500</span>) * <span class="hljs-number">100</span>;<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">// 算法的使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">priceCalculate</span>(<span class="hljs-params">discountType,price</span>)&#123;<br>    <span class="hljs-keyword">return</span> discountMap[discountType] &amp;&amp; discountMap[discountType](price);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>以上代码就将算法的实现和算法的使用分开，以后不管增加或修改了算法，都无需对<code>priceCalculate</code>方法进行改动。</p>
<p>当然以上代码的抽象程度并不高，如果我们想隐藏计算算法，可以借助 IIFE 使用闭包的方式，提供一个添加策略的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> priceCalculate = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> discountMap = &#123;<br>        <span class="hljs-string">&#x27;discount200-20&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>            <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price / <span class="hljs-number">200</span>) * <span class="hljs-number">20</span>;<br>        &#125;,<br>        <span class="hljs-string">&#x27;discount300-50&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>            <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">300</span>) * <span class="hljs-number">50</span>;<br>        &#125;,<br>        <span class="hljs-string">&#x27;discount500-100&#x27;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) &#123;<br>            <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">500</span>) * <span class="hljs-number">100</span>;<br>        &#125;,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">addStategy</span>(<span class="hljs-params">stategyName,fn</span>)&#123;<br>            <span class="hljs-keyword">if</span>(discountMap[stategyName]) <span class="hljs-keyword">return</span>;<br>            discountMap[stategyName] = fn;<br>        &#125;,<br>        <span class="hljs-title function_">priceCal</span>(<span class="hljs-params">discountType,price</span>)&#123;<br>            <span class="hljs-keyword">return</span> discountMap[discountType] &amp;&amp; discountMap[discountType](price);<br>        &#125;<br>    &#125;<br>&#125;)()<br><br><span class="hljs-comment">// 使用</span><br>priceCalculate.<span class="hljs-title function_">priceCal</span>(<span class="hljs-string">&#x27;discount200-20&#x27;</span>,<span class="hljs-number">250</span>); <span class="hljs-comment">// 230</span><br><br>priceCalculate.<span class="hljs-title function_">addStategy</span>(<span class="hljs-string">&#x27;discount800-200&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>)&#123;<br>    <span class="hljs-keyword">return</span> price - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(price/<span class="hljs-number">800</span>) * <span class="hljs-number">200</span>;<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样算法就被隐藏起来，并且预留了增加策略的入口，便于扩展。</p>
<p>场景：表单验证。</p>
<p>表单验证项一般会比较复杂，所以需要给每个表单项增加 <code>validator</code> 自定义校验方法。以<code>ElementUI</code> 的 <code>Form</code> 表单为例。</p>
<p>我们可以像官网示例一样把表单验证都写在组件的状态 data 函数中。</p>
<p>缺点：不好复用使用频率比较高的表单验证方法，造成代码冗余。</p>
<p><strong>使用策略模式和函数</strong> <strong>柯里化</strong> <strong>对代码进行改写。</strong></p>
<p><code>utils/validates.js</code>为通用验证规则，即为<code>StrategyMap</code>。</p>
<p><code>utils/index.js</code>中的<code>formValidateGene</code>通过柯里化动态选择表单验证方法，即为<code>Context</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/utils/validates.js</span><br><span class="hljs-comment">// 姓名校验 由2-10位汉字组成 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateUsername</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^[\u4e00-\u9fa5]&#123;2,10&#125;$/</span><br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str)<br>&#125;<br><br><span class="hljs-comment">// 手机号校验 由以1开头的11位数字组成</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateMobile</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^1\d&#123;10&#125;$/</span><br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str)<br>&#125;<br><br><span class="hljs-comment">// 邮箱校验 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateEmail</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$/</span><br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str)<br>&#125;<br><br><span class="hljs-comment">// src/utils/index.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Validates</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./validates.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> formValidateGene = <span class="hljs-function">(<span class="hljs-params">key,msg</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">rule,value,cb</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Validates</span>[key] &amp;&amp; <span class="hljs-title class_">Validates</span>[key](value))&#123;<br>            <span class="hljs-title function_">cb</span>()<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">cb</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(msg))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>&lt;script&gt;<br>  <span class="hljs-keyword">import</span> &#123; formValidateGene &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils&#x27;</span><br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">ruleForm</span>: &#123;<br>          <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">telephone</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        &#125;,<br>        <span class="hljs-attr">rules</span>: &#123;<br>          <span class="hljs-attr">username</span>: [<br>            &#123; <span class="hljs-attr">validator</span>: <span class="hljs-title function_">formValidateGene</span>(<span class="hljs-string">&#x27;validateUsername&#x27;</span>,<span class="hljs-string">&#x27;用户名格式为2～10个汉字，请重新输入&#x27;</span>), <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>          ],<br>          <span class="hljs-attr">telephone</span>: [<br>            &#123; <span class="hljs-attr">validator</span>: <span class="hljs-title function_">formValidateGene</span>(<span class="hljs-string">&#x27;validateMobile&#x27;</span>,<span class="hljs-string">&#x27;手机号格式错误，请重新输入&#x27;</span>), <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>          ],<br>        &#125;<br>      &#125;;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ol>
<li><p>策略相互独立，可以互相切换。提高了灵活性以及复用性。</p>
</li>
<li><p>不需要使用<code>if-else</code>进行策略选择，提高了维护性。</p>
</li>
<li><p>可扩展性好，满足开闭原则。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>策略相互独立，一些复杂的算法逻辑无法共享，造成资源浪费。</p>
</li>
<li><p>用户在使用策略时，需要了解具体的策略实现。不满足最少知识原则，增加了使用成本。</p>
</li>
</ol>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li><p>算法需要自由切换的场景。</p>
</li>
<li><p>多个算法只有行为上有些不同，可以考虑策略模式动态选择算法。</p>
</li>
<li><p>需要多重判断，可以考虑策略模式规避多重条件判断。</p>
</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote>
<p>观察者模式：一个对象（称为subject）维持一系列依赖于它的对象（称为observer），将有关状态的任何变更自动通知给它们（观察者）。</p>
</blockquote>
<p><strong>观察者模式中的角色有两类：观察者和被观察者。</strong></p>
<ul>
<li>观察者必须订阅内容改变的事件，定义一对多的依赖关系。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b58ead6c9f2e49e88c73ecc2b12c57dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>生活中的例子：领导（被观察者）在台上介绍防疫政策，底下的工作人员（观察者）“观察”领导说的防疫政策的变化，当政策变化时，通知（update）到街道。</p>
<p>工作人员（观察者）必须订阅内容改变的事件，即用耳朵去听政策的变化。</p>
<h4 id="🌰-例子-4"><a href="#🌰-例子-4" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>简单的代码基本实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 观察者模式 被观察者Subject 观察者Observer Subject变化 notify观察者</span><br><span class="hljs-keyword">let</span> observerIds = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 被观察者Subject</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];<br>  &#125;<br><br>  <span class="hljs-comment">// 添加观察者</span><br>  <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);<br>  &#125;<br><br>  <span class="hljs-comment">// 移除观察者</span><br>  <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">obs</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> obs.<span class="hljs-property">id</span> !== observer.<span class="hljs-property">id</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 通知notify观察者</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> observer.<span class="hljs-title function_">update</span>(<span class="hljs-variable language_">this</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 观察者Observer</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = observerIds++;<br>  &#125;<br><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params">subject</span>) &#123;<br>    <span class="hljs-comment">// 更新</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：目标变化就会通知观察者，这是观察者模式最大的优点。</p>
<p>缺点： 不灵活。目标和观察者是耦合在一起的，要实现观察者模式，必须同时引入被观察者和观察者才能达到响应式的效果。</p>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><blockquote>
<p>发布&#x2F;订阅模式：基于一个主题&#x2F;事件通道，希望接收通知的对象（称为subscriber）通过自定义事件订阅主题，被激活事件的对象（称为publisher）通过发布主题事件的方式被通知。</p>
</blockquote>
<p><strong>发布-订阅模式的角色有两类：发布者和订阅者</strong></p>
<ul>
<li>使用一个主题通道，这个通道介于发布者和订阅者之间。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa47553e014346f29f0a3f51f11a2dc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"> 容</p>
<h4 id="🌰-例子-5"><a href="#🌰-例子-5" class="headerlink" title="🌰 例子"></a>🌰 例子</h4><p>我们微信会关注很多公众号，公众号有新文章发布时，就会有消息及时通知我们文章更新了。</p>
<p>这个时候公众号为发布者，用户为订阅者，用户将订阅公众号的事件注册到事件调度中心，当发布者发布新文章时，会发布事件至事件调度中心，调度中心会发消息告诉订阅者。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 订阅</span><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">push</span>(fn);<br>  &#125;<br><br>  <span class="hljs-comment">// 取消订阅</span><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> event !== fn;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 发布</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventEmitter</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">event</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="源码实例-2"><a href="#源码实例-2" class="headerlink" title="源码实例"></a>源码实例</h4><p>Vue 双向绑定中的发布订阅模式</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d3e2fcf8f643a2b29cb90941d5cd7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p><code>Vue</code> 双向绑定通过数据劫持和发布-订阅模式实现。</p>
<ol>
<li><p>通过<code>DefineProperty</code>劫持各个数据的<code>setter</code>和<code>getter</code>，并为每个数据添加一个订阅者列表，这个列表将会记录所有依赖这个数据的组件。响应式后的数据相当于消息的发布者。</p>
</li>
<li><p>每个组件都对应一个<code>Watcher</code>订阅者，当组件渲染函数执行时，会将本组件的<code>Watcher</code>加入到所依赖的响应式数据的订阅者列表中。相当于完成了一次订阅，这个过程叫做“依赖收集”。</p>
</li>
<li><p>当响应式数据发生变化时，会出<code>setter</code>，<code>setter</code>负责通知数据的订阅者列表中的<code>Watcher</code>，<code>Watcher</code>触发组件重新渲染来更新视图。视图层相当于消息的订阅者。</p>
</li>
</ol>
<p>EventEmitter</p>
<blockquote>
<p>跟 🌰 差不多，略。</p>
</blockquote>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ol>
<li><p>时间解耦：注册的订阅行为由发布者决定何时调用，订阅者无需持续关注，由发布者负责通知。</p>
</li>
<li><p>对象解耦：发布者无需知道消息的接受者，只需遍历订阅该消息类型的订阅者发送消息，解耦了发布者和订阅者之间的联系，互不持有，都依赖于抽象。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>资源消耗：创建订阅者需要一定的时间和内存。</p>
</li>
<li><p>增加复杂度：弱化了联系，难以维护调用关系，增加了理解成本。</p>
</li>
</ol>
<h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>各模块相互独立</p>
</li>
<li><p>存在一对多的依赖关系</p>
</li>
<li><p>依赖模块不稳定、依赖关系不稳定</p>
</li>
<li><p>各模块由不同的人员开发</p>
</li>
</ul>
<h2 id="5-this的指向"><a href="#5-this的指向" class="headerlink" title="5 this的指向"></a>5 this的指向</h2><h3 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h3><p>在javascript中，this可谓是无处不在，它可以用来指向某些元素、对象，在合适的地方使用this，能让我们减少无用代码的编写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;aclie&quot;</span>,<br>  <span class="hljs-attr">sing</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在唱歌&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">dance</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在跳舞&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">study</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在学习&#x27;</span>)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上这段代码中，每个方法都需要用到user对象中的name属性，如果当user对象名称发生变化，那么所有方法都要改动，这种情况下，使用this是个很好的选择</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;aclie&quot;</span>,<br>  <span class="hljs-attr">sing</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在唱歌&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">dance</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在跳舞&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">study</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;在学习&#x27;</span>)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><blockquote>
<p>this的指向和函数在哪里定义无关，和如何调用有关</p>
</blockquote>
<p>以下foo函数调用方式不同，this的值也不同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">foo</span>()<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>() <br><br>obj.<span class="hljs-property">foo</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&quot;hello&quot;</span>)    <br></code></pre></td></tr></table></figure>

<p>执行结果如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104035637-20230411%2010:40:37.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104035637"></p>
<h3 id="this四种绑定方式"><a href="#this四种绑定方式" class="headerlink" title="this四种绑定方式"></a>this四种绑定方式</h3><p><strong>一、默认绑定</strong></p>
<blockquote>
<p>当函数独立调用时，this默认绑定window</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1、直接调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">foo</span>()<br><br><span class="hljs-comment">// 2、对象中的函数</span><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><span class="hljs-keyword">var</span> fn1 = obj1.<span class="hljs-property">foo</span><br><span class="hljs-title function_">fn1</span>()<br><br><span class="hljs-comment">// 3、被全局变量引用</span><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> fn2 = obj2.<span class="hljs-property">bar</span><br><span class="hljs-title function_">fn2</span>()<br><br><span class="hljs-comment">// 4、函数嵌套调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo1&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo2&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>  <span class="hljs-title function_">foo1</span>()<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo3&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>  <span class="hljs-title function_">foo2</span>()<br>&#125;<br><span class="hljs-title function_">foo3</span>()<br><br><span class="hljs-comment">// 5、通过闭包调用</span><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br>&#125;<br>obj2.<span class="hljs-title function_">bar</span>()()<br></code></pre></td></tr></table></figure>

<p>执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104057283-20230411%2010:40:57.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104057283"></p>
<p>以上五种调用方式全都属于默认绑定，因为他们最终都是单独的对函数进行调用</p>
<p><strong>二、隐式绑定</strong></p>
<blockquote>
<p>调用的对象内部有对函数的引用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br>obj1.<span class="hljs-title function_">foo</span>()<br><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj2&#x27;</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>obj2.<span class="hljs-title function_">bar</span>()<br><br><span class="hljs-keyword">var</span> obj3 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj3&#x27;</span>,<br>  <span class="hljs-attr">baz</span>: obj2.<span class="hljs-property">bar</span><br>&#125;<br>obj3.<span class="hljs-title function_">baz</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104112732-20230411%2010:41:12.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104112732"></p>
<p>以上三种都属于隐式绑定，他们都是通过对象调用，this就指向了该对象</p>
<p><strong>三、显式绑定</strong></p>
<blockquote>
<p>不希望在对象内部包含这个函数的引用，但又希望通过对象强制调用，使用call&#x2F;apply&#x2F;bind进行显式绑定</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>,<br>&#125;<br><br>foo.<span class="hljs-title function_">call</span>(obj)<br>foo.<span class="hljs-title function_">apply</span>(obj)<br>foo.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;xxx&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104134131-20230411%2010:41:34.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104134131"></p>
<p>foo函数直接调用this应该指向window，这里通过call&#x2F;apply来改变了this的指向</p>
<p><strong>四、new绑定</strong></p>
<blockquote>
<p>通过new关键字来创建构造函数的实例，绑定this</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">20</span>)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;mogan&#x27;</span>, <span class="hljs-number">24</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104147865-20230411%2010:41:48.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104147865"></p>
<p>此时this指向的是通过new创建的实例对象</p>
<h3 id="this绑定的优先级"><a href="#this绑定的优先级" class="headerlink" title="this绑定的优先级"></a>this绑定的优先级</h3><p><strong>一、隐式绑定高于默认绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104203699-20230411%2010:42:03.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104203699"></p>
<p>foo函数默认绑定window对象，当同时存在隐式绑定和默认绑定时，隐式绑定优先级高于默认绑定</p>
<p><strong>二、显示绑定高于隐式绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 案例一</span><br><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>user.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;kiki&#x27;</span>)<br><br><span class="hljs-comment">// 案例二</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span>,<br>  <span class="hljs-attr">foo</span>: foo.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&quot;aclie&quot;</span>)<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104220954-20230411%2010:42:21.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104220954"></p>
<p>如果隐式绑定优先级更高的话，this的指向应该都为对象，但根据以上执行结果得知this绑定为显示绑定的结果，所以当同时存在隐式绑定和显示绑定时，显示绑定的优先级高于隐式绑定</p>
<p><strong>三、new高于隐式绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lisa&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">new</span> user.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104232426-20230411%2010:42:32.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104232426"></p>
<p>当同时存在于new关键字绑定和隐式绑定时，this绑定了foo构造函数，所以new关键字的优先级高于隐式绑定</p>
<p><strong>四、new高于显示绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> fn = bar.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104243338-20230411%2010:42:43.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104243338"></p>
<p>当同时存在于new关键字绑定和显示绑定时，this绑定了bar构造函数，所以new关键字的优先级高于显示绑定</p>
<p><strong>综上，以上四种绑定的优先级顺序为</strong></p>
<blockquote>
<p>new关键字 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
</blockquote>
<h3 id="规则之外"><a href="#规则之外" class="headerlink" title="规则之外"></a>规则之外</h3><p>还有几种特殊的绑定方式，不在上述四种绑定规则中</p>
<p><strong>一、忽略显示绑定</strong></p>
<blockquote>
<p>当显示绑定的值为 null&#x2F;undefined 时，this直接绑定window</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;alice&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>user.<span class="hljs-title function_">foo</span>()<br>user.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>)<br>user.<span class="hljs-property">foo</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">undefined</span>)<br></code></pre></td></tr></table></figure>

<p>以上代码执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104256708-20230411%2010:42:56.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104256708"></p>
<p><strong>二、间接函数引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj2&#x27;</span><br>&#125;;<br>obj2.<span class="hljs-property">baz</span> = obj1.<span class="hljs-property">foo</span>;<br>obj2.<span class="hljs-title function_">baz</span>();<br><br>(obj2.<span class="hljs-property">bar</span> = obj1.<span class="hljs-property">foo</span>)()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104313515-20230411%2010:43:13.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104313515"></p>
<p>两种方式所绑定的this不同，第二种方式进行了赋值调用，实际上是间接函数引用，（obj2.bar &#x3D; obj1.foo）这里返回了赋值的结果，再加上一个小括号，就直接调用赋值的结果函数</p>
<p><strong>三、箭头函数</strong></p>
<blockquote>
<p>箭头函数是不绑定this的，它的this来源于上级作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kiki&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数中的this&#x27;</span>,<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br>user.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104326432-20230411%2010:43:26.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104326432"></p>
<p>这里调用foo函数，因为箭头函数不绑定this，所以去foo函数的上级查找this，找到了全局对象window</p>
<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><p><strong>1、考察间接函数引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;window&quot;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;person&quot;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> sss = person.<span class="hljs-property">sayName</span>;<br>  <span class="hljs-title function_">sss</span>(); <br>  person.<span class="hljs-title function_">sayName</span>(); <br>  (person.<span class="hljs-property">sayName</span>)(); <br>  (b = person.<span class="hljs-property">sayName</span>)();<br>&#125;<br><span class="hljs-title function_">sayName</span>();<br></code></pre></td></tr></table></figure>

<p>执行sayName函数</p>
<ul>
<li>变量sss 被person.sayName方法赋值，执行sss函数，此时是独立函数调用，this指向全局window，全局中变量name被绑定到了window中，所以this.name为”window”</li>
<li>person.sayName() 为隐式绑定，this指向person对象，所以this.name为person.name，即”person”</li>
<li>(person.sayName)() 与前一个本质是一样的，隐式绑定，this指向person对象，所以this.name为person.name，即”person”</li>
<li>(b &#x3D; person.sayName)() 是间接函数引用，person.sayName赋值给b变量，而小括号括起来的代表赋值的结果，this指向window，this.name为window.name，即”window”</li>
</ul>
<p>所以执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104341809-20230411%2010:43:42.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104341809"></p>
<p><strong>2、定义对象时是不产生作用域的</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person1&#x27;</span>,<br>  <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-attr">foo2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-attr">foo3</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">foo4</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person2&#x27;</span> &#125;<br><br>person1.<span class="hljs-title function_">foo1</span>();<br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2);<br><br>person1.<span class="hljs-title function_">foo2</span>();<br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2);<br><br>person1.<span class="hljs-title function_">foo3</span>()();<br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)();<br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2);<br><br>person1.<span class="hljs-title function_">foo4</span>()();<br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)();<br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2);<br></code></pre></td></tr></table></figure>

<p>调用过程分析</p>
<ol>
<li>foo1函数<ul>
<li>person1.foo1() 隐式绑定，this指向person1，this.name为person1.name，即 “person1”</li>
<li>person1.foo1.call(person2) 隐式绑定+显示绑定person2，显示绑定优先级更高，所以this指向person2，this.name为person2.name，即 “person2”</li>
</ul>
</li>
<li>foo2函数<ul>
<li>person1.foo2() 隐式绑定， 箭头函数没有自己的this，所以向上层作用域查找，找到了全局window（person1是对象，定义它的时候不产生作用域），全局变量name被绑定到了window中，this.name为window.name，即 “window”</li>
<li>person1.foo2.call(person) 隐式绑定+显示绑定，但是 箭头函数不绑定this，这里的显示绑定无效，没有自己的this，向上层作用域查找，找到全局window，this.name为window.name，即 “window”</li>
</ul>
</li>
<li>foo3函数<ul>
<li>person1.foo3()() 这里相当于执行person1.foo()的返回函数，这里是独立函数调用，this指向全局window，this.name为window.name，即 “window”</li>
<li>person1.foo3.call(person2)() 这里通过call改变的是foo3函数中this的指向，但最终执行的是foo3函数返回的闭包，闭包作为独立函数调用，this仍然指向全局window，this.name为window.name，即’window”</li>
<li>person1.foo3().call(person2) 这里将foo3函数返回的闭包显示绑定了person2对象，this指向person2，this.name为person2.name，即”person2”</li>
</ul>
</li>
<li>foo4函数<ul>
<li>person1.foo4()() 执行person1.foo()的返回值，返回的闭包是箭头函数没有this的，向上层作用域查找，找到了foo4函数，foo4的this指向person1，所以闭包的this也指向person1，thiss.name为person1.name，即 “person1”</li>
<li>person1.foo4.call(person2)() 返回的闭包没有this，向上层作用域找到了foo4函数，foo4函数的this通过显示绑定变成了person2，所以闭包的this也指向person2，this.name为person2.name，即”person2”</li>
<li>person1.foo4().call(person) 返回的闭包是箭头函数，无法通过call进行显示绑定，直接向上级作用域查找，找到foo4函数，foo4的this指向person1，所以闭包的this指向person1，this.name为person1.name，即”person1”</li>
</ul>
</li>
</ol>
<p>上述代码的执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104355086-20230411%2010:43:55.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104355086"></p>
<p><strong>3、构造函数中定义函数，该函数的上级作用域是构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-title function_">foo1</span>()<br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo2</span>() <br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo3</span>()()<br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)()<br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo4</span>()()<br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)()<br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <br></code></pre></td></tr></table></figure>

<p>调用分析过程</p>
<ol>
<li>foo1函数<ul>
<li>person1.foo1() 隐式绑定，this指向person1，person1创建实例时传入name为person1，所以this.name为person1</li>
<li>person1.foo1.call(person2) 隐式绑定+显示绑定，显示绑定优先级更高，绑定person2，person2创建实例时传入的name为person2，所以this.name为person2</li>
</ul>
</li>
<li>foo2函数<ul>
<li>person1.foo2() 隐式绑定，但foo2是箭头函数，没有自己的this，向上层作用域查找，找到了Person构造函数，此时this是指向person1这个对象的，而person1实例化时传入的name为person1，所以this.name为person1</li>
<li>person1.foo2.call(person2) 隐式绑定+显式绑定，但foo2是箭头函数，不绑定this，所以this仍然需要向上层作用域查找，找到Person构造函数，this指向person1对象，所以this.name为person1</li>
</ul>
</li>
<li>foo3函数<ul>
<li>person1.foo3()() 执行person1.foo3的返回值，返回的函数是独立调用，this指向window，全局的name变量被绑定到window中，this.name为window.name，即 “window”</li>
<li>person1.foo3.call(person2)() 显式绑定更改的是foo3函数的this，最终执行的是foo3函数的返回值，仍然是函数的独立调用，所以this指向window，this.name为window.name，即 “window”</li>
<li>person1.foo3().call(person2) foo3函数的返回函数通过显示绑定将this绑定到了person2中，person2创建实例时传入的name为person2，所以this.name为person2</li>
</ul>
</li>
<li>foo4函数<ul>
<li>person1.foo4()() 执行foo4函数的返回值，返回函数为箭头函数，没有this，所以向上层作用域查找，找到foo4函数的this指向person1，所以箭头函数的this也指向person1，所以this.name为person1</li>
<li>person1.foo4.call(person2)() foo4通过显示绑定将this绑定成了person2，返回的函数为箭头函数，this与父级作用域foo4一致，所以箭头函数的this也指向person2，所以this.name为person2</li>
<li>person1.foo4().call(person2) foo4函数的返回值为箭头函数，不绑定this，这里显示绑定无效，向上级作用域查找this，找到foo4函数，this指向person1</li>
</ul>
</li>
</ol>
<p>执行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104409934-20230411%2010:44:10.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104409934"></p>
<p><strong>4、区分作用域</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>    <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">foo2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>().<span class="hljs-title function_">call</span>(person2) <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>().<span class="hljs-title function_">call</span>(person2) <br></code></pre></td></tr></table></figure>

<ol>
<li>foo1函数<ul>
<li>person1.obj.foo1()() 执行foo1函数的返回函数，此时该函数为独立函数调用，this指向window，全局变量name被添加到window中，这里的this.name指向window.name，即 “window”</li>
<li>person1.obj.foo1.call(person2)() 这里显示绑定改变foo1中this的指向，但最终执行的是foo1函数的返回值，返回函数作为独立函数调用，this仍然指向window，所以this.name为window.name，即 “window”</li>
<li>person1.obj.foo1().call(person2) 这里通过显示绑定更改foo1函数的返回函数中this的指向， 所以该函数this指向person2，而person2在实例化的时候传入name值为person2，所以this.name为person2</li>
</ul>
</li>
<li>foo2函数<ul>
<li>person1.obj.foo2()() 执行foo2的返回函数，此时该函数为独立函数调用，但它自己没有this，要向上级作用域查找，找到foo2函数的this指向obj，所以该函数的this也指向obj，this.name为obj.name，即 “obj”</li>
<li>person1.obj.foo2.call(person2)() 执行foo2的返回函数，此时该函数为独立函数调用，但它自己没有this，要向上级作用域查找，foo2函数的this通过显示绑定变成person2，所以该函数的this也为person2，而person2在实例化的时候传入name值为person2，所以this.name为person2</li>
<li>person1.obj.foo2().call(person2) foo2的返回函数为箭头函数，不绑定this，显式绑定无效，也没有自己的this，要向上级作用域查找，找到foo2函数的this指向obj，所以该函数的this也指向obj，this.name为obj.name，即 “obj”</li>
</ul>
</li>
</ol>
<p>所以执行结果为</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230411104425836-20230411%2010:44:26.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230411104425836"></p>
<h2 id="6-原型链"><a href="#6-原型链" class="headerlink" title="6 原型链"></a>6 原型链</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个前端开发工程师，熟练掌握JS这门语言是必须要的。无论是日常的工作中，亦或者是出去面试找工作，JS掌握的多深多好，很大程度上决定了你能走的多远。今天本人就来介绍一下JS的<code>原型</code>以及<code>原型链</code>，基于本人的一些认识。因为本人也在学习的阶段，所以如果文章中有什么不对的或者不好的地方，烦请大家指出。</p>
<h3 id="JS原型"><a href="#JS原型" class="headerlink" title="JS原型"></a>JS原型</h3><p>众所周知，JS的复杂类型都是对象类型（<strong>Object</strong>），而JS不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>因为JS中没有类（<strong>Class</strong>）这个概念，所以JS的设计者使用了<code>构造函数</code>来实现继承机制。</p>
<blockquote>
<p>ES6中的<code>class</code>可以看作只是一个语法糖，它的绝大部分的功能，ES5都可以做到，新的<code>class</code>写法只是让原型的写法更加的清晰、更像面向对象编程的语法而已。下文也会进一步的说明。（摘自阮一峰的ES6入门）</p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 构造函数<br>function Person(name, age) &#123;<br>    <span class="hljs-attr">this.name</span> = name<span class="hljs-comment">;</span><br>    <span class="hljs-attr">this.age</span> = age<span class="hljs-comment">;</span><br>&#125;<br><br>// 生成实例<br>const <span class="hljs-attr">p</span> = new Person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如上述代码所示，JS通过<code>构造函数</code>来生成<code>实例</code>。但是又出现了一个新的问题，在<code>构造函数</code>中通过<code>this</code>赋值的属性或者方法，是每个实例的<code>实例属性</code>以及<code>实例方法</code>，无法共享公共属性。所以又设计出了一个<code>原型对象</code>，来存储这个<code>构造函数</code>的公共属性以及方法。</p>
<h4 id="补充知识：构造函数创建一个实例的过程"><a href="#补充知识：构造函数创建一个实例的过程" class="headerlink" title="补充知识：构造函数创建一个实例的过程"></a>补充知识：构造函数创建一个实例的过程</h4><ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（这样this就指向了新对象）</li>
<li>执行构造函数中的代码（为新对象添加实例属性和实例方法）</li>
<li>返回新对象</li>
</ol>
<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>说了这么久，终于说到了JS的<code>原型对象</code>了。JS的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5aaae37b7094aaaad14daa910c61775~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h3><p>讲清楚了JS的<code>原型对象</code>，来就是介绍JS的<code>原型链</code>了。既然有了<code>构造函数</code>，那么就可以通过该<code>构造函数</code>，来创建一个实例对象了。此时，完善一下我们的<code>Preson</code>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Preson</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 所有实例共享的公共方法</span><br><span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br>p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法 打印：张三说：hello world</span><br><br></code></pre></td></tr></table></figure>

<p>这里就要思考了，为什么我们构造的<code>p1</code>这个<code>实例对象</code>，它可以调用到<code>Person</code>这个<code>构造函数</code>的<code>原型对象</code>上的方法呢？明明只有在<code>构造函数</code>内部通过<code>this</code>来赋值的属性或者方法才会被实例所继承，为什么在<code>构造函数</code>的<code>原型对象</code>上定义的<code>say</code>方法也能通过实例来调用到呢？这里就引出了<code>原型链</code>这个概念。</p>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em><em>proto</em></em></h4><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>，这么说好像有点绕，我们看下图</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1141452b532f4e9cab03ba48f58beade~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的<code>私有属性</code>，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法&#x2F;属性。（摘自阮一峰的ES6入门）</p>
</blockquote>
<p>现在我们知道了，当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p>
<p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Preson</span>(<span class="hljs-params">name, age</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-comment">// 所有实例共享的公共方法</span><br>    <span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br>    <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 新创建一个Proson实例对象</span><br>    p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法</span><br>    p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>    p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">do</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;往原型对象中添加方法&#x27;</span>);<br>    &#125;<br>    p2.<span class="hljs-title function_">do</span>(); <span class="hljs-comment">// 打印出了-往原型对象中添加方法</span><br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>所以，我们在开发的时候，要注意不要通过<code>实例对象</code>去改变其<code>构造函数</code>的<code>原型对象</code>，这样会对其他通过该<code>构造函数</code>生成的<code>实例对象</code>造成影响。</p>
</blockquote>
<p>说到这里，有的读者可能又会产生疑问了，再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找是什么意思？我们继续往下看。</p>
<h4 id="补充知识：原型链的尽头"><a href="#补充知识：原型链的尽头" class="headerlink" title="补充知识：原型链的尽头"></a>补充知识：原型链的尽头</h4><p>既然我们之前构造的<code>p1实例对象</code>有<code>__proto__</code>属性指向其<code>构造函数</code>的<code>原型对象</code>，那么该<code>构造函数</code>的<code>原型对象</code>有这个<code>__proto__</code>属性吗？如果有，那么其又指向谁呢？我们不妨打印一下。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2750863007534407b542d38ea5259cdf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>我们随便创建了一个<code>A</code>的<code>构造函数</code>，通过打印它的<code>prototype</code>属性，我们可以看到，在浏览器中，它有个<code>__proto__</code>属性指向了一个<code>Object</code>对象。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2cda9bce64b41339f411a9c974000d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>而进一步展开后，我们会发现，该对象的<code>构造函数</code>为<code>function Object</code>，我们由此可以得知，<strong>所有的<code>原型对象</code>的<code>__proto__</code>属性都是指向<code>function Object</code>的<code>原型对象</code>。</strong> 而<code>function Object</code>的<code>原型对象</code>在上图中我们可以得知是不存在<code>__proto__</code>这个属性的，它指向了<code>null</code>。我们就得知了<code>原型链</code>的尽头是<code>null</code>。</p>
<h4 id="补充知识：所有对象的原型链"><a href="#补充知识：所有对象的原型链" class="headerlink" title="补充知识：所有对象的原型链"></a>补充知识：所有对象的原型链</h4><p>既然JS的复杂类型都是<code>对象</code>，那么，函数作为一个<code>对象</code>，是否也存在<code>原型链</code>呢？ 我们在浏览器中创建一个<code>构造函数</code>，打印它的<code>__proto__</code>属性，一探究竟：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/818ed8034ed54aa9aa6591d8be8a70ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>我们可以看到，它的<code>__proto__</code>属性指向了一个<code>function Function</code>的<code>原型对象</code>，该<code>原型对象</code>为JS中所有函数的<code>原型对象</code>，而其<code>__proto__</code>属性也还是指向了<code>function Object</code>的<code>原型对象</code>，所以验证了<code>原型链</code>的尽头为<code>null</code>，这一说法。</p>
<p>最后，奉上神图一张，祝大家理解JS的<code>原型链</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0815c8f7fa544cf4a33fd7defdc6c1f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">   你可以将它想象成一个链条，连接着实例对象和原型对象。每个函数都有一个prototype属性，<br>   这就是我们所说的原型对象。如果这个函数用new 构建出了一个实例对象，这个实例对象会有<br>   一个<span class="hljs-strong">__proto__</span>指针指向他的构造函数的原型对象，这样构造函数和实例对象之间就通过<br>   (<span class="hljs-strong">__proto__</span>)连接在一起，形成了一个链子。     <br>   <br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b004a98f32e40e19da293add4b690c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="原型链的作用"><a href="#原型链的作用" class="headerlink" title="原型链的作用"></a>原型链的作用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">JS有一个原型查找机制，把原来定义在实例上的方法，放到原型对象上去，通过构造函数的new操作，会把原型对<br>象赋值给实例的<span class="hljs-strong">__proto__</span>属性，那么当使用返回的实例去调用某一个方法的时候，如果实例本身上没有，就去自<br>动去实例的<span class="hljs-strong">__proto__</span>上去查找，这样达到方法的复用，减少内存开销。   <br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="prototype-和-proto"><a href="#prototype-和-proto" class="headerlink" title="prototype 和 proto"></a>prototype 和 <strong>proto</strong></h3><ul>
<li><p>prototype</p>
<p>显式原型，是构造函数的原型对象，函数的独有属性</p>
</li>
<li><p><strong>proto</strong></p>
<p>是实例对象指向原型对象的指针，隐式原型，是每一个对象都有的属性</p>
</li>
<li><p>示例</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b70d1d571e7a47478ecd08892fbae7c9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78b281e66df644dbb693a026f0dbd50f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">由上面的示例可知，构造函数和prototype对象，<span class="hljs-strong">__proto__</span>指针是有关联的，在实例对象中用<span class="hljs-strong">__proto__</span>指针调<br>用方法，而在原型对象中则用prototype ，这两种相等，则说明原型链将被 <span class="hljs-strong">__proto__</span> 指针连接起来。<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><p>constructor</p>
<p>原型对象中，还有一个指向函数的 constructor 属性</p>
<p>每个函数都有一个原型对象，该原型对象有一个constructor属性，指向创建对象的函数本身。</p>
</li>
</ul>
<p>所有的实例对象都可以访问 constructor 属性 ， 可以使用 constructor 属性来判断是否在一个原型链上</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c064ed668cc40748b9be48fbabf7854~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68f12e9cf5434f9795a04881eabfc3d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>示例</p>
<p>两者的 constructor 值相等，说明他们在同一个原型链上</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>1.实例化对象中查询使用__proto__ 指针 ，它指向prototype 对象</p>
<p>2.prototype 是函数独有的属性，定义构造函数时自动被创建，可以给函数和对象添加可共享的（继承的）方法和属性</p>
<p>3.constructor 属性能使原型对象和实例对象找到其创建他们的构造函数。</p>
<h2 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7 闭包"></a>7 闭包</h2><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong></p>
<p>先了解一些变量的作用域：</p>
<p>变量的作用域包括两种：全局变量和局部变量。</p>
<p>全局变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br><span class="hljs-title function_">f1</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>局部变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<span class="hljs-comment">//局部变量</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<span class="hljs-comment">//n is not defined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="一、简单理解闭包"><a href="#一、简单理解闭包" class="headerlink" title="一、简单理解闭包"></a>一、简单理解闭包</h3><p>先看一下MDN关于闭包的定义：</p>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
</blockquote>
<p>重点的一句：<strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</strong></p>
<p>现在不理解也没关系，继续往下看：</p>
<p>学习一个概念时，最好的方法就是找它的demo，从demo中理解和分析，下面先看一段代码，这是一个最简单的闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> f2<span class="hljs-comment">//返回内部函数f2，这样在f1中就能读取f2的数据和函数等价于window.f2 = f2;</span><br>  <br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>首先定义个普通函数f1；</li>
<li>在f1中再定义一个普通函数f2、和在f1函数中的内部变量n;</li>
<li>在f1中返回函数f2(确切说，在f1中返回了f2的引用);</li>
<li>将f1的返回值赋值给变量result；</li>
<li>执行result</li>
</ul>
<p>在上边的代码中，f1函数里面嵌套了一个函数f2，并且f2调用了f1的变量，那么变量n和函数f2组合就成了一个闭包。</p>
<p>那为什么是闭包呢？我们可以根据上边MDN对闭包的定义这句话（<strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</strong>）进行分析，我们再看一张图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e69a7ec327436d8aedf7b92828e961~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>f1是一个外部函数，变量n是外部函数的局部变量，f2是嵌套在f1中的一个内部函数，在<strong>内部函数f2中调用了外部函数f1的变量n</strong>,所以f2和变量n就组成了一个闭包。</p>
<p>那么，我们就可以得出产生闭包的条件：</p>
<ul>
<li>一个<strong>外部函数里面嵌套着一个内部函数</strong>；比如外部函数f1里面嵌套了一个内部函数f2</li>
<li>一个嵌套的<strong>内部函数调用了外部函数的内部变量或函数</strong>；比如f2内部函数调用了外部函数f1的变量n 只要满足以上两个条件，就产生了闭包。</li>
</ul>
<p>那你可能会问为什么要return f1呢？</p>
<p>因为在JS中，只要内部函数才能够读取外部函数的内部变量或数据，反之则不行，如果你不return f2，那你将无法使用f2这个闭包，return f2是为了在f1中能使用f2的变量和数据，与闭包没有关系的。</p>
<p>那到底什么是闭包呢？</p>
<p>可以通俗理解成：<strong>闭包就是有权访问另一个函数作用域中内部变量或数据的函数</strong>，因为在JS中，只要内部函数能能够读取外部函数的变量或数据，反之就不行，所有可以将<strong>闭包简单理解成，定义在一个函数内部的函数。</strong></p>
<p>总结：</p>
<p><strong>闭包就是有权访问另一个函数内部变量的函数。</strong></p>
<p><strong>闭包产生的原因：内部函数存在对外部函数局部变量的引用就会导致闭包。</strong></p>
<p>到这里相信你也已经对闭包有了一个简单的了解了，但是单单是了解还是不够的，我们学学习一样技术，最重要的就是要学以致用，那我们继续往下了解吧。</p>
<h3 id="二、闭包的经典使用场景"><a href="#二、闭包的经典使用场景" class="headerlink" title="二、闭包的经典使用场景"></a>二、闭包的经典使用场景</h3><h4 id="1、return一个内部函数，读取内部函数的变量；"><a href="#1、return一个内部函数，读取内部函数的变量；" class="headerlink" title="1、return一个内部函数，读取内部函数的变量；"></a>1、return一个内部函数，读取内部函数的变量；</h4><p>最大的一个用途就是前面提到的可以：读取内部函数的变量；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2；<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2、函数作为参数"><a href="#2、函数作为参数" class="headerlink" title="2、函数作为参数"></a>2、函数作为参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f3</span>(<span class="hljs-params">p</span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1001</span>;<br>  <span class="hljs-title function_">p</span>();<br>&#125;<br><br><span class="hljs-title function_">f3</span>(<span class="hljs-title function_">f1</span>());<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3、IIFE（自执行函数）"><a href="#3、IIFE（自执行函数）" class="headerlink" title="3、IIFE（自执行函数）"></a>3、IIFE（自执行函数）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;)()<br><span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边的代码中f1( )是一个闭包，调用了全局变量n（即调用了window下的变量n）;</p>
<h4 id="4、循环赋值"><a href="#4、循环赋值" class="headerlink" title="4、循环赋值"></a>4、循环赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;,<span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br><span class="hljs-comment">//1,2,3,4,5,6,7,8,9,10依次打印</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5、使用回调函数就是在使用闭包"><a href="#5、使用回调函数就是在使用闭包" class="headerlink" title="5、使用回调函数就是在使用闭包"></a>5、使用回调函数就是在使用闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">n</span> = <span class="hljs-number">999</span>;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">n</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="6、将外部函数创建的变量值始终保持在内存中；"><a href="#6、将外部函数创建的变量值始终保持在内存中；" class="headerlink" title="6、将外部函数创建的变量值始终保持在内存中；"></a>6、将外部函数创建的变量值始终保持在内存中；</h4><p>可以看下下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n++);<br>  &#125;<br>  result f2<br>&#125;<br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码中f1的内部变量n一直存在内存中，不会在f1调用结束后被自动清除。 再看另一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  nAdd = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    n+=<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  result f2<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br><span class="hljs-title function_">nAdd</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码中函数f1的返回值赋值给了全局变量result，函数f1的返回值实际上就是f2函数，可以理解为f2被赋值给了全局变量result，这就导致了f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束之后，被垃圾回收机制(GC机制)回收，所有很容易造成<strong>内存泄漏</strong>。</p>
<p>内存泄漏，就是一些你访问不到或用不到的变量，还占据着内存空间，不能被再次利用起来。</p>
<h4 id="7、封装对象的私有对象和私有方法；"><a href="#7、封装对象的私有对象和私有方法；" class="headerlink" title="7、封装对象的私有对象和私有方法；"></a>7、封装对象的私有对象和私有方法；</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>)&#123;<br>     privateCounter += val;<br>   &#125;<br>   <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">increment</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">decrement</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">value</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> privateCounter;<br>      &#125;<br>   &#125;<br> &#125;)();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="三、-使用闭包需要注意什么？"><a href="#三、-使用闭包需要注意什么？" class="headerlink" title="三、 使用闭包需要注意什么？"></a>三、 使用闭包需要注意什么？</h3><p>因为使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制（简称GC机制）回收，多度使用闭包会过度占用内存，造成内存泄漏。</p>
<h3 id="形成闭包的原因"><a href="#形成闭包的原因" class="headerlink" title="形成闭包的原因"></a>形成闭包的原因</h3><blockquote>
<p><strong>内部的函数存在外部作用域的引用就会导致闭包</strong>。从上面介绍的上级作用域的概念中其实就有闭包的例子 <code>return f</code>就是一个表现形式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b =<span class="hljs-number">14</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>    &#125;<br>    <span class="hljs-title function_">fo</span>()<br>&#125;<br><span class="hljs-title function_">foo</span>()<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的子函数 <code>fo</code> 内存就存在外部作用域的引用 <code>a, b</code>，所以这就会产生闭包</p>
</blockquote>
<h3 id="闭包变量存储的位置"><a href="#闭包变量存储的位置" class="headerlink" title="闭包变量存储的位置"></a>闭包变量存储的位置</h3><blockquote>
<p>直接说明：<strong>闭包中的变量存储的位置是堆内存。</strong></p>
</blockquote>
<ul>
<li>假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。</li>
</ul>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul>
<li>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。</li>
<li>保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li>
</ul>
<h3 id="JS-堆栈内存释放"><a href="#JS-堆栈内存释放" class="headerlink" title="JS 堆栈内存释放"></a>JS 堆栈内存释放</h3><ul>
<li>堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。</li>
<li>堆内存释放：将引用类型的空间地址变量赋值成 <code>null</code>，或没有变量占用堆内存了浏览器就会释放掉这个地址</li>
<li>栈内存：提供代码执行的环境和存储基本类型值。</li>
<li>栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。</li>
</ul>
<h3 id="闭包经典使用场景"><a href="#闭包经典使用场景" class="headerlink" title="闭包经典使用场景"></a>闭包经典使用场景</h3><ul>
<li><ol>
<li><code>return</code> 回一个函数</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> n =<span class="hljs-number">20</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>       n++;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>     &#125;<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">x</span>() <span class="hljs-comment">// 21</span><br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的 return <code>f</code>, <code>f()</code>就是一个闭包，存在上级作用域的引用。</p>
</blockquote>
<ul>
<li><ol start="2">
<li>函数作为参数</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;foo&#x27;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fo<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">p</span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;f&#x27;</span><br>    <span class="hljs-title function_">p</span>()<br>&#125;<br><span class="hljs-title function_">f</span>(<span class="hljs-title function_">foo</span>())<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   foo</span><br><span class="hljs-comment">/ </span><br><span class="hljs-comment">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用 return <code>fo</code> 返回回来，<code>fo()</code> 就是闭包，<code>f(foo())</code> 执行的参数就是函数 <code>fo</code>，因为 <code>fo() 中的 a</code> 的上级作用域就是函数<code>foo()</code>，所以输出就是<code>foo</code></p>
</blockquote>
<ul>
<li><ol start="3">
<li>IIFE（自执行函数）</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-string">&#x27;林一一&#x27;</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">p</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>&#125;)()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   林一一</span><br><span class="hljs-comment">/ </span><br><span class="hljs-comment">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>同样也是产生了闭包<code>p()</code>，存在 <code>window</code>下的引用 <code>n</code>。</p>
</blockquote>
<ul>
<li><ol start="4">
<li>循环赋值</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;, <span class="hljs-number">1000</span>) <br>  &#125;)(i)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 <code>i++</code> 到 10时，异步代码才开始执行此时的 <code>i=10</code> 输出的都是 10。</p>
</blockquote>
<ul>
<li><ol start="5">
<li>使用回调函数就是在使用闭包</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeHandler</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>);<br>&#125;, <span class="hljs-number">100</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><ol start="6">
<li>节流防抖</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...arg</span>) &#123;<br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-keyword">return</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, timeout)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, timeout</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>        &#125;, timeout)<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li><ol start="7">
<li>柯里化实现</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, len = fn.length</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_curry</span>(fn, len)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry</span>(<span class="hljs-params">fn, len, ...arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...params</span>) &#123;<br>        <span class="hljs-keyword">let</span> _arg = [...arg, ...params]<br>        <span class="hljs-keyword">if</span> (_arg.<span class="hljs-property">length</span> &gt;= len) &#123;<br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, _arg)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, len, ..._arg)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b + c + d + e)<br>&#125;)<br><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 15</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="使用闭包需要注意什么"><a href="#使用闭包需要注意什么" class="headerlink" title="使用闭包需要注意什么"></a>使用闭包需要注意什么</h3><blockquote>
<p>容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。</p>
</blockquote>
<h4 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h4><ul>
<li>performance 面板 和 memory 面板可以找到泄露的现象和位置</li>
</ul>
<p>详细可以查看：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904048961781774#comment">js 内存泄漏场景、如何监控以及分析</a></p>
<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><ul>
<li>for 循环和闭包(号称必刷题)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">/</span><br><span class="hljs-comment">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>i</code> 是全局下的 <code>i</code>，共用一个作用域，当函数被执行的时候这时的 <code>i=3</code>，导致输出的结构都是3。</p>
</blockquote>
<ul>
<li>使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>      <span class="hljs-built_in">setTimeout</span>( data[j] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;)(i)<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>写法2：使用 <code>let</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>let</code> 具有块级作用域，形成的3个私有作用域都是互不干扰的。</p>
</blockquote>
<h3 id="思考题和上面有何不同-字节"><a href="#思考题和上面有何不同-字节" class="headerlink" title="思考题和上面有何不同 (字节)"></a>思考题和上面有何不同 (字节)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        result[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            total += i * a;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br>result[<span class="hljs-number">0</span>]();  <span class="hljs-comment">// 3</span><br>result[<span class="hljs-number">1</span>]();  <span class="hljs-comment">// 6</span><br>result[<span class="hljs-number">2</span>]();  <span class="hljs-comment">// 9</span><br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tip：这里也形成了闭包。total 被外层引用没有被销毁。</p>
</blockquote>
<p>1、简述什么是闭包，闭包的作用是什么？写出一个简单的闭包例子。</p>
<p>2、闭包会造成内存泄漏吗？</p>
<blockquote>
<p>会，因为使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制回收，多度使用闭包会过度占用内存，造成内存泄漏。</p>
</blockquote>
<p>3、for循环和闭包(必刷题)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<span class="hljs-comment">//3</span><br>data[<span class="hljs-number">1</span>]();<span class="hljs-comment">//3</span><br>data[<span class="hljs-number">2</span>]();<span class="hljs-comment">//3</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码的变量i属于一个全局变量，公用一个作用域，所有输出是3个3； 使用闭包改善上边的写法达到预期的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(data[j] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;,<span class="hljs-number">0</span>)<br>  &#125;)(i)<br>&#125;<br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br>复制代码<br></code></pre></td></tr></table></figure>

<p>4、请写出以下代码的输出结果：</p>
<p>第一题4-1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    n++<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-title function_">f2</span>();<br>  <span class="hljs-keyword">return</span> f2<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<span class="hljs-comment">//21</span><br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//22</span><br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//23</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<span class="hljs-comment">//10</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第二题4-2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">x</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>)&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> add5 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> add10 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">10</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add5</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">//7</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add10</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">//12</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第三题4-3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>)&#123;<br>     privateCounter += val;<br>   &#125;<br>   <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">increment</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">decrement</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">value</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> privateCounter;<br>      &#125;<br>   &#125;<br> &#125;)();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第四题4-4：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> makeCounter = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>) &#123;<br>    privateCounter += val;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>    &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>    &#125;,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> privateCounter;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter1</span> = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter2</span> = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter2</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>

<p>Counter1和Counter2是两个独立的闭包，一个闭包变量的值改变不会影响到另一个闭包的变量。</p>
<p>第五题4-5：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">//10 10 10 10 10 10 10 10 10 10每隔1秒输出10，一共10个10</span><br></code></pre></td></tr></table></figure>

<p>因为setTimeout是异步的，for循环是同步的，同步代码执行完，i已经是10了，异步代码才开始执行，所以i最后打印的是10。</p>
<p>如果将var换成let，打印的结果也不一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<span class="hljs-comment">//1,2,3,4,5,6,7,8,9,10</span><br></code></pre></td></tr></table></figure>

<p>在for循环中使用var,那i就是一个全局变量，循环结束之后i的值为10。</p>
<h2 id="8-diff"><a href="#8-diff" class="headerlink" title="8 diff"></a>8 diff</h2><blockquote>
<p>diff算法：对于update的组件，他会将当前组件与该组件在上次更新是对应的Fiber节点比较，将比较的结果生成新的Fiber节点。</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">! 为了防止概念混淆，强调</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>一个DOM节点，在某一时刻最多会有4个节点和他相关。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">- <span class="hljs-number">1.</span>current <span class="hljs-title class_">Fiber</span>。如果该<span class="hljs-variable constant_">DOM</span>节点已在页面中，current <span class="hljs-title class_">Fiber</span>代表该<span class="hljs-variable constant_">DOM</span>节点对应的<span class="hljs-title class_">Fiber</span>节点。<br>- <span class="hljs-number">2.</span>workInProgress <span class="hljs-title class_">Fiber</span>。如果该<span class="hljs-variable constant_">DOM</span>节点将在本次更新中渲染到页面中，workInProgress <span class="hljs-title class_">Fiber</span>代表该<span class="hljs-variable constant_">DOM</span>节点对应的<span class="hljs-title class_">Fiber</span>节点。<br>- <span class="hljs-number">3.</span><span class="hljs-variable constant_">DOM</span>节点本身。<br>- <span class="hljs-number">4.</span><span class="hljs-variable constant_">JSX</span>对象。即<span class="hljs-title class_">ClassComponent</span>的render方法的返回结果，或者<span class="hljs-title class_">FunctionComponent</span>的调用结果，<span class="hljs-variable constant_">JSX</span>对象中包含描述<span class="hljs-variable constant_">DOM</span>节点信息。<br>复制代码<br>diff算法的本质上是对比<span class="hljs-number">1</span>和<span class="hljs-number">4</span>，生成<span class="hljs-number">2</span>。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="Diff的瓶颈以及React如何应对"><a href="#Diff的瓶颈以及React如何应对" class="headerlink" title="Diff的瓶颈以及React如何应对"></a>Diff的瓶颈以及React如何应对</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">由于diff操作本身也会带来性能损耗，<span class="hljs-title class_">React</span>文档中提到，即使在最前沿的算法中<br>将前后两棵树完全比对的算法的复杂程度为 <span class="hljs-title function_">O</span>(n <span class="hljs-number">3</span> )，其中 n 是树中元素的数量。<br><br>如果在<span class="hljs-title class_">React</span>中使用了该算法，那么展示<span class="hljs-number">1000</span>个元素所需要执行的计算量将在十亿的量级范围。<br>这个开销实在是太过高昂。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="所以为了降低算法复杂度，React的diff会预设3个限制："><a href="#所以为了降低算法复杂度，React的diff会预设3个限制：" class="headerlink" title="所以为了降低算法复杂度，React的diff会预设3个限制："></a>所以为了降低算法复杂度，React的diff会预设3个限制：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-number">1</span>.同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。<br> <span class="hljs-number">2</span>.不同类型的元素会产生出不同的树。如果元素由<span class="hljs-selector-tag">div</span>变为<span class="hljs-selector-tag">p</span>，React会销毁<span class="hljs-selector-tag">div</span>及其子孙节点，并新建<span class="hljs-selector-tag">p</span>及其子孙节点。<br> <span class="hljs-number">3</span>.者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="那么我们接下来看一下Diff是如何实现的"><a href="#那么我们接下来看一下Diff是如何实现的" class="headerlink" title="那么我们接下来看一下Diff是如何实现的"></a>那么我们接下来看一下Diff是如何实现的</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d640e75281b64f8695c89d5882ac2c50~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="我们可以从同级的节点数量将Diff分为两类："><a href="#我们可以从同级的节点数量将Diff分为两类：" class="headerlink" title="我们可以从同级的节点数量将Diff分为两类："></a>我们可以从同级的节点数量将Diff分为两类：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-number">1.</span>当newChild类型为<span class="hljs-built_in">object</span>、<span class="hljs-built_in">number</span>、<span class="hljs-built_in">string</span>，代表同级只有一个节点<br>- <span class="hljs-number">2.</span>当newChild类型为<span class="hljs-title class_">Array</span>，同级有多个节点<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>单节点diff</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">以类型<span class="hljs-selector-tag">Object</span>为例，会进入这个函数reconcileSingleElement<br>复制代码<br></code></pre></td></tr></table></figure>

<p>参考 <a href="https://link.juejin.cn/?target=https://thoughts.teambition.com/share/638dda0502499a004515dc65">前端进阶面试题详细解答</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef216f1c4ed04a399f93b07638ee16d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这个函数会做如下事情：<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63f964815cd542eebaf613c194f198bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">让我们看看第二步判断DOM节点是否可以复用是如何实现的。<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/125009f3e191483ab5b5288c51d9559d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从代码可以看出，React通过先判断key是否相同，如果key相同则判断type是否相同，只有都相同时一个DOM节点才能复用。</p>
<p>这里有个细节需要关注下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><span class="hljs-string">.当child</span> <span class="hljs-type">!==</span> <span class="hljs-literal">null</span><span class="hljs-string">且key相同且type不同时执行deleteRemainingChildren将child及其兄弟fiber都标记删除。</span><br><br><span class="hljs-number">2</span><span class="hljs-string">.当child</span> <span class="hljs-type">!==</span> <span class="hljs-literal">null</span><span class="hljs-string">且key不同时仅将child标记删除。</span><br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>例子：当前页面有3个li，我们要全部删除，再插入一个p。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a985d0ba5b4b435cacc4ab9b2624c67f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>由于本次更新时只有一个p，属于单一节点的Diff，会走上面介绍的代码逻辑。</p>
<blockquote>
<p>解释：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">在reconcileSingleElement中遍历之前的<span class="hljs-number">3</span>个fiber（对应的DOM为<span class="hljs-number">3</span>个<span class="hljs-selector-tag">li</span>），寻找本次更新的<span class="hljs-selector-tag">p</span>是否可以复用之前的<span class="hljs-number">3</span>个fiber中某个的DOM。<br><br>当key相同且type不同时，代表我们已经找到本次更新的<span class="hljs-selector-tag">p</span>对应的上次的fiber，但是 <span class="hljs-selector-tag">p</span> 与 <span class="hljs-selector-tag">li</span> 的type不同，不能复用。<br>既然唯一的可能性已经不能复用，则剩下的fiber都没有机会了，所以都需要标记删除。<br><br>当key不同时只代表遍历到的该fiber不能被<span class="hljs-selector-tag">p</span>复用，后面还有兄弟fiber还没有遍历到。所以仅仅标记该fiber删除。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>练习题：</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d63fbcd0419e4830b5beb25a576ee240~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript">习题<span class="hljs-number">1</span>: 未设置key prop默认 key = <span class="hljs-literal">null</span>;，所以更新前后key相同，都为<span class="hljs-literal">null</span>，但是更新前<span class="hljs-keyword">type</span>为div，更新后为p，<span class="hljs-keyword">type</span>改变则不能复用。<br><br>习题<span class="hljs-number">2</span>: 更新前后key改变，不需要再判断<span class="hljs-keyword">type</span>，不能复用。<br><br>习题<span class="hljs-number">3</span>: 更新前后key没变，但是<span class="hljs-keyword">type</span>改变，不能复用。<br><br>习题<span class="hljs-number">4</span>: 更新前后key与<span class="hljs-keyword">type</span>都未改变，可以复用。children变化，<span class="hljs-variable constant_">DOM</span>的子元素需要更新。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>多节点diff</p>
</blockquote>
<p>同级多个节点的Diff，一定属于下面3中情况的一种或多种。</p>
<ul>
<li>情况1：节点更新</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b64fd4dd9c9448cd82302fa8f54a55d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>情况2：节点新增或减少</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e1977f0b6b44900a1f7164a0b28f344~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>情况3：节点位置变化</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a0fa6ded7254be79e6bb7e401510a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe">注意在这里diff算法无法使用双指针优化<br>在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。<br>复制代码<br>虽然本次更新的JSX对象 <span class="hljs-keyword">new</span><span class="hljs-type">Children</span>为数组形式，但是和<span class="hljs-keyword">new</span><span class="hljs-type">Children</span>中每个组件进行比较的是current fiber<br>同级的Fiber节点是由sibling指针链接形成的单链表。<br><br>即 <span class="hljs-keyword">new</span><span class="hljs-type">Children</span>[<span class="hljs-number">0</span>]与fiber比较，<span class="hljs-keyword">new</span><span class="hljs-type">Children</span>[<span class="hljs-number">1</span>]与fiber.sibling比较。<br>复制代码<br>所以无法使用双指针优化。<br>复制代码<br></code></pre></td></tr></table></figure>

<p>基于以上原因，Diff算法的整体逻辑会经历两轮遍历：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.第一轮遍历：处理更新的节点。<br>2.第二轮遍历：处理剩下的不属于更新的节点<br>复制代码<br></code></pre></td></tr></table></figure>

<p>第一轮遍历：</p>
<p>第一轮遍历步骤如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">let <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>，遍历newChildren，将newChildren<span class="hljs-selector-attr">[i]</span>与oldFiber比较，判断DOM节点是否可复用。<br><br>如果可复用，<span class="hljs-selector-tag">i</span>++，继续比较newChildren<span class="hljs-selector-attr">[i]</span>与oldFiber<span class="hljs-selector-class">.sibling</span>，可以复用则继续遍历。<br><br>如果不可复用，立即跳出整个遍历，第一轮遍历结束。<br><br>如果newChildren遍历完（即<span class="hljs-selector-tag">i</span> === newChildren<span class="hljs-selector-class">.length</span> - <span class="hljs-number">1</span>）或者oldFiber遍历完（即oldFiber<span class="hljs-selector-class">.sibling</span> === null）<br>跳出遍历，第一轮遍历结束。<br><br>上面<span class="hljs-number">3</span>跳出的遍历<br><br>此时newChildren没有遍历完，oldFiber也没有遍历完。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">前<span class="hljs-number">2</span>个节点可复用，遍历到key === <span class="hljs-number">2</span>的节点发现type改变，不可复用，跳出遍历。<br><br>此时oldFiber剩下key === <span class="hljs-number">2</span>未遍历，newChildren剩下key === <span class="hljs-number">2</span>、key === <span class="hljs-number">3</span>未遍历。<br><br>上面<span class="hljs-number">4</span>跳出的遍历<br><br>可能newChildren遍历完，或oldFiber遍历完，或他们同时遍历完。<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上例子：</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ad899f9e68492eab0192e2cce3a079~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>带着第一轮遍历的结果，我们开始第二轮遍历。</p>
<p>第一轮遍历：（4种情况）</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- 1.newChildren与oldFiber同时遍历完 </span><br><br>那就是最理想的情况：只有组件更新。此时Diff结束。<br>复制代码<br><span class="hljs-deletion">- 2.newChildren没遍历完，oldFiber遍历完</span><br><br>已有的DOM节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入<br>我们只需要遍历剩下的newChildren为生成的workInProgress fiber依次标记Placement。<br>复制代码<br><span class="hljs-deletion">- 3.newChildren遍历完，oldFiber没遍历完</span><br><br>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的oldFiber，依次标记Deletion。<br>复制代码<br><span class="hljs-deletion">- 4.newChildren与oldFiber都没遍历完</span><br><br>这意味着有节点在这次更新中改变了位置。<br><br>改变了位置就需要我们处理移动的节点<br><br>由于有节点改变了位置，所以不能再用位置索引i对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？<br>我们需要使用key。<br><br>为了快速的找到key对应的oldFiber，我们将所有还未处理的oldFiber存入以key为key，oldFiber为value的Map中。<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ee1f48567714489a78fc9551e4f2c2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">接下来遍历剩余的newChildren，通过newChildren[i].<span class="hljs-keyword">key</span>就能在existingChildren中找到<span class="hljs-keyword">key</span>相同的oldFiber<br><br>标记节点是否移动<br>复制代码<br>!既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？<br>我们的参照物是：最后一个可复用的节点在oldFiber中的位置索引（用变量lastPlacedIndex表示）。<br>复制代码<br>由于本次更新中节点是按newChildren的顺序排列。<br>在遍历newChildren过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个<br>即一定在lastPlacedIndex对应的可复用的节点在本次更新中位置的后面。<br><br>那么我们只需要比较遍历到的可复用节点在上次更新时是否也在lastPlacedIndex对应的oldFiber后面<br>就能知道两次更新中这两个节点的相对位置改变没有。<br><br>我们用变量oldIndex表示遍历到的可复用节点在oldFiber中的位置索引。<br><br>如果oldIndex &lt; lastPlacedIndex，代表本次更新该节点需要向右移动。<br><br>lastPlacedIndex初始为<span class="hljs-number">0</span>，每遍历一个可复用的节点，如果oldFiber &gt;= lastPlacedIndex，则lastPlacedIndex = oldFiber。<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="下面通过两个demo来看一下react团队的diff算法精髓"><a href="#下面通过两个demo来看一下react团队的diff算法精髓" class="headerlink" title="下面通过两个demo来看一下react团队的diff算法精髓"></a>下面通过两个demo来看一下react团队的diff算法精髓</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 之前 abcd` `<span class="hljs-regexp">//</span> 之后 acdb<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>（之后）vs <span class="hljs-selector-tag">a</span>（之前）  <br><br>key不变，可复用<br><br>此时 <span class="hljs-selector-tag">a</span> 对应的oldFiber（之前的<span class="hljs-selector-tag">a</span>）在之前的数组（abcd）中索引为<span class="hljs-number">0</span><br><br>所以 lastPlacedIndex = <span class="hljs-number">0</span>;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续第一轮遍历…</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">c（之后）vs b（之前）  <br><br>key改变，不能复用，跳出第一轮遍历<br><br>此时 lastPlacedIndex === <span class="hljs-number">0</span>;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">newChildren === cdb，没用完，不需要执行删除旧节点<br><br>oldFiber === bcd，没用完，不需要执行插入新节点<br><br>将剩余oldFiber（bcd）保存为map<br>复制代码<br><span class="hljs-comment">// 当前oldFiber：bcd</span><br><span class="hljs-comment">// 当前newChildren：cdb</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">key === c 在 oldFiber中存在<br><br><span class="hljs-keyword">const</span> oldIndex = c（之前）.<span class="hljs-property">index</span>;<br><br>此时 oldIndex === <span class="hljs-number">2</span>;  <span class="hljs-comment">// 之前节点为 abcd，所以c.index === 2</span><br><br>比较 oldIndex 与 lastPlacedIndex;<br><br>如果 oldIndex &gt;= lastPlacedIndex 代表该可复用节点不需要移动<br><br>并将 lastPlacedIndex = oldIndex;<br><br>如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动<br><br>在例子中，oldIndex <span class="hljs-number">2</span> &gt; lastPlacedIndex <span class="hljs-number">0</span>，<br><br>则 lastPlacedIndex = <span class="hljs-number">2</span>;<br><br>c节点位置不变<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：bd<br>// 当前newChildren：db<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> d 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> d（之前）.index<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">3</span> &gt; lastPlacedIndex <span class="hljs-number">2</span> // 之前节点为 abcd，所以d.index <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><br>则 lastPlacedIndex <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br><br>d节点位置不变<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：b<br>// 当前newChildren：b<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> b 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> b（之前）.index<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">1</span> &lt; lastPlacedIndex <span class="hljs-number">3</span> // 之前节点为 abcd，所以b.index <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><br>则 b节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">!最终acd <span class="hljs-number">3</span>个节点都没有移动，<span class="hljs-selector-tag">b</span>节点被标记为移动<br></code></pre></td></tr></table></figure>

<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 之前 abcd<br><span class="hljs-regexp">//</span> 之后 dabc<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">d（之后）vs <span class="hljs-selector-tag">a</span>（之前）  <br>key改变，不能复用，跳出遍历<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第一轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历开始&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">newChildren === dabc，没用完，不需要执行删除旧节点<br><br>oldFiber === abcd，没用完，不需要执行插入新节点<br><br>将剩余oldFiber（abcd）保存为map<br><br>继续遍历剩余newChildren<br>复制代码<br><span class="hljs-comment">// 当前oldFiber：abcd</span><br><span class="hljs-comment">// 当前newChildren dabc</span><br>key === d 在 oldFiber中存在<br><br><span class="hljs-keyword">const</span> oldIndex = d（之前）.<span class="hljs-property">index</span>;<br><br>此时 oldIndex === <span class="hljs-number">3</span>; <span class="hljs-comment">// 之前节点为 abcd，所以d.index === 3</span><br><br>比较 oldIndex 与 lastPlacedIndex;<br><br>oldIndex <span class="hljs-number">3</span> &gt; lastPlacedIndex <span class="hljs-number">0</span><br><br>则 lastPlacedIndex = <span class="hljs-number">3</span>;<br><br>d节点位置不变<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：abc<br>// 当前newChildren abc<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> a 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> a（之前）.index<span class="hljs-comment">; // 之前节点为 abcd，所以a.index === 0</span><br><br>此时 oldIndex <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><br>比较 oldIndex 与 lastPlacedIndex<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">0</span> &lt; lastPlacedIndex <span class="hljs-number">3</span><br><br>则 a节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：bc<br>// 当前newChildren bc<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> b 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> b（之前）.index<span class="hljs-comment">; // 之前节点为 abcd，所以b.index === 1</span><br><br>此时 oldIndex <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><br>比较 oldIndex 与 lastPlacedIndex<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">1</span> &lt; lastPlacedIndex <span class="hljs-number">3</span><br><br>则 b节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继续遍历剩余newChildren</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 当前oldFiber：c<br>// 当前newChildren c<br><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> c 在 oldFiber中存在<br><br>const oldIndex <span class="hljs-operator">=</span> c（之前）.index<span class="hljs-comment">; // 之前节点为 abcd，所以c.index === 2</span><br><br>此时 oldIndex <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br><br>比较 oldIndex 与 lastPlacedIndex<span class="hljs-comment">;</span><br><br>oldIndex <span class="hljs-number">2</span> &lt; lastPlacedIndex <span class="hljs-number">3</span><br><br>则 c节点需要向右移动<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;&#x3D;第二轮遍历结束&#x3D;&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">!可以看到，我们以为从 abcd 变为 dabc，只需要将d移动到前面。` `!但实际上React保持d不变，将abc分别移动到了d的后面。<br></code></pre></td></tr></table></figure>

<blockquote>
<p>用张老生常谈的图</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6d65e26b2a4b24be86f06a873852f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h2 id="9-继承"><a href="#9-继承" class="headerlink" title="9 继承"></a>9 继承</h2><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<p>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>(); <br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>()); <span class="hljs-comment">// true</span><br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></a></p>
<p>img</p>
<p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span></span>()&#123;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span></span>()&#123;&#125;<br><br>SubType.prototype = <span class="hljs-keyword">new</span> <span class="hljs-type">SuperType</span>();<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-type">SubType</span>();<br>instance1.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br>alert(instance1.colors); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-type">SubType</span>(); <br>alert(instance2.colors); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<h3 id="2、借用构造函数继承"><a href="#2、借用构造函数继承" class="headerlink" title="2、借用构造函数继承"></a>2、借用构造函数继承</h3><p>使用父类的构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类（不使用原型）</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">SuperType</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">this</span>.color=[<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>];<br>&#125;<br><span class="hljs-keyword">function</span>  <span class="hljs-title function_">SubType</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//继承自SuperType</span><br>    SuperType.call(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> SubType();<br>instance1.color.push(<span class="hljs-string">&quot;black&quot;</span>);<br>alert(instance1.color);<span class="hljs-comment">//&quot;red,green,blue,black&quot;</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> SubType();<br>alert(instance2.color);<span class="hljs-comment">//&quot;red,green,blue&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将SuperType中的属性复制一份。</p>
<p>缺点：</p>
<ul>
<li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性&#x2F;方法</li>
<li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<h3 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-comment">// 继承属性</span><br>  <span class="hljs-comment">// 第二次调用SuperType()</span><br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-comment">// 构建原型链</span><br><span class="hljs-comment">// 第一次调用SuperType()</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>(); <br><span class="hljs-comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">SubType</span>; <br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-title function_">alert</span>(instance1.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br>instance1.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">//&quot;Nicholas&quot;;</span><br>instance1.<span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">//29</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-title function_">alert</span>(instance2.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green&quot;</span><br>instance2.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">//&quot;Greg&quot;;</span><br>instance2.<span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">//27</span><br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c010c537ff8~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c010c537ff8~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></a></p>
<p>img</p>
<p>缺点：</p>
<ul>
<li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性name，color。</li>
<li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性name，color。</li>
</ul>
<p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性&#x2F;方法。</p>
<h3 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h3><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(obj)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title">F</span>()&#123;&#125;<br>  F.prototype = obj;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">new</span> F();<br>&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>object()对传入其中的对象执行了一次<code>浅复制</code>，将构造函数F的原型直接指向传入的对象。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-keyword">var</span> anotherPerson = object(person);<br>anotherPerson.name = <span class="hljs-string">&quot;Greg&quot;</span>;<br>anotherPerson.friends.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;Rob&quot;</span>);<br><br><span class="hljs-keyword">var</span> yetAnotherPerson = object(person);<br>yetAnotherPerson.name = <span class="hljs-string">&quot;Linda&quot;</span>;<br>yetAnotherPerson.friends.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;Barbie&quot;</span>);<br><br>alert(person.friends);   <span class="hljs-comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<p>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。</p>
<h3 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h3><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">clone</span> = <span class="hljs-keyword">object</span>(original); <span class="hljs-comment">// 通过调用 object() 函数创建一个新对象</span><br>  <span class="hljs-keyword">clone</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// 以某种方式来增强对象</span><br>    <span class="hljs-title function_ invoke__">alert</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">clone</span>; <span class="hljs-comment">// 返回这个对象</span><br>&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> person = &#123;<br>  <span class="hljs-built_in">na</span><span class="hljs-symbol">me:</span> <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>  frien<span class="hljs-symbol">ds:</span> [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><span class="hljs-built_in">var</span> anotherPerson = createAnother(person);<br>anotherPerson.sayHi(); //<span class="hljs-string">&quot;hi&quot;</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>缺点（同原型式继承）：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<h3 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h3><p>结合借用构造函数传递参数和寄生模式实现继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>)&#123;<br>  <span class="hljs-keyword">var</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span><br>  prototype.<span class="hljs-property">constructor</span> = subType;                    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br>  subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;                      <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span><br>&#125;<br><br><span class="hljs-comment">// 父类初始化实例属性和原型属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 将父类原型指向子类</span><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>, <span class="hljs-title class_">SuperType</span>);<br><br><span class="hljs-comment">// 新增子类原型属性</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;xyc&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;lxy&quot;</span>, <span class="hljs-number">23</span>);<br><br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span><br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span><br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></a></p>
<p>img</p>
<p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p>
<p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p>
<h3 id="7、混入方式继承多个对象"><a href="#7、混入方式继承多个对象" class="headerlink" title="7、混入方式继承多个对象"></a>7、混入方式继承多个对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyClass</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title class_">SuperClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>     <span class="hljs-title class_">OtherSuperClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继承一个类</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">SuperClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 混合其它</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">OtherSuperClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 重新指定constructor</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">MyClass</span>;<br><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">// do something</span><br>&#125;;<br>复制代码<br><br><span class="hljs-variable constant_">JS</span><br></code></pre></td></tr></table></figure>

<p><code>Object.assign</code>会把 <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>
<h3 id="8、ES6类继承extends"><a href="#8、ES6类继承extends" class="headerlink" title="8、ES6类继承extends"></a>8、ES6类继承extends</h3><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-comment">// constructor</span><br>    <span class="hljs-keyword">constructor</span>(height, width) &#123;<br>        <span class="hljs-keyword">this</span>.height = height;<br>        <span class="hljs-keyword">this</span>.width = width;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Getter</span><br>    <span class="hljs-keyword">get</span> area() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calcArea()<br>    &#125;<br>    <br>    <span class="hljs-comment">// Method</span><br>    calcArea() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> rectangle = new Rectangle(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>console.log(rectangle.area);<br><span class="hljs-comment">// 输出 200</span><br><br>-----------------------------------------------------------------<br><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-title">extends</span> <span class="hljs-title">Rectangle</span> &#123;<br><br>  <span class="hljs-keyword">constructor</span>(length) &#123;<br>    <span class="hljs-keyword">super</span>(length, length);<br>    <br>    <span class="hljs-comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;Square&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> area() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> square = new Square(<span class="hljs-number">10</span>);<br>console.log(square.area);<br><span class="hljs-comment">// 输出 100</span><br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_inherits(<span class="hljs-params">subType</span>, <span class="hljs-params">superType</span>)</span> &#123;<br>  <br>    <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span><br>    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br>    <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span><br>    subType.prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(superType<span class="hljs-operator"> &amp;&amp; </span>superType.prototype, &#123;<br>        constructor: &#123;<br>            value: subType,<br>            enumerable: <span class="hljs-literal">false</span>,<br>            writable: <span class="hljs-literal">true</span>,<br>            configurable: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">if</span> (superType) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>setPrototypeOf <br>            ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">subType</span>, <span class="hljs-params">superType</span>)</span> <br>            : subType.__proto__ = superType;<br>    &#125;<br>&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、函数声明和类声明的区别</p>
<p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let p = <span class="hljs-keyword">new</span> <span class="hljs-type">Rectangle</span>(); <br><span class="hljs-comment">// ReferenceError</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;&#125;<br>复制代码<br><br>JS<br></code></pre></td></tr></table></figure>

<p>2、ES5继承和ES6继承的区别</p>
<ul>
<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li>
<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>
</ul>
<h2 id="10-实用的BOM属性对象方法"><a href="#10-实用的BOM属性对象方法" class="headerlink" title="10 实用的BOM属性对象方法"></a>10 实用的BOM属性对象方法</h2><p>什么是Bom?Bom是浏览器对象。有哪些常用的Bom属性呢？ </p>
<h3 id="1-location对象"><a href="#1-location对象" class="headerlink" title="(1)location对象"></a>(1)location对象</h3><p>location.href–返回或设置当前文档的URL </p>
<p>location.search – 返回 URL 中的查询字符串部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu">http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu</a> 返回包括(?)后面的 内容 ?id&#x3D;5&amp;name&#x3D;dreamdu location.hash – 返回 URL#后面的内容，如果没有#，返回空 </p>
<p>location.host – 返回 URL 中的域名部分，例如<a target="_blank" rel="noopener" href="http://www.dreamdu.com/">www.dreamdu.com</a> </p>
<p>location.hostname – 返回 URL 中的主域名部分，例如 dreamdu.com </p>
<p>location.pathname – 返回 URL 的域名后的部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com/xhtml/">http://www.dreamdu.com/xhtml/</a> 返回&#x2F;xhtml&#x2F; </p>
<p>location.port – 返回 URL 中的端口部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com:8080/xhtml/">http://www.dreamdu.com:8080/xhtml/</a> </p>
<p>location.protocol – 返回 URL 中的协议部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com:8080/xhtml/">http://www.dreamdu.com:8080/xhtml/</a> 返回(&#x2F;&#x2F;)前面的内容 http: location.assign –设置当前文档的 URL </p>
<p>location.replace()– 设置当前文档的 URL，并且在 history 对象的地址列表中移除 这个 URL location.replace(url); location.reload() – 重载当前页面</p>
<h3 id="2-history对象"><a href="#2-history对象" class="headerlink" title="(2)history对象"></a>(2)history对象</h3><p>history.go() – 前进或后退指定的页面数 history.go(num); </p>
<p>history.back() – 后退一页 </p>
<p>history.forward() – 前进一页 </p>
<h3 id="3-Navigator对象"><a href="#3-Navigator对象" class="headerlink" title="(3)Navigator对象"></a>(3)Navigator对象</h3><p>navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) </p>
<p>navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie</p>
<h2 id="11-HTML5-drag-api"><a href="#11-HTML5-drag-api" class="headerlink" title="11 HTML5 drag api"></a>11 HTML5 drag api</h2><p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 </p>
<p>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 </p>
<p>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</p>
<p>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 </p>
<p>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 </p>
<p>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 </p>
<p>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</p>
<p><strong>接下来我们看一个简单的例子：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc0b0b0bd1b4dfab7db7fcb7dca12ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="DnD-1.gif"></p>
<p>代码地址：<a href="https://link.juejin.cn/?target=https://codepen.io/wuzhengyan2015/pen/abwxVEV">codepen.io&#x2F;wuzhengyan2…</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drop-area&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drag-el&quot;</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>window.onload = () =&gt; &#123;<br>  const dragEl = document.querySelector(&#x27;#drag-el&#x27;)<br>  const dropArea = document.querySelector(&#x27;#drop-area&#x27;)<br><br>  dragEl.addEventListener(&#x27;dragstart&#x27;, (event) =&gt; &#123;<br>    event.dataTransfer.setData(&#x27;text/plain&#x27;, event.target.id)<br>  &#125;)<br>  dropArea.addEventListener(&#x27;dragover&#x27;, (event) =&gt; &#123;<br>    event.preventDefault()<br>  &#125;)<br>  dropArea.addEventListener(&#x27;drop&#x27;, (event) =&gt; &#123;<br>    const id = event.dataTransfer.getData(&#x27;text/plain&#x27;)<br>    dropArea.appendChild(document.getElementById(id))<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述例子就一个简单的拖放操作，让我们看下例子中拖放的三个重要点都是怎么实现的。</p>
<ol>
<li>元素可拖拽：DOM 属性上设置 draggable&#x3D;true</li>
<li>元素可放置：监听 dragover 事件，事件中调用 preventDefault</li>
<li>拖放数据传递；可拖拽元素监听 dragstart 事件，调用 dataTransfer 对象的 setData 方法，可放置元素监听 drop 事件，使用 dataTransfer 对象的 getData 方法获取设置的数据。</li>
</ol>
<p>可以看到，一个拖放操作实现起来还是很简洁的。</p>
<h2 id="12-序列化-x2F-反序列化"><a href="#12-序列化-x2F-反序列化" class="headerlink" title="12 序列化&#x2F;反序列化"></a>12 序列化&#x2F;反序列化</h2><h3 id="序列化：js中的object转化为字符串"><a href="#序列化：js中的object转化为字符串" class="headerlink" title="序列化：js中的object转化为字符串"></a>序列化：js中的object转化为字符串</h3><p>1.使用toJSONString</p>
<p><code>var last=obj.toJSONString(); //将JSON对象转化为JSON字符</code></p>
<p>2.使用stringify</p>
<p><code>var last=JSON.stringify(obj); //将JSON对象转化为JSON字符  </code></p>
<p>3.json转字符串函数</p>
<pre><code class="hljs">    var json = &#123;a:1,b:2,c:3&#125;;
    var arr = [];
    for ( name in json) &#123;
        arr.push(name+&#39;:&#39;+json[name]);
    &#125;
    var str = arr.join(&#39;,&#39;);
    alert(str);
</code></pre>
<h3 id="反序列化：json字符串转化为object"><a href="#反序列化：json字符串转化为object" class="headerlink" title="反序列化：json字符串转化为object"></a>反序列化：json字符串转化为object</h3><p>1.eval</p>
<p><code>var obj=eval(&quot;(&quot;+data+&quot;)&quot;);  </code></p>
<p>2.使用parseJSON</p>
<p><code>var obj = data.parseJSON(); //由JSON字符串转换为JSON对象  </code></p>
<p>3.使用parse</p>
<p><code>var obj = JSON.parse(data); //由JSON字符串转换为JSON对象 </code></p>
<p>4.使用封装函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convertCartStrToObj</span>(<span class="hljs-params">cartStr</span>)&#123;        <br>         <span class="hljs-keyword">var</span> obj =&#123;&#125;;<br>        <span class="hljs-comment">//将字符串name:17dian,key:123456,tel:18810701077 按“,”拆分成数组[&quot;name:17dian&quot;, &quot;key:123456&quot;, &quot;tel:18810701077&quot;]</span><br>         <span class="hljs-keyword">var</span> arrVal = cartStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);  <br>         <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arrVal.<span class="hljs-property">length</span> ;i++)&#123;<br>                  data = arrVal[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>); <span class="hljs-comment">// 在将每一项拆分 例如arrVal[0]时 data =[&quot;name&quot;, &quot;17dian&quot;]</span><br>                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>                  obj[data[<span class="hljs-number">0</span>]] = data[<span class="hljs-number">1</span>]; <span class="hljs-comment">//给对象添加属性</span><br>         &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-web-worker"><a href="#13-web-worker" class="headerlink" title="13 web worker"></a>13 web worker</h2><p>Web Worker (工作线程) 是 HTML5 中提出的概念，分为两种类型，专用线程（Dedicated Web Worker） 和共享线程（Shared Web Worker）。专用线程仅能被创建它的脚本所使用（一个专用线程对应一个主线程），而共享线程能够在不同的脚本中使用（一个共享线程对应多个主线程）。</p>
<p>专用线程可以看做是默认情况的 Web Worker，其加上修饰词的目的是为了与共享线程进行区分。本文会较为严格地区分两者，可能较为累赘，但个人认为这是必要的。如果单纯以 <code>Web Worker</code> 字样出现的地方指的是两者都会有的情况。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Web Worker 的意义在于可以将一些耗时的数据处理操作从主线程中剥离，使主线程更加专注于页面渲染和交互。</p>
<ul>
<li>懒加载</li>
<li>文本分析</li>
<li>流媒体数据处理</li>
<li>canvas 图形绘制</li>
<li>图像处理</li>
<li>…</li>
</ul>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ul>
<li>有同源限制</li>
<li>无法访问 DOM 节点</li>
<li>运行在另一个上下文中，无法使用Window对象</li>
<li>Web Worker 的运行不会影响主线程，但与主线程交互时仍受到主线程单线程的瓶颈制约。换言之，如果 Worker 线程频繁与主线程进行交互，主线程由于需要处理交互，仍有可能使页面发生阻塞</li>
<li>共享线程可以被多个浏览上下文（Browsing context）调用，但所有这些浏览上下文必须同源（相同的协议，主机和端口号）</li>
</ul>
<h3 id="浏览器支持度"><a href="#浏览器支持度" class="headerlink" title="浏览器支持度"></a>浏览器支持度</h3><p>根据 CanI Use 网站的统计，目前约有 93.05% 的浏览器支持专用线程。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af51cf353eb148529ba8041ad484e5bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image"></p>
<p>而对于共享线程，则仅有大约 41.66% 的浏览器支持。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d24fb447b7e340e1b186ec890dfdef54~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image"></p>
<p>由于专用线程和共享线程的构造方法都包含在 window 对象中，我们在使用两者之前可以对浏览器的支持性进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">Worker</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>复制代码<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">SharedWorker</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>专用线程由 <code>Worker()</code>方法创建，可以接收两个参数，第一个参数是必填的脚本的位置，第二个参数是可选的配置对象，可以指定 <code>type</code>、<code>credentials</code>、<code>name</code> 三个属性。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>)<br>// var <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>, &#123; name: <span class="hljs-string">&#x27;dedicatedWorker&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>共享线程使用 <code>Shared Worker()</code> 方法创建，同样支持两个参数，用法与 <code>Worker()</code> 一致。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> SharedWorker(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>值得注意的是，因为 Web Worker 有同源限制，所以在本地调试的时候也需要通过启动本地服务器的方式访问，使用 <code>file://</code> 协议直接打开的话将会抛出异常。</p>
<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>Worker 线程和主线程都通过 <code>postMessage()</code> 方法发送消息，通过 <code>onmessage</code> 事件接收消息。在这个过程中数据并不是被共享的，而是被复制的。值得注意的是 <code>Error</code> 和 <code>Function</code> 对象不能被结构化克隆算法复制，如果尝试这么做的话会导致抛出 <code>DATA_CLONE_ERR</code> 的异常。另外，<code>postMessage()</code> 一次只能发送一个对象， 如果需要发送多个参数可以将参数包装为数组或对象再进行传递。</p>
<p>关于 <code>postMessage()</code> 和结构化克隆算法（The structured clone algorithm）将在本文最后进行阐述。</p>
<p>下面是专用线程数据传递的示例。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 主线程</span><br><span class="hljs-selector-tag">var</span> worker = new <span class="hljs-built_in">Worker</span>(&#x27;worker.js&#x27;)<br>worker<span class="hljs-selector-class">.postMessage</span>([<span class="hljs-number">10</span>, <span class="hljs-number">24</span>])<br>worker<span class="hljs-selector-class">.onmessage</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>    console<span class="hljs-selector-class">.log</span>(e.data)<br>&#125;<br><br><span class="hljs-comment">// Worker 线程</span><br>onmessage = function (e) &#123;<br>    if (e.data.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">postMessage</span>(e.data[<span class="hljs-number">1</span>] - e.data[<span class="hljs-number">0</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Worker 线程中，<code>self</code> 和 <code>this</code> 都代表子线程的全局对象。对于监听 <code>message</code> 事件，以下的四种写法是等同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法 1</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 2</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 3</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 4</span><br>onmessage = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>主线程通过 <code>MessagePort</code> 访问专用线程和共享线程。专用线程的 port 会在线程创建时自动设置，并且不会暴露出来。与专用线程不同的是，共享线程在传递消息之前，端口必须处于打开状态。MDN 上的 <code>MessagePort</code> 关于 <code>start()</code> 方法的描述是：</p>
<blockquote>
<p>Starts the sending of messages queued on the port (only needed when using EventTarget.addEventListener; it is implied when using MessagePort.onmessage.)</p>
</blockquote>
<p>这句话经过试验，可以理解为 <code>start()</code> 方法是与 <code>addEventListener</code> 配套使用的。如果我们选择 <code>onmessage</code> 进行事件监听，那么将隐含调用 <code>start()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 业务逻辑</span><br>&#125;<br>复制代码<br><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 业务逻辑</span><br>&#125;, <span class="hljs-literal">false</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">start</span>() <span class="hljs-comment">// 需要显式打开</span><br></code></pre></td></tr></table></figure>

<p>在传递消息时，<code>postMessage()</code> 方法和 <code>onmessage</code> 事件必须通过端口对象调用。另外，在 Worker 线程中，需要使用 <code>onconnect</code> 事件监听端口的变化，并使用端口的消息处理函数进行响应。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 主线程<br>sharedWorker.port.postMessage(<span class="hljs-section">[10, 24]</span>)<br><span class="hljs-attr">sharedWorker.port.onmessage</span> = function (e) &#123;<br>    console.log(e.data)<br>&#125;<br><br>// Worker 线程<br><span class="hljs-attr">onconnect</span> = function (e) &#123;<br>    let <span class="hljs-attr">port</span> = e.ports[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-attr">port.onmessage</span> = function (e) &#123;<br>        if (e.data.length &gt; 1) &#123;<br>            port.postMessage(e.data<span class="hljs-section">[1]</span> - e.data<span class="hljs-section">[0]</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="关闭-Worker"><a href="#关闭-Worker" class="headerlink" title="关闭 Worker"></a>关闭 Worker</h3><p>可以在主线程中使用 <code>terminate()</code> 方法或在 Worker 线程中使用 <code>close()</code> 方法关闭 worker。这两种方法是等效的，但比较推荐的用法是使用 <code>close()</code>，防止意外关闭正在运行的 Worker 线程。Worker 线程一旦关闭 Worker 后 Worker 将不再响应。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 主线程</span><br>worker<span class="hljs-selector-class">.terminate</span>()<br><br><span class="hljs-comment">// Dedicated Worker 线程中</span><br>self<span class="hljs-selector-class">.close</span>()<br><br><span class="hljs-comment">// Shared Worker 线程中</span><br>self<span class="hljs-selector-class">.port</span><span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>可以通过在主线程或 Worker 线程中设置 <code>onerror</code> 和 <code>onmessageerror</code> 的回调函数对错误进行处理。其中，<code>onerror</code> 在 Worker 的 <code>error</code> 事件触发并冒泡时执行，<code>onmessageerror</code> 在 Worker 收到的消息不能进行反序列化时触发(本人经过尝试没有办法触发 <code>onmessageerror</code> 事件，如果在 worker 线程使用 <code>postMessage</code> 方法传递一个 Error 或 Function 对象会因为无法序列化优先被 <code>onerror</code> 方法捕获，而根本不会进入反序列化的过程)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程</span><br>worker.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 主线程使用专用线程</span><br>worker.<span class="hljs-property">onmessageerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 主线程使用共享线程</span><br>worker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessageerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// worker 线程</span><br>onerror = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="加载外部脚本"><a href="#加载外部脚本" class="headerlink" title="加载外部脚本"></a>加载外部脚本</h3><p>Web Worker 提供了 <code>importScripts()</code> 方法，能够将外部脚本文件加载到 Worker 中。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">importScripts</span>(&#x27;script1.js&#x27;)<br><span class="hljs-built_in">importScripts</span>(&#x27;script2.js&#x27;)<br><br><span class="hljs-comment">// 以上写法等价于</span><br><span class="hljs-built_in">importScripts</span>(&#x27;script1.js&#x27;, &#x27;script2.js&#x27;)<br></code></pre></td></tr></table></figure>

<h3 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h3><p>Worker 可以生成子 Worker，但有两点需要注意。</p>
<ul>
<li>子 Worker 必须与父网页同源</li>
<li>子 Worker 中的 URI 相对于父 Worker 所在的位置进行解析</li>
</ul>
<h3 id="嵌入式-Worker"><a href="#嵌入式-Worker" class="headerlink" title="嵌入式 Worker"></a>嵌入式 Worker</h3><p>目前没有一类标签可以使 Worker 的代码像 <code>&lt;script&gt;</code> 元素一样嵌入网页中，但我们可以通过 <code>Blob()</code> 将页面中的 Worker 代码进行解析。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;worker&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;javascript/worker&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 这段代码不会被 JS 引擎直接解析，因为类型是 &#x27;javascript/worker&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 在这里写 Worker 线程的逻辑</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> workerScript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#worker&#x27;</span>).<span class="hljs-property">textContent</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([workerScript], &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/javascript&quot;</span>&#125;)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="关于-postMessage"><a href="#关于-postMessage" class="headerlink" title="关于 postMessage"></a>关于 postMessage</h3><p>Web Worker 中，Worker 线程和主线程之间使用结构化克隆算法（The structured clone algorithm）进行数据通信。结构化克隆算法是一种通过递归输入对象构建克隆的算法，算法通过保存之前访问过的引用的映射，避免无限遍历循环。这一过程可以理解为，在发送方使用类似 <code>JSON.stringfy()</code> 的方法将参数序列化，在接收方采用类似 <code>JSON.parse()</code> 的方法反序列化。</p>
<p>但是，一次数据传输就需要同时经过序列化和反序列化，如果数据量大的话，这个过程本身也可能造成性能问题。因此， Worker 中提出了 <code>Transferable Objects</code> 的概念，当数据量较大时，我们可以选择在将主线程中的数据直接移交给 Worker 线程。值得注意的是，这种转移是彻底的，一旦数据成功转移，主线程将不能访问该数据。这个移交的过程仍然通过 <code>postMessage</code> 进行传递。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">postMessage</span>(message, transferList)<br></code></pre></td></tr></table></figure>

<p>例如，传递一个 ArrayBuffer 对象</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">aBuffer</span> = new ArrayBuffer(<span class="hljs-number">1</span>)<br>worker.postMessage(&#123; data: aBuffer &#125;, <span class="hljs-section">[aBuffer]</span>)<br></code></pre></td></tr></table></figure>

<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>Worker 工作在一个 <code>WorkerGlobalDataScope</code> 的上下文中。每一个 <code>WorkerGlobalDataScope</code> 对象都有不同的 <code>event loop</code>。这个 <code>event loop</code> 没有关联浏览器上下文（browsing context），它的任务队列也只有事件（events）、回调（callbacks）和联网的活动（networking activity）。</p>
<p>每一个 <code>WorkerGlobalDataScope</code> 都有一个 <code>closing</code> 标志，当这个标志设为 <code>true</code> 时，任务队列将丢弃之后试图加入任务队列的任务，队列中已经存在的任务不受影响（除非另有指定）。同时，定时器将停止工作，所有挂起（pending）的后台任务将会被删除。</p>
<h3 id="Worker-中可以使用的函数和类"><a href="#Worker-中可以使用的函数和类" class="headerlink" title="Worker 中可以使用的函数和类"></a>Worker 中可以使用的函数和类</h3><p>由于 Worker 工作的上下文不同于普通的浏览器上下文，因此不能访问 window 以及 window 相关的 API，也不能直接操作 DOM。Worker 中提供了 <code>WorkerNavigator</code> 和 <code>WorkerLocation</code> 接口，它们分别是 window 中 <code>Navigator</code> 和 <code>Location</code> 的子集。除此之外，Worker 还提供了涉及时间、存储、网络、绘图等多个种类的接口，以下列举了其中的一部分，更多的接口可以参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers">MDN 文档</a>。</p>
<h4 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h4><ul>
<li>clearInterval()</li>
<li>clearTimeout()</li>
<li>setInterval()</li>
<li>setTimeout</li>
</ul>
<h4 id="Worker-相关"><a href="#Worker-相关" class="headerlink" title="Worker 相关"></a>Worker 相关</h4><ul>
<li>importScripts()</li>
<li>close()</li>
<li>postMessage()</li>
</ul>
<h4 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h4><ul>
<li>Cache</li>
<li>IndexedDB</li>
</ul>
<h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><ul>
<li>Fetch</li>
<li>WebSocket</li>
<li>XMLHttpRequest</li>
</ul>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">使用 Web Workers - Web APIs | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker">Worker | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort">MessagePort | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://html.spec.whatwg.org/multipage/workers.html">HTML Standard - Web workers</a></li>
<li><a href="https://link.juejin.cn/?target=https://www.html5rocks.com/zh/tutorials/workers/basics/">Web Workers 的基本信息</a></li>
</ul>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://fed.taobao.org/blog/taofed/do71ct/canvas-performance">Canvas 最佳实践 - 淘宝FED</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Worklet">Worklet</a></li>
</ul>
<h2 id="14-addEventListener参数"><a href="#14-addEventListener参数" class="headerlink" title="14 addEventListener参数"></a>14 addEventListener参数</h2><p><code>element.addEventListener(event, function, useCapture)</code></p>
<h3 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>event</em></td>
<td align="left">必须。字符串，指定事件名。  <strong>注意:</strong> 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。  <strong>提示：</strong> 所有 HTML DOM 事件，可以查看我们完整的 <a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM Event 对象参考手册</a>。</td>
</tr>
<tr>
<td align="left"><em>function</em></td>
<td align="left">必须。指定要事件触发时执行的函数。  当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</td>
</tr>
<tr>
<td align="left"><em>useCapture</em></td>
<td align="left">可选。布尔值，指定事件是否在捕获或冒泡阶段执行。  可能值:true - 事件句柄在捕获阶段执行false- false- 默认。事件句柄在冒泡阶段执行</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myBtn&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;Hello World&quot;</span>;<br> <br>&#125;);<br> <br></code></pre></td></tr></table></figure>

<p>提示： 使用 removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄。</p>
<p>参数值</p>
<p>event 必须。字符串，指定事件名。</p>
<p>注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。</p>
<p>function 必须。指定要事件触发时执行的函数。</p>
<p>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</p>
<p>useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。</p>
<p>可能值:</p>
<p>true - 事件句柄在捕获阶段执行</p>
<p>false- false- 默认。事件句柄在冒泡阶段执行</p>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>click 当用户点击某个对象时调用的事件句柄。</p>
<p>contextmenu 在用户点击鼠标右键打开上下文菜单时触发</p>
<p>dblclick 当用户双击某个对象时调用的事件句柄。</p>
<p>mousedown 鼠标按钮被按下。</p>
<p>mouseenter 当鼠标指针移动到元素上时触发。</p>
<p>mouseleave 当鼠标指针移出元素时触发</p>
<p>mousemove 鼠标被移动。</p>
<p>mouseover 鼠标移到某元素之上。</p>
<p>mouseout 鼠标从某元素移开。</p>
<p>mouseup 鼠标按键被松开。</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>属性 描述 DOM</p>
<p>keydown 某个键盘按键被按下。</p>
<p>keypress 某个键盘按键被按下并松开。</p>
<p>keyup 某个键盘按键被松开。</p>
<p>框架&#x2F;对象（Frame&#x2F;Object）事件</p>
<p>abort 图像的加载被中断。 ( )</p>
<p>beforeunload 该事件在即将离开页面（刷新或关闭）时触发</p>
<p>error 在加载文档或图像时发生错误。 ( , 和 )</p>
<p>hashchange 该事件在当前 URL 的锚部分发生修改时触发。</p>
<p>load 一张页面或一幅图像完成加载。</p>
<p>pageshow 该事件在用户访问页面时触发</p>
<p>pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发</p>
<p>resize 窗口或框架被重新调整大小。</p>
<p>scroll 当文档被滚动时发生的事件。</p>
<p>unload 用户退出页面。 ( 和 )</p>
<h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><p>blur 元素失去焦点时触发</p>
<p>change 该事件在表单元素的内容改变时触发( , , , 和 )</p>
<p>focus 元素获取焦点时触发</p>
<p>focusin 元素即将获取焦点是触发</p>
<p>focusout 元素即将失去焦点是触发</p>
<p>input 元素获取用户输入是触发</p>
<p>reset 表单重置时触发</p>
<p>search 用户向搜索域输入文本时触发 (</p>
<h4 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h4><p>copy 该事件在用户拷贝元素内容时触发</p>
<p>cut 该事件在用户剪切元素内容时触发</p>
<p>paste 该事件在用户粘贴元素内容时触发</p>
<h4 id="打印事件"><a href="#打印事件" class="headerlink" title="打印事件"></a>打印事件</h4><p>afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发</p>
<p>beforeprint 该事件在页面即将开始打印时触发</p>
<h4 id="拖动事件"><a href="#拖动事件" class="headerlink" title="拖动事件"></a>拖动事件</h4><p>drag 该事件在元素正在拖动时触发</p>
<p>dragend 该事件在用户完成元素的拖动时触发</p>
<p>dragenter 该事件在拖动的元素进入放置目标时触发</p>
<p>dragleave 该事件在拖动元素离开放置目标时触发</p>
<p>dragover 该事件在拖动元素在放置目标上时触发</p>
<p>dragstart 该事件在用户开始拖动元素时触发</p>
<p>drop 该事件在拖动元素放置在目标区域时触发</p>
<h4 id="多媒体（Media）事件"><a href="#多媒体（Media）事件" class="headerlink" title="多媒体（Media）事件"></a>多媒体（Media）事件</h4><p>abort 事件在视频&#x2F;音频（audio&#x2F;video）终止加载时触发。</p>
<p>canplay 事件在用户可以开始播放视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>canplaythrough 事件在视频&#x2F;音频（audio&#x2F;video）可以正常播放且无需停顿和缓冲时触发。</p>
<p>durationchange 事件在视频&#x2F;音频（audio&#x2F;video）的时长发生变化时触发。</p>
<p>emptied The event occurs when the current playlist is empty</p>
<p>ended 事件在视频&#x2F;音频（audio&#x2F;video）播放结束时触发。</p>
<p>error 事件在视频&#x2F;音频（audio&#x2F;video）数据加载期间发生错误时触发。</p>
<p>loadeddata 事件在浏览器加载视频&#x2F;音频（audio&#x2F;video）当前帧时触发触发。</p>
<p>loadedmetadata 事件在指定视频&#x2F;音频（audio&#x2F;video）的元数据加载后触发。</p>
<p>loadstart 事件在浏览器开始寻找指定视频&#x2F;音频（audio&#x2F;video）触发。</p>
<p>pause 事件在视频&#x2F;音频（audio&#x2F;video）暂停时触发。</p>
<p>play 事件在视频&#x2F;音频（audio&#x2F;video）开始播放时触发。</p>
<p>playing 事件在视频&#x2F;音频（audio&#x2F;video）暂停或者在缓冲后准备重新开始播放时触发。</p>
<p>progress 事件在浏览器下载指定的视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>ratechange 事件在视频&#x2F;音频（audio&#x2F;video）的播放速度发送改变时触发。</p>
<p>seeked 事件在用户重新定位视频&#x2F;音频（audio&#x2F;video）的播放位置后触发。</p>
<p>seeking 事件在用户开始重新定位视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。</p>
<p>suspend 事件在浏览器读取媒体数据中止时触发。</p>
<p>timeupdate 事件在当前的播放位置发送改变时触发。</p>
<p>volumechange 事件在音量发生改变时触发。</p>
<p>waiting 事件在视频由于要播放下一帧而需要缓冲时触发。</p>
<h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><p>animationend 该事件在 CSS 动画结束播放时触发</p>
<p>animationiteration 该事件在 CSS 动画重复播放时触发</p>
<p>animationstart 该事件在 CSS 动画开始播放时触发</p>
<h4 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h4><p>transitionend 该事件在 CSS 完成过渡后触发。</p>
<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发</p>
<p>online 该事件在浏览器开始在线工作时触发。</p>
<p>offline 该事件在浏览器开始离线工作时触发。</p>
<p>popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。</p>
<h2 id="15-cookie、sessionStorage和localStorage的区别"><a href="#15-cookie、sessionStorage和localStorage的区别" class="headerlink" title="15 cookie、sessionStorage和localStorage的区别"></a>15 cookie、sessionStorage和localStorage的区别</h2><p>一、 概念的理解</p>
<h3 id="webstorage本地存储"><a href="#webstorage本地存储" class="headerlink" title="webstorage本地存储"></a>webstorage本地存储</h3><p>1）webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage</p>
<p>2）localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信</p>
<p>3）sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>
<p>4）WebStorage的目标</p>
<p>提供一种在cookie之外存储会话数据的路径</p>
<p>提供一种存储大量可以跨会话存在的数据的机制</p>
<p>HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）</p>
<p>5）作用域的不同：</p>
<p>不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p>
<p>6）存储大小：</p>
<p>localStorage和sessionStorage的存储数据大小一般都是：5MB</p>
<p>7）存储位置：</p>
<p>localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信</p>
<p>8）存储内容类型：</p>
<p>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p>
<p>9）获取方式：</p>
<p>localStorage：window.localStorage;；sessionStorage：window.sessionStorage;</p>
<p>10）应用场景：</p>
<p>localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据，而sessionStorage：敏感账号一次性登录</p>
<p>11）WebStorage的优点：</p>
<p>存储空间更大：cookie为4KB，而WebStorage是5MB</p>
<p>节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量</p>
<p>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便</p>
<p>快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快</p>
<p>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题</p>
<p>WebStorage提供了一些方法，数据操作比cookie方便</p>
<p>setItem (key, value) —— 保存数据，以键值对的方式储存信息。</p>
<p>getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。</p>
<p>removeItem (key) —— 删除单个数据，根据键值移除对应的信息。</p>
<p>clear () —— 删除所有的数据</p>
<p>key (index) —— 获取某个索引的key</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>1）HTTP Cookie简称cookie,在HTTP请求发送Set-Cookie HTTP头作为响应的一部分。通过name&#x3D;value的形式存储</p>
<p>2）cookie的构成：</p>
<p>名称：name(不区分大小写,但最好认为它是区分的)</p>
<p>值:value(通过URL编码:encodeURIComponent)</p>
<p>域</p>
<p>路径</p>
<p>失效时间:一般默认是浏览器关闭失效,可以自己设置失效时间</p>
<p>安全标志:设置安全标志后只有SSL连接的时候才发送到服务器</p>
<p>3）cookie的作用:主要用于保存登录信息</p>
<p>4）生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>
<p>5）cookie的优点：具有极高的扩展性和可用性</p>
<p>通过良好的编程，控制保存在cookie中的session对象的大小</p>
<p>通过加密和安全传输技术，减少cookie被破解的可能性</p>
<p>只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失</p>
<p>控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie</p>
<p>6）cookie的缺点：</p>
<p>cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉</p>
<p>安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用</p>
<p>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用</p>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>1）sessionStorage是Storage类型的一个对象，拥有clear(),getItem(name),key(index),removeItem(name),setItem(name,value)方法</p>
<p>2）sessionStorage对象存储特定于某个会话的数据,也就是该数据只保持到浏览器关闭</p>
<p>3）将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据</p>
<p>4）sessionStorage为临时保存</p>
<p>localStorage</p>
<p>1）localStorage也是Storage类型的一个对象</p>
<p>2）在HTML5中localStorage作为持久保存在客户端数据的方案取代了globalStorage(globalStorage必须指定域名)</p>
<p>3）localStorage会永久存储会话数据，除非removeItem,否则会话数据一直存在</p>
<p>4）将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用</p>
<p>5）localStorage为永久保存</p>
<p>图示说明：</p>
<p>注意：时刻注意XSS注入的风险，因为可以在控制台直接访问它们，所以不要存入敏感数据</p>
<h3 id="区别的比较"><a href="#区别的比较" class="headerlink" title="区别的比较"></a>区别的比较</h3><p>本地储存localStorage与cookie的区别</p>
<p>1）cookie在浏览器与服务器之间来回传递</p>
<p>sessionStorage和localStorage不会把数据发给服务器，仅在本地保存</p>
<p>2）数据有效期不同</p>
<p>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<p>sessionStorage：仅在当前浏览器窗口关闭前有效</p>
<p>localStorage 始终有效，长期保存</p>
<p>3）cookie数据还有路径的概念，可以限制cookie只属于某个路径下</p>
<p>存储大小也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>4）作用域不用</p>
<p>sessionStorage不在不同的浏览器窗口中共享</p>
<p>localStorage在所有同源窗口中都是共享的</p>
<p>cookie也是在所有同源窗口中都是共享的</p>
<p>WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便</p>
<h4 id="cookie、session和localStorage的区别"><a href="#cookie、session和localStorage的区别" class="headerlink" title="cookie、session和localStorage的区别"></a>cookie、session和localStorage的区别</h4><p>1）cookie的内容主要包括：名字、值、过期时间、路径和域，路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失，这种生命期为浏览器会话期的cookie被称为会话cookie</p>
<p>2）会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。</p>
<p>3）当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</p>
<h4 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h4><p>1）cookie数据存放在客户的浏览器上，session数据放在服务器上</p>
<p>2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</p>
<p>3）session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</p>
<p>4）单个cookie保存的数*据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</p>
<p>5）建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中</p>
<p>6）session保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息</p>
<p>7）session中保存的是对象，cookie中保存的是字符串</p>
<p>8）session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的</p>
<h4 id="web-Storage和cookie的区别"><a href="#web-Storage和cookie的区别" class="headerlink" title="web Storage和cookie的区别"></a>web Storage和cookie的区别</h4><p>1）Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用</p>
<p>2）web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie</p>
<p>3）但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生</p>
<p>sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的</p>
<p>4）Web Storage的好处</p>
<p>减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递</p>
<p>快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示</p>
<p>临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便</p>
<h4 id="浏览器本地存储与服务器端存储的区别"><a href="#浏览器本地存储与服务器端存储的区别" class="headerlink" title="浏览器本地存储与服务器端存储的区别"></a>浏览器本地存储与服务器端存储的区别</h4><p>1）数据既可以在浏览器本地存储，也可以在服务器端存储</p>
<p>2）浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据</p>
<p>3）服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据</p>
<p>4）服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端 ，服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上</p>
<p>5）服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期</p>
<p>6）服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据</p>
<h4 id="sessionStorage、localStorage和cookie的区别"><a href="#sessionStorage、localStorage和cookie的区别" class="headerlink" title="sessionStorage、localStorage和cookie的区别"></a>sessionStorage、localStorage和cookie的区别</h4><p>1）相同点是都是保存在浏览器端、且同源的</p>
<p>2）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
<p>3）存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>4）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>5）作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
<p>6）web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p>
<p>7）web Storage的api接口使用更方便</p>
<h4 id="sessionStorage与页面js数据对象的区别"><a href="#sessionStorage与页面js数据对象的区别" class="headerlink" title="sessionStorage与页面js数据对象的区别"></a>sessionStorage与页面js数据对象的区别</h4><p>1）页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了</p>
<p>2）sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在</p>
<h2 id="16-js中的垃圾回收机制"><a href="#16-js中的垃圾回收机制" class="headerlink" title="16 js中的垃圾回收机制"></a>16 js中的垃圾回收机制</h2><p>本文主要围绕JS引擎相关知识，来深入了解底层运行逻辑，这对于日常开发维护高性能Javascript代码以及排查代码性能问题有着很好的帮助。关于JS引擎底层的垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化，实现对JS内存管理以及内存溢出的处理。</p>
<p>那么我们需要考虑几个问题：</p>
<ul>
<li>什么是垃圾回收机制（GC）？</li>
<li>垃圾是怎样产生的？</li>
<li>为什么要进行垃圾回收？</li>
<li>Javascript的内存是如何管理的？</li>
<li>Chrome浏览器又是如何进行垃圾回收的？</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在Javascript编程中，内存管理大概分成三个步骤，也是内存的生命周期：</p>
<ul>
<li>分配你所需系统内存的空间</li>
<li>使用分配到的内存进行读写操作</li>
<li>不需要使用内存时，将空间进行释放和归还</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ca5e11ded7433cbf09a98a70856d29~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (4).png"></p>
<p>与其它手动管理内存的语言不一样的是，在Javascript中，当我们创建变量时，系统会给对象进行自动分配对应的内存空间以及闲置资源回收，也就是不需要我们手动进行分配。但是，正是因为垃圾回收机制导致开发者有着错误的感觉，就是他们不用关心内存管理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;yichuan&quot;</span>;<span class="hljs-comment">//给字符串分配栈内存</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;<span class="hljs-comment">//给数值分配栈内存</span><br><br><span class="hljs-comment">//给对象以及包含的值分配堆内存</span><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;onechuan&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">19</span><br>&#125;<br><span class="hljs-comment">//给数组以及包含的值分配堆内存</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;yichuan&quot;</span>,<span class="hljs-string">&quot;onechuan&quot;</span>,<span class="hljs-number">18</span>];<br><span class="hljs-comment">//给函数对象分配堆内存</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">x,y</span>)&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在前面《Javascript的数据类型知多少》文中，我们知道了基础数据类型和引用数据类型的分配机制，即：</p>
<ul>
<li>简单数据类型内存保存在固定的栈空间中，可直接通过值进行访问</li>
<li>引用数据类型的值大小不固定，其引用地址保存在栈空间、引用所指向的值保存在堆空间中，需要通过引用进行访问</li>
</ul>
<p>栈内存中的基本数据类型，可以直接通过操作系统进行处理，而堆内存中的引用数据类型的值大小不确定，因此需要JS的引擎通过垃圾回收机制进行处理。</p>
<h3 id="内存回收机制（GC）"><a href="#内存回收机制（GC）" class="headerlink" title="内存回收机制（GC）"></a>内存回收机制（GC）</h3><p>Javascript的V8引擎被限制了内存的使用，因此根据不同操作系统的内存大小会不一样。</p>
<p>V8引擎最初设计是作为浏览器的引擎，并未考虑占据过多的内存空间，随着web技术工程化的发展，占据了越来越多的内存空间。又由于被v8的会回收机制所限制，这样就引起了js执行的线程被挂起，会影响当前执行的页面应用性能。</p>
<p><strong>垃圾回收算法：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清楚或释放内存。</strong> 但是垃圾回收算法是个不完美的方案，因为某块内存是否还可用，属于不可预判的问题，也就意味着单纯依靠算法是解决不了的。还有为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了。</p>
<p>我们知道了垃圾是如何产生的，那么我们应该如何清除呢？在浏览器的发展历史上有两种解决策略：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除分为：标记阶段和清除阶段。</p>
<p>首先它会遍历堆内存上所有的对象，分别给它们打上标记，然后在代码执行过程结束之后，对所使用过的变量取消标记。在清除阶段再把具有标记的内存对象进行整体清除，从而释放内存空间。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae628622e794fcdaba8012668c44385~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (5).png"></p>
<p>整个标记清除算法大致过程就像下面这样</p>
<ul>
<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记</li>
<li>然后从各个根对象开始遍历，把还在被上下文变量引用的变量标记去掉标记</li>
<li>清理所有带有标牌机的变量，销毁并回收它们所占用的内存空间</li>
<li>最后垃圾回收程序做一次内存清理</li>
</ul>
<p>使用标记清除策略的最重要的优点在于简单，无非是标记和不标记的差异。通过标记清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，这就造成出现内存碎片的问题。内存碎片多了后，如果要存储一个新的需要占据较大内存空间的对象，就会造成影响。对于通过标记清除产生的内存碎片，还是需要通过标记整理策略进行解决。</p>
<p>简而言之：</p>
<ul>
<li>优点：简单</li>
<li>缺点：内存碎片化、分配速度慢</li>
</ul>
<h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>经过标记清除策略整理后，老生代内存中因此产生了许多内存碎片，如果不进行清理内存碎片，就会对存储造成影响。</p>
<p><strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决标记清除的两个缺点。它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00446ce9546a4194832617a5fb7b07c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (6).png"></p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数是一种不常见的垃圾回收策略，其思路就是对每个值都记录其的引用次数。具体的：</p>
<ul>
<li>当变量进行声明并赋值后，值的引用数为1。</li>
<li>当同一个值被赋值给另一个变量时，引用数+1</li>
<li>当保存该值引用的变量被其它值覆盖时，引用数-1</li>
<li>当该值的引用数为0时，表示无法再访问该值了，此时就可以放心地将其清除并回收内存。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() 	<span class="hljs-comment">// 此对象的引用计数为 1（a引用）</span><br><span class="hljs-keyword">let</span> b = a 		<span class="hljs-comment">// 此对象的引用计数是 2（a,b引用）</span><br>a = <span class="hljs-literal">null</span>  		<span class="hljs-comment">// 此对象的引用计数为 1（b引用）</span><br>b = <span class="hljs-literal">null</span> 	 	<span class="hljs-comment">// 此对象的引用计数为 0（无引用）</span><br>...			<span class="hljs-comment">// GC 回收此对象</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这种回收策略看起来很方便，但是当其进行循环引用时就会出现问题，会造成大量的内存不会被释放。当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一。</p>
<h3 id="V8对于垃圾回收机制的优化"><a href="#V8对于垃圾回收机制的优化" class="headerlink" title="V8对于垃圾回收机制的优化"></a>V8对于垃圾回收机制的优化</h3><p>大多数浏览器都是基于标记清除算法，不同的只是在运行垃圾回收的频率具有差异。V8 对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化。</p>
<h4 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h4><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。</p>
<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。</p>
<p>V8 整个堆内存的大小就等于新生代加上老生代的内存，对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51af8d575c54ea9bccfccacf828144b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (7).png"></p>
<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4><p>在64操作系统下分配为32MB，因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是能够理解。</p>
<p>对于新生代内存的回收，通常是通过Scavenge 的算法进行垃圾回收，就是将新生代内存进行一分为二，正在被使用的内存空间称为使用区，而限制状态的内存空间称为空闲区。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dac4e1334124e048f0e8a69126e2d7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (8).png"> 新生代内存回收的原理是：</p>
<ul>
<li>新加入的对象都会存放在使用区，当使用区快写满时就进行一次垃圾清理操作。</li>
<li>在开始进行垃圾回收时，新生代回收器会对使用区内的对象进行标记</li>
<li>标记完成后，需要对使用区内的活动对象拷贝到空闲区进行排序</li>
<li>而后进入垃圾清理阶段，将非活动对象占用的内存空间进行清理</li>
<li>最后对使用区和空闲区进行交换，使用区-&gt;空闲区，空闲区-&gt;使用区</li>
</ul>
<p>新生代中的变量如果经过回收之后依然一直存在，那么会放入到老生代内存中，只要是已经经历过一次Scavenge算法回收的，就可以晋升为老生代内存的对象。</p>
<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4><p>当然，Scavenge算法也有其适用场景范围，对于内存空间较大的就不适合使用Scavenge算法。此时应该使用Mark-Sweep（标记清除）和Mark-Compact（标记整理）的策略进行老生代内存中的垃圾回收。</p>
<p>首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。</p>
<p>同样的标记清除策略会产生内存碎片，因此还需要进行标记整理策略进行优化。</p>
<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3><p>内存泄漏，指在JS中已经分配内存地址的对象由于长时间未进行内存释放或无法清除，造成了长期占用内存，使得内存资源浪费，最终导致运行的应用响应速度变慢以及最终崩溃的情况。</p>
<p>在代码中创建对象和变量时会占据内存，但是<strong>JS基于自己的内存回收机制是可以确定哪些变量不再需要，并将其进行清除</strong>。但是，当你的代码中存在逻辑缺陷时，你以为你已经不需要，但是程序中还存在这引用，这就导致程序运行完后并没有进行合适的回收所占有的内存空间。运行时间越长占用内存越多，随之出现的问题就是：性能不佳、高延迟、频繁崩溃。</p>
<p>造成内存泄漏的常见原因有：</p>
<ul>
<li><strong>过多的缓存</strong>。及时清理过多的缓存。</li>
<li><strong>滥用闭包</strong>。尽量避免使用大量的闭包。</li>
<li><strong>定时器或回调太多</strong>。与节点或数据相关联的计时器不再需要时，DOM节点对象可以清除，整个回调函数也不再需要。可是，计时器回调函数仍然没有被回收（计时器停止才会被回收）。当不需要setTimeout或setInterval时，<strong>定时器没有被清除</strong>，定时器的糊掉函数以及其内部依赖的变量都不能被回收，<strong>会造成内存泄漏</strong>。解决方法：在定时器完成工作时，需要手动清除定时器。</li>
<li><strong>太多无效的DOM引用</strong>。DOM删除了，但是节点的引用还在，导致GC无法实现对其所占内存的回收。解决方法：给删除的DOM节点引用设置为null。</li>
<li><strong>滥用全局变量。</strong>全局变量是根据定义无法被垃圾回收机制进行收集的，因此需要特别注意临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，请确保将其指定为null或在完成后重新分配它。解决方法：使用严格模式。</li>
<li><strong>从外到内执行appendChild。</strong>此时即使调用removeChild也无法进行释放内存。解决方法：从内到外appendChild。</li>
<li><strong>反复重写同一个数据会造成内存大量占用</strong>，但是IE浏览器关闭后会被释放。</li>
<li><strong>注意程序逻辑</strong>，避免编写『死循环』之类的代码。</li>
<li><strong>DOM对象和JS对象相互引用</strong>。</li>
</ul>
<p>关于内存泄漏，如果你想要更好地排查以及提前避免问题的发生，最好的解决方法是通过熟练使用Chrome的内存剖析工具，多分析多定位Chrome帮你分析保留的内存快照，来查看持续占用大量内存的对象。</p>
<h2 id="17-eval"><a href="#17-eval" class="headerlink" title="17 eval"></a>17 eval</h2><p>解析成js并执行。</p>
<p>语法：<code>eval(string)</code></p>
<h2 id="18-setTimeout、setInterval和requestAnimationFrame的不同"><a href="#18-setTimeout、setInterval和requestAnimationFrame的不同" class="headerlink" title="18 setTimeout、setInterval和requestAnimationFrame的不同"></a>18 setTimeout、setInterval和requestAnimationFrame的不同</h2><p>与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔，大多数电 脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。大多数浏览器都 会对重绘 操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验 也不会有 提升。因此，最平滑动画的最佳循环间隔是 1000ms&#x2F;60，约等于 16.6ms。 RAF 采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的 任 务多的话， 会响应setTimeout和setInterval真正运行时的时间间隔。 </p>
<p>特点： </p>
<p>（1）requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或 回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 </p>
<p>（2）在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这 当 然就意味着更少的 CPU、GPU 和内存使用量 </p>
<p>（3）requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会 自 动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节 省了 CPU 开销</p>
<h2 id="19-深入理解JS中的事件发射器（Event-Emitters）"><a href="#19-深入理解JS中的事件发射器（Event-Emitters）" class="headerlink" title="19 深入理解JS中的事件发射器（Event Emitters）"></a>19 深入理解JS中的事件发射器（Event Emitters）</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>先看一个<code>DOM</code>事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-comment">/* do something with the event */</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>以上代码在<code>button</code>上添加了一个事件监听器，每当点击<code>button</code>的时候，点击事件被触发出去并且同时调用<code>callback</code>函数。</p>
<p>有很多时候可能会有需要触发自定义事件的需求，不单单只是一个点击事件，假设有这样一个需要触发一个基于其他触发器的事件，并且需要有一个事件响应的，可以自定义一个<code>event emitter</code>来实现。</p>
<p>一个<code>event emitter</code>就是监听一个<code>event</code>，触发一个回调函数，然后<code>emit</code>一个带有<code>value</code>的事件的一种模式，有时候也称为<code>pub/sub</code>模型或者监听器。</p>
<p>在JavaScript中的一种实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">event</span> = <span class="hljs-keyword">new</span> EventEmitter();<br><br><span class="hljs-keyword">event</span>.subscribe(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-keyword">value</span> =&gt; (n = <span class="hljs-keyword">value</span>));<br><br><span class="hljs-keyword">event</span>.emit(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">// n: 18</span><br><br><span class="hljs-keyword">event</span>.emit(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// n: 5</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们订阅了一个叫做 <code>THUNDER_ON_THE_MOUNTAIN</code>的事件，并且当事件被 <code>emitted</code> 的时候，回调函数 <code>value =&gt; (n = value)</code> 也会被触发，可以调用 <code>emit()</code>来<code>emit</code>该事件。</p>
<p>这在与异步代码交互的时候，如果有不在当前模块下的值需要更新时十分有用。</p>
<p>一个真实的例子就是<a href="https://link.juejin.cn/?target=https://react-redux.js.org/">React Redux</a>， <code>Redux</code>需要一种通知外部其内部的值已经更新的机制，其允许<code>React</code>调用<code>setState()</code>并重新渲染UI来获取哪些值已经改变，这个地方也是使用<code>event emitter</code>来实现的。 <code>Redux store</code>有一个传入一个提供新的<code>store</code>的回调函数作为参数的订阅函数，在这个订阅函数中，调用了 <code>React Redux</code>的以新<code>store</code>的值调用了<code>setState()</code>方法的 <code>&lt;Provider&gt;</code> 组件，可以<a href="https://link.juejin.cn/?target=https://github.com/reduxjs/react-redux/blob/master/src/components/Provider.js%23L36">在此</a>查看。</p>
<p>现在我们的应用有了两个不同的部分，一部分是<code>React UI</code>，另一部分是<code>Redux store</code>，谁也说不清楚事件究竟是被那一部分触发的。</p>
<h3 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h3><p>先看一个简单的<code>event emitter</code>，其中使用了<code>class</code>，在这个<code>class</code>中跟踪事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  public <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>事件</li>
</ul>
<p>定义一个事件接口，用来存储一个每一个<code>key</code>都是一个事件名并且各自的值都是回调函数组成的数组的空白对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Events</span> &#123;<br>  [<span class="hljs-attr">key</span>: string]: <span class="hljs-title class_">Function</span>[];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &quot;event&quot;: [fn],</span><br><span class="hljs-comment">  &quot;event_two&quot;: [fn]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>使用数组的原因是因为每一个事件都可能有多个<code>subscriber</code>，因为<code>element.addEventLister(&quot;click&quot;)</code>可能会被多次调用。</p>
<ul>
<li>订阅</li>
</ul>
<p>现在需要处理订阅的事件，在上面的例子中，<code>subscribe()</code>函数接收两个参数：一个<code>name</code>和一个<code>callback</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">event.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;named event&quot;</span>, <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br></code></pre></td></tr></table></figure>

<p>定义一个<code>subscribe</code>方法来接收这两个参数，只需把这两个参数添加到类内部的<code>this.events</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>发射</li>
</ul>
<p>到此可以订阅事件了，接下来，当一个新事件发射的时候需要触发回调函数，当触发的时候，将使用<code>(emit(&quot;event&quot;))</code>中存储的事件名和需要传递到回调函数<code>(emit(&quot;event&quot;, value))</code>的任意值，我们可以简单地传递任意参数到回调函数在第一个参数后面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">emit</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">void</span> &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然我们知道了我们希望发射的事件，可以使用<code>this.events[name]</code>来查看，返回的是一个回调函数的数组。</p>
<ul>
<li>取消订阅</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: string, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>  (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码返回一个带有<code>unsubscribe</code>方法的对象，可以使用箭头函数<code>() =&gt;</code>来获取传递给父对象参数的作用域，在这个函数中，使用<code>&gt;&gt;&gt;</code><a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it">操作符</a>可以找到传递给父级回调函数的索引，在这里使用可以保证我们每次在回调函数数组上调用<code>splice()</code> 的时候总是可以取到一个真正的数字，即使<code>indexOf()</code> 都不能返回数字也行。 可以这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> subscription = event.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;event&quot;</span>, <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br><br>subscription.<span class="hljs-title function_">unsubscribe</span>();<br></code></pre></td></tr></table></figure>

<p>到此，我们就可以取消这一个特别的订阅了，而且不影响其他的订阅。</p>
<ul>
<li>完整实现</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Events</span> &#123;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Function</span>[];<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">emit</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">void</span> &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>实例</li>
</ul>
<p><a href="https://link.juejin.cn/?target=https://codepen.io/charliewilco/pen/gEoErR">codepen.io&#x2F;charliewilc…</a></p>
<p>上述代码中，首先在另外一个事件回调中使用了<code>event emitter</code>，在这种情况下，一个<code>event emitter</code>是用来清除一些逻辑，在GitHub上选择一个仓库，获取详情，缓存详情，并更新DOM去显示这些详情。在订阅回调函数中从网络或者缓存中获取结果并更新，可以这样做的原因是当我们发射时间的时候从列表中给了回调函数一个随机的仓库。</p>
<p>现在来考虑一些不太一样的东西，在一个应用中，可能会有许多状态需要登录之后才可以触发，并且可能会有多个订阅器来处理用户试图退出的操作。因为已经发射了一个带<code>false</code>值的事件，每一个订阅器都可以使用这个值，并且需要判断是否需要重定向页面，移除cookie或者禁用表单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> events = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br><br>events.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-literal">false</span>);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  buttonEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;disabled&quot;</span>, !isLogged);<br>&#125;);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">replace</span>(!isLoggedIn ? <span class="hljs-string">&quot;/login&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>&#125;);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  !isLoggedIn &amp;&amp; cookies.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;auth_token&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>最后</li>
</ul>
<p>要让<code>emitters</code>能工作，有几点需要考虑：</p>
<ul>
<li>需要在<code>emit()</code>函数中使用<code>forEach</code>或者<code>map</code>来确保我们能创建新的订阅器或者取消订阅。</li>
<li>当一个<code>EventEmitter</code>类被实例化之后，可以传递一个预定义的事件到事件接口。</li>
<li>可以不需要使用<code>class</code>，来实现，个人喜好，但是使用<code>class</code>使事件存储在哪里会更加清晰。 可以在一个函数中实现，如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">emitter</span>(<span class="hljs-params">e?: Events</span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span> = e || &#123;&#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    events,<br>    <span class="hljs-attr">subscribe</span>: <span class="hljs-function">(<span class="hljs-params">name: string, cb: <span class="hljs-built_in">Function</span></span>) =&gt;</span> &#123;<br>      (events[name] || (events[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>          events[name] &amp;&amp; events[name].<span class="hljs-title function_">splice</span>(events[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;;<br>    &#125;,<br>    <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">name: string, ...args: any[]</span>) =&gt;</span> &#123;<br>      (events[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="20-js数组常用方法"><a href="#20-js数组常用方法" class="headerlink" title="20 js数组常用方法"></a>20 js数组常用方法</h2><h3 id="一、改变原数组的方法"><a href="#一、改变原数组的方法" class="headerlink" title="一、改变原数组的方法"></a>一、改变原数组的方法</h3><h4 id="1-push（）-末尾添加数据"><a href="#1-push（）-末尾添加数据" class="headerlink" title="1.push（） 末尾添加数据"></a><strong>1.push（） 末尾添加数据</strong></h4><p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong> 就是往数组末尾添加数据</p>
<p><strong>返回值:</strong>  就是这个数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //push">var arr = [10, 20, 30, 40]<br>res = arr.push(20)<br>console.log(arr);//[10,20,30,40,20]<br>console.log(res);//5<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-pop（）-末尾出删除数据"><a href="#2-pop（）-末尾出删除数据" class="headerlink" title="2. pop（） 末尾出删除数据"></a>2. pop（） 末尾出删除数据</h4><p><strong>语法:</strong> <strong>数组名.pop()</strong></p>
<p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p>
<p><strong>返回值:</strong> 就是你删除的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //pop">var arr = [10, 20, 30, 40] <br>res =arr.pop()<br>console.log(arr);//[10,20,30]<br>console.log(res);//40<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3-unshift（）-头部添加数据"><a href="#3-unshift（）-头部添加数据" class="headerlink" title="3.unshift（） 头部添加数据"></a>3.unshift（） 头部添加数据</h4><p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong>  就是在数组的头部添加数据</p>
<p><strong>返回值:</strong> 就是数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //pop"> var arr = [10, 20, 30, 40]<br> res=arr.unshift(99)<br> console.log(arr);//[99,10,20,30,40]<br> console.log(res);//5<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-shift（）-头部删除数据"><a href="#4-shift（）-头部删除数据" class="headerlink" title="4.shift（） 头部删除数据"></a>4.shift（） 头部删除数据</h4><p><strong>语法:</strong> <strong>数组名.shift()</strong></p>
<p><strong>作用:</strong>  头部删除一个数据</p>
<p><strong>返回值:</strong>  就是删除掉的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //shift"> var arr = [10, 20, 30, 40]<br> res=arr.shift()<br> console.log(arr);[20,30,40]<br> console.log(res);10<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-reverse（）-翻转数组"><a href="#5-reverse（）-翻转数组" class="headerlink" title="5.reverse（） 翻转数组"></a>5.reverse（） 翻转数组</h4><p><strong>语法:</strong> <strong>数组名.reverse()</strong></p>
<p><strong>作用:</strong> 就是用来翻转数组的</p>
<p><strong>返回值:</strong> 就是翻转好的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure>

<h4 id="6-sort（）-排序"><a href="#6-sort（）-排序" class="headerlink" title="6.sort（） 排序"></a>6.sort（） 排序</h4><p>语法一: 数组名.sort()会排序 会按照位排序</p>
<p>语法二: 数组名.sort(function (a,b) {return a-b})  会正序排列</p>
<p>语法三: 数组名.sort(function (a,b) {return b-a})  会倒序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //sort()">var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]<br>arr.sort()<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(a-b)&#125;)<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(b-a)&#125;)<br>console.log(arr);<br></code></pre></td></tr></table></figure>

<h4 id="7-splice（）-截取数组"><a href="#7-splice（）-截取数组" class="headerlink" title="7.splice（）  截取数组"></a>7.splice（）  截取数组</h4><p>语法一: 数组名.splice(开始索引,多少个)</p>
<p>作用: 就是用来截取数组的</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<p>语法二: 数组名.splice(开始索引,多少个,你要插入的数据)</p>
<p>作用: 删除并插入数据</p>
<p>注意: 从你的开始索引起</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr);<br>console.log(res);<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr);<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h3 id="二、不改变原数组的方法"><a href="#二、不改变原数组的方法" class="headerlink" title="二、不改变原数组的方法"></a>二、不改变原数组的方法</h3><h4 id="1-concat（）合并数组"><a href="#1-concat（）合并数组" class="headerlink" title="1.concat（）合并数组"></a>1.concat（）合并数组</h4><p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong>  合并数组的</p>
<p><strong>返回值:</strong>  一个新的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //concat">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.concat(20,&quot;小敏&quot;,50)<br>console.log(arr) <br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-join（）-数组转字符串"><a href="#2-join（）-数组转字符串" class="headerlink" title="2.join（） 数组转字符串"></a>2.join（） 数组转字符串</h4><p><strong>语法:</strong> <strong>数组名.join(‘</strong> <strong>连接符’)</strong></p>
<p><strong>作用:</strong> 就是把一个数组转成字符串</p>
<p><strong>返回值:</strong>  就是转好的一个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //join">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.join(&quot;+&quot;)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h4 id="3-slice（）截取数组的一部分数据"><a href="#3-slice（）截取数组的一部分数据" class="headerlink" title="3.slice（）截取数组的一部分数据"></a>3.slice（）截取数组的一部分数据</h4><p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p>
<p><strong>作用:</strong> 就是截取数组中的一部分数据</p>
<p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p>
<p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-indexOf-从左检查数组中有没有这个数值"><a href="#4-indexOf-从左检查数组中有没有这个数值" class="headerlink" title="4.indexOf 从左检查数组中有没有这个数值"></a>4.indexOf 从左检查数组中有没有这个数值</h4><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr)<br>console.log(res);<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-lastIndexOf-从右检查数组中有没有这个数值"><a href="#5-lastIndexOf-从右检查数组中有没有这个数值" class="headerlink" title="5.lastIndexOf 从右检查数组中有没有这个数值"></a>5.lastIndexOf 从右检查数组中有没有这个数值</h4><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="三、ES6新增的数组方法"><a href="#三、ES6新增的数组方法" class="headerlink" title="三、ES6新增的数组方法"></a>三、ES6新增的数组方法</h3><h4 id="1-forEach-用来循环遍历的-for"><a href="#1-forEach-用来循环遍历的-for" class="headerlink" title="1. forEach()  用来循环遍历的 for"></a>1. forEach()  用来循环遍历的 for</h4><p>语法: 数组名.forEach(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来循环遍历数组的 代替了我们的for</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-map-映射数组的"><a href="#2-map-映射数组的" class="headerlink" title="2.map  映射数组的"></a>2.map  映射数组的</h4><p>语法: 数组名.map(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来映射</p>
<p>返回值: 必然是一个数组 一个映射完毕的数组；这个数组合原数组长度一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //map">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.map(function (item) &#123;<br>    return item*1000<br>&#125;)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3-filter-过滤数组"><a href="#3-filter-过滤数组" class="headerlink" title="3.filter  过滤数组"></a>3.filter  过滤数组</h4><p>语法: 数组名.filter(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来过滤数组的</p>
<p>返回值: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-every-判断数组是不是满足所有条件"><a href="#4-every-判断数组是不是满足所有条件" class="headerlink" title="4.every  判断数组是不是满足所有条件"></a>4.every  判断数组是不是满足所有条件</h4><p>语法: 数组名.every(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> 只有所有的都满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要有一个不满足返回的就是<span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值 注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //every">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-some（）-数组中有没有满足条件的"><a href="#5-some（）-数组中有没有满足条件的" class="headerlink" title="5.some（） 数组中有没有满足条件的"></a>5.some（） 数组中有没有满足条件的</h4><p>语法: 数组名.some(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> 只有有一个满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要都不满足返回的就是<span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res);//true<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="6-find（）用来获取数组中满足条件的第一个数据"><a href="#6-find（）用来获取数组中满足条件的第一个数据" class="headerlink" title="6.find（）用来获取数组中满足条件的第一个数据"></a>6.find（）用来获取数组中满足条件的第一个数据</h4><p>语法: 数组名.find(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来获取数组中满足条件的数据</p>
<p>返回值: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res)//4<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="7-reduce（）叠加后的效果"><a href="#7-reduce（）叠加后的效果" class="headerlink" title="7.reduce（）叠加后的效果"></a>7.reduce（）叠加后的效果</h4><p>语法: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p>
<ul>
<li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来叠加的</p>
<p>返回值: 就是叠加后的结果</p>
<p>注意: 以return的形式书写返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //reduce">var arr = [1, 2, 3, 4, 5]<br>var res = arr.reduce(function (prev, item) &#123;<br>    return prev *= item<br>&#125;, 1)<br>console.log(res);//120<br><br></code></pre></td></tr></table></figure>

<h2 id="21-js-字符串常用方法"><a href="#21-js-字符串常用方法" class="headerlink" title="21 js 字符串常用方法"></a>21 js 字符串常用方法</h2><h3 id="1-获取字符串长度"><a href="#1-获取字符串长度" class="headerlink" title="1. 获取字符串长度"></a>1. 获取字符串长度</h3><p>JavaScript中的字符串有一个length属性，该属性可以用来获取字符串的长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-property">length</span>   <span class="hljs-comment">// 输出结果：5</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="2-获取字符串指定位置的值"><a href="#2-获取字符串指定位置的值" class="headerlink" title="2. 获取字符串指定位置的值"></a>2. 获取字符串指定位置的值</h3><p>charAt()和charCodeAt()方法都可以通过索引来获取指定位置的值：</p>
<ul>
<li>charAt() 方法获取到的是指定位置的字符；</li>
<li>charCodeAt()方法获取的是指定位置字符的Unicode值。</li>
</ul>
<h4 id="（1）charAt"><a href="#（1）charAt" class="headerlink" title="（1）charAt()"></a>（1）charAt()</h4><p>charAt() 方法可以返回指定位置的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">charAt</span>(index)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>index表示字符在字符串中的索引值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 输出结果：e </span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们知道，字符串也可以通过索引值来直接获取对应字符，那它和charAt()有什么区别呢？来看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 输出结果：e </span><br>str[<span class="hljs-number">1</span>]         <span class="hljs-comment">// 输出结果：e </span><br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出结果：&#x27;&#x27; </span><br>str[<span class="hljs-number">5</span>]         <span class="hljs-comment">// 输出结果：undefined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>可以看到，当index的取值不在str的长度范围内时，str[index]会返回undefined，而charAt(index)会返回空字符串；除此之外，str[index]不兼容ie6-ie8，charAt(index)可以兼容。</p>
<h4 id="（2）charCodeAt"><a href="#（2）charCodeAt" class="headerlink" title="（2）charCodeAt()"></a>（2）charCodeAt()</h4><p><code>charCodeAt()</code>：该方法会返回指定索引位置字符的 Unicode 值，返回值是 0 - 65535 之间的整数，表示给定索引处的 UTF-16 代码单元，如果指定位置没有字符，将返回 <strong>NaN</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// &quot;b&quot; --&gt; 98</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过这个方法，可以获取字符串中指定Unicode编码值范围的字符。比如，数字0～9的Unicode编码范围是: 48～57，可以通过这个方法来筛选字符串中的数字，当然如果你更熟悉正则表达式，会更方便。</p>
<h3 id="3-检索字符串是否包含特定序列"><a href="#3-检索字符串是否包含特定序列" class="headerlink" title="3. 检索字符串是否包含特定序列"></a>3. 检索字符串是否包含特定序列</h3><p>这5个方法都可以用来检索一个字符串中是否包含特定的序列。其中前两个方法得到的指定元素的索引值，并且只会返回第一次匹配到的值的位置。后三个方法返回的是布尔值，表示是否匹配到指定的值。</p>
<p>注意：这5个方法都对大小写敏感！</p>
<h4 id="（1）indexOf"><a href="#（1）indexOf" class="headerlink" title="（1）indexOf()"></a>（1）indexOf()</h4><p><code>indexOf()</code>：查找某个字符，<strong>有则返回第一次匹配到的位置</strong>，否则返回-1，其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">indexOf</span>(searchvalue,fromindex)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，规定需检索的字符串值；</li>
<li>fromindex：可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 string.length - 1。如省略该，则从字符串的首字符开始检索。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefgabc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;a&quot;</span>));   <span class="hljs-comment">// 输出结果：0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;z&quot;</span>));   <span class="hljs-comment">// 输出结果：-1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// 输出结果：9</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）lastIndexOf"><a href="#（2）lastIndexOf" class="headerlink" title="（2）lastIndexOf()"></a>（2）lastIndexOf()</h4><p><code>lastIndexOf()</code>：查找某个字符，有则返回最后一次匹配到的位置，否则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcabc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;a&quot;</span>));  <span class="hljs-comment">// 输出结果：3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;z&quot;</span>));  <span class="hljs-comment">// 输出结果：-1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法和indexOf()类似，只是查找的顺序不一样，indexOf()是正序查找，lastIndexOf()是逆序查找。</p>
<h4 id="（3）includes"><a href="#（3）includes" class="headerlink" title="（3）includes()"></a>（3）includes()</h4><p><code>includes()</code>：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。该方法的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">includes</span>(searchvalue, start)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要查找的字符串；</li>
<li>start：可选，设置从那个位置开始查找，默认为 0。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;o&#x27;</span>)  <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;z&#x27;</span>)  <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 输出结果：false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（4）startsWith"><a href="#（4）startsWith" class="headerlink" title="（4）startsWith()"></a>（4）startsWith()</h4><p><code>startsWith()</code>：该方法用于检测字符串<strong>是否以指定的子字符串开始</strong>。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Helle&#x27;</span>) <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;wo&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 输出结果：true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（5）endsWith"><a href="#（5）endsWith" class="headerlink" title="（5）endsWith()"></a>（5）endsWith()</h4><p><code>endsWith()</code>：该方法用来判断当前字符串<strong>是否是以指定的子字符串结尾</strong>。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">endsWith</span>(searchvalue, length)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要搜索的子字符串；</li>
<li>length： 设置字符串的长度，默认值为原始字符串长度 string.length。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)       <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;llo&#x27;</span>)     <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;llo&#x27;</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出结果：true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>可以看到，当第二个参数设置为5时，就会从字符串的前5个字符中进行检索，所以会返回true。</p>
<h3 id="4-连接多个字符串"><a href="#4-连接多个字符串" class="headerlink" title="4. 连接多个字符串"></a>4. 连接多个字符串</h3><p>concat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">concat</span>(string1, string2, ..., stringX)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>其中参数 string1, string2, …, stringX 是必须的，他们将被连接为一个字符串的一个或多个字符串对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;efg&quot;</span>));          <span class="hljs-comment">//输出结果：&quot;abcefg&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;efg&quot;</span>,<span class="hljs-string">&quot;hijk&quot;</span>)); <span class="hljs-comment">//输出结果：&quot;abcefghijk&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>虽然concat()方法是专门用来拼接字符串的，但是在开发中使用最多的还是加操作符+，因为其更加简单。</p>
<h3 id="5-字符串分割成数组"><a href="#5-字符串分割成数组" class="headerlink" title="5. 字符串分割成数组"></a>5. 字符串分割成数组</h3><p>split() 方法用于把一个字符串分割成字符串数组。该方法不会改变原始字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">split</span>(separator,limit)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>separator：必需。字符串或正则表达式，从该参数指定的地方分割 string。</li>
<li>limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;c&quot;</span>);    <span class="hljs-comment">// 输出结果：[&quot;ab&quot;, &quot;def&quot;]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">4</span>)   <span class="hljs-comment">// 输出结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] </span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果把空字符串用作 separator，那么字符串中的每个字符之间都会被分割。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);     <span class="hljs-comment">// 输出结果：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>其实在将字符串分割成数组时，可以同时拆分多个分割符，使用正则表达式即可实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-string">&quot;apples,bananas;cherries&quot;</span><br><span class="hljs-keyword">const</span> fruits = list.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[,;]/</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits);  <span class="hljs-comment">// 输出结果：[&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="6-截取字符串"><a href="#6-截取字符串" class="headerlink" title="6. 截取字符串"></a>6. 截取字符串</h3><p>substr()、substring()和 slice() 方法都可以用来截取字符串。</p>
<h4 id="（1）-slice"><a href="#（1）-slice" class="headerlink" title="（1） slice()"></a>（1） slice()</h4><p>slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">slice</span>(start,end)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。</li>
<li>end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</li>
</ul>
<p>上面说了，如果start是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdef&quot; </span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);     <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; </span><br>str.<span class="hljs-title function_">slice</span>();      <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; </span><br>str.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">2</span>);    <span class="hljs-comment">// 输出结果：&quot;fg&quot;</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h4 id="（2）-substr"><a href="#（2）-substr" class="headerlink" title="（2） substr()"></a>（2） substr()</h4><p>substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">substr</span>(start,length)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start	必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</li>
<li>length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; </span><br>str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; 相当于截取[1,str.length-1]</span><br>str.<span class="hljs-title function_">substr</span>();    <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; 相当于截取[0,str.length-1]</span><br>str.<span class="hljs-title function_">substr</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;g&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）-substring"><a href="#（3）-substring" class="headerlink" title="（3） substring()"></a>（3） substring()</h4><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">substring</span>(<span class="hljs-keyword">from</span>, to)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。</li>
<li>to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</li>
</ul>
<p><strong>注意：</strong> 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">// 输出结果：&quot;bcdef&quot; [1,6)</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; [1,str.length-1]</span><br>str.<span class="hljs-title function_">substring</span>();    <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; [0,str.length-1]</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出结果 &quot;bcdef&quot; [1,6)</span><br>str.<span class="hljs-title function_">substring</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h3 id="7-字符串大小写转换"><a href="#7-字符串大小写转换" class="headerlink" title="7. 字符串大小写转换"></a>7. 字符串大小写转换</h3><p>toLowerCase() 和 toUpperCase()方法可以用于字符串的大小写转换。</p>
<h4 id="（1）toLowerCase"><a href="#（1）toLowerCase" class="headerlink" title="（1）toLowerCase()"></a>（1）toLowerCase()</h4><p><code>toLowerCase()</code>：该方法用于把字符串转换为小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;adABDndj&quot;</span>;<br>str.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// 输出结果：&quot;adabdndj&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）toUpperCase"><a href="#（2）toUpperCase" class="headerlink" title="（2）toUpperCase()"></a>（2）toUpperCase()</h4><p><code>toUpperCase()</code>：该方法用于把字符串转换为大写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;adABDndj&quot;</span>;<br>str.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// 输出结果：&quot;ADABDNDJ&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们可以用这个方法来将字符串中第一个字母变成大写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> word = <span class="hljs-string">&#x27;apple&#x27;</span><br>word = word[<span class="hljs-number">0</span>].<span class="hljs-title function_">toUpperCase</span>() + word.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(word) <span class="hljs-comment">// 输出结果：&quot;Apple&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="8-字符串模式匹配"><a href="#8-字符串模式匹配" class="headerlink" title="8. 字符串模式匹配"></a>8. 字符串模式匹配</h3><p>replace()、match()和search()方法可以用来匹配或者替换字符。</p>
<h4 id="（1）replace"><a href="#（1）replace" class="headerlink" title="（1）replace()"></a>（1）replace()</h4><p><code>replace()</code>：该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">replace</span>(searchvalue, newvalue)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需。规定子字符串或要替换的模式的 RegExp 对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</li>
<li>newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>) <span class="hljs-comment">// 输出结果：abzdef</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>执行一个全局替换, 忽略大小写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;Mr Blue has a blue house and a blue car&quot;</span>;<br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/blue/gi</span>, <span class="hljs-string">&quot;red&quot;</span>);    <span class="hljs-comment">// 输出结果：&#x27;Mr red has a red house and a red car&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p>
<h4 id="（2）match"><a href="#（2）match" class="headerlink" title="（2）match()"></a>（2）match()</h4><p><code>match()</code>：该方法用于在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">match</span>(regexp)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法的参数 regexp 是必需的，规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。</p>
<p><strong>注意：</strong> 该方法返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-string">&quot;c&quot;</span>)) <span class="hljs-comment">// [&quot;c&quot;, index: 2, input: &quot;abcdef&quot;, groups: undefined]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）search"><a href="#（3）search" class="headerlink" title="（3）search()"></a>（3）search()</h4><p><code>search()</code>方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">search</span>(searchvalue)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法的参数 regex 可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。</p>
<p><strong>注意：</strong> 要执行忽略大小写的检索，请追加标志 i。该方法不执行全局匹配，它将忽略标志 g，也就是只会返回第一次匹配成功的结果。如果没有找到任何匹配的子串，则返回 -1。</p>
<p><strong>返回值：</strong> 返回 str 中第一个与 regexp 相匹配的子串的起始位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/bcd/</span>)   <span class="hljs-comment">// 输出结果：1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="9-移除字符串收尾空白符"><a href="#9-移除字符串收尾空白符" class="headerlink" title="9. 移除字符串收尾空白符"></a>9. 移除字符串收尾空白符</h3><p>trim()、trimStart()和trimEnd()这三个方法可以用于移除字符串首尾的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。</p>
<h4 id="（1）trim"><a href="#（1）trim" class="headerlink" title="（1）trim()"></a>（1）trim()</h4><p>trim() 方法用于移除字符串首尾空白符，该方法不会改变原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;  abcdef  &quot;</span><br>str.<span class="hljs-title function_">trim</span>()    <span class="hljs-comment">// 输出结果：&quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法不适用于null、undefined、Number类型。</p>
<h4 id="（2）trimStart"><a href="#（2）trimStart" class="headerlink" title="（2）trimStart()"></a>（2）trimStart()</h4><p>trimStart() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的开头删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br><br>s.<span class="hljs-title function_">trimStart</span>()   <span class="hljs-comment">// &quot;abc  &quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）trimEnd"><a href="#（3）trimEnd" class="headerlink" title="（3）trimEnd()"></a>（3）trimEnd()</h4><p>trimEnd() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的结尾删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br><br>s.<span class="hljs-title function_">trimEnd</span>()   <span class="hljs-comment">// &quot;  abc&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="10-获取字符串本身"><a href="#10-获取字符串本身" class="headerlink" title="10. 获取字符串本身"></a>10. 获取字符串本身</h3><p>valueOf()和toString()方法都会返回字符串本身的值，感觉用处不大。</p>
<h4 id="（1）valueOf"><a href="#（1）valueOf" class="headerlink" title="（1）valueOf()"></a>（1）valueOf()</h4><p><code>valueOf()</code>：返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">valueOf</span>()) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）toString"><a href="#（2）toString" class="headerlink" title="（2）toString()"></a>（2）toString()</h4><p><code>toString()</code>：返回字符串对象本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="11-重复一个字符串"><a href="#11-重复一个字符串" class="headerlink" title="11. 重复一个字符串"></a>11. 重复一个字符串</h3><p>repeat() 方法返回一个新字符串，表示将原字符串重复n次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)     <span class="hljs-comment">// 输出结果：&quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 输出结果：&quot;hellohello&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">0</span>)    <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是小数，会向下取整：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2.9</span>) <span class="hljs-comment">// 输出结果：&quot;nana&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是负数或者Infinity，会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-title class_">Infinity</span>)   <span class="hljs-comment">// RangeError</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(-<span class="hljs-number">1</span>)         <span class="hljs-comment">// RangeError</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(-<span class="hljs-number">0.9</span>)   <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是NaN，就等同于 0：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-title class_">NaN</span>)    <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果repeat的参数是字符串，则会先转换成数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-string">&#x27;na&#x27;</span>)   <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-string">&#x27;3&#x27;</span>)    <span class="hljs-comment">// 输出结果：&quot;nanana&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="12-补齐字符串长度"><a href="#12-补齐字符串长度" class="headerlink" title="12. 补齐字符串长度"></a>12. 补齐字符串长度</h3><p>padStart()和padEnd()方法用于补齐字符串的长度。如果某个字符串不够指定长度，会在头部或尾部补全。</p>
<h4 id="（1）padStart"><a href="#（1）padStart" class="headerlink" title="（1）padStart()"></a>（1）padStart()</h4><p><code>padStart()</code>用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 </p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;x&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;ababx&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;abax&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果省略第二个参数，默认使用空格补全长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// &#x27;   x&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>padStart()的常见用途是为数值补全指定位数，笔者最近做的一个需求就是将返回的页数补齐为三位，比如第1页就显示为001，就可以使用该方法来操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;1&quot;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)   <span class="hljs-comment">// 输出结果： &#x27;001&#x27;</span><br><span class="hljs-string">&quot;15&quot;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)  <span class="hljs-comment">// 输出结果： &#x27;015&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）padEnd"><a href="#（2）padEnd" class="headerlink" title="（2）padEnd()"></a>（2）padEnd()</h4><p><code>padEnd()</code>用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xabab&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xaba&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="13-字符串转为数字"><a href="#13-字符串转为数字" class="headerlink" title="13. 字符串转为数字"></a>13. 字符串转为数字</h3><p>parseInt()和parseFloat()方法都用于将字符串转为数字。</p>
<h4 id="（1）parseInt"><a href="#（1）parseInt" class="headerlink" title="（1）parseInt()"></a>（1）parseInt()</h4><p>parseInt() 方法用于可解析一个字符串，并返回一个整数。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(string, radix)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>string：必需。要被解析的字符串。</li>
<li>radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</li>
</ul>
<p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>);			  <span class="hljs-comment">// 输出结果：10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;17&quot;</span>,<span class="hljs-number">8</span>);		  <span class="hljs-comment">// 输出结果：15 (8+7)</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;010&quot;</span>);		  <span class="hljs-comment">// 输出结果：10 或 8</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>当参数 radix 的值以 “0x” 或 “0X” 开头，将以 16 为基数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0x10&quot;</span>)      <span class="hljs-comment">// 输出结果：16</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;50&quot;</span>, <span class="hljs-number">1</span>)      <span class="hljs-comment">// 输出结果：NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;50&quot;</span>, <span class="hljs-number">40</span>)     <span class="hljs-comment">// 输出结果：NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>只有字符串中的第一个数字会被返回，当遇到第一个不是数字的字符为止:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;40 4years&quot;</span>)   <span class="hljs-comment">// 输出结果：40</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果字符串的第一个字符不能被转换为数字，就会返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;new100&quot;</span>)     <span class="hljs-comment">// 输出结果：NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>字符串开头和结尾的空格是允许的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;  60  &quot;</span>)    <span class="hljs-comment">// 输出结果： 60</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）parseFloat"><a href="#（2）parseFloat" class="headerlink" title="（2）parseFloat()"></a>（2）parseFloat()</h4><p>parseFloat() 方法可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(string)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>parseFloat 将它的字符串参数解析成为浮点数并返回。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.00&quot;</span>)      <span class="hljs-comment">// 输出结果：10.00</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.01&quot;</span>)      <span class="hljs-comment">// 输出结果：10.01</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;-10.01&quot;</span>)     <span class="hljs-comment">// 输出结果：-10.01</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;40.5 years&quot;</span>) <span class="hljs-comment">// 输出结果：40.5</span><br><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;new40.5&quot;</span>)    <span class="hljs-comment">// 输出结果：NaN</span><br></code></pre></td></tr></table></figure>

<h2 id="22-JS-判断数据类型的-8-种方式"><a href="#22-JS-判断数据类型的-8-种方式" class="headerlink" title="22 JS 判断数据类型的 8 种方式"></a>22 JS 判断数据类型的 8 种方式</h2><h3 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h3><ul>
<li>只能识别基础类型和引用类型</li>
</ul>
<p>注意：<code>null</code>、 <code>NaN</code>、 <code>document.all</code> 的判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">all</span>); <span class="hljs-comment">// undefined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2、constructor"><a href="#2、constructor" class="headerlink" title="2、constructor"></a>2、constructor</h3><ul>
<li><code>constructor</code> 指向创建该实例对象的构造函数</li>
</ul>
<p>注意 <code>null</code> 和 <code>undefined</code> 没有 <code>constructor</code>，以及 <code>constructor</code> 可以被改写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;云牧&quot;</span>.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// [Function: fn]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3、instanceof"><a href="#3、instanceof" class="headerlink" title="3、instanceof"></a>3、instanceof</h3><ul>
<li>语法：<code>obj instanceof Type</code></li>
<li>功能：判断 <code>obj</code> 是不是 <code>Type</code> 类的实例，只可用来判断引用数据</li>
<li>实现思路： <code>Type</code> 的原型对象是否是 <code>obj</code> 的原型链上的某个对象</li>
<li>注意：右操作数必须是函数或者 class</li>
</ul>
<p>手写 <code>instanceof</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">Fn, obj</span>) &#123;<br>  <span class="hljs-comment">// 获取该函数显示原型</span><br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-comment">// 获取obj的隐式原型</span><br>  <span class="hljs-keyword">let</span> proto = obj.<span class="hljs-property">__proto__</span>;<br>  <span class="hljs-comment">// 遍历原型链</span><br>  <span class="hljs-keyword">while</span> (proto) &#123;<br>    <span class="hljs-comment">// 检测原型是否相等</span><br>    <span class="hljs-keyword">if</span> (proto === prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不等于则继续往深处查找</span><br>    proto = proto.<span class="hljs-property">__proto__</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4、isPrototypeof"><a href="#4、isPrototypeof" class="headerlink" title="4、isPrototypeof"></a>4、isPrototypeof</h3><ul>
<li>是否在实例对象的原型链上</li>
<li>功能基本等同于 <code>instanceof</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isPrototypeOf</span>(&#123;&#125;)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(&#123;&#125;)); <span class="hljs-comment">// true  期望左操作数是一个原型，&#123;&#125; 原型链能找到 Object.prototype</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5、Object-prototype-toString"><a href="#5、Object-prototype-toString" class="headerlink" title="5、Object.prototype.toString"></a>5、Object.prototype.toString</h3><ul>
<li>利用函数动态 this 的特性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">typeOf</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-string">&quot;1&quot;</span>)); <span class="hljs-comment">// String</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// Boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// Null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// Undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-title class_">Symbol</span>(<span class="hljs-number">1</span>))); <span class="hljs-comment">// Symbol</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(&#123;&#125;)); <span class="hljs-comment">// Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>([])); <span class="hljs-comment">// Array</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;)); <span class="hljs-comment">// Function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())); <span class="hljs-comment">// Date</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>())); <span class="hljs-comment">// RegExp</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6、鸭子类型检测"><a href="#6、鸭子类型检测" class="headerlink" title="6、鸭子类型检测"></a>6、鸭子类型检测</h3><ul>
<li>检查自身属性的类型或者执行结果的类型</li>
<li>通常作为候选方案</li>
<li>例子：<code>kindof</code> 与 <code>p-is-promise</code> 库</li>
</ul>
<p>p-is-promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObject</span> = value =&gt;<br>  value !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;function&quot;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPromise</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ||<br>    (<span class="hljs-title function_">isObject</span>(value) &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">then</span> === <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">catch</span> === <span class="hljs-string">&quot;function&quot;</span>)<br>  );<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>kindof：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">kindof</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">var</span> type;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span>;<br><br>  <span class="hljs-keyword">switch</span> ((type = <span class="hljs-keyword">typeof</span> obj)) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;object&quot;</span>:<br>      <span class="hljs-keyword">switch</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj)) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;[object RegExp]&quot;</span>:<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;regexp&quot;</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;[object Date]&quot;</span>:<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;date&quot;</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;[object Array]&quot;</span>:<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;array&quot;</span>;<br>      &#125;<br><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> type;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="7、Symbol-toStringTag"><a href="#7、Symbol-toStringTag" class="headerlink" title="7、Symbol.toStringTag"></a>7、Symbol.toStringTag</h3><ul>
<li>原理：<code>Object.prototype.toString</code> 会读取该值</li>
<li>适用场景：需自定义类型</li>
<li>注意事项：兼容性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyArray&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arr)); <span class="hljs-comment">// [object MyArray]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="8、等比较"><a href="#8、等比较" class="headerlink" title="8、等比较"></a>8、等比较</h3><ul>
<li>原理：与某个固定值进行比较</li>
<li>适用场景：<code>undefined</code>、 <code>window</code>、 <code>document</code>、 <code>null</code> 等</li>
</ul>
<p>underscore.js：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d329bc51315a419082fc0bfe75f62390~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><code>void 0</code> 始终返回 <code>undefined</code>，<code>void</code> 后面接任意值都是返回 <code>undefined</code>， 这是为了兼容 IE，因为在 IE 中 <code>undefined</code> 值可以被改写</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>方法</th>
<th>基础数据类型</th>
<th>引用类型</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>typeof</td>
<td>√</td>
<td>×</td>
<td>NaN、object、document.all</td>
</tr>
<tr>
<td>constructor</td>
<td>√ 部分</td>
<td>√</td>
<td>可以被改写</td>
</tr>
<tr>
<td>instanceof</td>
<td>×</td>
<td>√</td>
<td>多窗口，右边构造函数或者class</td>
</tr>
<tr>
<td>isPrototypeof</td>
<td>×</td>
<td>√</td>
<td>小心 null 和 undefined</td>
</tr>
<tr>
<td>toString</td>
<td>√</td>
<td>√</td>
<td>小心内置原型</td>
</tr>
<tr>
<td>鸭子类型</td>
<td>-</td>
<td>√</td>
<td>不得已兼容</td>
</tr>
<tr>
<td>Symbol.toString Tag</td>
<td>×</td>
<td>√</td>
<td>识别自定义对象</td>
</tr>
<tr>
<td>等比较</td>
<td>√</td>
<td>√</td>
<td>特殊对象</td>
</tr>
</tbody></table>
<h3 id="加餐：ES6-增强的-NaN"><a href="#加餐：ES6-增强的-NaN" class="headerlink" title="加餐：ES6 增强的 NaN"></a>加餐：ES6 增强的 NaN</h3><h4 id="NaN-和-Number-NaN-特点"><a href="#NaN-和-Number-NaN-特点" class="headerlink" title="NaN 和 Number.NaN 特点"></a>NaN 和 Number.NaN 特点</h4><ol>
<li><code>typeof</code> 判断类型是数字</li>
<li>自己不等于自己</li>
</ol>
<h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h4><ul>
<li>如果非数字，隐式转换传入结果如果是 <code>NaN</code>，就返回 <code>true</code>，反之返回 <code>false</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(&#123;&#125;)); <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN"></a>Number.isNaN</h4><ul>
<li>判断一个值是否是数字，并且值是否等于 <code>NaN</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(&#123;&#125;)); <span class="hljs-comment">// false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>综合垫片（如果不支持 <code>Number.isNaN</code> 的话）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!(<span class="hljs-string">&quot;isNaN&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">Number</span>)) &#123;<br>  <span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(val);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="indexOf-和-includes"><a href="#indexOf-和-includes" class="headerlink" title="indexOf 和 includes"></a>indexOf 和 includes</h4><ul>
<li><code>indexOf</code> 不可查找 <code>NaN</code>，<code>includes</code> 则可以</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-title class_">NaN</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// -1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h2 id="23-Javascript-toString-方法原理"><a href="#23-Javascript-toString-方法原理" class="headerlink" title="23 Javascript toString 方法原理"></a>23 Javascript toString 方法原理</h2><p>toString方法的作用是返回一个对象的字符串形式。我们还是分不同数据类型来讨论。</p>
<p>1.Srting，字符串类型直接原始值返回；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;123&#x27;</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></td></tr></table></figure>

<p>2.Boolean，布尔值类型返回对应的字符形式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">true</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;true&#x27;</span><br><span class="hljs-literal">false</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;false&#x27;</span><br></code></pre></td></tr></table></figure>

<p>3.Number，数值类型情况有点复杂；</p>
<p>a.对于NaN， Infinity，-Infinity，返回字符形式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;NaN&#x27;</span><br><span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;Infinity&#x27;</span><br><br>+<span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// Infinity</span><br>(+<span class="hljs-title class_">Infinity</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;Infinity&#x27;</span><br><br>(-<span class="hljs-title class_">Infinity</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;-Infinity&#x27;</span><br>-<span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// -Infinity</span><br></code></pre></td></tr></table></figure>

<p>b.对于整数，加引号直接返回。直接调用toString方法会报错，因为整数后面的点会被识别为小数点，加个括号就好；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">123.</span><span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// Uncaught SyntaxError: Invalid or unexpected token</span><br>(<span class="hljs-number">123</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>

<p>c.对于浮点数，可以直接调用toString方法，直接加引号返回；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.23</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;1.23&#x27;</span><br></code></pre></td></tr></table></figure>

<p>d.对于一些前面有正负号的数值，要加括号再调用toString方法，否则会先运行toString()方法，再添加正负号，隐式转换为数字；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-number">1.23</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 1.23</span><br>(+<span class="hljs-number">1.23</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;1.23&#x27;</span><br><br>-<span class="hljs-number">1.23</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// -1.23</span><br>(-<span class="hljs-number">1.23</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;-1.23&#x27;</span><br></code></pre></td></tr></table></figure>

<p>e.数值类型的toString方法还可以接收一个表示转换基数(radix)的可选参数。如果不指定此参数，转换规则将是基于十进制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// &#x27;NaN&#x27;</span><br><span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// &#x27;Infinity&#x27;</span><br><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;17&#x27;</span><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// &#x27;10001&#x27;</span><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>); <span class="hljs-comment">// &#x27;21&#x27;</span><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>); <span class="hljs-comment">// &#x27;11&#x27;</span><br></code></pre></td></tr></table></figure>

<p>4.null和undefined，没有toString方法，直接调用会报错，但可以使用call方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">null</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 错误</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;[object Null]&quot;</span><br><br><span class="hljs-literal">undefined</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 错误</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><br></code></pre></td></tr></table></figure>

<p>5.复合类型，返回 “[object type]”，其中 type 是对象的类型。数组、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。</p>
<p>a.内置的对象和自定义的对象，返回”[object Object]”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;josavion&#x27;</span>,<br>&#125;;<br>obj.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;josavion&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">/* &quot;function Person() &#123;</span><br><span class="hljs-comment">                        this.name = &#x27;josavion&#x27;;</span><br><span class="hljs-comment">                      &#125;&quot; */</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Object() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>b.函数Function类型返回函数代码;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;<br>test.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">/* &quot;function test()&#123;</span><br><span class="hljs-comment">                        console.log(&#x27;test&#x27;);</span><br><span class="hljs-comment">                     &#125;&quot; */</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">haha</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br>haha.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;() =&gt; &#123;&#125;&quot;</span><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Function() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>c.数组Array类型返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;&quot;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;&quot; (数组的toString方法被改写了)</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Array() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>d.时间Date类型返回表示当前时区的时间的字符串表示；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;Wed Jun 24 2020 17:22:01 GMT+0800 (中国标准时间)&quot;</span><br><br><span class="hljs-title class_">Date</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Date() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>e.正则表达式RegExp类型返回正则表达式字面量的字符串表示；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">/xyz/i.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;/xyz/i&quot;</span><br><br><span class="hljs-title class_">RegExp</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function RegExp() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>f.错误Error类型；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>err.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;Error: test&quot;</span><br><br><span class="hljs-title class_">Error</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Error() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>6.toString() 的应用。Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">数值：返回[object <span class="hljs-title class_">Number</span>]。<br>字符串：返回[object <span class="hljs-title class_">String</span>]。<br>布尔值：返回[object <span class="hljs-title class_">Boolean</span>]。<br><span class="hljs-literal">undefined</span>：返回[object <span class="hljs-title class_">Undefined</span>]。<br><span class="hljs-literal">null</span>：返回[object <span class="hljs-title class_">Null</span>]。<br>数组：返回[object <span class="hljs-title class_">Array</span>]。<br><span class="hljs-variable language_">arguments</span> 对象：返回[object <span class="hljs-title class_">Arguments</span>]。<br>函数：返回[object <span class="hljs-title class_">Function</span>]。<br><span class="hljs-title class_">Error</span> 对象：返回[object <span class="hljs-title class_">Error</span>]。<br><span class="hljs-title class_">Date</span> 对象：返回[object <span class="hljs-title class_">Date</span>]。<br><span class="hljs-title class_">RegExp</span> 对象：返回[object <span class="hljs-title class_">RegExp</span>]。<br>其他对象：返回[object <span class="hljs-title class_">Object</span>]。<br></code></pre></td></tr></table></figure>

<h2 id="24-promise的api"><a href="#24-promise的api" class="headerlink" title="24 promise的api"></a>24 promise的api</h2><h3 id="1-Promise-then"><a href="#1-Promise-then" class="headerlink" title="1. Promise#then"></a>1. <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020">Promise</a>#then</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">promise.<span class="hljs-keyword">then</span>(onFulfilled, onRejected);<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><strong>示例：Promise#then</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">var promise = new Promise(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(resolve, reject)</span></span> &#123;<br>    resolve(<span class="hljs-string">&quot;传递给then的值&quot;</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span></span> &#123;<br>    console.<span class="hljs-built_in">log</span>(value);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span></span> &#123;<br>    console.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">error</span>);<br>&#125;);<span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<p>这段代码创建一个promise对象，定义了处理onFulfilled和onRejected的函数（handler），然后返回这个promise对象。这个promise对象会在变为resolve或者reject的时候分别调用相应注册的回调函数。 </p>
<p>（1）当handler返回一个正常值的时候，这个值会传递给promise对象的onFulfilled方法。 </p>
<p>（2）定义的handler中产生异常的时候，这个值则会传递给promise对象的onRejected方法。</p>
<h3 id="2-Promise-catch"><a href="#2-Promise-catch" class="headerlink" title="2. Promise#catch"></a>2. Promise#catch</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">promise.<span class="hljs-keyword">catch</span>(onRejected); <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>等价于<code>promise.then(undefined, onRejected)</code> 的语法糖。<br><strong>示例：Promise#catch</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-title function_ invoke__">resolve</span>(<span class="hljs-string">&quot;要传递给then的值&quot;</span>);<br>&#125;);<br><br><br><br>promise.<span class="hljs-title function_ invoke__">then</span>(function(value) &#123;<br>    console.<span class="hljs-title function_ invoke__">log</span>(value);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>    console.<span class="hljs-title function_ invoke__">log</span>(error);<br>&#125;);<span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h3 id="3-Promise-resolve"><a href="#3-Promise-resolve" class="headerlink" title="3. Promise.resolve"></a>3. Promise.resolve</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-built_in">object</span>);<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<p><strong>示例：Promise.resolve</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">var taskName = <span class="hljs-string">&quot;task1&quot;</span>;<br><br>asyncTask(taskName).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span></span> &#123;<br>    console.<span class="hljs-built_in">log</span>(value);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span></span> &#123;<br>    console.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">error</span>);<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncTask</span><span class="hljs-params">(name)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> Promise.resolve(name).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span></span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Done! &quot;</span> + value;<br>    &#125;)<br>&#125;<span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure>

<p>根据接收到的参数不同，返回不同的promise对象。 </p>
<p>（1）接收到promise对象参数的时候：返回的还是接收到的promise对象 </p>
<p>（2）接收到thenable类型的对象的时候：返回一个新的promise对象，这个对象具有一个 then 方法 </p>
<p>（3）接收的参数为其他类型的时候（包括JavaScript对或null等）：返回一个将该对象作为值的新promise对象</p>
<h3 id="4-Promise-reject"><a href="#4-Promise-reject" class="headerlink" title="4. Promise.reject"></a>4. Promise.reject</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Promise.reject(<span class="hljs-built_in">object</span>)<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><strong>示例：Promise.reject</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">var r = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;error&quot;</span>));<br>console.log(r === <span class="hljs-built_in">Promise</span>.reject(r));       <span class="hljs-regexp">//</span> <span class="hljs-literal">false</span><br>var r = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;test&quot;</span>);<br>console.log(r === <span class="hljs-built_in">Promise</span>.resolve(r));      <span class="hljs-regexp">//</span> true12345<br></code></pre></td></tr></table></figure>

<p>和 Promise.resolve不同的是，即使Promise.reject接收到的参数是一个promise对象，该函数也还是会返回一个全新的promise对象。</p>
<h3 id="5-Promise-all"><a href="#5-Promise-all" class="headerlink" title="5. Promise.all"></a>5. Promise.all</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">Promise.all(promiseArray)1<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cobol">var p1 = Promise.resolve(1),<br>    p2 = Promise.resolve(2),<br>    p3 = Promise.resolve(3);<br>Promise.all([p1, p2, p3]).then(function(results) &#123;<br>    console.log(results);       // [1, 2, 3]<br>&#125;);123456<br></code></pre></td></tr></table></figure>

<p>生成并返回一个新的promise对象。 </p>
<p>参数传递promise数组中所有的promise对象都变为resolve的时候，该方法才会返回， 新创建的promise则会使用这些promise的值。 </p>
<p>如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象。</p>
<h3 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6. Promise.race"></a>6. Promise.race</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">Promise.all(promiseArray)1<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cobol">var p1 = Promise.resolve(1),<br>    p2 = Promise.resolve(2),<br>    p3 = Promise.resolve(3);<br><br><br><br>Promise.all([p1, p2, p3]).then(function(results) &#123;<br>    console.log(results);       // 1<br>&#125;);123456<br></code></pre></td></tr></table></figure>

<p>生成并返回一个新的promise对象。<br>参数 promise 数组中的任何一个promise对象如果变为resolve或者reject的话， 该函数就会返回，并使用这个promise对象的值进行resolve或者reject。</p>
<h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>为了增加代入感，本文从最为基础的一个应用实例开始探索：通过异步请求获取用户id，然后做一些处理。在平时大家都是习惯用回调或者事件来处理，下面我们看下 Promise 的处理方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>		<span class="hljs-comment">// 异步请求</span><br>		Y.<span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;/userid&#x27;</span>, &#123;<br>			<span class="hljs-attr">on</span>: &#123;<br>				<span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id, res</span>) &#123;<br>					<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(res).<span class="hljs-property">id</span>);<br>				&#125;<br>			&#125;<br>		&#125;);<br>	&#125;);<br>&#125;<br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/kebigicu/1/embed?js,console">JS Bin</a></p>
<p><code>getUserId</code> 方法返回一个 promise，可以通过它的 <code>then</code> 方法注册在 promise 异步操作成功时执行的回调。自然、表意的 API，用起来十分顺手。</p>
<p>满足这样一种使用场景的 Promise 是如何构建的呢？其实并不复杂，下面给出最基础的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>,<br>    	deferreds = [];<br>        <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>        deferreds.<span class="hljs-title function_">push</span>(onFulfilled);<br>    &#125;;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    	deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>    		<span class="hljs-title function_">deferred</span>(value);<br>    	&#125;);<br>    &#125;<br><br>    <span class="hljs-title function_">fn</span>(resolve);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码很短，逻辑也非常清晰：</p>
<ul>
<li>调用<code>then</code>方法，将想要在 Promise 异步操作成功时执行的回调放入 <code>deferreds</code> 队列；</li>
<li>创建 Promise 实例时传入函数被赋予一个函数类型的参数，即 <code>resolve</code>，用以在合适的时机触发异步操作成功。真正执行的操作是将 <code>deferreds</code> 队列中的回调一一执行；</li>
<li><code>resolve</code> 接收一个参数，即异步操作返回的结果，方便回调使用。</li>
</ul>
<p>有时需要注册多个回调，如果能够支持 jQuery 那样的链式操作就好了！事实上，这很容易：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>    deferreds.<span class="hljs-title function_">push</span>(onFulfilled);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这个小改进带来的好处非常明显，当真是一个大收益的小创新呢：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例2</span><br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth else with id</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/fedukaso/2/edit?js,console">JS Bin</a></p>
<h3 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h3><p>如果 promise 是同步代码，<code>resolve</code> 会先于 <code>then</code> 执行，这时 <code>deferreds</code> 队列还空无一物，更严重的是，后续注册的回调再也不会被执行了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例3</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>		<span class="hljs-title function_">resolve</span>(<span class="hljs-number">9876</span>);<br>	&#125;);<br>&#125;<br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/fenopelo/3/edit?js,console">JS Bin</a></p>
<p>此外，Promises&#x2F;A+ 规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。为解决这两个问题，可以通过 <code>setTimeout</code> 将 <code>resolve</code> 中执行回调的逻辑放置到 JS 任务队列末尾：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>    	    <span class="hljs-title function_">deferred</span>(value);<br>        &#125;);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h3><p>Hmm，好像存在一点问题：如果 Promise 异步操作已经成功，之后调用 <code>then</code> 注册的回调再也不会执行了，而这是不符合我们预期的。</p>
<p>解决这个问题，需要引入规范中所说的 States，即每个 Promise 存在三个互斥状态：pending、fulfilled、rejected，它们之间的关系是：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/a400b1f5.png" srcset="/blog/img/loading.gif" lazyload alt="states flow"></p>
<p>states flow</p>
<p>经过改进后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>    	value = <span class="hljs-literal">null</span>,<br>    	deferreds = [];<br>        <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>    	<span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        	deferreds.<span class="hljs-title function_">push</span>(onFulfilled);<br>        	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>        &#125;<br>        <span class="hljs-title function_">onFulfilled</span>(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">newValue</span>) &#123;<br>        value = newValue;<br>    	state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>                <span class="hljs-title function_">deferred</span>(value);<br>            &#125;);<br>        &#125;, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">fn</span>(resolve);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/lamewijo/2/edit?js,console">JS Bin</a></p>
<p><code>resolve</code> 执行时，会将状态设置为 fulfilled，在此之后调用 <code>then</code> 添加的新回调，都会立即执行。</p>
<p>似乎少了点什么，哦，是的，没有任何地方将 state 设为 rejected，这个问题稍后会聊，方便聚焦在核心代码上。</p>
<h3 id="串行-Promise"><a href="#串行-Promise" class="headerlink" title="串行 Promise"></a>串行 Promise</h3><p>在这一小节，将要探索的是 Promise 的 Killer Feature：<strong>串行 Promise</strong>，这是最为有趣也最为神秘的一个功能。</p>
<p>串行 Promise 是指在当前 promise 达到 fulfilled 状态后，即开始进行下一个 promise（后邻 promise）。例如获取用户 id 后，再根据用户 id 获取用户手机号等其他信息，这样的场景比比皆是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例4</span><br><br><span class="hljs-title function_">getUserId</span>()<br>    .<span class="hljs-title function_">then</span>(getUserMobileById)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">mobile</span>) &#123;<br>	    <span class="hljs-comment">// do sth with mobile</span><br>    &#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserMobileById</span>(<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>	    Y.<span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;/usermobile/&#x27;</span> + id, &#123;<br>	        <span class="hljs-attr">on</span>: &#123;<br>	            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">i, o</span>) &#123;<br>	                <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(o).<span class="hljs-property">mobile</span>);<br>	            &#125;<br>	        &#125;<br>   	    &#125;);<br>	&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/pibicefe/2/edit?js,console">JS Bin</a></p>
<p>这个 feature 实现的难点在于：如何衔接当前 promise 和后邻 promise。</p>
<p>首先对 <code>then</code> 方法进行改造：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-title function_">handle</span>(&#123;<br>            <span class="hljs-attr">onFulfilled</span>: onFulfilled || <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">resolve</span>: resolve<br>        &#125;);<br>    &#125;);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">deferred</span>) &#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        deferreds.<span class="hljs-title function_">push</span>(deferred);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> ret = deferred.<span class="hljs-title function_">onFulfilled</span>(value);<br>    deferred.<span class="hljs-title function_">resolve</span>(ret);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>then</code> 方法改变很多，这是一段暗藏玄机的代码：</p>
<ul>
<li><code>then</code> 方法中，创建了一个新的 Promise 实例，并作为返回值，这类 promise，权且称作 bridge promise。这是串行 Promise 的基础。另外，因为返回类型一致，之前的链式执行仍然被支持；</li>
<li><code>handle</code> 方法是当前 promise 的内部方法。这一点很重要，看不懂的童鞋可以去补充下闭包的知识。<code>then</code> 方法传入的形参 <code>onFullfilled</code>，以及创建新 Promise 实例时传入的 <code>resolve</code> 均被压入当前 promise 的 <code>deferreds</code> 队列中。所谓“巧妇难为无米之炊”，而这，正是衔接当前 promise 与后邻 promise 的“米”之所在。</li>
</ul>
<p>新增的 <code>handle</code> 方法，相比改造之前的 <code>then</code> 方法，仅增加了一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">deferred.<span class="hljs-title function_">resolve</span>(ret);<br></code></pre></td></tr></table></figure>

<p>这意味着当前 promise 异步操作成功后执行 <code>handle</code> 方法时，先执行 <code>onFulfilled</code> 方法，然后将其返回值作为实参执行 <code>resolve</code> 方法，而这标志着后邻 promise 异步操作成功，<strong>接力</strong>工作就这样完成啦！</p>
<p>以例 2 代码为例，串行 Promise 执行流如下：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/c7f62426.png" srcset="/blog/img/loading.gif" lazyload alt="promise series flow"></p>
<p>promise series flow</p>
<p>这就是所谓的串行 Promise？当然不是，这些改造只是为了为最后的冲刺做铺垫，它们在重构底层实现的同时，兼容了本文之前讨论的所有功能。接下来，画龙点睛之笔–最后一个方法 <code>resolve</code> 是这样被改造的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">var</span> then = newValue.<span class="hljs-property">then</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            then.<span class="hljs-title function_">call</span>(newValue, resolve);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>    value = newValue;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>            <span class="hljs-title function_">handle</span>(deferred);<br>        &#125;);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>啊哈，<code>resolve</code> 方法现在支持传入的参数是一个 Promise 实例了！以例 4 为例，执行步骤如下：</p>
<ol>
<li><code>getUserId</code> 生成的 promise （简称 <code>getUserId</code> promise）异步操作成功，执行其内部方法 <code>resolve</code>，传入的参数正是异步操作的结果 <code>userid</code>；</li>
<li>调用 <code>handle</code> 方法处理 <code>deferreds</code> 队列中的回调：<code>getUserMobileById</code> 方法，生成新的 promise（简称 <code>getUserMobileById</code> promise）；</li>
<li>执行之前由 <code>getUserId</code> promise 的 <code>then</code> 方法生成的 bridge promise 的 <code>resolve</code> 方法，传入参数为 <code>getUserMobileById</code> promise。这种情况下，会将该 <code>resolve</code> 方法传入 <code>getUserMobileById</code> promise 的 <code>then</code> 方法中，并直接返回；</li>
<li>在 <code>getUserMobileById</code> promise 异步操作成功时，执行其 <code>deferreds</code> 中的回调：<code>getUserId</code> bridge promise 的 <code>resolve</code> 方法；</li>
<li>最后，执行 <code>getUserId</code> bridge promise 的后邻 promise 的 <code>deferreds</code> 中的回调</li>
</ol>
<p>上述步骤实在有些复杂，主要原因是 bridge promise 的引入。不过正是得益于此，注册一个返回值也是 promise 的回调，从而实现异步操作串行的机制才得以实现。</p>
<p>一图胜千言，下图描述了例 4 的 Promise 执行流：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/3459d82b.png" srcset="/blog/img/loading.gif" lazyload alt="promise series flow"></p>
<p>promise series flow</p>
<h3 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h3><p>本节处理之前遗留的 rejected 状态问题。在异步操作失败时，标记其状态为 rejected，并执行注册的失败回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例5</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>		<span class="hljs-comment">// 异步请求</span><br>		Y.<span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;/userid/1&#x27;</span>, &#123;<br>			<span class="hljs-attr">on</span>: &#123;<br>				<span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id, res</span>) &#123;<br>                    <span class="hljs-keyword">var</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(res);<br>                    <span class="hljs-keyword">if</span> (o.<span class="hljs-property">status</span> === <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-title function_">resolve</span>(o.<span class="hljs-property">id</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 请求失败，返回错误信息</span><br>                        <span class="hljs-title function_">reject</span>(o.<span class="hljs-property">errorMsg</span>);<br>                    &#125;<br>				&#125;<br>			&#125;<br>		&#125;);<br>	&#125;);<br>&#125;<br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/padolebi/2/edit?js,console">JS Bin</a></p>
<p>有了之前处理 fulfilled 状态的经验，支持错误处理变得很容易。毫无疑问的是，这将加倍 code base，在注册回调、处理状态变更上都要加入新的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>    	value = <span class="hljs-literal">null</span>,<br>        deferreds = [];<br>        <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-title function_">handle</span>(&#123;<br>                <span class="hljs-attr">onFulfilled</span>: onFulfilled || <span class="hljs-literal">null</span>,<br>                <span class="hljs-attr">onRejected</span>: onRejected || <span class="hljs-literal">null</span>,<br>                <span class="hljs-attr">resolve</span>: resolve,<br>                <span class="hljs-attr">reject</span>: reject<br>            &#125;);<br>        &#125;);<br>    &#125;;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">deferred</span>) &#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>            deferreds.<span class="hljs-title function_">push</span>(deferred);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">var</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">onFulfilled</span> : deferred.<span class="hljs-property">onRejected</span>,<br>            ret;<br>        <span class="hljs-keyword">if</span> (cb === <span class="hljs-literal">null</span>) &#123;<br>            cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">resolve</span> : deferred.<span class="hljs-property">reject</span>;<br>            <span class="hljs-title function_">cb</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ret = <span class="hljs-title function_">cb</span>(value);<br>        deferred.<span class="hljs-title function_">resolve</span>(ret);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">newValue</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">var</span> then = newValue.<span class="hljs-property">then</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>                then.<span class="hljs-title function_">call</span>(newValue, resolve, reject);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>        value = newValue;<br>        <span class="hljs-title function_">finale</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>        state = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>        value = reason;<br>        <span class="hljs-title function_">finale</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">finale</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>                <span class="hljs-title function_">handle</span>(deferred);<br>            &#125;);<br>        &#125;, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">fn</span>(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>增加了新的 <code>reject</code> 方法，供异步操作失败时调用，同时抽出了 <code>resolve</code> 和 <code>reject</code> 共用的部分，形成 <code>finale</code> 方法。</p>
<p><strong>错误冒泡</strong>是上述代码已经支持，且非常实用的一个特性。在 <code>handle</code> 中发现没有指定异步操作失败的回调时，会直接将 bridge promise 设为 rejected 状态，如此达成执行后续失败回调的效果。这有利于简化串行 Promise 的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例6</span><br><br><span class="hljs-title function_">getUserId</span>()<br>    .<span class="hljs-title function_">then</span>(getUserMobileById)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">mobile</span>) &#123;<br>	    <span class="hljs-comment">// do sth else with mobile</span><br>    &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-comment">// getUserId或者getUerMobileById时出现的错误</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/joqamiko/3/edit?js,console">JS Bin</a></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用 <code>try-catch</code> 捕获错误，并将 bridge promise 设为 rejected 状态。<code>handle</code> 方法改造如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">deferred</span>) &#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        deferreds.<span class="hljs-title function_">push</span>(deferred);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">onFulfilled</span> : deferred.<span class="hljs-property">onRejected</span>,<br>        ret;<br>    <span class="hljs-keyword">if</span> (cb === <span class="hljs-literal">null</span>) &#123;<br>        cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">resolve</span> : deferred.<span class="hljs-property">reject</span>;<br>        <span class="hljs-title function_">cb</span>(value);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ret = <span class="hljs-title function_">cb</span>(value);<br>        deferred.<span class="hljs-title function_">resolve</span>(ret);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        deferred.<span class="hljs-title function_">reject</span>(e);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果在异步操作中，多次执行 <code>resolve</code> 或者 <code>reject</code> 会重复处理后续回调，可以通过内置一个标志位解决。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Promise 作为异步操作的一种 Monad，魔幻一般的 API 让人难以驾驭。本文从简单的基础实现起步，逐步添加内置状态、串行、失败处理&#x2F;失败冒泡、异常处理等关键特性，最终达到类似由 Forbes Lindesay 所完成的一个<a target="_blank" rel="noopener" href="https://github.com/then/promise/blob/master/core.js">简单 Promise 实现</a>的效果。在让我本人更加深刻理解 Promise 魔力之源的同时，希望为各位更加熟练的使用这一实用工具带来一些帮助。</p>
<h2 id="25-async和defer的区别"><a href="#25-async和defer的区别" class="headerlink" title="25 async和defer的区别"></a>25 async和defer的区别</h2><p>1.先来试个一句话解释仨，当浏览器碰到 <code>script</code> 脚本的时候：</p>
<ol>
<li><p><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>
<p>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
</li>
<li><p><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>
<p>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。</p>
</li>
<li><p><code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></p>
<p>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</p>
</li>
</ol>
<p>然后从实用角度来说呢，首先把所有脚本都丢到 <code>&lt;/body&gt;</code> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p>接着，我们来看一张图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/894d84e8a7e0497091a26e43e1a84237~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p>
<p>此图告诉我们以下几个要点：</p>
<ol>
<li><em>defer</em> 和 <em>async</em> 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>
<li>它俩的差别在于脚本下载完之后何时执行，显然 <em>defer</em> 是最接近我们对于应用脚本加载和执行的要求的</li>
<li>关于 <em>defer</em>，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>
<li><em>async</em> 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>
<li>仔细想想，<em>async</em> 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>
</ol>
<h2 id="26-localstorage占满、跨域"><a href="#26-localstorage占满、跨域" class="headerlink" title="26 localstorage占满、跨域"></a>26 localstorage占满、跨域</h2><p> 占满怎么解决</p>
<p>1、划分域名。各域名下的存储空间由各业务组统一规划使用</p>
<p>2、跨页面传数据：考虑单页应用、优先采用 url 传数据</p>
<p>3、最后的兜底方案：清掉别人的存储</p>
<p>4、indexeddb</p>
<h3 id="怎么跨域"><a href="#怎么跨域" class="headerlink" title="怎么跨域"></a>怎么跨域</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>一般用于业务域名众多，但是需要共享本地缓存数据。举个例子🌰，比如我用Chrome浏览天猫网站，在搜索栏搜索‘云安全’，过几天我用Chrome进了淘宝网，点击搜索栏想要获取到‘云安全’这个搜索记录，这个时候就需要用到localStroage的跨域存储（当然，也可以将搜索记录存储在服务端，这也是另一种解决办法）</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>主要是通过postMessage来实现跨源通信</li>
<li>可以实现一个公共的iframe部署在某个域名中，作为共享域</li>
<li>将需要实现localStorage跨域通信的页面嵌入这个iframe</li>
<li>接入对应的SDK操作共享域，从而实现localStorage的跨域存储</li>
</ul>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>（注：以下代码均使用TypeScript编写）</p>
<h4 id="1-共享域"><a href="#1-共享域" class="headerlink" title="1.共享域"></a>1.共享域</h4><h4 id="CrossStorageHub"><a href="#CrossStorageHub" class="headerlink" title="CrossStorageHub"></a>CrossStorageHub</h4><p>需要用到的数据结构</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PermissionInfo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 允许的源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@example</span>  /\.example\.(?:com|net|cn)(?:\:\d+)?$/</span><br><span class="hljs-comment">     */</span><br>    origin: RegExp;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 允许的请求方法</span><br><span class="hljs-comment">     */</span><br>    allow: <span class="hljs-keyword">string</span>[];<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>PermissionInfo主要用来配置域名的相关权限</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">ParamsInfo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 键</span><br><span class="hljs-comment">     */</span><br>    key: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">value</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量del</span><br><span class="hljs-comment">     */</span><br>    keys: <span class="hljs-built_in">string</span>[];<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestInfo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求唯一标识</span><br><span class="hljs-comment">     */</span><br>    id: number;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求方法</span><br><span class="hljs-comment">     */</span><br>    method: <span class="hljs-string">&#x27;get&#x27;</span> | <span class="hljs-string">&#x27;set&#x27;</span> | <span class="hljs-string">&#x27;del&#x27;</span> | <span class="hljs-string">&#x27;clear&#x27;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">params</span>: ParamsInfo;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">ResponseInfo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求唯一标识</span><br><span class="hljs-comment">     */</span><br>    id: number;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 错误信息</span><br><span class="hljs-comment">     */</span><br>    error: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求结果</span><br><span class="hljs-comment">     */</span><br>    result: <span class="hljs-built_in">string</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>初始化，检测localStorage是否可用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">init</span>(<span class="hljs-attr">permissions</span>: <span class="hljs-title class_">PermissionInfo</span>[]): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">let</span> available = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 判断localStorage是否可用</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>) available = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">if</span> (!available) &#123;<br>                <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;unavailable&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_permissions</span> = permissions || [];<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_installListener</span>();<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>安装窗口消息事件所需的侦听器，兼容IE8及以上版本</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_installListener</span>(): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">const</span> listener = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_listener</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">addEventListener</span>) &#123;<br>                <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, listener, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable language_">window</span>[<span class="hljs-string">&#x27;attachEvent&#x27;</span>](<span class="hljs-string">&#x27;onmessage&#x27;</span>, listener);<br>            &#125;<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>核心函数，处理来自父窗口的消息，忽略任何来源与权限不匹配的消息。根据method调用对应的函数（’get’ | ‘set’ | ‘del’ | ‘clear’)，响应请求的唯一标识，错误信息，以及result。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_listener</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">MessageEvent</span>): <span class="hljs-built_in">void</span> &#123;<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">origin</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">request</span>: <span class="hljs-title class_">RequestInfo</span>, <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>, <br>            <span class="hljs-attr">error</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] | <span class="hljs-built_in">string</span>, <span class="hljs-attr">response</span>: <span class="hljs-built_in">string</span>;<br><br>            origin = message.<span class="hljs-property">origin</span>;<br>            <br>            <span class="hljs-comment">// 检查message.data是否为有效json</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                request = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(message.<span class="hljs-property">data</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 校验request.method数据类型</span><br>            <span class="hljs-keyword">if</span> (!request || <span class="hljs-keyword">typeof</span> request.<span class="hljs-property">method</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            method = request.<span class="hljs-property">method</span>;<br><br>            <span class="hljs-keyword">if</span> (!method) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">CrossStorageHub</span>.<span class="hljs-title function_">_permitted</span>(origin, method)) &#123;<br>                error = <span class="hljs-string">&#x27;Invalid permissions for &#x27;</span> + method;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    result = <span class="hljs-title class_">CrossStorageHub</span>[<span class="hljs-string">&#x27;_&#x27;</span> + method](request.<span class="hljs-property">params</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                    error = err.<span class="hljs-property">message</span>;<br>                &#125;<br>            &#125;<br><br>            response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>                <span class="hljs-attr">id</span>: request.<span class="hljs-property">id</span>,<br>                <span class="hljs-attr">error</span>: error,<br>                <span class="hljs-attr">result</span>: result<br>            &#125;)<br><br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(response, origin);<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>为了防止恶意网站的接入，所以进行权限检测，不满足条件的消息将被过滤。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_permitted</span>(<span class="hljs-attr">origin</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">available</span>: <span class="hljs-built_in">string</span>[], <span class="hljs-attr">match</span>: <span class="hljs-built_in">boolean</span>;<br><br>            available = [<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-string">&#x27;clear&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_inArray</span>(method, available)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_permissions</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!(entry.<span class="hljs-property">origin</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) || !(entry.<span class="hljs-property">allow</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                match = entry.<span class="hljs-property">origin</span>.<span class="hljs-title function_">test</span>(origin);<br>                <span class="hljs-keyword">if</span> (match &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_inArray</span>(method, entry.<span class="hljs-property">allow</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;;<br>复制代码<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 取数据</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> params </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_get</span>(<span class="hljs-attr">params</span>: <span class="hljs-title class_">ParamsInfo</span>): <span class="hljs-built_in">string</span> &#123;<br>            <span class="hljs-keyword">const</span> &#123; key &#125; = params;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);<br>        &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>剩下的 set | del | clear 函数都是针对localStorage相关API的调用，我就不一一列举了</p>
<h4 id="cross-storage-iframe-html"><a href="#cross-storage-iframe-html" class="headerlink" title="cross-storage-iframe.html"></a>cross-storage-iframe.html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./bin/crossStorage/crossStorage.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        crossStorage.<span class="hljs-title function_">init</span>([</span><br><span class="language-javascript">            &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">origin</span>: <span class="hljs-regexp">/\\*/</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">allow</span>: [<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        ]);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>将代码编译成js文件进行引入。这里为了方便测试将origin配置为&#x2F;\*&#x2F;，允许任何域名访问get，set，del方法。</p>
<h4 id="2-父窗口CrossStorageSDK实现"><a href="#2-父窗口CrossStorageSDK实现" class="headerlink" title="2.父窗口CrossStorageSDK实现"></a>2.父窗口CrossStorageSDK实现</h4><p>主要是用来载入共享域并与之进行通信</p>
<p>sdk的初始化，加载cross-storage-iframe，以及监听message事件</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossStorageSDK</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_storageSrc</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;https://www.example.com/cross-storage-iframe.html&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_storageOrign</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;https://www.example.com&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">_ready</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">_callbacks</span>: &#123; [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-function">(<span class="hljs-params">response?: ResponseInfo</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; | <span class="hljs-built_in">void</span> &#125; = &#123;&#125;;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">init</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_installListener</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_installCrossStorageIframe</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;ready&#x27;</span>] = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;unavailable&#x27;</span>] = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>();<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 安装cross-storage-iframe</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_installCrossStorageIframe</span>(): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>            iframe.<span class="hljs-property">frameBorder</span> = iframe.<span class="hljs-property">width</span> = iframe.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            iframe.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cross-storage&#x27;</span>;<br>            iframe.<span class="hljs-property">src</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_storageSrc</span>;<br>            <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);<br>        &#125;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 安装窗口消息事件所需的侦听器</span><br><span class="hljs-comment">         * 兼容IE8及以上版本</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_installListener</span>(): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">const</span> listener = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_listener</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">addEventListener</span>) &#123;<br>                <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, listener, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable language_">window</span>[<span class="hljs-string">&#x27;attachEvent&#x27;</span>](<span class="hljs-string">&#x27;onmessage&#x27;</span>, listener);<br>            &#125;<br>        &#125;;<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>处理来自cross-storage-iframe的事件消息，通过请求唯一标识进行回调。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_listener</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">MessageEvent</span>): <span class="hljs-built_in">void</span> &#123;<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">ResponseInfo</span>;<br><br>            <span class="hljs-comment">// 忽略其他源发送的消息</span><br>            <span class="hljs-keyword">if</span> (message.<span class="hljs-property">origin</span> !== <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_storageOrign</span>) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-keyword">if</span> (message.<span class="hljs-property">data</span> === <span class="hljs-string">&#x27;unavailable&#x27;</span>) &#123;<br>                <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;unavailable&#x27;</span>]();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (message.<span class="hljs-property">data</span> === <span class="hljs-string">&#x27;ready&#x27;</span> &amp;&amp; !<span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_ready</span>) &#123;<br>                <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_ready</span> = <span class="hljs-literal">true</span>;<br>                <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;ready&#x27;</span>]();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 检查message.data是否为有效json</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(message.<span class="hljs-property">data</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[response.<span class="hljs-property">id</span>] &amp;&amp; <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[response.<span class="hljs-property">id</span>](response)<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>对cross-storage-iframe的localStorage进行get操作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>                <span class="hljs-keyword">const</span> <span class="hljs-attr">request</span>: <span class="hljs-title class_">RequestInfo</span> = &#123;<br>                    <span class="hljs-attr">id</span>: id,<br>                    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>                    <span class="hljs-attr">params</span>: &#123;<br>                        <span class="hljs-attr">key</span>: key<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[id] = <span class="hljs-function">(<span class="hljs-params">response: ResponseInfo</span>) =&gt;</span> &#123;<br>                    response.<span class="hljs-property">error</span> ? <span class="hljs-title function_">reject</span>(response.<span class="hljs-property">error</span>) : <span class="hljs-title function_">resolve</span>(response.<span class="hljs-property">result</span>);<br>                &#125;<br><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_sendRequest</span>(request);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_sendRequest</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">RequestInfo</span>): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">frames</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(request), <span class="hljs-variable language_">this</span>.<span class="hljs-property">_storageOrign</span>);<br>        &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h4><p>a.html和b.html分别接入CrossStorageSDK，调用sdk所暴露的相关方法，就能实现localStorage的跨域（源）通信。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>Safari浏览器由于隐私限制，默认是禁用localStorage跨域存储的，需要用户主动开启设置。</p>
<h2 id="27-indexdb使用"><a href="#27-indexdb使用" class="headerlink" title="27 indexdb使用"></a>27 indexdb使用</h2><p>在人们的印象中，可能觉得只有做后端的小伙伴才会接触到数据库。其实在前端的领域里面也有数据库，只是可能用的比较少，因为前端存储方案有很多，比如cookie、sessionstorage等等。</p>
<p>在浏览器上有两种数据库：webSQL和IndexedDB。但是如果在浏览器上需要用到数据库一般会使用Indexed DB数据库，webSQL基本上已经废弃了，具体原因小伙伴可以下来自己查查，今天主要就讲解Indexed DB数据库的使用。</p>
<h3 id="1-IndexedDB简介"><a href="#1-IndexedDB简介" class="headerlink" title="1.IndexedDB简介"></a>1.IndexedDB简介</h3><p>MDN官网是这样解释Indexed DB的：</p>
<blockquote>
<p>IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件&#x2F;二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。</p>
</blockquote>
<p>官网上的这句话也很简单明了，意思就是IndexedDB主要用来客户端存储大量数据而生的，我们都知道cookie、localstorage等存储方式都有存储大小限制。如果数据量很大，且都需要客户端存储时，那么就可以使用IndexedDB数据库。</p>
<p>客户端各存储方式对比：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b50dd9b052e4dde934c217fa1c1ca01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="2-IndexedDB使用场景"><a href="#2-IndexedDB使用场景" class="headerlink" title="2.IndexedDB使用场景"></a>2.IndexedDB使用场景</h3><p>所有的场景都基于客户端需要存储大量数据的前提下：</p>
<ol>
<li>数据可视化等界面，大量数据，每次请求会消耗很大性能。</li>
<li>即时聊天工具，大量消息需要存在本地。</li>
<li>其它存储方式容量不满足时，不得已使用IndexedDB</li>
</ol>
<h3 id="3-IndexedDB特点"><a href="#3-IndexedDB特点" class="headerlink" title="3.IndexedDB特点"></a>3.IndexedDB特点</h3><p><strong>（1） 非关系型数据库(NoSql)</strong></p>
<p>我们都知道MySQL等数据库都是关系型数据库，它们的主要特点就是数据都以一张二维表的形式存储，而Indexed DB是非关系型数据库，主要以键值对的形式存储数据。</p>
<p><strong>（2）持久化存储</strong></p>
<p>cookie、localStorage、sessionStorage等方式存储的数据当我们清楚浏览器缓存后，这些数据都会被清除掉的，而使用IndexedDB存储的数据则不会，除非手动删除该数据库。</p>
<p><strong>（3）异步操作</strong></p>
<p>IndexedDB操作时不会锁死浏览器，用户依然可以进行其他的操作，这与localstorage形成鲜明的对比，后者是同步的。</p>
<p><strong>（4）支持事务</strong></p>
<p>IndexedDB支持事务(transaction)，这意味着一系列的操作步骤之中，只要有一步失败了，整个事务都会取消，数据库回滚的事务发生之前的状态，这和MySQL等数据库的事务类似。</p>
<p><strong>（6）同源策略</strong></p>
<p>IndexedDB同样存在同源限制，每个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p><strong>（7）存储容量大</strong></p>
<p>这也是IndexedDB最显著的特点之一了，这也是不用localStorage等存储方式的最好理由。</p>
<h3 id="4-IndexedDB重要概念讲解"><a href="#4-IndexedDB重要概念讲解" class="headerlink" title="4.IndexedDB重要概念讲解"></a>4.IndexedDB重要概念讲解</h3><h4 id="4-1仓库objectStore"><a href="#4-1仓库objectStore" class="headerlink" title="4.1仓库objectStore"></a>4.1仓库objectStore</h4><p>IndexedDB没有表的概念，它只有仓库store的概念，大家可以把仓库理解为表即可，即一个store是一张表。</p>
<h4 id="4-2索引index"><a href="#4-2索引index" class="headerlink" title="4.2索引index"></a>4.2索引index</h4><p>在关系型数据库当中也有索引的概念，我们可以给对应的表字段添加索引，以便加快查找速率。在IndexedDB中同样有索引，我们可以在创建store的时候同时创建索引，在后续对store进行查询的时候即可通过索引来筛选，给某个字段添加索引后，在后续插入数据的过成功，索引字段便不能为空。</p>
<h4 id="4-3游标cursor"><a href="#4-3游标cursor" class="headerlink" title="4.3游标cursor"></a>4.3游标cursor</h4><p>游标是IndexedDB数据库新的概念，大家可以把游标想象为一个指针，比如我们要查询满足某一条件的所有数据时，就需要用到游标，我们让游标一行一行的往下走，游标走到的地方便会返回这一行数据，此时我们便可对此行数据进行判断，是否满足条件。</p>
<p>【注意】：IndexedDB查询不像MySQL等数据库方便，它只能通过主键、索引、游标方式查询数据。</p>
<h4 id="4-4事务"><a href="#4-4事务" class="headerlink" title="4.4事务"></a>4.4事务</h4><p>IndexedDB支持事务，即对数据库进行操作时，只要失败了，都会回滚到最初始的状态，确保数据的一致性。</p>
<h3 id="5-IndexedDB实操"><a href="#5-IndexedDB实操" class="headerlink" title="5.IndexedDB实操"></a>5.IndexedDB实操</h3><p>IndexedDB所有针对仓库的操作都是基于事务的。</p>
<h4 id="5-1创建或连接数据库"><a href="#5-1创建或连接数据库" class="headerlink" title="5.1创建或连接数据库"></a>5.1创建或连接数据库</h4><p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开数据库</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; dbName 数据库的名字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; version 数据库的版本</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object</span>&#125; 该函数会返回一个数据库实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-params">dbName, version = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//  兼容浏览器</span><br>    <span class="hljs-keyword">var</span> indexedDB =<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">indexedDB</span> ||<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">mozIndexedDB</span> ||<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitIndexedDB</span> ||<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">msIndexedDB</span>;<br>    <span class="hljs-keyword">let</span> db;<br>    <span class="hljs-comment">// 打开数据库，若没有则会创建</span><br>    <span class="hljs-keyword">const</span> request = indexedDB.<span class="hljs-title function_">open</span>(dbName, version);<br>    <span class="hljs-comment">// 数据库打开成功回调</span><br>    request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// 数据库对象</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库打开成功&quot;</span>);<br>      <span class="hljs-title function_">resolve</span>(db);<br>    &#125;;<br>    <span class="hljs-comment">// 数据库打开失败的回调</span><br>    request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库打开报错&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">// 数据库有更新时候的回调</span><br>    request.<span class="hljs-property">onupgradeneeded</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-comment">// 数据库创建或升级的时候会触发</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onupgradeneeded&quot;</span>);<br>      db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// 数据库对象</span><br>      <span class="hljs-keyword">var</span> objectStore;<br>      <span class="hljs-comment">// 创建存储库</span><br>      objectStore = db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">&quot;signalChat&quot;</span>, &#123;<br>        <span class="hljs-attr">keyPath</span>: <span class="hljs-string">&quot;sequenceId&quot;</span>, <span class="hljs-comment">// 这是主键</span><br>        <span class="hljs-comment">// autoIncrement: true // 实现自增</span><br>      &#125;);<br>      <span class="hljs-comment">// 创建索引，在后面查询数据的时候可以根据索引查</span><br>      objectStore.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span> &#125;); <br>      objectStore.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;sequenceId&quot;</span>, <span class="hljs-string">&quot;sequenceId&quot;</span>, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span> &#125;);<br>      objectStore.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;messageType&quot;</span>, <span class="hljs-string">&quot;messageType&quot;</span>, &#123;<br>        <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span>,<br>      &#125;);<br>    &#125;;<br>  &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们将创建数据库的操作封装成了一个函数，并且该函数返回一个promise对象，使得在调用的时候可以链式调用，函数主要接收两个参数：数据库名称、数据库版本。函数内部主要有三个回调函数，分别是：</p>
<ul>
<li><strong>onsuccess</strong>：数据库打开成功或者创建成功后的回调，这里我们将数据库实例返回了出去。</li>
<li><strong>onerror</strong>：数据库打开或创建失败后的回调。</li>
<li><strong>onupgradeneeded</strong>：当数据库版本有变化的时候会执行该函数，比如我们想创建新的存储库（表），就可以在该函数里面操作，更新数据库版本即可。</li>
</ul>
<h4 id="5-2插入数据"><a href="#5-2插入数据" class="headerlink" title="5.2插入数据"></a>5.2插入数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; data 数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addData</span>(<span class="hljs-params">db, storeName, data</span>) &#123;<br>  <span class="hljs-keyword">var</span> request = db<br>    .<span class="hljs-title function_">transaction</span>([storeName], <span class="hljs-string">&quot;readwrite&quot;</span>) <span class="hljs-comment">// 事务对象 指定表格名称和操作模式（&quot;只读&quot;或&quot;读写&quot;）</span><br>    .<span class="hljs-title function_">objectStore</span>(storeName) <span class="hljs-comment">// 仓库对象</span><br>    .<span class="hljs-title function_">add</span>(data);<br><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据写入成功&quot;</span>);<br>  &#125;;<br><br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据写入失败&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>IndexedDB插入数据需要通过事务来进行操作，插入的方法也很简单，利用IndexedDB提供的add方法即可，这里我们同样将插入数据的操作封装成了一个函数，接收三个参数，分别如下：</p>
<ul>
<li>db：在创建或连接数据库时，返回的db实例，需要那个时候保存下来。</li>
<li>storeName：仓库名称(或者表名)，在创建或连接数据库时我们就已经创建好了仓库。</li>
<li>data：需要插入的数据，通常是一个对象</li>
</ul>
<p><strong>【注意】：</strong>插入的数据是一个对象，而且必须包含我们声明的索引键值对。</p>
<h4 id="5-3通过主键读取数据"><a href="#5-3通过主键读取数据" class="headerlink" title="5.3通过主键读取数据"></a>5.3通过主键读取数据</h4><p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过主键读取数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; key 主键值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDataByKey</span>(<span class="hljs-params">db, storeName, key</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> transaction = db.<span class="hljs-title function_">transaction</span>([storeName]); <span class="hljs-comment">// 事务</span><br>    <span class="hljs-keyword">var</span> objectStore = transaction.<span class="hljs-title function_">objectStore</span>(storeName); <span class="hljs-comment">// 仓库对象</span><br>    <span class="hljs-keyword">var</span> request = objectStore.<span class="hljs-title function_">get</span>(key); <span class="hljs-comment">// 通过主键获取数据</span><br><br>    request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;事务失败&quot;</span>);<br>    &#125;;<br><br>    request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;主键查询结果: &quot;</span>, request.<span class="hljs-property">result</span>);<br>      <span class="hljs-title function_">resolve</span>(request.<span class="hljs-property">result</span>);<br>    &#125;;<br>  &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>主键即刚刚我们在创建数据库时声明的keyPath，通过主键只能查询出一条数据。</p>
<h4 id="5-4通过游标查询数据"><a href="#5-4通过游标查询数据" class="headerlink" title="5.4通过游标查询数据"></a>5.4通过游标查询数据</h4><p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过游标读取数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cursorGetData</span>(<span class="hljs-params">db, storeName</span>) &#123;<br>  <span class="hljs-keyword">let</span> list = [];<br>  <span class="hljs-keyword">var</span> store = db<br>    .<span class="hljs-title function_">transaction</span>(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>) <span class="hljs-comment">// 事务</span><br>    .<span class="hljs-title function_">objectStore</span>(storeName); <span class="hljs-comment">// 仓库对象</span><br>  <span class="hljs-keyword">var</span> request = store.<span class="hljs-title function_">openCursor</span>(); <span class="hljs-comment">// 指针对象</span><br>  <span class="hljs-comment">// 游标开启成功，逐行读数据</span><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">var</span> cursor = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>    <span class="hljs-keyword">if</span> (cursor) &#123;<br>      <span class="hljs-comment">// 必须要检查</span><br>      list.<span class="hljs-title function_">push</span>(cursor.<span class="hljs-property">value</span>);<br>      cursor.<span class="hljs-title function_">continue</span>(); <span class="hljs-comment">// 遍历了存储对象中的所有内容</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;游标读取的数据：&quot;</span>, list);<br>    &#125;<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上面函数开启了一个游标，然后逐行读取数据，存入数组，最终得到整个仓库的所有数据。</p>
<h4 id="5-5通过索引查询数据"><a href="#5-5通过索引查询数据" class="headerlink" title="5.5通过索引查询数据"></a>5.5通过索引查询数据</h4><p><strong>代码如下：</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ini">/**<br> * 通过索引读取数据<br> * @param &#123;object&#125; db 数据库实例<br> * @param &#123;string&#125; storeName 仓库名称<br> * @param &#123;string&#125; indexName 索引名称<br> * @param &#123;string&#125; indexValue 索引值<br> */<br>function getDataByIndex(db, storeName, indexName, indexValue) &#123;<br>  var <span class="hljs-attr">store</span> = db.transaction(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).objectStore(storeName)<span class="hljs-comment">;</span><br>  var <span class="hljs-attr">request</span> = store.index(indexName).get(indexValue)<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onerror</span> = function () &#123;<br>    console.log(&quot;事务失败&quot;)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onsuccess</span> = function (e) &#123;<br>    var <span class="hljs-attr">result</span> = e.target.result<span class="hljs-comment">;</span><br>    console.log(&quot;索引查询结果：&quot;, result)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>索引名称即我们创建仓库的时候创建的索引名称，也就是键值对中的键，最终会查询出所有满足我们传入函数索引值的数据。</p>
<h4 id="5-6通过索引和游标查询数据"><a href="#5-6通过索引和游标查询数据" class="headerlink" title="5.6通过索引和游标查询数据"></a>5.6通过索引和游标查询数据</h4><p>通过5.4节和5.5节我们发现，单独通过索引或者游标查询出的数据都是部分或者所有数据，如果我们想要查询出索引中满足某些条件的所有数据，那么单独使用索引或游标是无法实现的。当然，你也可以查询出所有数据之后在循环数组筛选出合适的数据，但是这不是最好的实现方式，最好的方式当然是将索引和游标结合起来。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过索引和游标查询记录</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; indexName 索引名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; indexValue 索引值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cursorGetDataByIndex</span>(<span class="hljs-params">db, storeName, indexName, indexValue</span>) &#123;<br>  <span class="hljs-keyword">let</span> list = [];<br>  <span class="hljs-keyword">var</span> store = db.<span class="hljs-title function_">transaction</span>(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).<span class="hljs-title function_">objectStore</span>(storeName); <span class="hljs-comment">// 仓库对象</span><br>  <span class="hljs-keyword">var</span> request = store<br>    .<span class="hljs-title function_">index</span>(indexName) <span class="hljs-comment">// 索引对象</span><br>    .<span class="hljs-title function_">openCursor</span>(<span class="hljs-title class_">IDBKeyRange</span>.<span class="hljs-title function_">only</span>(indexValue)); <span class="hljs-comment">// 指针对象</span><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">var</span> cursor = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>    <span class="hljs-keyword">if</span> (cursor) &#123;<br>      <span class="hljs-comment">// 必须要检查</span><br>      list.<span class="hljs-title function_">push</span>(cursor.<span class="hljs-property">value</span>);<br>      cursor.<span class="hljs-title function_">continue</span>(); <span class="hljs-comment">// 遍历了存储对象中的所有内容</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;游标索引查询结果：&quot;</span>, list);<br>    &#125;<br>  &#125;;<br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;&#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上面函数接收四个参数，分别是：</p>
<ul>
<li>db：数据库实例</li>
<li>storeName：仓库名</li>
<li>indexName：索引名称</li>
<li>indexName：索引值</li>
</ul>
<p>利用索引和游标结合查询，我们可以查询出索引值满足我们传入函数值的所有数据对象，而不是之查询出一条数据或者所有数据。</p>
<h4 id="5-7通过索引和游标分页查询"><a href="#5-7通过索引和游标分页查询" class="headerlink" title="5.7通过索引和游标分页查询"></a>5.7通过索引和游标分页查询</h4><p>IndexedDB分页查询不像MySQL分页查询那么简单，没有提供现成的API，如limit等，所以需要我们自己实现分页。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs ini">/**<br> * 通过索引和游标分页查询记录<br> * @param &#123;object&#125; db 数据库实例<br> * @param &#123;string&#125; storeName 仓库名称<br> * @param &#123;string&#125; indexName 索引名称<br> * @param &#123;string&#125; indexValue 索引值<br> * @param &#123;number&#125; page 页码<br> * @param &#123;number&#125; pageSize 查询条数<br> */<br>function cursorGetDataByIndexAndPage(<br>  db,<br>  storeName,<br>  indexName,<br>  indexValue,<br>  page,<br>  pageSize<br>) &#123;<br>  let <span class="hljs-attr">list</span> = []<span class="hljs-comment">;</span><br>  let <span class="hljs-attr">counter</span> = <span class="hljs-number">0</span><span class="hljs-comment">; // 计数器</span><br>  let <span class="hljs-attr">advanced</span> = <span class="hljs-literal">true</span><span class="hljs-comment">; // 是否跳过多少条查询</span><br>  var <span class="hljs-attr">store</span> = db.transaction(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).objectStore(storeName)<span class="hljs-comment">; // 仓库对象</span><br>  var <span class="hljs-attr">request</span> = store<br>    .index(indexName) // 索引对象<br>    .openCursor(IDBKeyRange.only(indexValue))<span class="hljs-comment">; // 指针对象</span><br>  <span class="hljs-attr">request.onsuccess</span> = function (e) &#123;<br>    var <span class="hljs-attr">cursor</span> = e.target.result<span class="hljs-comment">;</span><br>    if (page &gt; 1 &amp;&amp; advanced) &#123;<br>      <span class="hljs-attr">advanced</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br>      cursor.advance((page - 1) * pageSize)<span class="hljs-comment">; // 跳过多少条</span><br>      return<span class="hljs-comment">;</span><br>    &#125;<br>    if (cursor) &#123;<br>      // 必须要检查<br>      list.push(cursor.value)<span class="hljs-comment">;</span><br>      counter++<span class="hljs-comment">;</span><br>      if (counter &lt; pageSize) &#123;<br>        cursor.continue()<span class="hljs-comment">; // 遍历了存储对象中的所有内容</span><br>      &#125; else &#123;<br>        <span class="hljs-attr">cursor</span> = null<span class="hljs-comment">;</span><br>        console.log(&quot;分页查询结果&quot;, list)<span class="hljs-comment">;</span><br>      &#125;<br>    &#125; else &#123;<br>      console.log(&quot;分页查询结果&quot;, list)<span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onerror</span> = function (e) &#123;&#125;<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这里用到了IndexedDB的一个API：advance。该函数可以让我们的游标跳过多少条开始查询。假如我们的额分页是每页10条数据，现在需要查询第2页，那么我们就需要跳过前面10条数据，从11条数据开始查询，直到计数器等于10，那么我们就关闭游标，结束查询。</p>
<h4 id="5-8更新数据"><a href="#5-8更新数据" class="headerlink" title="5.8更新数据"></a>5.8更新数据</h4><p>IndexedDB更新数据较为简单，直接使用put方法，值得注意的是如果数据库中没有该条数据，则会默认增加该条数据，否则更新。有些小伙伴喜欢更新和新增都是用put方法，这也是可行的。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; data 数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDB</span>(<span class="hljs-params">db, storeName, data</span>) &#123;<br>  <span class="hljs-keyword">var</span> request = db<br>    .<span class="hljs-title function_">transaction</span>([storeName], <span class="hljs-string">&quot;readwrite&quot;</span>) <span class="hljs-comment">// 事务对象</span><br>    .<span class="hljs-title function_">objectStore</span>(storeName) <span class="hljs-comment">// 仓库对象</span><br>    .<span class="hljs-title function_">put</span>(data);<br><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据更新成功&quot;</span>);<br>  &#125;;<br><br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据更新失败&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>put方法接收一个数据对象。</p>
<h4 id="5-9通过主键删除数据"><a href="#5-9通过主键删除数据" class="headerlink" title="5.9通过主键删除数据"></a>5.9通过主键删除数据</h4><p>主键即我们创建数据库时申明的keyPath，它是唯一的。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过主键删除数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; id 主键值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteDB</span>(<span class="hljs-params">db, storeName, id</span>) &#123;<br>  <span class="hljs-keyword">var</span> request = db<br>    .<span class="hljs-title function_">transaction</span>([storeName], <span class="hljs-string">&quot;readwrite&quot;</span>)<br>    .<span class="hljs-title function_">objectStore</span>(storeName)<br>    .<span class="hljs-title function_">delete</span>(id);<br><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据删除成功&quot;</span>);<br>  &#125;;<br><br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据删除失败&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该种删除只能删除一条数据，必须传入主键。</p>
<h4 id="5-10通过索引和游标删除指定数据"><a href="#5-10通过索引和游标删除指定数据" class="headerlink" title="5.10通过索引和游标删除指定数据"></a>5.10通过索引和游标删除指定数据</h4><p>有时候我们拿不到主键值，只能只能通过索引值来删除，通过这种方式，我们可以删除一条数据（索引值唯一）或者所有满足条件的数据（索引值不唯一）。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ini">/**<br> * 通过索引和游标删除指定的数据<br> * @param &#123;object&#125; db 数据库实例<br> * @param &#123;string&#125; storeName 仓库名称<br> * @param &#123;string&#125; indexName 索引名<br> * @param &#123;object&#125; indexValue 索引值<br> */<br>function cursorDelete(db, storeName, indexName, indexValue) &#123;<br>  var <span class="hljs-attr">store</span> = db.transaction(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).objectStore(storeName)<span class="hljs-comment">;</span><br>  var <span class="hljs-attr">request</span> = store<br>    .index(indexName) // 索引对象<br>    .openCursor(IDBKeyRange.only(indexValue))<span class="hljs-comment">; // 指针对象</span><br>  <span class="hljs-attr">request.onsuccess</span> = function (e) &#123;<br>    var <span class="hljs-attr">cursor</span> = e.target.result<span class="hljs-comment">;</span><br>    var deleteRequest<span class="hljs-comment">;</span><br>    if (cursor) &#123;<br>      <span class="hljs-attr">deleteRequest</span> = cursor.delete()<span class="hljs-comment">; // 请求删除当前项</span><br>      <span class="hljs-attr">deleteRequest.onerror</span> = function () &#123;<br>        console.log(&quot;游标删除该记录失败&quot;)<span class="hljs-comment">;</span><br>      &#125;<span class="hljs-comment">;</span><br>      <span class="hljs-attr">deleteRequest.onsuccess</span> = function () &#123;<br>        console.log(&quot;游标删除该记录成功&quot;)<span class="hljs-comment">;</span><br>      &#125;<span class="hljs-comment">;</span><br>      cursor.continue()<span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onerror</span> = function (e) &#123;&#125;<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上段代码可以删除索引值为indexValue的所有数据，值得注意的是使用了<a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/IDBKeyRange">IDBKeyRange.only(）</a>API，该API代表只能当两个值相等时，具体API解释可参考MDN官网。</p>
<h4 id="5-11关闭数据库"><a href="#5-11关闭数据库" class="headerlink" title="5.11关闭数据库"></a>5.11关闭数据库</h4><p>当我们数据库操作完毕后，建议关闭它，节约资源。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关闭数据库</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">closeDB</span>(<span class="hljs-params">db</span>) &#123;<br>  db.<span class="hljs-title function_">close</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库已关闭&quot;</span>);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>5.12删除数据库</p>
<p>最后我们需要删库跑路，删除操作也很简单。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除数据库</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; dbName 数据库名称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteDBAll</span>(<span class="hljs-params">dbName</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dbName);<br>  <span class="hljs-keyword">let</span> deleteRequest = <span class="hljs-variable language_">window</span>.<span class="hljs-property">indexedDB</span>.<span class="hljs-title function_">deleteDatabase</span>(dbName);<br>  deleteRequest.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;删除失败&quot;</span>);<br>  &#125;;<br>  deleteRequest.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;删除成功&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>IndexedDB数据库没有我们想象的那么复杂，了解了它的几个基本概念，上手还是很快的，无非就是增删改查等等，虽然可能开发中用的少，但是了解一下不至于真正用到的时候两眼抓瞎。</p>
<h2 id="28-js最大值"><a href="#28-js最大值" class="headerlink" title="28 js最大值"></a>28 js最大值</h2><p>js的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=number%E7%B1%BB&spm=1001.2101.3001.7020">number类</a>型有个最大值（安全值）。即2的53次方，为9007199254740992。如果超过这个值，那么js会出现不精确的问题。这个值为16位。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><h4 id="1-后端发字符串类型。"><a href="#1-后端发字符串类型。" class="headerlink" title="1.后端发字符串类型。"></a>1.后端发字符串类型。</h4><p>将后端发过来的long类型转为string类型再向前端传。如果向前端传的是DAO集合，则每个DAO都需要转类型，太过于繁琐。想想就算了。</p>
<h4 id="2-在userDao中加入一个字段"><a href="#2-在userDao中加入一个字段" class="headerlink" title="2.在userDao中加入一个字段"></a>2.在userDao中加入一个字段</h4><p>如果项目已经成型并且修改数据库会造成不可预料的问题那么可以在User对象中再增加一个String类型id映射字段，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">private <span class="hljs-title class_">Long</span> userId;<br>private <span class="hljs-title class_">String</span> userIdStr;<br>public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUserIdStr</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userId</span>+<span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br>public <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserIdStr</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> userIdStr</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">userIdStr</span> = userIdStr;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法是比较靠谱的，确实可以正常的显示数据，查询单个数据id的值都是正确的。但修改用户时无法获取前端传过来的userDao中的userIdStr的值，因为上面的getUserIdStr()不能获取userIdStr的值（如果id没有值）。</p>
<h4 id="3-控制用户新建数据时id的长度。兜兜转转觉得这个最方便。"><a href="#3-控制用户新建数据时id的长度。兜兜转转觉得这个最方便。" class="headerlink" title="3.控制用户新建数据时id的长度。兜兜转转觉得这个最方便。"></a>3.控制用户新建数据时id的长度。兜兜转转觉得这个最方便。</h4><h2 id="29-事件循环和垃圾回收的工作机制"><a href="#29-事件循环和垃圾回收的工作机制" class="headerlink" title="29 事件循环和垃圾回收的工作机制"></a>29 事件循环和垃圾回收的工作机制</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>官网说，JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。</p>
<p>仔细来看看事件循环的责任，也就是他负责了什么：</p>
<ul>
<li>执行代码</li>
<li>收集和处理事件</li>
<li>执行队列中的子任务</li>
</ul>
<p>我们能够接收到这样的三个信息，基于这三个信息，我们来思考如下问题：</p>
<ul>
<li>如何执行代码？以什么样的流程操作的？</li>
<li>如何收集事件？如何处理事件？是否存在事件的优先级，比如说宏任务&#x2F;微任务先执行哪个？</li>
<li>如何执行队列中的子任务？</li>
</ul>
<p>根据下图和图下的代码进行分析：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dd6e851599487cb1e044e6a4f4b186~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">b</span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">return</span> a + b + <span class="hljs-number">11</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">let</span> y = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>(x * y);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bar</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 返回 42</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h4><p>在JavaScript中，函数的调用行成了一个由若干帧组成的栈。每一帧是60Hz，大概是16.6ms。</p>
<p>上面代码为例，当调用bar时，第一帧被创建并压入栈中，这一帧包含了bar的参数和局部变量。</p>
<p>当bar调用foo的时候，第二个帧被创建并压入栈中，并放在第一个帧之上，第二帧中包含foo的参数和局部变量。</p>
<p>当foo执行完毕然后返回时，第二个帧就被弹出栈了。此时剩下bar函数调用帧。</p>
<p>当bar也执行完毕然后返回时，第一个栈也被弹出了，栈就被清空了。</p>
<h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h4><p>堆是用来表示一大块(通常是非结构化的)内存区域的计算机术语。</p>
<p>对象会被分配在堆中。比如：用一个变量存储对象，这个对象会在堆中有一个唯一标识，栈中的变量会保存这个唯一标识来确定你引用的是哪个对象。多个变量标识如果一样，证明引用了同一个对象。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>一段JavaScript代码运行时包含了一个待处理消息的消息队列。每一个消息都包含着用来处理这个消息的回调函数。</p>
<p>在事件循环期间的某个时刻，运行时会从最先进入队列中的消息开始处理。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。这个函数调用还会创建一个新的栈。</p>
<p>函数的处理会一直进行到栈空了为止；然后事件循环会继续处理任务队列中下一个消息。</p>
<h4 id="执行完成"><a href="#执行完成" class="headerlink" title="执行完成"></a>执行完成</h4><p>每一个消息被完整的执行完之后，其他消息才会被执行。</p>
<p>这样做会为程序的分析提供了一些优秀的特性，比如下面这个：</p>
<ul>
<li>当一个函数被执行时不会被抢占，只有在他运行完毕之后才会运行其他代码，才会修改这个函数操作的数据。</li>
</ul>
<p>当然这个模型也是存在缺点的：</p>
<ul>
<li>当一个消息需要很久的时间才能处理完毕，Web应用程序会无法处理与用户的交互，比如滚动&#x2F;点击。 一定养成好的习惯，缩短单个消息处理的时间。</li>
</ul>
<h4 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a>添加消息</h4><p>在浏览器里，每当有一个事件发生并且有一个事件监听绑定在改事件上时，一个消息就会被添加到事件队列中。如果没有事件监听器，这个事件将会丢失。</p>
<p>比如带有点击事件的元素被点击时，就会像其他事件一样产生一个消息。</p>
<p>setTimeout 函数是特殊的，他接受两个参数：待加入队列的消息 ｜ 一个时间值（默认是0）。</p>
<p>这个时间表示消息实际被加入到队列的最小延时时间。意思就是：如果队列中没有其他消息，并且栈为空，在这段延时的时间过去之后，setTimeout 里的消息就会被立马处理。但是，如果有其他消息，setTimeout 必须等其他消息处理完才能在这段延时时间过去之后处理消息。</p>
<p>这就是常说的宏任务与微任务。setTimeout 作为宏任务，始终是等前面的微任务执行完之后，延迟执行。其他的宏任务还有JS文件，也就是前面的JS文件会作为优先后面的JS文件的宏任务。</p>
<h4 id="永不阻塞"><a href="#永不阻塞" class="headerlink" title="永不阻塞"></a>永不阻塞</h4><p>JavaScript事件循环模型与其它语言不同，有一个非常有趣的特性：永不阻塞。例如：在用户XHR请求返回时，我们任然可以进对输入框的输入。</p>
<p>会有一些例外，如alert或者同步XHR。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾回收在计算机编程中用于描述查找和删除那些不再被其他对象引用的对象的处理过程。</p>
<p>当某个程序占用一部分内存空间，并且不再被这个程序访问时，这个程序就会借助垃圾回收算法向操作系统归还这部分操作空间。</p>
<p>记不记得事件循环中的Heap，堆就是管理所有内存空间的地方。当有一个对象没有被使用到，也就是说谁也没有引用到这个对象。那就会被回收，会被垃圾回收算法进行处理。</p>
<p>如何处理的？我们接下来看看。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>垃圾回收有两个基本原理：</p>
<ul>
<li>考虑某个对象在未来的程序运行中，将不会被访问。</li>
<li>回收这些对象所占用的存储器。</li>
</ul>
<p>思考下面这个问题：</p>
<ul>
<li>如何知道这个对象在未来会不被使用到？</li>
</ul>
<h4 id="跟踪收集器"><a href="#跟踪收集器" class="headerlink" title="跟踪收集器"></a>跟踪收集器</h4><p>跟踪收集器是通过算法运行的，他主要做的是定期遍历它所管理的内存空间。</p>
<p>它会从若干个根存储对象中开始查找与之相关的存储对象，然后标记其余的没有关联的存储对象，最后回收这些没有关联的存储对象占用的内存空间。</p>
<p>跟踪收集器中的大概运行流程我们明白了，接下来看看他都有哪些算法吧。</p>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><p>先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后，恢复运行线程。</p>
<p>这样做会产生大量的空闲空间碎片，和使得大容量对象不容易获得连续的内存空间，从而造成浪费。</p>
<p>我们来举例子：</p>
<p>JS运行是单线程的，在运行之前会被进行垃圾回收，先暂停JS的运行，回收线程进行扫描，标记没有用到的对象，标记完成之后直接清除这个对象，回收存储器。最后恢复JS运行。</p>
<p>由于我们回收的空间可能不是连续的，就会导致产生空闲空间碎片，如果这个被回收的存储器左右皆是大容量对象进行存储，这样大容量对象就不会有连续的存储空间，从而造成浪费。</p>
<p>为什么不连续会造成浪费？如果一个变量应用这个大容量对象，本来应该是找到下一个存储器就可以，由于不连续，得找下下一个，这就是浪费。</p>
<h4 id="标记-压缩"><a href="#标记-压缩" class="headerlink" title="标记 - 压缩"></a>标记 - 压缩</h4><p>和标记 - 清除相似，不同的是，回收期间同时会将保留的存储对象搬运到连续的内存空间。</p>
<p>这样会对空闲的空间进行整合，避免内存碎片化。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>需要程序将所拥有的空间分成两个部分。程序运行所需要的存储对象会被先存储在一个分区（分区0）。同样暂停整个运行程序的全部运行线程，进行标记之后，回首期间将保留的存储对象搬运汇集到另一个分区（分区1），完成回收，程序在本次回收之后将接下来产生的存储对象存储到“分区1”。在下一次回收时，将两个分区角色对调。</p>
<h4 id="增量回收器"><a href="#增量回收器" class="headerlink" title="增量回收器"></a>增量回收器</h4><p>需要程序将所拥有的内存空间分成若干个分区。程序运行时所需要的存储对象会分布在这些分区中，每次只对一个分区进行回收操作。</p>
<p>这样避免了暂停所有正在运行的线程来进行回收，允许部分线程在不影响回收行为下保持运行，降低了回收时间，增加了响应速度。</p>
<h4 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h4><p>由于“复制”算法对于存活时间长，大容量的存储对象移动时消耗时间长，和存在存储对象的存活时间的差异。需要程序将所有的内存空间分成若干分区，并标记为年轻代空间和老年代空间。</p>
<p>运行时所需存储的对象会先被存储到年轻代分区。</p>
<p>年轻代分区会较为频繁的进行垃圾回收行为，每次回收完成，幸存的存储对象内的寿命计数器会+1。当年轻代分区存储对象的寿命计数器达到了一定阀值或存储对象占用的空间超出了一定阀值时，会被移动到老年代分区。</p>
<p>老年代分区有较少运行的垃圾回收行为。</p>
<p>一般情况下还有永久代空间，用于程序整个运行的生命周期的对象存储，例如运行代码、数据常量等。该空间不会运行垃圾回收的操作。</p>
<p>通过这样分代处理，存活在局限域、小容量、寿命短的存储对象会被快速回收；存活在全局域、大容量、寿命长的存储对象就较少的被回收行为所处理。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>到此本篇文章就讲完了事件循环和垃圾回收的工作机制，来简单回顾一下。</p>
<ul>
<li>事件回收：<ul>
<li>栈(Stack)：队列中消息被压入</li>
<li>堆(Heap)：栈中引用对象变量。存储对象的内存。</li>
<li>队列(Queue)：消息的执行顺序。</li>
</ul>
</li>
<li>垃圾回收：针对堆中，存储对象如何存储，如何回收，通过相关算法实现。<ul>
<li>标记 - 清除：碎片多、不连续。</li>
<li>标记 - 压缩：减少了碎片、使得空间连续，减少浪费。但是时间相对较长，需要整理空间。</li>
<li>复制：移动会有时间损耗。存储对象存活时间有差异。</li>
<li>增量回收器：避免暂停了所有线程。降低了回收时间，增加了响应速度。</li>
<li>分代：年轻代分区、老年代分区。更好的优化了复制算法。</li>
</ul>
</li>
</ul>
<h2 id="30-说一下map和weakmap的区别"><a href="#30-说一下map和weakmap的区别" class="headerlink" title="30 说一下map和weakmap的区别"></a>30 说一下map和weakmap的区别</h2><h3 id="Weakmap的优点"><a href="#Weakmap的优点" class="headerlink" title="Weakmap的优点"></a>Weakmap的优点</h3><ul>
<li>不阻碍垃圾回收</li>
<li>api与map保持一致</li>
</ul>
<h3 id="Weakmap的缺点"><a href="#Weakmap的缺点" class="headerlink" title="Weakmap的缺点"></a>Weakmap的缺点</h3><ul>
<li>key必须是引用类型</li>
<li>外部没有了key的引用时，weakmap的数据可能被垃圾回收</li>
<li>不提供遍历数据的方法</li>
<li>无法得到map的大小</li>
</ul>
<h2 id="31-symbol使用场景"><a href="#31-symbol使用场景" class="headerlink" title="31 symbol使用场景"></a>31 symbol使用场景</h2><p>Symbol是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用Symbol()函数来创建一个Symbol实例：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">s1</span> = Symbol()<br>复制代码<br></code></pre></td></tr></table></figure>

<p>或者，你也可以在调用Symbol()函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">s2</span> = Symbol(<span class="hljs-string">&#x27;another symbol&#x27;</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果用当下比较流行的TypeScript的方式来描述这个Symbol()函数的话，可以表示成：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  &#123;any&#125; description 描述信息。可以是任何可以被转型成字符串的值，如：字符串、数字、对象、数组等</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Symbol</span>(<span class="hljs-params">description?: any</span>): <span class="hljs-title">symbol</span></span><br><span class="hljs-function">复制代码</span><br></code></pre></td></tr></table></figure>

<p>由于Symbol是一种基础数据类型，所以当我们使用typeof去检查它的类型的时候，它会返回一个属于自己的类型symbol，而不是什么string、object之类的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">typeof</span> s1  <span class="hljs-comment">// &#x27;symbol&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>另外，我们需要重点记住的一点是：每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回false：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">s1</span> = Symbol()<br>let <span class="hljs-attr">s2</span> = Symbol(<span class="hljs-string">&#x27;another symbol&#x27;</span>)<br>let <span class="hljs-attr">s3</span> = Symbol(<span class="hljs-string">&#x27;another symbol&#x27;</span>)<br><br><span class="hljs-attr">s1</span> === s2 // <span class="hljs-literal">false</span><br><span class="hljs-attr">s2</span> === s3 // <span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>Symbol()</code>不是一个完整的构造函数，因此不能通过<code>new Symbol()</code> 来创建(通过 <code>new</code>实例化的结果是一个 <code>object</code>对象，而不是原始类型的 <code>symbol</code>)</p>
<p><code>Symbol</code>不能进行隐式类型转换，但可以显式转为字符串；不能转化为数字，但可以转化为布尔值</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const s = Symbol(<span class="hljs-string">&#x27;s&#x27;</span>)<br><br><span class="hljs-comment">// 强制类型转换会抛类型错误</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s + <span class="hljs-string">&#x27;/s&#x27;</span>); <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a string</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;s&#125;</span>/s`</span>) <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a string</span><br><br><span class="hljs-comment">// 只能先进行强制转换</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(s) + <span class="hljs-string">&#x27;/s&#x27;</span>); <span class="hljs-comment">// Symbol(s)/s</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s.toString() + <span class="hljs-string">&#x27;/s&#x27;</span>); <span class="hljs-comment">// Symbol(s)/s</span><br><br></code></pre></td></tr></table></figure>



<h3 id="应用场景1：使用Symbol来作为对象属性名-key"><a href="#应用场景1：使用Symbol来作为对象属性名-key" class="headerlink" title="应用场景1：使用Symbol来作为对象属性名(key)"></a>应用场景1：使用Symbol来作为对象属性名(key)</h3><p>在这之前，我们通常定义或访问对象的属性时都是使用字符串，比如下面的代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss">let obj = &#123;<br>  abc: <span class="hljs-number">123</span>,<br>  <span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span><br>&#125;<br><br>obj<span class="hljs-selector-attr">[<span class="hljs-string">&quot;abc&quot;</span>]</span> <span class="hljs-comment">// 123</span><br>obj<span class="hljs-selector-attr">[<span class="hljs-string">&quot;hello&quot;</span>]</span> <span class="hljs-comment">// &#x27;world&#x27;</span><br>而现在，Symbol可同样用于对象属性的定义和访问：<br><br>const PROP_NAME = <span class="hljs-built_in">Symbol</span>()<br>const PROP_AGE = <span class="hljs-built_in">Symbol</span>()<br><br>let obj = &#123;<br>  <span class="hljs-selector-attr">[PROP_NAME]</span>: <span class="hljs-string">&quot;一斤代码&quot;</span><br>&#125;<br>obj<span class="hljs-selector-attr">[PROP_AGE]</span> = <span class="hljs-number">18</span><br><br>obj<span class="hljs-selector-attr">[PROP_NAME]</span> <span class="hljs-comment">// &#x27;一斤代码&#x27;</span><br>obj<span class="hljs-selector-attr">[PROP_AGE]</span> <span class="hljs-comment">// 18</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用Object.keys()或者for…in来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">let obj = &#123;<br>   <span class="hljs-selector-attr">[Symbol(<span class="hljs-string">&#x27;name&#x27;</span>)]</span>: <span class="hljs-string">&#x27;一斤代码&#x27;</span>,<br>   age: <span class="hljs-number">18</span>,<br>   title: <span class="hljs-string">&#x27;Engineer&#x27;</span><br>&#125;<br><br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.keys</span>(obj)   // <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>]</span><br><br>for (let <span class="hljs-selector-tag">p</span> in obj) &#123;<br>   console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">p</span>)   // 分别会输出：&#x27;age&#x27; 和 &#x27;title&#x27;<br>&#125;<br><br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.getOwnPropertyNames</span>(obj)   // <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>由上代码可知，Symbol类型的key是不能通过Object.keys()或者for…in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。</p>
<p>也正因为这样一个特性，当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">JSON.stringify(obj)  // &#123;<span class="hljs-string">&quot;age&quot;</span>:18,<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;Engineer&quot;</span>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。</p>
<p>然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">// 使用<span class="hljs-selector-tag">Object</span>的API<br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.getOwnPropertySymbols</span>(obj) // <span class="hljs-selector-attr">[Symbol(name)]</span><br><br>// 使用新增的反射API<br>Reflect<span class="hljs-selector-class">.ownKeys</span>(obj) // <span class="hljs-selector-attr">[Symbol(name), <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="应用场景2：使用Symbol来替代常量"><a href="#应用场景2：使用Symbol来替代常量" class="headerlink" title="应用场景2：使用Symbol来替代常量"></a>应用场景2：使用Symbol来替代常量</h3><p>先来看一下下面的代码，是不是在你的代码里经常会出现？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TYPE_AUDIO</span> = <span class="hljs-string">&#x27;AUDIO&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TYPE_VIDEO</span> = <span class="hljs-string">&#x27;VIDEO&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TYPE_IMAGE</span> = <span class="hljs-string">&#x27;IMAGE&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFileResource</span>(<span class="hljs-params">resource</span>) &#123;<br>  <span class="hljs-keyword">switch</span>(resource.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">TYPE_AUDIO</span>:<br>      <span class="hljs-title function_">playAudio</span>(resource)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">TYPE_VIDEO</span>:<br>      <span class="hljs-title function_">playVideo</span>(resource)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">TYPE_IMAGE</span>:<br>      <span class="hljs-title function_">previewImage</span>(resource)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Unknown type of resource&#x27;</span>)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值（比如这里的’AUDIO’、’VIDEO’、 ‘IMAGE’），常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。</p>
<p>现在有了Symbol，我们大可不必这么麻烦了：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">TYPE_AUDIO</span> = Symbol()<br>const <span class="hljs-attr">TYPE_VIDEO</span> = Symbol()<br>const <span class="hljs-attr">TYPE_IMAGE</span> = Symbol()<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样定义，直接就保证了三个常量的值是唯一的了！是不是挺方便的呢。</p>
<h3 id="应用场景3：使用Symbol定义类的私有属性-x2F-方法"><a href="#应用场景3：使用Symbol定义类的私有属性-x2F-方法" class="headerlink" title="应用场景3：使用Symbol定义类的私有属性&#x2F;方法"></a>应用场景3：使用Symbol定义类的私有属性&#x2F;方法</h3><p>我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。</p>
<p>而有了Symbol以及模块化机制，类的私有属性和方法才变成可能。例如：</p>
<p>在文件 a.js中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PASSWORD</span> = <span class="hljs-title class_">Symbol</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">username, password</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username<br>    <span class="hljs-variable language_">this</span>[<span class="hljs-variable constant_">PASSWORD</span>] = password<br>  &#125;<br><br>  <span class="hljs-title function_">checkPassword</span>(<span class="hljs-params">pwd</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-variable constant_">PASSWORD</span>] === pwd<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Login</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>在文件 b.js 中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span><br><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Login</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br><br>login.<span class="hljs-title function_">checkPassword</span>(<span class="hljs-string">&#x27;123456&#x27;</span>)  <span class="hljs-comment">// true</span><br><br>login.<span class="hljs-property">PASSWORD</span>  <span class="hljs-comment">// oh!no!</span><br>login[<span class="hljs-variable constant_">PASSWORD</span>] <span class="hljs-comment">// oh!no!</span><br>login[<span class="hljs-string">&quot;PASSWORD&quot;</span>] <span class="hljs-comment">// oh!no!</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个PASSWORD的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p>
<h3 id="注册和获取全局Symbol"><a href="#注册和获取全局Symbol" class="headerlink" title="注册和获取全局Symbol"></a>注册和获取全局Symbol</h3><p>通常情况下，我们在一个浏览器窗口中（window），使用Symbol()函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了iframe），并需要这些window中使用的某些Symbol是同一个，那就不能使用Symbol()函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是Symbol.for()，它可以注册或获取一个window间全局的Symbol实例：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">gs1</span> = Symbol.for(<span class="hljs-string">&#x27;global_symbol_1&#x27;</span>)  //注册一个全局Symbol<br>let <span class="hljs-attr">gs2</span> = Symbol.for(<span class="hljs-string">&#x27;global_symbol_1&#x27;</span>)  //获取全局Symbol<br><br><span class="hljs-attr">gs1</span> === gs2  // <span class="hljs-literal">true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p>
<p>好了，通过以上这些例子，你现在是不是开始对ES6的这个Symbol功能有点了解了呢？Symbol在JS内部也有很多应用，比如迭代器(Iterator)等，大家可以以此为出发点，发掘出更多相关知识点，深入的理解Symbol的用法和使用场景。</p>
<h3 id="js判断某个对象是否是Symbol对象"><a href="#js判断某个对象是否是Symbol对象" class="headerlink" title="js判断某个对象是否是Symbol对象"></a>js判断某个对象是否是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Symbol&spm=1001.2101.3001.7020">Symbol</a>对象</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul>
<li><p>typeof 为 symbol</p>
<p>或</p>
</li>
<li><p>typeof 为 object</p>
</li>
<li><p>不为null</p>
</li>
<li><p>toString 值为 [object Symbol]</p>
</li>
</ul>
<h2 id="32-proxy"><a href="#32-proxy" class="headerlink" title="32 proxy"></a>32 proxy</h2><p><code>Proxy</code>对象用于创建一个对象的代理，是用于监听一个对象的相关操作。代理对象可以监听我们对原对象的操作。</p>
<p>接下来我们将通过一个监听对象的属性操作来认识学习下什么是<code>Proxy</code>。</p>
<p>Proxy对象需要传入两个参数，分别是需要被<code>Proxy</code>代理的对象和一系列的捕获器（PS：下面会讲）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj=&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;_island&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> objProxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj,&#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy);<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4a76a2240c4015bfd8182e16640b30~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20220204200341915"></p>
<p>打印出来可以看到的是一个<code>Proxy</code>对象。下面我们开始看看<code>Proxy</code>中的捕获器对象。</p>
<h3 id="Proxy捕获器"><a href="#Proxy捕获器" class="headerlink" title="Proxy捕获器"></a>Proxy捕获器</h3><p>在实例化<code>Proxy</code>对象时，第二个参数传入的是捕获器集合，我们在其对象内定义一个<code>get</code>捕获器，用于监听获取对象值的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个普通的对象obj</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span><br>&#125;;<br><br><span class="hljs-comment">// 代理obj这个对象，并传入get捕获器</span><br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-comment">// get捕获器</span><br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`捕获到对象获取<span class="hljs-subst">$&#123;key&#125;</span>属性的值操作`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 通过代理对象操作obj对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 捕获到对象获取name属性的值操作</span><br><span class="hljs-comment">// _island</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>在<code>objProxy</code>对象的拦截器中新增一个捕获器<code>set</code>，用于监听对象的某个属性被设置时触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// set捕获器</span><br><span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, val</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`捕获到对象设置<span class="hljs-subst">$&#123;key&#125;</span>属性的值操作,新值为<span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>  target[key] = val;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;QC2125&quot;</span>);<br><span class="hljs-comment">// 捕获到对象设置name属性的值操作,新值为QC2125</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 捕获到对象获取name属性的值操作</span><br><span class="hljs-comment">// QC2125</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果不想这个属性被设定这个值，你可以抛出异常告诉开发者，该值不能被设定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, val</span>) &#123;<br>  <span class="hljs-keyword">if</span> (key===<span class="hljs-string">&#x27;age&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    target[key] = val;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;该属性的值必须是Number类型&quot;</span>);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们也可以监听对象是否调用了<code>getPrototypeOf</code>操作，使用<code>getPrototypeOf</code>捕获器即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听getPrototypeOf</span><br><span class="hljs-attr">getPrototypeOf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到对象getPrototypeOf操作`</span>);<br>&#125;,<br>复制代码<br></code></pre></td></tr></table></figure>

<p>在<code>Proxy</code>中共有<code>13</code>个捕获器，它们用于我们对对象、函数的方法调用监听。下面是<code>Proxy</code>捕获器以及它们的触发条件。</p>
<table>
<thead>
<tr>
<th>对象中的方法</th>
<th>对应触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>handler.getPrototypeOf()</td>
<td><code>Object.getPrototypeOf</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.setPrototypeOf()</td>
<td><code>Object.setPrototypeOf</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.isExtensible()</td>
<td><code>Object.isExtensible</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.preventExtensions()</td>
<td><code>Object.preventExtensions</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.getOwnPropertyDescriptor()</td>
<td><code>Object.getOwnPropertyDescriptor</code> 方法的捕捉器。</td>
</tr>
<tr>
<td>handler.defineProperty()</td>
<td><code>Object.defineProperty</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.has()</td>
<td><code>in</code> 操作符的捕捉器</td>
</tr>
<tr>
<td>handler.get()</td>
<td>属性读取操作的捕捉器</td>
</tr>
<tr>
<td>handler.set()</td>
<td>属性设置操作的捕捉器</td>
</tr>
<tr>
<td>handler.deleteProperty()</td>
<td><code>delete</code> 操作符的捕捉器</td>
</tr>
<tr>
<td>handler.ownKeys()</td>
<td><code>Object.getOwnPropertyNames</code> 方法和 <code>Object.getOwnPropertySymbols</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.apply()</td>
<td>函数被<code>apply</code>调用操作的捕捉器</td>
</tr>
<tr>
<td>handler.construct()</td>
<td><code>new</code> 操作符的捕捉器</td>
</tr>
</tbody></table>
<h3 id="this指向的问题"><a href="#this指向的问题" class="headerlink" title="this指向的问题"></a>this指向的问题</h3><p><code>Proxy</code>对象可以对我们的目标对象进行访问，但没有做任何拦截时，也不能保证与目标对象的行为一致，因为目标对象内部的<code>this</code>会自动改变为<code>Proxy</code>代理对象。我们看下面这个例子就知道了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj=&#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;_island&#x27;</span>,<br> <span class="hljs-attr">foo</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> === objProxy<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> objProxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj,&#123;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">foo</span>()); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-title function_">foo</span>()); <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="对象监听案例"><a href="#对象监听案例" class="headerlink" title="对象监听案例"></a>对象监听案例</h3><p>某些场景下，需要监听一个对象的操作，当这个操作触发时执行另外的一个函数，就像<code>vue2</code>中的<code>watchApi</code>，它可以监听<code>data</code>数据中某个属性的改变并操作指定的函数。</p>
<p>我们看看下面这份代码，在<code>ES5</code>中使用<code>Object.defineProperty</code>（对象属性描述符）对对象的监听，将一个对象进行遍历，并设定<code>getter</code>、<code>setter</code>方法进行监听和拦截。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个Object对象</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> val = obj[key];<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;调用了get方法&quot;</span>);<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;调用了set方法&quot;</span>);<br>      val = newVal;<br>    &#125;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 操作obj对象</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;QC2125&quot;</span>;<br><span class="hljs-comment">// name调用了set方法</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// age调用了set方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <br><span class="hljs-comment">// name调用了get方法</span><br><span class="hljs-comment">// QC2125</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>Object.defineProperty</code>的设计初衷并不是为了去监听拦截一个对象中的属性，且他也实现不了更加丰富的操作，例如添加、删除属性等操作。所以在<code>ES6</code>中新增了<code>Proxy</code>对象，用于监听<code>Object</code>、<code>Function</code>的操作。</p>
<p>我们将上面通过<code>Object.defineProperty</code>实现对象监听的方法修改成<code>Proxy</code>方案。在Vue3框架中的响应式原理也是用到了Proxy对象进行对属性的监听操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-comment">// 获取值时的捕获器</span><br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到了<span class="hljs-subst">$&#123;key&#125;</span>被获取值`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-comment">// 设置值时的捕获器</span><br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, newValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到了<span class="hljs-subst">$&#123;key&#125;</span>被设置值`</span>);<br>    target[key] = newValue;<br>  &#125;<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 监听到了name被获取值</span><br><span class="hljs-comment">// _island</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>);<br><span class="hljs-comment">// 监听到了age被获取值</span><br><span class="hljs-comment">// 18</span><br>objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;QC2125&quot;</span>;<br><span class="hljs-comment">// 监听到了name被设置值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 监听到了name被获取值</span><br><span class="hljs-comment">// QC2125</span><br></code></pre></td></tr></table></figure>

<h2 id="33-x3D-和-x3D-x3D-的的区别"><a href="#33-x3D-和-x3D-x3D-的的区别" class="headerlink" title="33 =&#x3D;=和&#x3D;&#x3D;的的区别"></a>33 =&#x3D;=和&#x3D;&#x3D;的的区别</h2><ul>
<li><p>“&#x3D;&#x3D;” 只判断等号两边的值是否相等，而不判断类型是否相同。值相同则返回 true</p>
</li>
<li><p>“&#x3D;&#x3D;&#x3D;” 既要判断值是否相等，也要判断类型是否相同，即全等才能返回 true</p>
</li>
</ul>
<h3 id="x3D-x3D-的实现"><a href="#x3D-x3D-的实现" class="headerlink" title="&#x3D;&#x3D;的实现"></a>&#x3D;&#x3D;的实现</h3><p>在 JavaScript 中，使用双等号（&#x3D;&#x3D;）进行比较时，会进行类型转换，比较的是两个值是否相等。</p>
<p>如果比较的两个值类型相同，则直接比较它们的值。如果值相等，返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>如果比较的两个值类型不同，则 JavaScript 会尝试将其中一个值转换为另一个值的类型，然后再进行比较。类型转换的规则如下：</p>
<ol>
<li>如果比较的两个值类型相同，则直接比较它们的值。</li>
<li>如果其中一个值为 <code>null</code>，另一个值为 <code>undefined</code>，返回 <code>true</code>。</li>
<li>如果其中一个值为布尔值（<code>true</code> 或 <code>false</code>），另一个值为非布尔值，将布尔值转换为数字类型（<code>1</code> 或 <code>0</code>），然后再进行比较。</li>
<li>如果其中一个值为字符串，另一个值为数字，将字符串转换为数字，然后再进行比较。</li>
<li>如果其中一个值为对象，另一个值为字符串、数字或布尔值，则将对象调用 <code>valueOf()</code> 方法后得到的原始值，再进行比较。如果 <code>valueOf()</code> 方法返回的值不是原始值，则继续调用 <code>toString()</code> 方法，得到的字符串再进行比较。</li>
<li>如果其中一个值为字符串、数字或布尔值，另一个值为对象，则调用对象的 <code>valueOf()</code> 和 <code>toString()</code> 方法，得到的值再进行比较。</li>
<li>如果比较的两个值都是对象，则比较它们的引用是否相等。</li>
</ol>
<p>以下是一些示例：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">javascriptCopy code<br><span class="hljs-attribute">null</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> undefined<span class="hljs-comment">; // true</span><br><span class="hljs-attribute">true</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // true</span><br><span class="hljs-attribute">false</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; // true</span><br><span class="hljs-string">&quot;1&quot;</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // true</span><br>[] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">; // true</span><br>&#123;&#125; <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;[object Object]&quot;</span><span class="hljs-comment">; // true</span><br><span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> new String(<span class="hljs-string">&quot;abc&quot;</span>)<span class="hljs-comment">; // true</span><br></code></pre></td></tr></table></figure>

<p>由于双等号存在类型转换的问题，容易导致一些意想不到的问题，因此在实际开发中，建议使用三等号（&#x3D;&#x3D;&#x3D;）进行比较，它不会进行类型转换，只有两个值的类型和值都相同，才会返回 <code>true</code>。</p>
<h3 id="x3D-x3D-x3D-的实现"><a href="#x3D-x3D-x3D-的实现" class="headerlink" title="&#x3D;&#x3D;&#x3D;的实现"></a>&#x3D;&#x3D;&#x3D;的实现</h3><p>在 JavaScript 中，”&#x3D;&#x3D;&#x3D;” 运算符又称为严格相等运算符，它用于比较两个值是否严格相等，包括类型和值。</p>
<p>其实现过程如下：</p>
<ol>
<li>如果两个操作数的数据类型不同，则它们不相等，直接返回 false。</li>
<li>如果两个操作数都是 null 或者都是 undefined，则它们相等。</li>
<li>如果两个操作数都是布尔类型 true 或 false，则它们相等。</li>
<li>如果其中一个操作数是 NaN，则它们不相等。</li>
<li>如果两个操作数都是数字，并且值相等（包括 +0 和 -0），则它们相等。</li>
<li>如果两个操作数都是字符串，而且内容相同，则它们相等。</li>
<li>如果两个操作数指向同一个对象、数组或函数，则它们相等。</li>
<li>如果以上条件均不满足，则它们不相等。</li>
</ol>
<p>需要注意的是，当使用 “&#x3D;&#x3D;&#x3D;” 运算符比较两个引用类型的值时，比较的是它们在内存中的地址，而不是对象中存储的数据。因此，即使两个对象中存储的数据相同，它们也不会被认为是相等的，除非它们是同一个对象的引用。</p>
<h2 id="34-JavaScript中-null-和-undefined-的区别"><a href="#34-JavaScript中-null-和-undefined-的区别" class="headerlink" title="34 JavaScript中 null 和 undefined 的区别"></a>34 JavaScript中 null 和 undefined 的区别</h2><h3 id="一、JS-中的-null"><a href="#一、JS-中的-null" class="headerlink" title="一、JS 中的 null"></a>一、JS 中的 null</h3><h4 id="1-描述："><a href="#1-描述：" class="headerlink" title="1. 描述："></a>1. 描述：</h4><p>① 是 JavaScript 基本类型之一，特指对象的值未设置，是表示缺少的标识，指示变量未指向任何对象，把 null 看为尚未创建的对象，也许更好理解；<br> ② 是一个字面量，不像 undefined，它不是全局对象的一个属性；<br> ③ 在布尔运算中被认为是 false；<br> ④ 与其他任何对象一样永远不会被 JavaScript 隐式赋值给变量。</p>
<p>注：如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 false，其他值都视为 true。</p>
<p>undefined<br> null<br> false<br> 0<br> NaN<br> “” 或 ‘’（空字符串）</p>
<h4 id="2-典型用法："><a href="#2-典型用法：" class="headerlink" title="2. 典型用法："></a>2. 典型用法：</h4><p>（1） 作为函数的参数，表示该函数的参数为空。</p>
<p>（2） 作为对象原型链的终点。</p>
<h3 id="二、JS-中的-undefined"><a href="#二、JS-中的-undefined" class="headerlink" title="二、JS 中的 undefined"></a>二、JS 中的 undefined</h3><ol>
<li><p>描述：<br>① 是 JavaScript 基本类型之一，表示 “缺少值”，就是此处应该有一个值，但是还没有定义；<br>② 是 JavaScript 在运行时创建的全局变量，是全局对象的一个属性；<br>③ 在布尔运算中被认为是 false。<br>注：有关全局对象和全局变量，可参考 javascript 全局对象与全局变量</p>
</li>
<li><p>典型用法：</p>
<p>（1）变量被声明但没有赋值时，就等于 undefined。</p>
<p>（2）对象的某个属性没有赋值时，该属性的值为 undefined。</p>
<p>（3）调用函数过程中，应该提供的参数没有提供时，该参数就等于 undefined。</p>
<p>（4）函数没有返回值时，默认返回 undefined。</p>
</li>
</ol>
<h3 id="三、JS-中的-undefined-和-null-的区别有："><a href="#三、JS-中的-undefined-和-null-的区别有：" class="headerlink" title="三、JS 中的 undefined 和 null 的区别有："></a>三、JS 中的 undefined 和 null 的区别有：</h3><h4 id="1-相等但不全等："><a href="#1-相等但不全等：" class="headerlink" title="1. 相等但不全等："></a>1. 相等但不全等：</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">	<span class="hljs-attr">null</span> == undefined	// <span class="hljs-literal">true</span><br>	<span class="hljs-attr">null</span> === undefined 	// <span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>实际上，undefined 值是派生自 null 值的，ECMAScript 标准规定对二者进行相等性测试要返回 true，可以理解为 null 和 undefined 都代表着无效的值，所以二者相等，但由于是两种不同的原始数据类型，所以不全等。</p>
<p>注：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">	<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>	<span class="hljs-comment">// undefined</span><br>	<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>		<span class="hljs-comment">// object</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>① typeof null 结果是 object，这是个历史遗留 bug，参考 js 中 typeof 用法详细介绍；<br> ② 在 ECMA6 中，曾经有提案为历史平反，将 typeof null 的值纠正为 null，但最后提案被拒了，理由是历史遗留代码太多，不想得罪人，不如继续将错就错当和事老。</p>
<h4 id="2-在数字运算中被转换为-number-类型的值不同"><a href="#2-在数字运算中被转换为-number-类型的值不同" class="headerlink" title="2. 在数字运算中被转换为 number 类型的值不同"></a>2. 在数字运算中被转换为 number 类型的值不同</h4><p>在 null 上执行算术转换时，确定的值为 0</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">	let <span class="hljs-attr">a</span> = <span class="hljs-number">10</span> + null<span class="hljs-comment">;</span><br>	<br>	console.log(a)<span class="hljs-comment">;	// 10	</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>undefined 得出的结果为 NaN</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">	let <span class="hljs-attr">b</span> = <span class="hljs-number">10</span> + undefined<span class="hljs-comment">;</span><br>	<br>	console.log(b)<span class="hljs-comment">;	// NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注：有关加法运算中的隐式类型转换，可参考 “加号 +” 的运算原理（详细！！！）</p>
<h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><p>都是原始类型的值，保存在栈中变量本地</p>
<h3 id="何时使用："><a href="#何时使用：" class="headerlink" title="何时使用："></a>何时使用：</h3><p>null当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null;</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">arr</span>=[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;cc&quot;</span>]<span class="hljs-comment">;</span><br><span class="hljs-attr">arr</span>=null<span class="hljs-comment">;//释放指向数组的引用</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="额外补充的知识"><a href="#额外补充的知识" class="headerlink" title="额外补充的知识"></a>额外补充的知识</h3><p>数组进行相等比较是一个怪物，看下面的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua">	[] == <span class="hljs-string">&#x27;&#x27;</span>   // -&gt; <span class="hljs-literal">true</span><br>	[] == <span class="hljs-number">0</span>    // -&gt; <span class="hljs-literal">true</span><br>	[<span class="hljs-string">&#x27;&#x27;</span>] == <span class="hljs-string">&#x27;&#x27;</span> // -&gt; <span class="hljs-literal">true</span><br>	[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>   // -&gt; <span class="hljs-literal">true</span><br>	[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;&#x27;</span>  // -&gt; <span class="hljs-literal">false</span><br>	[<span class="hljs-string">&#x27;&#x27;</span>] == <span class="hljs-number">0</span>  // -&gt; <span class="hljs-literal">true</span><br>	<br>	[null] == <span class="hljs-string">&#x27;&#x27;</span>      // <span class="hljs-literal">true</span><br>	[null] == <span class="hljs-number">0</span>       // <span class="hljs-literal">true</span><br>	[undefined] == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	[undefined] == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[[[[[]]]]]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[[[[[]]]]]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[[[[[ null ]]]]]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[[[[[ null ]]]]]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[[[[[ undefined ]]]]]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[[[[[ undefined ]]]]]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>个人理解：</p>
<p> 以上例子可以理解为，在比较过程中， [] 、[null] 和 [undefined] 都隐式转换为 ‘’；</p>
<p> 对于最里层的 [] ，不管外层嵌套多少个 [] ，最终都可看成只有最里层一个 [] 。</p>
<h3 id="Null，NaN，Undefined"><a href="#Null，NaN，Undefined" class="headerlink" title="Null，NaN，Undefined"></a>Null，NaN，Undefined</h3><p>null：空对象，一般作为对象的初值</p>
<p>Nan：浮点数中表示未定义或不可表示的值，例如0&#x2F;0、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E2%88%9E?fromModule=lemma_inlink">∞</a>&#x2F;∞、∞&#x2F;−∞、−∞&#x2F;∞、−∞&#x2F;−∞</p>
<p>undefined：未定义，声明但未定义，例如，形参未传参，获取return的函数返回，对象属性名不存在</p>
<h3 id="toString，valueOf"><a href="#toString，valueOf" class="headerlink" title="toString，valueOf"></a>toString，valueOf</h3><p>javascript中所有数据类型都拥有valueOf和toString这两个方法，null和undefined除外（String() 都能转）</p>
<p>valueOf偏向于运算，toString偏向于显示</p>
<h1 id="over-point"><a href="#over-point" class="headerlink" title="over point"></a>over point</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" class="category-chain-item">前端八股</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/blog/tags/%E8%AE%A1%E7%AE%97/">#计算</a>
      
        <a href="/blog/tags/javascript/">#javascript</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端八股 ｜ js篇</div>
      <div>https://yoonalis.github.io/blog/2023/04/06/前端八股 ｜js篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9Cjs%E7%AF%872/" title="前端八股 ｜ js篇2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前端八股 ｜ js篇2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20css%E7%AF%87/" title="前端八股 ｜ css篇">
                        <span class="hidden-mobile">前端八股 ｜ css篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
