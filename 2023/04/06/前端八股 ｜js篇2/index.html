

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="react">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股 ｜ js篇2">
<meta property="og:url" content="https://yoonalis.github.io/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9Cjs%E7%AF%872/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="react">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
<meta property="article:published_time" content="2023-04-06T13:31:21.932Z">
<meta property="article:modified_time" content="2023-04-12T01:36:11.446Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="计算">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>前端八股 ｜ js篇2 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端八股 ｜ js篇2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-06 21:31" pubdate>
          2023年4月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          73k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          609 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端八股 ｜ js篇2</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前端八股-｜js篇2"><a href="#前端八股-｜js篇2" class="headerlink" title="前端八股 ｜js篇2"></a>前端八股 ｜js篇2</h1><h2 id="20-js数组常用方法"><a href="#20-js数组常用方法" class="headerlink" title="20 js数组常用方法"></a>20 js数组常用方法</h2><h3 id="一、改变原数组的方法"><a href="#一、改变原数组的方法" class="headerlink" title="一、改变原数组的方法"></a>一、改变原数组的方法</h3><h4 id="1-push（）-末尾添加数据"><a href="#1-push（）-末尾添加数据" class="headerlink" title="1.push（） 末尾添加数据"></a><strong>1.push（） 末尾添加数据</strong></h4><p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong> 就是往数组末尾添加数据</p>
<p><strong>返回值:</strong>  就是这个数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //push">var arr = [10, 20, 30, 40]<br>res = arr.push(20)<br>console.log(arr);//[10,20,30,40,20]<br>console.log(res);//5<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-pop（）-末尾出删除数据"><a href="#2-pop（）-末尾出删除数据" class="headerlink" title="2. pop（） 末尾出删除数据"></a>2. pop（） 末尾出删除数据</h4><p><strong>语法:</strong> <strong>数组名.pop()</strong></p>
<p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p>
<p><strong>返回值:</strong> 就是你删除的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //pop">var arr = [10, 20, 30, 40] <br>res =arr.pop()<br>console.log(arr);//[10,20,30]<br>console.log(res);//40<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3-unshift（）-头部添加数据"><a href="#3-unshift（）-头部添加数据" class="headerlink" title="3.unshift（） 头部添加数据"></a>3.unshift（） 头部添加数据</h4><p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong>  就是在数组的头部添加数据</p>
<p><strong>返回值:</strong> 就是数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //pop"> var arr = [10, 20, 30, 40]<br> res=arr.unshift(99)<br> console.log(arr);//[99,10,20,30,40]<br> console.log(res);//5<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-shift（）-头部删除数据"><a href="#4-shift（）-头部删除数据" class="headerlink" title="4.shift（） 头部删除数据"></a>4.shift（） 头部删除数据</h4><p><strong>语法:</strong> <strong>数组名.shift()</strong></p>
<p><strong>作用:</strong>  头部删除一个数据</p>
<p><strong>返回值:</strong>  就是删除掉的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //shift"> var arr = [10, 20, 30, 40]<br> res=arr.shift()<br> console.log(arr);[20,30,40]<br> console.log(res);10<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-reverse（）-翻转数组"><a href="#5-reverse（）-翻转数组" class="headerlink" title="5.reverse（） 翻转数组"></a>5.reverse（） 翻转数组</h4><p><strong>语法:</strong> <strong>数组名.reverse()</strong></p>
<p><strong>作用:</strong> 就是用来翻转数组的</p>
<p><strong>返回值:</strong> 就是翻转好的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure>

<h4 id="6-sort（）-排序"><a href="#6-sort（）-排序" class="headerlink" title="6.sort（） 排序"></a>6.sort（） 排序</h4><p>语法一: 数组名.sort()会排序 会按照位排序</p>
<p>语法二: 数组名.sort(function (a,b) {return a-b})  会正序排列</p>
<p>语法三: 数组名.sort(function (a,b) {return b-a})  会倒序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //sort()">var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]<br>arr.sort()<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(a-b)&#125;)<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(b-a)&#125;)<br>console.log(arr);<br></code></pre></td></tr></table></figure>

<h4 id="7-splice（）-截取数组"><a href="#7-splice（）-截取数组" class="headerlink" title="7.splice（）  截取数组"></a>7.splice（）  截取数组</h4><p>语法一: 数组名.splice(开始索引,多少个)</p>
<p>作用: 就是用来截取数组的</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<p>语法二: 数组名.splice(开始索引,多少个,你要插入的数据)</p>
<p>作用: 删除并插入数据</p>
<p>注意: 从你的开始索引起</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr);<br>console.log(res);<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr);<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h3 id="二、不改变原数组的方法"><a href="#二、不改变原数组的方法" class="headerlink" title="二、不改变原数组的方法"></a>二、不改变原数组的方法</h3><h4 id="1-concat（）合并数组"><a href="#1-concat（）合并数组" class="headerlink" title="1.concat（）合并数组"></a>1.concat（）合并数组</h4><p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong>  合并数组的</p>
<p><strong>返回值:</strong>  一个新的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //concat">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.concat(20,&quot;小敏&quot;,50)<br>console.log(arr) <br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-join（）-数组转字符串"><a href="#2-join（）-数组转字符串" class="headerlink" title="2.join（） 数组转字符串"></a>2.join（） 数组转字符串</h4><p><strong>语法:</strong> <strong>数组名.join(‘</strong> <strong>连接符’)</strong></p>
<p><strong>作用:</strong> 就是把一个数组转成字符串</p>
<p><strong>返回值:</strong>  就是转好的一个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //join">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.join(&quot;+&quot;)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h4 id="3-slice（）截取数组的一部分数据"><a href="#3-slice（）截取数组的一部分数据" class="headerlink" title="3.slice（）截取数组的一部分数据"></a>3.slice（）截取数组的一部分数据</h4><p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p>
<p><strong>作用:</strong> 就是截取数组中的一部分数据</p>
<p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p>
<p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-indexOf-从左检查数组中有没有这个数值"><a href="#4-indexOf-从左检查数组中有没有这个数值" class="headerlink" title="4.indexOf 从左检查数组中有没有这个数值"></a>4.indexOf 从左检查数组中有没有这个数值</h4><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr)<br>console.log(res);<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-lastIndexOf-从右检查数组中有没有这个数值"><a href="#5-lastIndexOf-从右检查数组中有没有这个数值" class="headerlink" title="5.lastIndexOf 从右检查数组中有没有这个数值"></a>5.lastIndexOf 从右检查数组中有没有这个数值</h4><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="三、ES6新增的数组方法"><a href="#三、ES6新增的数组方法" class="headerlink" title="三、ES6新增的数组方法"></a>三、ES6新增的数组方法</h3><h4 id="1-forEach-用来循环遍历的-for"><a href="#1-forEach-用来循环遍历的-for" class="headerlink" title="1. forEach()  用来循环遍历的 for"></a>1. forEach()  用来循环遍历的 for</h4><p>语法: 数组名.forEach(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来循环遍历数组的 代替了我们的for</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-map-映射数组的"><a href="#2-map-映射数组的" class="headerlink" title="2.map  映射数组的"></a>2.map  映射数组的</h4><p>语法: 数组名.map(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来映射</p>
<p>返回值: 必然是一个数组 一个映射完毕的数组；这个数组合原数组长度一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //map">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.map(function (item) &#123;<br>    return item*1000<br>&#125;)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3-filter-过滤数组"><a href="#3-filter-过滤数组" class="headerlink" title="3.filter  过滤数组"></a>3.filter  过滤数组</h4><p>语法: 数组名.filter(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来过滤数组的</p>
<p>返回值: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-every-判断数组是不是满足所有条件"><a href="#4-every-判断数组是不是满足所有条件" class="headerlink" title="4.every  判断数组是不是满足所有条件"></a>4.every  判断数组是不是满足所有条件</h4><p>语法: 数组名.every(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> 只有所有的都满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要有一个不满足返回的就是<span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值 注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //every">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-some（）-数组中有没有满足条件的"><a href="#5-some（）-数组中有没有满足条件的" class="headerlink" title="5.some（） 数组中有没有满足条件的"></a>5.some（） 数组中有没有满足条件的</h4><p>语法: 数组名.some(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> 只有有一个满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要都不满足返回的就是<span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res);//true<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="6-find（）用来获取数组中满足条件的第一个数据"><a href="#6-find（）用来获取数组中满足条件的第一个数据" class="headerlink" title="6.find（）用来获取数组中满足条件的第一个数据"></a>6.find（）用来获取数组中满足条件的第一个数据</h4><p>语法: 数组名.find(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来获取数组中满足条件的数据</p>
<p>返回值: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res)//4<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="7-reduce（）叠加后的效果"><a href="#7-reduce（）叠加后的效果" class="headerlink" title="7.reduce（）叠加后的效果"></a>7.reduce（）叠加后的效果</h4><p>语法: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p>
<ul>
<li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来叠加的</p>
<p>返回值: 就是叠加后的结果</p>
<p>注意: 以return的形式书写返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //reduce">var arr = [1, 2, 3, 4, 5]<br>var res = arr.reduce(function (prev, item) &#123;<br>    return prev *= item<br>&#125;, 1)<br>console.log(res);//120<br><br></code></pre></td></tr></table></figure>

<h2 id="21-js-字符串常用方法"><a href="#21-js-字符串常用方法" class="headerlink" title="21 js 字符串常用方法"></a>21 js 字符串常用方法</h2><h3 id="1-获取字符串长度"><a href="#1-获取字符串长度" class="headerlink" title="1. 获取字符串长度"></a>1. 获取字符串长度</h3><p>JavaScript中的字符串有一个length属性，该属性可以用来获取字符串的长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-property">length</span>   <span class="hljs-comment">// 输出结果：5</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="2-获取字符串指定位置的值"><a href="#2-获取字符串指定位置的值" class="headerlink" title="2. 获取字符串指定位置的值"></a>2. 获取字符串指定位置的值</h3><p>charAt()和charCodeAt()方法都可以通过索引来获取指定位置的值：</p>
<ul>
<li>charAt() 方法获取到的是指定位置的字符；</li>
<li>charCodeAt()方法获取的是指定位置字符的Unicode值。</li>
</ul>
<h4 id="（1）charAt"><a href="#（1）charAt" class="headerlink" title="（1）charAt()"></a>（1）charAt()</h4><p>charAt() 方法可以返回指定位置的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">charAt</span>(index)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>index表示字符在字符串中的索引值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 输出结果：e </span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们知道，字符串也可以通过索引值来直接获取对应字符，那它和charAt()有什么区别呢？来看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 输出结果：e </span><br>str[<span class="hljs-number">1</span>]         <span class="hljs-comment">// 输出结果：e </span><br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出结果：&#x27;&#x27; </span><br>str[<span class="hljs-number">5</span>]         <span class="hljs-comment">// 输出结果：undefined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>可以看到，当index的取值不在str的长度范围内时，str[index]会返回undefined，而charAt(index)会返回空字符串；除此之外，str[index]不兼容ie6-ie8，charAt(index)可以兼容。</p>
<h4 id="（2）charCodeAt"><a href="#（2）charCodeAt" class="headerlink" title="（2）charCodeAt()"></a>（2）charCodeAt()</h4><p><code>charCodeAt()</code>：该方法会返回指定索引位置字符的 Unicode 值，返回值是 0 - 65535 之间的整数，表示给定索引处的 UTF-16 代码单元，如果指定位置没有字符，将返回 <strong>NaN</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// &quot;b&quot; --&gt; 98</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过这个方法，可以获取字符串中指定Unicode编码值范围的字符。比如，数字0～9的Unicode编码范围是: 48～57，可以通过这个方法来筛选字符串中的数字，当然如果你更熟悉正则表达式，会更方便。</p>
<h3 id="3-检索字符串是否包含特定序列"><a href="#3-检索字符串是否包含特定序列" class="headerlink" title="3. 检索字符串是否包含特定序列"></a>3. 检索字符串是否包含特定序列</h3><p>这5个方法都可以用来检索一个字符串中是否包含特定的序列。其中前两个方法得到的指定元素的索引值，并且只会返回第一次匹配到的值的位置。后三个方法返回的是布尔值，表示是否匹配到指定的值。</p>
<p>注意：这5个方法都对大小写敏感！</p>
<h4 id="（1）indexOf"><a href="#（1）indexOf" class="headerlink" title="（1）indexOf()"></a>（1）indexOf()</h4><p><code>indexOf()</code>：查找某个字符，<strong>有则返回第一次匹配到的位置</strong>，否则返回-1，其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">indexOf</span>(searchvalue,fromindex)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，规定需检索的字符串值；</li>
<li>fromindex：可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 string.length - 1。如省略该，则从字符串的首字符开始检索。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefgabc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;a&quot;</span>));   <span class="hljs-comment">// 输出结果：0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;z&quot;</span>));   <span class="hljs-comment">// 输出结果：-1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// 输出结果：9</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）lastIndexOf"><a href="#（2）lastIndexOf" class="headerlink" title="（2）lastIndexOf()"></a>（2）lastIndexOf()</h4><p><code>lastIndexOf()</code>：查找某个字符，有则返回最后一次匹配到的位置，否则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcabc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;a&quot;</span>));  <span class="hljs-comment">// 输出结果：3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;z&quot;</span>));  <span class="hljs-comment">// 输出结果：-1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法和indexOf()类似，只是查找的顺序不一样，indexOf()是正序查找，lastIndexOf()是逆序查找。</p>
<h4 id="（3）includes"><a href="#（3）includes" class="headerlink" title="（3）includes()"></a>（3）includes()</h4><p><code>includes()</code>：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。该方法的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">includes</span>(searchvalue, start)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要查找的字符串；</li>
<li>start：可选，设置从那个位置开始查找，默认为 0。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;o&#x27;</span>)  <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;z&#x27;</span>)  <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 输出结果：false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（4）startsWith"><a href="#（4）startsWith" class="headerlink" title="（4）startsWith()"></a>（4）startsWith()</h4><p><code>startsWith()</code>：该方法用于检测字符串<strong>是否以指定的子字符串开始</strong>。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Helle&#x27;</span>) <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;wo&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 输出结果：true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（5）endsWith"><a href="#（5）endsWith" class="headerlink" title="（5）endsWith()"></a>（5）endsWith()</h4><p><code>endsWith()</code>：该方法用来判断当前字符串<strong>是否是以指定的子字符串结尾</strong>。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">endsWith</span>(searchvalue, length)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要搜索的子字符串；</li>
<li>length： 设置字符串的长度，默认值为原始字符串长度 string.length。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)       <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;llo&#x27;</span>)     <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;llo&#x27;</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出结果：true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>可以看到，当第二个参数设置为5时，就会从字符串的前5个字符中进行检索，所以会返回true。</p>
<h3 id="4-连接多个字符串"><a href="#4-连接多个字符串" class="headerlink" title="4. 连接多个字符串"></a>4. 连接多个字符串</h3><p>concat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">concat</span>(string1, string2, ..., stringX)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>其中参数 string1, string2, …, stringX 是必须的，他们将被连接为一个字符串的一个或多个字符串对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;efg&quot;</span>));          <span class="hljs-comment">//输出结果：&quot;abcefg&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;efg&quot;</span>,<span class="hljs-string">&quot;hijk&quot;</span>)); <span class="hljs-comment">//输出结果：&quot;abcefghijk&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>虽然concat()方法是专门用来拼接字符串的，但是在开发中使用最多的还是加操作符+，因为其更加简单。</p>
<h3 id="5-字符串分割成数组"><a href="#5-字符串分割成数组" class="headerlink" title="5. 字符串分割成数组"></a>5. 字符串分割成数组</h3><p>split() 方法用于把一个字符串分割成字符串数组。该方法不会改变原始字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">split</span>(separator,limit)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>separator：必需。字符串或正则表达式，从该参数指定的地方分割 string。</li>
<li>limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;c&quot;</span>);    <span class="hljs-comment">// 输出结果：[&quot;ab&quot;, &quot;def&quot;]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">4</span>)   <span class="hljs-comment">// 输出结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] </span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果把空字符串用作 separator，那么字符串中的每个字符之间都会被分割。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);     <span class="hljs-comment">// 输出结果：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>其实在将字符串分割成数组时，可以同时拆分多个分割符，使用正则表达式即可实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-string">&quot;apples,bananas;cherries&quot;</span><br><span class="hljs-keyword">const</span> fruits = list.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[,;]/</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits);  <span class="hljs-comment">// 输出结果：[&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="6-截取字符串"><a href="#6-截取字符串" class="headerlink" title="6. 截取字符串"></a>6. 截取字符串</h3><p>substr()、substring()和 slice() 方法都可以用来截取字符串。</p>
<h4 id="（1）-slice"><a href="#（1）-slice" class="headerlink" title="（1） slice()"></a>（1） slice()</h4><p>slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">slice</span>(start,end)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。</li>
<li>end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</li>
</ul>
<p>上面说了，如果start是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdef&quot; </span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);     <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; </span><br>str.<span class="hljs-title function_">slice</span>();      <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; </span><br>str.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">2</span>);    <span class="hljs-comment">// 输出结果：&quot;fg&quot;</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h4 id="（2）-substr"><a href="#（2）-substr" class="headerlink" title="（2） substr()"></a>（2） substr()</h4><p>substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">substr</span>(start,length)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start	必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</li>
<li>length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; </span><br>str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; 相当于截取[1,str.length-1]</span><br>str.<span class="hljs-title function_">substr</span>();    <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; 相当于截取[0,str.length-1]</span><br>str.<span class="hljs-title function_">substr</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;g&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）-substring"><a href="#（3）-substring" class="headerlink" title="（3） substring()"></a>（3） substring()</h4><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">substring</span>(<span class="hljs-keyword">from</span>, to)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。</li>
<li>to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</li>
</ul>
<p><strong>注意：</strong> 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">// 输出结果：&quot;bcdef&quot; [1,6)</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; [1,str.length-1]</span><br>str.<span class="hljs-title function_">substring</span>();    <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; [0,str.length-1]</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出结果 &quot;bcdef&quot; [1,6)</span><br>str.<span class="hljs-title function_">substring</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h3 id="7-字符串大小写转换"><a href="#7-字符串大小写转换" class="headerlink" title="7. 字符串大小写转换"></a>7. 字符串大小写转换</h3><p>toLowerCase() 和 toUpperCase()方法可以用于字符串的大小写转换。</p>
<h4 id="（1）toLowerCase"><a href="#（1）toLowerCase" class="headerlink" title="（1）toLowerCase()"></a>（1）toLowerCase()</h4><p><code>toLowerCase()</code>：该方法用于把字符串转换为小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;adABDndj&quot;</span>;<br>str.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// 输出结果：&quot;adabdndj&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）toUpperCase"><a href="#（2）toUpperCase" class="headerlink" title="（2）toUpperCase()"></a>（2）toUpperCase()</h4><p><code>toUpperCase()</code>：该方法用于把字符串转换为大写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;adABDndj&quot;</span>;<br>str.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// 输出结果：&quot;ADABDNDJ&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们可以用这个方法来将字符串中第一个字母变成大写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> word = <span class="hljs-string">&#x27;apple&#x27;</span><br>word = word[<span class="hljs-number">0</span>].<span class="hljs-title function_">toUpperCase</span>() + word.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(word) <span class="hljs-comment">// 输出结果：&quot;Apple&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="8-字符串模式匹配"><a href="#8-字符串模式匹配" class="headerlink" title="8. 字符串模式匹配"></a>8. 字符串模式匹配</h3><p>replace()、match()和search()方法可以用来匹配或者替换字符。</p>
<h4 id="（1）replace"><a href="#（1）replace" class="headerlink" title="（1）replace()"></a>（1）replace()</h4><p><code>replace()</code>：该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">replace</span>(searchvalue, newvalue)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需。规定子字符串或要替换的模式的 RegExp 对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</li>
<li>newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>) <span class="hljs-comment">// 输出结果：abzdef</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>执行一个全局替换, 忽略大小写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;Mr Blue has a blue house and a blue car&quot;</span>;<br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/blue/gi</span>, <span class="hljs-string">&quot;red&quot;</span>);    <span class="hljs-comment">// 输出结果：&#x27;Mr red has a red house and a red car&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p>
<h4 id="（2）match"><a href="#（2）match" class="headerlink" title="（2）match()"></a>（2）match()</h4><p><code>match()</code>：该方法用于在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">match</span>(regexp)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法的参数 regexp 是必需的，规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。</p>
<p><strong>注意：</strong> 该方法返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-string">&quot;c&quot;</span>)) <span class="hljs-comment">// [&quot;c&quot;, index: 2, input: &quot;abcdef&quot;, groups: undefined]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）search"><a href="#（3）search" class="headerlink" title="（3）search()"></a>（3）search()</h4><p><code>search()</code>方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">search</span>(searchvalue)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法的参数 regex 可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。</p>
<p><strong>注意：</strong> 要执行忽略大小写的检索，请追加标志 i。该方法不执行全局匹配，它将忽略标志 g，也就是只会返回第一次匹配成功的结果。如果没有找到任何匹配的子串，则返回 -1。</p>
<p><strong>返回值：</strong> 返回 str 中第一个与 regexp 相匹配的子串的起始位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/bcd/</span>)   <span class="hljs-comment">// 输出结果：1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="9-移除字符串收尾空白符"><a href="#9-移除字符串收尾空白符" class="headerlink" title="9. 移除字符串收尾空白符"></a>9. 移除字符串收尾空白符</h3><p>trim()、trimStart()和trimEnd()这三个方法可以用于移除字符串首尾的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。</p>
<h4 id="（1）trim"><a href="#（1）trim" class="headerlink" title="（1）trim()"></a>（1）trim()</h4><p>trim() 方法用于移除字符串首尾空白符，该方法不会改变原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;  abcdef  &quot;</span><br>str.<span class="hljs-title function_">trim</span>()    <span class="hljs-comment">// 输出结果：&quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法不适用于null、undefined、Number类型。</p>
<h4 id="（2）trimStart"><a href="#（2）trimStart" class="headerlink" title="（2）trimStart()"></a>（2）trimStart()</h4><p>trimStart() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的开头删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br><br>s.<span class="hljs-title function_">trimStart</span>()   <span class="hljs-comment">// &quot;abc  &quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）trimEnd"><a href="#（3）trimEnd" class="headerlink" title="（3）trimEnd()"></a>（3）trimEnd()</h4><p>trimEnd() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的结尾删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br><br>s.<span class="hljs-title function_">trimEnd</span>()   <span class="hljs-comment">// &quot;  abc&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="10-获取字符串本身"><a href="#10-获取字符串本身" class="headerlink" title="10. 获取字符串本身"></a>10. 获取字符串本身</h3><p>valueOf()和toString()方法都会返回字符串本身的值，感觉用处不大。</p>
<h4 id="（1）valueOf"><a href="#（1）valueOf" class="headerlink" title="（1）valueOf()"></a>（1）valueOf()</h4><p><code>valueOf()</code>：返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">valueOf</span>()) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）toString"><a href="#（2）toString" class="headerlink" title="（2）toString()"></a>（2）toString()</h4><p><code>toString()</code>：返回字符串对象本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="11-重复一个字符串"><a href="#11-重复一个字符串" class="headerlink" title="11. 重复一个字符串"></a>11. 重复一个字符串</h3><p>repeat() 方法返回一个新字符串，表示将原字符串重复n次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)     <span class="hljs-comment">// 输出结果：&quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 输出结果：&quot;hellohello&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">0</span>)    <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是小数，会向下取整：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2.9</span>) <span class="hljs-comment">// 输出结果：&quot;nana&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是负数或者Infinity，会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-title class_">Infinity</span>)   <span class="hljs-comment">// RangeError</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(-<span class="hljs-number">1</span>)         <span class="hljs-comment">// RangeError</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(-<span class="hljs-number">0.9</span>)   <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是NaN，就等同于 0：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-title class_">NaN</span>)    <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果repeat的参数是字符串，则会先转换成数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-string">&#x27;na&#x27;</span>)   <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-string">&#x27;3&#x27;</span>)    <span class="hljs-comment">// 输出结果：&quot;nanana&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="12-补齐字符串长度"><a href="#12-补齐字符串长度" class="headerlink" title="12. 补齐字符串长度"></a>12. 补齐字符串长度</h3><p>padStart()和padEnd()方法用于补齐字符串的长度。如果某个字符串不够指定长度，会在头部或尾部补全。</p>
<h4 id="（1）padStart"><a href="#（1）padStart" class="headerlink" title="（1）padStart()"></a>（1）padStart()</h4><p><code>padStart()</code>用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 </p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;x&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;ababx&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;abax&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果省略第二个参数，默认使用空格补全长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// &#x27;   x&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>padStart()的常见用途是为数值补全指定位数，笔者最近做的一个需求就是将返回的页数补齐为三位，比如第1页就显示为001，就可以使用该方法来操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;1&quot;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)   <span class="hljs-comment">// 输出结果： &#x27;001&#x27;</span><br><span class="hljs-string">&quot;15&quot;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)  <span class="hljs-comment">// 输出结果： &#x27;015&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）padEnd"><a href="#（2）padEnd" class="headerlink" title="（2）padEnd()"></a>（2）padEnd()</h4><p><code>padEnd()</code>用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xabab&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xaba&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="13-字符串转为数字"><a href="#13-字符串转为数字" class="headerlink" title="13. 字符串转为数字"></a>13. 字符串转为数字</h3><p>parseInt()和parseFloat()方法都用于将字符串转为数字。</p>
<h4 id="（1）parseInt"><a href="#（1）parseInt" class="headerlink" title="（1）parseInt()"></a>（1）parseInt()</h4><p>parseInt() 方法用于可解析一个字符串，并返回一个整数。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(string, radix)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>string：必需。要被解析的字符串。</li>
<li>radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</li>
</ul>
<p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>);			  <span class="hljs-comment">// 输出结果：10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;17&quot;</span>,<span class="hljs-number">8</span>);		  <span class="hljs-comment">// 输出结果：15 (8+7)</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;010&quot;</span>);		  <span class="hljs-comment">// 输出结果：10 或 8</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>当参数 radix 的值以 “0x” 或 “0X” 开头，将以 16 为基数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0x10&quot;</span>)      <span class="hljs-comment">// 输出结果：16</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;50&quot;</span>, <span class="hljs-number">1</span>)      <span class="hljs-comment">// 输出结果：NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;50&quot;</span>, <span class="hljs-number">40</span>)     <span class="hljs-comment">// 输出结果：NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>只有字符串中的第一个数字会被返回，当遇到第一个不是数字的字符为止:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;40 4years&quot;</span>)   <span class="hljs-comment">// 输出结果：40</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果字符串的第一个字符不能被转换为数字，就会返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;new100&quot;</span>)     <span class="hljs-comment">// 输出结果：NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>字符串开头和结尾的空格是允许的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;  60  &quot;</span>)    <span class="hljs-comment">// 输出结果： 60</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）parseFloat"><a href="#（2）parseFloat" class="headerlink" title="（2）parseFloat()"></a>（2）parseFloat()</h4><p>parseFloat() 方法可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(string)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>parseFloat 将它的字符串参数解析成为浮点数并返回。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.00&quot;</span>)      <span class="hljs-comment">// 输出结果：10.00</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.01&quot;</span>)      <span class="hljs-comment">// 输出结果：10.01</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;-10.01&quot;</span>)     <span class="hljs-comment">// 输出结果：-10.01</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;40.5 years&quot;</span>) <span class="hljs-comment">// 输出结果：40.5</span><br><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;new40.5&quot;</span>)    <span class="hljs-comment">// 输出结果：NaN</span><br></code></pre></td></tr></table></figure>

<h2 id="22-JS-判断数据类型的-8-种方式"><a href="#22-JS-判断数据类型的-8-种方式" class="headerlink" title="22 JS 判断数据类型的 8 种方式"></a>22 JS 判断数据类型的 8 种方式</h2><h3 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h3><ul>
<li>只能识别基础类型和引用类型</li>
</ul>
<p>注意：<code>null</code>、 <code>NaN</code>、 <code>document.all</code> 的判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">all</span>); <span class="hljs-comment">// undefined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2、constructor"><a href="#2、constructor" class="headerlink" title="2、constructor"></a>2、constructor</h3><ul>
<li><code>constructor</code> 指向创建该实例对象的构造函数</li>
</ul>
<p>注意 <code>null</code> 和 <code>undefined</code> 没有 <code>constructor</code>，以及 <code>constructor</code> 可以被改写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;云牧&quot;</span>.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// [Function: fn]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3、instanceof"><a href="#3、instanceof" class="headerlink" title="3、instanceof"></a>3、instanceof</h3><ul>
<li>语法：<code>obj instanceof Type</code></li>
<li>功能：判断 <code>obj</code> 是不是 <code>Type</code> 类的实例，只可用来判断引用数据</li>
<li>实现思路： <code>Type</code> 的原型对象是否是 <code>obj</code> 的原型链上的某个对象</li>
<li>注意：右操作数必须是函数或者 class</li>
</ul>
<p>手写 <code>instanceof</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">Fn, obj</span>) &#123;<br>  <span class="hljs-comment">// 获取该函数显示原型</span><br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-comment">// 获取obj的隐式原型</span><br>  <span class="hljs-keyword">let</span> proto = obj.<span class="hljs-property">__proto__</span>;<br>  <span class="hljs-comment">// 遍历原型链</span><br>  <span class="hljs-keyword">while</span> (proto) &#123;<br>    <span class="hljs-comment">// 检测原型是否相等</span><br>    <span class="hljs-keyword">if</span> (proto === prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果不等于则继续往深处查找</span><br>    proto = proto.<span class="hljs-property">__proto__</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4、isPrototypeof"><a href="#4、isPrototypeof" class="headerlink" title="4、isPrototypeof"></a>4、isPrototypeof</h3><ul>
<li>是否在实例对象的原型链上</li>
<li>功能基本等同于 <code>instanceof</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isPrototypeOf</span>(&#123;&#125;)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(&#123;&#125;)); <span class="hljs-comment">// true  期望左操作数是一个原型，&#123;&#125; 原型链能找到 Object.prototype</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5、Object-prototype-toString"><a href="#5、Object-prototype-toString" class="headerlink" title="5、Object.prototype.toString"></a>5、Object.prototype.toString</h3><ul>
<li>利用函数动态 this 的特性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">typeOf</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-string">&quot;1&quot;</span>)); <span class="hljs-comment">// String</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// Boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// Null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// Undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-title class_">Symbol</span>(<span class="hljs-number">1</span>))); <span class="hljs-comment">// Symbol</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(&#123;&#125;)); <span class="hljs-comment">// Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>([])); <span class="hljs-comment">// Array</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;)); <span class="hljs-comment">// Function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())); <span class="hljs-comment">// Date</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>())); <span class="hljs-comment">// RegExp</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6、鸭子类型检测"><a href="#6、鸭子类型检测" class="headerlink" title="6、鸭子类型检测"></a>6、鸭子类型检测</h3><ul>
<li>检查自身属性的类型或者执行结果的类型</li>
<li>通常作为候选方案</li>
<li>例子：<code>kindof</code> 与 <code>p-is-promise</code> 库</li>
</ul>
<p>p-is-promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObject</span> = value =&gt;<br>  value !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;function&quot;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPromise</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span> ||<br>    (<span class="hljs-title function_">isObject</span>(value) &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">then</span> === <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">catch</span> === <span class="hljs-string">&quot;function&quot;</span>)<br>  );<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>kindof：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">kindof</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">var</span> type;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span>;<br><br>  <span class="hljs-keyword">switch</span> ((type = <span class="hljs-keyword">typeof</span> obj)) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;object&quot;</span>:<br>      <span class="hljs-keyword">switch</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj)) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;[object RegExp]&quot;</span>:<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;regexp&quot;</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;[object Date]&quot;</span>:<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;date&quot;</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;[object Array]&quot;</span>:<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;array&quot;</span>;<br>      &#125;<br><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> type;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="7、Symbol-toStringTag"><a href="#7、Symbol-toStringTag" class="headerlink" title="7、Symbol.toStringTag"></a>7、Symbol.toStringTag</h3><ul>
<li>原理：<code>Object.prototype.toString</code> 会读取该值</li>
<li>适用场景：需自定义类型</li>
<li>注意事项：兼容性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyArray&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arr)); <span class="hljs-comment">// [object MyArray]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="8、等比较"><a href="#8、等比较" class="headerlink" title="8、等比较"></a>8、等比较</h3><ul>
<li>原理：与某个固定值进行比较</li>
<li>适用场景：<code>undefined</code>、 <code>window</code>、 <code>document</code>、 <code>null</code> 等</li>
</ul>
<p>underscore.js：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d329bc51315a419082fc0bfe75f62390~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><code>void 0</code> 始终返回 <code>undefined</code>，<code>void</code> 后面接任意值都是返回 <code>undefined</code>， 这是为了兼容 IE，因为在 IE 中 <code>undefined</code> 值可以被改写</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>方法</th>
<th>基础数据类型</th>
<th>引用类型</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>typeof</td>
<td>√</td>
<td>×</td>
<td>NaN、object、document.all</td>
</tr>
<tr>
<td>constructor</td>
<td>√ 部分</td>
<td>√</td>
<td>可以被改写</td>
</tr>
<tr>
<td>instanceof</td>
<td>×</td>
<td>√</td>
<td>多窗口，右边构造函数或者class</td>
</tr>
<tr>
<td>isPrototypeof</td>
<td>×</td>
<td>√</td>
<td>小心 null 和 undefined</td>
</tr>
<tr>
<td>toString</td>
<td>√</td>
<td>√</td>
<td>小心内置原型</td>
</tr>
<tr>
<td>鸭子类型</td>
<td>-</td>
<td>√</td>
<td>不得已兼容</td>
</tr>
<tr>
<td>Symbol.toString Tag</td>
<td>×</td>
<td>√</td>
<td>识别自定义对象</td>
</tr>
<tr>
<td>等比较</td>
<td>√</td>
<td>√</td>
<td>特殊对象</td>
</tr>
</tbody></table>
<h3 id="加餐：ES6-增强的-NaN"><a href="#加餐：ES6-增强的-NaN" class="headerlink" title="加餐：ES6 增强的 NaN"></a>加餐：ES6 增强的 NaN</h3><h4 id="NaN-和-Number-NaN-特点"><a href="#NaN-和-Number-NaN-特点" class="headerlink" title="NaN 和 Number.NaN 特点"></a>NaN 和 Number.NaN 特点</h4><ol>
<li><code>typeof</code> 判断类型是数字</li>
<li>自己不等于自己</li>
</ol>
<h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h4><ul>
<li>如果非数字，隐式转换传入结果如果是 <code>NaN</code>，就返回 <code>true</code>，反之返回 <code>false</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(&#123;&#125;)); <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN"></a>Number.isNaN</h4><ul>
<li>判断一个值是否是数字，并且值是否等于 <code>NaN</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(&#123;&#125;)); <span class="hljs-comment">// false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>综合垫片（如果不支持 <code>Number.isNaN</code> 的话）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!(<span class="hljs-string">&quot;isNaN&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">Number</span>)) &#123;<br>  <span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(val);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="indexOf-和-includes"><a href="#indexOf-和-includes" class="headerlink" title="indexOf 和 includes"></a>indexOf 和 includes</h4><ul>
<li><code>indexOf</code> 不可查找 <code>NaN</code>，<code>includes</code> 则可以</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-title class_">NaN</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// -1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h2 id="23-Javascript-toString-方法原理"><a href="#23-Javascript-toString-方法原理" class="headerlink" title="23 Javascript toString 方法原理"></a>23 Javascript toString 方法原理</h2><p>toString方法的作用是返回一个对象的字符串形式。我们还是分不同数据类型来讨论。</p>
<p>1.Srting，字符串类型直接原始值返回；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;123&#x27;</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></td></tr></table></figure>

<p>2.Boolean，布尔值类型返回对应的字符形式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">true</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;true&#x27;</span><br><span class="hljs-literal">false</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;false&#x27;</span><br></code></pre></td></tr></table></figure>

<p>3.Number，数值类型情况有点复杂；</p>
<p>a.对于NaN， Infinity，-Infinity，返回字符形式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;NaN&#x27;</span><br><span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;Infinity&#x27;</span><br><br>+<span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// Infinity</span><br>(+<span class="hljs-title class_">Infinity</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;Infinity&#x27;</span><br><br>(-<span class="hljs-title class_">Infinity</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;-Infinity&#x27;</span><br>-<span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// -Infinity</span><br></code></pre></td></tr></table></figure>

<p>b.对于整数，加引号直接返回。直接调用toString方法会报错，因为整数后面的点会被识别为小数点，加个括号就好；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">123.</span><span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// Uncaught SyntaxError: Invalid or unexpected token</span><br>(<span class="hljs-number">123</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>

<p>c.对于浮点数，可以直接调用toString方法，直接加引号返回；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.23</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;1.23&#x27;</span><br></code></pre></td></tr></table></figure>

<p>d.对于一些前面有正负号的数值，要加括号再调用toString方法，否则会先运行toString()方法，再添加正负号，隐式转换为数字；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-number">1.23</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 1.23</span><br>(+<span class="hljs-number">1.23</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;1.23&#x27;</span><br><br>-<span class="hljs-number">1.23</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// -1.23</span><br>(-<span class="hljs-number">1.23</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;-1.23&#x27;</span><br></code></pre></td></tr></table></figure>

<p>e.数值类型的toString方法还可以接收一个表示转换基数(radix)的可选参数。如果不指定此参数，转换规则将是基于十进制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// &#x27;NaN&#x27;</span><br><span class="hljs-title class_">Infinity</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// &#x27;Infinity&#x27;</span><br><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;17&#x27;</span><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// &#x27;10001&#x27;</span><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>); <span class="hljs-comment">// &#x27;21&#x27;</span><br>(<span class="hljs-number">17</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>); <span class="hljs-comment">// &#x27;11&#x27;</span><br></code></pre></td></tr></table></figure>

<p>4.null和undefined，没有toString方法，直接调用会报错，但可以使用call方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">null</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 错误</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;[object Null]&quot;</span><br><br><span class="hljs-literal">undefined</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 错误</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><br></code></pre></td></tr></table></figure>

<p>5.复合类型，返回 “[object type]”，其中 type 是对象的类型。数组、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。</p>
<p>a.内置的对象和自定义的对象，返回”[object Object]”；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;josavion&#x27;</span>,<br>&#125;;<br>obj.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;josavion&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">/* &quot;function Person() &#123;</span><br><span class="hljs-comment">                        this.name = &#x27;josavion&#x27;;</span><br><span class="hljs-comment">                      &#125;&quot; */</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Object() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>b.函数Function类型返回函数代码;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;<br>test.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">/* &quot;function test()&#123;</span><br><span class="hljs-comment">                        console.log(&#x27;test&#x27;);</span><br><span class="hljs-comment">                     &#125;&quot; */</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">haha</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br>haha.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;() =&gt; &#123;&#125;&quot;</span><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Function() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>c.数组Array类型返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;&quot;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;&quot; (数组的toString方法被改写了)</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Array() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>d.时间Date类型返回表示当前时区的时间的字符串表示；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;Wed Jun 24 2020 17:22:01 GMT+0800 (中国标准时间)&quot;</span><br><br><span class="hljs-title class_">Date</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Date() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>e.正则表达式RegExp类型返回正则表达式字面量的字符串表示；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">/xyz/i.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;/xyz/i&quot;</span><br><br><span class="hljs-title class_">RegExp</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function RegExp() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>f.错误Error类型；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>err.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;Error: test&quot;</span><br><br><span class="hljs-title class_">Error</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;function Error() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure>

<p>6.toString() 的应用。Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">数值：返回[object <span class="hljs-title class_">Number</span>]。<br>字符串：返回[object <span class="hljs-title class_">String</span>]。<br>布尔值：返回[object <span class="hljs-title class_">Boolean</span>]。<br><span class="hljs-literal">undefined</span>：返回[object <span class="hljs-title class_">Undefined</span>]。<br><span class="hljs-literal">null</span>：返回[object <span class="hljs-title class_">Null</span>]。<br>数组：返回[object <span class="hljs-title class_">Array</span>]。<br><span class="hljs-variable language_">arguments</span> 对象：返回[object <span class="hljs-title class_">Arguments</span>]。<br>函数：返回[object <span class="hljs-title class_">Function</span>]。<br><span class="hljs-title class_">Error</span> 对象：返回[object <span class="hljs-title class_">Error</span>]。<br><span class="hljs-title class_">Date</span> 对象：返回[object <span class="hljs-title class_">Date</span>]。<br><span class="hljs-title class_">RegExp</span> 对象：返回[object <span class="hljs-title class_">RegExp</span>]。<br>其他对象：返回[object <span class="hljs-title class_">Object</span>]。<br></code></pre></td></tr></table></figure>

<h2 id="24-promise的api"><a href="#24-promise的api" class="headerlink" title="24 promise的api"></a>24 promise的api</h2><h3 id="1-Promise-then"><a href="#1-Promise-then" class="headerlink" title="1. Promise#then"></a>1. <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020">Promise</a>#then</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">promise.<span class="hljs-keyword">then</span>(onFulfilled, onRejected);<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><strong>示例：Promise#then</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">var promise = new Promise(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(resolve, reject)</span></span> &#123;<br>    resolve(<span class="hljs-string">&quot;传递给then的值&quot;</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span></span> &#123;<br>    console.<span class="hljs-built_in">log</span>(value);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span></span> &#123;<br>    console.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">error</span>);<br>&#125;);<span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<p>这段代码创建一个promise对象，定义了处理onFulfilled和onRejected的函数（handler），然后返回这个promise对象。这个promise对象会在变为resolve或者reject的时候分别调用相应注册的回调函数。 </p>
<p>（1）当handler返回一个正常值的时候，这个值会传递给promise对象的onFulfilled方法。 </p>
<p>（2）定义的handler中产生异常的时候，这个值则会传递给promise对象的onRejected方法。</p>
<h3 id="2-Promise-catch"><a href="#2-Promise-catch" class="headerlink" title="2. Promise#catch"></a>2. Promise#catch</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">promise.<span class="hljs-keyword">catch</span>(onRejected); <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>等价于<code>promise.then(undefined, onRejected)</code> 的语法糖。<br><strong>示例：Promise#catch</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-title function_ invoke__">resolve</span>(<span class="hljs-string">&quot;要传递给then的值&quot;</span>);<br>&#125;);<br><br><br><br>promise.<span class="hljs-title function_ invoke__">then</span>(function(value) &#123;<br>    console.<span class="hljs-title function_ invoke__">log</span>(value);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>    console.<span class="hljs-title function_ invoke__">log</span>(error);<br>&#125;);<span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure>

<h3 id="3-Promise-resolve"><a href="#3-Promise-resolve" class="headerlink" title="3. Promise.resolve"></a>3. Promise.resolve</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-built_in">object</span>);<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<p><strong>示例：Promise.resolve</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">var taskName = <span class="hljs-string">&quot;task1&quot;</span>;<br><br>asyncTask(taskName).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span></span> &#123;<br>    console.<span class="hljs-built_in">log</span>(value);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span></span> &#123;<br>    console.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">error</span>);<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncTask</span><span class="hljs-params">(name)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> Promise.resolve(name).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span></span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Done! &quot;</span> + value;<br>    &#125;)<br>&#125;<span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure>

<p>根据接收到的参数不同，返回不同的promise对象。 </p>
<p>（1）接收到promise对象参数的时候：返回的还是接收到的promise对象 </p>
<p>（2）接收到thenable类型的对象的时候：返回一个新的promise对象，这个对象具有一个 then 方法 </p>
<p>（3）接收的参数为其他类型的时候（包括JavaScript对或null等）：返回一个将该对象作为值的新promise对象</p>
<h3 id="4-Promise-reject"><a href="#4-Promise-reject" class="headerlink" title="4. Promise.reject"></a>4. Promise.reject</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Promise.reject(<span class="hljs-built_in">object</span>)<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><strong>示例：Promise.reject</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">var r = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;error&quot;</span>));<br>console.log(r === <span class="hljs-built_in">Promise</span>.reject(r));       <span class="hljs-regexp">//</span> <span class="hljs-literal">false</span><br>var r = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;test&quot;</span>);<br>console.log(r === <span class="hljs-built_in">Promise</span>.resolve(r));      <span class="hljs-regexp">//</span> true12345<br></code></pre></td></tr></table></figure>

<p>和 Promise.resolve不同的是，即使Promise.reject接收到的参数是一个promise对象，该函数也还是会返回一个全新的promise对象。</p>
<h3 id="5-Promise-all"><a href="#5-Promise-all" class="headerlink" title="5. Promise.all"></a>5. Promise.all</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">Promise.all(promiseArray)1<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cobol">var p1 = Promise.resolve(1),<br>    p2 = Promise.resolve(2),<br>    p3 = Promise.resolve(3);<br>Promise.all([p1, p2, p3]).then(function(results) &#123;<br>    console.log(results);       // [1, 2, 3]<br>&#125;);123456<br></code></pre></td></tr></table></figure>

<p>生成并返回一个新的promise对象。 </p>
<p>参数传递promise数组中所有的promise对象都变为resolve的时候，该方法才会返回， 新创建的promise则会使用这些promise的值。 </p>
<p>如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象。</p>
<h3 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6. Promise.race"></a>6. Promise.race</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">Promise.all(promiseArray)1<br></code></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cobol">var p1 = Promise.resolve(1),<br>    p2 = Promise.resolve(2),<br>    p3 = Promise.resolve(3);<br><br><br><br>Promise.all([p1, p2, p3]).then(function(results) &#123;<br>    console.log(results);       // 1<br>&#125;);123456<br></code></pre></td></tr></table></figure>

<p>生成并返回一个新的promise对象。<br>参数 promise 数组中的任何一个promise对象如果变为resolve或者reject的话， 该函数就会返回，并使用这个promise对象的值进行resolve或者reject。</p>
<h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>为了增加代入感，本文从最为基础的一个应用实例开始探索：通过异步请求获取用户id，然后做一些处理。在平时大家都是习惯用回调或者事件来处理，下面我们看下 Promise 的处理方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>		<span class="hljs-comment">// 异步请求</span><br>		Y.<span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;/userid&#x27;</span>, &#123;<br>			<span class="hljs-attr">on</span>: &#123;<br>				<span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id, res</span>) &#123;<br>					<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(res).<span class="hljs-property">id</span>);<br>				&#125;<br>			&#125;<br>		&#125;);<br>	&#125;);<br>&#125;<br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/kebigicu/1/embed?js,console">JS Bin</a></p>
<p><code>getUserId</code> 方法返回一个 promise，可以通过它的 <code>then</code> 方法注册在 promise 异步操作成功时执行的回调。自然、表意的 API，用起来十分顺手。</p>
<p>满足这样一种使用场景的 Promise 是如何构建的呢？其实并不复杂，下面给出最基础的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>,<br>    	deferreds = [];<br>        <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>        deferreds.<span class="hljs-title function_">push</span>(onFulfilled);<br>    &#125;;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    	deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>    		<span class="hljs-title function_">deferred</span>(value);<br>    	&#125;);<br>    &#125;<br><br>    <span class="hljs-title function_">fn</span>(resolve);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码很短，逻辑也非常清晰：</p>
<ul>
<li>调用<code>then</code>方法，将想要在 Promise 异步操作成功时执行的回调放入 <code>deferreds</code> 队列；</li>
<li>创建 Promise 实例时传入函数被赋予一个函数类型的参数，即 <code>resolve</code>，用以在合适的时机触发异步操作成功。真正执行的操作是将 <code>deferreds</code> 队列中的回调一一执行；</li>
<li><code>resolve</code> 接收一个参数，即异步操作返回的结果，方便回调使用。</li>
</ul>
<p>有时需要注册多个回调，如果能够支持 jQuery 那样的链式操作就好了！事实上，这很容易：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>    deferreds.<span class="hljs-title function_">push</span>(onFulfilled);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这个小改进带来的好处非常明显，当真是一个大收益的小创新呢：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例2</span><br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth else with id</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/fedukaso/2/edit?js,console">JS Bin</a></p>
<h3 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h3><p>如果 promise 是同步代码，<code>resolve</code> 会先于 <code>then</code> 执行，这时 <code>deferreds</code> 队列还空无一物，更严重的是，后续注册的回调再也不会被执行了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例3</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>		<span class="hljs-title function_">resolve</span>(<span class="hljs-number">9876</span>);<br>	&#125;);<br>&#125;<br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/fenopelo/3/edit?js,console">JS Bin</a></p>
<p>此外，Promises&#x2F;A+ 规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。为解决这两个问题，可以通过 <code>setTimeout</code> 将 <code>resolve</code> 中执行回调的逻辑放置到 JS 任务队列末尾：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>    	    <span class="hljs-title function_">deferred</span>(value);<br>        &#125;);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h3><p>Hmm，好像存在一点问题：如果 Promise 异步操作已经成功，之后调用 <code>then</code> 注册的回调再也不会执行了，而这是不符合我们预期的。</p>
<p>解决这个问题，需要引入规范中所说的 States，即每个 Promise 存在三个互斥状态：pending、fulfilled、rejected，它们之间的关系是：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/a400b1f5.png" srcset="/blog/img/loading.gif" lazyload alt="states flow"></p>
<p>states flow</p>
<p>经过改进后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>    	value = <span class="hljs-literal">null</span>,<br>    	deferreds = [];<br>        <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>    	<span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        	deferreds.<span class="hljs-title function_">push</span>(onFulfilled);<br>        	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>        &#125;<br>        <span class="hljs-title function_">onFulfilled</span>(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">newValue</span>) &#123;<br>        value = newValue;<br>    	state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>                <span class="hljs-title function_">deferred</span>(value);<br>            &#125;);<br>        &#125;, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">fn</span>(resolve);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/lamewijo/2/edit?js,console">JS Bin</a></p>
<p><code>resolve</code> 执行时，会将状态设置为 fulfilled，在此之后调用 <code>then</code> 添加的新回调，都会立即执行。</p>
<p>似乎少了点什么，哦，是的，没有任何地方将 state 设为 rejected，这个问题稍后会聊，方便聚焦在核心代码上。</p>
<h3 id="串行-Promise"><a href="#串行-Promise" class="headerlink" title="串行 Promise"></a>串行 Promise</h3><p>在这一小节，将要探索的是 Promise 的 Killer Feature：<strong>串行 Promise</strong>，这是最为有趣也最为神秘的一个功能。</p>
<p>串行 Promise 是指在当前 promise 达到 fulfilled 状态后，即开始进行下一个 promise（后邻 promise）。例如获取用户 id 后，再根据用户 id 获取用户手机号等其他信息，这样的场景比比皆是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例4</span><br><br><span class="hljs-title function_">getUserId</span>()<br>    .<span class="hljs-title function_">then</span>(getUserMobileById)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">mobile</span>) &#123;<br>	    <span class="hljs-comment">// do sth with mobile</span><br>    &#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserMobileById</span>(<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>	    Y.<span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;/usermobile/&#x27;</span> + id, &#123;<br>	        <span class="hljs-attr">on</span>: &#123;<br>	            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">i, o</span>) &#123;<br>	                <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(o).<span class="hljs-property">mobile</span>);<br>	            &#125;<br>	        &#125;<br>   	    &#125;);<br>	&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/pibicefe/2/edit?js,console">JS Bin</a></p>
<p>这个 feature 实现的难点在于：如何衔接当前 promise 和后邻 promise。</p>
<p>首先对 <code>then</code> 方法进行改造：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-title function_">handle</span>(&#123;<br>            <span class="hljs-attr">onFulfilled</span>: onFulfilled || <span class="hljs-literal">null</span>,<br>            <span class="hljs-attr">resolve</span>: resolve<br>        &#125;);<br>    &#125;);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">deferred</span>) &#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        deferreds.<span class="hljs-title function_">push</span>(deferred);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> ret = deferred.<span class="hljs-title function_">onFulfilled</span>(value);<br>    deferred.<span class="hljs-title function_">resolve</span>(ret);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>then</code> 方法改变很多，这是一段暗藏玄机的代码：</p>
<ul>
<li><code>then</code> 方法中，创建了一个新的 Promise 实例，并作为返回值，这类 promise，权且称作 bridge promise。这是串行 Promise 的基础。另外，因为返回类型一致，之前的链式执行仍然被支持；</li>
<li><code>handle</code> 方法是当前 promise 的内部方法。这一点很重要，看不懂的童鞋可以去补充下闭包的知识。<code>then</code> 方法传入的形参 <code>onFullfilled</code>，以及创建新 Promise 实例时传入的 <code>resolve</code> 均被压入当前 promise 的 <code>deferreds</code> 队列中。所谓“巧妇难为无米之炊”，而这，正是衔接当前 promise 与后邻 promise 的“米”之所在。</li>
</ul>
<p>新增的 <code>handle</code> 方法，相比改造之前的 <code>then</code> 方法，仅增加了一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">deferred.<span class="hljs-title function_">resolve</span>(ret);<br></code></pre></td></tr></table></figure>

<p>这意味着当前 promise 异步操作成功后执行 <code>handle</code> 方法时，先执行 <code>onFulfilled</code> 方法，然后将其返回值作为实参执行 <code>resolve</code> 方法，而这标志着后邻 promise 异步操作成功，<strong>接力</strong>工作就这样完成啦！</p>
<p>以例 2 代码为例，串行 Promise 执行流如下：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/c7f62426.png" srcset="/blog/img/loading.gif" lazyload alt="promise series flow"></p>
<p>promise series flow</p>
<p>这就是所谓的串行 Promise？当然不是，这些改造只是为了为最后的冲刺做铺垫，它们在重构底层实现的同时，兼容了本文之前讨论的所有功能。接下来，画龙点睛之笔–最后一个方法 <code>resolve</code> 是这样被改造的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">var</span> then = newValue.<span class="hljs-property">then</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            then.<span class="hljs-title function_">call</span>(newValue, resolve);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>    value = newValue;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>            <span class="hljs-title function_">handle</span>(deferred);<br>        &#125;);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>啊哈，<code>resolve</code> 方法现在支持传入的参数是一个 Promise 实例了！以例 4 为例，执行步骤如下：</p>
<ol>
<li><code>getUserId</code> 生成的 promise （简称 <code>getUserId</code> promise）异步操作成功，执行其内部方法 <code>resolve</code>，传入的参数正是异步操作的结果 <code>userid</code>；</li>
<li>调用 <code>handle</code> 方法处理 <code>deferreds</code> 队列中的回调：<code>getUserMobileById</code> 方法，生成新的 promise（简称 <code>getUserMobileById</code> promise）；</li>
<li>执行之前由 <code>getUserId</code> promise 的 <code>then</code> 方法生成的 bridge promise 的 <code>resolve</code> 方法，传入参数为 <code>getUserMobileById</code> promise。这种情况下，会将该 <code>resolve</code> 方法传入 <code>getUserMobileById</code> promise 的 <code>then</code> 方法中，并直接返回；</li>
<li>在 <code>getUserMobileById</code> promise 异步操作成功时，执行其 <code>deferreds</code> 中的回调：<code>getUserId</code> bridge promise 的 <code>resolve</code> 方法；</li>
<li>最后，执行 <code>getUserId</code> bridge promise 的后邻 promise 的 <code>deferreds</code> 中的回调</li>
</ol>
<p>上述步骤实在有些复杂，主要原因是 bridge promise 的引入。不过正是得益于此，注册一个返回值也是 promise 的回调，从而实现异步操作串行的机制才得以实现。</p>
<p>一图胜千言，下图描述了例 4 的 Promise 执行流：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/3459d82b.png" srcset="/blog/img/loading.gif" lazyload alt="promise series flow"></p>
<p>promise series flow</p>
<h3 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h3><p>本节处理之前遗留的 rejected 状态问题。在异步操作失败时，标记其状态为 rejected，并执行注册的失败回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例5</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>		<span class="hljs-comment">// 异步请求</span><br>		Y.<span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;/userid/1&#x27;</span>, &#123;<br>			<span class="hljs-attr">on</span>: &#123;<br>				<span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id, res</span>) &#123;<br>                    <span class="hljs-keyword">var</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(res);<br>                    <span class="hljs-keyword">if</span> (o.<span class="hljs-property">status</span> === <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-title function_">resolve</span>(o.<span class="hljs-property">id</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 请求失败，返回错误信息</span><br>                        <span class="hljs-title function_">reject</span>(o.<span class="hljs-property">errorMsg</span>);<br>                    &#125;<br>				&#125;<br>			&#125;<br>		&#125;);<br>	&#125;);<br>&#125;<br><br><span class="hljs-title function_">getUserId</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>	<span class="hljs-comment">// do sth with id</span><br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/padolebi/2/edit?js,console">JS Bin</a></p>
<p>有了之前处理 fulfilled 状态的经验，支持错误处理变得很容易。毫无疑问的是，这将加倍 code base，在注册回调、处理状态变更上都要加入新的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>    	value = <span class="hljs-literal">null</span>,<br>        deferreds = [];<br>        <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-title function_">handle</span>(&#123;<br>                <span class="hljs-attr">onFulfilled</span>: onFulfilled || <span class="hljs-literal">null</span>,<br>                <span class="hljs-attr">onRejected</span>: onRejected || <span class="hljs-literal">null</span>,<br>                <span class="hljs-attr">resolve</span>: resolve,<br>                <span class="hljs-attr">reject</span>: reject<br>            &#125;);<br>        &#125;);<br>    &#125;;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">deferred</span>) &#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>            deferreds.<span class="hljs-title function_">push</span>(deferred);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">var</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">onFulfilled</span> : deferred.<span class="hljs-property">onRejected</span>,<br>            ret;<br>        <span class="hljs-keyword">if</span> (cb === <span class="hljs-literal">null</span>) &#123;<br>            cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">resolve</span> : deferred.<span class="hljs-property">reject</span>;<br>            <span class="hljs-title function_">cb</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ret = <span class="hljs-title function_">cb</span>(value);<br>        deferred.<span class="hljs-title function_">resolve</span>(ret);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">newValue</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">var</span> then = newValue.<span class="hljs-property">then</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>                then.<span class="hljs-title function_">call</span>(newValue, resolve, reject);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>        value = newValue;<br>        <span class="hljs-title function_">finale</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>        state = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>        value = reason;<br>        <span class="hljs-title function_">finale</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">finale</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            deferreds.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">deferred</span>) &#123;<br>                <span class="hljs-title function_">handle</span>(deferred);<br>            &#125;);<br>        &#125;, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">fn</span>(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>增加了新的 <code>reject</code> 方法，供异步操作失败时调用，同时抽出了 <code>resolve</code> 和 <code>reject</code> 共用的部分，形成 <code>finale</code> 方法。</p>
<p><strong>错误冒泡</strong>是上述代码已经支持，且非常实用的一个特性。在 <code>handle</code> 中发现没有指定异步操作失败的回调时，会直接将 bridge promise 设为 rejected 状态，如此达成执行后续失败回调的效果。这有利于简化串行 Promise 的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例6</span><br><br><span class="hljs-title function_">getUserId</span>()<br>    .<span class="hljs-title function_">then</span>(getUserMobileById)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">mobile</span>) &#123;<br>	    <span class="hljs-comment">// do sth else with mobile</span><br>    &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-comment">// getUserId或者getUerMobileById时出现的错误</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://jsbin.com/joqamiko/3/edit?js,console">JS Bin</a></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用 <code>try-catch</code> 捕获错误，并将 bridge promise 设为 rejected 状态。<code>handle</code> 方法改造如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">deferred</span>) &#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        deferreds.<span class="hljs-title function_">push</span>(deferred);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">onFulfilled</span> : deferred.<span class="hljs-property">onRejected</span>,<br>        ret;<br>    <span class="hljs-keyword">if</span> (cb === <span class="hljs-literal">null</span>) &#123;<br>        cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? deferred.<span class="hljs-property">resolve</span> : deferred.<span class="hljs-property">reject</span>;<br>        <span class="hljs-title function_">cb</span>(value);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ret = <span class="hljs-title function_">cb</span>(value);<br>        deferred.<span class="hljs-title function_">resolve</span>(ret);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        deferred.<span class="hljs-title function_">reject</span>(e);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果在异步操作中，多次执行 <code>resolve</code> 或者 <code>reject</code> 会重复处理后续回调，可以通过内置一个标志位解决。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Promise 作为异步操作的一种 Monad，魔幻一般的 API 让人难以驾驭。本文从简单的基础实现起步，逐步添加内置状态、串行、失败处理&#x2F;失败冒泡、异常处理等关键特性，最终达到类似由 Forbes Lindesay 所完成的一个<a target="_blank" rel="noopener" href="https://github.com/then/promise/blob/master/core.js">简单 Promise 实现</a>的效果。在让我本人更加深刻理解 Promise 魔力之源的同时，希望为各位更加熟练的使用这一实用工具带来一些帮助。</p>
<h2 id="25-async和defer的区别"><a href="#25-async和defer的区别" class="headerlink" title="25 async和defer的区别"></a>25 async和defer的区别</h2><p>1.先来试个一句话解释仨，当浏览器碰到 <code>script</code> 脚本的时候：</p>
<ol>
<li><p><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>
<p>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
</li>
<li><p><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>
<p>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。</p>
</li>
<li><p><code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></p>
<p>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</p>
</li>
</ol>
<p>然后从实用角度来说呢，首先把所有脚本都丢到 <code>&lt;/body&gt;</code> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p>接着，我们来看一张图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/894d84e8a7e0497091a26e43e1a84237~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p>
<p>此图告诉我们以下几个要点：</p>
<ol>
<li><em>defer</em> 和 <em>async</em> 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>
<li>它俩的差别在于脚本下载完之后何时执行，显然 <em>defer</em> 是最接近我们对于应用脚本加载和执行的要求的</li>
<li>关于 <em>defer</em>，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>
<li><em>async</em> 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>
<li>仔细想想，<em>async</em> 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>
</ol>
<h2 id="26-localstorage占满、跨域"><a href="#26-localstorage占满、跨域" class="headerlink" title="26 localstorage占满、跨域"></a>26 localstorage占满、跨域</h2><p> 占满怎么解决</p>
<p>1、划分域名。各域名下的存储空间由各业务组统一规划使用</p>
<p>2、跨页面传数据：考虑单页应用、优先采用 url 传数据</p>
<p>3、最后的兜底方案：清掉别人的存储</p>
<p>4、indexeddb</p>
<h3 id="怎么跨域"><a href="#怎么跨域" class="headerlink" title="怎么跨域"></a>怎么跨域</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>一般用于业务域名众多，但是需要共享本地缓存数据。举个例子🌰，比如我用Chrome浏览天猫网站，在搜索栏搜索‘云安全’，过几天我用Chrome进了淘宝网，点击搜索栏想要获取到‘云安全’这个搜索记录，这个时候就需要用到localStroage的跨域存储（当然，也可以将搜索记录存储在服务端，这也是另一种解决办法）</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>主要是通过postMessage来实现跨源通信</li>
<li>可以实现一个公共的iframe部署在某个域名中，作为共享域</li>
<li>将需要实现localStorage跨域通信的页面嵌入这个iframe</li>
<li>接入对应的SDK操作共享域，从而实现localStorage的跨域存储</li>
</ul>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>（注：以下代码均使用TypeScript编写）</p>
<h4 id="1-共享域"><a href="#1-共享域" class="headerlink" title="1.共享域"></a>1.共享域</h4><h4 id="CrossStorageHub"><a href="#CrossStorageHub" class="headerlink" title="CrossStorageHub"></a>CrossStorageHub</h4><p>需要用到的数据结构</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PermissionInfo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 允许的源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@example</span>  /\.example\.(?:com|net|cn)(?:\:\d+)?$/</span><br><span class="hljs-comment">     */</span><br>    origin: RegExp;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 允许的请求方法</span><br><span class="hljs-comment">     */</span><br>    allow: <span class="hljs-keyword">string</span>[];<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>PermissionInfo主要用来配置域名的相关权限</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">ParamsInfo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 键</span><br><span class="hljs-comment">     */</span><br>    key: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">value</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量del</span><br><span class="hljs-comment">     */</span><br>    keys: <span class="hljs-built_in">string</span>[];<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestInfo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求唯一标识</span><br><span class="hljs-comment">     */</span><br>    id: number;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求方法</span><br><span class="hljs-comment">     */</span><br>    method: <span class="hljs-string">&#x27;get&#x27;</span> | <span class="hljs-string">&#x27;set&#x27;</span> | <span class="hljs-string">&#x27;del&#x27;</span> | <span class="hljs-string">&#x27;clear&#x27;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">params</span>: ParamsInfo;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">ResponseInfo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求唯一标识</span><br><span class="hljs-comment">     */</span><br>    id: number;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 错误信息</span><br><span class="hljs-comment">     */</span><br>    error: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求结果</span><br><span class="hljs-comment">     */</span><br>    result: <span class="hljs-built_in">string</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>初始化，检测localStorage是否可用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">init</span>(<span class="hljs-attr">permissions</span>: <span class="hljs-title class_">PermissionInfo</span>[]): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">let</span> available = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 判断localStorage是否可用</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>) available = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">if</span> (!available) &#123;<br>                <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;unavailable&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_permissions</span> = permissions || [];<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_installListener</span>();<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>安装窗口消息事件所需的侦听器，兼容IE8及以上版本</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_installListener</span>(): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">const</span> listener = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_listener</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">addEventListener</span>) &#123;<br>                <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, listener, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable language_">window</span>[<span class="hljs-string">&#x27;attachEvent&#x27;</span>](<span class="hljs-string">&#x27;onmessage&#x27;</span>, listener);<br>            &#125;<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>核心函数，处理来自父窗口的消息，忽略任何来源与权限不匹配的消息。根据method调用对应的函数（’get’ | ‘set’ | ‘del’ | ‘clear’)，响应请求的唯一标识，错误信息，以及result。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_listener</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">MessageEvent</span>): <span class="hljs-built_in">void</span> &#123;<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">origin</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">request</span>: <span class="hljs-title class_">RequestInfo</span>, <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>, <br>            <span class="hljs-attr">error</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span>[] | <span class="hljs-built_in">string</span>, <span class="hljs-attr">response</span>: <span class="hljs-built_in">string</span>;<br><br>            origin = message.<span class="hljs-property">origin</span>;<br>            <br>            <span class="hljs-comment">// 检查message.data是否为有效json</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                request = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(message.<span class="hljs-property">data</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 校验request.method数据类型</span><br>            <span class="hljs-keyword">if</span> (!request || <span class="hljs-keyword">typeof</span> request.<span class="hljs-property">method</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            method = request.<span class="hljs-property">method</span>;<br><br>            <span class="hljs-keyword">if</span> (!method) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">CrossStorageHub</span>.<span class="hljs-title function_">_permitted</span>(origin, method)) &#123;<br>                error = <span class="hljs-string">&#x27;Invalid permissions for &#x27;</span> + method;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    result = <span class="hljs-title class_">CrossStorageHub</span>[<span class="hljs-string">&#x27;_&#x27;</span> + method](request.<span class="hljs-property">params</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                    error = err.<span class="hljs-property">message</span>;<br>                &#125;<br>            &#125;<br><br>            response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>                <span class="hljs-attr">id</span>: request.<span class="hljs-property">id</span>,<br>                <span class="hljs-attr">error</span>: error,<br>                <span class="hljs-attr">result</span>: result<br>            &#125;)<br><br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(response, origin);<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>为了防止恶意网站的接入，所以进行权限检测，不满足条件的消息将被过滤。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_permitted</span>(<span class="hljs-attr">origin</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">available</span>: <span class="hljs-built_in">string</span>[], <span class="hljs-attr">match</span>: <span class="hljs-built_in">boolean</span>;<br><br>            available = [<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-string">&#x27;clear&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_inArray</span>(method, available)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_permissions</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!(entry.<span class="hljs-property">origin</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) || !(entry.<span class="hljs-property">allow</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                match = entry.<span class="hljs-property">origin</span>.<span class="hljs-title function_">test</span>(origin);<br>                <span class="hljs-keyword">if</span> (match &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_inArray</span>(method, entry.<span class="hljs-property">allow</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;;<br>复制代码<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 取数据</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> params </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_get</span>(<span class="hljs-attr">params</span>: <span class="hljs-title class_">ParamsInfo</span>): <span class="hljs-built_in">string</span> &#123;<br>            <span class="hljs-keyword">const</span> &#123; key &#125; = params;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);<br>        &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>剩下的 set | del | clear 函数都是针对localStorage相关API的调用，我就不一一列举了</p>
<h4 id="cross-storage-iframe-html"><a href="#cross-storage-iframe-html" class="headerlink" title="cross-storage-iframe.html"></a>cross-storage-iframe.html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./bin/crossStorage/crossStorage.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        crossStorage.<span class="hljs-title function_">init</span>([</span><br><span class="language-javascript">            &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">origin</span>: <span class="hljs-regexp">/\\*/</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">allow</span>: [<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        ]);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>将代码编译成js文件进行引入。这里为了方便测试将origin配置为&#x2F;\*&#x2F;，允许任何域名访问get，set，del方法。</p>
<h4 id="2-父窗口CrossStorageSDK实现"><a href="#2-父窗口CrossStorageSDK实现" class="headerlink" title="2.父窗口CrossStorageSDK实现"></a>2.父窗口CrossStorageSDK实现</h4><p>主要是用来载入共享域并与之进行通信</p>
<p>sdk的初始化，加载cross-storage-iframe，以及监听message事件</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrossStorageSDK</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_storageSrc</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;https://www.example.com/cross-storage-iframe.html&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_storageOrign</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;https://www.example.com&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">_ready</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">_callbacks</span>: &#123; [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-function">(<span class="hljs-params">response?: ResponseInfo</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; | <span class="hljs-built_in">void</span> &#125; = &#123;&#125;;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">init</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_installListener</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_installCrossStorageIframe</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;ready&#x27;</span>] = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>();<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;unavailable&#x27;</span>] = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>();<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 安装cross-storage-iframe</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_installCrossStorageIframe</span>(): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>            iframe.<span class="hljs-property">frameBorder</span> = iframe.<span class="hljs-property">width</span> = iframe.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            iframe.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;cross-storage&#x27;</span>;<br>            iframe.<span class="hljs-property">src</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_storageSrc</span>;<br>            <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);<br>        &#125;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 安装窗口消息事件所需的侦听器</span><br><span class="hljs-comment">         * 兼容IE8及以上版本</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_installListener</span>(): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-keyword">const</span> listener = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_listener</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">addEventListener</span>) &#123;<br>                <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, listener, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable language_">window</span>[<span class="hljs-string">&#x27;attachEvent&#x27;</span>](<span class="hljs-string">&#x27;onmessage&#x27;</span>, listener);<br>            &#125;<br>        &#125;;<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>处理来自cross-storage-iframe的事件消息，通过请求唯一标识进行回调。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_listener</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">MessageEvent</span>): <span class="hljs-built_in">void</span> &#123;<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">ResponseInfo</span>;<br><br>            <span class="hljs-comment">// 忽略其他源发送的消息</span><br>            <span class="hljs-keyword">if</span> (message.<span class="hljs-property">origin</span> !== <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_storageOrign</span>) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-keyword">if</span> (message.<span class="hljs-property">data</span> === <span class="hljs-string">&#x27;unavailable&#x27;</span>) &#123;<br>                <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;unavailable&#x27;</span>]();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (message.<span class="hljs-property">data</span> === <span class="hljs-string">&#x27;ready&#x27;</span> &amp;&amp; !<span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_ready</span>) &#123;<br>                <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_ready</span> = <span class="hljs-literal">true</span>;<br>                <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[<span class="hljs-string">&#x27;ready&#x27;</span>]();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 检查message.data是否为有效json</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(message.<span class="hljs-property">data</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[response.<span class="hljs-property">id</span>] &amp;&amp; <span class="hljs-title class_">CrossStorageSDK</span>.<span class="hljs-property">_callbacks</span>[response.<span class="hljs-property">id</span>](response)<br>        &#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>对cross-storage-iframe的localStorage进行get操作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>                <span class="hljs-keyword">const</span> <span class="hljs-attr">request</span>: <span class="hljs-title class_">RequestInfo</span> = &#123;<br>                    <span class="hljs-attr">id</span>: id,<br>                    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>                    <span class="hljs-attr">params</span>: &#123;<br>                        <span class="hljs-attr">key</span>: key<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[id] = <span class="hljs-function">(<span class="hljs-params">response: ResponseInfo</span>) =&gt;</span> &#123;<br>                    response.<span class="hljs-property">error</span> ? <span class="hljs-title function_">reject</span>(response.<span class="hljs-property">error</span>) : <span class="hljs-title function_">resolve</span>(response.<span class="hljs-property">result</span>);<br>                &#125;<br><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_sendRequest</span>(request);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">_sendRequest</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">RequestInfo</span>): <span class="hljs-built_in">void</span> &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">frames</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(request), <span class="hljs-variable language_">this</span>.<span class="hljs-property">_storageOrign</span>);<br>        &#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h4><p>a.html和b.html分别接入CrossStorageSDK，调用sdk所暴露的相关方法，就能实现localStorage的跨域（源）通信。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>Safari浏览器由于隐私限制，默认是禁用localStorage跨域存储的，需要用户主动开启设置。</p>
<h2 id="27-indexdb使用"><a href="#27-indexdb使用" class="headerlink" title="27 indexdb使用"></a>27 indexdb使用</h2><p>在人们的印象中，可能觉得只有做后端的小伙伴才会接触到数据库。其实在前端的领域里面也有数据库，只是可能用的比较少，因为前端存储方案有很多，比如cookie、sessionstorage等等。</p>
<p>在浏览器上有两种数据库：webSQL和IndexedDB。但是如果在浏览器上需要用到数据库一般会使用Indexed DB数据库，webSQL基本上已经废弃了，具体原因小伙伴可以下来自己查查，今天主要就讲解Indexed DB数据库的使用。</p>
<h3 id="1-IndexedDB简介"><a href="#1-IndexedDB简介" class="headerlink" title="1.IndexedDB简介"></a>1.IndexedDB简介</h3><p>MDN官网是这样解释Indexed DB的：</p>
<blockquote>
<p>IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件&#x2F;二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。</p>
</blockquote>
<p>官网上的这句话也很简单明了，意思就是IndexedDB主要用来客户端存储大量数据而生的，我们都知道cookie、localstorage等存储方式都有存储大小限制。如果数据量很大，且都需要客户端存储时，那么就可以使用IndexedDB数据库。</p>
<p>客户端各存储方式对比：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b50dd9b052e4dde934c217fa1c1ca01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="2-IndexedDB使用场景"><a href="#2-IndexedDB使用场景" class="headerlink" title="2.IndexedDB使用场景"></a>2.IndexedDB使用场景</h3><p>所有的场景都基于客户端需要存储大量数据的前提下：</p>
<ol>
<li>数据可视化等界面，大量数据，每次请求会消耗很大性能。</li>
<li>即时聊天工具，大量消息需要存在本地。</li>
<li>其它存储方式容量不满足时，不得已使用IndexedDB</li>
</ol>
<h3 id="3-IndexedDB特点"><a href="#3-IndexedDB特点" class="headerlink" title="3.IndexedDB特点"></a>3.IndexedDB特点</h3><p><strong>（1） 非关系型数据库(NoSql)</strong></p>
<p>我们都知道MySQL等数据库都是关系型数据库，它们的主要特点就是数据都以一张二维表的形式存储，而Indexed DB是非关系型数据库，主要以键值对的形式存储数据。</p>
<p><strong>（2）持久化存储</strong></p>
<p>cookie、localStorage、sessionStorage等方式存储的数据当我们清楚浏览器缓存后，这些数据都会被清除掉的，而使用IndexedDB存储的数据则不会，除非手动删除该数据库。</p>
<p><strong>（3）异步操作</strong></p>
<p>IndexedDB操作时不会锁死浏览器，用户依然可以进行其他的操作，这与localstorage形成鲜明的对比，后者是同步的。</p>
<p><strong>（4）支持事务</strong></p>
<p>IndexedDB支持事务(transaction)，这意味着一系列的操作步骤之中，只要有一步失败了，整个事务都会取消，数据库回滚的事务发生之前的状态，这和MySQL等数据库的事务类似。</p>
<p><strong>（6）同源策略</strong></p>
<p>IndexedDB同样存在同源限制，每个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p><strong>（7）存储容量大</strong></p>
<p>这也是IndexedDB最显著的特点之一了，这也是不用localStorage等存储方式的最好理由。</p>
<h3 id="4-IndexedDB重要概念讲解"><a href="#4-IndexedDB重要概念讲解" class="headerlink" title="4.IndexedDB重要概念讲解"></a>4.IndexedDB重要概念讲解</h3><h4 id="4-1仓库objectStore"><a href="#4-1仓库objectStore" class="headerlink" title="4.1仓库objectStore"></a>4.1仓库objectStore</h4><p>IndexedDB没有表的概念，它只有仓库store的概念，大家可以把仓库理解为表即可，即一个store是一张表。</p>
<h4 id="4-2索引index"><a href="#4-2索引index" class="headerlink" title="4.2索引index"></a>4.2索引index</h4><p>在关系型数据库当中也有索引的概念，我们可以给对应的表字段添加索引，以便加快查找速率。在IndexedDB中同样有索引，我们可以在创建store的时候同时创建索引，在后续对store进行查询的时候即可通过索引来筛选，给某个字段添加索引后，在后续插入数据的过成功，索引字段便不能为空。</p>
<h4 id="4-3游标cursor"><a href="#4-3游标cursor" class="headerlink" title="4.3游标cursor"></a>4.3游标cursor</h4><p>游标是IndexedDB数据库新的概念，大家可以把游标想象为一个指针，比如我们要查询满足某一条件的所有数据时，就需要用到游标，我们让游标一行一行的往下走，游标走到的地方便会返回这一行数据，此时我们便可对此行数据进行判断，是否满足条件。</p>
<p>【注意】：IndexedDB查询不像MySQL等数据库方便，它只能通过主键、索引、游标方式查询数据。</p>
<h4 id="4-4事务"><a href="#4-4事务" class="headerlink" title="4.4事务"></a>4.4事务</h4><p>IndexedDB支持事务，即对数据库进行操作时，只要失败了，都会回滚到最初始的状态，确保数据的一致性。</p>
<h3 id="5-IndexedDB实操"><a href="#5-IndexedDB实操" class="headerlink" title="5.IndexedDB实操"></a>5.IndexedDB实操</h3><p>IndexedDB所有针对仓库的操作都是基于事务的。</p>
<h4 id="5-1创建或连接数据库"><a href="#5-1创建或连接数据库" class="headerlink" title="5.1创建或连接数据库"></a>5.1创建或连接数据库</h4><p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开数据库</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; dbName 数据库的名字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; version 数据库的版本</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object</span>&#125; 该函数会返回一个数据库实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-params">dbName, version = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//  兼容浏览器</span><br>    <span class="hljs-keyword">var</span> indexedDB =<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">indexedDB</span> ||<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">mozIndexedDB</span> ||<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitIndexedDB</span> ||<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">msIndexedDB</span>;<br>    <span class="hljs-keyword">let</span> db;<br>    <span class="hljs-comment">// 打开数据库，若没有则会创建</span><br>    <span class="hljs-keyword">const</span> request = indexedDB.<span class="hljs-title function_">open</span>(dbName, version);<br>    <span class="hljs-comment">// 数据库打开成功回调</span><br>    request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// 数据库对象</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库打开成功&quot;</span>);<br>      <span class="hljs-title function_">resolve</span>(db);<br>    &#125;;<br>    <span class="hljs-comment">// 数据库打开失败的回调</span><br>    request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库打开报错&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">// 数据库有更新时候的回调</span><br>    request.<span class="hljs-property">onupgradeneeded</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-comment">// 数据库创建或升级的时候会触发</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onupgradeneeded&quot;</span>);<br>      db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// 数据库对象</span><br>      <span class="hljs-keyword">var</span> objectStore;<br>      <span class="hljs-comment">// 创建存储库</span><br>      objectStore = db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">&quot;signalChat&quot;</span>, &#123;<br>        <span class="hljs-attr">keyPath</span>: <span class="hljs-string">&quot;sequenceId&quot;</span>, <span class="hljs-comment">// 这是主键</span><br>        <span class="hljs-comment">// autoIncrement: true // 实现自增</span><br>      &#125;);<br>      <span class="hljs-comment">// 创建索引，在后面查询数据的时候可以根据索引查</span><br>      objectStore.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span> &#125;); <br>      objectStore.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;sequenceId&quot;</span>, <span class="hljs-string">&quot;sequenceId&quot;</span>, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span> &#125;);<br>      objectStore.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;messageType&quot;</span>, <span class="hljs-string">&quot;messageType&quot;</span>, &#123;<br>        <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span>,<br>      &#125;);<br>    &#125;;<br>  &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们将创建数据库的操作封装成了一个函数，并且该函数返回一个promise对象，使得在调用的时候可以链式调用，函数主要接收两个参数：数据库名称、数据库版本。函数内部主要有三个回调函数，分别是：</p>
<ul>
<li><strong>onsuccess</strong>：数据库打开成功或者创建成功后的回调，这里我们将数据库实例返回了出去。</li>
<li><strong>onerror</strong>：数据库打开或创建失败后的回调。</li>
<li><strong>onupgradeneeded</strong>：当数据库版本有变化的时候会执行该函数，比如我们想创建新的存储库（表），就可以在该函数里面操作，更新数据库版本即可。</li>
</ul>
<h4 id="5-2插入数据"><a href="#5-2插入数据" class="headerlink" title="5.2插入数据"></a>5.2插入数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; data 数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addData</span>(<span class="hljs-params">db, storeName, data</span>) &#123;<br>  <span class="hljs-keyword">var</span> request = db<br>    .<span class="hljs-title function_">transaction</span>([storeName], <span class="hljs-string">&quot;readwrite&quot;</span>) <span class="hljs-comment">// 事务对象 指定表格名称和操作模式（&quot;只读&quot;或&quot;读写&quot;）</span><br>    .<span class="hljs-title function_">objectStore</span>(storeName) <span class="hljs-comment">// 仓库对象</span><br>    .<span class="hljs-title function_">add</span>(data);<br><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据写入成功&quot;</span>);<br>  &#125;;<br><br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据写入失败&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>IndexedDB插入数据需要通过事务来进行操作，插入的方法也很简单，利用IndexedDB提供的add方法即可，这里我们同样将插入数据的操作封装成了一个函数，接收三个参数，分别如下：</p>
<ul>
<li>db：在创建或连接数据库时，返回的db实例，需要那个时候保存下来。</li>
<li>storeName：仓库名称(或者表名)，在创建或连接数据库时我们就已经创建好了仓库。</li>
<li>data：需要插入的数据，通常是一个对象</li>
</ul>
<p><strong>【注意】：</strong>插入的数据是一个对象，而且必须包含我们声明的索引键值对。</p>
<h4 id="5-3通过主键读取数据"><a href="#5-3通过主键读取数据" class="headerlink" title="5.3通过主键读取数据"></a>5.3通过主键读取数据</h4><p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过主键读取数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; key 主键值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDataByKey</span>(<span class="hljs-params">db, storeName, key</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> transaction = db.<span class="hljs-title function_">transaction</span>([storeName]); <span class="hljs-comment">// 事务</span><br>    <span class="hljs-keyword">var</span> objectStore = transaction.<span class="hljs-title function_">objectStore</span>(storeName); <span class="hljs-comment">// 仓库对象</span><br>    <span class="hljs-keyword">var</span> request = objectStore.<span class="hljs-title function_">get</span>(key); <span class="hljs-comment">// 通过主键获取数据</span><br><br>    request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;事务失败&quot;</span>);<br>    &#125;;<br><br>    request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;主键查询结果: &quot;</span>, request.<span class="hljs-property">result</span>);<br>      <span class="hljs-title function_">resolve</span>(request.<span class="hljs-property">result</span>);<br>    &#125;;<br>  &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>主键即刚刚我们在创建数据库时声明的keyPath，通过主键只能查询出一条数据。</p>
<h4 id="5-4通过游标查询数据"><a href="#5-4通过游标查询数据" class="headerlink" title="5.4通过游标查询数据"></a>5.4通过游标查询数据</h4><p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过游标读取数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cursorGetData</span>(<span class="hljs-params">db, storeName</span>) &#123;<br>  <span class="hljs-keyword">let</span> list = [];<br>  <span class="hljs-keyword">var</span> store = db<br>    .<span class="hljs-title function_">transaction</span>(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>) <span class="hljs-comment">// 事务</span><br>    .<span class="hljs-title function_">objectStore</span>(storeName); <span class="hljs-comment">// 仓库对象</span><br>  <span class="hljs-keyword">var</span> request = store.<span class="hljs-title function_">openCursor</span>(); <span class="hljs-comment">// 指针对象</span><br>  <span class="hljs-comment">// 游标开启成功，逐行读数据</span><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">var</span> cursor = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>    <span class="hljs-keyword">if</span> (cursor) &#123;<br>      <span class="hljs-comment">// 必须要检查</span><br>      list.<span class="hljs-title function_">push</span>(cursor.<span class="hljs-property">value</span>);<br>      cursor.<span class="hljs-title function_">continue</span>(); <span class="hljs-comment">// 遍历了存储对象中的所有内容</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;游标读取的数据：&quot;</span>, list);<br>    &#125;<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上面函数开启了一个游标，然后逐行读取数据，存入数组，最终得到整个仓库的所有数据。</p>
<h4 id="5-5通过索引查询数据"><a href="#5-5通过索引查询数据" class="headerlink" title="5.5通过索引查询数据"></a>5.5通过索引查询数据</h4><p><strong>代码如下：</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ini">/**<br> * 通过索引读取数据<br> * @param &#123;object&#125; db 数据库实例<br> * @param &#123;string&#125; storeName 仓库名称<br> * @param &#123;string&#125; indexName 索引名称<br> * @param &#123;string&#125; indexValue 索引值<br> */<br>function getDataByIndex(db, storeName, indexName, indexValue) &#123;<br>  var <span class="hljs-attr">store</span> = db.transaction(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).objectStore(storeName)<span class="hljs-comment">;</span><br>  var <span class="hljs-attr">request</span> = store.index(indexName).get(indexValue)<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onerror</span> = function () &#123;<br>    console.log(&quot;事务失败&quot;)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onsuccess</span> = function (e) &#123;<br>    var <span class="hljs-attr">result</span> = e.target.result<span class="hljs-comment">;</span><br>    console.log(&quot;索引查询结果：&quot;, result)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>索引名称即我们创建仓库的时候创建的索引名称，也就是键值对中的键，最终会查询出所有满足我们传入函数索引值的数据。</p>
<h4 id="5-6通过索引和游标查询数据"><a href="#5-6通过索引和游标查询数据" class="headerlink" title="5.6通过索引和游标查询数据"></a>5.6通过索引和游标查询数据</h4><p>通过5.4节和5.5节我们发现，单独通过索引或者游标查询出的数据都是部分或者所有数据，如果我们想要查询出索引中满足某些条件的所有数据，那么单独使用索引或游标是无法实现的。当然，你也可以查询出所有数据之后在循环数组筛选出合适的数据，但是这不是最好的实现方式，最好的方式当然是将索引和游标结合起来。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过索引和游标查询记录</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; indexName 索引名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; indexValue 索引值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cursorGetDataByIndex</span>(<span class="hljs-params">db, storeName, indexName, indexValue</span>) &#123;<br>  <span class="hljs-keyword">let</span> list = [];<br>  <span class="hljs-keyword">var</span> store = db.<span class="hljs-title function_">transaction</span>(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).<span class="hljs-title function_">objectStore</span>(storeName); <span class="hljs-comment">// 仓库对象</span><br>  <span class="hljs-keyword">var</span> request = store<br>    .<span class="hljs-title function_">index</span>(indexName) <span class="hljs-comment">// 索引对象</span><br>    .<span class="hljs-title function_">openCursor</span>(<span class="hljs-title class_">IDBKeyRange</span>.<span class="hljs-title function_">only</span>(indexValue)); <span class="hljs-comment">// 指针对象</span><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">var</span> cursor = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>    <span class="hljs-keyword">if</span> (cursor) &#123;<br>      <span class="hljs-comment">// 必须要检查</span><br>      list.<span class="hljs-title function_">push</span>(cursor.<span class="hljs-property">value</span>);<br>      cursor.<span class="hljs-title function_">continue</span>(); <span class="hljs-comment">// 遍历了存储对象中的所有内容</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;游标索引查询结果：&quot;</span>, list);<br>    &#125;<br>  &#125;;<br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;&#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上面函数接收四个参数，分别是：</p>
<ul>
<li>db：数据库实例</li>
<li>storeName：仓库名</li>
<li>indexName：索引名称</li>
<li>indexName：索引值</li>
</ul>
<p>利用索引和游标结合查询，我们可以查询出索引值满足我们传入函数值的所有数据对象，而不是之查询出一条数据或者所有数据。</p>
<h4 id="5-7通过索引和游标分页查询"><a href="#5-7通过索引和游标分页查询" class="headerlink" title="5.7通过索引和游标分页查询"></a>5.7通过索引和游标分页查询</h4><p>IndexedDB分页查询不像MySQL分页查询那么简单，没有提供现成的API，如limit等，所以需要我们自己实现分页。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs ini">/**<br> * 通过索引和游标分页查询记录<br> * @param &#123;object&#125; db 数据库实例<br> * @param &#123;string&#125; storeName 仓库名称<br> * @param &#123;string&#125; indexName 索引名称<br> * @param &#123;string&#125; indexValue 索引值<br> * @param &#123;number&#125; page 页码<br> * @param &#123;number&#125; pageSize 查询条数<br> */<br>function cursorGetDataByIndexAndPage(<br>  db,<br>  storeName,<br>  indexName,<br>  indexValue,<br>  page,<br>  pageSize<br>) &#123;<br>  let <span class="hljs-attr">list</span> = []<span class="hljs-comment">;</span><br>  let <span class="hljs-attr">counter</span> = <span class="hljs-number">0</span><span class="hljs-comment">; // 计数器</span><br>  let <span class="hljs-attr">advanced</span> = <span class="hljs-literal">true</span><span class="hljs-comment">; // 是否跳过多少条查询</span><br>  var <span class="hljs-attr">store</span> = db.transaction(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).objectStore(storeName)<span class="hljs-comment">; // 仓库对象</span><br>  var <span class="hljs-attr">request</span> = store<br>    .index(indexName) // 索引对象<br>    .openCursor(IDBKeyRange.only(indexValue))<span class="hljs-comment">; // 指针对象</span><br>  <span class="hljs-attr">request.onsuccess</span> = function (e) &#123;<br>    var <span class="hljs-attr">cursor</span> = e.target.result<span class="hljs-comment">;</span><br>    if (page &gt; 1 &amp;&amp; advanced) &#123;<br>      <span class="hljs-attr">advanced</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br>      cursor.advance((page - 1) * pageSize)<span class="hljs-comment">; // 跳过多少条</span><br>      return<span class="hljs-comment">;</span><br>    &#125;<br>    if (cursor) &#123;<br>      // 必须要检查<br>      list.push(cursor.value)<span class="hljs-comment">;</span><br>      counter++<span class="hljs-comment">;</span><br>      if (counter &lt; pageSize) &#123;<br>        cursor.continue()<span class="hljs-comment">; // 遍历了存储对象中的所有内容</span><br>      &#125; else &#123;<br>        <span class="hljs-attr">cursor</span> = null<span class="hljs-comment">;</span><br>        console.log(&quot;分页查询结果&quot;, list)<span class="hljs-comment">;</span><br>      &#125;<br>    &#125; else &#123;<br>      console.log(&quot;分页查询结果&quot;, list)<span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onerror</span> = function (e) &#123;&#125;<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这里用到了IndexedDB的一个API：advance。该函数可以让我们的游标跳过多少条开始查询。假如我们的额分页是每页10条数据，现在需要查询第2页，那么我们就需要跳过前面10条数据，从11条数据开始查询，直到计数器等于10，那么我们就关闭游标，结束查询。</p>
<h4 id="5-8更新数据"><a href="#5-8更新数据" class="headerlink" title="5.8更新数据"></a>5.8更新数据</h4><p>IndexedDB更新数据较为简单，直接使用put方法，值得注意的是如果数据库中没有该条数据，则会默认增加该条数据，否则更新。有些小伙伴喜欢更新和新增都是用put方法，这也是可行的。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; data 数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDB</span>(<span class="hljs-params">db, storeName, data</span>) &#123;<br>  <span class="hljs-keyword">var</span> request = db<br>    .<span class="hljs-title function_">transaction</span>([storeName], <span class="hljs-string">&quot;readwrite&quot;</span>) <span class="hljs-comment">// 事务对象</span><br>    .<span class="hljs-title function_">objectStore</span>(storeName) <span class="hljs-comment">// 仓库对象</span><br>    .<span class="hljs-title function_">put</span>(data);<br><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据更新成功&quot;</span>);<br>  &#125;;<br><br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据更新失败&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>put方法接收一个数据对象。</p>
<h4 id="5-9通过主键删除数据"><a href="#5-9通过主键删除数据" class="headerlink" title="5.9通过主键删除数据"></a>5.9通过主键删除数据</h4><p>主键即我们创建数据库时申明的keyPath，它是唯一的。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过主键删除数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; storeName 仓库名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; id 主键值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteDB</span>(<span class="hljs-params">db, storeName, id</span>) &#123;<br>  <span class="hljs-keyword">var</span> request = db<br>    .<span class="hljs-title function_">transaction</span>([storeName], <span class="hljs-string">&quot;readwrite&quot;</span>)<br>    .<span class="hljs-title function_">objectStore</span>(storeName)<br>    .<span class="hljs-title function_">delete</span>(id);<br><br>  request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据删除成功&quot;</span>);<br>  &#125;;<br><br>  request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据删除失败&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该种删除只能删除一条数据，必须传入主键。</p>
<h4 id="5-10通过索引和游标删除指定数据"><a href="#5-10通过索引和游标删除指定数据" class="headerlink" title="5.10通过索引和游标删除指定数据"></a>5.10通过索引和游标删除指定数据</h4><p>有时候我们拿不到主键值，只能只能通过索引值来删除，通过这种方式，我们可以删除一条数据（索引值唯一）或者所有满足条件的数据（索引值不唯一）。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ini">/**<br> * 通过索引和游标删除指定的数据<br> * @param &#123;object&#125; db 数据库实例<br> * @param &#123;string&#125; storeName 仓库名称<br> * @param &#123;string&#125; indexName 索引名<br> * @param &#123;object&#125; indexValue 索引值<br> */<br>function cursorDelete(db, storeName, indexName, indexValue) &#123;<br>  var <span class="hljs-attr">store</span> = db.transaction(storeName, <span class="hljs-string">&quot;readwrite&quot;</span>).objectStore(storeName)<span class="hljs-comment">;</span><br>  var <span class="hljs-attr">request</span> = store<br>    .index(indexName) // 索引对象<br>    .openCursor(IDBKeyRange.only(indexValue))<span class="hljs-comment">; // 指针对象</span><br>  <span class="hljs-attr">request.onsuccess</span> = function (e) &#123;<br>    var <span class="hljs-attr">cursor</span> = e.target.result<span class="hljs-comment">;</span><br>    var deleteRequest<span class="hljs-comment">;</span><br>    if (cursor) &#123;<br>      <span class="hljs-attr">deleteRequest</span> = cursor.delete()<span class="hljs-comment">; // 请求删除当前项</span><br>      <span class="hljs-attr">deleteRequest.onerror</span> = function () &#123;<br>        console.log(&quot;游标删除该记录失败&quot;)<span class="hljs-comment">;</span><br>      &#125;<span class="hljs-comment">;</span><br>      <span class="hljs-attr">deleteRequest.onsuccess</span> = function () &#123;<br>        console.log(&quot;游标删除该记录成功&quot;)<span class="hljs-comment">;</span><br>      &#125;<span class="hljs-comment">;</span><br>      cursor.continue()<span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<span class="hljs-comment">;</span><br>  <span class="hljs-attr">request.onerror</span> = function (e) &#123;&#125;<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>上段代码可以删除索引值为indexValue的所有数据，值得注意的是使用了<a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/IDBKeyRange">IDBKeyRange.only(）</a>API，该API代表只能当两个值相等时，具体API解释可参考MDN官网。</p>
<h4 id="5-11关闭数据库"><a href="#5-11关闭数据库" class="headerlink" title="5.11关闭数据库"></a>5.11关闭数据库</h4><p>当我们数据库操作完毕后，建议关闭它，节约资源。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关闭数据库</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; db 数据库实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">closeDB</span>(<span class="hljs-params">db</span>) &#123;<br>  db.<span class="hljs-title function_">close</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库已关闭&quot;</span>);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>5.12删除数据库</p>
<p>最后我们需要删库跑路，删除操作也很简单。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除数据库</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; dbName 数据库名称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteDBAll</span>(<span class="hljs-params">dbName</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dbName);<br>  <span class="hljs-keyword">let</span> deleteRequest = <span class="hljs-variable language_">window</span>.<span class="hljs-property">indexedDB</span>.<span class="hljs-title function_">deleteDatabase</span>(dbName);<br>  deleteRequest.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;删除失败&quot;</span>);<br>  &#125;;<br>  deleteRequest.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;删除成功&quot;</span>);<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>IndexedDB数据库没有我们想象的那么复杂，了解了它的几个基本概念，上手还是很快的，无非就是增删改查等等，虽然可能开发中用的少，但是了解一下不至于真正用到的时候两眼抓瞎。</p>
<h2 id="28-js最大值"><a href="#28-js最大值" class="headerlink" title="28 js最大值"></a>28 js最大值</h2><p>js的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=number%E7%B1%BB&spm=1001.2101.3001.7020">number类</a>型有个最大值（安全值）。即2的53次方，为9007199254740992。如果超过这个值，那么js会出现不精确的问题。这个值为16位。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><h4 id="1-后端发字符串类型。"><a href="#1-后端发字符串类型。" class="headerlink" title="1.后端发字符串类型。"></a>1.后端发字符串类型。</h4><p>将后端发过来的long类型转为string类型再向前端传。如果向前端传的是DAO集合，则每个DAO都需要转类型，太过于繁琐。想想就算了。</p>
<h4 id="2-在userDao中加入一个字段"><a href="#2-在userDao中加入一个字段" class="headerlink" title="2.在userDao中加入一个字段"></a>2.在userDao中加入一个字段</h4><p>如果项目已经成型并且修改数据库会造成不可预料的问题那么可以在User对象中再增加一个String类型id映射字段，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">private <span class="hljs-title class_">Long</span> userId;<br>private <span class="hljs-title class_">String</span> userIdStr;<br>public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUserIdStr</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userId</span>+<span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br>public <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserIdStr</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> userIdStr</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">userIdStr</span> = userIdStr;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法是比较靠谱的，确实可以正常的显示数据，查询单个数据id的值都是正确的。但修改用户时无法获取前端传过来的userDao中的userIdStr的值，因为上面的getUserIdStr()不能获取userIdStr的值（如果id没有值）。</p>
<h4 id="3-控制用户新建数据时id的长度。兜兜转转觉得这个最方便。"><a href="#3-控制用户新建数据时id的长度。兜兜转转觉得这个最方便。" class="headerlink" title="3.控制用户新建数据时id的长度。兜兜转转觉得这个最方便。"></a>3.控制用户新建数据时id的长度。兜兜转转觉得这个最方便。</h4><h2 id="29-事件循环和垃圾回收的工作机制"><a href="#29-事件循环和垃圾回收的工作机制" class="headerlink" title="29 事件循环和垃圾回收的工作机制"></a>29 事件循环和垃圾回收的工作机制</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>官网说，JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。</p>
<p>仔细来看看事件循环的责任，也就是他负责了什么：</p>
<ul>
<li>执行代码</li>
<li>收集和处理事件</li>
<li>执行队列中的子任务</li>
</ul>
<p>我们能够接收到这样的三个信息，基于这三个信息，我们来思考如下问题：</p>
<ul>
<li>如何执行代码？以什么样的流程操作的？</li>
<li>如何收集事件？如何处理事件？是否存在事件的优先级，比如说宏任务&#x2F;微任务先执行哪个？</li>
<li>如何执行队列中的子任务？</li>
</ul>
<p>根据下图和图下的代码进行分析：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dd6e851599487cb1e044e6a4f4b186~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">b</span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">return</span> a + b + <span class="hljs-number">11</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">let</span> y = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>(x * y);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bar</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 返回 42</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h4><p>在JavaScript中，函数的调用行成了一个由若干帧组成的栈。每一帧是60Hz，大概是16.6ms。</p>
<p>上面代码为例，当调用bar时，第一帧被创建并压入栈中，这一帧包含了bar的参数和局部变量。</p>
<p>当bar调用foo的时候，第二个帧被创建并压入栈中，并放在第一个帧之上，第二帧中包含foo的参数和局部变量。</p>
<p>当foo执行完毕然后返回时，第二个帧就被弹出栈了。此时剩下bar函数调用帧。</p>
<p>当bar也执行完毕然后返回时，第一个栈也被弹出了，栈就被清空了。</p>
<h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h4><p>堆是用来表示一大块(通常是非结构化的)内存区域的计算机术语。</p>
<p>对象会被分配在堆中。比如：用一个变量存储对象，这个对象会在堆中有一个唯一标识，栈中的变量会保存这个唯一标识来确定你引用的是哪个对象。多个变量标识如果一样，证明引用了同一个对象。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>一段JavaScript代码运行时包含了一个待处理消息的消息队列。每一个消息都包含着用来处理这个消息的回调函数。</p>
<p>在事件循环期间的某个时刻，运行时会从最先进入队列中的消息开始处理。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。这个函数调用还会创建一个新的栈。</p>
<p>函数的处理会一直进行到栈空了为止；然后事件循环会继续处理任务队列中下一个消息。</p>
<h4 id="执行完成"><a href="#执行完成" class="headerlink" title="执行完成"></a>执行完成</h4><p>每一个消息被完整的执行完之后，其他消息才会被执行。</p>
<p>这样做会为程序的分析提供了一些优秀的特性，比如下面这个：</p>
<ul>
<li>当一个函数被执行时不会被抢占，只有在他运行完毕之后才会运行其他代码，才会修改这个函数操作的数据。</li>
</ul>
<p>当然这个模型也是存在缺点的：</p>
<ul>
<li>当一个消息需要很久的时间才能处理完毕，Web应用程序会无法处理与用户的交互，比如滚动&#x2F;点击。 一定养成好的习惯，缩短单个消息处理的时间。</li>
</ul>
<h4 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a>添加消息</h4><p>在浏览器里，每当有一个事件发生并且有一个事件监听绑定在改事件上时，一个消息就会被添加到事件队列中。如果没有事件监听器，这个事件将会丢失。</p>
<p>比如带有点击事件的元素被点击时，就会像其他事件一样产生一个消息。</p>
<p>setTimeout 函数是特殊的，他接受两个参数：待加入队列的消息 ｜ 一个时间值（默认是0）。</p>
<p>这个时间表示消息实际被加入到队列的最小延时时间。意思就是：如果队列中没有其他消息，并且栈为空，在这段延时的时间过去之后，setTimeout 里的消息就会被立马处理。但是，如果有其他消息，setTimeout 必须等其他消息处理完才能在这段延时时间过去之后处理消息。</p>
<p>这就是常说的宏任务与微任务。setTimeout 作为宏任务，始终是等前面的微任务执行完之后，延迟执行。其他的宏任务还有JS文件，也就是前面的JS文件会作为优先后面的JS文件的宏任务。</p>
<h4 id="永不阻塞"><a href="#永不阻塞" class="headerlink" title="永不阻塞"></a>永不阻塞</h4><p>JavaScript事件循环模型与其它语言不同，有一个非常有趣的特性：永不阻塞。例如：在用户XHR请求返回时，我们任然可以进对输入框的输入。</p>
<p>会有一些例外，如alert或者同步XHR。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾回收在计算机编程中用于描述查找和删除那些不再被其他对象引用的对象的处理过程。</p>
<p>当某个程序占用一部分内存空间，并且不再被这个程序访问时，这个程序就会借助垃圾回收算法向操作系统归还这部分操作空间。</p>
<p>记不记得事件循环中的Heap，堆就是管理所有内存空间的地方。当有一个对象没有被使用到，也就是说谁也没有引用到这个对象。那就会被回收，会被垃圾回收算法进行处理。</p>
<p>如何处理的？我们接下来看看。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>垃圾回收有两个基本原理：</p>
<ul>
<li>考虑某个对象在未来的程序运行中，将不会被访问。</li>
<li>回收这些对象所占用的存储器。</li>
</ul>
<p>思考下面这个问题：</p>
<ul>
<li>如何知道这个对象在未来会不被使用到？</li>
</ul>
<h4 id="跟踪收集器"><a href="#跟踪收集器" class="headerlink" title="跟踪收集器"></a>跟踪收集器</h4><p>跟踪收集器是通过算法运行的，他主要做的是定期遍历它所管理的内存空间。</p>
<p>它会从若干个根存储对象中开始查找与之相关的存储对象，然后标记其余的没有关联的存储对象，最后回收这些没有关联的存储对象占用的内存空间。</p>
<p>跟踪收集器中的大概运行流程我们明白了，接下来看看他都有哪些算法吧。</p>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><p>先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后，恢复运行线程。</p>
<p>这样做会产生大量的空闲空间碎片，和使得大容量对象不容易获得连续的内存空间，从而造成浪费。</p>
<p>我们来举例子：</p>
<p>JS运行是单线程的，在运行之前会被进行垃圾回收，先暂停JS的运行，回收线程进行扫描，标记没有用到的对象，标记完成之后直接清除这个对象，回收存储器。最后恢复JS运行。</p>
<p>由于我们回收的空间可能不是连续的，就会导致产生空闲空间碎片，如果这个被回收的存储器左右皆是大容量对象进行存储，这样大容量对象就不会有连续的存储空间，从而造成浪费。</p>
<p>为什么不连续会造成浪费？如果一个变量应用这个大容量对象，本来应该是找到下一个存储器就可以，由于不连续，得找下下一个，这就是浪费。</p>
<h4 id="标记-压缩"><a href="#标记-压缩" class="headerlink" title="标记 - 压缩"></a>标记 - 压缩</h4><p>和标记 - 清除相似，不同的是，回收期间同时会将保留的存储对象搬运到连续的内存空间。</p>
<p>这样会对空闲的空间进行整合，避免内存碎片化。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>需要程序将所拥有的空间分成两个部分。程序运行所需要的存储对象会被先存储在一个分区（分区0）。同样暂停整个运行程序的全部运行线程，进行标记之后，回首期间将保留的存储对象搬运汇集到另一个分区（分区1），完成回收，程序在本次回收之后将接下来产生的存储对象存储到“分区1”。在下一次回收时，将两个分区角色对调。</p>
<h4 id="增量回收器"><a href="#增量回收器" class="headerlink" title="增量回收器"></a>增量回收器</h4><p>需要程序将所拥有的内存空间分成若干个分区。程序运行时所需要的存储对象会分布在这些分区中，每次只对一个分区进行回收操作。</p>
<p>这样避免了暂停所有正在运行的线程来进行回收，允许部分线程在不影响回收行为下保持运行，降低了回收时间，增加了响应速度。</p>
<h4 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h4><p>由于“复制”算法对于存活时间长，大容量的存储对象移动时消耗时间长，和存在存储对象的存活时间的差异。需要程序将所有的内存空间分成若干分区，并标记为年轻代空间和老年代空间。</p>
<p>运行时所需存储的对象会先被存储到年轻代分区。</p>
<p>年轻代分区会较为频繁的进行垃圾回收行为，每次回收完成，幸存的存储对象内的寿命计数器会+1。当年轻代分区存储对象的寿命计数器达到了一定阀值或存储对象占用的空间超出了一定阀值时，会被移动到老年代分区。</p>
<p>老年代分区有较少运行的垃圾回收行为。</p>
<p>一般情况下还有永久代空间，用于程序整个运行的生命周期的对象存储，例如运行代码、数据常量等。该空间不会运行垃圾回收的操作。</p>
<p>通过这样分代处理，存活在局限域、小容量、寿命短的存储对象会被快速回收；存活在全局域、大容量、寿命长的存储对象就较少的被回收行为所处理。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>到此本篇文章就讲完了事件循环和垃圾回收的工作机制，来简单回顾一下。</p>
<ul>
<li>事件回收：<ul>
<li>栈(Stack)：队列中消息被压入</li>
<li>堆(Heap)：栈中引用对象变量。存储对象的内存。</li>
<li>队列(Queue)：消息的执行顺序。</li>
</ul>
</li>
<li>垃圾回收：针对堆中，存储对象如何存储，如何回收，通过相关算法实现。<ul>
<li>标记 - 清除：碎片多、不连续。</li>
<li>标记 - 压缩：减少了碎片、使得空间连续，减少浪费。但是时间相对较长，需要整理空间。</li>
<li>复制：移动会有时间损耗。存储对象存活时间有差异。</li>
<li>增量回收器：避免暂停了所有线程。降低了回收时间，增加了响应速度。</li>
<li>分代：年轻代分区、老年代分区。更好的优化了复制算法。</li>
</ul>
</li>
</ul>
<h2 id="30-说一下map和weakmap的区别"><a href="#30-说一下map和weakmap的区别" class="headerlink" title="30 说一下map和weakmap的区别"></a>30 说一下map和weakmap的区别</h2><h3 id="Weakmap的优点"><a href="#Weakmap的优点" class="headerlink" title="Weakmap的优点"></a>Weakmap的优点</h3><ul>
<li>不阻碍垃圾回收</li>
<li>api与map保持一致</li>
</ul>
<h3 id="Weakmap的缺点"><a href="#Weakmap的缺点" class="headerlink" title="Weakmap的缺点"></a>Weakmap的缺点</h3><ul>
<li>key必须是引用类型</li>
<li>外部没有了key的引用时，weakmap的数据可能被垃圾回收</li>
<li>不提供遍历数据的方法</li>
<li>无法得到map的大小</li>
</ul>
<h2 id="31-symbol使用场景"><a href="#31-symbol使用场景" class="headerlink" title="31 symbol使用场景"></a>31 symbol使用场景</h2><p>Symbol是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用Symbol()函数来创建一个Symbol实例：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">s1</span> = Symbol()<br>复制代码<br></code></pre></td></tr></table></figure>

<p>或者，你也可以在调用Symbol()函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">s2</span> = Symbol(<span class="hljs-string">&#x27;another symbol&#x27;</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果用当下比较流行的TypeScript的方式来描述这个Symbol()函数的话，可以表示成：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  &#123;any&#125; description 描述信息。可以是任何可以被转型成字符串的值，如：字符串、数字、对象、数组等</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Symbol</span>(<span class="hljs-params">description?: any</span>): <span class="hljs-title">symbol</span></span><br><span class="hljs-function">复制代码</span><br></code></pre></td></tr></table></figure>

<p>由于Symbol是一种基础数据类型，所以当我们使用typeof去检查它的类型的时候，它会返回一个属于自己的类型symbol，而不是什么string、object之类的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">typeof</span> s1  <span class="hljs-comment">// &#x27;symbol&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>另外，我们需要重点记住的一点是：每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回false：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">s1</span> = Symbol()<br>let <span class="hljs-attr">s2</span> = Symbol(<span class="hljs-string">&#x27;another symbol&#x27;</span>)<br>let <span class="hljs-attr">s3</span> = Symbol(<span class="hljs-string">&#x27;another symbol&#x27;</span>)<br><br><span class="hljs-attr">s1</span> === s2 // <span class="hljs-literal">false</span><br><span class="hljs-attr">s2</span> === s3 // <span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>Symbol()</code>不是一个完整的构造函数，因此不能通过<code>new Symbol()</code> 来创建(通过 <code>new</code>实例化的结果是一个 <code>object</code>对象，而不是原始类型的 <code>symbol</code>)</p>
<p><code>Symbol</code>不能进行隐式类型转换，但可以显式转为字符串；不能转化为数字，但可以转化为布尔值</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const s = Symbol(<span class="hljs-string">&#x27;s&#x27;</span>)<br><br><span class="hljs-comment">// 强制类型转换会抛类型错误</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s + <span class="hljs-string">&#x27;/s&#x27;</span>); <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a string</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;s&#125;</span>/s`</span>) <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a string</span><br><br><span class="hljs-comment">// 只能先进行强制转换</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(s) + <span class="hljs-string">&#x27;/s&#x27;</span>); <span class="hljs-comment">// Symbol(s)/s</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s.toString() + <span class="hljs-string">&#x27;/s&#x27;</span>); <span class="hljs-comment">// Symbol(s)/s</span><br><br></code></pre></td></tr></table></figure>



<h3 id="应用场景1：使用Symbol来作为对象属性名-key"><a href="#应用场景1：使用Symbol来作为对象属性名-key" class="headerlink" title="应用场景1：使用Symbol来作为对象属性名(key)"></a>应用场景1：使用Symbol来作为对象属性名(key)</h3><p>在这之前，我们通常定义或访问对象的属性时都是使用字符串，比如下面的代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss">let obj = &#123;<br>  abc: <span class="hljs-number">123</span>,<br>  <span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span><br>&#125;<br><br>obj<span class="hljs-selector-attr">[<span class="hljs-string">&quot;abc&quot;</span>]</span> <span class="hljs-comment">// 123</span><br>obj<span class="hljs-selector-attr">[<span class="hljs-string">&quot;hello&quot;</span>]</span> <span class="hljs-comment">// &#x27;world&#x27;</span><br>而现在，Symbol可同样用于对象属性的定义和访问：<br><br>const PROP_NAME = <span class="hljs-built_in">Symbol</span>()<br>const PROP_AGE = <span class="hljs-built_in">Symbol</span>()<br><br>let obj = &#123;<br>  <span class="hljs-selector-attr">[PROP_NAME]</span>: <span class="hljs-string">&quot;一斤代码&quot;</span><br>&#125;<br>obj<span class="hljs-selector-attr">[PROP_AGE]</span> = <span class="hljs-number">18</span><br><br>obj<span class="hljs-selector-attr">[PROP_NAME]</span> <span class="hljs-comment">// &#x27;一斤代码&#x27;</span><br>obj<span class="hljs-selector-attr">[PROP_AGE]</span> <span class="hljs-comment">// 18</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用Object.keys()或者for…in来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">let obj = &#123;<br>   <span class="hljs-selector-attr">[Symbol(<span class="hljs-string">&#x27;name&#x27;</span>)]</span>: <span class="hljs-string">&#x27;一斤代码&#x27;</span>,<br>   age: <span class="hljs-number">18</span>,<br>   title: <span class="hljs-string">&#x27;Engineer&#x27;</span><br>&#125;<br><br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.keys</span>(obj)   // <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>]</span><br><br>for (let <span class="hljs-selector-tag">p</span> in obj) &#123;<br>   console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">p</span>)   // 分别会输出：&#x27;age&#x27; 和 &#x27;title&#x27;<br>&#125;<br><br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.getOwnPropertyNames</span>(obj)   // <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>由上代码可知，Symbol类型的key是不能通过Object.keys()或者for…in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。</p>
<p>也正因为这样一个特性，当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">JSON.stringify(obj)  // &#123;<span class="hljs-string">&quot;age&quot;</span>:18,<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;Engineer&quot;</span>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。</p>
<p>然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">// 使用<span class="hljs-selector-tag">Object</span>的API<br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.getOwnPropertySymbols</span>(obj) // <span class="hljs-selector-attr">[Symbol(name)]</span><br><br>// 使用新增的反射API<br>Reflect<span class="hljs-selector-class">.ownKeys</span>(obj) // <span class="hljs-selector-attr">[Symbol(name), <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="应用场景2：使用Symbol来替代常量"><a href="#应用场景2：使用Symbol来替代常量" class="headerlink" title="应用场景2：使用Symbol来替代常量"></a>应用场景2：使用Symbol来替代常量</h3><p>先来看一下下面的代码，是不是在你的代码里经常会出现？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TYPE_AUDIO</span> = <span class="hljs-string">&#x27;AUDIO&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TYPE_VIDEO</span> = <span class="hljs-string">&#x27;VIDEO&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TYPE_IMAGE</span> = <span class="hljs-string">&#x27;IMAGE&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFileResource</span>(<span class="hljs-params">resource</span>) &#123;<br>  <span class="hljs-keyword">switch</span>(resource.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">TYPE_AUDIO</span>:<br>      <span class="hljs-title function_">playAudio</span>(resource)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">TYPE_VIDEO</span>:<br>      <span class="hljs-title function_">playVideo</span>(resource)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">TYPE_IMAGE</span>:<br>      <span class="hljs-title function_">previewImage</span>(resource)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Unknown type of resource&#x27;</span>)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值（比如这里的’AUDIO’、’VIDEO’、 ‘IMAGE’），常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。</p>
<p>现在有了Symbol，我们大可不必这么麻烦了：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">TYPE_AUDIO</span> = Symbol()<br>const <span class="hljs-attr">TYPE_VIDEO</span> = Symbol()<br>const <span class="hljs-attr">TYPE_IMAGE</span> = Symbol()<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样定义，直接就保证了三个常量的值是唯一的了！是不是挺方便的呢。</p>
<h3 id="应用场景3：使用Symbol定义类的私有属性-x2F-方法"><a href="#应用场景3：使用Symbol定义类的私有属性-x2F-方法" class="headerlink" title="应用场景3：使用Symbol定义类的私有属性&#x2F;方法"></a>应用场景3：使用Symbol定义类的私有属性&#x2F;方法</h3><p>我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。</p>
<p>而有了Symbol以及模块化机制，类的私有属性和方法才变成可能。例如：</p>
<p>在文件 a.js中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PASSWORD</span> = <span class="hljs-title class_">Symbol</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">username, password</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username<br>    <span class="hljs-variable language_">this</span>[<span class="hljs-variable constant_">PASSWORD</span>] = password<br>  &#125;<br><br>  <span class="hljs-title function_">checkPassword</span>(<span class="hljs-params">pwd</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-variable constant_">PASSWORD</span>] === pwd<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Login</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>在文件 b.js 中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span><br><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Login</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br><br>login.<span class="hljs-title function_">checkPassword</span>(<span class="hljs-string">&#x27;123456&#x27;</span>)  <span class="hljs-comment">// true</span><br><br>login.<span class="hljs-property">PASSWORD</span>  <span class="hljs-comment">// oh!no!</span><br>login[<span class="hljs-variable constant_">PASSWORD</span>] <span class="hljs-comment">// oh!no!</span><br>login[<span class="hljs-string">&quot;PASSWORD&quot;</span>] <span class="hljs-comment">// oh!no!</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个PASSWORD的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p>
<h3 id="注册和获取全局Symbol"><a href="#注册和获取全局Symbol" class="headerlink" title="注册和获取全局Symbol"></a>注册和获取全局Symbol</h3><p>通常情况下，我们在一个浏览器窗口中（window），使用Symbol()函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了iframe），并需要这些window中使用的某些Symbol是同一个，那就不能使用Symbol()函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是Symbol.for()，它可以注册或获取一个window间全局的Symbol实例：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">gs1</span> = Symbol.for(<span class="hljs-string">&#x27;global_symbol_1&#x27;</span>)  //注册一个全局Symbol<br>let <span class="hljs-attr">gs2</span> = Symbol.for(<span class="hljs-string">&#x27;global_symbol_1&#x27;</span>)  //获取全局Symbol<br><br><span class="hljs-attr">gs1</span> === gs2  // <span class="hljs-literal">true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p>
<p>好了，通过以上这些例子，你现在是不是开始对ES6的这个Symbol功能有点了解了呢？Symbol在JS内部也有很多应用，比如迭代器(Iterator)等，大家可以以此为出发点，发掘出更多相关知识点，深入的理解Symbol的用法和使用场景。</p>
<h3 id="js判断某个对象是否是Symbol对象"><a href="#js判断某个对象是否是Symbol对象" class="headerlink" title="js判断某个对象是否是Symbol对象"></a>js判断某个对象是否是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Symbol&spm=1001.2101.3001.7020">Symbol</a>对象</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul>
<li><p>typeof 为 symbol</p>
<p>或</p>
</li>
<li><p>typeof 为 object</p>
</li>
<li><p>不为null</p>
</li>
<li><p>toString 值为 [object Symbol]</p>
</li>
</ul>
<h2 id="32-proxy"><a href="#32-proxy" class="headerlink" title="32 proxy"></a>32 proxy</h2><p><code>Proxy</code>对象用于创建一个对象的代理，是用于监听一个对象的相关操作。代理对象可以监听我们对原对象的操作。</p>
<p>接下来我们将通过一个监听对象的属性操作来认识学习下什么是<code>Proxy</code>。</p>
<p>Proxy对象需要传入两个参数，分别是需要被<code>Proxy</code>代理的对象和一系列的捕获器（PS：下面会讲）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj=&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;_island&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> objProxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj,&#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy);<br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4a76a2240c4015bfd8182e16640b30~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20220204200341915"></p>
<p>打印出来可以看到的是一个<code>Proxy</code>对象。下面我们开始看看<code>Proxy</code>中的捕获器对象。</p>
<h3 id="Proxy捕获器"><a href="#Proxy捕获器" class="headerlink" title="Proxy捕获器"></a>Proxy捕获器</h3><p>在实例化<code>Proxy</code>对象时，第二个参数传入的是捕获器集合，我们在其对象内定义一个<code>get</code>捕获器，用于监听获取对象值的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个普通的对象obj</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span><br>&#125;;<br><br><span class="hljs-comment">// 代理obj这个对象，并传入get捕获器</span><br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-comment">// get捕获器</span><br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`捕获到对象获取<span class="hljs-subst">$&#123;key&#125;</span>属性的值操作`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 通过代理对象操作obj对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 捕获到对象获取name属性的值操作</span><br><span class="hljs-comment">// _island</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>在<code>objProxy</code>对象的拦截器中新增一个捕获器<code>set</code>，用于监听对象的某个属性被设置时触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// set捕获器</span><br><span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, val</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`捕获到对象设置<span class="hljs-subst">$&#123;key&#125;</span>属性的值操作,新值为<span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>  target[key] = val;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;QC2125&quot;</span>);<br><span class="hljs-comment">// 捕获到对象设置name属性的值操作,新值为QC2125</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 捕获到对象获取name属性的值操作</span><br><span class="hljs-comment">// QC2125</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果不想这个属性被设定这个值，你可以抛出异常告诉开发者，该值不能被设定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, val</span>) &#123;<br>  <span class="hljs-keyword">if</span> (key===<span class="hljs-string">&#x27;age&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    target[key] = val;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;该属性的值必须是Number类型&quot;</span>);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们也可以监听对象是否调用了<code>getPrototypeOf</code>操作，使用<code>getPrototypeOf</code>捕获器即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听getPrototypeOf</span><br><span class="hljs-attr">getPrototypeOf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到对象getPrototypeOf操作`</span>);<br>&#125;,<br>复制代码<br></code></pre></td></tr></table></figure>

<p>在<code>Proxy</code>中共有<code>13</code>个捕获器，它们用于我们对对象、函数的方法调用监听。下面是<code>Proxy</code>捕获器以及它们的触发条件。</p>
<table>
<thead>
<tr>
<th>对象中的方法</th>
<th>对应触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>handler.getPrototypeOf()</td>
<td><code>Object.getPrototypeOf</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.setPrototypeOf()</td>
<td><code>Object.setPrototypeOf</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.isExtensible()</td>
<td><code>Object.isExtensible</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.preventExtensions()</td>
<td><code>Object.preventExtensions</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.getOwnPropertyDescriptor()</td>
<td><code>Object.getOwnPropertyDescriptor</code> 方法的捕捉器。</td>
</tr>
<tr>
<td>handler.defineProperty()</td>
<td><code>Object.defineProperty</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.has()</td>
<td><code>in</code> 操作符的捕捉器</td>
</tr>
<tr>
<td>handler.get()</td>
<td>属性读取操作的捕捉器</td>
</tr>
<tr>
<td>handler.set()</td>
<td>属性设置操作的捕捉器</td>
</tr>
<tr>
<td>handler.deleteProperty()</td>
<td><code>delete</code> 操作符的捕捉器</td>
</tr>
<tr>
<td>handler.ownKeys()</td>
<td><code>Object.getOwnPropertyNames</code> 方法和 <code>Object.getOwnPropertySymbols</code> 方法的捕捉器</td>
</tr>
<tr>
<td>handler.apply()</td>
<td>函数被<code>apply</code>调用操作的捕捉器</td>
</tr>
<tr>
<td>handler.construct()</td>
<td><code>new</code> 操作符的捕捉器</td>
</tr>
</tbody></table>
<h3 id="this指向的问题"><a href="#this指向的问题" class="headerlink" title="this指向的问题"></a>this指向的问题</h3><p><code>Proxy</code>对象可以对我们的目标对象进行访问，但没有做任何拦截时，也不能保证与目标对象的行为一致，因为目标对象内部的<code>this</code>会自动改变为<code>Proxy</code>代理对象。我们看下面这个例子就知道了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj=&#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;_island&#x27;</span>,<br> <span class="hljs-attr">foo</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> === objProxy<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> objProxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj,&#123;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">foo</span>()); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-title function_">foo</span>()); <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="对象监听案例"><a href="#对象监听案例" class="headerlink" title="对象监听案例"></a>对象监听案例</h3><p>某些场景下，需要监听一个对象的操作，当这个操作触发时执行另外的一个函数，就像<code>vue2</code>中的<code>watchApi</code>，它可以监听<code>data</code>数据中某个属性的改变并操作指定的函数。</p>
<p>我们看看下面这份代码，在<code>ES5</code>中使用<code>Object.defineProperty</code>（对象属性描述符）对对象的监听，将一个对象进行遍历，并设定<code>getter</code>、<code>setter</code>方法进行监听和拦截。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个Object对象</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> val = obj[key];<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;调用了get方法&quot;</span>);<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;调用了set方法&quot;</span>);<br>      val = newVal;<br>    &#125;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 操作obj对象</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;QC2125&quot;</span>;<br><span class="hljs-comment">// name调用了set方法</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// age调用了set方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <br><span class="hljs-comment">// name调用了get方法</span><br><span class="hljs-comment">// QC2125</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>Object.defineProperty</code>的设计初衷并不是为了去监听拦截一个对象中的属性，且他也实现不了更加丰富的操作，例如添加、删除属性等操作。所以在<code>ES6</code>中新增了<code>Proxy</code>对象，用于监听<code>Object</code>、<code>Function</code>的操作。</p>
<p>我们将上面通过<code>Object.defineProperty</code>实现对象监听的方法修改成<code>Proxy</code>方案。在Vue3框架中的响应式原理也是用到了Proxy对象进行对属性的监听操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-comment">// 获取值时的捕获器</span><br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到了<span class="hljs-subst">$&#123;key&#125;</span>被获取值`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-comment">// 设置值时的捕获器</span><br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, newValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到了<span class="hljs-subst">$&#123;key&#125;</span>被设置值`</span>);<br>    target[key] = newValue;<br>  &#125;<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 监听到了name被获取值</span><br><span class="hljs-comment">// _island</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>);<br><span class="hljs-comment">// 监听到了age被获取值</span><br><span class="hljs-comment">// 18</span><br>objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;QC2125&quot;</span>;<br><span class="hljs-comment">// 监听到了name被设置值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 监听到了name被获取值</span><br><span class="hljs-comment">// QC2125</span><br></code></pre></td></tr></table></figure>

<h2 id="33-x3D-和-x3D-x3D-的的区别"><a href="#33-x3D-和-x3D-x3D-的的区别" class="headerlink" title="33 =&#x3D;=和&#x3D;&#x3D;的的区别"></a>33 =&#x3D;=和&#x3D;&#x3D;的的区别</h2><ul>
<li><p>“&#x3D;&#x3D;” 只判断等号两边的值是否相等，而不判断类型是否相同。值相同则返回 true</p>
</li>
<li><p>“&#x3D;&#x3D;&#x3D;” 既要判断值是否相等，也要判断类型是否相同，即全等才能返回 true</p>
</li>
</ul>
<h3 id="x3D-x3D-的实现"><a href="#x3D-x3D-的实现" class="headerlink" title="&#x3D;&#x3D;的实现"></a>&#x3D;&#x3D;的实现</h3><p>在 JavaScript 中，使用双等号（&#x3D;&#x3D;）进行比较时，会进行类型转换，比较的是两个值是否相等。</p>
<p>如果比较的两个值类型相同，则直接比较它们的值。如果值相等，返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>如果比较的两个值类型不同，则 JavaScript 会尝试将其中一个值转换为另一个值的类型，然后再进行比较。类型转换的规则如下：</p>
<ol>
<li>如果比较的两个值类型相同，则直接比较它们的值。</li>
<li>如果其中一个值为 <code>null</code>，另一个值为 <code>undefined</code>，返回 <code>true</code>。</li>
<li>如果其中一个值为布尔值（<code>true</code> 或 <code>false</code>），另一个值为非布尔值，将布尔值转换为数字类型（<code>1</code> 或 <code>0</code>），然后再进行比较。</li>
<li>如果其中一个值为字符串，另一个值为数字，将字符串转换为数字，然后再进行比较。</li>
<li>如果其中一个值为对象，另一个值为字符串、数字或布尔值，则将对象调用 <code>valueOf()</code> 方法后得到的原始值，再进行比较。如果 <code>valueOf()</code> 方法返回的值不是原始值，则继续调用 <code>toString()</code> 方法，得到的字符串再进行比较。</li>
<li>如果其中一个值为字符串、数字或布尔值，另一个值为对象，则调用对象的 <code>valueOf()</code> 和 <code>toString()</code> 方法，得到的值再进行比较。</li>
<li>如果比较的两个值都是对象，则比较它们的引用是否相等。</li>
</ol>
<p>以下是一些示例：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">javascriptCopy code<br><span class="hljs-attribute">null</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> undefined<span class="hljs-comment">; // true</span><br><span class="hljs-attribute">true</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // true</span><br><span class="hljs-attribute">false</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; // true</span><br><span class="hljs-string">&quot;1&quot;</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // true</span><br>[] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">; // true</span><br>&#123;&#125; <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;[object Object]&quot;</span><span class="hljs-comment">; // true</span><br><span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> new String(<span class="hljs-string">&quot;abc&quot;</span>)<span class="hljs-comment">; // true</span><br></code></pre></td></tr></table></figure>

<p>由于双等号存在类型转换的问题，容易导致一些意想不到的问题，因此在实际开发中，建议使用三等号（&#x3D;&#x3D;&#x3D;）进行比较，它不会进行类型转换，只有两个值的类型和值都相同，才会返回 <code>true</code>。</p>
<h3 id="x3D-x3D-x3D-的实现"><a href="#x3D-x3D-x3D-的实现" class="headerlink" title="&#x3D;&#x3D;&#x3D;的实现"></a>&#x3D;&#x3D;&#x3D;的实现</h3><p>在 JavaScript 中，”&#x3D;&#x3D;&#x3D;” 运算符又称为严格相等运算符，它用于比较两个值是否严格相等，包括类型和值。</p>
<p>其实现过程如下：</p>
<ol>
<li>如果两个操作数的数据类型不同，则它们不相等，直接返回 false。</li>
<li>如果两个操作数都是 null 或者都是 undefined，则它们相等。</li>
<li>如果两个操作数都是布尔类型 true 或 false，则它们相等。</li>
<li>如果其中一个操作数是 NaN，则它们不相等。</li>
<li>如果两个操作数都是数字，并且值相等（包括 +0 和 -0），则它们相等。</li>
<li>如果两个操作数都是字符串，而且内容相同，则它们相等。</li>
<li>如果两个操作数指向同一个对象、数组或函数，则它们相等。</li>
<li>如果以上条件均不满足，则它们不相等。</li>
</ol>
<p>需要注意的是，当使用 “&#x3D;&#x3D;&#x3D;” 运算符比较两个引用类型的值时，比较的是它们在内存中的地址，而不是对象中存储的数据。因此，即使两个对象中存储的数据相同，它们也不会被认为是相等的，除非它们是同一个对象的引用。</p>
<h2 id="34-JavaScript中-null-和-undefined-的区别"><a href="#34-JavaScript中-null-和-undefined-的区别" class="headerlink" title="34 JavaScript中 null 和 undefined 的区别"></a>34 JavaScript中 null 和 undefined 的区别</h2><h3 id="一、JS-中的-null"><a href="#一、JS-中的-null" class="headerlink" title="一、JS 中的 null"></a>一、JS 中的 null</h3><h4 id="1-描述："><a href="#1-描述：" class="headerlink" title="1. 描述："></a>1. 描述：</h4><p>① 是 JavaScript 基本类型之一，特指对象的值未设置，是表示缺少的标识，指示变量未指向任何对象，把 null 看为尚未创建的对象，也许更好理解；<br> ② 是一个字面量，不像 undefined，它不是全局对象的一个属性；<br> ③ 在布尔运算中被认为是 false；<br> ④ 与其他任何对象一样永远不会被 JavaScript 隐式赋值给变量。</p>
<p>注：如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 false，其他值都视为 true。</p>
<p>undefined<br> null<br> false<br> 0<br> NaN<br> “” 或 ‘’（空字符串）</p>
<h4 id="2-典型用法："><a href="#2-典型用法：" class="headerlink" title="2. 典型用法："></a>2. 典型用法：</h4><p>（1） 作为函数的参数，表示该函数的参数为空。</p>
<p>（2） 作为对象原型链的终点。</p>
<h3 id="二、JS-中的-undefined"><a href="#二、JS-中的-undefined" class="headerlink" title="二、JS 中的 undefined"></a>二、JS 中的 undefined</h3><ol>
<li><p>描述：<br>① 是 JavaScript 基本类型之一，表示 “缺少值”，就是此处应该有一个值，但是还没有定义；<br>② 是 JavaScript 在运行时创建的全局变量，是全局对象的一个属性；<br>③ 在布尔运算中被认为是 false。<br>注：有关全局对象和全局变量，可参考 javascript 全局对象与全局变量</p>
</li>
<li><p>典型用法：</p>
<p>（1）变量被声明但没有赋值时，就等于 undefined。</p>
<p>（2）对象的某个属性没有赋值时，该属性的值为 undefined。</p>
<p>（3）调用函数过程中，应该提供的参数没有提供时，该参数就等于 undefined。</p>
<p>（4）函数没有返回值时，默认返回 undefined。</p>
</li>
</ol>
<h3 id="三、JS-中的-undefined-和-null-的区别有："><a href="#三、JS-中的-undefined-和-null-的区别有：" class="headerlink" title="三、JS 中的 undefined 和 null 的区别有："></a>三、JS 中的 undefined 和 null 的区别有：</h3><h4 id="1-相等但不全等："><a href="#1-相等但不全等：" class="headerlink" title="1. 相等但不全等："></a>1. 相等但不全等：</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">	<span class="hljs-attr">null</span> == undefined	// <span class="hljs-literal">true</span><br>	<span class="hljs-attr">null</span> === undefined 	// <span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>实际上，undefined 值是派生自 null 值的，ECMAScript 标准规定对二者进行相等性测试要返回 true，可以理解为 null 和 undefined 都代表着无效的值，所以二者相等，但由于是两种不同的原始数据类型，所以不全等。</p>
<p>注：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">	<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>	<span class="hljs-comment">// undefined</span><br>	<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>		<span class="hljs-comment">// object</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>① typeof null 结果是 object，这是个历史遗留 bug，参考 js 中 typeof 用法详细介绍；<br> ② 在 ECMA6 中，曾经有提案为历史平反，将 typeof null 的值纠正为 null，但最后提案被拒了，理由是历史遗留代码太多，不想得罪人，不如继续将错就错当和事老。</p>
<h4 id="2-在数字运算中被转换为-number-类型的值不同"><a href="#2-在数字运算中被转换为-number-类型的值不同" class="headerlink" title="2. 在数字运算中被转换为 number 类型的值不同"></a>2. 在数字运算中被转换为 number 类型的值不同</h4><p>在 null 上执行算术转换时，确定的值为 0</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">	let <span class="hljs-attr">a</span> = <span class="hljs-number">10</span> + null<span class="hljs-comment">;</span><br>	<br>	console.log(a)<span class="hljs-comment">;	// 10	</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>undefined 得出的结果为 NaN</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">	let <span class="hljs-attr">b</span> = <span class="hljs-number">10</span> + undefined<span class="hljs-comment">;</span><br>	<br>	console.log(b)<span class="hljs-comment">;	// NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注：有关加法运算中的隐式类型转换，可参考 “加号 +” 的运算原理（详细！！！）</p>
<h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><p>都是原始类型的值，保存在栈中变量本地</p>
<h3 id="何时使用："><a href="#何时使用：" class="headerlink" title="何时使用："></a>何时使用：</h3><p>null当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null;</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">arr</span>=[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;cc&quot;</span>]<span class="hljs-comment">;</span><br><span class="hljs-attr">arr</span>=null<span class="hljs-comment">;//释放指向数组的引用</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="额外补充的知识"><a href="#额外补充的知识" class="headerlink" title="额外补充的知识"></a>额外补充的知识</h3><p>数组进行相等比较是一个怪物，看下面的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua">	[] == <span class="hljs-string">&#x27;&#x27;</span>   // -&gt; <span class="hljs-literal">true</span><br>	[] == <span class="hljs-number">0</span>    // -&gt; <span class="hljs-literal">true</span><br>	[<span class="hljs-string">&#x27;&#x27;</span>] == <span class="hljs-string">&#x27;&#x27;</span> // -&gt; <span class="hljs-literal">true</span><br>	[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>   // -&gt; <span class="hljs-literal">true</span><br>	[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;&#x27;</span>  // -&gt; <span class="hljs-literal">false</span><br>	[<span class="hljs-string">&#x27;&#x27;</span>] == <span class="hljs-number">0</span>  // -&gt; <span class="hljs-literal">true</span><br>	<br>	[null] == <span class="hljs-string">&#x27;&#x27;</span>      // <span class="hljs-literal">true</span><br>	[null] == <span class="hljs-number">0</span>       // <span class="hljs-literal">true</span><br>	[undefined] == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	[undefined] == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[[[[[]]]]]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[[[[[]]]]]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[[[[[ null ]]]]]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[[[[[ null ]]]]]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>	<br>	<span class="hljs-string">[[[[[[ undefined ]]]]]]</span> == <span class="hljs-number">0</span>  // <span class="hljs-literal">true</span><br>	<span class="hljs-string">[[[[[[ undefined ]]]]]]</span> == <span class="hljs-string">&#x27;&#x27;</span> // <span class="hljs-literal">true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>个人理解：</p>
<p> 以上例子可以理解为，在比较过程中， [] 、[null] 和 [undefined] 都隐式转换为 ‘’；</p>
<p> 对于最里层的 [] ，不管外层嵌套多少个 [] ，最终都可看成只有最里层一个 [] 。</p>
<h3 id="Null，NaN，Undefined"><a href="#Null，NaN，Undefined" class="headerlink" title="Null，NaN，Undefined"></a>Null，NaN，Undefined</h3><p>null：空对象，一般作为对象的初值</p>
<p>Nan：浮点数中表示未定义或不可表示的值，例如0&#x2F;0、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E2%88%9E?fromModule=lemma_inlink">∞</a>&#x2F;∞、∞&#x2F;−∞、−∞&#x2F;∞、−∞&#x2F;−∞</p>
<p>undefined：未定义，声明但未定义，例如，形参未传参，获取return的函数返回，对象属性名不存在</p>
<h3 id="toString，valueOf"><a href="#toString，valueOf" class="headerlink" title="toString，valueOf"></a>toString，valueOf</h3><p>javascript中所有数据类型都拥有valueOf和toString这两个方法，null和undefined除外（String() 都能转）</p>
<p>valueOf偏向于运算，toString偏向于显示</p>
<h2 id="35-如何根据class选取元素"><a href="#35-如何根据class选取元素" class="headerlink" title="35 如何根据class选取元素"></a>35 如何根据class选取元素</h2><p>可以使用以下两种方式根据 class 选取元素：</p>
<ol>
<li><p>使用 <code>document.getElementsByClassName()</code> 方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;example&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elements); <span class="hljs-comment">// NodeList of matched elements</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>document.querySelectorAll()</code> 方法，使用 CSS 选择器选取：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.example&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elements); <span class="hljs-comment">// NodeList of matched elements</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>这两种方式都会返回一个 NodeList 对象，可以使用 NodeList 提供的方法和属性对选取的元素进行操作和遍历。</p>
<h2 id="36-事件"><a href="#36-事件" class="headerlink" title="36 事件"></a>36 事件</h2><p>事件</p>
<p>文档和浏览器窗口中发生的特定交互</p>
<p>事件流</p>
<p>页面接受事件的先后顺序</p>
<p>事件类型</p>
<p>事件捕获：由外往内，从事件发生的根节点开始，逐级往下查找，一直到目标元素。</p>
<p>事件冒泡：由内往外，从具体的目标元素触发，逐级向上传递，直到根节点。</p>
<p>事件委托（⭐手写）</p>
<p>又名事件代理。事件委托就是利用事件冒泡，就是把子元素的事件都绑定到父元素上。</p>
<p>好处：提高性能，减少了事件绑定，从而减少内存占用</p>
<p>阻止事件冒泡：event.stopPropagation() .stop修饰符</p>
<ol>
<li>给”ul”标签添加点击事件</li>
<li>当点击某”li”标签时，该标签内容拼接”.”符号。如：某”li”标签被点击时，该标签内容为”..”<br>注意：</li>
<li>必须使用DOM0级标准事件（onclick）</li>
</ol>
<p>target表示当前触发事件的元素</p>
<p>currentTarget是绑定处理函数的元素</p>
<p>只有当事件处理函数绑定在自身的时候，target才会和currentTarget一样</p>
<h2 id="37-JS预解析（变量提升）"><a href="#37-JS预解析（变量提升）" class="headerlink" title="37 JS预解析（变量提升）"></a>37 JS预解析（变量提升）</h2><p><strong>预编译&#x2F;解析</strong>：JS代码在执行前，浏览器会对js代码进行扫描，默认的把所有带<strong>var和function声明</strong>的变量进行定义，创建执行<strong>上下文</strong>，初始化一些代码执行时需要用到的对象。</p>
<h2 id="38-Iterator，for-in，for-of，forEach，map循环遍历"><a href="#38-Iterator，for-in，for-of，forEach，map循环遍历" class="headerlink" title="38 Iterator，for in，for of，forEach，map循环遍历"></a>38 Iterator，for in，for of，forEach，map循环遍历</h2><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>一种接口，为各种不同的数据结构提供统一的访问机制</p>
<p>例如Array.prototype<a href="">@@iterator</a></p>
<p>Array 对象的 @@iterator 方法实现了迭代协议，并允许数组被大多数期望可迭代的语法所使用，例如展开语法和 for…of 循环。它返回一个迭代器，生成数组中每个索引的值。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>[“a”, “b”, “c”, “d”];for…in 循环读取键名 &#x2F;&#x2F; 0 1 2 3</p>
<p>适用于遍历对象的可枚举属性</p>
<p>无法遍历 symbol 属性 可以遍历到公有中可枚举的</p>
<p>使用 for…in 遍历时，还需要使用 hasOwnProperty() 方法来判断属性是否来自对象本身，并避免遍历原型链上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> object1 = &#123;&#125;;<br>object1.<span class="hljs-property">property1</span> = <span class="hljs-number">42</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;property1&#x27;</span>));<br><span class="hljs-comment">// Expected output: true</span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;hasOwnProperty&#x27;</span>));<br><span class="hljs-comment">// Expected output: false</span><br></code></pre></td></tr></table></figure>

<h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>[“a”, “b”, “c”, “d”];for…of 循环读取键值&#x2F;&#x2F; a b c d</p>
<p>支持迭代协议的数据结构（数组、字符串、Set、Map 等），不包括对象。</p>
<p>对于字符串，类数组，类型数组的迭代，循环内部调用的是数据结构的Symbol.iterator方法。</p>
<p>for…of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> object1 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;somestring&#x27;</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-literal">false</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(object1));<br><span class="hljs-comment">// Expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>arr.forEach（value[，index，默认隐藏参数arr]）</p>
<p>适用于需要知道索引值的数组遍历，但是不能中断（ break 和 return ）</p>
<p>如果需要跳出循环可以使用 some() 或 every() 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"> <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isBelowThreshold</span> = (<span class="hljs-params">currentValue</span>) =&gt; currentValue &lt; <span class="hljs-number">30</span>;<br> <br><span class="hljs-keyword">const</span> array1 = [<span class="hljs-number">1</span>, <span class="hljs-number">30</span>, <span class="hljs-number">39</span>, <span class="hljs-number">29</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>];<br> <br>array1.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element));<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array1.<span class="hljs-title function_">every</span>(isBelowThreshold));<br><span class="hljs-comment">// Expected output: false</span><br> <br><span class="hljs-comment">//是不是至少有 1 个元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array1.<span class="hljs-title function_">some</span>(isBelowThreshold));<span class="hljs-comment">//空数组,则返回false。</span><br><span class="hljs-comment">// Expected output: true</span><br></code></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 方法，基本用法与 forEach 一致</p>
<p>forEach()方法不会返回执行结果，而是undefined</p>
<p>map()方法会得到一个新的数组并返回</p>
<p>同样的一组数组，map()的执行速度优于 forEach()（map() 底层做了深度优化）</p>
<h2 id="39-严格模式"><a href="#39-严格模式" class="headerlink" title="39 严格模式"></a>39 严格模式</h2><p>严格模式通过抛出错误来消除了一些原有静默错误。</p>
<p>严格模式下，不允许给未声明的变量赋值</p>
<p>严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。</p>
<p>严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。</p>
<h2 id="40-JS延迟加载的方式"><a href="#40-JS延迟加载的方式" class="headerlink" title="40 JS延迟加载的方式"></a>40 JS延迟加载的方式</h2><p>JavaScript 是单线程（js不走完下面不会走是因为同步）会阻塞DOM的解析，因此也就会阻塞DOM的加载。所以有时候我们希望延迟JS的加载来提高页面的加载速度。</p>
<p>1.把JS放在页面的最底部（css放顶部，js放底部是框架常见优化）</p>
<p>2.script标签的defer属性：脚本会立即下载但延迟到整个页面加载完毕再执行。该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。</p>
<p>3.是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照指定他们的先后顺序执行， 该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。</p>
<p>4.动态创建script标签，监听dom加载完毕再引入js文件</p>
<h2 id="41-JavaScript-中-和"><a href="#41-JavaScript-中-和" class="headerlink" title="41 JavaScript 中 $$ 和 ||"></a>41 JavaScript 中 <code>$$</code> 和 <code>||</code></h2><p>JavaScript 中 <code>$$</code> 和 <code>||</code> 都可以用于数组过滤，但它们的规则有所不同。</p>
<p><code>$$</code> 是 <code>Array.prototype.filter</code> 的语法糖，它会把每个元素传递给一个函数，如果该函数返回值为 <code>true</code>，则将该元素添加到过滤后的数组中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascriptCopy code<br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">const</span> evenNumbers = arr.$$(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNumbers); <span class="hljs-comment">// [2, 4]</span><br></code></pre></td></tr></table></figure>

<p><code>||</code> 运算符的规则是，如果第一个操作数为“真”（即不是 <code>false</code>、<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code> 或空字符串），则返回它；否则返回第二个操作数。因此，可以用 <code>||</code> 过滤数组中的假值元素，例如：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">javascriptCopy code<br>const arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-number">2</span>];<br><br>const truthyValues = arr.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">Boolean</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(truthyValues); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure>

<p>这里的 <code>Boolean</code> 是 JavaScript 内置函数，会把它的参数转换为布尔值。因此，<code>arr.filter(Boolean)</code> 会过滤掉数组中的假值元素。</p>
<h2 id="42-js表示极大值和极小值"><a href="#42-js表示极大值和极小值" class="headerlink" title="42 js表示极大值和极小值"></a>42 js表示极大值和极小值</h2><p>在JavaScript中，要表示极大值和极小值，可以使用Number对象的常量属性，分别是<code>Number.MAX_VALUE</code>和<code>Number.MIN_VALUE</code>。</p>
<ul>
<li><code>Number.MAX_VALUE</code>表示JavaScript中的最大数值，约为1.79E+308（即1.79乘以10的308次方）。</li>
<li><code>Number.MIN_VALUE</code>表示JavaScript中的最小正数值，约为5E-324（即5乘以10的负324次方）。</li>
</ul>
<p>需要注意的是，<code>Number.MIN_VALUE</code>表示的是JavaScript中的最小正数值，不是JavaScript中的最小数值。JavaScript中的最小数值是负的最大数值，可以用<code>-Number.MAX_VALUE</code>表示。</p>
<h1 id="over-point"><a href="#over-point" class="headerlink" title="over point"></a>over point</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" class="category-chain-item">前端八股</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/blog/tags/%E8%AE%A1%E7%AE%97/">#计算</a>
      
        <a href="/blog/tags/javascript/">#javascript</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端八股 ｜ js篇2</div>
      <div>https://yoonalis.github.io/blog/2023/04/06/前端八股 ｜js篇2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20%E5%B7%A5%E5%85%B7%E7%AF%87/" title="前端八股 ｜ 工具篇">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前端八股 ｜ 工具篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9Cjs%E7%AF%87/" title="前端八股 ｜ js篇">
                        <span class="hidden-mobile">前端八股 ｜ js篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
