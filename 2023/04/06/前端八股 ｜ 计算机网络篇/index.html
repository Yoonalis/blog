

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端八股">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股 ｜ 计算机网络篇">
<meta property="og:url" content="https://yoonalis.github.io/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="前端八股">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
<meta property="article:published_time" content="2023-04-06T13:30:26.331Z">
<meta property="article:modified_time" content="2023-04-11T08:10:03.698Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="计算">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/coding.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>前端八股 ｜ 计算机网络篇 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端八股 ｜ 计算机网络篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-06 21:30" pubdate>
          2023年4月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          81k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          675 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端八股 ｜ 计算机网络篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前端八股-｜-计算机网络篇"><a href="#前端八股-｜-计算机网络篇" class="headerlink" title="前端八股 ｜ 计算机网络篇"></a>前端八股 ｜ 计算机网络篇</h1><h2 id="1-http和https"><a href="#1-http和https" class="headerlink" title="1 http和https"></a>1 http和https</h2><p>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>
<h3 id="HTTP-原理："><a href="#HTTP-原理：" class="headerlink" title="HTTP 原理："></a>HTTP 原理：</h3><p>①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</p>
<p>②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p>
<p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<h3 id="HTTPS-设计目标："><a href="#HTTPS-设计目标：" class="headerlink" title="HTTPS 设计目标："></a>HTTPS 设计目标：</h3><p>(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p>
<p>(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p>
<p>(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p>
<h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS  的区别"></a>HTTP 与 HTTPS  的区别</h3><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p>
<p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p>
<p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<h3 id="HTTPS-相对于-HTTP-的改进"><a href="#HTTPS-相对于-HTTP-的改进" class="headerlink" title="HTTPS 相对于 HTTP 的改进"></a>HTTPS 相对于 HTTP 的改进</h3><h4 id="双向的身份认证"><a href="#双向的身份认证" class="headerlink" title="双向的身份认证"></a>双向的身份认证</h4><p>客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：</p>
<p>客户端发起 SSL 握手消息给服务端要求连接。</p>
<p>服务端将证书发送给客户端。</p>
<p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p>
<p>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p>
<p>注意：</p>
<p>(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p>
<p>(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<p>(3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<h4 id="数据传输的机密性"><a href="#数据传输的机密性" class="headerlink" title="数据传输的机密性"></a>数据传输的机密性</h4><p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</p>
<h4 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h4><p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p>
<p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p>
<h3 id="HTTPS-的优点"><a href="#HTTPS-的优点" class="headerlink" title="HTTPS 的优点"></a>HTTPS 的优点</h3><p>1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>
<p>2、HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p>
<p>3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<h3 id="HTTPS-的缺点（对比优点）"><a href="#HTTPS-的缺点（对比优点）" class="headerlink" title="HTTPS 的缺点（对比优点）"></a>HTTPS 的缺点（对比优点）</h3><p>1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</p>
<p>2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p>
<p>3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p>
<p>4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</p>
<p>5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p>
<p>6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>
<h3 id="HTTPS-的连接过程"><a href="#HTTPS-的连接过程" class="headerlink" title="HTTPS 的连接过程"></a>HTTPS 的连接过程</h3><p><img src="https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kobejayandy/article/details/52433660%EF%BC%88%E5%9B%BE%E7%89%87%E6%98%AF%E6%88%91%E5%80%9F%E7%94%A8%E8%BF%99%E4%BD%8D%E5%A4%A7%E4%BD%AC%E7%9A%84%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%EF%BC%89">https://blog.csdn.net/kobejayandy/article/details/52433660（图片是我借用这位大佬的，大家可以看看）</a> </p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230321001950665-20230321%2000:19:50.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230321001950665"></p>
<p>图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</p>
<p>① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>
<p>③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p>
<p>④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p>
<p>⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。</p>
<p>⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA  是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p>
<p>⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>
<p>⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>
<p>⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>
<p>⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>
<h2 id="1-1http头部"><a href="#1-1http头部" class="headerlink" title="1.1http头部"></a>1.1http头部</h2><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）头部是HTTP请求和响应的一部分，它包含了关于请求或响应的元数据和其他信息。下面是HTTP头部可能包含的一些字段：</p>
<ol>
<li>Accept：指定客户端可以接受的MIME类型。</li>
<li>Accept-Encoding：指定客户端可以接受的编码格式，如gzip、deflate等。</li>
<li>Accept-Language：指定客户端可以接受的语言类型，如en、zh等。</li>
<li>Authorization：指定客户端的身份验证信息，如用户名和密码。</li>
<li>Cache-Control：指定请求或响应的缓存行为，如no-cache、max-age等。</li>
<li>Connection：指定是否保持连接，如keep-alive、close等。</li>
<li>Content-Encoding：指定响应主体的编码格式，如gzip、deflate等。</li>
<li>Content-Length：指定响应主体的长度。</li>
<li>Content-Type：指定响应主体的MIME类型。</li>
<li>Cookie：指定请求中包含的cookie值。</li>
<li>Host：指定请求的目标主机和端口号。</li>
<li>If-Modified-Since：指定缓存的响应是否已经过期。</li>
<li>Origin：指定请求的来源。</li>
<li>Referer：指定请求的来源页面的URL。</li>
<li>User-Agent：指定客户端使用的用户代理，如浏览器类型和版本号等。</li>
</ol>
<p>需要注意的是，HTTP头部是可扩展的，因此可能包含其他字段。此外，不同的HTTP版本可能支持不同的头部字段。</p>
<h2 id="2-跨域问题为什么会出现，怎么解决"><a href="#2-跨域问题为什么会出现，怎么解决" class="headerlink" title="2 跨域问题为什么会出现，怎么解决"></a>2 跨域问题为什么会出现，怎么解决</h2><h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h3><p>跨域问题其实就是浏览器的同源策略所导致的。</p>
<blockquote>
<p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。–来源 MDN</p>
</blockquote>
<p>当跨域时会收到以下错误</p>
<p><img src="https://pic1.zhimg.com/80/v2-e4a8e0c33d8ce388b29289eb15451bc8_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="2-同源示例"><a href="#2-同源示例" class="headerlink" title="2.同源示例"></a>2.同源示例</h3><p>那么如何才算是同源呢？先来看看 url 的组成部分</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.example.com:<span class="hljs-number">80</span><span class="hljs-regexp">/path/</span>to/myfile.html?key1=value1&amp;key2=value2<span class="hljs-comment">#SomewhereInTheDocument</span><br></code></pre></td></tr></table></figure>



<p><img src="https://pic3.zhimg.com/80/v2-35856fc3d23e7c83ce40a8a110821a0a_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>只有当</p>
<p><strong>protocol（协议）、domain（域名）、port（端口）三者一致。</strong></p>
<p>才是同源。</p>
<p>在默认情况下 http 可以省略端口 80， https 省略 443。这别到时候闹笑话了，你和我说<a href="https://link.zhihu.com/?target=http://www.example.com/">http://www.example.com:80</a>和<a href="https://link.zhihu.com/?target=http://www.example.com/">http://www.example.com</a>不是同源，他俩是一个东西。</p>
<h3 id="3-如何解决跨域问题"><a href="#3-如何解决跨域问题" class="headerlink" title="3.如何解决跨域问题"></a>3.如何解决跨域问题</h3><ol>
<li>CORS跨域 （前端不用动，后端设置Access-Control-Allow-Origin等）</li>
</ol>
<ul>
<li>服务端进行接口请求设置，前端直接调用</li>
<li>说明：后台设置前端某个站点进行访问</li>
</ul>
<p>优点：CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</p>
<p>缺点：对浏览器要求较高，低版本浏览器无法兼容</p>
<ol start="2">
<li>JSONP （动态创建script标签）</li>
</ol>
<ul>
<li><p>JSONP跨域-前端适配，后端配合</p>
</li>
<li><p>前后端同时改造</p>
</li>
</ul>
<p>jsonp原理：img、srcipt，link标签的src或href属性不受同源策略限制，可以用来作为请求，后端接受请求后返回一个回调函数callback，调用前端已经定义好的函数，从而实现跨域请求，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#btn&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>	<span class="hljs-keyword">var</span> frame = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>	frame.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:3000/article-listname=leo&amp;age=30&amp;callback=func&#x27;</span>;<br>	$(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">append</span>(frame);<br>&#125;);<br><br><span class="hljs-comment">// 此为回调函数，其中res为后端返回的数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">res</span>)&#123;<br>	<span class="hljs-title function_">alert</span>(res.<span class="hljs-property">message</span>+res.<span class="hljs-property">name</span>+<span class="hljs-string">&#x27;你已经&#x27;</span>+res.<span class="hljs-property">age</span>+<span class="hljs-string">&#x27;岁了&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中， func 这个回调函数命名，需要前后端沟通一致</p>
<p>优点：简单，兼容性好，可用于解决主流浏览器的跨域数据访问的问题</p>
<p>缺点：仅支持get方法，具有局限性，不安全</p>
<ol start="3">
<li>接口代理</li>
</ol>
<ul>
<li>通过修改nginx服务器配置实现代理转发</li>
<li>前端修改，后端不用</li>
</ul>
<p>前端请求 a 地址，设置nginx服务，将 a 地址代理到 b 地址。</p>
<p>如vue项目中可以在 vue.config.js 中设置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-comment">// 主机地址</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;8000&#x27;</span>, <span class="hljs-comment">// 端口</span><br>	<span class="hljs-attr">proxy</span>: &#123;<br>		<span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>			<span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;xxxxxxxx&#x27;</span>, <span class="hljs-comment">// 真实地址</span><br>			<span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>			<span class="hljs-attr">pathRewrite</span>: &#123;<br>				<span class="hljs-string">&#x27;/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>			&#125;<br>		&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优点：减少网络负荷，节约带宽，实现自动数据分流</p>
<p>缺点：易受攻击</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h3><h4 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1.CORS"></a>1.CORS</h4><p>跨域资源共享(<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">CORS</a>) 是一种机制，它使用额外的<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a>头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器<strong>不同的域、协议或端口</strong>请求一个资源时，资源会发起一个<strong>跨域 HTTP 请求</strong>。</p>
<p>而在 cors 中会有<code>简单请求</code>和<code>复杂请求</code>的概念。</p>
<p><strong>浏览器支持情况</strong></p>
<p>当你使用 IE&lt;&#x3D;9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP 。</p>
<h5 id="a-简单请求"><a href="#a-简单请求" class="headerlink" title="a.简单请求"></a>a.简单请求</h5><p>不会触发<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS%23Preflighted_requests">CORS 预检请求</a>。这样的请求为“简单请求”，请注意，该术语并不属于<a href="https://link.zhihu.com/?target=https://fetch.spec.whatwg.org/">Fetch</a>（其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p>
<p>情况一: 使用以下方法(意思就是以下请求意外的都是非简单请求)</p>
<ul>
<li><code>GET</code></li>
<li><code>HEAD</code></li>
<li><code>POST</code></li>
</ul>
<p>情况二: 人为设置以下集合外的请求头</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code>（需要注意额外的限制）</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
<p>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 application&#x2F;json 为非简单请求)</p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
<p>情况四:</p>
<p>请求中的任意<code>XMLHttpRequestUpload</code>对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code>对象可以使用<code>XMLHttpRequest.upload</code>属性访问。</p>
<p>情况五:</p>
<p>请求中没有使用<code>ReadableStream</code>对象。</p>
<h5 id="b-非简单请求"><a href="#b-非简单请求" class="headerlink" title="b.非简单请求"></a>b.非简单请求</h5><p>除以上情况外的。</p>
<h5 id="c-Node-中的解决方案"><a href="#c-Node-中的解决方案" class="headerlink" title="c.Node 中的解决方案"></a>c.Node 中的解决方案</h5><p>原生方式</p>
<p>我们来看下后端部分的解决方案。<code>Node</code>中<code>CORS</code>的解决代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, ctx.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span>);<br>  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-literal">true</span>);<br>  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Access-Control-Request-Method&quot;</span>, <span class="hljs-string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);<br>  ctx.<span class="hljs-title function_">set</span>(<br>    <span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>,<br>    <span class="hljs-string">&quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span><br>  );<br>  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">method</span> === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    ctx.<span class="hljs-property">status</span> = <span class="hljs-number">204</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>第三方中间件</p>
<p>为了方便也可以直接使用中间件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa-cors&quot;</span>);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());<br></code></pre></td></tr></table></figure>

<p>关于 cors 的 cookie 问题</p>
<p>想要传递<code>cookie</code>需要满足 3 个条件</p>
<p><a href="https://link.zhihu.com/?target=http://1.web/">1.web</a>请求设置<code>withCredentials</code></p>
<p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置<code>withCredentials</code>来进行传递<code>cookie</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原生 xml 的设置方式</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// axios 设置方式</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<p>2.<code>Access-Control-Allow-Credentials</code>为<code>true</code></p>
<p>3.<code>Access-Control-Allow-Origin</code>为非<code>*</code></p>
<p>这里请求的方式，在<code>chrome</code>中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，获取不到返回值。</p>
<p><img src="https://pic4.zhimg.com/80/v2-2f502ce25b1dabe6b80831a78b88788b_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Credentials&#x27; header in the response is &#x27;&#x27; which must be &#x27;true&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.<br></code></pre></td></tr></table></figure>



<p><img src="https://pic1.zhimg.com/80/v2-6f8432e5ea43cc4edbd06571369e0fd0_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Origin&#x27; header in the response must not be the wildcard &#x27;*&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.<br></code></pre></td></tr></table></figure>



<p><img src="https://pic1.zhimg.com/80/v2-497860b4fdd3c923f74df398ba40d1e8_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h5 id="d-前端示例"><a href="#d-前端示例" class="headerlink" title="d.前端示例"></a>d.前端示例</h5><p>分别演示一下前端部分<code>简单请求</code>和<code>非简单请求</code></p>
<p>简单请求</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>非简单请求</p>
<p>这里我们加入了一个非集合内的<code>header</code>头<code>cc</code>来达到非简单请求的目的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>, &#123; <span class="hljs-attr">header</span>: &#123; <span class="hljs-attr">cc</span>: <span class="hljs-string">&quot;xxx&quot;</span> &#125; &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><img src="https://pic3.zhimg.com/80/v2-ed336f9a78ccf4db5928dfff7cea8cca_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-32845b26e1bc9b4c3ff4d0a56f9418e2_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>小结</p>
<p>1、 在新版的 chrome 中，如果你发送了复杂请求，你却看不到<code>options</code>请求。可以在这里设置<code>chrome://flags/#out-of-blink-cors</code>设置成<code>disbale</code>，重启浏览器。对于非简单请求就能看到<code>options</code>请求了。</p>
<p>2、 一般情况下后端接口是不会开启这个跨域头的，除非是一些与用户无关的不太重要的接口。</p>
<h4 id="2-Node-正向代理"><a href="#2-Node-正向代理" class="headerlink" title="2.Node 正向代理"></a>2.Node 正向代理</h4><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。</p>
<p><strong>代理前</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-4115b9417b089c88bbd30a82f99b068f_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><strong>代理后</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-f49ed02d8e60db69c9ced6038364cff2_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>这样，所有的资源以及请求都在一个域名下了。</p>
<h5 id="a-cli-工具中的代理"><a href="#a-cli-工具中的代理" class="headerlink" title="a.cli 工具中的代理"></a>a.cli 工具中的代理</h5><ol>
<li>Webpack (4.x)</li>
</ol>
<p>在<code>webpack</code>中可以配置<code>proxy</code>来快速获得接口代理的能力。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">index</span>: <span class="hljs-string">&quot;./index.js&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>)<br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">8000</span>,<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:8080&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;index.html&quot;</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;webpack.html&quot;</span><br>    &#125;)<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getlist&quot;</span>&gt;</span>获取列表<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  getlist.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/corslist&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  login.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/api/login&quot;</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>Vue-cli 2.x</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// config/index.js</span><br><br>...<br><span class="hljs-attr">proxyTable</span>: &#123;<br>  <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>     <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>,<br>  &#125;<br>&#125;,<br>...<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>Vue-cli 3.x</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">// vue.config.js 如果没有就新建<br>module.exports = &#123;<br>  devServer: &#123;<br>    port: 8000,<br>    proxy: &#123;<br>      &quot;/api&quot;: &#123;<br>        target: &quot;http://localhost:8080&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>Parcel (2.x)</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">// .proxyrc<br>&#123;<br>  &quot;/api&quot;: &#123;<br>    &quot;target&quot;: &quot;http://localhost:8080&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看到这里，心里一句 xxx 就会脱口而出，一会写配置文件，一会 proxyTable ，一会 proxy，怎么这么多的形式？学不动了学不动了。。。不过也不用慌，还是有方法的。以上所有配置都是有着共同的底层包<a href="https://link.zhihu.com/?target=https://github.com/chimurai/http-proxy-middleware">http-proxy-middleware</a>.里面需要用到的各种<code>websocket</code>，<code>rewrite</code>等功能，直接看这个库的配置就可以了。关于 http-proxy-middleware 这个库的原理可以看我这篇文章<a href="https://link.zhihu.com/?target=https://github.com/hua1995116/proxy">https://github.com/hua1995116/proxy</a>当然了。。。对于配置的位置入口还是非统一的。教一个搜索的技巧吧，上面配置写哪里都不用记的，想要哪个框架的 直接 google 搜索 xxx proxy 就行了。</p>
<p>例如 vue-cli 2 proxy 、 webpack proxy 等等….基本会搜到有官网的配置答案，通用且 nice。</p>
<h5 id="b-使用自己的代理工具"><a href="#b-使用自己的代理工具" class="headerlink" title="b.使用自己的代理工具"></a>b.使用自己的代理工具</h5><p><a href="https://link.zhihu.com/?target=https://github.com/Rob--W/cors-anywhere">cors-anywhere</a></p>
<p><strong>服务端</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Listen on a specific host via the HOST environment variable</span><br><span class="hljs-keyword">var</span> host = process.<span class="hljs-property">env</span>.<span class="hljs-property">HOST</span> || <span class="hljs-string">&quot;0.0.0.0&quot;</span>;<br><span class="hljs-comment">// Listen on a specific port via the PORT environment variable</span><br><span class="hljs-keyword">var</span> port = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-number">7777</span>;<br><br><span class="hljs-keyword">var</span> cors_proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cors-anywhere&quot;</span>);<br>cors_proxy<br>  .<span class="hljs-title function_">createServer</span>(&#123;<br>    <span class="hljs-attr">originWhitelist</span>: [], <span class="hljs-comment">// Allow all origins</span><br>    <span class="hljs-attr">requireHeader</span>: [<span class="hljs-string">&quot;origin&quot;</span>, <span class="hljs-string">&quot;x-requested-with&quot;</span>],<br>    <span class="hljs-attr">removeHeaders</span>: [<span class="hljs-string">&quot;cookie&quot;</span>, <span class="hljs-string">&quot;cookie2&quot;</span>]<br>  &#125;)<br>  .<span class="hljs-title function_">listen</span>(port, host, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Running CORS Anywhere on &quot;</span> + host + <span class="hljs-string">&quot;:&quot;</span> + port);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>前端代码</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  getlist.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios</span><br><span class="language-javascript">      .<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/corslist&quot;</span>)</span><br><span class="language-javascript">      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  login.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/login&quot;</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>效果展示</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-09348a1894e52435fb0128c73b255080_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><strong>缺点</strong></p>
<p>无法专递 cookie，原因是因为这个是一个代理库，作者觉得中间传递 cookie 太不安全了。<a href="https://link.zhihu.com/?target=https://github.com/Rob--W/cors-anywhere/issues/208%23issuecomment-575254153">https://github.com/Rob--W/cors-anywhere/issues/208#issuecomment-575254153</a></p>
<h5 id="c-charles"><a href="#c-charles" class="headerlink" title="c.charles"></a>c.charles</h5><p>介绍</p>
<p>这是一个测试、开发的神器。<a href="https://link.zhihu.com/?target=https://juejin.im/post/5b8350b96fb9a019d9246c4c">介绍与使用</a></p>
<p>利用 charles 进行跨域，本质就是请求的拦截与代理。</p>
<p>在<code>tools/map remote</code>中设置代理</p>
<p><img src="https://pic1.zhimg.com/80/v2-5f038f5e5c14e937644dba2a8ebc8dcc_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-267e54aa34171ea4da5bcc30ee5c3199_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>前端代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getlist&quot;</span>&gt;</span>获取列表<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  getlist.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/corslist&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  login.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/api/login&quot;</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>后端代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/corslist&quot;</span>, <span class="hljs-keyword">async</span> ctx =&gt; &#123;<br>  ctx.<span class="hljs-property">body</span> = &#123;<br>    <span class="hljs-attr">data</span>: [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;秋风的笔记&quot;</span> &#125;]<br>  &#125;;<br>&#125;);<br><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/api/login&quot;</span>, <span class="hljs-keyword">async</span> ctx =&gt; &#123;<br>  ctx.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;token&quot;</span>, token, &#123;<br>    <span class="hljs-attr">expires</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>)<br>  &#125;);<br>  ctx.<span class="hljs-property">body</span> = &#123;<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;成功&quot;</span>,<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span><br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>效果</p>
<p>访问<a href="https://link.zhihu.com/?target=http://localhost:8000/charles">http://localhost:8000/charles</a></p>
<p><img src="https://pic2.zhimg.com/80/v2-24ef706ad0f8e9cbbc1e734185281345_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-53d70c5c98ec2c33c7d47735dd42e759_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>完美解决。</p>
<p>唔。这里又有一个注意点。在<code>Mac mojave 10.14</code>中会出现<code>charles</code>抓不到本地包的情况。这个时候需要自定义一个域名，然后配置<code>hosts</code>指定到<code>127.0.0.1</code>。然后修改访问方式<code>http://localhost.charlesproxy.com:8000/charles</code>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-602cf3cb7e5578499ac29d4f883f66a9_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-68dd01b26dbf276c5b9224e1d08438c8_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="3-Nginx-反向代理"><a href="#3-Nginx-反向代理" class="headerlink" title="3.Nginx 反向代理"></a>3.Nginx 反向代理</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。<a href="https://link.zhihu.com/?target=https://blog.csdn.net/diaojw090/article/details/89135073">nginx 安装教程</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-42205e6dc00ecc37f255944dc6eb1fec_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>配置下 hosts</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> local.test<br></code></pre></td></tr></table></figure>

<p>配置 nginx</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">server &#123;<br>        listen 80;<br>        server_name local.test;<br>        location /api &#123;<br>            proxy_pass http://localhost:8080;<br>        &#125;<br>        location / &#123;<br>            proxy_pass http://localhost:8000;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动 nginx</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo nginx</span><br></code></pre></td></tr></table></figure>

<p>重启 nginx</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo nginx -s reload</span><br></code></pre></td></tr></table></figure>

<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>前端代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  getlist.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/corslist&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  login.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/api/login&quot;</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>后端代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/corslist&quot;</span>, <span class="hljs-keyword">async</span> ctx =&gt; &#123;<br>  ctx.<span class="hljs-property">body</span> = &#123;<br>    <span class="hljs-attr">data</span>: [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;秋风的笔记&quot;</span> &#125;]<br>  &#125;;<br>&#125;);<br><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/api/login&quot;</span>, <span class="hljs-keyword">async</span> ctx =&gt; &#123;<br>  ctx.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;token&quot;</span>, token, &#123;<br>    <span class="hljs-attr">expires</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>)<br>  &#125;);<br>  ctx.<span class="hljs-property">body</span> = &#123;<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;成功&quot;</span>,<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span><br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>访问<code>http://local.test/charles</code></p>
<p>浏览器显示</p>
<p><img src="https://pic1.zhimg.com/80/v2-e5983404b78f69973f3fbfc0d2f105f0_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="4-JSONP"><a href="#4-JSONP" class="headerlink" title="4.JSONP"></a>4.JSONP</h4><p><code>JSONP</code>主要就是利用了<code>script</code>标签没有跨域限制的这个特性来完成的。</p>
<p><strong>使用限制</strong></p>
<p>仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。</p>
<p><strong>流程解析</strong></p>
<p>1.前端定义解析函数（例如 jsonpCallback&#x3D;function(){….}）</p>
<p>2.通过 params 形式包装请求参数，并且声明执行函数(例如 cb&#x3D;jsonpCallback)</p>
<p>3.后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。</p>
<p><strong>使用示例</strong></p>
<p>后端实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">path</span> === <span class="hljs-string">&quot;/api/jsonp&quot;</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; cb, msg &#125; = ctx.<span class="hljs-property">query</span>;<br>    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;cb&#125;</span>(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(&#123; msg &#125;)&#125;</span>)`</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure>

<p>普通 js 示例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">jsonpCallback</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span></span><br><span class="hljs-tag">  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>JQuery Ajax 示例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  $.<span class="hljs-title function_">ajax</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:8080/api/jsonp&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;jsonp&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;get&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;hello&quot;</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&quot;cb&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>原理解析</strong></p>
<p>其实这就是 js 的魔法</p>
<p>我们先来看最简单的 js 调用。嗯，很自然的调用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">jsonpCallback</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>  jsonpCallback(&#123; a: 1 &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们稍稍改造一下，外链的形式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">jsonpCallback</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/api/a.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// http://localhost:8080/api/a.js jsonpCallback(&#123;a:1&#125;);<br></code></pre></td></tr></table></figure>

<p>我们再改造一下，我们把这个外链的 js 就当做是一个动态的接口，因为本身资源和接口一样，是一个请求，也包含各种参数，也可以动态化返回。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">jsonpCallback</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/api/a.js?a=123&amp;cb=sonpCallback&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// http://localhost:8080/api/a.js jsonpCallback(&#123;a:123&#125;);<br></code></pre></td></tr></table></figure>

<p>你仔细品，细细品，是不是 jsonp 有的优势就是 script 加载 js 的优势，加载的方式只不过换了一种说法。这也告诉我们一个道理，很多东西并没有那么神奇，是在你所学的知识范围内。就好比，桃树和柳树，如果你把他们当成很大跨度的东西去记忆理解，那么世上这么多树，你真的要累死了，你把他们都当成是树，哦吼？你会突然发现，你对世界上所有的树都有所了解，他们都会长叶子，光合作用….当然也有个例，但是你只需要去记忆这些细微的差别，抓住主干。。。嗯，反正就这么个道理。</p>
<h4 id="5-Websocket"><a href="#5-Websocket" class="headerlink" title="5.Websocket"></a>5.Websocket</h4><p><a href="https://link.zhihu.com/?target=http://dev.w3.org/html5/websockets/">WebSocket</a>规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。详细教程可以看<a href="https://link.zhihu.com/?target=https://www.html5rocks.com/zh/tutorials/websockets/basics/">https://www.html5rocks.com/zh/tutorials/websockets/basics/</a></p>
<p>这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制，没有什么过多的解释直接上代码吧。</p>
<p>前端部分</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);</span><br><span class="language-javascript">  socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;秋风的笔记&quot;</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>后端部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> &#125;);<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>) &#123;<br>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br>    socket.<span class="hljs-title function_">send</span>(data);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="6-window-postMessage"><a href="#6-window-postMessage" class="headerlink" title="6.window.postMessage"></a>6.window.postMessage</h4><p>**window.postMessage()<strong>方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数<code>Document.domain</code>设置为相同的值) 时，这两个脚本才能相互通信。</strong>window.postMessage()**方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p>
<p>用途</p>
<p>1.页面和其打开的新窗口的数据传递</p>
<p>2.多窗口之间消息传递</p>
<p>3.页面与嵌套的 iframe 消息传递</p>
<p>用法</p>
<p>详细用法看<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">otherWindow.post<span class="hljs-constructor">Message(<span class="hljs-params">message</span>, <span class="hljs-params">targetOrigin</span>, [<span class="hljs-params">transfer</span>])</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>otherWindow: 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/DOM/window.open">window.open</a>返回的窗口对象、或者是命名过或数值索引的<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/DOM/window.frames">window.frames</a>。</li>
<li>message: 将要发送到其他 window 的数据。</li>
<li>targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件.</li>
<li>transfer(可选) : 是一串和 message 同时传递的<code>Transferable</code>对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</li>
</ul>
<p>示例</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span></span><br><span class="hljs-tag">  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;秋风的笔记&quot;</span>, <span class="hljs-string">&quot;http://localhost:8080&quot;</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>another.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>); <span class="hljs-comment">// 秋风的笔记</span></span><br><span class="language-javascript">    e.<span class="hljs-property">source</span>.<span class="hljs-title function_">postMessage</span>(e.<span class="hljs-property">data</span>, e.<span class="hljs-property">origin</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="7-document-domain-Iframe"><a href="#7-document-domain-Iframe" class="headerlink" title="7.document.domain + Iframe"></a>7.document.domain + Iframe</h4><p>从第 7 种到第 9 种方式，我觉得别人的写的已经很好了，为了完整性，我就拿别人的了。如有雷同….（不对，就是雷同….）不要说不出来。</p>
<p><strong>该方式只能用于二级域名相同的情况下，比如<code>a.test.com</code>和<code>b.test.com</code>适用于该方式</strong>。 只需要给页面添加<code>document.domain =&#39;test.com&#39;</code>表示二级域名都相同就可以实现跨域。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">www.   baidu.  com     .<br>三级域  二级域   顶级域   根域<br>// a.test.com<br>&lt;body&gt;<br>  helloa<br>  &lt;iframe<br>    src=<span class="hljs-string">&quot;http://b.test.com/b.html&quot;</span><br>    frameborder=<span class="hljs-string">&quot;0&quot;</span><br>    onload=<span class="hljs-string">&quot;load()&quot;</span><br>    <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;frame&quot;</span><br>  &gt;&lt;/iframe&gt;<br>  &lt;script&gt;<br>    document.domain = <span class="hljs-string">&quot;test.com&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">load</span></span>() &#123;<br>      console.log(frame.contentWindow.a);<br>    &#125;<br>  &lt;/script&gt;<br>&lt;/body&gt;<br>// b.test.com<br>&lt;body&gt;<br>  hellob<br>  &lt;script&gt;<br>    document.domain = <span class="hljs-string">&quot;test.com&quot;</span>;<br>    var a = 100;<br>  &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h4 id="8-window-location-hash-Iframe"><a href="#8-window-location-hash-Iframe" class="headerlink" title="8.window.location.hash + Iframe"></a>8.window.location.hash + Iframe</h4><p>实现原理</p>
<p>原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。</p>
<p>实现流程</p>
<p>一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 同样的，a.html 和 b.htm l 是同域的，都是<code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">// a.html<br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/hash/c.html#name1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>// b.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span> = location.<span class="hljs-property">hash</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>// c.html<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;iframe&quot;</span>);</span><br><span class="language-javascript">  iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://localhost:8000/hash/b.html#name2&quot;</span>;</span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="9-window-name-Iframe"><a href="#9-window-name-Iframe" class="headerlink" title="9.window.name+ Iframe"></a>9.window.name+ Iframe</h4><p>window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变。</p>
<p>其中 a.html 和 b.html 是同域的，都是<code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html">// a.html<br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span></span><br><span class="hljs-tag">  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/name/c.html&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> first = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (first) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="language-javascript">      iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://localhost:8000/name/b.html&quot;</span>;</span><br><span class="language-javascript">      first = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">name</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>b.html 为中间代理页，与 a.html 同域，内容为空。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">// b.html<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>// c.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;秋风的笔记&quot;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的<a href="https://link.zhihu.com/?target=http://window.name/">window.name</a>从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="10-浏览器开启跨域（终极方案）"><a href="#10-浏览器开启跨域（终极方案）" class="headerlink" title="10.浏览器开启跨域（终极方案）"></a>10.浏览器开启跨域（终极方案）</h4><p>其实讲下其实跨域问题是浏览器策略，源头是他，那么能否能关闭这个功能呢？</p>
<p>答案是肯定的。</p>
<p><strong>注意事项: 因为浏览器是众多 web 页面入口。我们是否也可以像客户端那种，就是用一个单独的专门宿主浏览器，来打开调试我们的开发页面。例如这里以 chrome canary 为例，这个是我专门调试页面的浏览器，不会用它来访问其他 web url。因此它也相对于安全一些。当然这个方式，只限于当你真的被跨域折磨地崩溃的时候才建议使用以下。使用后，请以正常的方式将他打开，以免你不小心用这个模式干了其他的事。</strong></p>
<p>Windows</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">找到你安装的目录<br>.\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=xxxx<br></code></pre></td></tr></table></figure>

<p>Mac</p>
<p><code>~/Downloads/chrome-data</code>这个目录可以自定义.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary  --disable-web-security --user-data-dir=~/Downloads/chrome-data<br></code></pre></td></tr></table></figure>

<p>效果展示</p>
<p><img src="https://pic2.zhimg.com/80/v2-d7f6c1f0a1132cd0b2872087dc1d96e1_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>嗯，使用起来很香，但是再次提醒，一般情况千万别轻易使用这个方式，这个方式好比七伤拳，使用的好威力无比，使用不好，很容易伤到自己。</p>
<h2 id="3-常用状态码-amp-请求头-amp-响应头-amp-Cookies及请求方法合集"><a href="#3-常用状态码-amp-请求头-amp-响应头-amp-Cookies及请求方法合集" class="headerlink" title="3 常用状态码&amp;请求头&amp;响应头&amp;Cookies及请求方法合集"></a>3 常用状态码&amp;请求头&amp;响应头&amp;Cookies及请求方法合集</h2><h3 id="HTTP和HTTPS的区别图解"><a href="#HTTP和HTTPS的区别图解" class="headerlink" title="HTTP和HTTPS的区别图解"></a>HTTP和HTTPS的区别图解</h3><p>HTTPS和HTTP相比多了一层加密</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3687ac32cfd4d5191c0cb1e99df44e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002153855635"></p>
<h3 id="HTTP的缓存"><a href="#HTTP的缓存" class="headerlink" title="HTTP的缓存"></a>HTTP的缓存</h3><p>HTTP缓存处理流程</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae548403c531494381177b51fca77ff1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20210920225414298"></p>
<h4 id="1-什么是缓存？"><a href="#1-什么是缓存？" class="headerlink" title="1. 什么是缓存？"></a>1. 什么是缓存？</h4><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力</p>
<p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。</p>
<p>HTTP 1.0协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取。</p>
<blockquote>
<p>另：</p>
</blockquote>
<ul>
<li>Expires因为是对时间设定的，且时间是Greenwich Mean Time （GMT），而不是本地时间，所以对时间要求较高。</li>
</ul>
<h4 id="2-浏览器是如何判断是否使用缓存的"><a href="#2-浏览器是如何判断是否使用缓存的" class="headerlink" title="2. 浏览器是如何判断是否使用缓存的"></a>2. 浏览器是如何判断是否使用缓存的</h4><p>第一次请求：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bbc2df77f4f6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>第二次请求相同网页：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bbaefa56810f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="3-缓存的类别"><a href="#3-缓存的类别" class="headerlink" title="3. 缓存的类别"></a>3. 缓存的类别</h4><p>浏览器缓存分为强缓存和协商缓存</p>
<h5 id="强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status-Code-200-OK"><a href="#强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status-Code-200-OK" class="headerlink" title="强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK"></a>强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bc0c7e54f6ec~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bdbc4b9c8720~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>200 form memory cache : 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</p>
</blockquote>
<blockquote>
<p>200 from disk cache： 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</p>
</blockquote>
<blockquote>
<p>优先访问memory cache,其次是disk cache，最后是请求网络资源</p>
</blockquote>
<h5 id="协商缓存-向服务器发送请求，服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源；"><a href="#协商缓存-向服务器发送请求，服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源；" class="headerlink" title="协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；"></a>协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bc3172e3a167~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="4-强缓存和协商缓存的header参数"><a href="#4-强缓存和协商缓存的header参数" class="headerlink" title="4. 强缓存和协商缓存的header参数"></a>4. 强缓存和协商缓存的header参数</h4><p><strong>强缓存：</strong></p>
<p>Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求</p>
<p>Cache-Control：当值设为max-age&#x3D;300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
<p>cache-control：除了该字段外，还有下面几个比较常用的设置值：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；<br>（<span class="hljs-number">2</span>） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；<br>（<span class="hljs-number">3</span>）<span class="hljs-built_in">public</span>：指示响应可被任何缓存区缓存；<br>（<span class="hljs-number">4</span>）private：只能针对个人用户，而不能被代理服务器缓存；<br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回<span class="hljs-number">304</span>，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上<span class="hljs-keyword">Cache</span>-Control:     no-<span class="hljs-keyword">cache</span>是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。<br>（<span class="hljs-number">6</span>）<span class="hljs-keyword">no</span>-store：禁止一切缓存（这个才是响应不被缓存的意思）。复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>cache-control是http1.1的头字段，expires是http1.0的头字段,如果expires和cache-control同时存在，cache-control会覆盖expires，建议两个都写。</p>
</blockquote>
<p><strong>协商缓存：</strong></p>
<p>Last-Modifed&#x2F;If-Modified-Since和Etag&#x2F;If-None-Match是分别成对出现的，呈一一对应关系</p>
<h5 id="Etag-x2F-If-None-Match："><a href="#Etag-x2F-If-None-Match：" class="headerlink" title="Etag&#x2F;If-None-Match："></a>Etag&#x2F;If-None-Match：</h5><p>Etag：</p>
<blockquote>
<p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p>
</blockquote>
<p>If-None-Match:</p>
<blockquote>
<p>当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304</p>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8c60fb0ef49f0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><h5 id="Last-Modifed-x2F-If-Modified-Since："><a href="#Last-Modifed-x2F-If-Modified-Since：" class="headerlink" title="Last-Modifed&#x2F;If-Modified-Since："></a>Last-Modifed&#x2F;If-Modified-Since：</h5><p>Last-Modified：</p>
<blockquote>
<p>浏览器向服务器发送资源最后的修改时间</p>
</blockquote>
<p>If-Modified-Since：</p>
<blockquote>
<p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。</p>
</blockquote>
<blockquote>
<ul>
<li>Last-Modifed&#x2F;If-Modified-Since的时间精度是秒，而Etag可以更精确。</li>
<li>Etag优先级是高于Last-Modifed的，所以服务器会优先验证Etag</li>
<li>Last-Modifed&#x2F;If-Modified-Since是http1.0的头字段</li>
</ul>
</blockquote>
<p><strong>Expires</strong> ：时间不准</p>
<p><strong>Cache- Control的值有</strong></p>
<ul>
<li><strong>max-age</strong> :单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>
<li><strong>no-cache</strong> :不使用强缓存，需要与服务器验证缓存是否新鲜</li>
<li><strong>no-store</strong> :禁止使用缓存(包括协商缓存)每次都向服务器请求最新的资源</li>
<li><strong>must-revalidate</strong> :在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>ETag&#x2F;lf-None-Match</strong>,：hash 码，代表的是一个资源的标识符</p>
<p><strong>Last- Modified&#x2F;lf- Modified-Since</strong>：文件的最后修改时间</p>
<h3 id="HTTP的常用状态码"><a href="#HTTP的常用状态码" class="headerlink" title="HTTP的常用状态码"></a>HTTP的常用状态码</h3><p><strong>200</strong>	 ：OK，客户端请求成功</p>
<p><strong>301</strong> ：资源(网页等)被永久转移到其它URL</p>
<p><strong>302</strong> ：临时跳转</p>
<p><strong>401</strong>	 ：Unauthorized -请求未经授权</p>
<p><strong>404</strong>  ：请求资源不存在，可能是输入了错误的URL</p>
<p><strong>500</strong>  ：服务器内部发生了不可预期的错误</p>
<p><strong>504</strong>  ： Gateway Timeout-网关或者代理的服务器无法在规定的时间内获得想要的响应。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddc22d21b8684815908eddc6831c32b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20210920192949824"></p>
<h3 id="HTTP常用请求头（Request-Headers）"><a href="#HTTP常用请求头（Request-Headers）" class="headerlink" title="HTTP常用请求头（Request Headers）"></a>HTTP常用请求头（Request Headers）</h3><p><strong>Accept</strong>： 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd96c4225f594de0acdb374c2d7de3bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161729473"></p>
<p><strong>Content-Type</strong>： 客户端发送出去实体内容的类型</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/262ac1dda217486a9ac9e32cd46320f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161801679"></p>
<p><strong>Cache-Control</strong>： 指定请求和响应遵循的缓存机制，如no-cache</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c71a74455c2493c985e9efa5fb11117~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002163255317"></p>
<p><strong>If-Modified-Since</strong>： 对应服务端的<code>Last-Modified</code>,用来匹配看文件是否变动，只能精确到1s之内</p>
<p><strong>Expires</strong>： 缓存控制，在这个时间内不会请求，直接使用缓存，服务端时间</p>
<p><strong>Max-age</strong>： 代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存</p>
<p><strong>If-None-Match</strong>： 对应服务端的ETag,用来匹配文件内容是否改变（非常精确）</p>
<p><strong>Cookie</strong>： 有cookie并且<strong>同域</strong>访问时会自动带上</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/523692dd113c49c18c56cbec1dc54b53~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002155443610"></p>
<p><strong>Referer</strong>： 该页面的来源URL（适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b44922d5149c4c1fb361c12a6009d605~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161835593"></p>
<p><strong>Origin</strong>： 最初的请求是从哪里发起的（只会精确到端口)）,Origin比Referer更尊重隐私</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97abc0d0bf3f4a6db0f6b66d2f0b0198~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161858626"></p>
<p><strong>User-Agent</strong>： 用户客户端的一些必要信息，如UA头部等</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fd3a146500c48a78ab0738bc707cd01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002155948600"></p>
<h3 id="HTTP常用响应头（Response-Headers）"><a href="#HTTP常用响应头（Response-Headers）" class="headerlink" title="HTTP常用响应头（Response Headers）"></a>HTTP常用响应头（Response Headers）</h3><p><strong>Content-Type</strong>： 服务端返回的实体内容的类型</p>
<p><strong>Cache-Control</strong>： 指定请求和响应遵循的缓存机制，如no-cache</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/795a8b82a5d645f98ed827646526fde0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002163336562"></p>
<p><strong>Last-Modified</strong>：</p>
<p>请求资源的最后修改时间</p>
<p><strong>Expires</strong>： 应该在什么时候认为文档已经过期，从而不再缓存它</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a14b1d358f3045f081d34a41cfa6aa18~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002163349623"></p>
<p><strong>Max-age</strong>： 客户端的本地资源应该缓存多少秒，开启了	Cache-Control	后有效</p>
<p><strong>ETag</strong>： 资源的特定版本的标识符，<code>Etags</code>类似于指纹</p>
<p><strong>Set-Cookie</strong>： 设置和页面关联的cookie,服务器通过这个头部把cookie传给客户端</p>
<p><strong>Server</strong>： 服务器的一些相关信息</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1724879a9bc24812b024b9610539009b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002160637134"></p>
<p><strong>Access-Control-Allow-Origin</strong>： 服务器端允许的请求Origin头部(譬如为*)</p>
<h3 id="HTTP的各类请求方法"><a href="#HTTP的各类请求方法" class="headerlink" title="HTTP的各类请求方法"></a>HTTP的各类请求方法</h3><p><strong>GET</strong>：</p>
<p>请求一个指定资源的表示形式.使用GET的请求应该只被用于获取数据</p>
<p><strong>POST</strong>：</p>
<p>用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</p>
<p><strong>PUT</strong>：</p>
<p>用请求有效载荷替换目标资源的所有当前表示</p>
<p><strong>DELETE</strong>：</p>
<p>删除指定的资源</p>
<p><strong>HEAD</strong>：</p>
<p>请求一个与GET请求的响应相同的响应，但没有响应体</p>
<p><strong>CONNECT</strong>：</p>
<p>建立一个到由目标资源标识的服务器的隧道。</p>
<p><strong>OPTIONS</strong>：</p>
<p>用于描述目标资源的通信选项。</p>
<p><strong>TRACE</strong>：</p>
<p>沿着到目标资源的路径执行一个消息环回测试。</p>
<p><strong>PATCH</strong>：</p>
<p>用于对资源应用部分修改。</p>
<h3 id="视频直播协议"><a href="#视频直播协议" class="headerlink" title="视频直播协议"></a>视频直播协议</h3><table>
<thead>
<tr>
<th>协议</th>
<th>描述</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>HLS</td>
<td>1、HTTP Live Streaming, Apple公司 2、基于HTTP协议 3、把一段视频流，分成一个个小的基于HTTP的文件来下载</td>
<td>跨平台</td>
</tr>
<tr>
<td>RTMP</td>
<td>1、Real Time Messaging Protocol 2、Adobe公司 3、基于TCP</td>
<td>时延低</td>
</tr>
<tr>
<td>HTTP - FLV</td>
<td>1、基于HTTP 2、http+flv，将音视频数据封装成FLV格式，然后通过HTTP协议传输给客户端</td>
<td>时延低</td>
</tr>
</tbody></table>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Set-Cookie - response</p>
<table>
<thead>
<tr>
<th>Name&#x3D;value</th>
<th>各种cookie的名称和值</th>
</tr>
</thead>
<tbody><tr>
<td>Expires&#x3D;Date</td>
<td>Cookie的有效期，缺省时Cookie仅在浏览器关闭之前有效。</td>
</tr>
<tr>
<td>Path&#x3D; Path</td>
<td>限制指定Cookie的发送范围的文件目录，默认为当前</td>
</tr>
<tr>
<td>Domain&#x3D;domain</td>
<td>限制cookie生效的域名，默认为创建cookie的服务域名</td>
</tr>
<tr>
<td>secure</td>
<td>仅在HTTPS安全连接时，才可以发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>JavaScript脚本无法获得Cookie</td>
</tr>
<tr>
<td><code>SameSite=[None/Strict/Lax]</code></td>
<td>- None同站、跨站请求都可发送 - Strict仅在同站发送 - 允许与顶级导航一起发送，并将与第三方网站发起的GET请求一起发送</td>
</tr>
</tbody></table>
<h2 id="4-GET和POST的区别"><a href="#4-GET和POST的区别" class="headerlink" title="4 GET和POST的区别"></a>4 GET和POST的区别</h2><p>get 参数通过 url 传递，post 放在 request body 中。</p>
<p>get 请求在url 中传递的参数是有长度限制的，而 post 没有。 </p>
<p>get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。</p>
<p>get 请求只能进行url 编码，而 post 支持多种编码方式</p>
<p>get 请求会浏览器主动 cache，而 post 支持多种编码方式。 </p>
<p>get 请求参数会被完整保留在浏览历史记录里，而post 中的参数不会被保留。</p>
<p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器&#x2F;服务器 的限制，导致他们在应用过程中体现出一些不同。 </p>
<p>GET产生一个TCP数据包；POST 产生两个TCP数据包。（对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<h2 id="5-在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？"><a href="#5-在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？" class="headerlink" title="5 在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？"></a>5 在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？</h2><p>输入 url 后，首先需要找到这个 url 域名的服务器 ip。</p>
<p>为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存，</p>
<p>缓存中没有则查找系统的 hosts 文件中是否有记录，</p>
<p>如果没有则查询 DNS 服务器，</p>
<p>得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一 个 http 请求 ，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据 ，并将这个 http 请求封装在一个 tcp 包中，这个 tcp 包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，</p>
<p>因为 html 是一个树形结构，浏览器根据这个html 来构建 DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码 ，这会造成阻塞，这就是为什么推荐 JS 代码应该放在html 代码的后面，之后根据外部样式，内部样式，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如 script，meta 标签和排除 display 为none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等 资源 ，在解析 DOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，</p>
<p>当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过 Cache-Control、Last-Modify、Expires 等首部字段控制。 Cache- Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求 这些有设置了缓存的数据时，会先查看是否过期，如果没有过期则直接使用本地缓 存，过期则请求并在服务器校验文件是否修改，如果上一次响应设置了 ETag 值会在 这次请求的时候作为 If-None-Match 的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。</p>
<h2 id="6-http2-0的特性"><a href="#6-http2-0的特性" class="headerlink" title="6 http2.0的特性"></a>6 http2.0的特性</h2><p>http2.0 的特性如下： </p>
<p>1、内容安全，因为http2.0是基于https 的，天然具有安全特性，通过 http2.0 的特性可以避免单纯使用https的性能下降 </p>
<p>2、二进制格式，http1.X 的解析是基于文本的，http2.0 将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展 性，比如引入了帧来传输数据和指令 </p>
<p>3、多路复用，这个功能相当于是长连接的增强，每个 request 请求可以随机的混杂在 一起，接收方可以根据request 的id将request 再归属到各自不同的服务端请求里 面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输。</p>
<h2 id="7-csrf和xss网络攻击及防范"><a href="#7-csrf和xss网络攻击及防范" class="headerlink" title="7 csrf和xss网络攻击及防范"></a>7 csrf和xss网络攻击及防范</h2><p>CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了 恶 意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用 来制 造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候 CSRF 就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是 可 以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的 话：使用验证码，检查 https 头部的 refer，使用 token </p>
<p>XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行 攻 击，比如获取 cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型 是 攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反 射 型的话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中，防御 的话为 cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。</p>
<p>XSS 防御的总体思路是：对输入(和 URL 参数)进行过滤，对输出进行编码。也就是对提 交的所有内容进行过滤，对 url 中的参数进行过滤，过滤掉会导致脚本执行的相关内 容 ；然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。虽然 对 输入过滤可以被绕过，但是也还是会拦截很大一部分的 XSS 攻击。 </p>
<p>防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并 验证；在 HTTP 头中自定义属性并验证。</p>
<h2 id="8-浏览器解析怎么解析html"><a href="#8-浏览器解析怎么解析html" class="headerlink" title="8 浏览器解析怎么解析html"></a>8 浏览器解析怎么解析html</h2><p>当我们在浏览器地址栏输入一个合法的<code>url</code>时，浏览器首先进行<code>DNS</code>域名解析，拿到服务器IP地址后，浏览器给服务器发送<code>GET</code>请求，等到服务器正常返回后浏览器开始下载并解析<code>html</code>。这里仅总结浏览器解析html的过程。</p>
<p><code>html</code>页面主要由<code>dom</code>、<code>css</code>、<code>javascript</code>等部分构成，其中<code>css</code>和<code>javascript</code>既能<code>内联</code>也能以<code>脚本</code>的形式引入，当然<code>html</code>中还可能引入<code>img</code>、<code>iframe</code>等其他资源。其实所有的这些资源也是以<code>dom</code>标签的形式嵌入在<code>html</code>页面中的，因此本篇总结说的<code>html</code>解析过程就是<code>dom</code>的解析过程。</p>
<h3 id="1-dom解析过程"><a href="#1-dom解析过程" class="headerlink" title="1 dom解析过程"></a>1 <code>dom</code>解析过程</h3><p>整个<code>dom</code>的解析过程是<code>顺序</code>，并且<code>渐进式</code>的。</p>
<p><code>顺序</code>指的是从第一行开始，一行一行依次解析；<code>渐进式</code>则指得是浏览器会迫不及待的将解析完成的部分显示出来，如果我们做下面这个实验会发现，在<code>断点</code>处第一个<code>div</code>已经在浏览器渲染出来了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        first div<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">debugger</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        second div<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>既然<code>dom</code>是从第一行按顺序解析，那么我们怎么判断<code>dom</code>何时解析完成呢？这个问题应该经常会在面试中问到，比如一般会问：</p>
<blockquote>
<p><code>window.onload</code>和<code>DOMContentLoaded</code>有什么区别？</p>
</blockquote>
<p>其实就是想看看是不是明白<code>dom树</code>何时构建完成，这个问题确实很重要，尤其是对于几年前的<code>jquery</code>技术栈来说，因为我们使用<code>javascript</code>操作<code>dom</code>或者给<code>dom</code>绑定事件有个前提条件就是需要<code>dom树</code>已经创建完成。整个<code>html</code>页面的<code>dom</code>解析完成时，<code>dom树</code>也就构建完成了。dom树构建完成后<code>document</code>对象会派发事件<code>DOMContentLoaded</code>来通知<code>dom树</code>已构建完成。</p>
<p><code>html</code>从第一行开始解析，遇到<code>外联</code>资源(<code>外联css</code>、<code>外联javascript</code>、<code>image</code>、<code>iframe</code>等)就会请求对应资源，那么请求过程是否会阻塞<code>dom</code>的解析过程呢？答案是看情况，有的资源会，有的资源不会。下面按是否会阻塞页面解析分为两类：<code>阻塞型</code>与<code>非阻塞型</code>，注意这里区分两类资源的标志是<code>document</code>对象派发<code>DOMContentLoaded</code>事件的时间点，认为派发<code>DOMContentLoaded</code>事件才表示<code>dom树</code>构建完成。</p>
<h5 id="1-1-阻塞型"><a href="#1-1-阻塞型" class="headerlink" title="1.1 阻塞型"></a>1.1 阻塞型</h5><p>会阻塞<code>dom</code>解析的资源主要包括：</p>
<ul>
<li>内联css</li>
<li>内联javascript</li>
<li>外联普通javascript</li>
<li>外联defer javascript</li>
<li>javascript标签之前的外联css</li>
</ul>
<p>外联<code>javascript</code>可以用<code>async</code>与<code>defer</code>标示，因此这里分为了三类：<code>外联普通javascript</code>，<code>外联defer javascript</code>、<code>外联async javascript</code>，这几类外联<code>javascript</code>本篇后面有详细介绍。 <code>dom</code>解析过程中遇到<code>外联普通javascript</code>会暂停解析，请求拿到<code>javascript</code>并执行，然后继续解析<code>dom树</code>。</p>
<p>对于<code>外联defer javascript</code>这里重点说明下为什么也归于<code>阻塞型</code>。前面也说了，这里以<code>document</code>对象派发<code>DOMContentLoaded</code>事件来标识<code>dom树</code>构建完成，而<code>defer javascript</code>是在该事件派发之前请求并执行的，因此也归类于阻塞型，但是需要知道，<code>defer</code>的<code>javascript</code>实际上是在<code>dom树</code>构建完成与派发<code>DOMContentLoaded</code>事件之间请求并执行的，不过如果换个思路理解，<code>&lt;script&gt;</code>本身也是<code>dom</code>的一部分也就不难理解为什么<code>defer</code>的<code>javascript</code>会在<code>DOMContentLoaded</code>派发之前执行了。</p>
<p>另外需要注意的是<code>javascript标签之前的外联css</code>。其实按说<code>css</code>资源是不应该阻塞<code>dom树</code>的构建过程的，毕竟<code>css</code>只影响<code>dom</code>样式，不影响<code>dom</code>结构，<code>MDN</code>上也是这么解释的：</p>
<blockquote>
<p>The <strong><code>DOMContentLoaded</code></strong> event is fired when the initial HTML document has been completely loaded and parsed, without waiting for <strong><code>stylesheets</code></strong>, images, and subframes to finish loading.</p>
</blockquote>
<p>但是实际情况是<code>dom树</code>的构建受<code>javascript</code>的阻塞，而<code>javascript</code>执行时又可能会使用类似<code>Window.getComputedStyle()</code>之类的API来获取<code>dom</code>样式，比如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">para</span> = document.querySelector(<span class="hljs-string">&#x27;p&#x27;</span>)<span class="hljs-comment">;</span><br>const <span class="hljs-attr">compStyles</span> = window.getComputedStyle(para)<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>因此浏览器一般会在遇到<code>&lt;script&gt;</code>标签时将该标签之前的<code>外联css</code>请求并执行完成。但是注意这里加了一个前提条件就是<code>javascript标签之前的外联css</code>，就是表示被<code>javascript</code>执行依赖的<code>外联css</code>。这个容易忽略的点<a href="https://link.juejin.cn/?target=https://javascript.info/onload-ondomcontentloaded">这篇文章</a>也有说明，推荐阅读。</p>
<p><strong>这些<code>阻塞型</code>的资源请求并执行完之后<code>dom树</code>的解析便完成了，这时<code>document</code>对象就会派发<code>DOMContentLoaded</code>事件，表示<code>dom树</code>构建完成。</strong></p>
<h5 id="1-2-非阻塞型"><a href="#1-2-非阻塞型" class="headerlink" title="1.2 非阻塞型"></a>1.2 非阻塞型</h5><p>不阻塞<code>dom</code>解析的资源主要包括：</p>
<ul>
<li>javascript标签之后的外联css</li>
<li>image</li>
<li>iframe</li>
<li>外联async javascript</li>
</ul>
<p><code>dom树</code>解析完成之后会派发<code>DOMContentLoaded</code>事件，对于<code>外联css</code>资源来说分为两类，一类是位于<code>&lt;script&gt;</code>标签之前，一类是位于<code>&lt;script&gt;</code>标签之后。位于<code>&lt;script&gt;</code>标签之后的<code>外联css</code>是不阻塞<code>dom树</code>的解析的。<code>外联css</code>对<code>dom树</code>解析过程的影响这里有一篇非常好的文章介绍：<a href="https://link.juejin.cn/?target=https://molily.de/domcontentloaded/">DOMContentLoaded and stylesheets</a>，推荐阅读。</p>
<p><code>DOMContentLoaded</code>事件用来标识<code>dom树</code>构建完成，那如何判断另外这些<code>非阻塞型</code>的资源加载完成呢？答案是<code>window.onload</code>。由于该事件派发的过晚，因此一般情况下我们用不着，而更多的是用<code>DOMContentLoaded</code>来尽早的的操作<code>dom</code>。</p>
<p>另外还有<code>image</code>、<code>iframe</code>以及<code>外联async javascript</code>也不会阻塞<code>dom</code>树的构建。这里<code>外联async javascript</code>又是什么呢？下一节整体介绍下<code>外联javascript</code>。</p>
<h3 id="2-外联javascript加载过程"><a href="#2-外联javascript加载过程" class="headerlink" title="2 外联javascript加载过程"></a>2 <code>外联javascript</code>加载过程</h3><p><code>html</code>页面中可以引入<code>内联javascript</code>，也可以引入<code>外联javascript</code>，<code>外联javascript</code>又分为：</p>
<ul>
<li>外联普通javascript</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;indx.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>外联defer javascript</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;indx.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>外联async javascript</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;indx.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>其中第一种就是<code>外联普通javascript</code>，会阻塞<code>html</code>的解析，<code>html</code>解析过程中每遇到这种<code>&lt;script&gt;</code>标签就会请求并执行，如下图所示，绿色表示<code>html</code>解析；灰色表示<code>html</code>解析暂停；蓝色表示<code>外联javascript</code>加载；粉色表示<code>javascript执行</code>。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/23/167daee046b13f89~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="标记"></p>
<p>是<code>外联普通javascript</code>的加载执行过程如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/23/167daf9dd89fdd11~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="外联普通javascript"></p>
<p>第二种<code>外联defer javascript</code>稍有不同，<code>html</code>解析过程中遇到此类<code>&lt;script&gt;</code>标签不阻塞解析，而是会暂存到一个队列中，等整个<code>html</code>解析完成后再按队列的顺序请求并执行<code>javascript</code>，但是这种<code>外联defer javascript</code>全部加载并执行完成后才会派发<code>DOMContentLoaded</code>事件，<code>外联defer javascript</code>的加载执行过程如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/23/167dafded7c4716c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="外联defer javascript"></p>
<p>第三种<code>外联async javascript</code>则不阻塞<code>html</code>的解析过程，注意这里是说的脚本的<code>下载</code>过程不阻塞<code>html</code>解析，如果下载完成后<code>html</code>还没解析完成，则会暂停<code>html</code>解析，先执行完成下载后的<code>javascript</code>代码再继续解析<code>html</code>，过程如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/23/167dafef85637252~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="外联async javascript"></p>
<p>但是如果<code>html</code>已经解析完毕，<code>外联async javascript</code>还未下载完成，则不阻塞<code>DOMContentLoaded</code>事件的派发。因此<code>外联async javascript</code>很有可能来不及监听<code>DOMContentLoaded</code>事件，比如<code>stackoverflow</code>上的<a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/9237044/async-loaded-scripts-with-domcontentloaded-or-load-event-handlers-not-being-call">这个问题</a>。</p>
<p>说明下，这几个图引用自<a href="https://link.juejin.cn/?target=https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html">这里</a>。</p>
<h3 id="3-DOMContentLoaded兼容性问题"><a href="#3-DOMContentLoaded兼容性问题" class="headerlink" title="3 DOMContentLoaded兼容性问题"></a>3 <code>DOMContentLoaded</code>兼容性问题</h3><p><code>DOMContentLoaded</code>最开始由<code>firefox</code>提出，其他浏览器觉得非常有用也相继开始支持，但是特性却稍有不同，比如<code>opera</code>中<code>javascript</code>的执行并不等待<code>外联css</code>的加载。直到<code>HTML5</code>出来后将<code>DOMContentLoaded</code>标准化，依照<code>HTML5</code>标准，<code>javascript</code>脚本执行前，出现在当前<code>&lt;script&gt;</code>之前的<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>必须完全载入。</p>
<p>那么在所有浏览器标准化之前怎么解决<code>DOMContentLoaded</code>的兼容性问题呢？可以参考<code>jQuery</code>中<code>.ready()</code>方法的实现，对于该方法的源码分析网上已经一大堆了，这里就不做分析了，直接说下原理。其实是就是用了<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded">MDN: DOMContentLoaded</a>中介绍的兼容性方法，<code>ie9</code>才开始支持<code>DOMContentedLoaded</code>，<code>ie8</code>环境可以通过检测<code>document.readystate</code>状态来确认<code>dom树</code>是否构建完成。<code>document.readystate</code>包括3种状态：</p>
<ul>
<li>loading - html文档加载中</li>
<li>interactive - html文档加载并解析完成，但是图片等资源还未完成加载，相当于<code>DOMContentLoaded</code></li>
<li>complete - 所有资源加载完成，相当于<code>window onload</code></li>
</ul>
<p>因此我们通过判断<code>document.readystate</code>的状态为<code>interactive</code>来模拟<code>DOMContentLoaded</code>时间点。但是这里需要注意一点，以<code>.ready()</code>方法为例，我们可能在下面这几个地方调用：</p>
<ul>
<li>内联javasctipt</li>
<li>外联普通javascript</li>
<li>外联defer javascript</li>
<li>外联async javascript</li>
</ul>
<p>其中3三个地方直接判断<code>document.readystate</code>肯定是<code>loading</code>状态，只有<code>外联async javascript</code>可能出现<code>document.readystate</code>为<code>interactive</code>或<code>completed</code>的状态，因为<code>外联async javascript</code>是不阻塞<code>dom</code>解析的，因此为了完全覆盖前面的4种情况，需要监听<code>document.readystate</code>的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">readystate</span> === <span class="hljs-string">&#x27;interactive&#x27;</span><br>    || <span class="hljs-variable language_">document</span>.<span class="hljs-property">readystate</span> === <span class="hljs-string">&#x27;complete&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 调用ready回调函数</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">readystate</span> === <span class="hljs-string">&#x27;interative&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 调用ready回调函数</span><br>        &#125;<br>    &#125; <br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h2 id="9-三次握手-x2F-四次挥手"><a href="#9-三次握手-x2F-四次挥手" class="headerlink" title="9 三次握手&#x2F;四次挥手"></a>9 三次握手&#x2F;四次挥手</h2><h3 id="TCP-三次握手过程是怎样的？"><a href="#TCP-三次握手过程是怎样的？" class="headerlink" title="TCP 三次握手过程是怎样的？"></a>TCP 三次握手过程是怎样的？</h3><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" srcset="/blog/img/loading.gif" lazyload alt="TCP 三次握手"></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230500953.png" srcset="/blog/img/loading.gif" lazyload alt="第一个报文 —— SYN 报文"></p>
<ul>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230504118.png" srcset="/blog/img/loading.gif" lazyload alt="第二个报文 —— SYN + ACK 报文"></p>
<ul>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230508297.png" srcset="/blog/img/loading.gif" lazyload alt="第三个报文 —— ACK 报文"></p>
<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code>标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p>
<p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h3 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="#如何在 Linux 系统中查看 TCP 状态？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B-tcp-%E7%8A%B6%E6%80%81">#</a>如何在 Linux 系统中查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230520683.png" srcset="/blog/img/loading.gif" lazyload alt="TCP 连接状态查看"></p>
<h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="#为什么是三次握手？不是两次、四次？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1">#</a>为什么是三次握手？不是两次、四次？</h3><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”</p>
<p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p>
<p>在前面我们知道了什么是 <strong>TCP 连接</strong>：</p>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <strong>Socket、序列号和窗口大小</strong>称为连接。</li>
</ul>
<p>所以，重要的是<strong>为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。</strong></p>
<p>接下来，以三个方面分析三次握手的原因：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p><em>原因一：避免历史连接</em></p>
<p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p>
<p>看看三次握手是如何阻止历史连接的：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png" srcset="/blog/img/loading.gif" lazyload alt="三次握手避免历史连接"></p>
<p>客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。</li>
<li>服务端收到 RST 报文后，就会释放连接。</li>
<li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p>
<p>TIP</p>
<p>有很多人问，如果服务端在收到 RST 报文之前，先收到了「新 SYN 报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN 报文」，此时会发生什么?</p>
<p>当服务端第一次收到 SYN 报文，也就是收到 「旧 SYN 报文」时，就会回复 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新 SYN 报文」时，就会回 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack (opens new window)</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。所以客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文。</p>
<p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p>
<p>我先直接说结论，主要是因为<strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p>
<p>你想想，在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png" srcset="/blog/img/loading.gif" lazyload alt="两次握手无法阻止历史连接"></p>
<p>可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p>
<p>因此，<strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p>
<p>所以，<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</strong></p>
<p>TIP</p>
<p>有人问：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</p>
<p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。</p>
<p><em>原因二：同步双方初始序列号</em></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code>报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230639121.png" srcset="/blog/img/loading.gif" lazyload alt="四次握手与三次握手"></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><em>原因三：避免资源浪费</em></p>
<p>如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，这会造成什么情况呢？</p>
<p>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png" srcset="/blog/img/loading.gif" lazyload alt="两次握手会造成资源浪费"></p>
<p>即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<p>TIP</p>
<p>很多人问，两次握手不是也可以根据上下文信息丢弃 syn 历史报文吗？</p>
<p>我这里两次握手是假设「由于没有第三次握手，服务端不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认报文，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接」这个场景。</p>
<p>当然你要实现成类似三次握手那样，根据上下文丢弃 syn 历史报文也是可以的，两次握手没有具体的实现，怎么假设都行。</p>
<p><em>小结</em></p>
<p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h3 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="#为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E6%97%B6-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2">#</a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><p>主要原因有两个方面：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ul>
<p>接下来，详细说说第一点。</p>
<p>假设每次建立连接，客户端和服务端的初始化序列号都是从 0 开始：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E7%9B%B8%E5%90%8C.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>过程如下：</p>
<ul>
<li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。</li>
<li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li>
<li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li>
</ul>
<p>可以看到，<strong>如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题</strong>。</p>
<p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，比如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/isn%E4%B8%8D%E7%9B%B8%E5%90%8C.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。</p>
<p>所以，每次初始化序列号不一样很大程度上能够避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了（因为序列号会有回绕的问题，所以需要用时间戳的机制来判断历史报文，详细看篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/isn_deff.html">TCP 是如何避免历史报文的？ (opens new window)</a>）。</p>
<h3 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="#初始序列号 ISN 是如何随机产生的？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7-isn-%E6%98%AF%E5%A6%82%E4%BD%95%E9%9A%8F%E6%9C%BA%E4%BA%A7%E7%94%9F%E7%9A%84">#</a>初始序列号 ISN 是如何随机产生的？</h3><p>起始 <code>ISN</code> 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<h3 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="#既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%97%A2%E7%84%B6-ip-%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87-%E4%B8%BA%E4%BB%80%E4%B9%88-tcp-%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81-mss-%E5%91%A2">#</a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p>我们先来认识下 MTU 和 MSS</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230633447.png" srcset="/blog/img/loading.gif" lazyload alt="MTU 与 MSS"></p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li>
</ul>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p>
<p>当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。</p>
<p>这看起来井然有序，但这存在隐患的，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p>
<p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p>
<p>当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。</p>
<p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230628926.png" srcset="/blog/img/loading.gif" lazyload alt="握手阶段协商 MSS"></p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
<h3 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="#第一次握手丢失了，会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>第一次握手丢失了，会发生什么？</h3><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code>状态。</p>
<p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
<p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/sys/net/ipv4/tcp_syn_retries</span><br>5<br></code></pre></td></tr></table></figure>

<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
<p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p>
<p>举个例子，假设 tcp_syn_retries 参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC1%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 3 次 SYN 报文后，由于 tcp_syn_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li>
</ul>
<h3 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="#第二次握手丢失了，会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>第二次握手丢失了，会发生什么？</h3><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p>
<p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/sys/net/ipv4/tcp_synack_retries</span><br>5<br></code></pre></td></tr></table></figure>

<p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<p>举个例子，假设 tcp_syn_retries 参数值为 1，tcp_synack_retries 参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC2%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 1 次 SYN 报文后，由于 tcp_syn_retries 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li>
<li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li>
</ul>
<h3 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="#第三次握手丢失了，会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>第三次握手丢失了，会发生什么？</h3><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<p>举个例子，假设 tcp_synack_retries 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li>
</ul>
<h3 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="#什么是 SYN 攻击？如何避免 SYN 攻击？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF-syn-%E6%94%BB%E5%87%BB-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-syn-%E6%94%BB%E5%87%BB">#</a>什么是 SYN 攻击？如何避免 SYN 攻击？</h3><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230625853.png" srcset="/blog/img/loading.gif" lazyload alt="SYN 攻击"></p>
<p>先跟大家说一下，什么是 TCP 半连接和全连接队列。</p>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<p>我们先来看下 Linux 内核的 <code>SYN</code> 队列（半连接队列）与 <code>Accpet</code> 队列（全连接队列）是如何工作的？</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png" srcset="/blog/img/loading.gif" lazyload alt="正常流程"></p>
<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li>
</ul>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p>
<p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>
<blockquote>
<p>方式一：调大 netdev_max_backlog</p>
</blockquote>
<p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">net.core.netdev_max_backlog = 10000<br></code></pre></td></tr></table></figure>

<blockquote>
<p>方式二：增大 TCP 半连接队列</p>
</blockquote>
<p>增大 TCP 半连接队列，要同时增大下面这三个参数：</p>
<ul>
<li>增大 net.ipv4.tcp_max_syn_backlog</li>
<li>增大 listen() 函数中的 backlog</li>
<li>增大 net.core.somaxconn</li>
</ul>
<p>具体为什么是三个参数决定 TCP 半连接队列的大小，可以看这篇：可以看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？(opens new window)</a></p>
<blockquote>
<p>方式三：开启 net.ipv4.tcp_syncookies</p>
</blockquote>
<p>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230618804.png" srcset="/blog/img/loading.gif" lazyload alt="tcp_syncookies 应对 SYN 攻击"></p>
<p>具体过程：</p>
<ul>
<li>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</li>
<li>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；</li>
<li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。</li>
<li>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept 队列」取出的连接。</li>
</ul>
<p>可以看到，当开启了 tcp_syncookies 了，即使受到 SYN 攻击而导致 SYN 队列满时，也能保证正常的连接成功建立。</p>
<p>net.ipv4.tcp_syncookies 参数主要有以下三个值：</p>
<ul>
<li>0 值，表示关闭该功能；</li>
<li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li>
<li>2 值，表示无条件开启功能；</li>
</ul>
<p>那么在应对 SYN 攻击时，只需要设置为 1 即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies<br></code></pre></td></tr></table></figure>

<blockquote>
<p>方式四：减少 SYN+ACK 重传次数</p>
</blockquote>
<p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。</p>
<p>那么针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</p>
<p>SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定（默认值是 5 次），比如将 tcp_synack_retries 减少到 2 次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/tcp_synack_retries</span><br></code></pre></td></tr></table></figure>

<h2 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h2><h3 id="TCP-四次挥手过程是怎样的？"><a href="#TCP-四次挥手过程是怎样的？" class="headerlink" title="#TCP 四次挥手过程是怎样的？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">#</a>TCP 四次挥手过程是怎样的？</h3><p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过<strong>四次挥手</strong>方式。</p>
<p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" srcset="/blog/img/loading.gif" lazyload alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="#为什么挥手需要四次？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1">#</a>为什么挥手需要四次？</h3><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<p>但是<strong>在特定情况下，四次挥手是可以变成三次挥手的</strong>，具体情况可以看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html">TCP 四次挥手，可以变成三次吗？(opens new window)</a></p>
<h3 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="#第一次挥手丢失了，会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>第一次挥手丢失了，会发生什么？</h3><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code>状态。</p>
<p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</p>
<p>举个例子，假设 tcp_orphan_retries 参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 3 次 FIN 报文后，由于 tcp_orphan_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。</li>
</ul>
<h3 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="#第二次挥手丢失了，会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>第二次挥手丢失了，会发生什么？</h3><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p>
<p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<p>举个例子，假设 tcp_orphan_retries 参数值为 2，当第二次挥手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 2 次 FIN 报文后，由于 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</li>
</ul>
<p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p>
<p>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。</p>
<p>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p>
<p>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2%E6%AD%BB%E7%AD%89.drawio.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="#第三次挥手丢失了，会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>第三次挥手丢失了，会发生什么？</h3><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</p>
<p>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</p>
<p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retrie</code>s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<p>举个例子，假设 <code>tcp_orphan_retrie</code>s &#x3D; 3，当第三次挥手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li>
<li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</li>
</ul>
<h3 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="#第四次挥手丢失了，会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>第四次挥手丢失了，会发生什么？</h3><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p>
<p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</p>
<p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</p>
<p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>举个例子，假设 tcp_orphan_retries 为 2，当第四次挥手一直丢失时，发生的过程如下：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1drawio.drawio.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li>
<li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li>
</ul>
<h3 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="#为什么 TIME_WAIT 等待的时间是 2MSL？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88-time-wait-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2msl">#</a>为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p>
<p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p>
<p>其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="hljs-comment">/* how long to wait to destroy TIME-WAIT </span></span><br><span class="hljs-comment"><span class="hljs-meta">                                    state, about 60 seconds  */</span></span><br></code></pre></td></tr></table></figure>

<p>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="#为什么需要 TIME_WAIT 状态？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-time-wait-%E7%8A%B6%E6%80%81">#</a>为什么需要 TIME_WAIT 状态？</h3><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
<p><em>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</em></p>
<p>为了能更好的理解这个原因，我们先来了解序列号（SEQ）和初始序列号（ISN）。</p>
<ul>
<li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li>
<li><strong>初始序列号</strong>，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时</strong>。</li>
</ul>
<p>给大家抓了一个包，下图中的 Seq 就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c9ea9b844e87bcd4acd3e320403ecab3.png" srcset="/blog/img/loading.gif" lazyload alt="TCP 抓包图"></p>
<p>通过前面我们知道，<strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/6385cc99500b01ba2ef288c27523c1e7-20230309230608128.png" srcset="/blog/img/loading.gif" lazyload alt="TIME-WAIT 时间过短，收到旧连接的数据报文"></p>
<p>如上图：</p>
<ul>
<li>服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li>
<li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 <code>SEQ = 301</code> 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li>
</ul>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><em>原因二：保证「被动关闭连接」的一方，能被正确的关闭</em></p>
<p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p>
<p><em>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</em></p>
<p>也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/3a81c23ce57c27cf63fc2b77e34de0ab-20230309230604522.png" srcset="/blog/img/loading.gif" lazyload alt="TIME-WAIT 时间过短，没有确保连接正常关闭"></p>
<p>服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png" srcset="/blog/img/loading.gif" lazyload alt="TIME-WAIT 时间正常，确保了连接正常关闭"></p>
<p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<h3 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="#TIME_WAIT 过多有什么危害？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#time-wait-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3">#</a>TIME_WAIT 过多有什么危害？</h3><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。具体可以看我这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/port.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%90%97">客户端的端口可以重复使用吗？(opens new window)</a></p>
<p>因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。</p>
<p>不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<h3 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="#如何优化 TIME_WAIT？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-time-wait">#</a>如何优化 TIME_WAIT？</h3><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
<p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em></p>
<p>如下的 Linux 内核参数开启后，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p>
<p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.ipv4.tcp_tw_reuse = 1<br></code></pre></td></tr></table></figure>

<p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">net.ipv4.tcp_timestamps=1（默认即为 1）<br></code></pre></td></tr></table></figure>

<p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。</p>
<p>由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<p><em>方式二：net.ipv4.tcp_max_tw_buckets</em></p>
<p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p>
<p><em>方式三：程序中使用 SO_LINGER</em></p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linger</span> <span class="hljs-title">so_linger</span>;</span><br>so_linger.l_onoff = <span class="hljs-number">1</span>;<br>so_linger.l_linger = <span class="hljs-number">0</span>;<br>setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="hljs-keyword">sizeof</span>(so_linger));<br></code></pre></td></tr></table></figure>

<p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p>
<p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<p>前面介绍的方法都是试图越过 <code>TIME_WAIT</code>状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p>
<p>《UNIX网络编程》一书中却说道：<strong>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它</strong>。</p>
<p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p>
<h3 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="#服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time-wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h3><p>首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p>
<p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>
<p>接下来，分别介绍下。</p>
<p><em>第一个场景：HTTP 没有使用长连接</em></p>
<p>我们先来看看 HTTP 长连接（Keep-Alive）机制是怎么开启的。</p>
<p>在 HTTP&#x2F;1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的 header 中添加：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Connection: Keep-Alive<br></code></pre></td></tr></table></figure>

<p>然后当服务器收到请求，作出回应的时候，它也被添加到响应中 header 里：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Connection: Keep-Alive<br></code></pre></td></tr></table></figure>

<p>这样做，TCP 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个 TCP 连接。这一直继续到客户端或服务器端提出断开连接。</p>
<p><strong>从 HTTP&#x2F;1.1 开始， 就默认是开启了 Keep-Alive</strong>，现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p>
<p>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 <code>Connection:close</code> 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p>
<p>关闭 HTTP 长连接机制后，每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/d6f6757c02e3afbf113d1048c937f8ee.png" srcset="/blog/img/loading.gif" lazyload alt="HTTP 短连接"></p>
<p>在前面我们知道，只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。</p>
<p>问题来了，<strong>这时候是客户端还是服务端主动关闭连接呢？</strong></p>
<p>在 RFC 文档中，并没有明确由谁来关闭连接，<strong>请求和响应的双方都可以主动关闭 TCP 连接。</strong></p>
<p>不过，<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<blockquote>
<p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p>
<p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p>
<blockquote>
<p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p>
<p>为什么要这么设计呢？在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select &#x2F; epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。</p>
<p>因此，<strong>当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive</strong>，因为任意一方没有开启 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</p>
<p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p>
<p><em>第二个场景：HTTP 长连接超时</em></p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/d2b20d1cc03936332adb2a68512eb167.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。</p>
<p>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/7e995ecb2e42941342f97256707496c9.png" srcset="/blog/img/loading.gif" lazyload alt="HTTP 长连接超时"></p>
<p>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。</p>
<p>可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</p>
<p><em>第三个场景：HTTP 长连接的请求数量达到上限</em></p>
<p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p>
<p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100 次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p>
<h3 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="#服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-close-wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B">#</a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>： 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p>
<p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析(opens new window)</a></p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="#如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5-%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E">#</a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.ipv4.tcp_keepalive_time=7200<br>net.ipv4.tcp_keepalive_intvl=75  <br>net.ipv4.tcp_keepalive_probes=9<br></code></pre></td></tr></table></figure>

<ul>
<li>tcp_keepalive_time&#x3D;7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl&#x3D;75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes&#x3D;9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230552557.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p>
<p>如果开启了 TCP 保活，需要考虑以下几种情况：</p>
<ul>
<li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>第二种，对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li>
<li>第三种，是对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>TCP 保活的这个机制检测的时间是有点长，我们可以自己在应用层实现一个心跳机制。</p>
<p>比如，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/2d872f947dedd24800a1867dc4f8b9ce.png" srcset="/blog/img/loading.gif" lazyload alt="web 服务的 心跳机制"></p>
<h3 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5-%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<p>我自己做了个实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</p>
<h2 id="10-网络中断怎么继续上传"><a href="#10-网络中断怎么继续上传" class="headerlink" title="10 网络中断怎么继续上传"></a>10 网络中断怎么继续上传</h2><h4 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h4><p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p>
<p>如下图</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/blog/img/loading.gif" lazyload alt="图片"></p>
<p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p>
<p>大致流程如下：</p>
<ol>
<li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li>
<li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li>
<li>按照一定的策略（串行或并行）发送各个分片数据块；</li>
<li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li>
</ol>
<h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p>
<p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p>
<p>一般实现方式有两种：</p>
<ul>
<li>服务器端返回，告知从哪开始</li>
<li>浏览器端自行处理</li>
</ul>
<p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p>
<p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p>
<h2 id="11-MySQL数据库之索引、事务"><a href="#11-MySQL数据库之索引、事务" class="headerlink" title="11 MySQL数据库之索引、事务"></a>11 MySQL数据库之索引、事务</h2><h3 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>功能：查找索引后，直接指向数据所在的物理地址</li>
<li>意义：加速查询速度，为字段排序</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>1）索引需要占用额外的磁盘空间。<ul>
<li>对于 MyISAM 引擎而言，索引文件和数据文件是分离的，索引文件用于保存数据记录的地址。</li>
<li>而 InnoDB 引擎的表数据文件本身就是索引文件。（索引文件和数据文件是同一个）</li>
</ul>
</li>
<li>2）在插入和修改数据时要花费更多的时间、消耗更多性能，因为索引也要随之变动。</li>
</ul>
<h3 id="创建索引的原则依据"><a href="#创建索引的原则依据" class="headerlink" title="创建索引的原则依据"></a>创建索引的原则依据</h3><ul>
<li>表的主键、外键必须有索引。因为主键具有唯一性，外键关联的是主表的主键，查询时可以快速定位。</li>
<li><strong>记录数超过300行（或500行）的表应该有索引</strong>。如果没有索引，每次查询都需要把表遍历一遍，会严重影响数据库的性能。（会影响IO和CPU的性能）</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引。</li>
<li>唯一性太差的字段不适合建立索引。（因为字段值会有重复）</li>
<li>更新太频繁地字段不适合创建索引。</li>
<li>经常出现在 where 子句中的字段，特别是大表的字段，应该建立索引。</li>
<li>在经常进行GROUP BY、ORDER BY的字段上建立索引。</li>
<li>索引应该建在选择性高的字段上。（即重复性低的字段）</li>
<li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引。（大字段建索引会增加磁盘空间，而且搜索起来会影响性能）</li>
</ul>
<p>注：</p>
<p>当一个表写入多、读取很少的时候，不需要建立索引。</p>
<p>唯一性太差的字段、更新太频繁地字段、大字段，不适合做索引。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>唯一性较好的字段</li>
<li>超过300行的字段</li>
<li>经常表连接的字段</li>
<li>不常更新的字段</li>
<li>小字段</li>
</ul>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="1）普通索引："><a href="#1）普通索引：" class="headerlink" title="1）普通索引："></a>1）普通索引：</h4><p>最基本的索引类型，没有唯一性之类的限制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index 索引名 <span class="hljs-keyword">on</span> 表名 (字段);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> index 索引名 (字段(<span class="hljs-number">4</span>));<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 (字段 数据类型.... , index 索引名(字段));<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2）唯一索引："><a href="#2）唯一索引：" class="headerlink" title="2）唯一索引："></a>2）唯一索引：</h4><p>唯一索引：与普通索引类似，但区别是唯一索引列的每个值都唯一。 唯一索引 允许有空值（注意和主键不同）。如果是用组合索引创建，则列值的组合必须唯一。添加唯一键将自动创建唯一索引。</p>
<p>创建唯一键或者创建唯一索引都可实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index 索引名 <span class="hljs-keyword">on</span> 表名 (字段);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> 索引名(字段);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 (字段 数据类型.... , <span class="hljs-keyword">unique</span> 索引名(字段));<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3）主键索引："><a href="#3）主键索引：" class="headerlink" title="3）主键索引："></a>3）主键索引：</h4><p>是一种特殊的唯一索引，必须指定为“PRIMARY KEY”。一个表只能有一个主键，不允许有空值。 添加主键将自动创建主键索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key (字段);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 (字段 数据类型.... , <span class="hljs-keyword">primary</span> key (字段));<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 (字段 数据类型<span class="hljs-keyword">primary</span> key, ... );<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4）组合索引（单列、多列索引）"><a href="#4）组合索引（单列、多列索引）" class="headerlink" title="4）组合索引（单列、多列索引）:"></a>4）组合索引（单列、多列索引）:</h4><p>可以是单列上创建的索引，也可以是在多列上创建的索引。需要满足最左原则，因为 select 语句的 where 条件是依次从左往右执行的，所以在使用 select 语句查询时 where 条件使用的字段顺序必须和组合索引中的排序一致，否则索引将不会生效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index XXX_index <span class="hljs-keyword">on</span> 表名 (字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>, ... , 字段n);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> index XXX_index (字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>, ... , 字段n);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(列名<span class="hljs-number">1</span> 数据类型,列名<span class="hljs-number">2</span> 数据类型,列名<span class="hljs-number">3</span> 数据类型, INDEX 索引名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>,字段<span class="hljs-number">3</span>));<br><br>#### 使用时要注意 <span class="hljs-keyword">where</span> 的最左原则：<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 字段<span class="hljs-number">1</span><span class="hljs-operator">=</span>XXX <span class="hljs-keyword">and</span> 字段<span class="hljs-number">2</span><span class="hljs-operator">=</span>XXX <span class="hljs-keyword">and</span> ....<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5）全文索引："><a href="#5）全文索引：" class="headerlink" title="5）全文索引："></a>5）全文索引：</h4><p>适合在进行模糊查询的时候使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> fulltext index 索引名 <span class="hljs-keyword">on</span> 表名 (字段);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> fulltext 索引名 (字段);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 (字段 数据类型.... , fulltext 索引名(字段));<br><br>#### 查询时只能匹配完整的字符串：<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(字段) against(<span class="hljs-string">&#x27;查询字符串&#x27;</span>);<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><h4 id="删除主键索引的方法："><a href="#删除主键索引的方法：" class="headerlink" title="删除主键索引的方法："></a>删除主键索引的方法：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="删除其他索引："><a href="#删除其他索引：" class="headerlink" title="删除其他索引："></a>删除其他索引：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> index 索引名 <span class="hljs-keyword">on</span> 表名;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> index 索引名;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="查询表中有哪些索引"><a href="#查询表中有哪些索引" class="headerlink" title="查询表中有哪些索引"></a>查询表中有哪些索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> 表名; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>能查看索引的字段和细节，建议使用\G纵向查看<br><br><span class="hljs-keyword">show</span> keys <span class="hljs-keyword">from</span> 表名;<br><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>只能查看索引的字段和名称<br>复制代码<br></code></pre></td></tr></table></figure>

<p>查询结果中，各字段的含义如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>表的名称</td>
</tr>
<tr>
<td>Non_unique</td>
<td>如果索引不能包括重复词，则为0；如果可以，则为1</td>
</tr>
<tr>
<td>Key_name</td>
<td>索引的名称</td>
</tr>
<tr>
<td>seq_in_index</td>
<td>索引中的列序号，从1开始</td>
</tr>
<tr>
<td>column_name</td>
<td>列名称</td>
</tr>
<tr>
<td>collation</td>
<td>列以什么方式存储在索引中。在 MySQL中，有值”A”（升序）或 NULL（无分类）</td>
</tr>
<tr>
<td>Cardinality</td>
<td>索引中唯一值数目的估计值</td>
</tr>
<tr>
<td>sub_part</td>
<td>如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL</td>
</tr>
<tr>
<td>Packed</td>
<td>指示关键字如何被压缩。如果没有被压缩，则为NULL</td>
</tr>
<tr>
<td>Null</td>
<td>如果该列含有NULL值，则显示YES。如果没有，则显示NO或为空</td>
</tr>
<tr>
<td>lndex_type</td>
<td>用过的索引方法（BTREE，FULLTEXT，HASH，RTREE）</td>
</tr>
<tr>
<td>comment</td>
<td>备注</td>
</tr>
</tbody></table>
<h4 id="使用explain命令分析："><a href="#使用explain命令分析：" class="headerlink" title="使用explain命令分析："></a>使用explain命令分析：</h4><p>可以使用explain命令分析一下，这个 select语句是否使用了索引或者索引使用是否正确</p>
<h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p><strong>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</strong></p>
<p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务用来管理 insert,update,delete 语句 主要用于处理操作量大，复杂度高的数据。</p>
<h4 id="事务的ACID特点"><a href="#事务的ACID特点" class="headerlink" title="事务的ACID特点"></a>事务的ACID特点</h4><p>原子性：事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性：指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>
<p>隔离性：指在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间</p>
<p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h4 id="事务之间的相互影响"><a href="#事务之间的相互影响" class="headerlink" title="事务之间的相互影响"></a>事务之间的相互影响</h4><p>脏读：事务B读取了事务A修改的，还未提交的数据</p>
<p>不可重复度：事务B在事务A提交事务前后发现数据不一致，数据被修改</p>
<p>幻读：事务B提交事务修改了全部数据，事务A同时也提交事务插入了数据。操作前一个事务的用户会发现表中还有没有修改的数据行</p>
<p>丢失更新：两个事务同时读取同一条记录，A先修改记录，B也修改记录(B不知道A修改过)，B提交数据后B的修改结果覆盖了A的修改结果。</p>
<p>Mysql 及事物隔离级别</p>
<p>（1）read_uncommitted : 读取尚未提交的数据 ：不解决脏读</p>
<p>（2）read_committed：读取已经提交的数据 ：可以解决脏读</p>
<p>（3）repeatable_read：重读读取：可以解决脏读 和 不可重复读 —mysql默认的</p>
<p>（4）serializable：串行化：可以解决 脏读 不可重复读 和 虚读—相当于锁表</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>第一类丢失更新</th>
<th>第二类丢失更新</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>禁止</td>
<td>允许</td>
</tr>
<tr>
<td>read committed</td>
<td>禁止</td>
<td>允许</td>
<td>允许</td>
<td>禁止</td>
<td>允许</td>
</tr>
<tr>
<td>repeatable read</td>
<td>禁止</td>
<td>禁止</td>
<td>允许</td>
<td>禁止</td>
<td>禁止</td>
</tr>
<tr>
<td>serializable</td>
<td>禁止</td>
<td>禁止</td>
<td>禁止</td>
<td>禁止</td>
<td>禁止</td>
</tr>
</tbody></table>
<h4 id="查询事务的隔离级别"><a href="#查询事务的隔离级别" class="headerlink" title="查询事务的隔离级别"></a>查询事务的隔离级别</h4><p><strong>查询全局事务隔离级别：</strong></p>
<p>variables 指变量， global variables 指全局变量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%isolation%&#x27;</span>;   #方法一<br> <br> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@global</span>.tx_isolation;               #方法二<br> <br> 注释：<br> <span class="hljs-keyword">like</span>：表示模糊查询。<br> <span class="hljs-string">&#x27;%isolation%&#x27;</span>：表示包含isolation字符串。<br> <span class="hljs-string">&#x27;isolation%&#x27;</span>：以isolation字符串开头。<br> <span class="hljs-string">&#x27;%isolation&#x27;</span>：以isolation字符串结尾。<br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>查询会话事务隔离级别：</strong></p>
<p>session variables 指会话变量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">show</span> session variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%isolation%&#x27;</span>;    #方法一<br> <br> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@session</span>.tx_isolation;                #方法二<br> <br> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@tx</span>_isolation;                        #方法三<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="设置事务的隔离级别"><a href="#设置事务的隔离级别" class="headerlink" title="设置事务的隔离级别"></a>设置事务的隔离级别</h4><p><strong>设置全局事务隔离级别：</strong></p>
<p>全局级别设置之后，当前会话需要退出重新进入才会生效。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level 隔离级别；  <span class="hljs-meta">#永久生效</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>设置会话事务隔离级别：</strong></p>
<p>会话事务隔离级别只对当前连接有效，退出连接后失效。在其他终端连接无效。</p>
<p>再次连接后会恢复为全局事务的隔离级别。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> set session transaction isolation level 隔离级别；<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="事务控制语句："><a href="#事务控制语句：" class="headerlink" title="事务控制语句："></a><strong>事务控制语句：</strong></h4><ul>
<li><strong>BEGIN 或 START TRANSACTION：</strong> 显式地开启一个事务。</li>
<li><strong>COMMIT 或 COMMITWORK：</strong> 提交事务，并使已对数据库进行的所有修改变为永久性的。</li>
<li><strong>ROLLBACK 或 ROLLBACK WORK：</strong> 回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
<li><strong>SAVEPOINT S1：</strong> 使用SAVEPOINT 允许在事务中创建一个回滚点，一个事务中可以有多个SAVEPOINT；“S1”代表回滚点名称。</li>
<li><strong>ROLLBACK TO [SAVEPOINT] S1：</strong> 把事务回滚到标记点。</li>
</ul>
<h3 id="使用-set-设置控制事务"><a href="#使用-set-设置控制事务" class="headerlink" title="使用 set 设置控制事务"></a>使用 set 设置控制事务</h3><p><strong>在mysql中执行单独的命令会立即生效，是因为Mysql默认开启自动提交。</strong></p>
<p>使用 set 设置控制事务：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-keyword">set</span> AUTOCOMMIT=<span class="hljs-number">0</span>;       <span class="hljs-meta">#禁止自动提交（仅针对当前会话）</span><br> <span class="hljs-keyword">set</span> AUTOCOMMIT=<span class="hljs-number">1</span>;       <span class="hljs-meta">#开启自动提交（仅针对当前会话），Mysql默认为1</span><br> <br> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> AUTOCOMMIT=<span class="hljs-number">0</span>;    <span class="hljs-meta">#禁止自动提交（针对全局事务）</span><br> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> AUTOCOMMIT=<span class="hljs-number">1</span>;    <span class="hljs-meta">#开启自动提交（针对全局事务），Mysql默认为1</span><br> <br> show variables like <span class="hljs-string">&#x27;AUTOCOMMIT&#x27;</span>;   <span class="hljs-meta">#查看当前会话的AUTOCOMMIT值</span><br> show <span class="hljs-keyword">global</span> variables like <span class="hljs-string">&#x27;AUTOCOMMIT&#x27;</span>;  <span class="hljs-meta">#查看全局事务的AUTOCOMMIT值</span><br><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>如果没有开启自动提交，当前会话连接的mysql的所有操作都会当成一个事务直到你输入<code>rollback; 或 commit;</code>当前事务才算结束。当前事务结束前新的mysql连接时无法读取到任何当前会话的操作结果。</li>
<li>如果开起了自动提交，mysql 会把每个sql 语句当成一个事务，然后自动的commit。</li>
<li>当然无论开启与否，<code>begin; commit | rollback;</code> 都是独立的事务。</li>
</ul>
<h2 id="12-搞懂浏览器进程和线程"><a href="#12-搞懂浏览器进程和线程" class="headerlink" title="12 搞懂浏览器进程和线程"></a>12 搞懂浏览器进程和线程</h2><ol>
<li>计算机资源独立分配到各个进程，进程之间 <strong>互相独立</strong>（可以通信，但是代价较大）</li>
<li>一个进程由一个或多个线程组成，是包含关系</li>
<li>同一进程下的各个线程之间共享程序的内存空间</li>
</ol>
<p>可以打开任务管理器，能看到当前系统中有很多的进程存在。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fec50981a124178992471bba78c46f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>我们可以来看一下比较官方的解释：</p>
<p><strong>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</strong></p>
<p><strong>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位）</strong></p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>① 不同进程之间也可以通信，不过代价较大</li>
<li>② <strong>单线程与多线程</strong>，都是指<strong>在一个进程内</strong>的单和多</li>
</ul>
<h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器，是一种多进程的架构设计，<strong>在浏览器中打开一个网页相当于新起了一个进程</strong>，当然，浏览器也有它自己的优化机制，比方说有五个空白页，这五个空白页会<strong>合并</strong>成同一个进程。</p>
<p>主要包含一下四种进程：</p>
<h4 id="1-Browser进程（主进程）"><a href="#1-Browser进程（主进程）" class="headerlink" title="1. Browser进程（主进程）"></a>1. Browser进程（主进程）</h4><p>控制chrome的地址栏，书签栏，返回和前进按钮，同时还有浏览器的不可见部分，例如网络请求和文件访问</p>
<h4 id="2-第三方插件进程"><a href="#2-第三方插件进程" class="headerlink" title="2. 第三方插件进程"></a>2. 第三方插件进程</h4><p>每种插件一个进程，插件运行时才会创建</p>
<h4 id="3-GPU进程"><a href="#3-GPU进程" class="headerlink" title="3. GPU进程"></a>3. GPU进程</h4><p><strong>仅此一个</strong> ，用于3D绘制等</p>
<h4 id="4-浏览器渲染进程（浏览器内核）"><a href="#4-浏览器渲染进程（浏览器内核）" class="headerlink" title="4. 浏览器渲染进程（浏览器内核）"></a>4. 浏览器渲染进程（浏览器内核）</h4><p>负责界面渲染，脚本执行，事件处理等</p>
<h3 id="多进程的优势"><a href="#多进程的优势" class="headerlink" title="多进程的优势"></a>多进程的优势</h3><ol>
<li>避免单个页面崩溃造成整个浏览器的卡顿（由于每一个 <strong>Tab页</strong> 都是独立的进程）</li>
<li>避免第三方插件崩溃影响整个浏览器（由于第三方插件是独立的进程）</li>
<li>多进程充分利用多核优势（现在的 CPU 性能都很高）</li>
</ol>
<h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h3><p>浏览器的内核，是极其复杂的，毕竟浏览器的整个核心，就是它，它主要由以下五种线程组成：</p>
<h4 id="1-GUI渲染线程"><a href="#1-GUI渲染线程" class="headerlink" title="1. GUI渲染线程"></a>1. GUI渲染线程</h4><p>负责渲染浏览器界面（解析 HTML ，CSS，构建 <code>DOM树</code> <code>CSSOM树</code> 和 <code>Render树</code> ，布局和绘制等）。</p>
<p>GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行，当界面需要重绘或由于某种操作引发的重排时，该线程就会执行。</p>
<p><strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong>，这也是造成 <code>JS堵塞</code> 的原因所在。</p>
<p>由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 引擎线程和 GUI 渲染线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>
<p>因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</p>
<p>如果想了解有关于 <code>CSS</code> 和 <code>JS</code> 的堵塞问题，可以查阅 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7044360789708242980">面试中常问到的CSS堵塞和JS堵塞</a></p>
<h4 id="2-JS引擎线程"><a href="#2-JS引擎线程" class="headerlink" title="2. JS引擎线程"></a>2. JS引擎线程</h4><p>也称为 JS 内核，负责处理 JavaScript 脚本程序。</p>
<p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS线程在运行JS程序（我们早在之前说过了，JS是一门<strong>单线程</strong>的语言。至于原因可以查阅 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6886602875225833480#heading-1">单线程的JS</a></p>
<p>再次注意，<strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong> ，所以，如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<h4 id="3-事件触发线程"><a href="#3-事件触发线程" class="headerlink" title="3. 事件触发线程"></a>3. 事件触发线程</h4><p>首先这属于浏览器而不是JS引擎，主要用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</p>
<p>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。</p>
<p>当对应的事件符合触发条件被触发时，该线程会把是事件添加到待处理队列（宏任务）的队尾，等待JS引擎的处理。</p>
<p>同样地，由于 JS 是<strong>单线程</strong>的，所以需要等到 JS 引擎空闲了之后，才会对待处理队列进行处理。</p>
<h4 id="4-定时触发器线程"><a href="#4-定时触发器线程" class="headerlink" title="4. 定时触发器线程"></a>4. 定时触发器线程</h4><p>传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程。</p>
<p>因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。</p>
<p>因此通过单独线程来计时并触发定时，计时完毕后，添加到事件队列（宏任务）中，等待JS引擎空闲后执行。</p>
<p>不禁感叹，懂得 JS 的<strong>单线程</strong> 原来那么有用。</p>
<p>需要值得注意的是，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于4ms的时间间隔算为4ms。</p>
<h4 id="5-异步http请求线程"><a href="#5-异步http请求线程" class="headerlink" title="5. 异步http请求线程"></a>5. 异步http请求线程</h4><p><code>XMLHttpRequest</code> 在连接后是通过浏览器新开的一个线程请求。</p>
<p>当检测到状态更新时，如果没有设置回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列（微任务）中，等待 JS 引擎执行。</p>
<p>关于这个事件队列的执行机制，以及对于 <code>微任务</code> 与 <code>宏任务</code> 云里雾里的，可以查阅<a target="_blank" rel="noopener" href="https://juejin.cn/post/6886602875225833480">一文搞懂JS系列（六）之微任务与宏任务，Event Loop</a></p>
<h3 id="一图概览"><a href="#一图概览" class="headerlink" title="一图概览"></a>一图概览</h3><p>所以，综上所述，浏览器的进程和线程可以用下面的一张图概括：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a8d76c9f5cf445bb752b61eed7a99a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="13-计算机分层模型"><a href="#13-计算机分层模型" class="headerlink" title="13 计算机分层模型"></a>13 计算机分层模型</h2><h3 id="1-计算机网络的分层"><a href="#1-计算机网络的分层" class="headerlink" title="1. 计算机网络的分层"></a>1. 计算机网络的分层</h3><p>在计算机网络体系中，采用<strong>层次化</strong>的思想，将通信协议中必要的功能进行分层，每一层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务。上下层之间进行交互所遵循的约定叫做『接口』，同一层之间进行交互所遵循的约定叫做『协议』。</p>
<ul>
<li>『接口』即相邻两层之间交换位置的连接点，是上层使用下层服务的入口。</li>
<li>『协议』即通信双方所做的一些约定，比如怎么开始通信、信息的格式与顺序、怎么结束通信等。协议非常重要，我们在学习计算机网络过程中，重点就是理解各种协议，如 HTTP、DNS、TCP 等。只有通信双方同时支持相同协议，才能进行通信。就像人类之间通信交流一样，假如一个人只会英文，那么给他说中文，就会不知所云。</li>
</ul>
<p>计算机网络为什么要采用分层模型呢？主要原因在于分层存在以下优势：</p>
<ul>
<li>分层是软件设计中的一个常见套路，它也是一种常见解耦的思路，可以有效减少程序中出现『牵一发而动全身』的情况。将每个分层独立使用，灵活性更强，<strong>即使系统中某些分层发生变化，也不会波及整个系统。</strong></li>
<li>分层也可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的部分来处理，从而<strong>更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务。</strong></li>
</ul>
<p>当然也不是分层越多越好，即分层可能也存在一些劣势，比如有时可能会过分模块化，使处理变得更加沉重以及不同模块可能要处理相似的逻辑，从而出现冗余等问题。</p>
<h3 id="2-常见参考模型"><a href="#2-常见参考模型" class="headerlink" title="2. 常见参考模型"></a>2. 常见参考模型</h3><p>在计算机通信的初期，每家计算机厂商都生产各自的网络产品来实现计算机通信。而由于缺乏标准化，不同厂商设定的各种协议之间不兼容，无法跨厂商通信，非常不方便。</p>
<p>为了解决上述问题，国际标准化组织 ISO 制定了一个国际标准 <code>OSI 参考模型</code> ，将计算机网络体系划分为 7 层，对通信系统进行了标准化。此模型概念清晰，但非常复杂，实现较为困难，并没有得到普及。</p>
<p>出于实用的目的， ARPA 提出了 <code>TCP/IP 参考模型</code>（其实比 OSI 模型出现更早），将计算机网络划分为 4 层。此模型在标准制定过程中将真正能够实现通信的技术作为首要任务（更看重的是如何实现，而不是理论），并且一旦发现有什么问题，就及时修改程序、协议或相应文档，模型更加简洁，且实用性更强，最终成为了<strong>业界标准</strong>。但是 TCP&#x2F;IP 最下面的网络接口层概念并不清晰，没有什么具体内容。</p>
<p>为了方便理解计算机网络原理，在计算机网络教程中，通常综合 OSI 7 层模型和 TCP&#x2F;IP 4 层模型的优缺点，将计算机网络分为 5 层，既简洁又能将概念阐述更加清楚（当然实际上应用的还是 TCP&#x2F;IP 模型）。</p>
<p>几种计算机网络参考模型的示意图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89ad704c862d4a70a0cd6f2af1a6ef6d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20221202222222759.png"></p>
<h3 id="3-5-层参考模型简介"><a href="#3-5-层参考模型简介" class="headerlink" title="3. 5 层参考模型简介"></a>3. 5 层参考模型简介</h3><ul>
<li><p><strong>应用层</strong></p>
<p>应用层的传输单位是<code>报文</code>，<strong>任务是完成特定网络应用，比如传输电子邮件、传送文件、请求与响应 Web 文档等具体网络功能</strong>，用户直接接触到的就是这一层，常见协议有 HTTP、FTP、DNS、SMTP。</p>
</li>
<li><p><strong>传输层</strong></p>
<p>传输层的传输单位是<code>报文段</code>，<strong>任务是为不同进程之间提供通信服务。</strong> 一台主机上可能运行着很多进程（比如用户可能一边听着歌，一边聊着天，运行着不同的进程，那么就需要知道数据应该发送给哪个进程），通过端口号进行区分。常见协议有 TCP、UDP。</p>
</li>
<li><p><strong>网络层</strong></p>
<p>网络层的传输单位是<code>数据报（包）</code>，<strong>任务是为不同网络主机之间提供通信服务，把数据从源端传到目的端。</strong> 使用 IP 地址来标识网络上的设备。除了<strong>寻址</strong>之外还需要进行<strong>路由选择</strong>，从主机 A 向主机 B 传输数据的时候，有很多条可以选择的路由，网络层利用相应的路由算法计算出⼀条合适的道路。常见协议有 IP、ICMP。</p>
</li>
<li><p><strong>数据链路层</strong></p>
<p>数据链路层的传输单位是<code>帧</code>，<strong>任务是为物理层面上互连的、同一链路上的不同节点（主机或路由器）之间提供通信服务</strong>。例如与 1 个以太网相连的 2 个节点之间的通信。使用 MAC 地址来标识网络上的设备。数据链路层还提供流量控制、差错控制等功能。</p>
<p>网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起，因此互联网也称为『网络的网络』。通常把单个的网络简化成一条链路，数据链路层服务于同一个链路中的不同节点。</p>
<p>通信链路分为多种（如以太网、WIFI、电缆接入网），由不同类型的物理媒体组成（如光纤、双绞线、同轴电缆）。不同网络主机之间可能相距很远，之间跨越很多条链路。就像我们从北京公司去南京老家，可能会经过高速公路、城市道路、乡村小道等不同道路。</p>
</li>
<li><p><strong>物理层</strong></p>
<p>物理层的传输单位是<code>⽐特</code>，<strong>任务是透明的传输比特流（0&#x2F;1 信号）</strong> 。（透明传输就是不管所传数据是什么样的比特组合，都应当能在链路上传送）</p>
</li>
</ul>
<p>当两台计算机在进行通信的过程中，数据将会经过计算机网络的不同层级。<strong>发送端在层与层之间传输数据时，每经过一层都会添加一个该层所属的首部信息</strong>（封装），比如传输层会加上源端口号和目的端口号等信息、网络层会加上源 IP 地址和目标 IP 地址等信息、数据链路层会加上源 MAC 地址和目标 MAC 地址。反之，<strong>接收端在层与层传输数据时，每经过一层时会把对应的首部消去</strong>（解封装）。</p>
<p>这就类似于寄快递，商家寄件的时候会加上包装盒、包装袋、寄件信息贴纸等，一层层包装，而消费者收件的时候则需要一层层去掉包装，得到最终的商品。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22bd47144eea47bab94ddd029639dfef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20221201221832522.png"></p>
<h2 id="14-死锁"><a href="#14-死锁" class="headerlink" title="14 死锁"></a>14 死锁</h2><h3 id="一、死锁的概念"><a href="#一、死锁的概念" class="headerlink" title="一、死锁的概念"></a><strong>一、死锁的概念</strong></h3><p>在许多应用中进程需要以<strong>独占</strong>的方式访问资源，当操作系统允许多个进程并发执行时可能会出现进程永远被阻塞现象，如两个进程分别等待对方所占的资源，于是两者都不能执行而<strong>处于永远等待状态</strong>，此现象称为<strong>死锁</strong>。</p>
<blockquote>
<p>死锁通常被定义为：如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁。</p>
</blockquote>
<h3 id="二、死锁产生的条件"><a href="#二、死锁产生的条件" class="headerlink" title="二、死锁产生的条件"></a><strong>二、死锁产生的条件</strong></h3><ul>
<li>互斥条件<br>临界资源是独占资源，进程应互斥且排他的使用这些资源。</li>
<li>占有和等待条件<br>进程在请求资源得不到满足而等待时，不释放已占有资源。</li>
<li>不剥夺条件<br>又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</li>
<li>循环等待条件<br>又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li>
</ul>
<p><strong>死锁只有在这四个条件同时满足时出现。</strong></p>
<h3 id="三、死锁产生的原因"><a href="#三、死锁产生的原因" class="headerlink" title="三、死锁产生的原因"></a><strong>三、死锁产生的原因</strong></h3><p>死锁产生的原因有很多，如：</p>
<ul>
<li>进程顺序不当</li>
<li>PV操作使用不妥</li>
<li>同类资源分配不均</li>
<li>对某些资源的使用未加限制</li>
</ul>
<p>等等。</p>
<blockquote>
<p>可见，产生死锁的原因不仅与系统拥有的资源数量有关，而且与资源分配策略、进程对资源的使用要求以及进程的推进顺序有关。</p>
</blockquote>
<h3 id="四、死锁解决的方法"><a href="#四、死锁解决的方法" class="headerlink" title="四、死锁解决的方法"></a><strong>四、死锁解决的方法</strong></h3><p>主要有一下三种方法：</p>
<ul>
<li>死锁防止</li>
<li>死锁避免</li>
<li>死锁检测和恢复</li>
</ul>
<h4 id="4-1-死锁防止"><a href="#4-1-死锁防止" class="headerlink" title="4.1 死锁防止"></a><strong>4.1 死锁防止</strong></h4><p><strong>在程序运行之前防止发生死锁。</strong></p>
<p>前面说了死锁产生的条件有四个，分别是：互斥条件、占有和等待条件、不剥夺条件、循环等待条件。</p>
<p><strong>而死锁防止的策略就是至少破坏这四个条件其中一项。</strong></p>
<h5 id="4-1-1-破坏互斥条件"><a href="#4-1-1-破坏互斥条件" class="headerlink" title="4.1.1 破坏互斥条件"></a><strong>4.1.1 破坏互斥条件</strong></h5><p>使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。</p>
<blockquote>
<p>只读数据文件、磁盘等软硬件资源均可采用这种办法管理；<br>但是许多资源是独占性资源，如可写文件、键盘等只能互斥的占有；<br>所以这种做法在许多场合是不适用的。</p>
</blockquote>
<h5 id="4-1-2-破坏占有和等待条件"><a href="#4-1-2-破坏占有和等待条件" class="headerlink" title="4.1.2 破坏占有和等待条件"></a><strong>4.1.2 破坏占有和等待条件</strong></h5><p>采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。</p>
<blockquote>
<p>实现简单，但是严重的减低了资源利用率。<br>因为在每个进程占有的资源中，有些资源在运行后期使用，有些资源在例外情况下才被使用，可能会造成进程占有一些几乎用不到的资源，而使其他想使用这些资源的进程等待。</p>
</blockquote>
<h5 id="4-1-3-破坏不剥夺条件"><a href="#4-1-3-破坏不剥夺条件" class="headerlink" title="4.1.3 破坏不剥夺条件"></a><strong>4.1.3 破坏不剥夺条件</strong></h5><p>剥夺调度能够防止死锁，但是只适用于内存和处理器资源。</p>
<p>方法一：占有资源的进程若要申请新资源，必须主动释放已占有资源，若需要此资源，应该向系统重新申请。</p>
<p>方法二：资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。</p>
<h5 id="4-1-4-破坏循环等待条件"><a href="#4-1-4-破坏循环等待条件" class="headerlink" title="4.1.4 破坏循环等待条件"></a><strong>4.1.4 破坏循环等待条件</strong></h5><p>给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。</p>
<blockquote>
<p>采用层次分配策略，将系统中所有的资源排列到不同层次中</p>
</blockquote>
<ul>
<li>一个进程得到某层的一个资源后，只能申请较高一层的资源</li>
<li>当进程释放某层的一个资源时，必须先释放所占有的较高层的资源</li>
<li>当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源</li>
</ul>
<h4 id="4-2死锁避免"><a href="#4-2死锁避免" class="headerlink" title="4.2死锁避免"></a><strong>4.2死锁避免</strong></h4><blockquote>
<p>各种死锁防止方法能够防止发生死锁，但必然会降低系统并发性，导致低效的资源利用率。</p>
</blockquote>
<p><strong>在程序运行时避免发生死锁。</strong></p>
<h5 id="4-2-1-安全状态"><a href="#4-2-1-安全状态" class="headerlink" title="4.2.1 安全状态"></a><strong>4.2.1 安全状态</strong></h5><p><img src="https://pic2.zhimg.com/80/v2-72ae2b390bb3628b373265661676079d_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<h5 id="4-2-2单个资源的银行家算法"><a href="#4-2-2单个资源的银行家算法" class="headerlink" title="4.2.2单个资源的银行家算法"></a><strong>4.2.2单个资源的银行家算法</strong></h5><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="https://pic4.zhimg.com/80/v2-849e1f710f9a7cf648c07c69f81a5da3_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h5 id="4-2-3-多个资源的银行家算法"><a href="#4-2-3-多个资源的银行家算法" class="headerlink" title="4.2.3 多个资源的银行家算法"></a><strong>4.2.3 多个资源的银行家算法</strong></h5><p><img src="https://pic3.zhimg.com/80/v2-7ae7ff0a84197797b63e38184a466fc6_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h4 id="4-3-死锁检测和恢复"><a href="#4-3-死锁检测和恢复" class="headerlink" title="4.3 死锁检测和恢复"></a><strong>4.3 死锁检测和恢复</strong></h4><blockquote>
<p>对资源的分配加以适当限制可防止或避免死锁发生，但不利于进程对系统资源的充分共享。</p>
</blockquote>
<p><strong>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</strong></p>
<blockquote>
<p>如果进程 - 资源分配图中无环路，此时系统没有发生死锁。<br>如果进程 - 资源分配图中有环路，则可分为以下两种情况：</p>
</blockquote>
<ul>
<li>每种资源类中仅有一个资源，则系统发生了死锁。此时，环路是系统发生死锁的<strong>充分必要条件</strong>，环路中的进程就是死锁进程。</li>
<li>每种资源类中有多个资源，则环路的存在只是产生死锁的<strong>必要不充分条件</strong>，系统未必会发生死锁。</li>
</ul>
<p><strong>下面详细说一下这两种情况：</strong></p>
<h5 id="4-3-1-每种资源类中仅有一个资源的死锁检测"><a href="#4-3-1-每种资源类中仅有一个资源的死锁检测" class="headerlink" title="4.3.1 每种资源类中仅有一个资源的死锁检测"></a><strong>4.3.1 每种资源类中仅有一个资源的死锁检测</strong></h5><p><img src="https://pic2.zhimg.com/80/v2-15d05471cb6d97558eac7c026f2fc7d5_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<blockquote>
<p>比如：进程D需要的资源是U、T；进程G需要的资源是V、U；进程E需要的资源是T、V<br>此时进程D占有资源U，进程E占有资源T，进程G占有资源V<br>所以此时导致进程D、E、G所申请的资源不能得到全部满足，陷入死锁。</p>
</blockquote>
<p><strong>死锁检测算法：</strong></p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h5 id="4-3-2-每种资源类中有多个资源的死锁检测"><a href="#4-3-2-每种资源类中有多个资源的死锁检测" class="headerlink" title="4.3.2 每种资源类中有多个资源的死锁检测"></a><strong>4.3.2 每种资源类中有多个资源的死锁检测</strong></h5><p><img src="https://pic1.zhimg.com/80/v2-b7e8ba213e6589be48c923a4b0bb43b4_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>每个资源类用一个方框表示，方框中的原点表示此资源类中的各个资源；</p>
<p>每个进程用一个圆圈来表示，用有向边表示进程申请资源和资源分配情况。</p>
<p>约定方框→圆圈表示资源分配，圆圈→方框表示申请资源。</p>
<p>这种情况下，图3-6 发生了死锁，而图3-7没有发生死锁。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7f7aaa0aaa4d147df95c9a931b146809_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><strong>死锁检测算法:</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-fda5b7573cc9383034d75d8993277ed5_1440w.webp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h5 id="4-3-3-死锁恢复"><a href="#4-3-3-死锁恢复" class="headerlink" title="4.3.3 死锁恢复"></a><strong>4.3.3 死锁恢复</strong></h5><ul>
<li><p>资源剥夺法<br>剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</p>
</li>
<li><p>进程回退法<br>根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</p>
</li>
<li><p>进程撤销法</p>
</li>
<li><ul>
<li>撤销陷入死锁的所有进程，解除死锁，继续运行。</li>
<li>逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。</li>
</ul>
</li>
</ul>
<p>可选择符合下面条件之一的先撤销： 1.CPU消耗时间最少者 2.产生的输出量最小者<br>3.预计剩余执行时间最长者 4.分得的资源数量最少者后优先级最低者</p>
<ul>
<li>系统重启法<br>结束所有进程的执行并重新启动操作系统。这种方法很简单，但先前的工作全部作废，损失很大。</li>
</ul>
<h2 id="15-tls的实现过程"><a href="#15-tls的实现过程" class="headerlink" title="15 tls的实现过程"></a>15 tls的实现过程</h2><h3 id="TLS-x2F-SSL-基础概念"><a href="#TLS-x2F-SSL-基础概念" class="headerlink" title="TLS&#x2F;SSL 基础概念"></a>TLS&#x2F;SSL 基础概念</h3><p>概念源自百度百科：传输层安全性协议 TLS（Transport Layer Security），及其前身安全套接层 SSL（Secure Sockets Layer）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。网景公司（Netscape）在 1994 年推出首版网页浏览器，网景导航者时，推出 HTTPS 协议，以 SSL 进行加密，这是 SSL 的起源。IETF 将 SSL 进行标准化，1999 年公布第一版 TLS 标准文件。随后又公布RFC 5246（2008年8月）与RFC 6176（2011年3月）。在浏览器、邮箱、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如 Google、Facebook 等也以这个协议来创建安全连线，发送数据。目前已成为互联网上保密通信的工业标准。</p>
<p>TLS&#x2F;SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。  </p>
<h3 id="散列函数-Hash"><a href="#散列函数-Hash" class="headerlink" title="散列函数 Hash"></a>散列函数 Hash</h3><p>常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>常见的有 AES-CBC、DES、3DES、AES-GCM 等，信息的加密和解密用相同的密钥，掌握密钥才能获取信息。在对称加密中，信息安全的基础是保证密钥的安全。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信。服务器持有私钥可以实现一对多的通信，而客户端可以用公钥来验证服务器发送的数字签名。服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但该算法的计算复杂，加密速度慢。</p>
<p>结合三类算法的特点，TLS&#x2F;SSL 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p>
<h3 id="密钥协商过程中存在的问题及解决办法"><a href="#密钥协商过程中存在的问题及解决办法" class="headerlink" title="密钥协商过程中存在的问题及解决办法"></a>密钥协商过程中存在的问题及解决办法</h3><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>上面介绍了 TLS&#x2F;SSL 在 HTTPS 信息传递中扮演的角色，我们知道了要用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥。可是这个公钥是怎么传递给客户端的？</p>
<p>上面图中的过程是不安全的，接下来对该问题进行说明。与公钥密码加密系统相伴的一个重要挑战就是正确地决定某个主体或身份的公钥。如果 A 向 B 发送自已的公钥，M 能够在传输过程中将其修改为自己的公钥。B (也被称为依赖方)可能察觉不到自已使用的是 M 的公钥，而认为这是 A 的公钥。这样就使得 M 能够轻易地扮演 A 的角色，即如下图所示：</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>一种常见的方法是依靠中心化的机构，其中包括对公钥基础设施 PKI (Public Key Infrastructure) 的使用。这一方法在特定的理论假设下容易被证明是安全的。 PKI 负责提供创建、吊销、分发以及更新密钥对与证书的服务。它需要一些证书颁发机构 CA  (Certificate Authority) 才能运行。证书颁发机构是用于管理与认证一些个体与它们的公钥间的绑定关系的实体。目前有数百家商业证书颁发机构。一个证书颁发机构通常采用层次的签名构架。这意味着一个公钥可能会被一个父密钥签名，而这个父密钥可能会被一个祖父密钥签名，依次类推。最终，一个证书颁发机构会拥有一个或多个根证书，许多下属的证书都会依赖根证书来建立信任。</p>
<p>在实践中，系统往往要求公钥操作应当拥有知名 CA 的根证书。这些根证书是在配置时安装的 (例如，微软公司的 Intemet ExpIorer 浏览器、 Mozilia 公司的 Firefox 浏览器以及 Google 公司的 Chrome 浏览器都能够访问一个预先配置的根证书数据库)。</p>
<h3 id="TLS-x2F-SSL-握手过程"><a href="#TLS-x2F-SSL-握手过程" class="headerlink" title="TLS&#x2F;SSL 握手过程"></a>TLS&#x2F;SSL 握手过程</h3><ol>
<li><h4 id="client-hello"><a href="#client-hello" class="headerlink" title="client_hello"></a>client_hello</h4></li>
</ol>
<p>客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息，相关信息如下：</p>
<p>(1) 支持的最高TSL协议版本version，从低到高依次 SSLv2，SSLv3，TLSv1，TLSv1.1，TLSv1.2，TLSv1.3。</p>
<p>(2) 客户端支持的加密套件 cipher suites 列表， 每个加密套件对应前面 TLS 原理中的四个功能的组合：认证算法 Au (身份验证)、密钥交换算法 Key Exchange(密钥协商)、对称加密算法 Enc (信息加密)和信息摘要 Mac(完整性校验)。</p>
<p>(3) 支持的压缩算法 compression methods 列表，用于后续的信息压缩传输。</p>
<p>(4) 随机数 random_C，用于后续的密钥的生成。</p>
<p>(5) 扩展字段 extensions，支持协议与算法的相关参数以及其它辅助信息等，常见的 SNI 就属于扩展字段，后续单独讨论该字段作用。</p>
<ol start="2">
<li><h4 id="server-hello-server-certificate-sever-hello-done"><a href="#server-hello-server-certificate-sever-hello-done" class="headerlink" title="server_hello + server_certificate + sever_hello_done"></a>server_hello + server_certificate + sever_hello_done</h4></li>
</ol>
<p>(1) server_hello， 服务端返回协商的信息结果，包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 等，其中随机数用于后续的密钥协商。</p>
<p>(2) server_certificates，服务器端配置对应的证书链，用于身份验证与密钥交换。</p>
<p>(3) server_hello_done，通知客户端 server_hello 信息发送结束。</p>
<ol start="3">
<li><h4 id="证书校验"><a href="#证书校验" class="headerlink" title="证书校验"></a>证书校验</h4></li>
</ol>
<p>客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作，合法性验证包括如下：</p>
<p>(1) 证书链的可信性 trusted certificate path。</p>
<p>(2) 证书是否吊销 revocation，有两类方式离线 CRL 与在线 OCSP，不同的客户端行为会不同。</p>
<p>(3) 有效期 expiry date，证书是否在有效时间范围。</p>
<p>(4) 域名 domain，核查证书域名是否与当前的访问域名匹配，匹配规则后续分析。</p>
<ol start="4">
<li><h4 id="client-key-exchange-change-cipher-spec-encrypted-handshake-message"><a href="#client-key-exchange-change-cipher-spec-encrypted-handshake-message" class="headerlink" title="client_key_exchange + change_cipher_spec + encrypted_handshake_message"></a>client_key_exchange + change_cipher_spec + encrypted_handshake_message</h4></li>
</ol>
<p>(1) client_key_exchange，合法性验证通过之后，客户端计算产生随机数字 Pre-master，并用证书公钥加密，发送给服务器。</p>
<p>(2) 此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，计算得到协商密钥： enc_key &#x3D; Function(random_C, random_S, Pre-Master); 。</p>
<p>(3) change_cipher_spec，客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信。</p>
<p>(4) encrypted_handshake_message，结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证。</p>
<ol start="5">
<li><h4 id="change-cipher-spec-encrypted-handshake-message"><a href="#change-cipher-spec-encrypted-handshake-message" class="headerlink" title="change_cipher_spec + encrypted_handshake_message"></a>change_cipher_spec + encrypted_handshake_message</h4></li>
</ol>
<p>(1) 服务器用私钥解密加密的 Pre-master 数据，基于之前交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥：enc_key &#x3D; Function(random_C, random_S, Pre-Master); 。</p>
<p>(2) 计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性。</p>
<p>(3) change_cipher_spec， 验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信。</p>
<p>(4) encrypted_handshake_message， 服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥 session secret 与算法加密并发送到客户端。(将随机密码加密的数据响应给客户端)</p>
<ol start="6">
<li><h4 id="握手结束"><a href="#握手结束" class="headerlink" title="握手结束"></a>握手结束</h4></li>
</ol>
<p>客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成。</p>
<ol start="7">
<li><h4 id="加密通信"><a href="#加密通信" class="headerlink" title="加密通信"></a>加密通信</h4></li>
</ol>
<p>开始使用协商密钥与算法进行加密通信。注意：</p>
<p>(1) 服务器也可以要求验证客户端，即双向认证，可以在过程 2 要发送 client_certificate_request 信息，客户端在过程 4 中先发送  client_certificate 与 certificate_verify_message 信息，证书的验证方式基本相同，certificate_verify_message 是采用 client 的私钥加密的一段基于已经协商的通信信息得到数据，服务器可以采用对应的公钥解密并验证。</p>
<p>(2) 根据使用的密钥交换算法的不同，如 ECC 等，协商细节略有不同，总体相似。</p>
<p>(3) sever key exchange 的作用是 server certificate 没有携带足够的信息时，发送给客户端以计算 pre-master，如基于 DH 的证书，公钥不被证书中包含，需要单独发送。</p>
<p>(4) change cipher spec 实际可用于通知对端改版当前使用的加密通信方式，当前没有深入解析。</p>
<p>(5) alter message 用于指明在握手或通信过程中的状态改变或错误信息，一般告警信息触发条件是连接关闭，收到不合法的信息，信息解密失败，用户取消操作等，收到告警信息之后，通信会被断开或者由接收方决定是否断开连接。</p>
<h4 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h4><p>发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用发送方的私钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方。接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该报文是发送方的。</p>
<p>数字签名有两种功效：一是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。二是数字签名能确定消息的完整性。因为数字签名的特点是它代表了文件的特征，文件如果发生改变，数字摘要的值也将发生变化。不同的文件将得到不同的数字摘要。 一次数字签名涉及到一个哈希函数、接收者的公钥、发送方的私钥。</p>
<h2 id="16-http1-0-1-1-2-0-3-0"><a href="#16-http1-0-1-1-2-0-3-0" class="headerlink" title="16 http1.0 1.1 2.0 3.0"></a>16 http1.0 1.1 2.0 3.0</h2><ol>
<li>HTTP&#x2F;0.9: 这是最初的 HTTP 协议版本，只支持 GET 方法，且响应只能是 HTML 文件，又叫单行版本。</li>
<li>HTTP&#x2F;1.0: 在 1996 年发布，支持多种文件类型的传输和多种请求方法（如 GET、POST、HEAD），但每个请求需要重新建立连接，因此性能较低，存在线头阻塞和标头冗余的问题。</li>
<li>HTTP&#x2F;1.1: 在 1999 年发布，引入了持久连接、管道机制、分块传输编码等技术，大大提高了性能。此外还引入了缓存机制、虚拟主机等功能。</li>
<li>HTTP&#x2F;2: 在 2015 年发布，引入了二进制协议、多路复用、头部压缩、双向数据流等技术，进一步提高了性能。通过使用一些先进的技术，HTTP&#x2F;2 能够更快地传输数据，节省带宽和连接资源。</li>
<li>HTTP&#x2F;3: 在 2020 年发布，采用 QUIC 协议作为基础，使用 UDP 代替 TCP 传输，可以更快地传输数据，提高性能和安全性。</li>
</ol>
<h2 id="17-两个-Node-js-进程如何通信？"><a href="#17-两个-Node-js-进程如何通信？" class="headerlink" title="17 两个 Node.js 进程如何通信？"></a>17 两个 Node.js 进程如何通信？</h2><p>两个 Node.js 进程之间如何进行通信呢？这里要分两种场景：</p>
<ol>
<li>不同电脑上的两个 Node.js 进程间通信</li>
<li>同一台电脑上两个 Node.js 进程间通信</li>
</ol>
<p>对于第一种场景，通常使用 TCP 或 HTTP 进行通信，而对于第二种场景，又分为两种子场景：</p>
<ol>
<li>Node.js 进程和自己创建的 Node.js 子进程通信</li>
<li>Node.js 进程和另外不相关的 Node.js 进程通信</li>
</ol>
<p>前者可以使用内置的 IPC 通信通道，后者可以使用自定义管道，接下来进行详细介绍：</p>
<h3 id="不同电脑上的两个-Node-js-进程间通信"><a href="#不同电脑上的两个-Node-js-进程间通信" class="headerlink" title="不同电脑上的两个 Node.js 进程间通信"></a>不同电脑上的两个 Node.js 进程间通信</h3><p>要想进行通信，首先得搞清楚如何标识网络中的进程？网络层的 ip 地址可以唯一标识网络中的主机，而传输层的协议和端口可以唯一标识主机中的应用程序（进程），这样利用三元组（ip 地址，协议，端口）就可以标识网络的进程了。</p>
<h4 id="使用-TCP-套接字"><a href="#使用-TCP-套接字" class="headerlink" title="使用 TCP 套接字"></a>使用 TCP 套接字</h4><p>TCP 套接字（socket）是一种基于 TCP&#x2F;IP 协议的通信方式，可以让通过网络连接的计算机上的进程进行通信。一个作为 server 另一个作为 client，server.js 代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;socket connected&#x27;</span>)<br>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;socket disconnected&#x27;</span>))<br>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">message</span>))<br>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`receive: <span class="hljs-subst">$&#123;data&#125;</span>`</span>)<br>    socket.<span class="hljs-title function_">write</span>(data)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`send: <span class="hljs-subst">$&#123;data&#125;</span>`</span>)<br>  &#125;)<br>&#125;)<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>client.js 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><span class="hljs-keyword">const</span> client = net.<span class="hljs-title function_">connect</span>(<span class="hljs-number">8888</span>, <span class="hljs-string">&#x27;192.168.10.105&#x27;</span>)<br><br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;connected.&#x27;</span>))<br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`receive: <span class="hljs-subst">$&#123;data&#125;</span>`</span>))<br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;disconnected.&#x27;</span>))<br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">message</span>))<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> msg = <span class="hljs-string">&#x27;hello&#x27;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`send: <span class="hljs-subst">$&#123;msg&#125;</span>`</span>)<br>  client.<span class="hljs-title function_">write</span>(msg)<br>&#125;, <span class="hljs-number">3000</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>运行效果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ node server.js<br>client connected<br>receive: hello<br>send: hello<br><br>$ node client.js<br>connect to server<br>send: hello<br>receive: hello<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="使用-HTTP-协议"><a href="#使用-HTTP-协议" class="headerlink" title="使用 HTTP 协议"></a>使用 HTTP 协议</h4><p>因为 HTTP 协议也是基于 TCP 的，所以从通信角度看，这种方式本质上并无区别，只是封装了上层协议。server.js 代码为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">end</span>(req.<span class="hljs-property">url</span>)).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>client.js 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;192.168.10.105&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">8888</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hello&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options, <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`statusCode: <span class="hljs-subst">$&#123;res.statusCode&#125;</span>`</span>)<br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(d))<br>&#125;)<br>req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error))<br>req.<span class="hljs-title function_">end</span>()<br>复制代码<br></code></pre></td></tr></table></figure>

<p>运行效果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ node server.js<br>url /hello<br><br>$ node client.js<br>statusCode: 200<br>hello<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="同一台电脑上两个-Node-js-进程间通信"><a href="#同一台电脑上两个-Node-js-进程间通信" class="headerlink" title="同一台电脑上两个 Node.js 进程间通信"></a>同一台电脑上两个 Node.js 进程间通信</h3><p>虽然网络 socket 也可用于同一台主机的进程间通讯（通过 loopback 地址 127.0.0.1），但是这种方式需要经过网络协议栈、需要打包拆包、计算校验和、维护序号和应答等，就是为网络通讯设计的，而同一台电脑上的两个进程可以有更高效的通信方式，即 IPC（Inter-Process Communication），在 unix 上具体的实现方式为 unix domain socket，这是服务器端和客户端之间通过本地打开的套接字文件进行通信的一种方法，与 TCP 通信不同，通信时指定本地文件，因此不进行域解析和外部通信，所以比 TCP 快，在同一台主机的传输速度是 TCP 的两倍。</p>
<h4 id="使用内置-IPC-通道"><a href="#使用内置-IPC-通道" class="headerlink" title="使用内置 IPC 通道"></a>使用内置 IPC 通道</h4><p>如果是跟自己创建的子进程通信，是非常方便的，<a href="https://link.juejin.cn/?target=https://nodejs.org/api/child_process.html">child_process</a> 模块中的 fork 方法自带通信机制，无需关注底层细节，例如父进程 parent.js 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fork = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>).<span class="hljs-property">fork</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>)<br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">fork</span>(path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;child.js&quot;</span>), [], &#123; <span class="hljs-attr">stdio</span>: <span class="hljs-string">&quot;inherit&quot;</span> &#125;);<br>child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;message from child:&quot;</span>, message)<br>  child.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>子进程 child.js 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;message from parent:&quot;</span>, message);<br>&#125;)<br><br><span class="hljs-keyword">if</span> (process.<span class="hljs-property">send</span>) &#123;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> process.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-number">3000</span>)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ node parent.js<br>message from child: hello<br>message from parent: hi<br>message from child: hello<br>message from parent: hi<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="使用自定义管道"><a href="#使用自定义管道" class="headerlink" title="使用自定义管道"></a>使用自定义管道</h4><p>如果是两个独立的 Node.js 进程，如何建立通信通道呢？在 Windows 上可以使用命名管道（Named PIPE），在 unix 上可以使用 unix domain socket，也是一个作为 server，另外一个作为 client，其中 server.js 代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> pipeFile = process.<span class="hljs-property">platform</span> === <span class="hljs-string">&#x27;win32&#x27;</span> ? <span class="hljs-string">&#x27;\\\\.\\pipe\\mypip&#x27;</span> : <span class="hljs-string">&#x27;/tmp/unix.sock&#x27;</span><br><br><span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function"><span class="hljs-params">connection</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;socket connected.&#x27;</span>)<br>  connection.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;disconnected.&#x27;</span>))<br>  connection.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`receive: <span class="hljs-subst">$&#123;data&#125;</span>`</span>)<br>    connection.<span class="hljs-title function_">write</span>(data)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`send: <span class="hljs-subst">$&#123;data&#125;</span>`</span>)<br>  &#125;)<br>  connection.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">message</span>))<br>&#125;)<br><br><span class="hljs-keyword">try</span> &#123;<br>  fs.<span class="hljs-title function_">unlinkSync</span>(pipeFile)<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;&#125;<br><br>server.<span class="hljs-title function_">listen</span>(pipeFile)<br><br>复制代码<br></code></pre></td></tr></table></figure>

<p>client.js 代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>)<br><br><span class="hljs-keyword">const</span> pipeFile = process.<span class="hljs-property">platform</span> === <span class="hljs-string">&#x27;win32&#x27;</span> ? <span class="hljs-string">&#x27;\\\\.\\pipe\\mypip&#x27;</span> : <span class="hljs-string">&#x27;/tmp/unix.sock&#x27;</span><br><br><span class="hljs-keyword">const</span> client = net.<span class="hljs-title function_">connect</span>(pipeFile)<br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;connected.&#x27;</span>))<br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`receive: <span class="hljs-subst">$&#123;data&#125;</span>`</span>))<br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;disconnected.&#x27;</span>))<br>client.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">message</span>))<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> msg = <span class="hljs-string">&#x27;hello&#x27;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`send: <span class="hljs-subst">$&#123;msg&#125;</span>`</span>)<br>  client.<span class="hljs-title function_">write</span>(msg)<br>&#125;, <span class="hljs-number">3000</span>)<br><br>复制代码<br></code></pre></td></tr></table></figure>

<p>运行效果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ node server.js <br>socket connected.<br>receive: hello<br>send: hello<br><br>$ node client.js<br>connected.<br>send: hello<br>receive: hello<br></code></pre></td></tr></table></figure>

<h2 id="18-进程间通信的方式"><a href="#18-进程间通信的方式" class="headerlink" title="18 进程间通信的方式"></a>18 进程间通信的方式</h2><h3 id="1、常见的通信方式"><a href="#1、常见的通信方式" class="headerlink" title="1、常见的通信方式"></a>1、常见的通信方式</h3><p>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p>消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>
<p>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h3 id="2、按通信类型区分"><a href="#2、按通信类型区分" class="headerlink" title="2、按通信类型区分"></a>2、按通信类型区分</h3><p>共享存储器系统</p>
<p>1.基于共享数据结构的通信方式</p>
<p>（仅适用于传递相对少量的数据，通信效率低，属于低级通信）</p>
<p>2.基于共享存储区的通信方式</p>
<p>管道通信系统</p>
<p>管道是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件（pipe文件）</p>
<p>管道机制需要提供一下几点的协调能力</p>
<p>1.互斥，即当一个进程正在对pipe执行读&#x2F;写操作时，其它进程必须等待</p>
<p>2.同步，当一个进程将一定数量的数据写入，然后就去睡眠等待，直到读进程将数据取走，再去唤醒。读进程与之类似</p>
<p>3.确定对方是否存在</p>
<p>消息传递系统</p>
<p>1.直接通信方式</p>
<p>发送进程利用OS所提供的发送原语直接把消息发给目标进程</p>
<p>2.间接通信方式</p>
<p>发送和接收进程都通过共享实体（邮箱）的方式进行消息的发送和接收</p>
<p>客户机服务器系统</p>
<p>1.套接字 – 通信标识型的数据结构是进程通信和网络通信的基本构件</p>
<p>基于文件型的 （当通信进程都在同一台服务器中）其原理类似于管道</p>
<p>基于网络型的（非对称方式通信，发送者需要提供接收者命名。通信双方的进程运行在不同主机环境下被分配了一对套接字，一个属于发送进程，一个属于接收进程）</p>
<p>2.远程过程调用和远程方法调用</p>
<p>3、详解</p>
<p>3.1 管道</p>
<p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p>
<p>1、特点：</p>
<p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p>
<p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p>
<p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
<p>管道分为pipe（无名管道）和fifo（命名管道）两种，除了建立、打开、删除的方式不同外，这两种管道几乎是一样的。他们都是通过内核缓冲区实现数据传输。</p>
<p>pipe用于相关进程之间的通信，例如父进程和子进程，它通过pipe()系统调用来创建并打开，当最后一个使用它的进程关闭对他的引用时，pipe将自动撤销。</p>
<p>FIFO即命名管道，在磁盘上有对应的节点，但没有数据块——换言之，只是拥有一个名字和相应的访问权限，通过mknode()系统调用或者mkfifo()函数来建立的。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。</p>
<p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。</p>
<p><img src="https://img-blog.csdnimg.cn/20190426140549553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>3.2 无名管道</p>
<p>pipe的例子：父进程创建管道，并在管道中写入数据，而子进程从管道读出数据</p>
<p><img src="https://img-blog.csdnimg.cn/20190426140634887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>3.3 命名管道</p>
<p>和无名管道的主要区别在于，命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。</p>
<p>而无名管道却不同，进程只能访问自己或祖先创建的管道，而不能访任意访问已经存在的管道——因为没有名字。</p>
<p>Linux中通过系统调用mknod()或makefifo()来创建一个命名管道。最简单的方式是通过直接使用shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> myfifo<br></code></pre></td></tr></table></figure>


<p>等价于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mknod</span> myfifo p<br></code></pre></td></tr></table></figure>

<p>以上命令在当前目录下创建了一个名为myfifo的命名管道。用ls -p命令查看文件的类型时，可以看到命名管道对应的文件名后有一条竖线”|”，表示该文件不是普通文件而是命名管道。</p>
<p>使用open()函数通过文件名可以打开已经创建的命名管道，而无名管道不能由open来打开。当一个命名管道不再被任何进程打开时，它没有消失，还可以再次被打开，就像打开一个磁盘文件一样。</p>
<p>可以用删除普通文件的方法将其删除，实际删除的事磁盘上对应的节点信息。</p>
<p>例子：用命名管道实现聊天程序，一个张三端，一个李四端。两个程序都建立两个命名管道，fifo1,fifo2,张三写fifo1，李四读fifo1；李四写fifo2，张三读fifo2。</p>
<p>用select把，管道描述符和stdin假如集合，用select进行阻塞，如果有i&#x2F;o的时候唤醒进程。（粉红色部分为select部分，黄色部分为命名管道部分）</p>
<p><img src="https://img-blog.csdnimg.cn/20190426140748405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190426140755878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>3.4 消息队列</p>
<p>消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。</p>
<p>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</p>
<p>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
<p>消息队列的常用函数如下表：</p>
<p><img src="https://img-blog.csdnimg.cn/20190426140938100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>进程间通过消息队列通信，主要是：创建或打开消息队列，添加消息，读取消息和控制消息队列。</p>
<p>3.5 共享内存</p>
<p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p>
<p>采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</p>
<p><img src="https://img-blog.csdnimg.cn/2019042614103483.png" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p>
<p><img src="https://img-blog.csdnimg.cn/20190426141107202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70" srcset="/blog/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>共享内存有两种实现方式：1、内存映射 2、共享内存机制</p>
<p>3.6 信号量</p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>1、特点</p>
<p>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p>
<p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p>
<p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<p>支持信号量组。</p>
<p>2、原型</p>
<p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。</p>
<p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">int</span> num_sems, <span class="hljs-type">int</span> sem_flags)</span>;<br><span class="hljs-comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semop</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-keyword">struct</span> sembuf semoparray[], <span class="hljs-type">size_t</span> numops)</span>;  <br><span class="hljs-comment">// 控制信号量的相关信息</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semctl</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-type">int</span> sem_num, <span class="hljs-type">int</span> cmd, ...)</span>;<br></code></pre></td></tr></table></figure>











<h1 id="over-point"><a href="#over-point" class="headerlink" title="over point"></a>over point</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" class="category-chain-item">前端八股</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/blog/tags/%E8%AE%A1%E7%AE%97/">#计算</a>
      
        <a href="/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端八股 ｜ 计算机网络篇</div>
      <div>https://yoonalis.github.io/blog/2023/04/06/前端八股 ｜ 计算机网络篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20css%E7%AF%87/" title="前端八股 ｜ css篇">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前端八股 ｜ css篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2023/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%20%EF%BD%9C%20%E6%89%8B%E6%92%95%E7%AF%87/" title="前端八股 ｜ 手撕篇">
                        <span class="hidden-mobile">前端八股 ｜ 手撕篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
