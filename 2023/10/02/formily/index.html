

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="formily">
<meta property="og:url" content="https://yoonalis.github.io/blog/2023/10/02/formily/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="前端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/form.jpg">
<meta property="article:published_time" content="2023-10-02T07:25:23.790Z">
<meta property="article:modified_time" content="2023-10-03T07:22:03.742Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="formily">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/form.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>formily - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="formily"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-02 15:25" pubdate>
          2023年10月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          28k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          232 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">formily</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="formily"><a href="#formily" class="headerlink" title="formily"></a>formily</h1><blockquote>
<p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/formily">https://github.com/alibaba/formily</a></p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://formilyjs.org/zh-CN/guide">https://formilyjs.org/zh-CN/guide</a></p>
</blockquote>
<h2 id="1、综述"><a href="#1、综述" class="headerlink" title="1、综述"></a>1、综述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>问题：</p>
<ul>
<li><p>在 React 中，在受控模式下，表单的整树渲染问题非常明显。</p>
</li>
<li><p>特别是对于数据联动的场景，很容易导致页面卡顿。</p>
</li>
</ul>
<p>解决：</p>
<ul>
<li>为了解决这个问题，<code>formily</code>将每个表单字段的状态做了分布式管理，从而大大提升了表单操作性能。</li>
<li><code>formily</code>深度整合了 JSON Schema 协议，可以帮助您快速解决后端驱动表单渲染的问题。</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>可设计，借助 Form Builder 可以快速搭建表单</li>
<li>高性能，字段分布式渲染，大大减轻 React 渲染压力</li>
<li>支持 Ant Design&#x2F;Fusion Next 组件体系</li>
<li>JSX 标签化写法&#x2F;JSON Schema 数据驱动方案无缝迁移过渡</li>
<li>副作用逻辑独立管理，涵盖各种复杂联动校验逻辑</li>
<li>支持各种表单复杂布局方案</li>
</ul>
<h2 id="2、介绍"><a href="#2、介绍" class="headerlink" title="2、介绍"></a>2、介绍</h2><h3 id="表单场景的复杂度"><a href="#表单场景的复杂度" class="headerlink" title="表单场景的复杂度"></a>表单场景的复杂度</h3><ul>
<li>字段数量多，如何让性能不随字段数量增加而变差？</li>
<li>字段关联逻辑复杂，如何更简单的实现复杂的联动逻辑？字段与字段关联时，如何保证不影响表单性能？<ul>
<li>一对多(异步)</li>
<li>多对一(异步)</li>
<li>多对多(异步)</li>
</ul>
</li>
<li>表单数据管理复杂<ul>
<li>表单值转换逻辑复杂(前后端格式不一致)</li>
<li>同步默认值与异步默认值合并逻辑复杂</li>
<li>跨表单数据通信，如何让性能不随字段数量增加而变差？</li>
</ul>
</li>
<li>表单状态管理复杂<ul>
<li>着重提自增列表场景，如何让数组数据在移动，删除过程中，字段状态能够做到跟随移动？</li>
</ul>
</li>
<li>表单的场景化复用<ul>
<li>查询列表</li>
<li>弹窗&#x2F;抽屉表单</li>
<li>分步表单</li>
<li>选项卡表单</li>
</ul>
</li>
<li>动态渲染诉求很强烈<ul>
<li>字段配置化，让非专业前端也能快速搭建复杂表单</li>
<li>跨端渲染，一份 JSON Schema，多端适配</li>
<li>如何在表单协议中描述布局？<ul>
<li>纵向布局</li>
<li>横向布局</li>
<li>网格布局</li>
<li>弹性布局</li>
<li>自由布局</li>
</ul>
</li>
<li>如何在表单协议中描述逻辑？</li>
</ul>
</li>
</ul>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="精确渲染"><a href="#精确渲染" class="headerlink" title="精确渲染"></a>精确渲染</h4><p>在 React 场景下实现一个表单需求，因为要收集表单数据，实现一些联动需求，大多数都是通过 setState 来实现字段数据收集，这样实现非常简单，心智成本非常低，但是却又引入了性能问题，因为每次输入都会导致所有字段全量渲染，虽然在 DOM 更新层面是有 diff，但是 diff 也是有计算成本的，浪费了很多计算资源，如果用时间复杂度来看的话，初次渲染表单是 O(n)，字段输入时也是 O(n)，这样明显是不合理的。</p>
<ul>
<li>MVVM 设计模式。这样的设计模式核心是将视图模型抽象出来，然后在 DSL 模板层消费，DSL 借助某种依赖收集机制，然后在视图模型中统一调度，保证每次输入都是精确渲染的。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/mobxjs/mobx">Mobx</a> 状态管理解决方案。Mobx 最核心的能力就是它的依赖追踪机制和响应式模型的抽象能力。</li>
</ul>
<h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p>表单的联动是非常复杂的，包含了字段间的各种关系，我们想象一下，大多数表单联动，基本上都是基于某些字段的值引发的联动，但是，实际业务需求可能会比较恶心，不仅要基于某些字段值引发联动，还会基于其他副作用值引发联动，比如应用状态，服务端数据状态，页面 URL，某个字段 UI 组件内部数据，当前字段自身的其他数据状态，某些特殊异步事件等等。用张图来描述：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01LWjBSt251w5BtGHW2_!!6000000007467-55-tps-1100-432.svg" srcset="/blog/img/loading.gif" lazyload alt="image-20210202081316031"></p>
<p>从上图可以看到，想要达成一个联动关系，核心是<strong>将字段的某些状态属性与某些数据关联起来</strong>，这里的某些数据可以是外界数据，也可以是自身数据，比如字段的显示&#x2F;隐藏与某些数据的关联，又比如字段的值与某些数据关联，还比如字段的禁用&#x2F;编辑与某些数据关联，就举了 3 个例子，我们其实已经抽象出了一个最简单的 Field 模型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Field</span> &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span><br>  <span class="hljs-attr">visible</span>: <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">disabled</span>: <span class="hljs-built_in">boolean</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，Field 模型仅仅只有这 3 个属性吗？肯定不是，如果我们要表达一个字段，那么字段的路径一定要有，因为要描述整个表单树结构，同时，我们还要管理起字段对应 UI 组件的属性，比如 Input 和 Select 都有它的属性，举个例子，Input 的 placeholder 与某些数据关联，或者 Select 的下拉选项与某些数据关联，这样就能理解了吧。所以，我们的 Field 模型可以是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs unknown">interface Field &#123;<br>   path:string[],<br>   value:any,<br>   visible:boolean,<br>   disabled:boolean,<br>   component:[Component,ComponentProps]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们加了 component 属性，它代表了字段所对应的 UI 组件和 UI 组件属性，这样就实现了某些数据与字段组件属性关联，甚至是与字段组件关联的能力。还有吗？当然还有，比如字段的外包裹容器，通常我们都叫 FormItem，它主要负责字段的外围的交互样式，比如字段标题，错误提示的样式等等，如果我们想要囊括更多联动，比如某些数据与 FormItem 的联动，那就得把外包裹容器也加进去。还有很多很多属性，这里没法一一列举。</p>
<p>从上面的思路中我们可以看到，为了解决联动问题，不管我们怎么抽象，最终还是会抽象出字段模型，它包含了字段相关的所有状态，只要去操作这些状态就能引发联动。</p>
<p>关于精确渲染，我们已经确定可以选用类似 Mobx 的 Reactive 方案，虽然是重新造了一个轮子，但是，Reactive 这种模式始终还是很适合抽象响应式模型，所以基于 Reactive 的能力，Formily 经过不断试错与纠正，总算设计出了真正优雅的表单模型。这样的表单模型，解决的是表单领域问题，所以也称之为领域模型，有了这样的领域模型，我们就能让表单的联动变得可枚举可预测，这样也为后面要说的协议描述联动打下了坚实基础。</p>
<h4 id="路径系统"><a href="#路径系统" class="headerlink" title="路径系统"></a>路径系统</h4><p>前面提到了表单领域模型中的字段模型，如果设计的更完备的话，其实不止是字段模型，必须还要有一个表单模型作为顶层模型，顶层模型管理着所有字段模型，每个字段都有着自己的路径，那如何查找这些字段呢？前面说到的联动关系，更多的是被动依赖关系，但是有些场景，我们就是要基于某个异步事件动作，去修改某个字段的状态，这里就涉及到如何优雅的查找某个字段，同样也是经过了大量的试错与纠正，Formily 独创的路径系统 @formily&#x2F;path 很好的解决了这个问题，不仅仅是让字段查找变得优雅，它还能通过解构表达式去处理前后端数据结构不一致的恶心问题。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>借助 Mobx 和路径系统，我们已经打造了一个较为完备的表单方案了，但是这样抽象了之后，我们的方案就像个黑盒，外界无法感知到方案内部状态流转过程，想要在某个过程阶段内实现一些逻辑则无法实现，所以，这里我们就需要另外一个概念了，生命周期，只要我们将整个表单生命周期作为事件钩子暴露给外界，这样就能做到了既有抽象，但又灵活的表单方案。</p>
<h4 id="协议驱动"><a href="#协议驱动" class="headerlink" title="协议驱动"></a>协议驱动</h4><p>如果想要实现动态可配置表单，那必然是需要将表单结构变得可序列化，序列化的方式有很多种，可以是以 UI 为思路的 UI 描述协议，也可以是以数据为思路的数据描述协议，因为表单本身就是为了维护一份数据，那自然而然，对于表单场景而言，数据协议最适合不过，想要描述数据结构，现在业界最流行的就是 <a target="_blank" rel="noopener" href="https://json-schema.org/"><strong>JSON-Schema</strong></a> 了，因为 JSON Schema 协议上本身就有很多校验相关的属性，这就天然和表单校验关联上了。那 UI 描述协议就真的不适合描述表单吗？No，UI 描述协议适合更通用的 UI 表达，描述表单当然不在话下，只是它会更偏前端协议，相反，JSON-Schema，在后端模型层，都是可表达的，在描述数据上更通用，所以两种协议，各有所长，只是在单纯表单领域，JSON-Schema 会更偏领域化一些。</p>
<p>那么，如果选用 JSON-Schema，我们怎么描述 UI，怎么描述逻辑呢？单纯的描述数据，想要输出实际业务可用的表单页面，不太现实。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rjsf-team/react-jsonschema-form"><strong>react-jsonschema-form</strong></a>的解法是，数据是数据，UI 是 UI，这样的好处是，各个协议都是非常纯净的协议，但是却带来了较大的维护成本和理解成本，用户要开发一个表单，需要不断的在两种协议心智上做切换，所以，如果从技术视角来看这样的拆分，其实是非常合理的，但是从产品视角来看的话，拆分则是把成本抛给了用户，所以，Formily 的表单协议会更加倾向于<strong>在 JSON-Schema 上做扩展</strong>。</p>
<p>那么，如何扩展呢？为了不污染标准 JSON-Schema 属性，我们统一以<code>x-*</code>格式来表达扩展属性：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;字符串&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是一个字符串&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>这样看来，UI 协议与数据协议混合在一起，只要有一个统一的扩展约定，也还是能保证两种协议职责单一。</p>
<p>然后，如果想要在某些字段上包裹一个 UI 容器怎么办呢？这里，Formily 定义了一个新的 schema type，叫<code>void</code>。void 不陌生，W3C 规范里也有 void element，js 里也有 void 关键字，前者代表虚元素，后者代表虚指针，所以，在 JSON Schema 中，引入 void，代表一个虚数据节点，表示该节点并不占用实际数据结构。所以，我们可以这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;void&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;卡片&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是一个卡片&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Card&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;string&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;字符串&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是一个字符串&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>这样就可以描述了一个 UI 容器了，因为可以描述 UI 容器，我们就能轻易封装一个场景化的组件了，比如 FormStep，那么我们怎么描述字段间联动呢？比如一个字段要控制另一个字段的显示隐藏。我们可以这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Source&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Target&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-reactions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;source&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;when&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;$deps[0] == &#x27;123&#x27;&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fulfill&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;otherwise&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>借助<code>x-reactions</code>描述了 target 字段，依赖了 source 字段的值，如果值为<code>&#39;123&#39;</code>的时候则显示 target 字段，否则隐藏，这种联动方式是一种被动联动，那如果我们希望实现主动联动呢？可以这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Source&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-reactions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;when&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;$self.value == &#x27;123&#x27;&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;target&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fulfill&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;otherwise&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Target&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>只需要将<code>x-reactions</code>换个位置，放到 source 字段上，然后再指定一个 target 即可。</p>
<p>可以看到，我们的联动，其实核心是基于：</p>
<ul>
<li>条件</li>
<li>条件满足的动作</li>
<li>条件不满足的动作</li>
</ul>
<p>来实现的，因为内部状态管理借助了 类似 Mobx 的<a target="_blank" rel="noopener" href="https://reactive.formilyjs.org/zh-CN">@formily&#x2F;reactive</a>方案，所以，Formily 很轻松的就实现了被动和主动联动场景，覆盖了绝大多数业务需求。</p>
<p>所以，我们的表单完全可以使用协议来描述了，不管是再复杂的布局，还是很复杂的联动，都能做到可配置。</p>
<h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>前面讲了对于一开始的各种问题的解法，那么现在我们如何设计才能让 Formily 更加自洽且优雅呢？</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01iEwHrP1NUw84xTded_!!6000000001574-55-tps-1939-1199.svg" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>这张图主要将 Formily 分为了内核层，UI 桥接层，扩展组件层，和配置应用层。</p>
<p>内核层是 UI 无关的，它保证了用户管理的逻辑和状态是不耦合任何一个框架，这样有几个好处：</p>
<ul>
<li>逻辑与 UI 框架解耦，未来做框架级别的迁移，业务代码无需大范围重构</li>
<li>学习成本统一，如果用户使用了@formily&#x2F;react，以后业务迁移@formily&#x2F;vue，用户不需要重新学习</li>
</ul>
<p>JSON Schema 独立存在，给 UI 桥接层消费，保证了协议驱动在不同 UI 框架下的绝对一致性，不需要重复实现协议解析逻辑。</p>
<p>扩展组件层，提供一系列表单场景化组件，保证用户开箱即用。无需花大量时间做二次开发。</p>
<h4 id="竞品对比"><a href="#竞品对比" class="headerlink" title="竞品对比"></a>竞品对比</h4><table>
<thead>
<tr>
<th align="left">能力</th>
<th align="left">Ant Design Form</th>
<th align="left">Fusion Form</th>
<th align="left">Formik</th>
<th align="left">React Final Form</th>
<th align="left">React Schema Form</th>
<th align="left">React Hook Form</th>
<th align="left">Formily1.x</th>
<th align="left">Formily2.x</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">自定义组件接入成本</td>
<td align="left">4.x接入成本低</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">4.x性能较好</td>
<td align="left">差</td>
<td align="left">差</td>
<td align="left">较好</td>
<td align="left">差</td>
<td align="left">好</td>
<td align="left">非常好</td>
<td align="left">非常好</td>
</tr>
<tr>
<td align="left">是否支持动态渲染</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">是否开箱即用</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">是否支持跨端</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">开发效率</td>
<td align="left">一般</td>
<td align="left">一般</td>
<td align="left">一般</td>
<td align="left">一般</td>
<td align="left">低</td>
<td align="left">一般</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">学习成本</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">很高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">视图代码可维护性</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">场景化封装能力</td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">有</td>
<td align="left">无</td>
<td align="left">有</td>
<td align="left">有</td>
</tr>
<tr>
<td align="left">是否支持表单预览态</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<h4 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h4><ul>
<li>高性能</li>
<li>开箱即用</li>
<li>联动逻辑实现高效</li>
<li>跨端能力，逻辑可跨框架，跨终端复用</li>
<li>动态渲染能力</li>
</ul>
<h2 id="3、具体用例"><a href="#3、具体用例" class="headerlink" title="3、具体用例"></a>3、具体用例</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createForm &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/core&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FormProvider</span>, <span class="hljs-title class_">FormConsumer</span>, <span class="hljs-title class_">Field</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/react&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">FormItem</span>,<br>  <span class="hljs-title class_">FormLayout</span>,<br>  <span class="hljs-title class_">Input</span>,<br>  <span class="hljs-title class_">FormButtonGroup</span>,<br>  <span class="hljs-title class_">Submit</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/antd&#x27;</span><br><br><br><span class="hljs-keyword">const</span> form = <span class="hljs-title function_">createForm</span>()<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FormProvider</span> <span class="hljs-attr">form</span>=<span class="hljs-string">&#123;form&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormLayout</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Field</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;input&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;输入框&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">required</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">initialValue</span>=<span class="hljs-string">&quot;Hello world&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">decorator</span>=<span class="hljs-string">&#123;[FormItem]&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;[Input]&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">FormLayout</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormConsumer</span>&gt;</span></span><br><span class="language-xml">        &#123;() =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">marginBottom:</span> <span class="hljs-attr">20</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">padding:</span> <span class="hljs-attr">5</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">border:</span> &#x27;<span class="hljs-attr">1px</span> <span class="hljs-attr">dashed</span> #<span class="hljs-attr">666</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">            &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          &gt;</span></span><br><span class="language-xml">            实时响应：&#123;form.values.input&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">FormConsumer</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormButtonGroup</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Submit</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;console.log&#125;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">Submit</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">FormButtonGroup</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FormProvider</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从以上例子中，我们可以学到很多东西：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://core.formilyjs.org/zh-CN/api/entry/create-form">createForm</a>用来创建表单核心领域模型，它是作为<a target="_blank" rel="noopener" href="https://core.formilyjs.org/guide/mvvm">MVVM</a>设计模式的标准 ViewModel</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://react.formilyjs.org/zh-CN/api/components/form-provider">FormProvider</a>组件是作为视图层桥接表单模型的入口，它只有一个参数，就是接收 createForm 创建出来的 Form 实例，并将 Form 实例以上下文形式传递到子组件中</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://antd.formilyjs.org/zh-CN/components/form-layout">FormLayout</a>组件是用来批量控制<a target="_blank" rel="noopener" href="https://antd.formilyjs.org/zh-CN/components/form-item">FormItem</a>样式的组件，这里我们指定布局为上下布局，也就是标签在上，组件在下</p>
</li>
<li><p>Field</p>
<p>组件是用来承接普通字段的组件</p>
<ul>
<li>name 属性，标识字段在表单最终提交数据中的路径</li>
<li>title 属性，标识字段的标题<ul>
<li>如果 decorator 指定为 FormItem，那么在 FormItem 组件中会默认以接收 title 属性作为标签</li>
<li>如果指定为某个自定义组件，那么 title 的消费方则由自定义组件来承接</li>
<li>如果不指定 decorator，那么 title 则不会显示在 UI 上</li>
</ul>
</li>
<li>required 属性，必填校验的极简写法，标识该字段必填<ul>
<li>如果 decorator 指定为 FormItem，那么会自动出现星号提示，同时校验失败也会有对应的状态反馈，这些都是 FormItem 内部做的默认处理</li>
<li>如果 decorator 指定为自定义组件，那么对应的 UI 样式则需要自定义组件实现方自己实现</li>
<li>如果不指定 decorator，那么 required 只是会阻塞提交，校验失败不会有任何 UI 反馈。</li>
</ul>
</li>
<li>initialValue 属性，代表字段的默认值</li>
<li>decorator 属性，代表字段的 UI 装饰器，通常我们都会指定为 FormItem<ul>
<li>注意 decorator 属性传递的是数组形式，第一个参数代表指定组件类型，第二个参数代表指定组件属性</li>
</ul>
</li>
<li>component 属性，代表字段的输入控件，可以是 Input，也可以是 Select，等等<ul>
<li>注意 component 属性传递的是数组形式，第一个参数代表指定组件类型，第二个参数代表指定组件属性</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://react.formilyjs.org/zh-CN/api/components/form-consumer">FormConsumer</a>组件是作为响应式模型的响应器而存在，它核心是一个 render props 模式，在作为 children 的回调函数中，会自动收集所有依赖，如果依赖发生变化，则会重新渲染，借助 FormConsumer 我们可以很方便的实现各种计算汇总的需求</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://antd.formilyjs.org/zh-CN/components/form-button-group">FormButtonGroup</a>组件作为表单按钮组容器而存在，主要负责按钮的布局</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://antd.formilyjs.org/zh-CN/components/submit">Submit</a>组件作为表单提交的动作触发器而存在，其实我们也可以直接使用 form.submit 方法进行提交，但是使用 Submit 的好处是不需要每次都在 Button 组件上写 onClick 事件处理器，同时它还处理了 Form 的 loading 状态，如果 onSubmit 方法返回一个 Promise，且 Promise 正在 pending 状态，那么按钮会自动进入 loading 状态</p>
</li>
</ul>
<h2 id="4、基础核心库：Reactive"><a href="#4、基础核心库：Reactive" class="headerlink" title="4、基础核心库：Reactive"></a>4、基础核心库：Reactive</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>@formily&#x2F;reactive 的核心思想是参考 <a target="_blank" rel="noopener" href="https://mobx.js.org/">Mobx</a> 的，那为什么要重新造轮子呢？</p>
<p>主要有 4 点原因：</p>
<ul>
<li>mobx 不支持 action 内部进行依赖收集</li>
<li>mobx 的 observable 函数不支持过滤 react node,moment,immutable 之类的特殊对象</li>
<li>mobx 的 observable 函数会自动将函数变成 action</li>
<li>mobx-react-lite 的 observer 不支持 React 并发渲染</li>
</ul>
<p>基于以上原因，formily 不得不重新造轮子，不过该轮子是强依赖 Proxy 的，也就是不支持 IE 浏览器，当然，重新造轮子也有它的好处：</p>
<ul>
<li>把控性更强，可以为 formily 场景做更深的优化定制</li>
<li>不用考虑 Mobx 的历史包袱，代码可以更干净</li>
<li>如果 Mobx 版本 Break Change 或者存在安全漏洞，对 Formily 无影响</li>
</ul>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h5 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h5><p>observable 是响应式编程模型中最重要的一块，它的核心概念就是：</p>
<p>一个 observable 对象，字面意思是可订阅对象，<strong>我们通过创建一个可订阅对象，在每次操作该对象的属性数据的过程中，会自动通知订阅者</strong>，@formily&#x2F;reactive 创建 observable 对象主要是通过 ES Proxy 来创建的，它可以做到完美劫持数据操作。</p>
<p>我们在@formily&#x2F;reactive 中主要用以下几个 API 来创建 observable 对象：</p>
<ul>
<li>observable 函数创建深度 observable 对象<ul>
<li>observable.deep 函数创建深劫持 observable 对象</li>
<li>observable.shallow 函数创建浅劫持 observable 对象</li>
<li>observable.computed 函数创建缓存计算器</li>
<li>observable.box 函数创建带 get&#x2F;set 方法的 observable 对象</li>
<li>observable.ref 函数创建引用级 observable 对象</li>
</ul>
</li>
<li>define 函数定义 observable 领域模型，可以组合 observable 函数与其静态属性(比如 observable.computed)函数完成领域模型的定义。</li>
<li>model 函数定义自动 observable 领域模型，它会将 getter setter 属性包装为 computed 计算属性，将函数包装为 action，将其他数据属性用 observable 包装(注意这里是深劫持)。</li>
</ul>
<h5 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h5><p>reaction 在响应式编程模型中，它就相当于是可订阅对象的订阅者，它接收一个 tracker 函数，这个函数在执行的时候，如果函数内部有对 observable 对象中的某个属性进行<strong>读操作</strong>(依赖收集)，那当前 reaction 就会与该属性进行一个绑定(依赖追踪)，直到该属性在其他地方发生了<strong>写操作</strong>，就会触发 tracker 函数重复执行，用一张图表示：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/O1CN01DQMGUL22mFICDsKfY_!!6000000007162-2-tps-1234-614.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>可以看到从订阅到派发订阅，其实是一个封闭的循环状态机，每次 tracker 函数执行的时候都会重新收集依赖，依赖变化时又会重新触发 tracker 执行。所以，如果一旦我们不想再订阅 reaction 了，一定要手动 dispose，否则会内存泄漏。</p>
<p>在@formily&#x2F;reactive 中的我们主要是使用以下几个 API 来创建 reaction:</p>
<ul>
<li>autorun 创建一个自动执行的响应器</li>
<li>reaction 创建一个可以实现脏检查的响应器</li>
<li>Tracker 创建一个依赖追踪器，需要用户手动执行追踪</li>
</ul>
<h5 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h5><p>computed 在响应式编程模型中也是属于一个比较重要的概念，一句话表达的话，<strong>computed 是一个可以缓存计算结果的 Reaction</strong></p>
<p>它的缓存策略是：只要 computed 函数内部所依赖的 observable 数据发生变化，函数才会重新执行计算，否则永远读取缓存结果</p>
<p>这里要求的就是 computed 函数必须是纯函数，内部依赖的数据要么是 observable 数据，要么是外部常量数据，如果是外部变量数据(非 observable)，那如果外部变量数据发生变化，computed 是不会重新执行计算的。</p>
<h5 id="Batch"><a href="#Batch" class="headerlink" title="Batch"></a>Batch</h5><p>前面有讲到@formily&#x2F;reactive 是基于 Proxy 劫持来实现的响应式编程模型，所以任何一个原子操作都会触发 Reaction 执行，这样明显是浪费了计算资源的，比如我们有一个函数内部是对多个 observable 属性进行操作的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; observable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/reactive&#x27;</span><br><span class="hljs-keyword">const</span> obs = <span class="hljs-title function_">observable</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  obs.<span class="hljs-property">aa</span> = <span class="hljs-number">123</span><br>  obs.<span class="hljs-property">bb</span> = <span class="hljs-number">321</span><br>&#125;<br><br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obs.<span class="hljs-property">aa</span>, obs.<span class="hljs-property">bb</span>)<br>&#125;)<br><br><br><span class="hljs-title function_">handler</span>()<br></code></pre></td></tr></table></figure>

<p>这样就会执行 3 次打印，autorun 默认执行一次，加上 obs.aa 赋值执行一次，obs.bb 赋值执行一次，如果原子操作更多一些，那执行次数会更多，所以，我们推荐使用 batch 模式，将更新进行合并：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; observable, autorun, batch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/reactive&#x27;</span><br><span class="hljs-keyword">const</span> obs = <span class="hljs-title function_">observable</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  obs.<span class="hljs-property">aa</span> = <span class="hljs-number">123</span><br>  obs.<span class="hljs-property">bb</span> = <span class="hljs-number">321</span><br>&#125;<br><br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obs.<span class="hljs-property">aa</span>, obs.<span class="hljs-property">bb</span>)<br>&#125;)<br><br><br><span class="hljs-title function_">batch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">handler</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>当然，我们也可以使用 action 进行高阶包装：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; observable, autorun, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/reactive&#x27;</span><br><span class="hljs-keyword">const</span> obs = <span class="hljs-title function_">observable</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> handler = action.<span class="hljs-title function_">bound</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  obs.<span class="hljs-property">aa</span> = <span class="hljs-number">123</span><br>  obs.<span class="hljs-property">bb</span> = <span class="hljs-number">321</span><br>&#125;)<br><br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obs.<span class="hljs-property">aa</span>, obs.<span class="hljs-property">bb</span>)<br>&#125;)<br><br><br><span class="hljs-title function_">handler</span>()<br></code></pre></td></tr></table></figure>

<p>最终执行次数就是 2 次了，即便 handler 内部的操作再多也还是 2 次</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>在使用@formily&#x2F;reactive 的时候，我们只需要注意以下几点即可：</p>
<ul>
<li>尽量少用 observable&#x2F;observable.deep 进行深度包装，不是非不得已就多用 observable.ref&#x2F;observable.shallow，这样性能会更好</li>
<li>领域模型中多用 computed 计算属性，它可以智能缓存计算结果</li>
<li>虽然批量操作不是必须的，但是尽量多用 batch 模式，这样可以减少 Reaction 执行次数</li>
<li>使用 autorun&#x2F;reaction 的时候，一定记得调用 dispose 释放函数(也就是调用函数所返回的二阶函数)，否则会内存泄漏</li>
</ul>
<h2 id="5、基础核心库：core"><a href="#5、基础核心库：core" class="headerlink" title="5、基础核心库：core"></a>5、基础核心库：core</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><h5 id="UI-无关"><a href="#UI-无关" class="headerlink" title="UI 无关"></a>UI 无关</h5><p>因为 @formily&#x2F;core 作为一个独立的包而存在，它的核心意义是将领域模型从 UI 框架中抽离出来，同时给开发者带来了以下两个直观收益：</p>
<ol>
<li>可以方便 formily 开发者从 UI 与逻辑的耦合关系中释放出来，提升代码可维护性；</li>
<li>可以让 formily 拥有跨终端，跨框架的能力，不管你是 React 用户，Vue 用户还是 Angular 用户，都能享受到 formily 的领域模型带来的提效。</li>
</ol>
<h5 id="超高性能"><a href="#超高性能" class="headerlink" title="超高性能"></a>超高性能</h5><p>借助 @formily&#x2F;reactive，@formily&#x2F;core 天然获得了依赖追踪，高效更新，按需渲染的能力，不管是在 React 下，还是 Vue&#x2F;Angular 下，不管是字段频繁输入，还是字段联动，都能给用户带来 O(1)的性能体验，开发者无需关心性能优化的事情，只需要专注于业务逻辑实现即可。</p>
<h5 id="领域模型-1"><a href="#领域模型-1" class="headerlink" title="领域模型"></a>领域模型</h5><p>如果把表单问题做分解，其实我们可以分解出：</p>
<ul>
<li>数据管理问题</li>
<li>字段管理问题</li>
<li>校验管理问题</li>
<li>联动管理问题</li>
</ul>
<p>这几个方向的问题其实都可以作为领域级问题去解决，每一个领域问题，其实都是非常复杂的问题，在 Formily 中，全部一一给您突破解决了，所以您只需要专注于业务逻辑即可。</p>
<h5 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h5><p>因为 formily 是完全的 Typescript 项目，所以用户在 VSCode 或 WebStorm 等上开发可以获得最大化的智能提示体验</p>
<p><img src="https://img.alicdn.com/imgextra/i2/O1CN01yiREHk1X95KJPPz1c_!!6000000002880-2-tps-2014-868.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h5 id="状态可观测"><a href="#状态可观测" class="headerlink" title="状态可观测"></a>状态可观测</h5><p>安装 <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN">FormilyDevtools</a> 可以实时观测模型状态变化，排查问题</p>
<p><img src="https://img.alicdn.com/imgextra/i4/O1CN01DSci5h1rAGfRafpXw_!!6000000005590-2-tps-2882-1642.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><p><img src="https://img.alicdn.com/imgextra/i4/O1CN01HlrsLS1hQAJnihhh1_!!6000000004271-55-tps-2431-2037.svg" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从上图中我们可以看到 Formily 内核其实是一个 @formily&#x2F;reactive 领域模型。</p>
<p>实际消费领域模型则主要是依赖 @formily&#x2F;reactive 的 响应器 机制做依赖追踪来消费。</p>
<p>我们可以在响应器(Reactions)中消费 Form&#x2F;Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField 模型中的任意属性，依赖的属性发生变化，响应器就会重复执行。</p>
<p>从而实现了表单层面的 Reactive 编程模型。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p><strong>MVVM</strong>（<strong>Model–view–viewmodel</strong>）是一种 OOP 软件架构模式，它的核心是将我们的应用程序的逻辑与视图做分离，提升代码可维护性与应用健壮性。我们可以用一张图来描述：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01jiB7h723ZFf0lBCTo_!!6000000007269-55-tps-1244-432.svg" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>解释一下就是，View(视图层)负责维护 UI 结构与样式，同时负责与 ViewModel(视图模型)做数据绑定，这里的数据绑定关系是双向的，也就是，ViewModel(视图模型)的数据发生变化，会触发 View(视图层)的更新，同时视图层的数据变化又会触发 ViewModel(视图模型)的变化。Model 则更偏实际业务数据处理模型。ViewModel 和 Model 都是充血模型，两者都注入了不同领域的业务逻辑，比如 ViewModel 的业务逻辑更偏视图交互层的领域逻辑，而 Model 的业务逻辑则更偏业务数据的处理逻辑。</p>
<p>那么，Formily 解决方案在 MVVM 中应该是什么样的定位呢？</p>
<p>很明显，Formily 它提供了 View 和 ViewModel 两层能力，View 则是@formily&#x2F;react @formily&#x2F;vue，专门用来与@formily&#x2F;core 做桥接通讯的，所以，@formily&#x2F;core 的定位就是 ViewModel 层，</p>
<p>那 Model 层在哪里呢？</p>
<p>当然就是我们的实际业务代码层了，这一层 formily 就不会管了，所以这一层，用户到底是用 OOP 模式维护了一个 Model 还是用 FP 模式维护了一系列的业务逻辑函数集，formily 都不关心。</p>
<p>所以，这也使得 formily 对业务的入侵性很低，因为 formily 的目标是减少用户设计 ViewModel 的成本，让用户更加专注于业务逻辑的实现。</p>
<h4 id="FP-架构"><a href="#FP-架构" class="headerlink" title="FP 架构"></a>FP 架构</h4><p>还记得之前 React 团队用了一个最简单的表达式 <strong>UI &#x3D; fn(State)</strong> 来表达整个 React 体系吗？这样的函数式表达 UI，非常简单清晰，那会不会和 MVVM 模式产生冲突呢？</p>
<p>并不会冲突，因为在 MVVM 的模式中，View 和 ViewModel 的关系其实就约等于 <strong>UI &#x3D; fn(State)</strong> ，因为 ViewModel 是一个注入逻辑的充血模型，它与 <strong>fn(State)</strong> 都能达到相同的目标，只是它是更 OOP 的表达，只是<strong>fn(State)</strong> 是一种更加函数式的表达，将状态作为贫血模型而存在，通过一个又一个的函数，对贫血模型做 Immutable 式的更新，最终反应到 UI 上。</p>
<p>所以，从逻辑和数据分离的角度上来看，函数式表达更加清晰，只是函数式表达要求所有数据都是 Immutable 的。所以在性能要求高的场景上，采用函数式模型收益并不会太大，当然只是在 js 语言下是这样的。相反，MVVM 这种模式对数据的要求更多的是 Reactive 数据，也就是可以通过引用式操作数据的响应式数据模型，这样可以做到精确监控数据变化，最终反应到 UI 上。</p>
<p>所以，在表单场景上，MVVM 模式性能优势会更好一些，最重要的是，目前大多数存活了几十年的 GUI 产品，几乎都是不约而同的使用 MVVM，这么看来，在前端领域，函数式体系会更偏学术化一些，从实际对业务的收益来看的话，MVVM 还是首选。</p>
<h4 id="表单模型"><a href="#表单模型" class="headerlink" title="表单模型"></a>表单模型</h4><p>整个表单模型很大很复杂，分解下来其实核心是以下几个子模型：</p>
<ul>
<li>字段管理模型</li>
<li>字段模型</li>
<li>数据模型</li>
<li>联动模型</li>
<li>路径系统</li>
</ul>
<p>下面具体来讲一下表单模型是如何管理的。</p>
<h5 id="字段管理模型"><a href="#字段管理模型" class="headerlink" title="字段管理模型"></a>字段管理模型</h5><p>字段管理模型，主要包含：</p>
<ul>
<li>字段添加</li>
<li>字段查询</li>
<li>导入字段集</li>
<li>导出字段集</li>
<li>清空字段集</li>
</ul>
<p>字段添加</p>
<p>主要通过 createField&#x2F;createArrayField&#x2F;createObjectField&#x2F;createVoidField 方法来创建字段，如果字段已经存在，则不会重复创建</p>
<p>字段查询</p>
<p>主要通过 query 方法来查询字段，query 方法可以传入字段的路径或者正则表达式来匹配字段。</p>
<p>因为字段路径的详细规则还是比较复杂的，在后面的<a target="_blank" rel="noopener" href="https://core.formilyjs.org/api/entry/form-path">路径系统</a>篇中会详细讲解。</p>
<p>然后调用 query 方法会返回一个 Query 对象，Query 对象中可以有批量遍历所有字段的 forEach&#x2F;map&#x2F;reduce 方法，也可以有只取查询到的第一个字段的 take 方法，同时还有直接读取字段属性的 get 方法，还有可以深层读取字段属性的 getIn 方法，两个方法的差别就是前者可以有智能提示，后者没有提示，所以推荐用户都用 get 方法。</p>
<p>导入字段集</p>
<p>主要通过 setFormGraph 来导入字段集，入参格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，使用该 API 主要在一些需要做时间旅行的场景，将 Immutable 字段状态导入至表单模型中。</p>
<p>导出字段集</p>
<p>主要通过 getFormGraph 来导出字段集，导出格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，与导入字段集入参一致，因为返回的数据是一个 Immutable 的数据，所以是可以完全做持久化存储的，方便时间旅行。</p>
<p>清空字段集</p>
<p>主要通过 clearFormGraph 来清空字段集。</p>
<h5 id="字段模型"><a href="#字段模型" class="headerlink" title="字段模型"></a>字段模型</h5><p>字段模型主要包含了：</p>
<ul>
<li>Field 模型，主要负责管理非自增型字段状态，比如 Input&#x2F;Select&#x2F;NumberPicker&#x2F;DatePicker 这些组件</li>
<li>ArrayField 模型，主要负责管理自增列表字段状态，可以对列表项进行增删移动的。</li>
<li>ObjectField 模型，主要负责管理自增对象字段状态，可以对对象的 key 做增删操作。</li>
<li>VoidField 模型，主要负责管理虚字段状态，虚字段是一种不会污染表单数据的节点存在，但是它可以控制它的子节点显示隐藏，交互模式。</li>
</ul>
<p>因为字段模型非常复杂，所以会在后面的<a target="_blank" rel="noopener" href="https://core.formilyjs.org/guide/field">字段模型</a>篇中详细讲解。</p>
<h5 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h5><p>表单数据模型，formily 之前的版本或多或少都会存在一些边界问题，在 2.x 中重新梳理了一版，才真正把之前的遗留问题突破掉了。</p>
<p>数据模型主要包含：</p>
<ul>
<li>表单值(values)管理</li>
<li>表单默认值(initialValues)管理</li>
<li>字段值(value)管理</li>
<li>字段默认值(initialValue)管理</li>
<li>值与默认值的选择合并策略</li>
</ul>
<p>表单值管理，其实就是一个对象结构的 values 属性，只是它是一个 @formily&#x2F;reactive observable 属性，同时借助了 @formily&#x2F;reactive 的深度 observer 能力，监听了它任意属性变化，如果发生变化，便会触发 onFormValuesChange 的生命周期钩子。</p>
<p>同理，默认值管理其实也是一个对象结构的 initialValues 属性，同样会深度监听属性变化，触发 onFormInitialValues 的生命周期钩子。</p>
<p>字段值管理，是在每个数据型字段的 value 属性上体现的，formily 会给每个字段维护一个叫 path 的数据路径属性，然后 value 的读写，都是对顶层表单的 values 进行读写，这样保证了字段的值与表单的值是绝对幂等的，同理字段默认值也一样。</p>
<p>总结一下，<strong>值的管理，都是在顶层表单上管理的，字段的值与表单的值是通过 path 来实现的绝对幂等。</strong></p>
<p>值与默认值的差别其实就在于表单重置的时候，字段是否会重置为默认值状态</p>
<p>值与默认值的选择合并策略</p>
<p>平时我们在业务开发的过程中，总会有数据回显的需求，这份数据一般都是作为异步默认值，作为详情页面的话，都还好，但是作为编辑页面的话，就会存在一些问题了：</p>
<p><strong>存在冲突</strong></p>
<p>比如表单值为<code>&#123;xx:123&#125;</code>，表单默认值为<code>&#123;xx:321&#125;</code>，这里的策略是：</p>
<ul>
<li>如果xx没有相应的字段模型，代表仅仅只是冗余数据，用户无法修改<ul>
<li>如果表单值是先赋值，默认值是后赋值的，那么默认值直接覆盖表单值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据<code>&#123;xx:321&#125;</code></li>
<li>如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据<code>&#123;xx:123&#125;</code></li>
</ul>
</li>
<li>如果xx有字段模型<ul>
<li>如果表单值先赋值，默认值是后赋值的<ul>
<li>如果当前字段被用户修改过(modified 为 true)，那么默认值不能覆盖表单值，最终提交数据<code>&#123;xx:123&#125;</code></li>
<li>如果当前字段没有被用户修改过(modified 为 false)，那么默认值会直接覆盖字段值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据<code>&#123;xx:321&#125;</code></li>
</ul>
</li>
<li>如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据<code>&#123;xx:123&#125;</code></li>
</ul>
</li>
</ul>
<p><strong>不存在冲突</strong></p>
<p>比如表单值为<code>&#123;xx:123&#125;</code>，表单默认值为<code>&#123;yy:321&#125;</code>，这里的策略是直接合并。</p>
<p>总结一下，值与默认值的选择合并策略，<strong>核心是看该字段是否被用户修改过，一切以用户为准，如果没被用户修改过就以赋值顺序为准</strong></p>
<p>这里提到的默认值，是可以重复赋值的，说的也是在重复赋值的过程中，要不要舍弃值的问题。</p>
<h5 id="校验模型"><a href="#校验模型" class="headerlink" title="校验模型"></a>校验模型</h5><p>表单校验模型核心是对数据的合法性校验，然后将校验结果管理起来，所以校验模型主要包含了：</p>
<ul>
<li>校验规则管理</li>
<li>校验结果管理</li>
</ul>
<p>因为校验模型隶属于字段模型，所以会在后面的<a target="_blank" rel="noopener" href="https://core.formilyjs.org/guide/field#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99">字段模型</a>篇中详细讲解</p>
<h5 id="联动模型"><a href="#联动模型" class="headerlink" title="联动模型"></a>联动模型</h5><p>联动模型在 formily1.x 中核心是走的主动式联动模型，大致用一句表达式来表达就是：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">setFieldState</span>(<span class="hljs-title class_">Subscribe</span>(<span class="hljs-title class_">FormLifeCycle</span>, <span class="hljs-title class_">Selector</span>(<span class="hljs-title class_">Path</span>)), <span class="hljs-title class_">TargetState</span>)<br></code></pre></td></tr></table></figure>

<p>解释下就是，任意一次联动，都是基于表单的某个生命周期钩子去触发指定路径下字段的状态，这样的模型能解决很多问题，但是它也有个很明显的问题，就是在多对一联动的场景下，需要同时监听多个字段变化去控制某个字段的状态，这样对用户而言，实现成本还是比较高的，特别是实现一些计算器联动需求，代码量剧增。当然，对于一对多场景，反而这种模型又是最高效的。</p>
<p>所以，在 formily2.x 中，在主动联动模型上新增了被动联动模型，同样是一句表达式表达：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">subscribe</span>(<span class="hljs-title class_">Dependencies</span>, <span class="hljs-title class_">Reactions</span>)<br></code></pre></td></tr></table></figure>

<p>简化了很多，核心就是针对依赖数据变化做响应，依赖的数据可以是表单模型属性，也可以是任意字段模型的属性，响应的动作可以是改任意字段模型的属性，也可以是做其他异步动作。这样的模型同样是一个完备的联动模型，只是在一对多场景下，比起主动模型而言，实现成本会比较高。</p>
<p>所以，两种联动模型，需要用户根据自身需求来选择。</p>
<h5 id="路径系统-1"><a href="#路径系统-1" class="headerlink" title="路径系统"></a>路径系统</h5><p>路径系统，非常重要，几乎整个表单模型处处都有用到路径系统，它的主要给表单模型提供了以下几个能力：</p>
<ul>
<li>它可以用来从字段集中查找任意一个字段，同时支持按照规则批量查找</li>
<li>它可以用来表达字段间关系的模型，借助路径系统，我们可以实现查找某个字段父亲，能查找父亲，也就能实现树级别的数据继承能力，同样，我们也能查找某个字段的相邻节点</li>
<li>它可以用来实现字段数据的读写，带解构的数据读写</li>
</ul>
<p>整个路径系统，其实是基于@formily&#x2F;path 的路径 DSL 来实现的，想要了解更多路径系统的内容，可以详细看看<a target="_blank" rel="noopener" href="https://core.formilyjs.org/api/entry/form-path">FormPath API</a>篇</p>
<h4 id="字段模型-1"><a href="#字段模型-1" class="headerlink" title="字段模型"></a>字段模型</h4><p>Formily 的字段模型核心包含了两类字段模型：</p>
<ul>
<li>数据型字段</li>
<li>虚数据型字段</li>
</ul>
<p>数据型字段(Field)，核心是负责维护表单数据(表单提交时候的值)。</p>
<p>虚数据型字段(VoidField)，你可以理解为它就是一个阉割了数据维护能力的 Field，所以它更多的是作为容器维护一批字段的 UI 形式。</p>
<p>下面我们具体分析这两种类型字段。</p>
<h5 id="数据型字段"><a href="#数据型字段" class="headerlink" title="数据型字段"></a>数据型字段</h5><p>在 字段模型 中有 3 种数据型字段：</p>
<ul>
<li>Field</li>
<li>ArrayField</li>
<li>ObjectField</li>
</ul>
<p>ArrayField 和 ObjectField 都是继承自 Field，Field 的定位就是维护非自增型数据字段，对比 ArrayField&#x2F;Object，并不是说 Field 就不能存数组类型或者对象类型的数据，Field 其实可以存任意数据类型的数据，只是，如果用户期望实现数组的添加删除移动这样的交互，则需要使用 ArrayField，对象属性的添加删除交互，则需要使用 ObjectField，如果没有这样的需求，所有数据类型统一用 Field 即可。</p>
<p>然后咱们再看具体 Field 领域规则：</p>
<ul>
<li>路径规则</li>
<li>显隐规则</li>
<li>数据读写规则</li>
<li>数据源规则</li>
<li>字段组件规则</li>
<li>字段装饰器规则</li>
<li>校验规则</li>
</ul>
<h5 id="路径规则"><a href="#路径规则" class="headerlink" title="路径规则"></a>路径规则</h5><p>因为我们实际业务的表单结构本身就是一个树结构，所以在 Formily 中，每个字段在表单模型中都会有一个绝对路径，这个绝对路径大致描述了字段在表单数据中的位置(为什么用大致，后面会讲)，通过绝对路径可以找到任意一个字段，同时还能表达字段间的父子关系，所以字段模型中，我们定义了 address 属性来表达字段的绝对路径，主要用点语法来描述，比如 a.b.c 这样的路径代表了字段 c 的父亲是字段 b，字段 b 的父亲是 a。</p>
<p>当然，事情并没有这么简单，因为我们还有 VoidField，VoidField 作为虚数据字段，它同样也有自己的绝对路径，因为它可以作为数据字段的父亲，如果我们只有绝对路径， 就无法让一个数据字段正确的往表单数据里写入字段数据。读取数据也会读错位置。</p>
<p>所以，我们其实还需要一个数据路径作为专门用于数据字段写入数据和读取数据的，这里我们用 path 来描述字段的数据路径，大概的规则可以看看这张图：</p>
<p><img src="https://img.alicdn.com/imgextra/i1/O1CN01cdzULJ1et4PBak8si_!!6000000003928-2-tps-3506-2042.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>总结下来就是，Address 永远是代表节点的绝对路径，Path 是会跳过 VoidField 的节点路径，但是如果是 VoidField 的 Path，是会保留它自身的路径位置。</p>
<p>所以，不管是 Field 还是 VoidField，都会有它的 Address 和 Path，所以我们在用 query 方法查询字段的时候，既可以用 Address 规则查询，也可以用 Path 规则查询，比如<code>query(&quot;b.c&quot;)</code>可以查询到 c 字段，同样用<code>query(&quot;a.b.c&quot;)</code>也能查询到 c 字段。</p>
<h5 id="显隐规则"><a href="#显隐规则" class="headerlink" title="显隐规则"></a>显隐规则</h5><p>字段的显示隐藏，主要用 display 属性来表达：</p>
<ul>
<li>display 为 none 代表字段 UI 隐藏，同时不保留字段数据</li>
<li>display 为 hidden 代表字段 UI 隐藏，保留字段数据</li>
<li>display 为 visible 代表字段 UI 显示，同时恢复字段数据</li>
</ul>
<p>在 display 属性之上，我们还提供了两个便捷属性</p>
<ol>
<li>visible，如果为 true 代表 display 等于 visible，如果为 false 代表 display 等于 none</li>
<li>hidden，如果为 true 代表 display 等于 hidden，如果为 false 代表 display 等于 visible</li>
</ol>
<p>上面讲的是显隐属性的写规则，读取规则就会更复杂一些，这里有一个默认继承逻辑：</p>
<p>如果父节点主动设置了 display 属性，子节点没有主动设置 display 属性，那么子节点会继承父节点的 display</p>
<p>那什么才是主动设置 display 呢？主要包括：</p>
<ul>
<li>给字段配置了初始化属性 display&#x2F;visible&#x2F;hidden</li>
<li>如果初始化时没有配置，但是在后期又给字段设置了 display&#x2F;visible&#x2F;hidden</li>
</ul>
<p>那如果希望从不继承变为继承怎么办？把 display 设置为 null 即可。</p>
<h5 id="数据读写规则"><a href="#数据读写规则" class="headerlink" title="数据读写规则"></a>数据读写规则</h5><p>因为 Field 是数据型字段，它负责维护表单数据的某个节点的数据，这里的读取，其实是直接读取的表单数据，通过 path 属性来寻址，这样也保证了表单数据与字段数据的绝对幂等，读取的方式直接读取 value&#x2F;initialValue 即可。</p>
<p>数据写入规则与读取规则一致，Field 不会独立维护一份数据，它操作的直接就是具体表单的数据，通过 path 属性来寻址，写入的方式主要有：</p>
<ul>
<li>直接修改 value&#x2F;initialValue 属性</li>
<li>调用 onInput 会写入数据，同时设置字段的 inputValue 为入参数据，inputValues 为多参数据，然后设置 modified 属性为 true，代表该字段被手动修改过，最后触发 triggerType 为 onInput 的校验规则</li>
<li>调用 setValue 方法</li>
</ul>
<h5 id="数据源规则"><a href="#数据源规则" class="headerlink" title="数据源规则"></a>数据源规则</h5><p>考虑到字段的值来源不是只有通过 Input 输入框输入的，还有会从一个数据源中选取的，比如下拉框之类的，所以字段模型加了一个数据源的属性 dataSource，专门用于读取数据源。只是在组件消费端需要做一层映射。写入数据源的方式可以直接修改 dataSource 属性，也可以调用 setDataSource 方法</p>
<h5 id="组件规则"><a href="#组件规则" class="headerlink" title="组件规则"></a>组件规则</h5><p>字段模型，如果没有代理 UI 组件信息，那就没法实现更加精细化的联动控制了，比如 A 字段的值变化要控制 B 字段的 placeholder，那就必须将字段的属性给代理起来，所以 formily 提供了 component 属性，专门用于代理 UI 组件信息，component 是一个数组<code>[Component,ComponentProps]</code>，第一个元素代表是哪个组件，第二个代表组件的属性有哪些，为什么用数组，主要原因是这样方便类型提示，同时写法也比较简单。</p>
<p>读取组件信息的方式直接读取 component 属性即可。</p>
<p>写入组件信息的方式主要有：</p>
<ul>
<li>直接修改 component 属性，传入数组</li>
<li>调用 setComponent 方法，第一个参数是组件，第二个是组件属性</li>
<li>调用 setComponentProps 方法，直接会设置组件属性</li>
</ul>
<h5 id="装饰器规则"><a href="#装饰器规则" class="headerlink" title="装饰器规则"></a>装饰器规则</h5><p>与字段组件规则相似，字段装饰器主要用来维护字段的包裹容器，比如 FormItem，更偏 UI 布局的控制，这里我们用 decorator 属性来描述字段装饰器。</p>
<p>读取装饰器信息的方式直接读取 decorator 属性即可。</p>
<p>写入装饰器信息的方式主要有：</p>
<ul>
<li>直接修改 decorator 属性，传入数组</li>
<li>调用 setDecorator 方法，第一个参数是组件，第二个是组件属性</li>
<li>调用 setDecoratorProps 方法，直接会设置组件属性</li>
</ul>
<h5 id="校验规则"><a href="#校验规则" class="headerlink" title="校验规则"></a>校验规则</h5><p>校验规则主要包含：</p>
<ul>
<li>校验器</li>
<li>校验时机</li>
<li>校验策略</li>
<li>校验结果</li>
</ul>
<p>校验器</p>
<p>在字段模型中的校验器主要用 validator 属性描述，在字段初始化的时候可以给字段传入 validator，初始化之后也可以再次修改 validator</p>
<p>一个 validator 主要有以下几种形态：</p>
<ul>
<li>纯字符串格式校验，比如<code>&quot;phone&quot; | validator = &quot;url&quot; | validator= &quot;email&quot;</code> ，这样的格式校验是正则规则的简写形式，formily 内部提供了一些标准的正则规则，当然用户也能通过 registerValidateFormats 来手动创建规则，方便复用</li>
<li>自定义函数校验，有 3 种返回值模式：<ul>
<li><code>(value)=&gt;&quot;message&quot;</code>，返回字符串代表有错误，不返回字符串代表无错误</li>
<li><code>(value)=&gt;(&#123;type:&quot;error&quot;,message:&quot;message&quot;&#125;)</code>，返回对象形式，可以指定 type 是 error 或 warning 或 success</li>
<li><code>&#123;validator:()=&gt;false,message:&quot;message&quot;&#125;</code>，返回布尔形式，错误消息会复用对象结构的 message 字段</li>
</ul>
</li>
<li>对象结构校验，是一种更完备的表达，比如：<ul>
<li><code>&#123;format:&quot;url&quot;&#125;</code> 这样可以指定正则格式</li>
<li><code>&#123;required:true&#125;</code>这样可以指定必填</li>
<li>还有更多的规则属性可以参考 API 文档，同时我们还能通过 registerValidateRules 来注册类似的校验规则</li>
</ul>
</li>
<li>对象数组结构校验，是前面三种的组合表达，其实前 3 种，都会转换成对象数组结构，比如：<ul>
<li><code>[&quot;url&quot;,&#123;required:true&#125;,(value)=&gt;&quot;message&quot;]</code>其实相当于 <code>[&#123;format:&quot;url&quot;&#125;,&#123;required:true&#125;,&#123;validator:(value)=&gt;&quot;message&quot;&#125;]</code></li>
</ul>
</li>
</ul>
<p>校验时机</p>
<p>有些时候，我们希望某些校验规则只在聚焦或者失焦的时候触发，我们可以在每个校验规则对象中加一个 triggerType，比如<code>&#123;validator:(value)=&gt;&quot;message&quot;,triggerType:&quot;onBlur&quot;&#125;</code> 这样就可以精确的控制某个校验规则只在某个事件中执行校验，这里的 triggerType 主要有<code>&quot;onInput&quot; | &quot;onBlur&quot; | &quot;onFocus&quot;</code> ，如果调用<code>form.validate</code>，是会一次性校验所有 triggerType 的规则，如果手动调用<code>field.validate</code>，则可以在入参中指定 triggerType，不传参就会校验所有。</p>
<p>校验策略</p>
<p>有些时候，我们希望某个字段的校验策略是，执行所有校验规则的时候，如果某个校验规则校验失败则立即返回结果，我们只需要在 field 初始化的时候传入参数 validateFirst 为 true 即可，默认是 false，也就是校验失败也会继续校验，拿到的校验结果是一个数组。</p>
<p>校验结果读取</p>
<p>对于校验结果，在字段模型中主要是存放在 feedbacks 属性中的，feedbacks 是由 Feedback 对象组成的数组，每个 Feedback 的结构是：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Feedback</span> &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span> <span class="hljs-comment">//字段数据路径</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span> <span class="hljs-comment">//字段绝对路径</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span> | <span class="hljs-string">&#x27;success&#x27;</span> | <span class="hljs-string">&#x27;warning&#x27;</span> <span class="hljs-comment">//校验结果类型</span><br>  <span class="hljs-attr">code</span>: <span class="hljs-comment">//校验结果编码</span><br>  | <span class="hljs-string">&#x27;ValidateError&#x27;</span><br>    | <span class="hljs-string">&#x27;ValidateSuccess&#x27;</span><br>    | <span class="hljs-string">&#x27;ValidateWarning&#x27;</span><br>    | <span class="hljs-string">&#x27;EffectError&#x27;</span><br>    | <span class="hljs-string">&#x27;EffectSuccess&#x27;</span><br>    | <span class="hljs-string">&#x27;EffectWarning&#x27;</span><br>  <span class="hljs-attr">messages</span>: <span class="hljs-built_in">string</span>[] <span class="hljs-comment">//校验消息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>读取方式主要有 4 种：</p>
<ul>
<li>直接读取 feedbacks 属性</li>
<li>读取 errors 属性，相当于是从 feedbacks 中过滤出 type 为 error 的所有校验结果</li>
<li>读取 warnings 属性，相当于是从 feedbacks 中过滤出 type 为 warning 的所有校验结果</li>
<li>读取 successes 属性，相当于是从 feedbacks 中过滤出 type 为 success 的所有校验结果</li>
</ul>
<p>校验结果写入</p>
<p>写入方式有 3 种：</p>
<ul>
<li>调用 validate 方法，触发字段校验器执行校验动作，校验结果的 Code 统一是 Validate*&#96;<ul>
<li>调用 onInput 会触发 validate</li>
<li>调用 onFocus 会触发 validate</li>
<li>调用 onBlur 会触发 validate</li>
<li>调用 reset，并指定 validate 为 true 会触发 validate</li>
</ul>
</li>
<li>直接修改 feedbacks 属性</li>
<li>直接修改 errors 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectError</li>
<li>直接修改 warnings 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectWarning</li>
<li>直接修改 successes 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectSuccess</li>
</ul>
<p>这样的写入逻辑主要是为了防止用户修改校验结果污染本身校验器的校验结果，做严格分离，容易恢复现场。</p>
<p>校验结果查询</p>
<p>校验结果的查询主要通过 queryFeedbacks 来查询，查询的入参与 Feedback 对象一致，可以按照 type 或者 code，也可以按照路径进行过滤。</p>
<h5 id="ArrayField"><a href="#ArrayField" class="headerlink" title="ArrayField"></a>ArrayField</h5><p>ArrayField 相比于 Field，仅仅只是在继承 Field 的基础上扩展了数组相关的方法，比如 push&#x2F;pop&#x2F;insert&#x2F;move 这些，为什么要提供这些方法，它的能力不只是对字段的数据做处理，它内部还提供了对 ArrayField 子节点的状态转置处理主要为了保证字段的顺序与数据的顺序是一致。可以举个例子：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01mpGugu1QFlnfQ4qfo_!!6000000001947-2-tps-3506-1794.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>这是一个 move 调用的过程，数组元素的值会发生移动，同时对应字段的状态也会发生移动。</p>
<h5 id="ObjectField"><a href="#ObjectField" class="headerlink" title="ObjectField"></a>ObjectField</h5><p>因为 object 类型是无序的，也就不存在状态转置，所以 ObjectField 就提供了 addProperty&#x2F;removeProperty&#x2F;existProperty 3 个 API 给用户使用。</p>
<h5 id="VoidField"><a href="#VoidField" class="headerlink" title="VoidField"></a>VoidField</h5><p>VoidField 相比于 Field，主要是阉割了数据读写规则、数据源规则和校验规则，用户使用的时候，主要还是使用显隐规则和组件，装饰器规则。</p>
<p>前面讲的一系列字段领域规则，并没有提到详细的 API 使用细节，更多的是从思路上帮助用户梳理 formily，如果对 API 不熟悉的，最好先看 API 文档。</p>
<h2 id="6、基础核心库：react"><a href="#6、基础核心库：react" class="headerlink" title="6、基础核心库：react"></a>6、基础核心库：react</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>@formily&#x2F;react 的核心定位是将 ViewModel(<a target="_blank" rel="noopener" href="https://core.formilyjs.org/">@formily&#x2F;core</a>)与组件实现一个状态绑定关系，它不负责管理表单数据，表单校验，它仅仅是一个渲染胶水层，但是这样一层胶水，并不脏，它会把很多脏逻辑优雅的解耦，变得可维护。</p>
<p>@formily&#x2F;react 的架构相比于@formily&#x2F;core 并不复杂，先看架构图：</p>
<p><img src="https://img.alicdn.com/imgextra/i1/O1CN013jbRfk1l5n6N7jYH8_!!6000000004768-55-tps-2200-1637.svg" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从这张架构图中我们可以看到，@formily&#x2F;react 支持了两类用户，一类就是纯源码开发用户，他们只需要使用 Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField 组件。另一类就是基于 JSON-Schema 做动态开发的用户，他们依赖的主要是 SchemaField 组件，但是，这两类用户都需要使用一个 FormProvider 的组件来统一下发上下文。然后是 SchemaField 组件，它内部其实是依赖的 Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField 组件。</p>
<h3 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h3><p>@formily&#x2F;react 本身架构不复杂，因为它只是提供了一系列的组件和 Hooks 给用户使用，但是我们还是需要理解以下几个概念：</p>
<ul>
<li>表单上下文</li>
<li>字段上下文</li>
<li>协议上下文</li>
<li>模型绑定</li>
<li>协议驱动</li>
<li>三种开发模式</li>
</ul>
<h4 id="表单上下文"><a href="#表单上下文" class="headerlink" title="表单上下文"></a>表单上下文</h4><p>从<a target="_blank" rel="noopener" href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们可以看到 FormProvider 是作为表单统一上下文而存在，它的地位非常重要，主要用于将@formily&#x2F;core 创建出来的<a target="_blank" rel="noopener" href="https://core.formilyjs.org/zh-CN/api/models/form">Form</a>实例下发到所有子组件中，不管是在内置组件还是用户扩展的组件，都能通过<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/hooks/use-form">useForm</a>读取到<a target="_blank" rel="noopener" href="https://core.formilyjs.org/zh-CN/api/models/form">Form</a>实例</p>
<h4 id="字段上下文"><a href="#字段上下文" class="headerlink" title="字段上下文"></a>字段上下文</h4><p>从<a target="_blank" rel="noopener" href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们可以看到不管是 Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField，会给子树下发一个 FieldContext，我们可以在自定义组件中读取到当前字段模型，主要是使用<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/hooks/use-field">useField</a>来读取，这样非常方便于做模型映射</p>
<h4 id="协议上下文"><a href="#协议上下文" class="headerlink" title="协议上下文"></a>协议上下文</h4><p>从<a target="_blank" rel="noopener" href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们可以看到<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a>会给子树下发一个 FieldSchemaContext，我们可以在自定义组件中读取到当前字段的 Schema 描述，主要是使用<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/hooks/useFieldSchema">useFieldSchema</a>来读取。注意，该 Hook 只能用在<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/SchemaField">SchemaField</a>和<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a>子树中使用</p>
<h4 id="模型绑定"><a href="#模型绑定" class="headerlink" title="模型绑定"></a>模型绑定</h4><p>想要理解模型绑定，需要先理解什么是<a target="_blank" rel="noopener" href="https://core.formilyjs.org/zh-CN/guide/mvvm">MVVM</a>，理解了之后我们再看看这张图：</p>
<p><img src="https://img.alicdn.com/imgextra/i1/O1CN01A03C191KwT1raxnDg_!!6000000001228-55-tps-2200-869.svg" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>在 Formily 中，@formily&#x2F;core 就是 ViewModel，Component 和 Decorator 就是 View，@formily&#x2F;react 就是将 ViewModel 和 View 绑定起来的胶水层，ViewModel 和 View 的绑定就叫做模型绑定，实现模型绑定的手段主要有<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/hooks/use-field">useField</a>，也能使用<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/shared/connect">connect</a>和<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/shared/map-props">mapProps</a>，需要注意的是，Component 只需要支持 value&#x2F;onChange 属性即可自动实现数据层的双向绑定。</p>
<h4 id="协议驱动-1"><a href="#协议驱动-1" class="headerlink" title="协议驱动"></a>协议驱动</h4><p>协议驱动渲染算是@formily&#x2F;react 中学习成本最高的部分了，但是学会了之后，它给业务带来的收益也是很高，总共需要理解 4 个核心概念：</p>
<ul>
<li>Schema</li>
<li>递归渲染</li>
<li>协议绑定</li>
<li>三种开发模式</li>
</ul>
<h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>formily 的协议驱动主要是基于标准 JSON Schema 来进行驱动渲染的，同时我们在标准之上又扩展了一些<code>x-*</code>属性来表达 UI，使得整个协议可以具备完整描述一个复杂表单的能力，具体 Schema 协议，参考<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/shared/schema">Schema</a> API 文档</p>
<h4 id="递归渲染"><a href="#递归渲染" class="headerlink" title="递归渲染"></a>递归渲染</h4><p>何为递归渲染？递归渲染就是组件 A 在某些条件下会继续用组件 A 来渲染内容，看看以下伪代码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：object；渲染权：RecursionField)<br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;phone&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;email&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;contacts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：array；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;array&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ArrayTable&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：object；渲染权：ArrayTable组件)<br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;phone&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;email&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>@formily&#x2F;react 递归渲染的入口是<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/schema-field">SchemaField</a>，但它内部实际是使用 <a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a> 来渲染的，因为 JSON-Schema 就是一个递归型结构，所以 <a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a> 在渲染的时候会从顶层 Schema 节点解析，如果是非 object 和 array 类型则直接渲染具体组件，如果是 object，则会遍历 properties 继续用 <a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a> 渲染子级 Schema 节点。</p>
<p>这里有点特殊的情况是 array 类型的自增列表渲染，需要用户在自定义组件内使用<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a>进行递归渲染，因为自增列表的 UI 个性化定制程度很高，所以就把递归渲染权交给用户来渲染了，这样设计也能让协议驱动渲染变得更加灵活。</p>
<p>那 SchemaField 和 RecursionField 有啥差别呢？主要有两点：</p>
<ul>
<li>SchemaField 是支持 Markup 语法的，它会提前解析 Markup 语法生成<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/shared/schema">JSON Schema</a>移交给 RecursionField 渲染，所以 RecursionField 只能基于 <a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/shared/schema">JSON Schema</a> 渲染</li>
<li>SchemaField 渲染的是整体的 Schema 协议，而 RecursionField 渲染的是局部 Schema 协议</li>
</ul>
<h4 id="协议绑定"><a href="#协议绑定" class="headerlink" title="协议绑定"></a>协议绑定</h4><p>前面讲了模型绑定，而协议绑定则是将 Schema 协议转换成模型绑定的过程，因为 JSON-Schema 协议是 JSON 字符串，可离线存储的，而模型绑定则是内存间的绑定关系，是 Runtime 层的，比如<code>x-component</code>在 Schema 中是组件的字符串标识，但是在模型中的 component 则是需要组件引用，所以 JSON 字符串与 Runtime 层是需要转换的。然后我们就可以继续完善一下以上模型绑定的图：</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01jLCRxH1aa3V0x6nw4_!!6000000003345-55-tps-2200-1147.svg" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>总结下来，在@formily&#x2F;react 中，主要有 2 层绑定关系，Schema 绑定模型，模型绑定组件，实现绑定的胶水层就是@formily&#x2F;react，需要注意的是，Schema 绑定字段模型之后，字段模型中是感知不到 Schema 的，比如要修改<code>enum</code>，就是修改字段模型中的<code>dataSource</code>属性了，总之，想要更新字段模型，参考<a target="_blank" rel="noopener" href="https://core.formilyjs.org/zh-CN/api/models/field">Field</a>，想要理解 Schema 与字段模型的映射关系可以参考<a target="_blank" rel="noopener" href="https://react.formilyjs.org/api/shared/schema">Schema</a>文档</p>
<h4 id="三种开发模式"><a href="#三种开发模式" class="headerlink" title="三种开发模式"></a>三种开发模式</h4><p>从<a target="_blank" rel="noopener" href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们其实已经看到整个@formily&#x2F;react 是有三种开发模式的，对应不同用户：</p>
<ul>
<li>JSX 开发模式</li>
<li>JSON Schema 开发模式</li>
<li>Markup Schema 开发模式</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/formily/">#formily</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>formily</div>
      <div>https://yoonalis.github.io/blog/2023/10/02/formily/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2023/09/15/React%20&amp;%20TypeScript%E5%A4%87%E5%BF%98%E5%BD%95/" title="React &amp; TypeScript备忘录">
                        <span class="hidden-mobile">React &amp; TypeScript备忘录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
