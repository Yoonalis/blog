

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="比特币、以太坊">
<meta property="og:type" content="article">
<meta property="og:title" content="区块链">
<meta property="og:url" content="https://yoonalis.github.io/blog/2022/09/01/%E5%8C%BA%E5%9D%97%E9%93%BE/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="比特币、以太坊">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/blockchaincover.jpg">
<meta property="article:published_time" content="2022-09-01T11:01:03.000Z">
<meta property="article:modified_time" content="2022-05-19T02:54:06.000Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="比特币">
<meta property="article:tag" content="以太坊">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/blockchaincover.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>区块链 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="区块链"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-01 19:01" pubdate>
          2022年9月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          119 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">区块链</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>讨论：速度最慢的数据库、下一代价值互联网</p>
<h3 id="1、比特币中的密码学原理"><a href="#1、比特币中的密码学原理" class="headerlink" title="1、比特币中的密码学原理"></a>1、比特币中的密码学原理</h3><p>比特币又称加密货币，用到了密码学上的哈希和签名</p>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>密码学上的哈希函数cryptographic hash function两个重要性质：</p>
<ul>
<li>collision resistance，两个不同的输入算出来的哈希值相等，称为哈希碰撞，哈希碰撞无法避免，这里是指没有高效的方法人为制造哈希碰撞。<ul>
<li>MD5曾经是很流行的哈希函数，但现在已经知道如何人为制造哈希碰撞了。</li>
</ul>
</li>
<li>hiding：哈希函数的计算过程是单向的，不可逆的。无法通过哈希值反推输入的内容，哈希值没有泄露输入的信息。</li>
<li>二者结合在一起，可以实现：digital commitment&#x2F;digital equivalent of a sealed envelope，但要注意，需要输入空间足够大、输入分布要尽量均匀。输入空间不够大时，可以给输入值后面拼接随机数再一起取hash，以保证输入随机且分布均匀。</li>
<li>比特币中用到的哈希函数还要求第三个性质：puzzle friendly。<ul>
<li>挖矿：寻找随机数nonce，拼接到block header，使得$H(\text {block header}) \le target$，需要大量的计算，挖矿很难、验证很容易（difficult to solve, but easy to verify）。</li>
</ul>
</li>
</ul>
<p>比特币中的哈希函数叫做<code>SHA-256</code>。</p>
<h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>开账户：在本地创立一个公钥和私钥的对（public key, private key)，这就代表了一个比特币的账户，公私钥的概念来自非对称的加密体系（asymmetric encryption algorithm）</p>
<ul>
<li>对称加密体系需要安全的网络环境，不能以明文形式在网络上传输，密钥的分发不是很方便。</li>
<li>非对称加密体系：加密用公钥、解密用私钥，公钥可以公开。</li>
</ul>
<p>比特币系统是不加密的，信息都是公开的，公私钥的作用主要就是签名， 发起交易时用自己的私钥签名，其他人用公钥验证，证明交易来自本人。</p>
<p>生成公私钥的过程要是随机的，比特币中每一次签名时也要有好的随机源，一次随机源不好就有可能泄露私钥。</p>
<h3 id="2、比特币的数据结构"><a href="#2、比特币的数据结构" class="headerlink" title="2、比特币的数据结构"></a>2、比特币的数据结构</h3><p>哈希指针（hash pointers）：存地址+hash值。（找到位置，检测是否有被篡改）</p>
<p><strong>区块链：</strong></p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" srcset="/blog/img/loading.gif" lazyload alt="区块链的数据结构"></p>
<p>取hash时，是将前一个区块的内容（包括保存的hash值）一起取hash，通过这个数据结构可以实现tamper-evident log：只要记住系统里保存的最后一个hash值，就可以检测出对区块链任何部位的修改。</p>
<p><strong>Merkle tree：</strong></p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).jpg" srcset="/blog/img/loading.gif" lazyload alt="merkle tree"></p>
<p>用hash指针代替了普通的指针。记住根hash值，就能检测出对数中任何节点的修改，效率更高。每个区块分为两部分：块头和块身。</p>
<ul>
<li>block header：仅存储这个区块所包含的所有交易组成的merkle tree组成的根hash值。</li>
<li>block body：有交易列表。</li>
</ul>
<p>Merkle tree的用途：</p>
<ul>
<li><p>提供merkle proof：从需验证的交易往上找到根节点，这个路径上的节点就是merkle proof，从下往上验证，沿途的这些hash值都是正确的就行了。</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/e65b588da577865af9a1ad6b7339f89.png" srcset="/blog/img/loading.gif" lazyload alt="merkle proof"></p>
</li>
<li><p>proof of membership&#x2F;proof of inclusion：$O(log(n))$</p>
</li>
<li><p>proof of non-membership：$O(n)$</p>
</li>
<li><p>Sorted merkle tree：对hash值排序</p>
</li>
</ul>
<blockquote>
<p>hash指针不适用于有环的情况，会出现数据相互依赖从而没有一个区块的数据能定下来。</p>
</blockquote>
<h3 id="3、比特币协议"><a href="#3、比特币协议" class="headerlink" title="3、比特币协议"></a>3、比特币协议</h3><p>使用公私钥发行货币：double spending attack</p>
<p>使用编号，每次使用货币向央行验证归属：央行超负荷（中心化方案）</p>
<p>将央行的职能改为由用户共同承担（去中心化方案）</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(3).jpg" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (3)"></p>
<p>比特币系统中每个交易都包含了输入和输出两个部分，输入部分要给出币的来源，输出部分要给出收款人公钥的hash。</p>
<p>付款人的公钥是付款人交易时给出，但可能为伪造，为了验证交易真实，使用付款人给出的公钥和币的来源时的公钥核对。（有借必有贷、借贷必相等）</p>
<ul>
<li><p>block header：保存宏观信息</p>
<ul>
<li>version 使用比特币哪个版本的协议</li>
<li>hash of previous block header 区块链中指向前一个区块的指针</li>
<li>Merkle root hash merkle tree的根hash值</li>
<li>target 挖矿的难度目标阈值</li>
<li>nonce 随机数</li>
</ul>
</li>
<li><p>block body：保存交易数据</p>
<ul>
<li>transaction list 交易列表</li>
</ul>
</li>
</ul>
<p>系统中的节点分为全节点(full node)和轻节点(light node)，全节点保存区块链的所有信息，验证每一个交易，也叫fully validating node，轻节点只保存block header，一般来说，轻节点无法独立验证交易的合法性。系统中大部分节点是轻节点，不参与区块链的构造和维护，只是利用区块链的信息做查询等。</p>
<p>账本的内容要取得分布式的共识 distributed consensus：系统里有很多台机器，共同维护一个全局的hash表（distributed hash table）。</p>
<p>分布式系统有很多不可能结论，例FLP impossibility result：在一个异步(asynchronous)的系统里(网络传输时延没有上限)，那么即使只有一个成员是有问题的(faulty)，那么也不可能取得共识。</p>
<p>CAP Theorem：一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)，这三个性质中最多只能满足两个，不可能三个都满足。</p>
<p>分布式共识的一个重要协议：Paxos(确保一致性)</p>
<p>比特币中的共识协议：有些节点可能是有恶意的，假设系统中大多数节点是好的。</p>
<ul>
<li><p>使用投票：需要先确定谁有投票权(membership)，例如联盟链(hyperledger fabric)，只有某些符合条件的大公司才可以加入，此时基于投票的方案是可行的。但比特币产生账户是很容易的，不需要批准，只有跟外部发生交易时才知道有这个账户存在，可能受到女巫攻击(sybil attack)。</p>
</li>
<li><p>比特币中的解决方案：用计算力来投票。</p>
<ul>
<li><p>每个节点都可以在本地组装出一个候选区块，把他认为合法的交易放在区块里，然后尝试各种nonce值(4 bytes)，看哪一个能满足不等式要求，求出hash落在指定范围内，如果某个节点找到了符合要求的nonce，就获得了记账权，也即往比特币这个去中心化的系统里写入下一个区块的权力，只有找到nonce，获得记账权的节点才有资格发布下一个区块。</p>
</li>
<li><p>其他节点收到这个区块后，要验证这个区块的合法性(验证block header的内容是否正确；目标阈值的编码——nBits域，检查nBits域是否符合比特币协议中规定的难度要求；检查nonce是否使$H(\text {block header}) \le target$成立)，假设都符合要求，然后看block body里的交易列表，验证每个交易都是合法的(要有合法的签名；以前没有被花过)，如果有任何一个不符合要求，那么这个区块是不能被接收的，要被放弃掉。</p>
</li>
<li><p>最长合法链 longest vaild chain：假设有一个区块经过检查，都是符合要求的，但如果不在最长链上，也有可能不被接收。比特币协议中规定：接受的区块应该是在扩展最长合法链。（分叉攻击的例子forking attack：通过往中间插入区块，来回滚已经发生了的交易）</p>
<ul>
<li>如果两个节点在差不多同一个时间找到了符合要求的nonce，都可以发布区块，这时候会出现两个等长的分叉，按最长合法链原则，这两个都是合法的。</li>
<li>比特币中，缺省情况下，每个节点是接收它最早收到的那个。</li>
<li>等长的临时性的分叉可能会维持一段时间，直到最后有某个区块是胜出的，也即沿着这个区块往下扩展，其他分支又被称为orphan block。</li>
</ul>
</li>
<li><p>获得记账权的节点本身有一定权利，可以决定哪些交易被写到下个区块里，但是设计协议时不应该让这个成为争夺记账权的主要动力，因为凡是合法的交易，都应该能被写到区块链里。</p>
<ul>
<li><p>出块奖励 block reward 比特币协议中规定，获得记账权的节点在发布的区块里，可以有一个特殊的交易，即铸币交易，在这个交易里可以发布一定数量的比特币。</p>
</li>
<li><p>coinbase transaction 是比特币系统中发行新比特币的唯一方法，其他所有的交易都只是把已有的比特币把一个账户转移到另一个账户，包括用法币购买比特币，也没有产生新的比特币。</p>
</li>
<li><p>比特币刚上线时，每一个发布的区块可以产生50BTC，21万个区块之后，这个出块奖励就要减半，即25BTC，再过21万个区块，再次减半，即12.5BTC。</p>
<blockquote>
<p>21万个区块平均是4年，每隔4年出块奖励减半。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上即是比特币里的共识机制。</p>
<h3 id="4、比特币系统的实现"><a href="#4、比特币系统的实现" class="headerlink" title="4、比特币系统的实现"></a>4、比特币系统的实现</h3><p>比特币采取基于交易的账本模式 transaction-based ledger，每个区块里记录的是交易信息，有转账交易、有铸币交易，但是系统中没有显式的记录每个账户有多少钱，需要经过交易记录来推算。</p>
<p>比特币中的全节点要维护一个UTXO的数据结构(Unspent Transaction Output)——还没有被花出去的交易的输出组成的集合。一个交易可能有多个输出，Utxo中的每个元素要给出产生这个输出的交易的hash值，以及它在这个交易里是第几个输出。新发起的交易是否合法，要查询Utxo，只有在这个集合里才是合法的，维护Utxo以便快速检测double spending。</p>
<p>每个交易可以有多个输入，也可以有多个输出，所有输入的金额加起来要等于输出的金额。</p>
<blockquote>
<p> 有时可能不等，涉及到比特币系统的第二个激励机制：transaction fee</p>
</blockquote>
<p>以太坊采取基于账户的模式 account_based ledger，这个模式之中，系统要显式的记录每个账户上有多少个币。</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/e905bb6edc2ab35cd4c40a7b8616245.png" srcset="/blog/img/loading.gif" lazyload alt="e905bb6edc2ab35cd4c40a7b8616245"></p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/62f9439c6b117abb1d982f4a890709a.png" srcset="/blog/img/loading.gif" lazyload alt="62f9439c6b117abb1d982f4a890709a"></p>
<blockquote>
<p>求hash时只用到了block header的内容，block header里有merkle tree的根hash值，这已经能保证整个区块里的交易是不能被篡改的。</p>
</blockquote>
<h4 id="挖矿过程的概率分析"><a href="#挖矿过程的概率分析" class="headerlink" title="挖矿过程的概率分析"></a>挖矿过程的概率分析</h4><p>挖矿即不断尝试nonce，求解puzzle，每次尝试nonce可以看做是一个伯努利实验Bernoulli trial（a random experiment with binary outcome），大量尝试这个过程，构成了一个Bernoulli process（a sequence of independent Bernoulli trials），具有无记忆性（memoryless）。</p>
<p>每次尝试nonce，成功的可能性很小，需要尝试大量的nonce，才有可能找到符合要求的，这个情况下，Bernoulli process可以用Poisson process来近似（实验的次数很多，每次实验成功的概率很小）。</p>
<p>出块时间服从指数分布（exponential distribution），整个系统的平均出块时间是10min，这个平均时间是比特币协议设计出来的，通过定期调整挖矿难度，使得平均出块时间维持在10min左右，具体到每一个矿工，能挖到下一个区块的时间，取决于这个矿工的算力占系统总算力的百分比。出块时间的分布也是无记忆的，将来还要挖多少时间跟过去已经挖了多少时间是没有关系的，仍然服从指数分布，平均还是要10min，这个性质也成progress free（过去的progress是没有用的）。</p>
<blockquote>
<p>如果没有这个特点，算力强的矿工会有不成比例的优势，这恰恰是挖矿公平性的保证。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/1.png" srcset="/blog/img/loading.gif" lazyload alt="1"></p>
<h4 id="比特币的总量"><a href="#比特币的总量" class="headerlink" title="比特币的总量"></a>比特币的总量</h4><p>出块奖励是系统中产生新的比特币的唯一途径。而出块奖励每隔四年减半，这样产生的比特币数量就构成了一个几何序列（geometric series）：$21万<em>50+21万</em>25+21万<em>12.5+\dots &#x3D; 21万</em>50*(1+\frac 1 2+\frac 1 4+\dots ) &#x3D; 21万<em>50</em>2 &#x3D;210万$</p>
<p>比特币的puzzle除了比拼算力之外，没有其他的实际意义，比特币越来越难挖到是因为出块奖励被人为的减少了，比特币的稀缺性是人为造成的。</p>
<p>但是，挖矿的过程对于维护比特币系统的安全性是至关重要的：Bitcoin is secured by mining。对于一个去中心化的，没有membership控制的系统来说，挖矿提供了一种凭借算力投票的有效手段，只要大部分算力掌握在诚实的节点手里，比特币的安全性就能得到保证，挖矿这个过程虽然表面上看没有实际意义，但是这个机制的设立对于维护整个系统的安全性是非常有效的。</p>
<h4 id="比特币安全性分析"><a href="#比特币安全性分析" class="headerlink" title="比特币安全性分析"></a>比特币安全性分析</h4><p>假设大部分算力掌握在诚实的矿工手里，是否能保证写入区块链的交易都是合法的？</p>
<ul>
<li><p>恶意节点伪造交易：没有对方的私钥无法签名。</p>
</li>
<li><p>定义有恶意的攻击是否成功的标准，是看他能不能让诚实的节点接受这个交易，如果仅是恶意节点之间互相认账，诚实节点都不认账，那是没有用的，因为比特币是扩展最长合法链，恶意的区块相当于作废，这对于攻击者来说会损失出块奖励。（&#x3D;&#x3D;这里老师讲的是恶意节点多长都没有用，可如果这个节点本来是诚实的，他后面延伸了很多节点，后来它变成恶意的了，这条链不再扩展，那么它后面的诚实链会受到影响吗？&#x3D;&#x3D;）</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(0).jpg" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (0)"></p>
</li>
<li><p>能否把已经花出去的币再花一遍？</p>
</li>
<li><p>区块插在哪个位置，是要在刚开始挖矿时就要决定的，因为设置的block header里要填前一个区块的hash，如果想插在某个节点之后，一开始就要把该节点设置为前一个区块，而不是等获得了记账权之后再说。防范双花攻击的办法是多等几个区块&#x2F;确认，比特币协议中缺省要等六个confirmation，此时才认为前面一个交易是不可篡改的，平均出块时间10min，这个过程要等一个小时。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/4.jpg" srcset="/blog/img/loading.gif" lazyload alt="4"></p>
<ul>
<li><p>零确认 zero confirmation：这个转账交易发布出去，但还没有被写入区块链。比特币中缺省的设置是节点接收最先听到的交易；实际交易天然有时间间隔。</p>
</li>
<li><p>恶意节点是否能故意不把合法的交易写在区块链？</p>
</li>
<li><p>可以，但合法的交易可以写在下一个区块里，总有诚实的节点愿意发布这些交易，比特币协议规定，区块的大小有限制，最多不能超过1M字节，所以如果交易太多，有些交易就只能等到下一个区块再发布。</p>
</li>
<li><p>是否可以隐藏算好的区块，等到交易目标达成再同时发布，以超越已形成的区块&#x2F;confirmation，成为最长链？（selfish mining）</p>
</li>
<li><p>正常的情况是挖到区块马上发布，以免被其他人挖到损失奖励，这个攻击成功的前提是需要占到很大的算力。（不可能越级挖，因为每个块需要前一个块的hash，前面一个区块没挖出来，没办法提前准备好）</p>
<blockquote>
<p>selfish mining 的另一个目的：减少竞争。</p>
<p>藏一个块，用两个块竞争，但也有风险，还是拼算力。</p>
</blockquote>
</li>
</ul>
<h3 id="5、比特币网络"><a href="#5、比特币网络" class="headerlink" title="5、比特币网络"></a>5、比特币网络</h3><p>用户把交易发布到比特币网络上，节点收到这些交易把他们打包到区块里，然后把区块发布到比特币网络上，这些新发布的交易和区块在比特币网络上如何传播？</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/5.jpg" srcset="/blog/img/loading.gif" lazyload alt="5"></p>
<p>比特币网络的设计原则：简单、鲁棒而非高效。</p>
<p>消息以flooding的方式传播：节点第一次收到消息时，将它传播给其他邻居节点，同时记录已收到这个消息，下次再收到这个消息，就不再转发给邻居节点，邻居节点的选取是随机的，不考虑底层的拓扑结构，鲁棒性很强，但牺牲了效率。</p>
<p>比特币系统中每个节点要维护一个等待上链交易的集合，第一次听到某个交易时，把这个交易写入集合，并且转发这个交易，再收到这个交易就不转发，转发的前提是交易合法（有合法的签名，以前没有被花过）。</p>
<p>集合中的交易一旦写入区块链，就要从集合中删掉，如果因为某个区块链里的交易导致集合里出现了非法交易，也要删除非法交易。</p>
<blockquote>
<p>risk condition：有两个有冲突的交易，差不多同时被广播到网络上，那么每个节点因为在网络上的位置不同，先收到的交易不同。</p>
</blockquote>
<p>新发布的区块在网络上的传播方式跟新发布的交易是类似的，每个节点除了检查区块的内容的合法性，还要检查它是否在最长合法链上，越是大的区块在网络上的传播速度就越慢。</p>
<p>best effort：一个交易发布到比特币网络上，不一定所有的节点都能收到，而且不同的节点收到交易的顺序也可能是不一样的，网络传播存在延迟，且有的节点不一定按照比特币协议的要求进行转发，也有的节点可能转发不合法的交易，这是一个去中心化的系统中面临的实际问题。</p>
<h3 id="6、比特币的挖矿难度调整"><a href="#6、比特币的挖矿难度调整" class="headerlink" title="6、比特币的挖矿难度调整"></a>6、比特币的挖矿难度调整</h3><p>挖矿：不断尝试block header里的nonce值，使整个block header的哈希值小于等于给定的目标阈值。即$H(\text{block header}) \le target$。$target$越小，挖矿难度越大，调整挖矿难度就是调整目标空间在整个输出空间中所占的比例。</p>
<p>比特币用的哈希算法是SHA-256，产生的哈希值是256位，所以整个输出空间是$2^{256}$个可能的取值，调整这个比例就是哈希值前面有多少个0（不准确）。</p>
<p>出块时间太短会出现的问题：</p>
<ul>
<li>分叉会成为常态，分叉过多，对于不利于系统达成共识，也危害系统安全（比特币协议假设大部分算力掌握在诚实的矿工手里，系统的总算力越强，安全性越好）。恶意节点可以集中算力扩展成最长合法链。</li>
</ul>
<p>比特币协议中规定：每隔2016个区块，要重新调整目标阈值，大概是每两个星期调整一下（$\frac {2016<em>10} {60</em>24} &#x3D; 14天$）。具体调整方式为$target &#x3D; target * \frac {\text{actual time}} {\text{experted time}}$，目标阈值增大最多增大4倍，不会超过4倍；目标阈值缩小最多缩小$\frac 1 4$，不会超过$\frac 1 4$。</p>
<p>计算$target$的方法是写在比特币系统的代码里，每挖到2016个区块会自动进行调整，代码开源，如果$target$被恶意修改，诚实的矿工不会承认。</p>
<ul>
<li>nBits域：$target$编码的版本，在block header里没有直接存储$target$，因为需要256位&#x2F;32个字节，而nBits只有4个字节，可以认为是一个压缩编码，如果没有按规则调整$target$，检查区块合法性就无法通过，因为每个节点要独立验证发布的区块的合法性。</li>
</ul>
<h3 id="7、比特币挖矿"><a href="#7、比特币挖矿" class="headerlink" title="7、比特币挖矿"></a>7、比特币挖矿</h3><p>全节点</p>
<ul>
<li>一直在线</li>
<li>在本地硬盘上维护完整的区块链信息</li>
<li>在内存里维护UTXO集合，以便快速检验交易的正确性</li>
<li>监听比特币网络上的交易信息，验证每个交易的合法性</li>
<li>决定哪些交易会被打包到区块里</li>
<li>监听别的矿工挖出来的区块，验证其合法性</li>
<li>挖矿<ul>
<li>决定验证哪条链挖下去</li>
<li>当出现等长的分叉的时候，选择哪一个分叉</li>
</ul>
</li>
</ul>
<p>轻节点</p>
<ul>
<li>不是一直在线</li>
<li>不用保存整个区块链，只要保存每个区块的块头（1000倍）</li>
<li>不用保存全部交易，只保存与自己相关的交易</li>
<li>无法校验大多数交易的合法性，只能校验与自己相关的那些交易的合法性</li>
<li>无法检测网上发布的区块的正确性</li>
<li>可以验证挖矿的难度</li>
<li>只能检测哪个是最长链，不知道哪个是最长合法链</li>
</ul>
<p>比特币怎么保证安全性</p>
<ul>
<li>密码学上的保证：没有私钥，就无法伪造签名，不能将他人账上的前转走，前提是，系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受那些没有合法签名的交易，如果没有这一点，密码学上的保证就没有用武之地。</li>
<li>共识机制</li>
</ul>
<p>挖矿设备</p>
<ul>
<li><p>趋于专业化：CPU挖矿（通用计算机、笔记本电脑）→ GPU挖矿（主要用于大规模的并行计算，例如深度学习，大量的矩阵乘法） → ASIC芯片（application specific integrated circulation）</p>
</li>
<li><p>大型矿池的出现：单个矿工即使用了ASIC芯片，挖矿从平均收益上看是有利可图的，但是收益是非常不稳定的，除了挖矿外，单个矿工还要承担全节点的其他责任。矿池就是把矿工组织起来成为一个整体，矿石的架构是一个全节点会驱动很多矿机。</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/6.jpg" srcset="/blog/img/loading.gif" lazyload alt="6"></p>
<p>矿工只负责计算哈希值，全节点的其他职责都由pool manager来承担（监听网上的交易、把交易组织打包成候选区块、是否有其他节点抢先发布区块，有的话要进行调整）。</p>
<p>矿池的出现解决了收入不稳定的问题，收入分配时，矿主以矿工提交的较简单的almost valid block作为share的数量为依据进行分配。</p>
<p>是否会出现矿工挖到矿后不提交给矿池，自己独占奖励？</p>
<ul>
<li>不可行，每个矿工的任务是有矿主分配的，矿主负责组装好区块，然后交给矿工尝试nonce，光是调整nonce是不够的，还要调整coinbase，矿主可能把不同的coinbase对应的nonce值的范围交给不同的矿工尝试，coinbase transaction的地址填的是矿主的地址，所以矿工挖到区块后不提交给矿主，自己提交是无用的。</li>
</ul>
<p>大型矿池的一个弊病：51%的攻击更容易了（分叉攻击、双花攻击、Boycott封锁某个账户）。类似云计算里的on demand computing，此处为on demand mining，矿石带来的潜在危害。</p>
</li>
</ul>
<h3 id="8、比特币脚本"><a href="#8、比特币脚本" class="headerlink" title="8、比特币脚本"></a>8、比特币脚本</h3><p>唯一能访问的内存空间就是堆栈，所以是基于栈的语言。</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/fb118d0f3f3f69f20c421b3b978ce13.jpg" srcset="/blog/img/loading.gif" lazyload alt="fb118d0f3f3f69f20c421b3b978ce13"></p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/a44e90b2b47b4759d5d81b91b166c8f.jpg" srcset="/blog/img/loading.gif" lazyload alt="a44e90b2b47b4759d5d81b91b166c8f"></p>
<blockquote>
<p>每个输入都要说明这个输入的币来自之前哪个交易的输出，前两行给出输入的币的来源，第三项是输入脚本，给出signature证明有权力花这个钱。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/2175087397b6f48030dd2daf87dc210.jpg" srcset="/blog/img/loading.gif" lazyload alt="2175087397b6f48030dd2daf87dc210"></p>
<blockquote>
<p>scriptPublicKey是输出脚本，asm是输出脚本内容，包含一系列操作，reqSigs表示这个输出需要多少个签名才能兑现，type是输出的类型，这里表示公钥的哈希，addresses是输出的地址。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/df1c2ac503eaaa4ca31f23169e91964.jpg" srcset="/blog/img/loading.gif" lazyload alt="df1c2ac503eaaa4ca31f23169e91964"></p>
<blockquote>
<p>输出脚本要与输入脚本匹配</p>
</blockquote>
<p>输入输出脚本的形式</p>
<ul>
<li><p>P2PK(Pay to Public Key)</p>
<ul>
<li><p>input script</p>
<ul>
<li>PUSHDATA(Sig)</li>
</ul>
</li>
<li><p>output script</p>
<ul>
<li>PUSHDATA(PubKey)&#x2F;&#x2F;输出脚本里直接给出收款人的公钥。</li>
<li>CHECKSIG&#x2F;&#x2F;检查签名，在输入脚本里直接检查签名，签名是用私钥对输入脚本所在的整个交易的签名，是最简单的。</li>
</ul>
</li>
<li><p>实例：</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/9f2bc3262d66508b9926191b78f1d49.jpg" srcset="/blog/img/loading.gif" lazyload alt="9f2bc3262d66508b9926191b78f1d49"></p>
</li>
</ul>
</li>
<li><p>P2PKH(Pay to Public Key Hash)</p>
<ul>
<li><p>input script</p>
<ul>
<li>PUSHDATA(Sig)&#x2F;&#x2F;把签名压入栈</li>
<li>PUSHDATA(Public)&#x2F;&#x2F;把公钥压入栈</li>
</ul>
</li>
<li><p>output script</p>
<ul>
<li>DUP&#x2F;&#x2F;把栈顶元素复制一遍(栈顶为两个公钥)</li>
<li>HASH160&#x2F;&#x2F;把栈顶元素弹出来，取哈希，然后把得到的哈希值压入栈(栈顶为公钥的哈希值)(输入脚本里给出的公钥)</li>
<li>PUSHDATA(PubKeyHash)&#x2F;&#x2F;把输出脚本里提供的公钥的哈希值压入栈(收款人的公钥的哈希)</li>
<li>EQUALVERIFY&#x2F;&#x2F;弹出栈顶两个元素是否相等，防止冒名顶替</li>
<li>CHECKSIG&#x2F;&#x2F;弹出栈顶的两个元素，用公钥检查签名</li>
</ul>
</li>
<li><p>实例</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/0223bb1d47a9820801fef7d25ca796d.jpg" srcset="/blog/img/loading.gif" lazyload alt="0223bb1d47a9820801fef7d25ca796d"></p>
</li>
</ul>
</li>
<li><p>P2SH(Pay to Script Hash)</p>
<ul>
<li><p>采用BIP16的方案</p>
</li>
<li><p>input script</p>
<ul>
<li><p>……</p>
</li>
<li><p>PUSHDATA(Sig)</p>
</li>
<li><p>……</p>
</li>
<li><p>PUSHDATA(serialized redeemScript)</p>
</li>
</ul>
</li>
<li><p>output script</p>
<ul>
<li>HASH160</li>
<li>PUSHDATA(redeemScriptHash)(赎回脚本)</li>
<li>EQUAL</li>
</ul>
</li>
<li><p>input script要给出一些签名（数目不定）及一段序列化的redeemScript，验证分为如下两步：</p>
<ul>
<li>验证序列化的redeemScript是否与output script中的哈希值匹配</li>
<li>反序列化并执行redeemScript，验证input script中给出的签名是否正确</li>
</ul>
</li>
<li><p>redeemScript的形式</p>
<ul>
<li>P2PK形式</li>
<li>P2PKH形式</li>
<li>多重签名形式</li>
</ul>
</li>
<li><p>例：用P2SH实现P2PK</p>
<ul>
<li>redeemScript<ul>
<li>PUSHDATA(PubKey)</li>
<li>CHECKSIG</li>
</ul>
</li>
<li>input script<ul>
<li>PUSHDATA(Sig)</li>
<li>PUSHDATA(serialized redeemScript)</li>
</ul>
</li>
<li>output script<ul>
<li>HASH160</li>
<li>PUSHDATA(redeemScriptHash)</li>
<li>EQUAL</li>
</ul>
</li>
</ul>
</li>
<li><p>P2SH的一个常见场景是对多重签名的支持</p>
<ul>
<li><p>比特币系统中一个输出可能性需要多个签名才能把钱取出来</p>
</li>
<li><p>最早的多重签名，目前已不推荐使用</p>
<ul>
<li>input script<ul>
<li>X&#x2F;&#x2F;需要多压一个没用的元素，已对应CHECKMULITISIG的bug</li>
<li>PUSHDATA(Sig_1)</li>
<li>PUSHDATA(Sig_2)</li>
<li>……</li>
<li>PUSHDATA(Sig_M)</li>
</ul>
</li>
<li>outputScript<ul>
<li>M</li>
<li>PUSHDATA(pubkey_1)</li>
<li>PUSHDATA(pubkey_2)</li>
<li>……</li>
<li>PUSHDATA(pubkey_N)</li>
<li>N</li>
<li>CHECKMULTISIG</li>
</ul>
</li>
</ul>
</li>
<li><p>用P2SH实现多重签名</p>
<ul>
<li>把输出脚本的复杂度转移到输入脚本</li>
<li>redeemScript<ul>
<li>M</li>
<li>PUSHDATA(pubkey_1)</li>
<li>PUSHDATA(pubkey_2)</li>
<li>……</li>
<li>PUSHDATA(pubkey_N)</li>
<li>N</li>
<li>CHECKMULTISIG</li>
</ul>
</li>
<li>input script<ul>
<li>X</li>
<li>PUSHDATA(Sig_1)</li>
<li>PUSHDATA(Sig_2)</li>
<li>……</li>
<li>PUSHDATA(Sig_M)</li>
<li>PUSHDATA(serialized RedeemScript)</li>
</ul>
</li>
<li>output script<ul>
<li>HASH160</li>
<li>PUSHDATA(RedeemScriptHash)</li>
<li>EQUAL</li>
</ul>
</li>
</ul>
</li>
<li><p>实例</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/3694329da6ab2de67074e3d6382151d.jpg" srcset="/blog/img/loading.gif" lazyload alt="3694329da6ab2de67074e3d6382151d"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Proof of Burn</p>
<ul>
<li><p>output script</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs script">RETURN //无条件返回错误，包含这个操作的脚本永远不可能通过验证<br>	[zero or more ops or test]<br></code></pre></td></tr></table></figure>

<p>这种形式的output被称为：Provably Unspendable&#x2F;Prunable Outputs</p>
</li>
<li><p>脚本说明</p>
<p>假如有一个交易的input指向这个output，无论input里的input script如何设计，执行到RETURN命令之后都会直接但会false，不会执行RETURN后面的其他指令，所以这个output无法再被花出去，其对应的UTXO也就可以被剪枝了，无需保存。</p>
<p>应用场景：</p>
<ul>
<li><p>这个脚本是证明销毁比特币的一种方法，有些小币种要求销毁一定数量的比特币才能得到这个币种（AltCoin）。</p>
</li>
<li><p>在区块链里添加需要永久保存的内容，如digital commitment，把某项知识产权的内容取hash后，把hash值放在RETURN语句的后面，不会占很大的内容，也不会泄露知识产权的内容，应对知识产权的纠纷。</p>
<blockquote>
<p>coinbase域里也可以随意写内容，且不用销毁比特币，但只有获得记账权的节点才能用。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：简单起见，所有的操作都省略了OP_前缀，例：OP_CHECKSIG、OP_DUP</p>
<p>比特币的脚本语言不支持循环，就不会有死循环</p>
</blockquote>
<h3 id="9、比特币分叉"><a href="#9、比特币分叉" class="headerlink" title="9、比特币分叉"></a>9、比特币分叉</h3><p>分叉的原因：两个节点差不多同时挖到矿，会出现临时性的分叉（state fork）；分叉攻击（forKing attack&#x2F;deliberate fork）；比特币的协议发生了改变，去中心化的系统中升级软件没办法保证所有节点都升级（protocal fork），根据对协议修改的内容的不同，又可分为硬分叉（hard fork）和软分叉（soft fork）。</p>
<p>硬分叉：对比特币协议增加一些新的特性，这时候没有升级软件的旧的节点不认可这些特性，认为这些特性非法。一个例子是比特币协议中的区块大小限制（block size limit），某些新节点改为了4M，旧节点依然是1M，只要旧节点不更新软件，这个分叉就不会消失。出现hard fork后变成了两条平行的链，彼此之间有各自的加密货币（社区分裂），分叉前的链理论上分叉后的链都会认，但会出现问题，后来分裂的链会带一条chain Id。</p>
<blockquote>
<p>目前区块大小限制</p>
<p>$\frac {1000000} {250} &#x3D; 4000$   $\frac {4000} {60*10} &#x3D; 7 tx&#x2F;s$</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/7.jpg" srcset="/blog/img/loading.gif" lazyload alt="7"></p>
<p>软分叉：对比特币协议加一些限制，原来合法的交易&#x2F;区块，在新的协议中可能变得不合法。例某些新节点将区块大小限制改为了0.5M，旧节点依然是1M，因为新旧节点都认可的是0.5M的分叉，所以之后所有节点都会在0.5M的链上扩展，迫使其更新协议，系统不会有永久性的分叉。</p>
<p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(4).jpg" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (4)"></p>
<p>实际可能出现软分叉的情况：给某些目前协议中没有规定的域增加一些新的含义，赋予新的规则，例coinbase域，有时会把coinbase域的前八个字节也作为extra nonce，使搜索空间从$2^{32}$变成$2^{96}$，作为挖矿难度，剩下的字节如何用？有人提出作为UTXO的根哈希值。</p>
<p>比特币历史上一个比较著名的软分叉的例子是P2SH(Pay to Script Hash)，这个功能在最初的比特币版本上是没有的，是通过软分叉的方法加进去的。</p>
<h3 id="10、问答"><a href="#10、问答" class="headerlink" title="10、问答"></a>10、问答</h3><h5 id="Q1：转账交易时，接收者不在线怎么办"><a href="#Q1：转账交易时，接收者不在线怎么办" class="headerlink" title="Q1：转账交易时，接收者不在线怎么办"></a>Q1：转账交易时，接收者不在线怎么办</h5><p>不需要接收者在线，转账交易只是在区块链上记录把自己账户上的比特币转过去，是不是当时连在比特币网络是没关系的。</p>
<h5 id="Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的"><a href="#Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的" class="headerlink" title="Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的"></a>Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的</h5><p>可能的，比特币账户在创建的时候是不需要通知其他人的，在本地产生公私钥对就可以了，只有在以后产生收款地址，第一次收到钱，其他节点才知道这个账户的存在。</p>
<h5 id="Q3：账户的私钥丢失了怎么办"><a href="#Q3：账户的私钥丢失了怎么办" class="headerlink" title="Q3：账户的私钥丢失了怎么办"></a>Q3：账户的私钥丢失了怎么办</h5><p>账户上的钱变成了死钱，永远取不出来，但是有些加密货币的交易所是中心化的机构，在交易所开办账户一般来说是需要提供身份证明的，这种情况下，把比特币放在交易所，私钥是交易所保管的，登录交易所类似登录银行，这种情况下丢失了密码可以跟交易所练习，通过身份验证重置密码（不是密钥），有些在线钱包也有保管私钥的功能（Mt.Gox）。</p>
<h5 id="Q4：私钥泄露了怎么办"><a href="#Q4：私钥泄露了怎么办" class="headerlink" title="Q4：私钥泄露了怎么办"></a>Q4：私钥泄露了怎么办</h5><p>尽快把账户上的钱转移到另一个安全账户上。</p>
<h5 id="Q5：转账时写错了地址怎么办"><a href="#Q5：转账时写错了地址怎么办" class="headerlink" title="Q5：转账时写错了地址怎么办"></a>Q5：转账时写错了地址怎么办</h5><p>没有办法取消已经发布的交易，转到别人的地址或者不存在的地址都无法拿回比特币，如果转到不存在的地址，全节点会永久的把这个地址保存在UTXO里，这对全节点是不友好的。</p>
<h5 id="Q6：OP-RETURN是无条件返回错误，为什么能写在区块链里"><a href="#Q6：OP-RETURN是无条件返回错误，为什么能写在区块链里" class="headerlink" title="Q6：OP_RETURN是无条件返回错误，为什么能写在区块链里"></a>Q6：OP_RETURN是无条件返回错误，为什么能写在区块链里</h5><p>进行验证时，是当前交易的输入脚本和币的来源的输出脚本拼在一起看能不能顺利执行，这个执行过程是不可以发生错误的，如果抛出错误就不是合法交易，但OP_RETURN是写在当前交易的输出脚本，所以验证当前交易合法性时，不会执行这个语句。有人想花这笔钱时才会执行到这个交易的输出脚本。</p>
<p>&#x3D;&#x3D;那么这个输出脚本与下一个输入脚本拼和时会验证不通过吗&#x3D;&#x3D;</p>
<h5 id="Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）"><a href="#Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）" class="headerlink" title="Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）"></a>Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）</h5><p>发布的区块里有coinbase transaction，里面有收款人地址，是挖到矿的矿工的地址，偷答案要把这个地址换成自己的地址，一旦换掉，coinbase transaction的内容就发生了改变，这样会导致这个merkle tree的根hash会变化，会导致block header的内容发生变化，原来找到的nonce就作废了，所以不可能偷答案。</p>
<h5 id="Q8：事先怎么知道交易费要给哪个矿工"><a href="#Q8：事先怎么知道交易费要给哪个矿工" class="headerlink" title="Q8：事先怎么知道交易费要给哪个矿工"></a>Q8：事先怎么知道交易费要给哪个矿工</h5><p>事先不需要知道哪个矿工会得到交易费，交易费的计算是<code>total inputs - total outputs</code>，矿工挖到矿后，可以把区块里包含的交易的差额都收集起来，作为自己的交易费。</p>
<h3 id="11、比特币的匿名性"><a href="#11、比特币的匿名性" class="headerlink" title="11、比特币的匿名性"></a>11、比特币的匿名性</h3><p>有可能破坏比特币匿名性：</p>
<ul>
<li>地址账户可能被关联</li>
<li>比特币跟实体世界发生联系时，可能泄露真实身份</li>
<li>用比特币做支付</li>
</ul>
<p>网络层的匿名性：TOR（多路径转发&#x2F;洋葱路由）</p>
<p>应用层的匿名性：coin mixing（交易所、在线钱包）</p>
<p>不可篡改性对隐私保护是灾难性的</p>
<h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h4><p>概念：一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是争取的外的任何信息。</p>
<p>数学基础：同态隐藏</p>
<ul>
<li>如果x,y不同，那么它们的加密函数值E(x)和E(y)也不相同（应不会出现碰撞）</li>
<li>给定E(x)的值，很难反推出x的值</li>
<li>给定E(x)和E(y)的值，我们可以很容易地计算出某些关于x,y的加密函数值<ul>
<li>同态加法：通过E(x)和E(y)计算出E(x+y)的值</li>
<li>同态乘法：通过E(x)和E(y)计算出E(xy)的值</li>
<li>扩展到多项式</li>
</ul>
</li>
</ul>
<p>例子：Alice想要向Bob证明他知道一组数使得x+y&#x3D;7，同时不让Bob知道x和y的具体数值</p>
<ul>
<li><p>简单的版本</p>
<ul>
<li><p>Alice把E(x)和E(y)的数值发给Bob</p>
</li>
<li><p>Bob通过收到的E(x)和E(y)计算出E(x+y)的值</p>
</li>
<li><p>Bob同时计算E(7)的值，如果E(x+y) &#x3D; E(7)，那么验证通过，否则验证失败</p>
<blockquote>
<p>虽然Bob无法从E(x)知道x的值，但是可以遍历x的各种取值，所以在复杂场景下，Alice将值给Bob之前，要做一些随机化处理，但要保证x+y依然不变。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>盲签</p>
<ul>
<li>用户A提供SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款</li>
<li>用户A把SerialNum和Token交给B完成交易</li>
<li>用户B拿SerialNum和Token给银行验证，银行验证通过，增加B的存款</li>
<li>银行无法把A和B联系起来</li>
<li>中心化</li>
</ul>
<p>零币和零钞</p>
<ul>
<li>零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码保证</li>
<li>零币(zerocoin)系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务</li>
<li>零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行</li>
</ul>
<h3 id="12、比特币引发的思考"><a href="#12、比特币引发的思考" class="headerlink" title="12、比特币引发的思考"></a>12、比特币引发的思考</h3><p><strong>Q1：指针保存的是本地内存的地址，只是在本地计算机上才有意义，在其他计算机上就没有意义了，那么在发送区块的时候，哈希指针是怎么通过网络传输</strong></p>
<p>哈希指针只是一种形象的说法，实际用的时候只有哈希没有指针，全节点一般是把这些区块存储在(key,value)数据库里，key是区块的哈希，value是区块的内容，一个常用的(key,value)数据库是level DB，区块链这种链表结构实际上是在level DB里面用哈希指针串起来的，只要掌握了最后一个区块的哈希指针，就可以通过level DB来查找key对应的value就可以把最后一个区块的内容取出来，这个区块的块头又有指向前一个区块的哈希指针，一步步往前找，最终能把整个区块链找出来。</p>
<p>有些节点没有保存完整的区块链的信息，只保存了最近的几千个区块，如果需要用到前面区块的信息，可以问其他的全节点要，哈希指针的性质保证了整个区块的内容是不可篡改的。</p>
<p><strong>Q2：区块恋：n个人保存私钥的n个部分</strong></p>
<p>任何一人丢失，都可能导致无法取出钱。</p>
<p>截断私钥的做法会降低账户的安全性，比特币系统中每个账户的安全性与所用的私钥的长度是相关的。</p>
<p>多个人的共享账户不建议用共享私钥的办法，建议用多重签名。</p>
<p><strong>Q3：理论上，分布式系统中取得共识是不可能的，比特币系统如何绕过分布式共识中的那些不可能结论。</strong></p>
<p>严格来说，比特币没有取得真正的共识，因为取得的共识随时可能被推翻，例如分叉攻击，但是理论上的不可能结论，实际中不一定适用，理论可能只针对某种特定的模型。</p>
<p><strong>Q4：比特币的稀缺性</strong></p>
<p>总量固定&#x2F;稀缺的东西其实是不适合货币的，一个好的货币要有通货膨胀的功能。</p>
<p><strong>Q5：量子计算</strong></p>
<p>量子计算离实用还差得很远；比特币中并没有把账户的公钥直接暴露出来，而是用公钥取hash后得到一个地址（取hash不同于加密，可能造成信息的损失，hash函数一般是不可逆的）；</p>
<blockquote>
<p>未完待续。。。。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="category-chain-item">区块链</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E6%AF%94%E7%89%B9%E5%B8%81/">#比特币</a>
      
        <a href="/blog/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/">#以太坊</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>区块链</div>
      <div>https://yoonalis.github.io/blog/2022/09/01/区块链/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/" title="实训总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">实训总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2022/08/12/react/" title="react">
                        <span class="hidden-mobile">react</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
