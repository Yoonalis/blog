

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="动态规划、随机化算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法设计">
<meta property="og:url" content="https://yoonalis.github.io/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="动态规划、随机化算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/algorithm.jpg">
<meta property="article:published_time" content="2022-09-01T11:01:03.000Z">
<meta property="article:modified_time" content="2022-05-14T06:33:08.000Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="随机化算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/algorithm.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>算法设计 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法设计"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-01 19:01" pubdate>
          2022年9月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          41k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          338 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法设计</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><p><strong>教学内容</strong></p>
<ul>
<li><p>NP难问题的近似算法：NP难问题没有多项式时间精确算法，除非P&#x3D;NP，如何在多项式时间内寻找近似最优解。</p>
</li>
<li><p>在线算法：输入缺乏先验，随着时间的推移分别在线到达。如何设计算法，使性能和事先拥有全部信息的算法相近。</p>
</li>
<li><p>流式算法：解决在严重存储限制下的大型数据集上的问题，例如在高速网络环境中，</p>
</li>
<li><p>博弈论算法：输入由许多不同利益不同的参与者控制，</p>
</li>
</ul>
<p><strong>课程目标</strong></p>
<ul>
<li><p>巩固利用计算思维求解复杂问题的能力，掌握定量的问题分析、设计和程序实现的方法。</p>
</li>
<li><p>掌握基本的算法实现技能，进一步学习掌握算法开发方法。</p>
</li>
<li><p>掌握从具体问题出发独立查阅各种途径的资料来分析解决问题的能力。</p>
</li>
<li><p>掌握分析和建立计算机领域的问题模型的能力， 提高按照规范编写程序，培养良好的程序设计习惯。</p>
</li>
</ul>
<p><strong>科学范式</strong></p>
<ul>
<li>实验归纳：人类早期的科学实践，以记录描述自然现象为主要特征，称为“实验科学”（第一范式） </li>
<li>模型推演：科学家尝试简化模型，去掉干扰，留下关键因素，通过演算进行归纳总结（第二范式） </li>
<li>仿真模拟：随着计算机仿真越来越多成熟，可以逐渐取代实验，成为科研的常规方法（第三范式） </li>
<li>数据密集型科学发现：随着数据的爆炸性增长，计算机将不仅仅能做模拟仿真，还能进行分析总结，得到理论（第四范式）</li>
</ul>
<h3 id="1、三柱-x2F-四柱汉诺塔-x2F-动态规划"><a href="#1、三柱-x2F-四柱汉诺塔-x2F-动态规划" class="headerlink" title="1、三柱&#x2F;四柱汉诺塔&#x2F;动态规划"></a>1、三柱&#x2F;四柱汉诺塔&#x2F;动态规划</h3><h4 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h4><p>用递归树可视化递归过程</p>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-14_204251.png" srcset="/blog/img/loading.gif" lazyload alt="2022-04-14_204251"></p>
<p>分治算法的主定理：$T(n) &#x3D; aT(\frac n b +cn^k)$</p>
<ul>
<li>若$a &gt; b^k$，则$T(n)&#x3D;O(n^{log_ba})$</li>
<li>若$a &#x3D; b^k$，则$T(n) &#x3D; O(n^klog_bn)$</li>
<li>若$a &lt; b^k$，则$T(n) &#x3D; O(n^k)$</li>
</ul>
<h4 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h4><p>1883年由爱德华·卢卡斯提出</p>
<p>问题描述：由三个木桩和一组n个直径不同的圆盘组成，这些圆盘可以堆叠在木桩上。初始情况是圆盘按大小顺序堆放在一个木桩上，最大的在底部。规则为允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的顶部。目标是以最少的移动次数将所有圆盘转移到另一个目标木桩上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输出移动方式，用num存储移动次数，暴力解</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi3</span>(<span class="hljs-params">n,A,B,C</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    三柱汉诺塔</span><br><span class="hljs-string">    A:初始柱 B:过渡柱 C:目标柱</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;disk[<span class="hljs-subst">&#123;n&#125;</span>]: from <span class="hljs-subst">&#123;A&#125;</span> to <span class="hljs-subst">&#123;C&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        hanoi3(n-<span class="hljs-number">1</span>, A, C, B)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;disk[<span class="hljs-subst">&#123;n&#125;</span>]: from <span class="hljs-subst">&#123;A&#125;</span> to <span class="hljs-subst">&#123;B&#125;</span>&#x27;</span>)<br>        hanoi3(n-<span class="hljs-number">1</span>, B, A, C)<br><br><span class="hljs-comment">#测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-string">&#x27;主程序&#x27;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># num = 0</span><br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        hanoi3(n, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)<br>        <span class="hljs-built_in">print</span>(num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; ---END--- &#x27;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="四柱汉诺塔"><a href="#四柱汉诺塔" class="headerlink" title="四柱汉诺塔"></a>四柱汉诺塔</h4><p>当我们有大于3根柱子的时候，如何移动才能最优？</p>
<p>Frame-Stewart算法</p>
<ul>
<li>使用4根柱子将最上面的k个盘片移到一个临时柱子</li>
<li>使用剩余的3根柱子将剩余的盘片移到目标柱子</li>
<li>使用4根柱子将k个盘片从临时柱子移到目标柱子</li>
</ul>
<p>优化问题：如何选择最优的k？</p>
<ul>
<li>动态规划：存在重叠子问题</li>
<li>是否存在解析解？</li>
</ul>
<h3 id="2、四柱汉诺塔的最优解法-x2F-高楼扔鸡蛋"><a href="#2、四柱汉诺塔的最优解法-x2F-高楼扔鸡蛋" class="headerlink" title="2、四柱汉诺塔的最优解法&#x2F;高楼扔鸡蛋"></a>2、四柱汉诺塔的最优解法&#x2F;高楼扔鸡蛋</h3><h4 id="解四柱汉诺塔"><a href="#解四柱汉诺塔" class="headerlink" title="解四柱汉诺塔"></a>解四柱汉诺塔</h4><p>公式：$M_4(n)&#x3D;2M_4(n-k)+M_3(k)$</p>
<p>初始条件：$M_4(1)&#x3D;1$ and $M_3(k)&#x3D;2^k-1$</p>
<blockquote>
<p>解释：先用四柱的方式将上<code>n-k</code>个盘子放在某过渡柱上，再用三柱的方式将下<code>k</code>个盘子放在目标柱上，再用四柱的方式将过渡柱上的<code>n-k</code>个盘子放在目标柱上</p>
<p>$M_4(n)$：以四柱的方式放n个盘子最少需要多少次</p>
<p><code>n</code>：需要放的盘子总数</p>
<p><code>k</code>：以三柱的方式放多少个盘子</p>
</blockquote>
<p>引出问题：<code>k</code>如何取值？</p>
<p>暴力：对于输入k，遍历k&#x3D;1…n的结果，取遍历出的最小值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4</span>(<span class="hljs-params">n</span>):<br>    m = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>        tmp = <span class="hljs-number">2</span>*hanoi4(n-i) + math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &lt; m:<br>            m = tmp<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(m)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-string">&#x27;主程序&#x27;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        <span class="hljs-built_in">print</span>(hanoi4(n))<br></code></pre></td></tr></table></figure>



<p>优化方式：用一个数组来存储计算过的$M_4(n-k)$的值，遍历时优先查表</p>
<table>
<thead>
<tr>
<th>$n$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>$M_3$</td>
<td>1</td>
<td>3</td>
<td>7</td>
<td>15</td>
<td>31</td>
<td>63</td>
<td>127</td>
<td>255</td>
<td>511</td>
<td>1023</td>
</tr>
<tr>
<td>$M_4$</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>9</td>
<td>13</td>
<td>17</td>
<td>25</td>
<td>33</td>
<td>41</td>
<td>49</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 带备忘录的解法</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4_memo</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">global</span> memo<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> memo[n] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>): <span class="hljs-keyword">return</span> memo[n]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>        tmp = <span class="hljs-number">2</span>*hanoi4_memo(n-i) + math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &lt; memo[n]:<br>            memo[n] = <span class="hljs-built_in">int</span>(tmp)<br>    <span class="hljs-keyword">return</span> memo[n]<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        memo = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)]*(n+<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(hanoi4_memo(n))<br></code></pre></td></tr></table></figure>



<p>最优解：</p>
<p>三角形数：$t_k &#x3D; \frac{k(k+1)}{2}$ 也即<code>1,3,6,10,15,21</code></p>
<table>
<thead>
<tr>
<th>$k$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>$t_k$</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>10</td>
<td>15</td>
<td>21</td>
<td>28</td>
</tr>
</tbody></table>
<p>令$M(t_k) &#x3D; 2M(t_{k-1}) + 2^k-1$ ，初始条件$M(1)&#x3D;1$</p>
<blockquote>
<p>Frame和Stewart证明：</p>
<p>若$n&#x3D;t_k$，最优选择就是k；</p>
<p>当$t_{k-1} &lt; n &lt; t_k$时，<code>k-1</code>和<code>k</code>都是最优解。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dp数组的迭代解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4_dp</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 得到三柱汉诺塔的最少次数列表</span><br>    hanoi3 = [<span class="hljs-number">0</span>]*n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hanoi3[i] = <span class="hljs-built_in">int</span>(math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)-<span class="hljs-number">1</span>)<br>    dp = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 计算四柱汉诺塔</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 得到使用三柱方法的柱数k</span><br>        k=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i):<br>            <span class="hljs-keyword">if</span> i &lt;= j*(j+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>: <br>                k = j<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 算四柱的dp数组</span><br>        dp[i]=<span class="hljs-number">2</span>*dp[i-k]+hanoi3[k]<br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure>



<h4 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h4><p>问题描述：n层楼，k个鸡蛋，算最少的尝试次数，找到鸡蛋恰好摔碎的那层楼（以下都不碎，以上都会碎）</p>
<p>注：n,k至少为1，最坏情况：鸡蛋破碎一定发生在搜索空间穷尽时</p>
<p>条件：n层楼、k个鸡蛋</p>
<p>选择：去哪层楼扔</p>
<p>条件发生变化：在第i层扔下鸡蛋后</p>
<p>鸡蛋碎了：<code>k=k-1</code>，搜索区间<code>[1,i-1]</code>共<code>i-1</code>层</p>
<p>鸡蛋没碎：<code>k</code>不变，搜索区间<code>[i+1,n]</code>共<code>n-i</code>层</p>
<p>分别遍历两种可能，然后选择次数更多的一个（较差的情况下），加上初始扔的一次，就是初始在i层楼扔下鸡蛋需要的尝试次数。</p>
<p>用i遍历n，找出初始在每层楼需要的尝试次数，取最小值，即为所求次数。</p>
<blockquote>
<p>解题思路：</p>
<p>1、定义F(n,k)：n层楼，k个鸡蛋时，至少要扔几次鸡蛋</p>
<p>2、状态转移方程： $F(n,k)&#x3D;min_{1\le i\le n}(max(F(n-i,k),F(i-1,k-1))+1)$</p>
<p>3、base case： $F(0,x)&#x3D;0,F(x,1)&#x3D;x$</p>
</blockquote>
<p>暴力解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># n:楼层数，k:鸡蛋数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eggDrop</span>(<span class="hljs-params">n,k</span>):<br>    res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        tmp = <span class="hljs-built_in">max</span>(eggDrop(n-i,k),eggDrop(i-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>))+<span class="hljs-number">1</span><br>        res = <span class="hljs-built_in">min</span>(res,tmp)<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n,k=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入楼层数和鸡蛋数，用逗号隔开：&quot;</span>))<br>        <span class="hljs-built_in">print</span>(eggDrop(n,k))<br></code></pre></td></tr></table></figure>



<p>优化：添加备忘录消除重叠子问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># n:楼层数，k:鸡蛋数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop</span>(<span class="hljs-params">n,k</span>):<br>    memo = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">n,k</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 避免重复计算</span><br>        <span class="hljs-keyword">if</span> (n,k) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(n,k)]<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 穷举所有的可能</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">max</span>(dp(n-i,k),dp(i-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>)<br>        memo[(n,k)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> dp(n,k)<br></code></pre></td></tr></table></figure>



<p>优化：二分搜索代替线性搜索优化for循环</p>
<p>思路：<code>dp(n,k)</code>这个函数，当<code>k</code>固定时，是关于<code>n</code>单调递增的（鸡蛋数量固定时，楼层越多，需要的尝试次数越多），于是将<code>dp(n-i,k)</code>和<code>dp(i-1,k-1)</code>看做关于<code>i</code>的函数，所以<code>dp(n-i,k)</code>是关于<code>i</code>单调递减，<code>dp(i-1,k-1)</code>是关于<code>i</code>单调递增。</p>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/d2253affeade7b0d8c4128c5e193ab0.jpg" srcset="/blog/img/loading.gif" lazyload alt="d2253affeade7b0d8c4128c5e193ab0"></p>
<p>于是，问题便成了求二者的交点，可以用二分查找来寻找这个点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop2</span>(<span class="hljs-params">n,k</span>):<br>    memo = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">n,k</span>):<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">if</span> (n,k) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(n,k)]<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 用二分代替线性搜索</span><br>        low, high = <span class="hljs-number">1</span>, n<br>        <span class="hljs-keyword">while</span> low &lt;= high:<br>            mid = (low + high) // <span class="hljs-number">2</span><br>            broken = dp(mid-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>) <span class="hljs-comment"># 碎</span><br>            non_broken = dp(n-mid,k) <span class="hljs-comment"># 没碎</span><br>            <span class="hljs-comment"># res = min(max(碎，没碎) +1)</span><br>            <span class="hljs-keyword">if</span> broken &gt; non_broken:<br>                high = mid-<span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">min</span>(res,broken+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                low = mid+<span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">min</span>(res, non_broken+<span class="hljs-number">1</span>)<br>        memo[(n,k)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> dp(n,k)<br></code></pre></td></tr></table></figure>



<p>优化：重新定义状态转移</p>
<p>定义：k：鸡蛋数，m：最少扔鸡蛋次数，dp(k,m)：最高楼层数</p>
<p>鸡蛋碎了：测楼下</p>
<p>鸡蛋没碎：测楼上</p>
<p>总的楼层数 &#x3D; 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</p>
<p>状态转移方程：<code>dp[k][m] = dp[k][m-1] + dp[k-1][m-1] + 1</code></p>
<p><code>dp[k][m-1]</code>：楼上的楼层数</p>
<p><code>dp[k-1][m-1]</code>：楼下的楼层数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 重新定义状态转移方程</span><br><span class="hljs-comment"># k:鸡蛋数 m:最少扔鸡蛋次数</span><br><span class="hljs-comment"># 函数返回结果: 最高楼层数</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop3</span>(<span class="hljs-params">k,m</span>):<br>    dp = np.zeros((k+<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> dp[k][m] &lt; m:<br>        n+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>):<br>            dp[i][n] = dp[i][n-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> dp[k][m]<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        k,m=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入鸡蛋数和最少扔鸡蛋次数，用逗号隔开：&quot;</span>))<br>        <span class="hljs-built_in">print</span>(superEggDrop3(k,m))<br>        <br><span class="hljs-comment"># 该方程一个10*9的dp数组如下</span><br>[[   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>    <span class="hljs-number">8</span>    <span class="hljs-number">9</span>   <span class="hljs-number">10</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">6</span>   <span class="hljs-number">10</span>   <span class="hljs-number">15</span>   <span class="hljs-number">21</span>   <span class="hljs-number">28</span>   <span class="hljs-number">36</span>   <span class="hljs-number">45</span>   <span class="hljs-number">55</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">14</span>   <span class="hljs-number">25</span>   <span class="hljs-number">41</span>   <span class="hljs-number">63</span>   <span class="hljs-number">92</span>  <span class="hljs-number">129</span>  <span class="hljs-number">175</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">30</span>   <span class="hljs-number">56</span>   <span class="hljs-number">98</span>  <span class="hljs-number">162</span>  <span class="hljs-number">255</span>  <span class="hljs-number">385</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">62</span>  <span class="hljs-number">119</span>  <span class="hljs-number">218</span>  <span class="hljs-number">381</span>  <span class="hljs-number">637</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">126</span>  <span class="hljs-number">246</span>  <span class="hljs-number">465</span>  <span class="hljs-number">847</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">254</span>  <span class="hljs-number">501</span>  <span class="hljs-number">967</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">255</span>  <span class="hljs-number">510</span> <span class="hljs-number">1012</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">255</span>  <span class="hljs-number">511</span> <span class="hljs-number">1022</span>]]<br></code></pre></td></tr></table></figure>



<h4 id="思考题：最长上升子序列"><a href="#思考题：最长上升子序列" class="headerlink" title="思考题：最长上升子序列"></a>思考题：最长上升子序列</h4><p>问题描述：给定一个无序的整数数组，找到其中最长的上升子序列（不一定连续）的长度。</p>
<p>定义dp数组：<code>dp[i]</code>表示以<code>nums[i]</code>这个数结尾的最长递增子序列的长度。</p>
<p>根据这个定义，最终结果应为dp数组中的最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">nums</span>):<br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>)<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp)):<br>        res = <span class="hljs-built_in">max</span>(res,dp[i])<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        nums=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入序列：&quot;</span>)<br>        <span class="hljs-built_in">print</span>(lengthOfLIS(nums))<br></code></pre></td></tr></table></figure>



<h4 id="思考题：背包问题（组合优化）"><a href="#思考题：背包问题（组合优化）" class="headerlink" title="思考题：背包问题（组合优化）"></a>思考题：背包问题（组合优化）</h4><p>0-1背包</p>
<h3 id="3、马尔科夫链-x2F-最长上升子序列-x2F-背包问题-x2F-贪婪算法"><a href="#3、马尔科夫链-x2F-最长上升子序列-x2F-背包问题-x2F-贪婪算法" class="headerlink" title="3、马尔科夫链&#x2F;最长上升子序列&#x2F;背包问题&#x2F;贪婪算法"></a>3、马尔科夫链&#x2F;最长上升子序列&#x2F;背包问题&#x2F;贪婪算法</h3><h4 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h4><ul>
<li>以一维可数集为索引的离散随机变量：$X&#x3D;\left{X_n|n&gt;0\right}$</li>
<li>随机变量的取值为一个可数集（状态空间）的元素：$X &#x3D; s_i,s_i\in s$</li>
<li>满足马尔科夫性质：$p(X_{t+1} | X_t,…X_1) &#x3D; p(X_{t+1} | X_t)$</li>
</ul>
<h4 id="隐马尔科夫模型（HMM）"><a href="#隐马尔科夫模型（HMM）" class="headerlink" title="隐马尔科夫模型（HMM）"></a>隐马尔科夫模型（HMM）</h4><ul>
<li>状态不能直接观察，但是可以生成一个可以测量的输出对象</li>
<li>输出是一个依赖于状态的随机变量</li>
<li>应用：语音识别、自然语言处理</li>
<li>关键问题与算法<ul>
<li>评估问题：前向算法（给观测序列<code>O</code>，）</li>
<li>解码问题：Viterbi算法</li>
<li>学习问题：向前向后算法</li>
</ul>
</li>
</ul>
<p><strong>模型表达：2个状态集合和3个概率矩阵</strong></p>
<ol>
<li>隐含状态 $S$</li>
<li>可观测状态 $O$</li>
<li>初始状态概率矩阵 $\pi$</li>
<li>隐含状态转移概率矩阵 $A$</li>
<li>观测状态转移概率矩阵 $B$</li>
</ol>
<p>总结：一般的，可以用 $\lambda &#x3D; (A,B,\pi)$ 三元组来简洁的表示一个隐马尔科夫模型。 隐马尔可夫模型实际上是标准马尔可夫模型的扩展，添加了可观测状态集合和这些状态与隐含状态之间的概率关系。</p>
<blockquote>
<p>例：盒子模球实验</p>
<p>有三个盒子，编号分别为1号、2号和3号，每个盒子里有个数不等的黑球和白球：</p>
<ul>
<li>1号：黑球2个，白球8个</li>
<li>2号：黑球6个，白球4个</li>
<li>3号：黑球4个，白球6个</li>
</ul>
<p>据此可得<strong>观测概率矩阵</strong>：$$B&#x3D;\begin{pmatrix} 0.2 &amp; 0.8 \ 0.6 &amp; 0.4 \ 0.4 &amp; 0.6 \end{pmatrix}$$</p>
<p>实验过程：</p>
<p>每次随机出现一个盒子，然后从随机出现的盒子中随机摸一个球，记录下求得颜色，然后把球放回盒子。重复以上。</p>
<p>试验过程中，我们只能在每次摸出球后看到被摸出的球的颜色（可观测状态），但无法知道每次随机出现的盒子的编号（隐含状态）。</p>
<p>记录<strong>可观测状态</strong>：$O&#x3D;\left{黑，黑，白，白，白，黑，黑\right}$</p>
<p>假定第一次个盒子出现的概率分布为：1号0.3，2号0.5，3号0.2</p>
<p>可得<strong>初始状态概率矩阵：</strong> $\pi &#x3D; (0.3,0.5,0.2)^T$</p>
<p>提炼<strong>隐含状态转移概率矩阵：</strong> $ A &#x3D; \begin{bmatrix} 0.4 &amp; 0.4 &amp; 0.2 \ 0.3 &amp; 0.2 &amp; 0.5 \ 0.2 &amp; 0.6 &amp; 0.2 \end{bmatrix}$</p>
<blockquote>
<p>李姐状态转移矩阵：第一行：随机到1号后，再次随机，1号出现的概率是0.4，2号出现的概率是0.4，3号出现的概率是0.2。以此类推。</p>
</blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19633865/answer/1635328825">https://www.zhihu.com/question/19633865/answer/1635328825</a></p>
</blockquote>
<p><strong>主要关注：viterbi算法</strong></p>
<ul>
<li>最大似然解码：给定观察到的信道输出，找到最有可能的输入。</li>
<li>广泛应用于通信系统中，用于解码由有限状态过程编码的数据序列</li>
<li>求解：$maxP(1|0,\theta)$</li>
</ul>
<h4 id="动态规划的要素"><a href="#动态规划的要素" class="headerlink" title="动态规划的要素"></a>动态规划的要素</h4><p>状态：需要保留的信息是什么？</p>
<p>状态转移：信息交换与更新的过程</p>
<p>权重与损失函数：局部评价指标、最终目标</p>
<p>优化过程：寻找最优解</p>
<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>暴力：共$2^n$个子序列</p>
<p>老师讲的解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS2</span>(<span class="hljs-params">nums</span>):<br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[i] <span class="hljs-keyword">and</span> dp[j] &lt; dp[i]+<span class="hljs-number">1</span>:<br>                dp[j] = dp[i] + <span class="hljs-number">1</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp)):<br>        <span class="hljs-keyword">if</span> dp[i] &gt; res:<br>            res = dp[i]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>



<h4 id="背包问题：组合优化"><a href="#背包问题：组合优化" class="headerlink" title="背包问题：组合优化"></a>背包问题：组合优化</h4><p>问题描述：容量重量有限，求价值最大的方案</p>
<blockquote>
<p>Knapsack Problem是NP难问题，没有多项式时间解</p>
</blockquote>
<p><strong>0-1背包问题</strong></p>
<p><strong>问题描述：</strong></p>
<p>N件物品可放入背包，第i件物品的重量为w[i]，价值为v[i]。要求在总重量不超过上限W的情况下，装入背包的物品价值最大。</p>
<p>0-1决策：装或者不装</p>
<p>确定目标函数，指示函数d(i) &#x3D; {0,1}</p>
<p>$max_d \sum_{i&#x3D;1}^N d(i)V(i)$, subject to $\sum d(i)W(i) \leq W$</p>
<p>假设W，W(i)离散</p>
<p>已知条件：装了多少件物品，还可以装多重的东西</p>
<p>考虑的依据：不超过重量限制时，选择下一件物品使总价值最大</p>
<p><strong>解题思路：</strong></p>
<p>构建一个二维表<code>V[i][j]</code>：在重量限制<code>j</code>时，选择了<code>&#123;1,2，...，i&#125;</code>件物品的最大价值</p>
<p>表的上限<code>V[N][W]</code>：装<code>N</code>件物品，重量<code>W</code></p>
<p>分析状态转移：第<code>i</code>件物品要么装入背包，要么不装入背包</p>
<p>装入背包：<code>V[i][j] = V[i-1][j-W[i]] + v[i]</code></p>
<p>不装入背包：<code>V[i][j] = V[i-1][j]</code></p>
<p>决策依据：$V[i][j] &#x3D; max(V[i-1][j], V[i-1][j-W[i]] + v[i])$</p>
<p><strong>背包问题解的优化：</strong></p>
<p>伪多项式时间<code>O(NW)</code></p>
<p>进一步分析，不需要显式表示物品序号，可简化为一维表：</p>
<p><code>i</code>为不同的重量限制，<code>j</code>遍历每个物品</p>
<p>$V[i] &#x3D; max_j(V[i], V[i-w[j]]+v[j])$，其中，$V[W] &#x3D; 0$</p>
<blockquote>
<p><strong>一种解法（二维数组）</strong></p>
<p>&#x3D;&#x3D;step1：明确【状态】和【选择】&#x3D;&#x3D;</p>
<p>状态：【背包的容量】、【可选择的物品】</p>
<p>选择：【装进背包】、【不装进背包】</p>
<p>套框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">1</span>的所有取值:<br>&gt;<span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">2</span>的所有取值:<br>&gt;<span class="hljs-keyword">for</span> ...<br>dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>,选择<span class="hljs-number">2</span>,...)<br></code></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;step2：明确dp数组的定义&#x3D;&#x3D;</p>
<p>dp数组即描述问题局面的一个数组，上节明确了本题有两个状态，也就是说需要一个二维的dp数组，一维是可选择的物品，一维是背包的容量。</p>
<p>于是对dp数组定义：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][w]</code>。</p>
<p>根据这个定义，我们最终想求的答案就是<code>dp[N][W]</code>，base case为<code>dp[0][...] = dp[...][0] = 0</code>，因为没有物品或者背包没有空间时，能装的最大价值就是0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 细化框架</span><br>&gt;dp = np.zeros((N+<span class="hljs-number">1</span>, W+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span><br>&gt;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.N]:<br>&gt;<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.W]:<br>&gt;dp[i][w] = <span class="hljs-built_in">max</span>(<br> 把物品 i 装进背包,<br> 不把物品 i 装进背包<br>&gt;)<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;step3：根据【选择】，思考状态转移的逻辑&#x3D;&#x3D;</p>
<p>装入背包：<code>dp[i][W] = V[i-1][j-W[i-1]] + v[i-1]</code></p>
<p>不装入背包：<code>dp[i][W] = V[i-1][w]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 细化代码</span><br>&gt;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.N]:<br>&gt;<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.W]:<br>&gt;dp[i][w] = <span class="hljs-built_in">max</span>(<br> dp[i-<span class="hljs-number">1</span>][w],<br> dp[i-<span class="hljs-number">1</span>][w - wt[i-<span class="hljs-number">1</span>]] + val[i-<span class="hljs-number">1</span>]<br>&gt;)<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;step4：写成代码，处理边界情况&#x3D;&#x3D;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack2</span>(<span class="hljs-params">W,N,weight,value</span>):<br>&gt;<span class="hljs-comment"># 初始化全为0</span><br>&gt;dp = np.zeros((N+<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>&gt;<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,N+<span class="hljs-number">1</span>):<br>  <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>      <span class="hljs-keyword">if</span> w &lt; weight[n-<span class="hljs-number">1</span>]:<br>          <span class="hljs-comment"># 装不下</span><br>          dp[n][w] = dp[n-<span class="hljs-number">1</span>][w]<br>      <span class="hljs-keyword">else</span>:<br>          <span class="hljs-comment"># 择优：装/不装</span><br>          dp[n][w] = <span class="hljs-built_in">max</span>(dp[n-<span class="hljs-number">1</span>][w-weight[n-<span class="hljs-number">1</span>]]+value[n-<span class="hljs-number">1</span>],dp[n-<span class="hljs-number">1</span>][w])<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure>
</blockquote>
<p>优化为一维数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># W:背包能承受的重量 N:物品的数量 weight:每个物品的重量 value:每个物品的价值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack3</span>(<span class="hljs-params">W,N,weight,value</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>            <span class="hljs-keyword">if</span> w &gt;= weight[i]:<br>                dp[w] = <span class="hljs-built_in">max</span>(dp[w],dp[w-weight[i]]+value[i])<br>        <span class="hljs-built_in">print</span>(dp)<br>    <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure>



<blockquote>
<p>写个小坑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简化为一维数组</span><br><span class="hljs-comment"># W:背包能承受的重量 N:物品的数量 weight:每个物品的重量 value:每个物品的价值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack3</span>(<span class="hljs-params">W,N,weight,value</span>):<br> dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>     <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>         <span class="hljs-keyword">if</span> w &gt;= weight[i]:<br>             dp[w] = <span class="hljs-built_in">max</span>(dp[w],dp[w-weight[i]]+value[i])<br>     <span class="hljs-built_in">print</span>(dp)<br> <span class="hljs-keyword">return</span> dp<br><br> <span class="hljs-comment"># 另一种遍历</span><br> <span class="hljs-comment"># for w in range(1,W+1):</span><br>     <span class="hljs-comment"># for i in range(N):</span><br>     <span class="hljs-comment">#     if w &gt;= weight[i]:</span><br>     <span class="hljs-comment">#         dp[w] = max(dp[w],dp[w-weight[i]]+value[i])</span><br>     <span class="hljs-comment"># print(dp)</span><br><br><span class="hljs-comment"># 输入：10,6,[2,2,3,1,5,2],[2,3,1,5,4,3]</span><br><span class="hljs-comment"># 输出：[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]</span><br></code></pre></td></tr></table></figure>

<p>这里也是尝试写成一维数组，与上面方法不同的是从正向遍历，导致<code>dp[w-weight[i]]</code>拿到的数据可能包含了第<code>i</code>个物品，导致了重复。尝试了加flag之类的，但似乎正向遍历的方法没法做。</p>
</blockquote>
<h5 id="背包问题的变体"><a href="#背包问题的变体" class="headerlink" title="背包问题的变体"></a>背包问题的变体</h5><h6 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h6><p>例：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>
<p>分割等和子集：给定一个只包含正整数的非空数组，是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>问题转换：</strong></p>
<p><code>sum</code>为物品总重量，给一个可装载重量为<code>sum/2</code>的背包和<code>N</code>个物品，每个物品重量为<code>weight[i]</code>，是否存在一种装法，能够恰好将背包装满。</p>
<p>1、明确【状态】和【选择】：</p>
<p>状态：【背包的容量】、【可选择的物品】</p>
<p>选择：【装进背包】、【不装进背包】</p>
<p>2、明确dp数组定义：</p>
<p><code>dp[i][j]</code>表示对于前<code>i</code>个物品，当前背包的容量为<code>j</code>时，若<code>x</code>为<code>True</code>，则说明可以恰好将背包装满，若<code>x</code>为<code>False</code>，则说明不能恰好将背包装满。</p>
<p>根据这个定义，我们想求的最终答案即为<code>dp[N][sum/2]</code>。</p>
<p>base case为<code>dp[...][0] = True</code>和<code>dp[0][...]=False</code></p>
<blockquote>
<p>背包没有空间：装满了</p>
<p>没有物品可选：无法装满</p>
</blockquote>
<p>3、根据【选择】，思考状态转移的逻辑</p>
<p>判断是否可装入：<code>weight[i-1] &lt;= j</code></p>
<p>装入背包：<code>dp[i][j] = dp[i-1][j-weight[i-1]]</code></p>
<p>不装入背包：<code>dp[i][j] = dp[i-1][j]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_divide</span>(<span class="hljs-params">weight</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weight: <span class="hljs-built_in">sum</span> += w<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span>%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>)<br>    dp = np.full((<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>),<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>),<span class="hljs-literal">False</span>,dtype=<span class="hljs-built_in">bool</span>)<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 状态转换</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j-weight[i-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 背包容量不足</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 选择装入或不装入</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] | dp[i-<span class="hljs-number">1</span>][j-weight[i-<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(weight)][<span class="hljs-built_in">sum</span>]<br></code></pre></td></tr></table></figure>



<p>4、优化：状态压缩</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 状态压缩</span><br><span class="hljs-comment"># weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_divide2</span>(<span class="hljs-params">weight</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weight: <span class="hljs-built_in">sum</span> += w<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span>%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>)<br>    dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 状态转换</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">sum</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i]:<br>                dp[j] = dp[j] | dp[j-weight[i]]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">sum</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如上题，<code>j</code>应从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响了其他的结果。</p>
</blockquote>
<p>至此，子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。 </p>
<h6 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h6><p>例：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p>
<p>零钱兑换2：给定不同面额的硬币和一个总金额，写出函数来计算可以凑成总金额的硬币组合数，假设每一种面额的硬币有无限个<strong>。</strong></p>
<p><strong>问题转换：</strong></p>
<p>有一个背包，最大容量为<code>W</code>，有一系列物品<code>weight</code>，每个物品的重量为<code>weight[i]</code>，每个物品的数量无限，请问有多少种方法，能够把背包恰好装满。</p>
<p>1、明确【状态】和【选择】：</p>
<p>状态：【背包的容量】、【可选择的物品】</p>
<p>选择：【装进背包】、【不装进背包】</p>
<p>2、明确<code>dp</code>数组的定义：</p>
<p>若只使用前<code>i</code>个物品，当背包容量为<code>j</code>时，有<code>dp[i][j]</code>种方法可以装满背包。</p>
<p>所求的答案即为<code>dp[N][W]</code>，<code>N</code>为<code>weight</code>数组的大小。</p>
<p>base case：<code>dp[0][...]=0</code>和<code>dp[...][0]=1</code></p>
<p>3、根据【选择】，思考状态转移的逻辑：</p>
<p>条件：<code>j &gt;= weight[i-1]</code></p>
<p>装入背包：<code>dp[i][j-weight[i-1]]</code>&#x3D;&#x3D;(可以重复，所以是<code>i</code>而不是<code>i-1</code>)&#x3D;&#x3D;</p>
<p>不装入背包：<code>dp[i-1][j]</code></p>
<p>共有<code>dp[i][j] = dp[i][j-weight[i-1]] + dp[i-1][j]</code>种凑法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完全背包</span><br><span class="hljs-comment"># weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_complete</span>(<span class="hljs-params">W,weight</span>):<br>    dp = np.zeros((<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>),dtype=<span class="hljs-built_in">int</span>)<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j - weight[i-<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(weight)][W]<br></code></pre></td></tr></table></figure>

<p>4、优化：降低空间复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 状态压缩</span><br><span class="hljs-comment"># W: 背包承重 weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_complete2</span>(<span class="hljs-params">W,weight</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i]:<br>                dp[j] = dp[j] + dp[j-weight[i]]<br>    <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure>

<p>时间复杂度<code> O(len(weight)*W)</code>，空间复杂度<code>O(W)</code>。</p>
<h4 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h4><ul>
<li>通过做出一系列短视的决策来解决问题</li>
<li>每个决策本身都能最优地解决某些子问题</li>
<li>但这些子问题对整个问题来说未必最优</li>
<li>设计的关键：找到一种合适的方法，把问题分解成几个小的部分，然后把他们组合在一起</li>
<li>例：作业调度、Dijkstra算法、最小生成树</li>
</ul>
<blockquote>
<p>每一步都做出一个局部最优的选择，最终的结果就是全局最优。</p>
<p>注：部分问题具有这个性质</p>
</blockquote>
<h5 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h5><p>给出多个形如[start,end]的闭区间，算出这些区间中最多有几个互不相交的区间。</p>
<blockquote>
<p>例：intvs &#x3D; [[1,3],[2,4],[3,6]]，应返回2，即最多有两个区间互不相交</p>
</blockquote>
<p>解题思路：</p>
<p>1、从区间结合intvs中选择一个区间x，这个x是在当前所有区间中结束最早的（end最小）</p>
<p>2、把所有与x相交的区间从区间集合intvs中删除</p>
<p>3、重复步骤1和步骤2，直到intvs为空，之前选出的x就是最大不相交子集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 区间调度</span><br><span class="hljs-comment"># intvs: 区间集合</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">key_function</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">interval_schedule</span>(<span class="hljs-params">intvs</span>):<br>    <span class="hljs-keyword">if</span> intvs == []:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 按end排序</span><br>    intvs.sort(key=key_function)<br>    <span class="hljs-comment"># 至少有一个区间不相交</span><br>    count = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 排序后，第一个区间就是x</span><br>    x_end = intvs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> intv <span class="hljs-keyword">in</span> intvs:<br>        start = intv[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> start &gt;= x_end:<br>            count += <span class="hljs-number">1</span><br>            x_end = intv[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> count<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    intvs = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>    <span class="hljs-built_in">print</span>(interval_schedule(intvs))<br></code></pre></td></tr></table></figure>



<h5 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h5><p><strong>问题描述：</strong></p>
<p>给定：n个作业和一台机器，作业<code>i</code>有一个开始时间$s_i$和一个完成时间$f_i \geq s_i$</p>
<p>目标：以非重叠的方式找到可以在机器上调度的最大作业子集</p>
<p>对于任意两个计划作业<code>i</code>和<code>j</code>，$f_i \le s_j$ 或 $f_j \le s_i$ （不能同时进行）</p>
<p>贪婪方法：持续作业调度，确保没有新作业与现有的作业重叠。关键在于调度作业的顺序。</p>
<p><strong>贪婪策略：</strong></p>
<p>有几种可能的方法可以做到这一点，每种方法都试图尽量减少每个连续作业可能导致的潜在重叠次数</p>
<ul>
<li>最短作业优先</li>
<li>最早到达优先</li>
<li>冲突最少优先</li>
<li>最早完成时间优先</li>
</ul>
<p><strong>最早完成时间优先：</strong></p>
<p>考虑任何不少于<code>k</code>个作业的解决方案<code>S</code>。对<code>k</code>归纳证明，贪婪算法<code>G</code>调度至少<code>k</code>个作业时，前<code>k</code>个作业不晚于所选解中的前<code>k</code>个作业完成。这一结论意味着贪婪算法调度的作业数至少与最优解相同。</p>
<p>基本情况：<code>k=0</code>，假设归纳假设适用于<code>k-1</code></p>
<p>令$S_k$为<code>S</code>中的第<code>k</code>个作业，$G_k$是贪婪调度的第<code>k</code>个作业。显然，$s_{S_K} \ge f_{S_K-1} \ge f_{G_{K-1}}$。也就是说，$S_k$在$G_{k-1}$完成之后开始。另外，在贪婪中调度$G_{k-1}$时，$S_k$尚未被考虑。因此贪婪算法可以通过增加作业$S_k$来扩充其调度。因此，它会找到一个候选者来扩充它的解决方案，特别是选择一个不晚于$S_k$的解决方案。</p>
<p><strong>贪婪算法的特点：</strong>分步骤来构造一个优化问题的解，每一步需满足特定要求。</p>
<ul>
<li>可行：不违反约束条件</li>
<li>局部最优：当前步骤最优的局部解</li>
<li>不可撤销：一旦做出选择，后续步骤中无法改变（与动态规划的区别，动态规划考虑全局，可以撤销，贪婪考虑局部）</li>
</ul>
<h5 id="最佳股票交易时间"><a href="#最佳股票交易时间" class="headerlink" title="最佳股票交易时间"></a>最佳股票交易时间</h5><p>问题描述：整形数组中的元素表示当天股票的价格；根据需要买入卖出，完成尽可能多的交易；不得同时进行多笔交易，必须在再次购买之前卖出股票；设计算法找出最大利润。</p>
<p><strong>股票买卖问题：</strong></p>
<p>问题描述：给定一个数组，它的第<code>i</code>个元素时一支给定的股票在第<code>i</code>天的价格，设计一个算法来计算你能获取的最大利益。你最多可以完成<code>k</code>笔交易，且不能同时参与多笔交易。</p>
<p>示例：</p>
<blockquote>
<p>输入：[2,4,1], k&#x3D;2</p>
<p>输出：2（最大利益）</p>
<p>输入：[3,2,6,5,0,3], k&#x3D;2</p>
<p>输出：7（最大利益）</p>
</blockquote>
<p>1、明确【状态】和【选择】</p>
<p>状态：【天数】、【允许交易的最大次数】、【当前的持有状态】(1持有0没有持有)</p>
<p>选择：【买入】、【卖出】、【无操作】</p>
<p>尝试穷举：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][k][<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>]<br><span class="hljs-number">0</span> &lt;= i &lt;= n-<span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;= k &lt;= K<br><span class="hljs-comment"># n为天数，K为最多交易数</span><br><span class="hljs-comment"># 此问题共n*K*2种状态，可尝试穷举</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,K+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;:<br>            dp[i][k][s] = <span class="hljs-built_in">max</span>(buy,sell,rest)<br><span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<p>2、状态转移框架</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># base case:</span><br><span class="hljs-comment"># i=-1(没开始) k=0(不允许交易) 利润为0</span><br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-comment"># i=-1 s=1(没开始时持有股票) k=0 s=1(不允许交易持有股票) 负无穷表不可能</span><br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br><br><span class="hljs-comment"># 状态转移方程：</span><br>dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br></code></pre></td></tr></table></figure>

<p>3、运用到不同类型的题目</p>
<ul>
<li>k&#x3D;1</li>
</ul>
<p>此时<code>k</code>均为1，不会改变，<code>k</code>对于状态转移已经没有影响了，可以简化<code>k</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=1的情况</span><br><span class="hljs-comment"># prices: 股票价格列表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit2</span>(<span class="hljs-params">prices</span>):<br>    n = <span class="hljs-built_in">len</span>(prices)<br>    dp = np.zeros((n,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>: <br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br>            dp[i][<span class="hljs-number">1</span>]=-prices[i]<br>            <span class="hljs-keyword">continue</span><br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i])<br>        dp[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],-prices[i])<br>    <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<p>优化：降低空间复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 改进：dp数组-&gt;一个变量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit3</span>(<span class="hljs-params">prices</span>):<br>    n = <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-comment"># base case</span><br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+prices[i])<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,-prices[i])<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure>

<ul>
<li>k&#x3D;正无穷</li>
</ul>
<p>此时<code>k=k-1</code>，依然不需要<code>k</code>来记录状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k= 正无穷</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit4</span>(<span class="hljs-params">prices</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        tmp=dp0<br>        dp0=<span class="hljs-built_in">max</span>(dp0,dp1+prices[i])<br>        dp1=<span class="hljs-built_in">max</span>(dp1,tmp-prices[i])<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure>

<ul>
<li>k&#x3D;正无穷+冷却一天</li>
</ul>
<p>每次sell后，要等一天才能交易</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=正无穷+cooldown</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit5</span>(<span class="hljs-params">prices</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    dp_pre0 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> price <span class="hljs-keyword">in</span> prices:<br>        tmp=dp0<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+price)<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,dp_pre0-price)<br>        dp_pre0=tmp<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure>

<ul>
<li>k&#x3D;正无穷+fee</li>
</ul>
<p>把手续费从利润中减去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=正无穷+fee</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit6</span>(<span class="hljs-params">prices,fee</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1=<span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> price <span class="hljs-keyword">in</span> prices:<br>        tmp = dp0<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+price)<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,tmp-price-fee)<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure>

<ul>
<li>k&#x3D;2</li>
</ul>
<p>没有消掉<code>k</code>的影响，所以必须对<code>k</code>进行穷举</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit7</span>(<span class="hljs-params">prices</span>):<br>    K=<span class="hljs-number">2</span><br>    n=<span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-comment"># 创建三维表</span><br>    dp = np.zeros((n,K+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>:<br>                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>                dp[i][k][<span class="hljs-number">1</span>] = -prices[i]<br>                <span class="hljs-keyword">continue</span><br>            dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>]+prices[i])<br>            dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>

<ul>
<li>k&#x3D;any integer</li>
</ul>
<p>K非常大时，可使用k&#x3D;正无穷的解法，减少遍历。</p>
<p>此外可类似k&#x3D;2的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=any integer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit8</span>(<span class="hljs-params">prices,K</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> K &gt; n/<span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> profit4(prices)<br>    <span class="hljs-comment"># 创建三维表</span><br>    dp = np.zeros((n,K+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>:<br>                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>                dp[i][k][<span class="hljs-number">1</span>] = -prices[i]<br>                <span class="hljs-keyword">continue</span><br>            dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>]+prices[i])<br>            dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>

<p>总结：用数组存储所有的状态，从base case开始状态转移，至解。</p>
<h5 id="圆和弦（卡特兰数）"><a href="#圆和弦（卡特兰数）" class="headerlink" title="圆和弦（卡特兰数）"></a>圆和弦（卡特兰数）</h5><p>问题描述：圆上有<code>2n</code>个点，可以连成<code>n</code>个不相交的弦，不同的连接方式有多少？</p>
<p>解题思路：</p>
<p>0、定义函数<code>f(2n)</code>：为所求答案</p>
<p>1、连接任意两个点，可以用一根弦将整个圆分成两部分，例如对于有<code>2n</code>个点的圆，可以分成<code>2</code>和<code>n-4</code>两部分，于是这个情况有<code>f(2)*f(n-4)</code>种连接方式。</p>
<p>2、因为划分要做到两边都是偶数，才能保证连接出<code>n</code>个弦不相交，所以从单个点出发，有<code>n/2</code>种划分。</p>
<p>3、最终答案就是把每种划分的所有连接方式相加。</p>
<p>实际是算卡特兰数，也即：<code>f(n)=f(0)*f(n-1)+f(1)*f(n-2)+...+f(n-1)*f(0)</code></p>
<p>例：<code>[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796] </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 圆和弦</span><br><span class="hljs-comment"># 圆上有2n个点，可以连成n个不相交的弦，不同的连接方式有多少？</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>]=dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            dp[i] += dp[j]*dp[i-j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>同样是求卡特兰数的问题：</p>
<ul>
<li>出栈问题：已知进展顺序<code>abcd</code>，可能的出栈顺序多少种？<code>f(4)=14</code>。</li>
<li>n个符号分别依次入栈</li>
<li>归结为已知问题：在n*n的方格中，入栈&#x3D;向上，出栈&#x3D;向右，起点（0,0），终点（n,n）</li>
<li>满二叉树问题：求个(n+1)个叶子的满二叉树的个数（这里的满二叉树（full binary tree）是指除根节点外的节点要么有2个要么有0个节点）。<code>f(3)=5</code>即4个叶子的满二叉树个数。</li>
<li>购票问题：电影票每50张元，如果有个人排队买票，其中个n人各持有100元面值的钞票张，另外个m人各持有50元面值的钞票张，而票房没有预备找零．有多少种方法可以将这个人排成一列，顺序购票？<code>m=n时，即为Catalan数</code>。</li>
<li>凸多边形的剖分：求凸（n+2）边形用其(n-1)条对角线分割为互不重叠的三角形的分法总数。<code>f(4)=14</code>凸6边形用3条对角线的分法总数。</li>
</ul>
</blockquote>
<h6 id="卡特兰计数问题"><a href="#卡特兰计数问题" class="headerlink" title="卡特兰计数问题"></a>卡特兰计数问题</h6><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-21_133416.png" srcset="/blog/img/loading.gif" lazyload alt="2022-04-21_133416"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 动态规划的解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan4</span>(<span class="hljs-params">m,n</span>):<br>    dp = np.zeros((m+<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,j+<span class="hljs-number">1</span>):<br>            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure>



<h6 id="二叉树数量"><a href="#二叉树数量" class="headerlink" title="二叉树数量"></a>二叉树数量</h6><ul>
<li>给定二叉树的中序遍历结果，有多少种二叉树满足这种遍历。</li>
<li>观察视角：根节点在哪里？</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树数量的递归</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan6</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-built_in">sum</span> += Catalan6(i) * Catalan6(n-i-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure>



<h5 id="作业：熟悉掌握Viterbi算法"><a href="#作业：熟悉掌握Viterbi算法" class="headerlink" title="作业：熟悉掌握Viterbi算法"></a>作业：熟悉掌握Viterbi算法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">viterbi_decode</span>(<span class="hljs-params">score, transition</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;解码TensorFlow之外得分最高的标签序列</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">        score: 预测概率矩阵</span><br><span class="hljs-string">        transition: 转移矩阵</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">        viterbi: 最高得分标签的整数列表</span><br><span class="hljs-string">        viterbi_score: viterbi分数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 用于存储累计分数的数组</span><br>    <span class="hljs-comment"># np.zeros_like返回一个新矩阵，其维度与矩阵score一致，并为其初始化为全0；</span><br>    trellis = np.zeros_like(score)<br>    <span class="hljs-comment"># 用于存储最优路径索引的数组</span><br>    backpointers = np.zeros_like(score, dtype=np.int32)<br>    <span class="hljs-comment"># 第一个时刻的累计分数</span><br>    trellis[<span class="hljs-number">0</span>] = score[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># shape: 行，列</span><br>    <span class="hljs-comment"># 循环score的行，从1开始</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, score.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-comment"># 各个状态截止到上个时刻的累计分数 + 转移分数</span><br>        <span class="hljs-comment"># 把trellis的第一行扩展为三行（第一列的数形成第一行），与transision相加</span><br>        v = np.expand_dims(trellis[t - <span class="hljs-number">1</span>], <span class="hljs-number">1</span>) + transition<br>        <span class="hljs-comment"># max（各个状态截止到上个时刻的累计分数 + 转移分数）+ 选择当前状态的分数</span><br>        <span class="hljs-comment"># axis=0 代表行（对每列，选出最大行） , axis=1 代表列</span><br>        trellis[t] = score[t] + np.<span class="hljs-built_in">max</span>(v, <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 记录累计分数最大的索引</span><br>        backpointers[t] = np.argmax(v, <span class="hljs-number">0</span>)<br>	<br>    <span class="hljs-comment"># 最优路径的结果</span><br>    <span class="hljs-comment"># trellis数组最后一行最大值的索引以数组的形式返回</span><br>    viterbi = [np.argmax(trellis[-<span class="hljs-number">1</span>])]<br>    <span class="hljs-comment"># 反向遍历每个时刻，得到最优路径</span><br>    <span class="hljs-keyword">for</span> bp <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(backpointers[<span class="hljs-number">1</span>:]):<br>        viterbi.append(bp[viterbi[-<span class="hljs-number">1</span>]])<br>    viterbi.reverse()<br><br>    viterbi_score = np.<span class="hljs-built_in">max</span>(trellis[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> viterbi, viterbi_score<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    score = np.array([[<span class="hljs-number">0.8</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>],[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.4</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.2</span>]])<br>    transition = np.array([[<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>]])<br>    <span class="hljs-built_in">print</span>(viterbi_decode(score, transition))<br></code></pre></td></tr></table></figure>



<h3 id="4、Catalan-x2F-动态时间拉伸-x2F-Dijkstra"><a href="#4、Catalan-x2F-动态时间拉伸-x2F-Dijkstra" class="headerlink" title="4、Catalan&#x2F;动态时间拉伸&#x2F;Dijkstra"></a>4、Catalan&#x2F;动态时间拉伸&#x2F;Dijkstra</h3><h5 id="股票交易时间"><a href="#股票交易时间" class="headerlink" title="股票交易时间"></a>股票交易时间</h5><p>一趟扫描：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># a:股票价格数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit</span>(<span class="hljs-params">a</span>):<br>    tmp = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(a)):<br>        <span class="hljs-keyword">if</span> a[i] &gt; a[i-<span class="hljs-number">1</span>]:<br>            tmp += a[i] - a[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> tmp<br></code></pre></td></tr></table></figure>

<p>这是老师给的解答，相当于把所有相邻的前小后大全部相加，拿到了全局最优。</p>
<p>证明不详，但经测试与动态规划解法<code>profit4(prices)</code>能得出一样的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比较测试</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        random_int_list = []<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>            random_int_list.append(random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>))<br>        <span class="hljs-built_in">print</span>(profit(random_int_list))<br>        <span class="hljs-built_in">print</span>(profit4(random_int_list))<br></code></pre></td></tr></table></figure>



<h5 id="男生（100）女生（50）买票"><a href="#男生（100）女生（50）买票" class="headerlink" title="男生（100）女生（50）买票"></a>男生（100）女生（50）买票</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 半区网路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan3</span>(<span class="hljs-params">i,j</span>):<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == i <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> == j: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> i &lt; j <span class="hljs-keyword">and</span> i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> Catalan3(i-<span class="hljs-number">1</span>, j) + Catalan3(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> i == j: <span class="hljs-keyword">return</span> Catalan3(i-<span class="hljs-number">1</span>, j)<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == i: <span class="hljs-keyword">return</span> Catalan3(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;should have not reached here&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>



<h5 id="圆和弦"><a href="#圆和弦" class="headerlink" title="圆和弦"></a>圆和弦</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求Catalan递归的写法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan2</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        tmp = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n,<span class="hljs-number">2</span>):<br>            tmp += Catalan2(i)*Catalan2(n-i-<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> tmp<br></code></pre></td></tr></table></figure>



<h4 id="动态时间拉伸"><a href="#动态时间拉伸" class="headerlink" title="动态时间拉伸"></a>动态时间拉伸</h4><ul>
<li><p>多普勒效应：波在波源移向观察者时接收频率变高，而在波源远离观察者时接收频率变低。</p>
</li>
<li><p>模板匹配</p>
</li>
<li><p>时间序列对准</p>
</li>
<li><p>序列相似度度量</p>
</li>
</ul>
<p>两个有限长度的序列$X&#x3D;\left{x_1,\dots,x_m\right}$和$Y&#x3D;\left{y_1,\dots,y_n\right}$</p>
<p>非负代价函数$d(x_i,y_j)$</p>
<p>如何发现$X$和$Y$的最佳对应关系？</p>
<p><strong>动态规划求解：</strong></p>
<ul>
<li>转化为从(0,0)到(m,n)的最短路径问题</li>
<li>已知D(0,0)，求D(m,n)</li>
<li>递推过程：<code>D(i,j) = d(i,j) + min&#123;D(i,j-1),D(i-1,j-1),D(i-1,j)&#125;</code></li>
</ul>
<h5 id="Dijkstra最短路径算法（贪婪算法）"><a href="#Dijkstra最短路径算法（贪婪算法）" class="headerlink" title="Dijkstra最短路径算法（贪婪算法）"></a>Dijkstra最短路径算法（贪婪算法）</h5><ul>
<li>Dijkstra算法贪婪地探索从<code>s</code>开始的路径，每次移动到下一个最近的节点。这种方式实际构造了从<code>s</code>到图中每个其他节点的最短路径。</li>
<li>给定：带权图以及特殊节点<code>s</code>和<code>t</code></li>
<li>目标：找到<code>s</code>和<code>t</code>之间的最短路径</li>
</ul>
<p>算法描述：</p>
<ul>
<li><p>初始化<code>K=&#123;s&#125;</code>，令<code>Path(s)= ∅ </code>，<code>d(s) = 0</code></p>
</li>
<li><p>对不在<code>K</code>中的每一个节点<code>v</code>，计算距离 $d(v) &#x3D; \min_{u \in K}\left{ d(u) + w(u,v) \right}$</p>
</li>
<li><p>令$v^*$为$v^* &#x3D; \arg \min_{v \notin K}d(v)$，<code>e=(u,v)</code>为对应边</p>
</li>
<li><p>令$K&#x3D;K \cup \left{ v^* \right}$，$Path(v^*) &#x3D; Path(u)\cup\left{e^<em>\right}$，$d(v^</em>) &#x3D; d(u) + w(e^*)$</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, start</span>):<br>    vnum = <span class="hljs-built_in">len</span>(graph) <span class="hljs-comment"># 顶点个数</span><br>    paths = &#123;&#125;<br>    cands = [(<span class="hljs-number">0</span>,start,start)]<br>    heapify(cands) <span class="hljs-comment"># 转化为小顶堆，便于找到权重最小的边</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> count &lt; vnum <span class="hljs-keyword">and</span> cands <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plen,u,vmin=heappop(cands) <span class="hljs-comment"># 选出累计路径最短的边</span><br>        <span class="hljs-keyword">if</span> paths.get(vmin) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 如果已经找到到vmin的最短路径就跳过</span><br>            <span class="hljs-keyword">continue</span><br>        paths[vmin] = plen <span class="hljs-comment"># 存入最短路径</span><br>        <span class="hljs-keyword">for</span> next_edge <span class="hljs-keyword">in</span> graph[vmin]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> paths.get(next_edge[<span class="hljs-number">2</span>]):<br>                heappush(cands, (plen+next_edge[<span class="hljs-number">0</span>],u,next_edge[<span class="hljs-number">2</span>]))<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> paths<br>graph = &#123;<span class="hljs-string">&#x27;A&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)], <br>         <span class="hljs-string">&#x27;C&#x27;</span>: [(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)], <br>         <span class="hljs-string">&#x27;B&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)], <br>         <span class="hljs-string">&#x27;E&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)], <br>         <span class="hljs-string">&#x27;D&#x27;</span>: [(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)], <br>         <span class="hljs-string">&#x27;G&#x27;</span>: [(<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)], <br>         <span class="hljs-string">&#x27;F&#x27;</span>: [(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)]&#125;      <br><span class="hljs-built_in">print</span>(dijkstra(graph, <span class="hljs-string">&#x27;A&#x27;</span>))<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 法二：</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">startwith</span>(<span class="hljs-params">start: <span class="hljs-built_in">int</span>, mgraph: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>    passed = [start]<br>    nopass = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(mgraph)) <span class="hljs-keyword">if</span> x != start]<br>    dis = mgraph[start]<br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(nopass):<br>        idx = nopass[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nopass:<br>            <span class="hljs-keyword">if</span> dis[i] &lt; dis[idx]: idx = i<br><br>        nopass.remove(idx)<br>        passed.append(idx)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nopass:<br>            <span class="hljs-keyword">if</span> dis[idx] + mgraph[idx][i] &lt; dis[i]: <br>                dis[i] = dis[idx] + mgraph[idx][i]<br>    <span class="hljs-keyword">return</span> dis<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    inf = <span class="hljs-number">10086</span><br>    mgraph = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, inf, inf, inf],<br>              [inf, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, inf, inf],<br>              [inf, inf, <span class="hljs-number">0</span>, inf, <span class="hljs-number">5</span>, inf],<br>              [inf, inf, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>],<br>              [inf, inf, inf ,inf, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>],<br>              [inf, inf, inf, inf ,inf, <span class="hljs-number">0</span>]]<br><br>    <span class="hljs-built_in">print</span>(startwith(<span class="hljs-number">0</span>, mgraph))<br></code></pre></td></tr></table></figure>

<p><strong>Dijkstra算法的最优性：</strong></p>
<p>通过对$K$的大小的归纳来证明这个结论。</p>
<p>$|K| &#x3D; 1$的基本情况是平凡的：在这种情况下$K$只包含$s$和路径$Path(s) &#x3D; \varnothing$。</p>
<p>假设结论一直保持到步骤$k-1$仍然成立，并考虑第$k$步把点$v$添加到集合$K$，且$e&#x3D;(u,v)$为对应边。</p>
<p>为了造成矛盾，假设路径$Path(v)$并非$s$到$v$的最短路径，而$Path^*(v)$为相应的最短路径。设$x$为$Path^*(v)$上集合$K$中最后一个结点，$x’$是$Path^*(v)$上紧随$x$之后的结点。</p>
<p>由定义可知$d(x)+w(x,x’)$不超过为$Path^*(v)$的长度。</p>
<p>但是，通过构造，&#x3D;&#x3D;$d(u) + w(u,v) \leq d(x) + w(x,x’)$（不是很理解）&#x3D;&#x3D;，且$d(v) &#x3D; d(u) + w(u,v)$，意味着$d(v)$不超过$Path^*(v)$的长度。</p>
<p>于是导出矛盾。</p>
<h5 id="作业：kruskal算法、prime算法"><a href="#作业：kruskal算法、prime算法" class="headerlink" title="作业：kruskal算法、prime算法"></a>作业：kruskal算法、prime算法</h5><h3 id="5、Catalan计数-x2F-最小生成树问题"><a href="#5、Catalan计数-x2F-最小生成树问题" class="headerlink" title="5、Catalan计数&#x2F;最小生成树问题"></a>5、Catalan计数&#x2F;最小生成树问题</h3><p>Catalan计数见前文</p>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul>
<li>$G&#x3D;(V,E)$是一个无向连通图，代价函数<code>w</code>将边映射为正实数</li>
<li>生成树是一颗连接<code>G</code>的所有顶点的无向树</li>
<li>生成树的代价等于树中所有边的代价之和</li>
<li>最小生成树的代价为<code>G</code>的所有可能生成树的最小代价的一颗生成树</li>
<li>一个图可以有许多具有代价的<code>MST</code></li>
<li>构建<code>MST</code>的两个主要算法：<code>Kruskal</code>和<code>Prim</code>，都是贪婪算法</li>
</ul>
<p><strong>安全边</strong></p>
<ul>
<li>图的割：对结点集合<code>V</code>的一个划分</li>
<li>穿过割的边：一条边的两个端点分别在割的两边</li>
<li>轻边：穿过割的边中权重最小的一条边</li>
<li>结论：假设$A\subset E$，且包含在一些<code>MST</code>中，如果$(s,v_s)$ 是一个关于$A$的割，$(u,v)$是一条穿过割$(s,v_s)$的轻边，则$(u,v)$对$A$来说是安全的。</li>
</ul>
<p>贪婪算法：独特</p>
<h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><ul>
<li>集合<code>A</code>初始时只包括孤立的结点</li>
<li>对<code>E</code>的边按权重大小升序排序</li>
<li>顺序考虑边：如果这条边连接两个不同部分，则添加该边</li>
<li>无向图$G&#x3D;(V,E)$的<code>MST</code>可以在时间复杂度$O(|V|log|V| + |E|log|E|)$完成</li>
</ul>
<h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5><ul>
<li>Prim算法与Dijkstra算法的单源最短路径算法非常像，具有相同的复杂度</li>
<li>在算法的任何阶段，集合<code>A</code>都会形成一棵树，而不是像Kruskal那样由连接的组件组成的森林</li>
<li>每个阶段中，都会向树添加一条轻边，将<code>A</code>连接到$V_A$中的顶点</li>
<li>用边的权重组成一个优先队列负责查找轻边</li>
</ul>
<h4 id="P和NP"><a href="#P和NP" class="headerlink" title="P和NP"></a>P和NP</h4><ul>
<li>在分析算法的复杂性时，可以把问题转化为一个决策问题：答案为是&#x2F;否的可计算问题</li>
<li>例如，把在一种语言中生成字符串的问题转化为验证给定字符串在一种语言中的成员身份的问题</li>
<li>P指的是一类语言，它的隶属度问题可以用输入字符串大小的时间多项式来确定</li>
<li>对于某些语言，则没有多项式时间的成员算法。但是，我们可以用另一个“见证”字符串在多项式时间内验证该字符串是否使用这一语言</li>
<li>NP是一类语言，给定一个多项式长度的见证字符串，其成员资格可以在多项式时间内进行验证</li>
</ul>
<p><strong>P-时间可约性</strong></p>
<ul>
<li>可约性的概念允许我们在多项式时间内将一个问题转化为另一个问题</li>
<li>如果我们能解决后者，那么我们也能解决前者的问题；相反，如果前者是NP难问题，后者也是NP难问题</li>
<li>在讨论决策问题时，如果存在一个多项式时间算法，该算法将问题A的一个实例作为输入，并输出一个保证与问题A的实例具有相同结果的问题B的实例，这种归约成为Cook归约</li>
<li>就是说，如果问题B存在一个有效算法，那么问题A可以通过将其实例转换为问题B的实例，并对其应用有效算法来解决</li>
</ul>
<p><strong>P&#x3D;NP?</strong></p>
<ul>
<li>P和NP是否相等是计算机科学中最突出、最重要的开放性问题之一。考虑这个问题的有效工具：一个问题对于一个类来说是完全的概念</li>
<li>可以说，NP中最难的问题称为NP-Hard，是NP中的每一个问题都可以被多项式时间归约到的问题</li>
<li>因此，任何一个问题的多项式时间算法都意味着NP中的每一个问题都可以在多项式时间内求解，即$NP \subseteq P$</li>
<li>我们已经知道$P \subseteq NP$，因为每个P算法都可以被看作是一个NP算法</li>
<li>P&#x3D;NP if 存在一个决定任何一个NP完全问题的多项式时间算法</li>
</ul>
<p><strong>SAT问题</strong></p>
<ul>
<li>第一个被证明是NP完全的问题是Boolean-SAT：给定一个布尔表达式，是否有一组变量可以使整个表达式的值为真？显然，存在一些不可满足的布尔表达式</li>
<li>可满足性：给定共轭范式的布尔表达式，寻找变量的值使该表达式为TRUE</li>
<li>Cook和Levin独立地证明了SAT的NP完全性，称为Cook-Levin定理。Cook-Levin定理证明了SAT是NP完全的，证明了对于NP中的任何问题SAT都存在一个约简</li>
</ul>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_103017.png" srcset="/blog/img/loading.gif" lazyload alt="2022-04-30_103017"></p>
<p><strong>顶点覆盖问题</strong></p>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_103309.png" srcset="/blog/img/loading.gif" lazyload alt="2022-04-30_103309"></p>
<p>问题描述：给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</p>
<p><strong>SAT问题定义</strong></p>
<p>布尔可满足性：给定一个CNF（共轭范式）中的布尔公式$\phi$，该公式可以满足吗？换句话说，我们给出了一个带有n个变量的$x_1,x_2,\dots,x_n$的布尔公式$\phi &#x3D; C_1\wedge C_2\wedge \dots \wedge C_k$，其中每个$C_i$是一个形式为$(l_{i1} \vee l_{i2} \vee \dots \vee l_{il})$的子句，每个$l_{ij}$是从集合$\left{ x_1,x_2,\dots,x_n;\overline{x_1},\overline{x_2},\dots,\overline{x_n} \right}$里抽取的文字。我们需要决定是否存在一些变量的设置使得$\phi$得到满足</p>
<p><strong>2-CNF和3-CNF</strong></p>
<ul>
<li>重要性：NP-完全问题是一类任何NP问题可以以多项式时间转化的问题。任一NP完全问题可以多项式时间求解，则所有NP-完全问题都变成了P问题</li>
<li>2-CNF：子句包含1或2个变量的满足性决策问题</li>
<li>3-CNF：子句可以包含3个变量</li>
<li>2-CNF是P问题，而3-CNF属于NPC</li>
</ul>
<p><strong>SAT的NP完全性质</strong></p>
<p>要证明SAT问题是NP完全的，只需证明NP中的任何问题都可以在多项式时间内归约为SAT问题</p>
<ul>
<li>首先把问题限制为决策问题：把原始问题转化为一个成员问题，即给定的输入是否属于某种语言。那么，P表示可以在多项式时间内确定成员隶属的语言类，而NP代表存在一个可以在多项式时间内验证其成员隶属的语言类。</li>
<li>其次，需要将一个问题规约为另一个问题。问题A可以规约到问题B，则如果得到B的一个解，可以多项式时间内调用这个解还原性为A的解。</li>
</ul>
<p>Cook-Levin定理表名，对于NP中的任何问题，都存在到SAT的一种规约，从而证明SAT是NP完全的</p>
<p><strong>Cook-Levin定理</strong></p>
<blockquote>
<p>SAT is NP-complete</p>
</blockquote>
<p>假设L是一个NP问题，根据定义，则L具有一个多项式时间的验证算法V：</p>
<ul>
<li>If $x\in L$，$\exist$见证者y，V(x,y) &#x3D; 1</li>
<li>If $x \notin L$，$\exist$见证者y，V(x,y) &#x3D; 0</li>
</ul>
<p>可以为V构造一个多项式大小的电路，由AND、OR、NOT组成。改电路包含|x|+|y|个输入，其中|x|对应x的每一位的值，|y|代表可变变量</p>
<p><strong>Cook-Levin定理证明思路</strong></p>
<p>要求解问题L，只需要找到输入中的|y|个变量中的一种设置使电路的输出为1。这样就把问题L归结为决定电路是否能输出1的问题。接下来证明满足电路的问题可被归为SAT的一个实例。电路中的每一个门可以表示称一个3CNF（三元CNF，每个子句金包含三项）</p>
<p>例如：</p>
<ul>
<li><p>或门OR是一个输入a和b以及输出$Z_i$的函数，表示为$(a \vee b \vee \bar Z_i) \wedge (Z_i \vee \bar a) \wedge (Z_i \vee \bar b) $</p>
<blockquote>
<p>a,b&#x3D;true&#x2F;false</p>
</blockquote>
</li>
<li><p>非门NOT是一个输入a且输出$Z_i$的函数，表示为$(a \vee \bar Z_i) \wedge (\bar a \vee Z_i)$</p>
<blockquote>
<p>a&#x3D;true&#x2F;false</p>
</blockquote>
</li>
</ul>
<p>即使有些子句只包含少于3项，可以通过填充独立文字来构造3CNF。独立文字的值不影响从句的布尔量。</p>
<p><strong>Cook-Levin定理证明</strong></p>
<p>假设V中共有q个门，记为$Z_i,Z_2,\dots,Z_q$，其中$Z_q$是V的最后输出。</p>
<p>这些门要么直接使用输入，要么使用中间结果$Z_i$为输入。</p>
<p>因此，整个电路可以表示为CNF形式的公式：$\phi &#x3D; C_1\wedge C_2\wedge \dots \wedge C_q \wedge Z_q$，其中每个$C_i&#x3D;(t_i \vee t_2 \vee t_3)$，$t_1,t_2,t_3 \in \left{ x,y,Z_1,Z_2,\dots,Z_q,\bar Z_1,\bar Z_2,\dots,\bar Z_q \right}$。</p>
<p>如前所述，即使最后一个子句只含一项$Z_q$，也可等价转换为3-CNF。因此，该电路被归结为$\phi$，3-CNF形式的公式。</p>
<p>$\phi$被满足当且仅当原电路输出1。</p>
<p>所以，$L \le_p SAT$，SAT是NP完全问题</p>
<h4 id="接雨水（贪婪）"><a href="#接雨水（贪婪）" class="headerlink" title="接雨水（贪婪）"></a>接雨水（贪婪）</h4><p>问题描述：给定一个长度为n的整形数组，元素均大于0，以其中任意两个作为隔板，且位置不变，如何使容纳水的容积最大？</p>
<p>解题思路：选择短板算容量并淘汰</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">water</span>(<span class="hljs-params">a</span>):<br>    n = <span class="hljs-built_in">len</span>(a)<br>    i,j = <span class="hljs-number">0</span>,n-<span class="hljs-number">1</span><br>    m = tmp = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; j:<br>        <span class="hljs-keyword">if</span> a[i] &lt; a[j]:<br>            tmp = a[i]*(j-i+<span class="hljs-number">1</span>)<br>            i+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            tmp = a[j]*(j-i-<span class="hljs-number">1</span>)<br>            j-=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &gt; m:<br>            m = tmp<br>    <span class="hljs-keyword">return</span> m<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a = [<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>    <span class="hljs-built_in">print</span>(water(a))<br></code></pre></td></tr></table></figure>



<h3 id="6、P和NP-x2F-接雨水-x2F-网络流算法-x2F-排队"><a href="#6、P和NP-x2F-接雨水-x2F-网络流算法-x2F-排队" class="headerlink" title="6、P和NP&#x2F;接雨水&#x2F;网络流算法&#x2F;排队"></a>6、P和NP&#x2F;接雨水&#x2F;网络流算法&#x2F;排队</h3><h4 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h4><p><strong>求解与验证</strong></p>
<ul>
<li>求解问题看起来比验证答案要难（更加耗时）</li>
<li>例如：数独，给定初始位置，一般情况下求解数独比验证填好的数字是否满足数独的规则要更加困难</li>
<li>但是，如果需要验证的解的数量非常大，即使单个答案可以很快验证，总体上也要花费很长时间</li>
<li>NP是nondetermintstic polynomial time的缩写，指在非确定性图灵机上可以以多项式时间精确求解的问题</li>
<li>有些问题似乎相似，实际分属P和NP：欧拉旅行问题（访问所有边），汉密尔顿环（一次性访问所有节点）</li>
</ul>
<p><strong>CNF</strong></p>
<p><strong>2-CNF和3-CNF</strong></p>
<p><strong>Cook-Levin定理</strong></p>
<h4 id="网络流算法"><a href="#网络流算法" class="headerlink" title="网络流算法"></a>网络流算法</h4><ul>
<li>假设有一个管道网络，每个管道都有一定的横截面，网络有一个入口和一个出口</li>
<li>目标是将水通过管道从入口以尽可能大的速率输送到出口</li>
<li>两个主要限制：通过管道的速度不能超过管道的横截面（容量约束）；在管网的任何连接处，流入的水量必须正好等于流出的水量（流量守恒约束）</li>
<li>最大流问题要求在给定的有容量图中找到一个最大可能的可行流</li>
</ul>
<p><strong>假设</strong></p>
<ul>
<li>图G不包含自循环（不含形为(u,u)的边）</li>
<li>图G不包含多重边，如果$e_1$，$e_2$是从u到v的两条边，容量分别是$c_1$，$c_2$，则可以用一条边容量为$c_1+c_2$的边e表示</li>
<li>图G有方向性。如果图包含一条无向边(u,v)，可以用两条有向边u-&gt;v和v-&gt;u来代替，每条边的容量都等于c(u,v)</li>
</ul>
<p><strong>贪婪算法</strong></p>
<p>重复下列操作直至所有s~t路径都达到饱和</p>
<ul>
<li>寻找带有剩余容量的s~t路径</li>
<li>让该路径达到饱和</li>
<li>重复直到没有这种路径存在</li>
</ul>
<p>贪婪算法无法保证最优解：单一步骤具有不可撤销的特点</p>
<p><strong>Ford-Fulkerson算法</strong></p>
<ul>
<li>算法的总体思想类似贪婪算法：在每一步通过图选择一条s~t路径，并对其进行饱和</li>
<li>在剩余图中找到路径，该图明确允许沿先前使用的边反向流动</li>
<li>给定一个可行流$f$，剩余图$G_f&#x3D;(V_f,E_f)$，容量函数$c_f$按下列方式定义：<ul>
<li>$V_f&#x3D;V$</li>
<li>$E_f&#x3D;\left{(u,v)|u,v \in V \wedge (c(u,v) &gt; f(u,v))\right} \cup \left{ (u,v) | u,v \in V \wedge (f(v,u) &gt; 0) \right}$ </li>
<li>$c_f(u,v)&#x3D;c(u,v)-f(u,v)+f(v,u)$</li>
</ul>
</li>
</ul>
<p><strong>网络流与割集</strong></p>
<ul>
<li>s-t割集是一组边C，使得图$G’&#x3D;(V,E \backslash C)$不包含s~t路径。割集的容量为$cap(C)&#x3D;\sum _{e\in C}c(e)$</li>
<li>记F为所有可行的流的集合，则对于任意s~t割集C，$cap(C) \ge \max _{f\in F}|f|$</li>
<li>设$C^*$为G的最小s~t割集，$f^*$是G的最大s-t流，则$cap(C^*) \ge |f^*|$</li>
</ul>
<p><strong>主要结论</strong></p>
<ul>
<li>如果容量是整数值，Ford-Fulkerson算法可以发现最大流</li>
<li>最大流量的大小等于最小割集的容量</li>
<li>算法的运行时间：迭代中的每一步最多需要$O(m)$时间，其中m是边的数目，因为在每次迭代中，流的大小至少增加1，迭代次数的一个简单上界是F，最大流的大小。这是一个$O(mF)$的界。运行时间是一个伪多项式时间。</li>
</ul>
<h4 id="排队问题"><a href="#排队问题" class="headerlink" title="排队问题"></a>排队问题</h4><p>问题描述：假设有打乱顺序的一群人站成一个队列，数组people表示队列中一些人的属性（不一定按顺序）。每个$people[i] &#x3D; [h_i,k_i]$表示第$i$个人的身高为$h_i$，前面正好有$k_i$个身高大于或等于$h_i$的人。请重新构造并返回数组people所表示的队列。返回的队列应该格式化为数组queue，其中$queue[j] &#x3D; [h_j,k_j]$是队列中第$j$个人的属性（queue[0]是排在队列前面的人）</p>
<blockquote>
<p>示例：输入：people&#x3D;[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</p>
<p>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p>
</blockquote>
<h4 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h4><p>随机算法</p>
<p>在线算法</p>
<p>经典分治算法应用FFT</p>
<h3 id="7、排队-x2F-np-x2F-顶点覆盖问题-x2F-二部图匹配（线性规划）"><a href="#7、排队-x2F-np-x2F-顶点覆盖问题-x2F-二部图匹配（线性规划）" class="headerlink" title="7、排队&#x2F;np&#x2F;顶点覆盖问题&#x2F;二部图匹配（线性规划）"></a>7、排队&#x2F;np&#x2F;顶点覆盖问题&#x2F;二部图匹配（线性规划）</h3><h4 id="顶点覆盖问题"><a href="#顶点覆盖问题" class="headerlink" title="顶点覆盖问题"></a>顶点覆盖问题</h4><p><strong>顶点覆盖问题的NP完全性</strong></p>
<ul>
<li>Vertex Covering Problem属于NP问题</li>
<li>任何一个NP完全问题可以规约为顶点覆盖问题</li>
</ul>
<p><strong>顶点覆盖问题属于NP</strong></p>
<ul>
<li>设计一个多项式时间的验证算法，检验：<ul>
<li>给定的顶点集合是原图顶点的一个子集</li>
<li>该顶点集合覆盖了所有的边</li>
</ul>
</li>
<li>上述步骤都可以在多项式时间完成。如果每一步回答都是YES，则返回YES，否则返回NO</li>
</ul>
<p><strong>SAT规约为顶点覆盖问题</strong></p>
<ul>
<li><p>给定一个3-CNF：</p>
<p>$\phi &#x3D; (x_1 \vee x_1 \vee x_2) \wedge (\bar x_1 \vee \bar x_2 \vee \bar x_2) \wedge (\bar x_1 \vee x_2 \vee x_2)$</p>
</li>
<li><p>设计一个顶点覆盖问题与之等价</p>
</li>
</ul>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_112712.png" srcset="/blog/img/loading.gif" lazyload alt="2022-04-30_112712"></p>
<h4 id="二部图匹配"><a href="#二部图匹配" class="headerlink" title="二部图匹配"></a>二部图匹配</h4><p><strong>问题描述</strong></p>
<ul>
<li>二部图G&#x3D;(V,E)是顶点集V可分为两个不相交的子集X和Y的图，使得每个边$e \in E$有一个端点在X中，另一个端点在Y中</li>
<li>一个匹配$M \subseteq E$是边的子集，使得V中的每个节点最多出现在M中的一条边上</li>
<li>Maximal Matching(极大匹配)是指在不将一个节点的度增加到2的情况下，不能再添加任何边的匹配，是一个局部最大值</li>
<li>Maximum Matching(最大匹配)是具有尽可能多的匹配，它是全局最优的</li>
</ul>
<p><strong>二部图与最大流</strong></p>
<ul>
<li>目标：在图中找到最大匹配</li>
<li>可以容易地找到最大匹配：只需在匹配中添加边，直到无法添加更多的边为止</li>
<li>可以证明，对于任何极大匹配(maximal matching) $M$，$|M| \ge \frac 1 2|M^*|$，其中$M^*$是最大匹配(maximum matching)</li>
<li>最大匹配问题可以归结为最大流问题</li>
</ul>
<p><strong>二部图匹配与最大流</strong></p>
<ul>
<li>在$G&#x3D;(V,E)$基础上构造$G’ &#x3D; (V’,E’)$，其中$V’$除$V$中的节点外还包含源s和汇t，$E’$除E中的边外还包含s到X和Y到t的边</li>
<li>所有边具有单位容量</li>
<li>对于大小为k的流，X中的点最多带有一条带流量的出边，Y中3的点最多有一条带流量的入边，X到Y有流量的边的个数是k</li>
<li>解决最大流问题就解决了最大匹配，时间复杂度$O((m+n)n)$</li>
</ul>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_115228.png" srcset="/blog/img/loading.gif" lazyload alt="2022-04-30_115228"></p>
<p><strong>完全匹配</strong></p>
<ul>
<li><p>完全匹配是指每个节点上正好有一条边的匹配</p>
</li>
<li><p>确定给定二部图是否具有完全匹配的一种方法可以先找到最大匹配，再检查匹配的大小是否等于每个部分中的节点数</p>
</li>
<li><p>另一种方法利用了霍尔定理</p>
<blockquote>
<p>二部图G(V,E)具有完全匹配当且仅当对每个子集$S \sube X$或$S \sube Y$，S的邻域的大小至少和S一样大，即$|\gamma (S)| \ge |S|$</p>
</blockquote>
</li>
</ul>
<p><strong>调度问题</strong></p>
<ul>
<li>假设$J&#x3D;\left{J_1,J_2,\dots,J_n\right}$是一组作业，$T&#x3D;\left{ T_1,T_2,\dots,T_k \right}$为可执行这些作业的机器上的可用时隙</li>
<li>每个作业$J$都有一组有效的时隙$S_j \in T$，可以对其进行调度；限制条件是不能同时调度两个作业</li>
<li>问题是如何找到可以调度的最大作业集</li>
<li>这一问题可以归结为二部匹配：对于每个作业，在$X$中创建一个节点，对于每个时隙，在$Y$中创建一个节点；对于$S_j$中的每个时隙，在$X$和$Y$之间创建一条边。二部图的最大匹配就是可以调度的最大作业集</li>
</ul>
<p><strong>调度问题举例</strong></p>
<ul>
<li>某家医院有n名医生，每个医生都有一组休假日。有k个假期段供选择，每个假期段连续跨越几天。设$D_j$为第$j$个假期中包含的天数</li>
<li>在限制条件下，需要最大限度地将医生分配到天，每天一名医生</li>
<li>限制：每个医生都有一个容量$c_i$，是可以安排的最大总天数，每个假期段，任何一个医生最多安排一次</li>
</ul>
<p><strong>转化为最大流问题</strong></p>
<ul>
<li>为每个医生$i$创建一个节点$u_i$，为每个休假日$j$创建一个节点$v_j$；从起始节点s添加一条边到$u_i$，从$v_j$加入一条边到汇点$t$</li>
<li>医生的容量表示为从$s$到$u_i$的边的容量</li>
<li>从节点$v_j$到$t$的边的容量都设置为1，表示每个假期选择一个医生</li>
<li>为了防止医生在休假期间被安排多次，引入中间节点：对于任何医生$i$和假期$j$，创建一个中间节点$w_{ij}$并创建一个从$u_i$到$w_{ij}$的单位容量的边。对于休假期间医生有空的每一天，创建一条从$w_{ij}$到该天节点的单位容量边</li>
</ul>
<p><strong>加入中间节点</strong></p>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-04_102711.png" srcset="/blog/img/loading.gif" lazyload alt="2022-05-04_102711"></p>
<p><strong>线性规划</strong></p>
<ul>
<li>把最大流可以归结为线性规划问题</li>
<li>首先考虑最大流问题的一个例子，$G&#x3D;(V,E)$，边$e \in E$的容量为$c_e$</li>
<li>设变量$f_e$为边$e$上的流量，下面的线性规划可用于最大流问题</li>
</ul>
<p>$ max \sum_{v:(s,v) \in E} $ </p>
<p>subject to $\sum_{u:(u,v) \in E}f(u,v) &#x3D; \sum_{u:(v,u) \in E}f(v,u) $ $\forall v \in V,v \ne s,$ </p>
<p>$0 \le f_e &lt; c_e $ ，$\forall e \in E$</p>
<p><strong>线性规划形式</strong></p>
<p>$min \sum_i c_ix_i$</p>
<p>subject to $\sum_i A_{ij}x_i \ge b_j$  $\forall j$</p>
<p>$ x_i \ge 0$  $\forall i$ </p>
<p><strong>线性规划举例</strong></p>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/90cf3102072a47d92eec4727d52285b.jpg" srcset="/blog/img/loading.gif" lazyload alt="90cf3102072a47d92eec4727d52285b"></p>
<h3 id="8、线性代数解法-x2F-随机化算法-x2F-knuth-shuffle-x2F-扩展计数范围-x2F-负载均衡问题-x2F-球和桶-x2F-遗传算法"><a href="#8、线性代数解法-x2F-随机化算法-x2F-knuth-shuffle-x2F-扩展计数范围-x2F-负载均衡问题-x2F-球和桶-x2F-遗传算法" class="headerlink" title="8、线性代数解法&#x2F;随机化算法&#x2F;knuth shuffle&#x2F;扩展计数范围&#x2F;负载均衡问题&#x2F;球和桶&#x2F;遗传算法"></a>8、线性代数解法&#x2F;随机化算法&#x2F;knuth shuffle&#x2F;扩展计数范围&#x2F;负载均衡问题&#x2F;球和桶&#x2F;遗传算法</h3><h4 id="线性代数解法练习"><a href="#线性代数解法练习" class="headerlink" title="线性代数解法练习"></a>线性代数解法练习</h4><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/2022-05-04_135935.png" srcset="/blog/img/loading.gif" lazyload alt="2022-05-04_135935"></p>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/09ec96aa4d19bf976ce665f5b08067d.jpg" srcset="/blog/img/loading.gif" lazyload alt="09ec96aa4d19bf976ce665f5b08067d"></p>
<h4 id="随机化算法（拉斯维加斯和蒙特卡洛）"><a href="#随机化算法（拉斯维加斯和蒙特卡洛）" class="headerlink" title="随机化算法（拉斯维加斯和蒙特卡洛）"></a>随机化算法（拉斯维加斯和蒙特卡洛）</h4><ul>
<li><p>随机化算法是一种类似于可以投掷硬币并根据投掷结果采取不同行动的算法，将讨论两种随机算法：</p>
</li>
<li><p>Las Vegas：随机化算法总是能给出正确答案，但在某些情况下可能花费更长的时间。它们的“预期”运行时间是输入大小的多项式，意味着所有可能投币的平均运行时间是多项式。</p>
<ul>
<li><p>在最坏的情况下，拉斯维加斯算法可能需要指数级的时间。</p>
</li>
<li><p>拉斯维加斯算法的一个例子是快速排序：它根据投币量做出一些决策，总是产生正确的结果，其预期运行时间和最坏情况下的运行时间分别是$nlogn$和$n^2$</p>
</li>
</ul>
</li>
<li><p>Monte Carlo算法：这些是指有时会得出一个错误的答案的随机算法。</p>
<ul>
<li>像拉斯维加斯算法一样，它们的预期运行时间是多项式的，但在最坏情况下可能是指数的。</li>
<li>通常可以通过多次运行Monte Carlo算法，将得到正确答案的概率“提升”到我们喜欢的最小值。</li>
<li>例如，如果一个特定的蒙特卡洛算法产生一个概率为$\frac 1 4$的错误结果，并且我们有能力洁厕到一个错误的结果，那么在t次独立运行之后，没有得到正确答案的概率是$(\frac 1 4)^t$。</li>
<li>在某些优化问题中，我们没有能力检测错误的答案，但可以比较不同的答案，并选择最好的一个。</li>
</ul>
</li>
</ul>
<blockquote>
<p>拉斯维加斯算法：采样越多，越有机会找到最优解（试钥匙）</p>
<p>蒙特卡罗算法：采样越多，越近似最优解（挑最大的苹果）</p>
</blockquote>
<p><strong>随机化的优势</strong></p>
<p>随机算法相比确定型算法具有几个有点：</p>
<ul>
<li>简单性。对于相同的任务，随机算法往往比确定型算法简单。例如，快速排序枢纽元的选择。</li>
<li>效率。对于某些问题，随机算法比确定型算法具有更好的渐近运行时间：对某些问题，确定型算法是以指数时间运行的，而随机算法是已知多项式时间的。</li>
<li>当算法面临信息不足时，随机化是非常有用的。</li>
</ul>
<h4 id="Karger随机化算法"><a href="#Karger随机化算法" class="headerlink" title="Karger随机化算法"></a>Karger随机化算法</h4><h4 id="knuth-shuffle"><a href="#knuth-shuffle" class="headerlink" title="knuth shuffle"></a>knuth shuffle</h4><p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">a,n</span>):<br>    tmp = a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &gt;= n: <span class="hljs-keyword">return</span> a<br>    i = random.randint(<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>)<br>    a[<span class="hljs-number">0</span>] = a[i]<br>    a[i] = tmp<br>    shuffle(a[<span class="hljs-number">1</span>:],n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    n = <span class="hljs-built_in">len</span>(a)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(shuffle(a,n))<br></code></pre></td></tr></table></figure>

<blockquote>
<p>可能因为依赖的<code>random.randint()</code>这个函数，感觉在短时间内的随机性不是很好</p>
</blockquote>
<h4 id="扩展计数范围"><a href="#扩展计数范围" class="headerlink" title="扩展计数范围"></a>扩展计数范围</h4><p>问题描述：给一个能在1-7中取随机的<code>rand7()</code>，设计一个能在1-10中取随机的<code>rand10()</code>，要求取到每个数的概率相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand7</span>():<br>    <span class="hljs-keyword">return</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand10</span>():<br>    x=-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> x == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> x &gt; <span class="hljs-number">40</span>:<br>        x = (rand7() - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + rand7()<br>    x = x%<span class="hljs-number">10</span>+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(rand10())<br></code></pre></td></tr></table></figure>



<h4 id="负载均衡问题"><a href="#负载均衡问题" class="headerlink" title="负载均衡问题"></a>负载均衡问题</h4><ul>
<li>在多个资源之间分配任务</li>
<li>例如，Nginx一种支持反向代理的开源Web服务器，可以用于高性能的负载均衡</li>
<li>在网络服务器之间合理分配请求，使每个服务器的工作量基本相同</li>
<li>简单的方法就是把任务以均匀分布方式分发给服务器</li>
</ul>
<p><strong>Nginx负载均衡方法</strong></p>
<ul>
<li>Round-Robin：对应用服务器的请求按照轮转方式分配</li>
<li>最少连接数：将下一条请求分配给活跃连接数最少的服务器</li>
<li>IP-hash：基于客户端的IP地址，使用哈希函数来决定为下一条请求分配哪一个服务器</li>
</ul>
<h4 id="球和桶"><a href="#球和桶" class="headerlink" title="球和桶"></a>球和桶</h4><ul>
<li>考虑把m个球扔进n个桶的过程</li>
<li>每一个球都以$\frac 1 n$的概率进入不同的桶，独立于其他的球</li>
<li>碰撞：两个球扔进同一个桶</li>
</ul>
<p><strong>基本结论</strong></p>
<ul>
<li><p>两球碰撞的概率是多少？</p>
</li>
<li><p>使用贝叶斯定理，再计算边际概率</p>
</li>
<li><p>把球i进入桶j的事件记作$B_i^j$</p>
<p>$Pr[Col_{12}] &#x3D; \sum^2_{i&#x3D;1}Pr[B^i_2|B^i_1]Pr[B^i_1] &#x3D; \sum^n_{i&#x3D;1} \frac 1 n Pr[B^i_1] &#x3D; \frac 1 n$</p>
</li>
<li><p>m个球进入n个桶相撞次数的期望值是：$\sum_{i \ne j}Pr[Col_{ij}]&#x3D;\frac 1 n C^2_m$</p>
</li>
<li><p>一个桶为空的概率是多少？一个球不落入桶i的概率是$1-\frac 1 n$，因此桶始终为空的概率是$(1-\frac 1 n)^n \to \frac 1 e$</p>
</li>
<li><p>空桶个数的期望值是多少？$\frac n e$</p>
</li>
<li><p>一个桶内恰好有k个球的概率是多少？$C_n^k(\frac 1 n)^k(1-\frac 1 n)^{n-k} \le \frac {n^k} {k!} \frac 1 {n^k} &#x3D; \frac 1 {k!}$</p>
</li>
<li><p>一个桶内至少有k个球的概率是多少？$\le C^k_n(\frac 1 n)^k \le (\frac e k)^k$</p>
</li>
</ul>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-06_152213.png" srcset="/blog/img/loading.gif" lazyload alt="2022-05-06_152213"></p>
<h4 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h4><p><strong>介绍</strong></p>
<ul>
<li>遗传算法是一种优化算法，用来寻找最大化或最小化的一个特定的函数的最优解</li>
<li>遗传算法是一个演化计算研究领域的一个分支，模拟繁殖和自然选择的生物过程来求解问题</li>
<li>与进化论一样，遗传算法的许多过程都是随机的，但允许人们设置随机水平和控制水平，比随机搜索和穷举搜索算法更强大和有效</li>
<li>优势在于不需要关于给定问题的额外信息，找到其他优化方法由于缺乏连续性、导数、线性或其他特性而无法处理的问题的解</li>
</ul>
<p><strong>算法的构成</strong></p>
<p>模拟生物过程设计，相关术语多从生物学中借用，但比其生物对应物要简单。具体包含如下组成部分：</p>
<ul>
<li>一个用于优化的适应度函数</li>
<li>一个染色体群体</li>
<li>选择哪些染色体将繁殖的方式</li>
<li>产生下一代染色体的交叉方式</li>
<li>新一代染色体中的随机变异</li>
</ul>
<p><strong>适应度函数</strong></p>
<ul>
<li>适应度函数是指算法力图优化的指标函数</li>
<li>适应度一词源自进化论，用适应度函数测试并量化每个潜在解决方案的适合程度</li>
<li>设计适应度函数是算法中最关键的部分之一</li>
<li>从随机选择的染色体初始群体开始，遗传算法用适应度函数对群体中的每一条染色体进行评估，检验它们解决问题的好坏</li>
</ul>
<h3 id="9、演化算法-x2F-模拟退火算法"><a href="#9、演化算法-x2F-模拟退火算法" class="headerlink" title="9、演化算法&#x2F;模拟退火算法"></a>9、演化算法&#x2F;模拟退火算法</h3><h4 id="遗传算法-1"><a href="#遗传算法-1" class="headerlink" title="遗传算法"></a>遗传算法</h4><p><strong>适应度函数</strong></p>
<ul>
<li>适应度函数是指算法力图优化的指标函数</li>
<li>适应度一词源自进化论，用适应度函数测试并量化每个潜在解决方案的适合程度</li>
<li>设计适应度函数是算法中最关键的部分之一</li>
<li>从随机选择的染色体初始群体开始，遗传算法用适应度函数对群体中的每一条染色体将进行评估，检验它们解决问题的好坏</li>
</ul>
<p><strong>染色体</strong></p>
<ul>
<li>染色体是指代表遗传算法候选解决方案一个或多个数值</li>
<li>每个候选解都被编码为一组参数值，如果问题具有维度n，则通常每个染色体编码为n元数组：$chromosome&#x3D;[p_1,p_2,…,p_n]$，其中每个$p_i$是第i个参数的取值</li>
<li>将候选解的样本空间转化为染色体是遗传算法的关键，例如二进制可将每个参数值转换为一个0&#x2F;1字符串以创建染色体</li>
</ul>
<p><strong>选择算子</strong></p>
<ul>
<li>选择算子根据用户定义的概率分布选择一些染色体进行复制</li>
<li>染色体fitness越高，被选中的可能性就越大。例如，如果f是一个非负适应度函数，那么选择$C_{25}$染色体进行繁殖的概率可以设成$Pr(C_{25} &#x3D; \frac {f(C_{25})} {\sum_i^n f(C_i)} )$</li>
<li>选择算子以带替换的方式选择染色体，因此同一染色体可以多次选择</li>
</ul>
<p><strong>Roullete</strong></p>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-06_200508.png" srcset="/blog/img/loading.gif" lazyload alt="2022-05-06_200508"></p>
<p><strong>交叉算子与变异算子</strong></p>
<ul>
<li>交叉算子类似于细胞减数分裂中染色体的生物交叉和重组</li>
<li>该操作符交换两条所选染色体的子序列来产生两个后代。例如，如果父代染色体为[11010111001000],[01011101010010]，在第四位之后交换，则子代染色体为[01010111001000],[11011101010010]</li>
<li>变异算子随机翻转新染色体中的单个位(将0变为1，反之亦然)，通常把变异发生的概率设为很低，如0.001</li>
</ul>
<p><strong>遗传算法的步骤</strong></p>
<ul>
<li>随机产生初始种群</li>
<li>选择其中一组进行交配，繁殖下一代，使用交叉算子</li>
<li>使用变异算子</li>
<li>得到子代后，重新评估适应度函数，接收则停止，否则返回第二步</li>
</ul>
<p><strong>单变量函数的优化</strong></p>
<p><strong>代际更替</strong></p>
<p><strong>连续值遗传算法</strong></p>
<p><strong>遗传算法的问题</strong></p>
<ul>
<li>如果算法需要搜索连续值，则需要把染色体转换为实数值数组</li>
<li>算法的解受到浮点数精度的制约</li>
<li>连续值遗传算法可以比二进制遗传算法更快，因为在计算适应度值时无需预先解码</li>
<li>例如，适应度函数为$f(x) &#x3D; 2xsin(x)+ysin(2y)$，$chromosone&#x3D;[x,y]$，$0 \le x \le 10,0 \le y \le 10$</li>
<li>可以提升变异概率，保留部分上一代的个体进入下一代。需要设计新的选择概率形式和交叉算子</li>
</ul>
<p><strong>遗传算法应用</strong></p>
<ul>
<li><p>背包问题：选择物品，在满足重量约束下使价值最高</p>
</li>
<li><p>染色体编码：二进制编码，位数与物品数量一致，1代表放入，0表示不放</p>
</li>
<li><p>适应度函数：不超出重量限制时取价值之和，否则设为-1</p>
</li>
<li><p>选择概率：$Pr(x_i) &#x3D; \frac {e^{f(x_i)}} {\sum ^n_j e^{f(x_j)}}$</p>
</li>
</ul>
<p><strong>遗传算法问题</strong></p>
<ul>
<li>每一代种群相当于一组可行解</li>
<li>按照概率分布探索解空间的不同区域</li>
<li>优点：较少的迭代次数，较低的计算强度，可以设计不同的适应度函数求解复杂的优化问题</li>
<li>困难：收敛过快，易于陷入局部最优；交叉和变异可能导致进入不可行的区域</li>
</ul>
<h5 id="遗传算法实现"><a href="#遗传算法实现" class="headerlink" title="遗传算法实现"></a>遗传算法实现</h5><p>种群初始化：通过随机生成的方式来创造一个种群，采用二进制将一个染色体编码为基因型，随后用进制转化，将二进制的基因型转化为十进制的表现型。</p>
<p>适应度计算（种群评估）：将目标函数值作为个体的适应度。</p>
<p>选择（复制）操作：根据种群中个体的适应度大小，通过轮盘赌等方式将适应度高的个体从当前种群中选择出来。其中轮盘赌即是与适应度成正比的概率来确定各个个体遗传到下一代群体中的数量。具体步骤如下：</p>
<ul>
<li>首先计算所有个体的适应度总和$\sum f_i$</li>
<li>其次计算出每个个体的相对适应度大小$\frac {f_i} {\sum_{f_i}}$</li>
<li>再产生一个0到1之间的随机数，依据随机数出现在上述哪个概率区域来确定各个个体被选中的次数</li>
</ul>
<p>交叉（交配）运算：该步骤是遗传算法中产生新的个体的主要操作过程，它用一定的交配概率阈值(pc，一般是0.4到0.99)来控制是否采取单点交叉，多点交叉等方式生成新的交叉个体。具体步骤如下：</p>
<ul>
<li>先对群体随机配对</li>
<li>再随机设定交叉点的位置</li>
<li>再互换配对染色体间的部分基因</li>
</ul>
<p>变异运算：该步骤是产生新的个体的另一种操作。一般先随机产生变异点，再根据变异概率阈值(pm，一般是0.0001到0.1)将变异点原有基因取反</p>
<p>终止判断：如果满足条件（迭代次数，一般是200~500）则终止算法，否则返回适应度计算</p>
<p><strong>代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> cm<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br><br><span class="hljs-comment"># sample:计算F(x,y)在[-3,3]和[-3,3]里的最大值</span><br><br><span class="hljs-comment"># 初始化</span><br>DNA_SIZE = <span class="hljs-number">24</span><br>POP_SIZE = <span class="hljs-number">200</span><br>CROSSOVER_RATE = <span class="hljs-number">0.8</span><br>MUTATION_RATE = <span class="hljs-number">0.005</span><br>N_GENERATIONS = <span class="hljs-number">50</span><br>X_BOUND = [-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>Y_BOUND = [-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>*(<span class="hljs-number">1</span>-x)**<span class="hljs-number">2</span>*np.exp(-(x**<span class="hljs-number">2</span>)-(y+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span>)-<span class="hljs-number">10</span>*(x/<span class="hljs-number">5</span>- x**<span class="hljs-number">3</span> - y**<span class="hljs-number">5</span>)*np.exp(-x**<span class="hljs-number">2</span>-y**<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>/<span class="hljs-number">3</span>**np.exp(-(x+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> - y**<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 适应度函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_fitness</span>(<span class="hljs-params">pop</span>):<br>    x,y = translateDNA(pop)<br>    pred = F(x,y)<br>    <span class="hljs-keyword">return</span> (pred - np.<span class="hljs-built_in">min</span>(pred)) + <span class="hljs-number">1e-3</span><br><br><span class="hljs-comment"># 解码函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">translateDNA</span>(<span class="hljs-params">pop</span>):<br>    x_pop = pop[:,<span class="hljs-number">1</span>::<span class="hljs-number">2</span>] <span class="hljs-comment"># 奇数列</span><br>    y_pop = pop[:,::<span class="hljs-number">2</span>] <span class="hljs-comment"># 偶数列</span><br>    x = x_pop.dot(<span class="hljs-number">2</span>**np.arange(DNA_SIZE)[::-<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(<span class="hljs-number">2</span>**DNA_SIZE-<span class="hljs-number">1</span>)*(X_BOUND[<span class="hljs-number">1</span>]-X_BOUND[<span class="hljs-number">0</span>])+X_BOUND[<span class="hljs-number">0</span>]<br>    y = y_pop.dot(<span class="hljs-number">2</span>**np.arange(DNA_SIZE)[::-<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(<span class="hljs-number">2</span>**DNA_SIZE-<span class="hljs-number">1</span>)*(Y_BOUND[<span class="hljs-number">1</span>]-Y_BOUND[<span class="hljs-number">0</span>])+Y_BOUND[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> x,y<br><br><span class="hljs-comment"># 交叉变异</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crossover_and_mutation</span>(<span class="hljs-params">pop,CROSSOVER_RATE = <span class="hljs-number">0.8</span></span>):<br>    new_pop = []<br>    <span class="hljs-keyword">for</span> father <span class="hljs-keyword">in</span> pop:<br>        child = father<br>        <span class="hljs-keyword">if</span> np.random.rand() &lt; CROSSOVER_RATE:<br>            mother = pop[np.random.randint(POP_SIZE)]<br>            cross_points = np.random.randint(low=<span class="hljs-number">1</span>,high=DNA_SIZE*<span class="hljs-number">2</span>)<br>            child[cross_points:] = mother[cross_points:]<br>        mutation(child)<br>        new_pop.append(child)<br>    <span class="hljs-keyword">return</span> new_pop<br><br><span class="hljs-comment"># 变异</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mutation</span>(<span class="hljs-params">child,MUTATION_RATE=<span class="hljs-number">0.001</span></span>):<br>    <span class="hljs-keyword">if</span> np.random.rand() &lt; MUTATION_RATE:<br>        mutate_point = np.random.randint(<span class="hljs-number">0</span>,DNA_SIZE*<span class="hljs-number">2</span>)<br>        child[mutate_point] = child[mutate_point]^<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 选择</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">pop, fitness</span>):<br>    idx = np.random.choice(np.arange(POP_SIZE),size=POP_SIZE,replace=<span class="hljs-literal">True</span>,p=(fitness)/(fitness.<span class="hljs-built_in">sum</span>()))<br>    <span class="hljs-keyword">return</span> pop[idx]<br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_info</span>(<span class="hljs-params">pop</span>):<br>    fitness = get_fitness(pop)<br>    max_fitness_index = np.argmax(fitness)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;max_fitness:&quot;</span>,fitness[max_fitness_index])<br>    x,y = translateDNA(pop)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最优的基因型：&quot;</span>,pop[max_fitness_index])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(x,y):&quot;</span>,(x[max_fitness_index],y[max_fitness_index]))<br><br><span class="hljs-comment"># 可视化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_3d</span>(<span class="hljs-params">ax</span>):<br><br>    X = np.linspace(*X_BOUND, <span class="hljs-number">100</span>)<br>    Y = np.linspace(*Y_BOUND, <span class="hljs-number">100</span>)<br>    X,Y = np.meshgrid(X,Y)<br>    Z = F(X,Y)<br>    ax.plot_surface(X,Y,Z,rstride=<span class="hljs-number">1</span>,cstride=<span class="hljs-number">1</span>,cmap=cm.coolwarm)<br>    ax.set_zlim(-<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>    ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    ax.set_zlabel(<span class="hljs-string">&#x27;z&#x27;</span>)<br>    plt.pause(<span class="hljs-number">3</span>)<br>    plt.show()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GAs</span>():<br><br>    fig = plt.figure()<br>    ax = Axes3D(fig)<br>    plt.ion()<br>    plot_3d(ax)<br><br>    <span class="hljs-comment"># 随机产生初始种群</span><br>    pop = np.random.randint(<span class="hljs-number">2</span>,size=(POP_SIZE,DNA_SIZE*<span class="hljs-number">2</span>))<br><br>    <span class="hljs-comment"># 迭代N代</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N_GENERATIONS):<br>        x,y = translateDNA(pop)<br><br>        <span class="hljs-comment"># 可视化</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sca&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">locals</span>():<br>            sca.remove()<br>        sca = ax.scatter(x,y,F(x,y),c=<span class="hljs-string">&#x27;black&#x27;</span>,marker=<span class="hljs-string">&#x27;o&#x27;</span>);plt.show();plt.pause(<span class="hljs-number">0.1</span>)<br><br>        pop = np.array(crossover_and_mutation(pop,CROSSOVER_RATE))<br>        fitness = get_fitness(pop)<br>        pop = select(pop,fitness)<br><br>    print_info(pop)<br>    plt.ioff()<br>    plot_3d(ax)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    GAs()<br></code></pre></td></tr></table></figure>



<h4 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h4><ul>
<li>模拟退火算法采用Monte Carlo方法，模仿金属退火时的加热-冷却过程来求解最大规模组合优化问题</li>
<li>与遗传算法相似，采用随机方式探索解空间，可用于非连续、不可微、非凸问题</li>
<li>与遗传算法不同，模拟退火在理论上具有可以保证的收敛性</li>
<li>遗传算法种群中的每一个点具有独立性，可以并行执行；模拟退火算法从单点出发，在存在很多局部最优解的情况下可以跳出局部寻找全局最优</li>
</ul>
<p> <strong>退火</strong></p>
<ul>
<li><p>固体材料加热到超过熔点，然后冷却回固体状态</p>
</li>
<li><p>最终的结构取决于冷却的方式</p>
<ul>
<li>缓慢冷却–大晶体（能量低）</li>
<li>快速冷却–缺陷（能量高）</li>
</ul>
</li>
<li><p>Metropolis算法模拟系统在冷却过程中能量变化，系统会最终收敛到某种能量的“冻结”状态</p>
</li>
<li><p>根据热力学：在温度T时，能量增加$\delta E$的概率为：$P(\triangle E) &#x3D; e^{-\frac {\delta E} {kT}}$</p>
</li>
</ul>
<p><strong>模拟退火算法实施</strong></p>
<ul>
<li>与一般的爬山法相似，区别在于不是接受最佳移动，而是接受一个随机移动</li>
<li>如果移动改进了结果，则接受；否则算法以一个小于1的概率采取这种移动（Metropolis判据）</li>
<li>接受概率与移动使解变坏的程度$\triangle E$有关，与其指数成反比：$Pr(\text{accepting uphill move}) \sim 1-e^{\frac {\triangle E} {kT}}$</li>
<li>参数T表示退火时的温度，T越大，接受的概率越大；k实质是Boltzmann常数。选择参数T逐步下降，$T(k+1)&#x3D;\alpha T(k), \alpha &lt; 1$</li>
</ul>
<p><strong>退火过程</strong></p>
<ul>
<li>凝聚态物理中，固体液化时在加热后需要冷却，使粒子在低能量状态下重新组织为晶格形式</li>
<li>在寻优过程中，允许偶发的上升，逃脱局部最优的陷阱</li>
</ul>
<p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-07_163131.png" srcset="/blog/img/loading.gif" lazyload alt="2022-05-07_163131"></p>
<p><strong>模拟退火过程</strong></p>
<ul>
<li>设置初始温度</li>
<li>重复下列步骤<ol>
<li>按预定次数执行<ul>
<li>生成一个扰动</li>
<li>如果能量下降，接受新的状态；否则以$P(\triangle E)$接受新的概率状态</li>
<li>降低温度</li>
</ul>
</li>
<li>直到冻结</li>
</ol>
</li>
</ul>
<p><strong>分析</strong></p>
<ul>
<li>在高温下，接受更差步骤的概率更改。如果$T&#x3D;\infin$，所有动作均可接受，对应于随机局部行走</li>
<li>在低温下，接受更差步骤的概率降低。如果$T&#x3D;0$，不接受更差的移动，搜索等同于局部搜索</li>
<li>接受解的质量大幅度退化的概率呈指数下降，趋近于0</li>
<li>温度必须足够高才允许移动到几乎所有邻近状态</li>
</ul>
<p><strong>分析</strong></p>
<ul>
<li>平稳分布（玻尔兹曼）：$P(x) ∝ e^{\frac {E(x)} T}$</li>
<li>如果T下降的足够慢，就会收敛到最优状态</li>
<li>考虑两个相邻状态x,y，$E(y) &lt; E(x)$</li>
<li>假设x→y和y→x且出度D(x)&#x3D;D(y)&#x3D;D</li>
<li>设P(x),P(y)为T点的均衡占有概率，P(x→y)是状态x跃迁到状态y的概率</li>
<li>为了避开局部最优，需要的爬坡步数越多，越不可能连续爬坡</li>
<li>“足够慢”也许意味着指数级的慢</li>
</ul>
<h5 id="模拟退火实现"><a href="#模拟退火实现" class="headerlink" title="模拟退火实现"></a>模拟退火实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.animation <span class="hljs-keyword">as</span> animation<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br><br><span class="hljs-comment"># sample: 求解一元函数y=x+10sin(5x)+7cos(4x)的最大值</span><br><br><span class="hljs-comment"># 判断函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Judge</span>(<span class="hljs-params">deltaE,T</span>):<br>    <span class="hljs-keyword">if</span> deltaE &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># probability会变大</span><br>        probability = math.exp(deltaE/T)<br>        <span class="hljs-comment"># random.random() 用于生成一个0到1的随机浮点数</span><br>        <span class="hljs-keyword">if</span> probability &gt; random.random():<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 为当前解添加随机扰动</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Disturbance</span>(<span class="hljs-params">low,high,x_old</span>):<br>    <span class="hljs-keyword">if</span> random.random() &gt; <span class="hljs-number">0.5</span>:<br>        x_new = x_old + (high-x_old)*random.random()<br>    <span class="hljs-keyword">else</span>:<br>        x_new = x_old - (x_old-low)*random.random()<br>    <span class="hljs-keyword">return</span> x_new<br><br><span class="hljs-comment"># 优化目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Func</span>(<span class="hljs-params">x</span>):<br>    y = x+<span class="hljs-number">10</span>*math.sin(<span class="hljs-number">5</span>*x)+<span class="hljs-number">7</span>*math.cos(<span class="hljs-number">4</span>*x)<br>    <span class="hljs-keyword">return</span> y<br><br><span class="hljs-comment"># 退火过程</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SA</span>(<span class="hljs-params">low,high,T,T_min,alpha,counter</span>):<br>    c = <span class="hljs-number">0</span><br>    x_old = low+(high-low)*random.random()<br>    x_new = x_old<br>    value_old = Func(x_old)<br>    value_new = Func(x_new)<br>    record_x = []<br>    record_y = []<br>    <span class="hljs-keyword">while</span> T &gt; T_min <span class="hljs-keyword">and</span> c &lt; counter:<br>        x_new = Disturbance(low, high, x_old)<br>        value_new = Func(x_new)<br>        deltaE = value_new - value_old<br>        <span class="hljs-comment"># 求最大值：deltaE&gt;0更优 deltaE&lt;0更劣 </span><br>        <span class="hljs-keyword">if</span> Judge(deltaE,T) == <span class="hljs-number">1</span>:<br>            value_old = value_new<br>            record_x.append(x_new)<br>            record_y.append(value_new)<br>            x_old = x_new<br>        <span class="hljs-keyword">if</span> deltaE &gt; <span class="hljs-number">0</span>:<br>            T = T*alpha<br>        <span class="hljs-keyword">else</span>:<br>            counter += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 可视化</span><br>    <span class="hljs-comment"># 第一个图：显示x,y各自的取值</span><br>    length = <span class="hljs-built_in">len</span>(record_x)<br>    index = [i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length)]<br>    plt.plot(index,record_y)<br>    plt.plot(index,record_x)<br>    <br>    <span class="hljs-comment"># 第二个图：显示x,y曲线</span><br>    x = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10000</span>)<br>    y = x+<span class="hljs-number">10</span>*np.sin(<span class="hljs-number">5</span>*x)+<span class="hljs-number">7</span>*np.cos(<span class="hljs-number">4</span>*x)<br>    plt.plot(x,y)<br><br>    <span class="hljs-comment"># 绘制动画</span><br>    fig, ax = plt.subplots()<br>    l = ax.plot(x,y)<br>    dot, = ax.plot([],[],<span class="hljs-string">&#x27;ro&#x27;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>        ax.set_xlim(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>        ax.set_ylim(-<span class="hljs-number">16</span>,<span class="hljs-number">25</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_dot</span>():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> index:<br>            newdot = [record_x[i-<span class="hljs-number">1</span>],record_y[i-<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">yield</span> newdot<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_dot</span>(<span class="hljs-params">newd</span>):<br>        dot.set_data(newd[<span class="hljs-number">0</span>],newd[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dot,<br><br>    ani = animation.FuncAnimation(<br>        fig, update_dot, frames = gen_dot, repeat = <span class="hljs-literal">False</span>, <br>        interval = <span class="hljs-number">10</span>, init_func = init)<br><br>    plt.show()<br><br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    SA(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1e5</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">0.98</span>,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<p><strong>练习</strong></p>
<ul>
<li>函数形式：$f(x)&#x3D;x^3-60x^2+900x+100$</li>
<li>编码x：5位二进制整数</li>
<li>邻域：随机反转某一位的值</li>
<li>初始值：$x_0&#x3D;0x10101,T_0&#x3D;800$</li>
<li>冷却方案：$T_k&#x3D;0.9T_{k-1}$</li>
</ul>
<h3 id="10、分治算法回顾-x2F-矩阵运算-x2F-流算法-x2F-在线算法"><a href="#10、分治算法回顾-x2F-矩阵运算-x2F-流算法-x2F-在线算法" class="headerlink" title="10、分治算法回顾&#x2F;矩阵运算&#x2F;流算法&#x2F;在线算法"></a>10、分治算法回顾&#x2F;矩阵运算&#x2F;流算法&#x2F;在线算法</h3><h4 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h4><p>8min PPT：问题的定义、算法、分析、实现及举例</p>
<p> 时间空间复杂度 不足及改进的思路</p>
<p>周六实验课演示</p>
<p>可选主题：寻找最近邻点问题、寻找凸包问题、最长公共子序列问题、最优二叉搜索树、人员分配问题、旅行商问题(TSP)、A*算法、素数检验问题、子集和问题近似求解、顶点覆盖问题</p>
<h4 id="分治算法回顾"><a href="#分治算法回顾" class="headerlink" title="分治算法回顾"></a>分治算法回顾</h4><p>矩阵运算</p>
<h5 id="Strassen算法"><a href="#Strassen算法" class="headerlink" title="Strassen算法"></a>Strassen算法</h5><h4 id="流算法"><a href="#流算法" class="headerlink" title="流算法"></a>流算法</h4><h3 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h3><h3 id="12、实验课（pre）"><a href="#12、实验课（pre）" class="headerlink" title="12、实验课（pre）"></a>12、实验课（pre）</h3><h4 id="x3D-x3D-寻找最近邻点问题-x3D-x3D"><a href="#x3D-x3D-寻找最近邻点问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;寻找最近邻点问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;寻找最近邻点问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-寻找凸包问题-x3D-x3D"><a href="#x3D-x3D-寻找凸包问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;寻找凸包问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;寻找凸包问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-最长公共子序列问题-x3D-x3D"><a href="#x3D-x3D-最长公共子序列问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;最长公共子序列问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;最长公共子序列问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-最优二叉搜索树-x3D-x3D"><a href="#x3D-x3D-最优二叉搜索树-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;"></a>&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;</h4><h4 id="x3D-x3D-人员分配问题-x3D-x3D"><a href="#x3D-x3D-人员分配问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;人员分配问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;人员分配问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-旅行商问题（TSP）-x3D-x3D"><a href="#x3D-x3D-旅行商问题（TSP）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;旅行商问题（TSP）&#x3D;&#x3D;"></a>&#x3D;&#x3D;旅行商问题（TSP）&#x3D;&#x3D;</h4><h4 id="x3D-x3D-A-算法-x3D-x3D"><a href="#x3D-x3D-A-算法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;A*算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;A*算法&#x3D;&#x3D;</h4><h4 id="x3D-x3D-素数检验问题-x3D-x3D"><a href="#x3D-x3D-素数检验问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;素数检验问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;素数检验问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-子集和问题近似求解-x3D-x3D"><a href="#x3D-x3D-子集和问题近似求解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;子集和问题近似求解&#x3D;&#x3D;"></a>&#x3D;&#x3D;子集和问题近似求解&#x3D;&#x3D;</h4><h4 id="x3D-x3D-顶点覆盖问题-x3D-x3D"><a href="#x3D-x3D-顶点覆盖问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;</h4>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E7%AE%97%E6%B3%95/">#算法</a>
      
        <a href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">#动态规划</a>
      
        <a href="/blog/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/">#随机化算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法设计</div>
      <div>https://yoonalis.github.io/blog/2022/09/01/算法设计/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2022/09/01/%E5%8C%BA%E5%9D%97%E9%93%BE/" title="区块链">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">区块链</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/" title="实训总结">
                        <span class="hidden-mobile">实训总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
