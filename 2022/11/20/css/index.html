

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="css">
<meta property="og:type" content="article">
<meta property="og:title" content="css">
<meta property="og:url" content="https://yoonalis.github.io/blog/2022/11/20/css/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="css">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/css.jpg">
<meta property="article:published_time" content="2022-11-20T13:49:55.367Z">
<meta property="article:modified_time" content="2023-03-05T04:44:04.979Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="css">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/css.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>css - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="css"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-20 21:49" pubdate>
          2022年11月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          186k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          1548 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">css</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/css/index.asp">https://www.w3school.com.cn/css/index.asp</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn">https://developer.mozilla.org/zh-CN/docs/Learn</a></li>
</ol>
</blockquote>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics/css-declaration-small.png" srcset="/blog/img/loading.gif" lazyload alt="图解 CSS 声明"></p>
<p>整个结构称为 <strong>规则集</strong>（通常简称“规则”），各部分释义如下：</p>
<ul>
<li><p>选择器（<strong>Selector</strong>）</p>
<p>HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 <code>p</code> 元素）。要给不同元素添加样式只需要更改选择器就行了。</p>
</li>
<li><p>声明（<strong>Declaration</strong>）</p>
<p>一个单独的规则，如 <code>color: red;</code> 用来指定添加样式元素的<strong>属性</strong>。</p>
</li>
<li><p>属性（<strong>Properties</strong>）</p>
<p>改变 HTML 元素样式的途径。（本例中 <code>color</code> 就是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p">&#96;&#96;</a> 元素的属性。）CSS 中，由编写人员决定修改哪个属性以改变规则。</p>
</li>
<li><p>属性的值（Property value）</p>
<p>在属性的右边，冒号后面即<strong>属性的值</strong>，它从指定属性的众多外观中选择一个值（我们除了 <code>red</code> 之外还有很多属性值可以用于 <code>color</code> ）。</p>
</li>
</ul>
<p>注意其他重要的语法：</p>
<ul>
<li>每个规则集（除了选择器的部分）都应该包含在成对的大括号里（<code>&#123;&#125;</code>）。</li>
<li>在每个声明里要用冒号（<code>:</code>）将属性与属性值分隔开。</li>
<li>在每个规则集里要用分号（<code>;</code>）将各个声明分隔开。</li>
</ul>
<p>如果要同时修改多个属性，只需要将它们用分号隔开，就像这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-1-选择器"><a href="#2-1-选择器" class="headerlink" title="2.1 选择器"></a>2.1 选择器</h3><h4 id="不同类型的选择器"><a href="#不同类型的选择器" class="headerlink" title="不同类型的选择器"></a><strong>不同类型的选择器</strong></h4><p>选择器有许多不同的类型。上面只介绍了<strong>元素选择器</strong>，用来选择 HTML 文档中给定的元素。但是选择操作可以更加具体。下面是一些常用的选择器类型：</p>
<table>
<thead>
<tr>
<th align="left">选择器名称</th>
<th align="left">选择的内容</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">元素选择器（也称作标签或类型选择器）</td>
<td align="left">所有指定 (该) 类型的 HTML 元素</td>
<td align="left"><code>p</code> 选择 <code>&lt;p&gt;</code></td>
</tr>
<tr>
<td align="left">ID 选择器</td>
<td align="left">具有特定 ID 的元素（单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID）</td>
<td align="left"><code>#my-id</code> 选择 <code>&lt;p id=&quot;my-id&quot;&gt;</code> 或 <code>&lt;a id=&quot;my-id&quot;&gt;</code></td>
</tr>
<tr>
<td align="left">类选择器</td>
<td align="left">具有特定类的元素（单一页面中，一个类可以有多个实例）</td>
<td align="left"><code>.my-class</code> 选择 <code>&lt;p class=&quot;my-class&quot;&gt;</code> 和 <code>&lt;a class=&quot;my-class&quot;&gt;</code></td>
</tr>
<tr>
<td align="left">属性选择器</td>
<td align="left">拥有特定属性的元素</td>
<td align="left"><code>img[src]</code> 选择 <code>&lt;img src=&quot;myimage.png&quot;&gt;</code> 而不是 <code>&lt;img&gt;</code></td>
</tr>
<tr>
<td align="left">伪（Pseudo）类选择器</td>
<td align="left">特定状态下的特定元素（比如鼠标指针悬停）</td>
<td align="left"><code>a:hover</code> 仅在鼠标指针悬停在链接上时选择 <code>&lt;a&gt;</code>。</td>
</tr>
</tbody></table>
<h4 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a><strong>选择器列表</strong></h4><p>如果你有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。例如，如果我的<code>h1</code>和<code>.special</code>类有相同的 CSS，那么我可以把它们写成两个分开的规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我也可以将它们组合起来，在它们之间加上一个逗号，变为选择器列表。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>空格可以在逗号前或后，你可能还会发现如果每个选择器都另起一行，会更好读些。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在下面的实时示例中，试着把两个有相同声明的选择器组合起来。外观在组合起来以后应该还是一样的。</p>
<p>当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。</p>
<h4 id="选择器种类"><a href="#选择器种类" class="headerlink" title="选择器种类"></a><strong>选择器种类</strong></h4><p><strong>标签属性选择器</strong></p>
<p>这组选择器根据一个元素上的某个标签的属性的存在以选择元素的不同方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure>

<p>或者根据一个有特定值的标签属性是否存在来选择：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure>

<h4 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a><strong>伪类与伪元素</strong></h4><p>这组选择器包含了伪类，用来样式化一个元素的特定状态。例如<code>:hover</code>伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br></code></pre></td></tr></table></figure>

<p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。例如，<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行，类似<code>&lt;span&gt;</code>包在了第一个被格式化的行外面，然后选择这个<code>&lt;span&gt;</code>。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure>

<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h4><p>最后一组选择器可以将其他选择器组合起来，更复杂的选择元素。下面的示例用运算符（<code>&gt;</code>）选择了<code>&lt;article&gt;</code>元素的初代子元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span> &#123; &#125;<br></code></pre></td></tr></table></figure>

<h4 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a><strong>全局选择器</strong></h4><p>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容，比如，它紧随在其他元素以及邻代运算符之后的时候）。下面的示例中，我们已经用全局选择器，移去了所有元素上的外边距。这就是说，和浏览器以外边距隔开标题和段的方式默认加上的样式不同的是，每个物件都紧紧地挨在一起，我们不能那么容易就看清楚不同的段。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种行为有时能在“重置样式表”中看到，其中所有浏览器所做的样式化都会被忽略。这些一度很受欢迎，但是把所有的样式化忽略掉的话，通常就是指，你必须做把这些样式带回来的工作！因此我们应小心使用全局选择器，以处理诸如下面所述之类的很特殊的情况。</p>
<p>全局选择器的一种用法是让选择器更易读，更明显地表明它们的作用。例如，如果我想选中任何<code>&lt;article&gt;</code>元素的第一子元素，不论它是什么元素，都给它加粗，我可以将<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a>选择器（我们将会在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">伪类和伪元素</a>课中进一步了解）用作<code>&lt;article&gt;</code>元素选择器的一个后代选择器：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> <span class="hljs-selector-pseudo">:first</span>-child &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这会和<code>article:first-child</code>混淆，而后者选择了作为其他元素的第一子元素的<code>&lt;article&gt;</code>元素。</p>
<p>为了避免这种混淆，我们可以向<code>:first-child</code>选择器加入全局选择器，这样选择器所做的事情很容易就能看懂。选择器正选中<code>&lt;article&gt;</code>元素的<em>任何</em>第一子元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> *<span class="hljs-selector-pseudo">:first</span>-child &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="多个类被应用的时候指向一个元素"><a href="#多个类被应用的时候指向一个元素" class="headerlink" title="多个类被应用的时候指向一个元素"></a><strong>多个类被应用的时候指向一个元素</strong></h4><p>你能对一个元素应用多个类，然后分别指向它们，或者仅仅在选择器中存在所有这些类的时候选择这一元素。在你的站点上，构建可以以不同方式组合起来的组件的时候，这会有用。</p>
<p>在下面的示例中，有一个包含了一条笔记的<code>&lt;div&gt;</code>。灰色的边框在盒子带有<code>notebox</code>类的时候应用。如果它还有一个<code>warning</code>或是<code>danger</code>类，我们改变<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a>。</p>
<p>为了告诉浏览器我们只想匹配带有所有这些类的元素，我们可以将这些类不加空格地连成一串。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox&quot;</span>&gt;</span><br>    This is an informational note.<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox warning&quot;</span>&gt;</span><br>    This note shows a warning.<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox danger&quot;</span>&gt;</span><br>    This note shows danger!<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;danger&quot;</span>&gt;</span><br>    This won&#x27;t get styled — it also needs to have the notebox class<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.notebox</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#666</span>;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.warning</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: orange;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.danger</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: red;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225135912071-20230305%2010:50:47.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230225135912071"></p>
<h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a><strong>ID 选择器</strong></h4><p>ID 选择器开头为<code>#</code>而非句点，不过基本上和类选择器是同种用法。可是在一篇文档中，一个 ID 只会用到一次。它能选中设定了<code>id</code>的元素，你可以在 ID 前面加上类型选择器，只指向元素和 ID 都匹配的类。在下面的示例里，你可以看看这两种用法。</p>
<p><em>备注：</em>正如我们在和特定性相关的课里面学到的那样，ID 所指特定，会优先于大多数其他选择器。所以很难处理它们。大多数情况下，给一个元素加个类，而不是使用 ID，会更好。不过要是 ID 是唯一一种指定这个元素的方式的话——也许是因为你没法访问标记标记因此不能编辑——这种方式可行。</p>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><p>从 HTML 的学习中，你已经知道，元素可以带有属性，它提供了关于如何标记的更详细信息。CSS 中，你能用属性选择器来选中带有特定属性的元素。本节课中，我们将会为你展示如何使用这些很有用的选择器。</p>
<p><strong>存否和值选择器</strong></p>
<p>这些选择器允许基于一个元素自身是否存在（例如<code>href</code>）或者基于各式不同的按属性值的匹配，来选取元素。</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr]</code></td>
<td align="left"><code>a[title]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td>
</tr>
<tr>
<td align="left"><code>[attr=value]</code></td>
<td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr~=value]</code></td>
<td align="left"><code>p[class~=&quot;special&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td>
</tr>
<tr>
<td align="left">&#96;[attr</td>
<td align="left">&#x3D;value]&#96;</td>
<td align="left">&#96;div[lang</td>
</tr>
</tbody></table>
<p>下面的示例中，你可以看到这些选择器是怎样使用的。</p>
<ul>
<li>使用<code>li[class]</code>，我们就能匹配任何有 class 属性的选择器。这匹配了除了第一项以外的所有项。</li>
<li><code>li[class=&quot;a&quot;]</code>匹配带有一个<code>a</code>类的选择器，不过不会选中一部分值为<code>a</code>而另一部分是另一个用空格隔开的值的类，它选中了第二项。</li>
<li><code>li[class~=&quot;a&quot;]</code>会匹配一个<code>a</code>类，不过也可以匹配一列用空格分开、包含<code>a</code>类的值，它选中了第二和第三项。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Attribute presence and value selectors<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a b&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ab&quot;</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class]</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">200%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class~=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225140919072-20230305%2010:51:16.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230225140919072"></p>
<p><strong>子字符串匹配选择器</strong></p>
<p>这些选择器让更高级的属性的值的子字符串的匹配变得可行。例如，如果你有<code>box-warning</code>和<code>box-error</code>类，想把开头为“box-”字符串的每个物件都匹配上的话，你可以用<code>[class^=&quot;box-&quot;]</code>来把它们两个都选中。</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr^=value]</code></td>
<td align="left"><code>li[class^=&quot;box-&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr$=value]</code></td>
<td align="left"><code>li[class$=&quot;-box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td>
</tr>
<tr>
<td align="left"><code>[attr*=value]</code></td>
<td align="left"><code>li[class*=&quot;box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td>
</tr>
</tbody></table>
<p>下个示例展示了这些选择器的用法：</p>
<ul>
<li><code>li[class^=&quot;a&quot;]</code>匹配了任何值开头为<code>a</code>的属性，于是匹配了前两项。</li>
<li><code>li[class$=&quot;a&quot;]</code>匹配了任何值结尾为<code>a</code>的属性，于是匹配了第一和第三项。</li>
<li><code>li[class*=&quot;a&quot;]</code>匹配了任何值的字符串中出现了<code>a</code>的属性，于是匹配了所有项。</li>
</ul>
<p><strong>大小写敏感</strong></p>
<p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。这个标记告诉浏览器，要以大小写不敏感的方式匹配 ASCII 字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式，进行匹配——HTML 中是大小写敏感的。</p>
<p>下面的示例中，第一个选择器将会匹配一个开头为<code>a</code>的值，这样它只匹配了第一项，因为另外两项开头是大写的 A。第二个选择器使用了大小写不敏感的标记，于是匹配了所有项。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span> i]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>备注：</em>此外还有一个更加新的<code>s</code>值，它会强制在上下文的匹配正常为大小写不敏感的时候，强行要求匹配时大小写敏感。不过，在浏览器中它不太受支持，而且在上下文为 HTML 时也没啥用。</p>
<h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p>下一组我们将了解的选择器被称为<strong>伪类</strong>和<strong>伪元素</strong>。这一类选择器的数量众多，通常用于很明确的目的。一旦你了解了如何使用它们，你便可以通过查阅列表来寻找合适的那一项以完成你想要的选择。与之前一样，每个选择器相关的 MDN 页面都将帮助你了解各浏览器的支持情况。</p>
<p><strong>什么是伪类</strong></p>
<p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。</p>
<p>伪类就是开头为冒号的关键字：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">:pseudo-class-name<br></code></pre></td></tr></table></figure>

<p>我们可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a>伪类选择器——这将<em>一直</em>选中文章中的第一个子元素，我们将不再需要编辑 HTML（编辑 HTML 并不总是可行，也许是因为它是由一个 CMS 生成的）。</p>
<p>所有的伪类以同样的方式实现。它们选中你的文档中处于某种状态的那部分，表现得就像是你已经向你的 HTML 加入类一样。看下 MDN 上的另外几个示例：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></li>
</ul>
<p>更多伪类用法参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-broken">https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-broken</a></p>
<h4 id="用户行为伪类"><a href="#用户行为伪类" class="headerlink" title="用户行为伪类"></a>用户行为伪类</h4><p>一些伪类只会在用户以某种方式和文档交互的时候应用。这些<strong>用户行为伪类</strong>，有时叫做<strong>动态伪类</strong>，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。案例包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a>——上面提到过，只会在用户将指针挪到元素上的时候才会激活，一般就是链接元素。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a>——只会在用户使用键盘控制，选定元素的时候激活。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">color</span>: rebeccapurple;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>:hotpink;<br>&#125;   <br></code></pre></td></tr></table></figure>

<p><strong>伪元素</strong></p>
<p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:</span><span class="hljs-symbol">:pseudo-element-name</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p>
</blockquote>
<p>例如，如果你想选中一段的第一行，你可以把它用一个<code>&lt;span&gt;</code>元素包起来，然后使用元素选择器；不过，如果包起来的单词&#x2F;字符数目长于或者短于父元素的宽度，这样做会失败。由于我们一般不会知道一行能放下多少单词&#x2F;字符——因为屏幕宽度或者字体大小改变的时候这也会变——通过改变 HTML 的方式来可预测地这么做是不可能的。</p>
<p><code>::first-line</code>伪元素选择器会值得信赖地做到这件事——即使单词&#x2F;字符的数目改变，它也只会选中第一行。</p>
<p>这表现得就像是<code>&lt;span&gt;</code>神奇地包在第一个被格式化的行一样，每当行长改变的时候还会更新。</p>
<p>你可以看到它把两段的第一行都选中了。</p>
<p><strong>把伪类和伪元素组合起来</strong></p>
<p>如果你想让第一段的第一行加粗，你需要把<code>:first-child</code>和<code>::first-line</code>选择器放到一起。试着编辑前面的实时示例，让它使用下面的 CSS。这里的意思是，我们想选择一个<code>&lt;article&gt;</code>元素里面的第一个<code>&lt;p&gt;</code>元素的第一行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child<span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">120%</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>生成带有::before 和::after 的内容</strong></p>
<p>有一组特别的伪元素，它们和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性一同使用，使用 CSS 将内容插入到你的文档中中。c</p>
<p>你能用这些插入一个文本字符串，和在下面的实时示例里那样。试着改变<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性的文本值，看看输出是怎么改变的。你也能改变<code>::before</code>伪元素为<code>::after</code>，看到这段文本插入到了元素的末尾而不是开头。</p>
<p>从 CSS 插入文本字符串，我们并不会在 Web 浏览器上经常这么做，因为对于一些屏幕阅读器来说，文本是不可见的，而且对于未来别人的查找和编辑也不是很方便。</p>
<p>这些伪元素的更推荐的用法是插入一个图标，例如下面的示例加入的一个小箭头，作为一个视觉性的提示，而且我们并不希望屏幕阅读器读出它。</p>
<p>这些伪元素经常用于插入空字符串，其后可以像页面上的其他元素被样式化。</p>
<p>下个示例，我们已经用 <code>::before</code>伪元素加入了个空字符串。我们把它设为了<code>display: block</code>，以让它可以用 width 和 height 进行样式化。然后我们可以用 CSS 像任何元素那样样式化。你可以摆弄 CSS，改变它的外观和行为。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>Content in the box in my HTML page.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225142817596-20230305%2010:51:40.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230225142817596"></p>
<p><code>::before</code>和<code>::after</code>伪元素与<code>content</code>属性的共同使用，在 CSS 中被叫做“生成内容”，而且你会见到这种技术被用于完成各种任务。<a target="_blank" rel="noopener" href="http://www.cssarrowplease.com/">CSS Arrow Please</a>网站就是一个著名的示例，它帮你用 CSS 生成一个箭头。在你创建你的箭头的时候看下 CSS，你将会看到实际使用的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a>伪元素。无论什么时候你看到了这些选择器，都要看下<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性，以了解文档中添加了什么。</p>
<h4 id="x3D-x3D-参考节-x3D-x3D"><a href="#x3D-x3D-参考节-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;参考节&#x3D;&#x3D;"></a>&#x3D;&#x3D;参考节&#x3D;&#x3D;</h4><p>有很多伪类和伪元素，所以有一个用于参考的列表会有用。下面是列出它们的表格，链接到了 MDN 上它们的参考页。把这作为参考，看看你能选中什么。</p>
<p><strong>伪类</strong></p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a></td>
<td align="left">在用户激活（例如点击）元素的时候匹配。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link"><code>:any-link</code></a></td>
<td align="left">匹配一个链接的<code>:link</code>和<code>:visited</code>状态。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:blank"><code>:blank</code></a></td>
<td align="left">匹配空输入值的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input">&#96;&#96;元素</a>。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked"><code>:checked</code></a></td>
<td align="left">匹配处于选中状态的单选或者复选框。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:current"><code>:current</code> (en-US)</a></td>
<td align="left">匹配正在展示的元素，或者其上级元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default"><code>:default</code></a></td>
<td align="left">匹配一组相似的元素中默认的一个或者更多的 UI 元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir"><code>:dir</code></a></td>
<td align="left">基于其方向性（HTML<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/dir"><code>dir</code></a>属性或者 CSS<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>属性的值）匹配一个元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled"><code>:disabled</code></a></td>
<td align="left">匹配处于关闭状态的用户界面元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty"><code>:empty</code></a></td>
<td align="left">匹配除了可能存在的空格外，没有子元素的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled"><code>:enabled</code></a></td>
<td align="left">匹配处于开启状态的用户界面元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first"><code>:first</code></a></td>
<td align="left">匹配<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Paged_Media">分页媒体</a>的第一页。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a></td>
<td align="left">匹配兄弟元素中的第一个元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type"><code>:first-of-type</code></a></td>
<td align="left">匹配兄弟元素中第一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a></td>
<td align="left">当一个元素有焦点的时候匹配。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible"><code>:focus-visible</code></a></td>
<td align="left">当元素有焦点，且焦点对用户可见的时候匹配。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within"><code>:focus-within</code></a></td>
<td align="left">匹配有焦点的元素，以及子代元素有焦点的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:future"><code>:future</code> (en-US)</a></td>
<td align="left">匹配当前元素之后的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a></td>
<td align="left">当用户悬浮到一个元素之上的时候匹配。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate"><code>:indeterminate</code></a></td>
<td align="left">匹配未定态值的 UI 元素，通常为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input/checkbox">复选框</a>。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range"><code>:in-range</code></a></td>
<td align="left">用一个区间匹配元素，当值处于区间之内时匹配。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>的位于不可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang"><code>:lang</code></a></td>
<td align="left">基于语言（HTML<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang">lang</a>属性的值）匹配元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></td>
<td align="left">匹配兄弟元素中最末的那个元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type"><code>:last-of-type</code></a></td>
<td align="left">匹配兄弟元素中最后一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left"><code>:left</code></a></td>
<td align="left">在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 (en-US)</a>中，匹配左手边的页。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a></td>
<td align="left">匹配未曾访问的链接。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:local-link"><code>:local-link</code> (en-US)</a></td>
<td align="left">匹配指向和当前文档同一网站页面的链接。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a></td>
<td align="left">匹配传入的选择器列表中的任何选择器。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not"><code>:not</code></a></td>
<td align="left">匹配作为值传入自身的选择器未匹配的物件。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a></td>
<td align="left">匹配一列兄弟元素中的元素——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type"><code>:nth-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child"><code>:nth-last-child</code></a></td>
<td align="left">匹配一列兄弟元素，从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type"><code>:nth-last-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素），从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></td>
<td align="left">匹配没有兄弟元素的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type"><code>:only-of-type</code></a></td>
<td align="left">匹配兄弟元素中某类型仅有的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional"><code>:optional</code></a></td>
<td align="left">匹配不是必填的 form 元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range"><code>:out-of-range</code></a></td>
<td align="left">按区间匹配元素，当值不在区间内的的时候匹配。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:past"><code>:past</code> (en-US)</a></td>
<td align="left">匹配当前元素之前的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown"><code>:placeholder-shown</code></a></td>
<td align="left">匹配显示占位文字的 input 元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:playing"><code>:playing</code> (en-US)</a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:paused"><code>:paused</code> (en-US)</a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only"><code>:read-only</code></a></td>
<td align="left">匹配用户不可更改的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write"><code>:read-write</code></a></td>
<td align="left">匹配用户可更改的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required"><code>:required</code></a></td>
<td align="left">匹配必填的 form 元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right"><code>:right</code></a></td>
<td align="left">在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 (en-US)</a>中，匹配右手边的页。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a></td>
<td align="left">匹配文档的根元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope"><code>:scope</code></a></td>
<td align="left">匹配任何为参考点元素的的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid"><code>:valid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>元素的处于可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target"><code>:target</code></a></td>
<td align="left">匹配当前 URL 目标的元素（例如如果它有一个匹配当前<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fragment_identifier">URL 分段</a>的元素）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a></td>
<td align="left">匹配已访问链接。</td>
</tr>
</tbody></table>
<p><strong>伪元素</strong></p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter"><code>::first-letter</code></a></td>
<td align="left">匹配元素的第一个字母。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line"><code>::first-line</code></a></td>
<td align="left">匹配包含此伪元素的元素的第一行。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error"><code>::grammar-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的语法错误的那部分。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection"><code>::selection</code></a></td>
<td align="left">匹配文档中被选择的那部分。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error"><code>::spelling-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td>
</tr>
</tbody></table>
<h4 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h4><p>我们要了解的最后一种选择器被命名为关系选择器（Combinator），这是因为它们在其他选择器之间和其他选择器与文档内容的位置之间建立了一种有用的关系的缘故。</p>
<p><strong>后代选择器</strong></p>
<p>后代选择器——典型用单个空格（” “）字符——组合两个选择器，比如，第二个选择器匹配的元素被选择，如果他们有一个祖先（父亲，父亲的父亲，父亲的父亲的父亲，等等）元素匹配第一个选择器。选择器利用后代组合符被称作后代选择器。</p>
<p>下面的示例中，我们只会匹配处于带有<code>.box</code>类的元素里面的<code>&lt;p&gt;</code>元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Text in .box<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Text not in .box<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;  <br></code></pre></td></tr></table></figure>

<p><strong>子代关系选择器</strong></p>
<p>子代关系选择器是个大于号（<code>&gt;</code>），只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。例如，只选中作为<code>&lt;article&gt;</code>的直接子元素的<code>&lt;p&gt;</code>元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure>

<p><strong>邻接兄弟</strong></p>
<p>邻接兄弟选择器（<code>+</code>）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件。例如，选中所有紧随<code>&lt;p&gt;</code>元素之后的<code>&lt;img&gt;</code>元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;   <br></code></pre></td></tr></table></figure>

<p><strong>通用兄弟</strong></p>
<p>如果你想选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（<code>~</code>）。要选中所有的<code>&lt;p&gt;</code>元素后<em>任何地方</em>的<code>&lt;img&gt;</code>元素，我们会这样做：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> ~ <span class="hljs-selector-tag">img</span><br></code></pre></td></tr></table></figure>

<p><strong>使用关系选择器</strong></p>
<p>你能用关系选择器，将任何在我们前面的学习过程中学到的选择器组合起来，选出你的文档中的一部分。例如如果我们想选中为<code>&lt;ul&gt;</code>的直接子元素的带有“a”类的列表项的话，我可以用下面的代码。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class=<span class="hljs-string">&quot;a&quot;</span>]</span>  &#123;  &#125;<br></code></pre></td></tr></table></figure>

<p>不过，建立一长列选中你的文档中很明确的部分的选择器的时候，小心一些。这些 CSS 规则难以复用，因为你让选择器在表示标记文本中的元素的相对位置上过于明确。</p>
<p>建立简单的一个类，然后把它应用到有需求的元素上，经常会是更好的做法。不过话说回来，如果你需要让你的文档变换一下样式，但是没法编辑 HTML（也许是因为它由 CMS 生成）的话，你的关系选择器的知识会派上用场。</p>
<h3 id="2-2-盒模型"><a href="#2-2-盒模型" class="headerlink" title="2.2 盒模型"></a>2.2 盒模型</h3><p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用 CSS 实现准确布局、处理元素排列的关键。</p>
<p>本文围绕“盒模型”为主题展开。旨在于完成学习后，您能够在“理解盒装模型原理”的基础上，完成更加复杂的布局任务。 </p>
<h4 id="块级盒子（Block-box）和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box）和 内联盒子（Inline box）"></a><strong>块级盒子（Block box）和 内联盒子（Inline box）</strong></h4><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)。这两种盒子会在<strong>页面流</strong>（page flow）和元素之间的关系方面表现出不同的行为：</p>
<p>一个被定义成块级的（block）盒子会表现出以下行为：</p>
<ul>
<li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li>
<li>每个盒子都会换行</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性可以发挥作用</li>
<li>内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”</li>
</ul>
<p>除非特殊指定，诸如标题 (<code>&lt;h1&gt;</code>等) 和段落 (<code>&lt;p&gt;</code>) 默认情况下都是块级的盒子。</p>
<p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下：</p>
<ul>
<li>盒子不会产生换行。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性将不起作用。</li>
<li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li>
<li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。</li>
</ul>
<p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p>
<p>我们通过对盒子<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p>
<p><strong>补充：内部和外部显示类型</strong></p>
<p>在这里最好也解释下<strong>内部</strong> 和 <strong>外部</strong> 显示类型。如上所述，css 的 box 模型有一个外部显示类型，来决定盒子是块级还是内联。</p>
<p>同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 **<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow">正常文档流</a> **布局，也意味着它们和其他块元素以及内联元素一样 (如上所述).</p>
<p>但是，我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。该盒子的所有直接子元素都会成为 flex 元素，会根据<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">弹性盒子（Flexbox）</a>规则进行布局，稍后您将了解这些规则。</p>
<p>当你进一步了解 css 布局的更多细节的时候，你会了解到 <code>flex</code>，和其他内部显示类型会用到的值，例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids"><code>grid</code></a> 。</p>
<p>块级和内联布局是 web 上默认的行为 —— 正如上面所述，它有时候被称为 <em>正常文档流</em>，因为如果没有其他说明，我们的盒子布局默认是块级或者内联。</p>
<h4 id="不同显示的例子"><a href="#不同显示的例子" class="headerlink" title="不同显示的例子"></a>不同显示的例子</h4><p>让我们继续看看别的例子。下面三个 html 元素，都有一个外部显示类型 <code>block</code>。第一个是一个段落，在 CSS 中加了边框。浏览器把它渲染成一个块级盒子，所以段落从新的一行开始，而且宽度占满一行。</p>
<p>第二个是一个列表，布局属性是 <code>display: flex</code>。将在容器中建立一个 flex 布局，但是每个列表是一个块级元素 —— 像段落一样 —— 会充满整个容器的宽度并且换行。</p>
<p>下面有个块级段落，里面有两个 <code>&lt;span&gt;</code> 元素。正常情况下是 <code>inline</code>，但是其中一个加了 block 类，设置属性 <code>display: block</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am a paragraph. A short one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item One<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item Two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item Three<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am another paragraph. Some of the <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;block&quot;</span>&gt;</span>words<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> have been wrapped in a <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span element<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>, <br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid rebeccapurple;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.block</span>,<br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-selector-class">.block</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225145508512-20230305%2010:52:00.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230225145508512"></p>
<p>我们可以看到 <code>inline</code> 元素在下面例子中的表现。 <code>&lt;span&gt;</code> 在第一段默认是内联元素所以不换行。</p>
<p>还有一个 <code>&lt;ul&gt;</code> 设置为 <code>display: inline-flex</code>，使得在一些 flex 元素外创建一个内联框。</p>
<p>最后设置两个段落为 <code>display: inline</code>。inline flex 容器和段落在一行上而不是像块级元素一样换行。</p>
<p><strong>你可以修改 <code>display: inline</code> 为 <code>display: block</code> 或者 <code>display: inline-flex</code> 改为 <code>display: flex</code> 来观察显示模式切换。</strong></p>
<p>在后面的内容中会遇到诸如弹性盒子布局的内容；现在需要记住的是， <code>display</code> 属性可以改变盒子的外部显示类型是块级还是内联，这将会改变它与布局中的其他元素的显示方式。</p>
<p>剩下的内容，我们会专注于外部显示类型。</p>
<h4 id="什么是-CSS-盒模型？"><a href="#什么是-CSS-盒模型？" class="headerlink" title="什么是 CSS 盒模型？"></a>什么是 CSS 盒模型？</h4><p>完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。</p>
<p><strong>盒模型的各个部分</strong></p>
<p>CSS 中组成一个块级盒子需要：</p>
<ul>
<li><strong>Content box</strong>: 这个区域是用来显示内容，大小可以通过设置 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>.</li>
<li><strong>Padding box</strong>: 包围在内容区域外部的空白区域；大小通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a> 相关属性设置。</li>
<li><strong>Border box</strong>: 边框盒包裹内容和内边距。大小通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 相关属性设置。</li>
<li><strong>Margin box</strong>: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 相关属性设置。</li>
</ul>
<p>如下图：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/box-model.png" srcset="/blog/img/loading.gif" lazyload alt="Diagram of the box model"></p>
<p><strong>标准盒模型</strong></p>
<p>在标准模型中，如果你给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 <em>content box</em>。padding 和 border 再加上设置的宽高一起决定整个盒子的大小。见下图。</p>
<p>假设定义了 <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>, and <code>padding</code>:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">350px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用标准模型，实际占用空间的宽高分别为：宽度 &#x3D; 410px (350 + 25 + 25 + 5 + 5)，高度 &#x3D; 210px (150 + 25 + 25 + 5 + 5)。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/standard-box-model.png" srcset="/blog/img/loading.gif" lazyload alt="Showing the size of the box when the standard box model is being used."></p>
<p><strong>备注：</strong> margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到 margin。</p>
<p><strong>替代（IE）盒模型</strong></p>
<p>你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的 ! 因为这个原因，css 还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width &#x3D; 350px, height &#x3D; 150px).</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/alternate-box-model.png" srcset="/blog/img/loading.gif" lazyload alt="Showing the size of the box when the alternate box model is being used."></p>
<p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 <code>box-sizing: border-box</code> 来实现。这样就可以告诉浏览器使用 <code>border-box</code> 来定义区域，从而设定您想要的大小。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你希望所有元素都使用替代模式，而且确实很常用，设置 <code>box-sizing</code> 在 <code>&lt;html&gt;</code> 元素上，然后设置所有元素继承该属性，正如下面的例子。如果想要深入理解，请看 <a target="_blank" rel="noopener" href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">the CSS Tricks article on box-sizing</a>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br>*, *<span class="hljs-selector-pseudo">::before</span>, *<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: inherit;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 一个有趣的历史记录 ——Internet Explorer 默认使用替代盒模型，没有可用的机制来切换。（译者注：IE8+ 支持使用 <code>box-sizing</code> 进行切换）</p>
<h4 id="外边距，内边距，边框"><a href="#外边距，内边距，边框" class="headerlink" title="外边距，内边距，边框"></a><strong>外边距，内边距，边框</strong></h4><p>您已经在上面的示例中看到了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性。该示例中使用的是属性的<strong>简写</strong>，允许我们一次设置盒子的四个边。这些简写等价于分别控制盒子的不同边的普通写法。</p>
<p>接下来，我们更详细地研究这些属性：</p>
<p><strong>外边距</strong></p>
<p>外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p>
<p>我们可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>属性一次控制一个元素的所有边距，或者每边单独使用等价的普通属性控制：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-left"><code>margin-left</code></a></li>
</ul>
<p><strong>边框</strong></p>
<p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p>
<p>为边框设置样式时，有大量的属性可以使用——有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。</p>
<p>可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性一次设置所有四个边框的宽度、颜色和样式。</p>
<p>分别设置每边的宽度、颜色和样式，可以使用：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></li>
</ul>
<p>设置所有边的颜色、样式或宽度，请使用以下属性：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></li>
</ul>
<p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-style"><code>border-top-style</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-color"><code>border-top-color</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-width"><code>border-right-width</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-style"><code>border-right-style</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-color"><code>border-right-color</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-width"><code>border-bottom-width</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-style"><code>border-bottom-style</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-color"><code>border-bottom-color</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-width"><code>border-left-width</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-style"><code>border-left-style</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-color"><code>border-left-color</code></a></li>
</ul>
<p><strong>设置边框的颜色、样式或宽度，可以使用最细粒度的普通属性或者简写属性。在下面的示例中，我们使用了各种普通属性或者简写属性来创建边框。尝试一下不同的属性，以检查您是否理解它们是如何工作的。MDN 中的边框属性页面为您提供可用的不同边框样式的信息。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">5px</span> dotted green;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> double <span class="hljs-built_in">rgb</span>(<span class="hljs-number">23</span>,<span class="hljs-number">45</span>,<span class="hljs-number">145</span>);<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333333</span>;<br>  <span class="hljs-attribute">border-top-style</span>: dotted;<br>  <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border-bottom-color</span>: hotpink;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>内边距</strong></p>
<p>内边距位于边框和内容区域之间。与外边距不同，您不能有负数量的内边距，所以值必须是 0 或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p>
<p>我们可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>简写属性控制元素所有边，或者每边单独使用等价的普通属性：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-top"><code>padding-top</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-bottom"><code>padding-bottom</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a></li>
</ul>
<p><strong>盒子模型和内联盒子</strong></p>
<p>以上所有的方法都完全适用于块级盒子。有些属性也可以应用于内联盒子，例如由<code>&lt;span&gt;</code>元素创建的那些内联盒子。</p>
<p>在下面的示例中，我们在一个段落中使用了<code>&lt;span&gt;</code>，并对其应用了宽度、高度、边距、边框和内边距。可以看到，宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p>
<p><strong>使用 display: inline-block</strong></p>
<p>display 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用：您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p>
<p>一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果：</p>
<ul>
<li>设置<code>width</code> 和<code>height</code> 属性会生效。</li>
<li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li>
</ul>
<p>但是，它不会跳转到新行，如果显式添加 <code>width</code> 和 <code>height</code> 属性，它只会变得比其内容更大。</p>
<p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<code>&lt;a&gt;</code> 是像 <code>&lt;span&gt;</code> 一样的内联元素；你可以使用 <code>display: inline-block</code> 来设置内边距，让用户更容易点击链接。</p>
<p>这种情况在导航栏中很常见。下面的导航使用 flexbox 显示在一行中，我们为 <code>&lt;a&gt;</code> 元素添加了内边距，因为我们希望能够在 <code>&lt;a&gt;</code> 在鼠标移动到上面时改变背景色。内边距似乎覆盖了 <code>&lt;ul&gt;</code> 元素上的边框。这是因为 <code>&lt;a&gt;</code> 是一个内联元素。</p>
<p>使用 <code>.links-list a</code> 选择器将 <code>display: inline-block</code> 添加到样式规则中，你将看到它是如何通过内边距推开其他元素来修复这个问题的。</p>
<p>这就是你需要了解的关于盒子模型的大部分内容。如果以后你发现对于盒模型的布局仍有困惑，你将会回来温故这些内容。</p>
<h3 id="2-3-背景与边框"><a href="#2-3-背景与边框" class="headerlink" title="2.3 背景与边框"></a>2.3 背景与边框</h3><p>在这节课中，我们来看看，使用 CSS 背景和边框来做一些，具有一些创造性的事情。渐变、背景图像和圆角，背景和边框的巧妙运用是 CSS 中许多样式问题的答案。</p>
<h4 id="css的背景样式"><a href="#css的背景样式" class="headerlink" title="css的背景样式"></a>css的背景样式</h4><p>CSS <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性是我们将在本课中学习的许多普通背景属性的简写。如果您在样式表中发现了一个复杂的背景属性，可能会觉得难以理解，因为可以同时传入这么多值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">2</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>) center center / <span class="hljs-number">400px</span> <span class="hljs-number">200px</span> no-repeat,<br>  <span class="hljs-built_in">url</span>(<span class="hljs-string">big-star.png</span>) center no-repeat, rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在本教程的后面部分，我们将返回到简写的工作方式，但是首先，我们通过分开使用各个普通背景属性的方式，看一下在 CSS 中使用背景可以做哪些不同的事情。</p>
<p><strong>背景颜色</strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color"><code>background-color</code></a> 属性定义了 CSS 中任何元素的背景颜色。属性接受任何有效的<code>&lt;color&gt;值</code>。背景色扩展到元素的内容和内边距的下面。</p>
<p><strong>背景图片</strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 属性允许在元素的背景中显示图像。在下面的例子中，我们有两个方框——一个是比方框大的背景图像，另一个是星星的小图像。</p>
<p><strong>如果除了背景图像外，还指定了背景颜色，则图像将显示在颜色的顶部。</strong></p>
<h4 id="控制背景平铺"><a href="#控制背景平铺" class="headerlink" title="控制背景平铺"></a><strong>控制背景平铺</strong></h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a> 属性用于控制图像的平铺行为。可用的值是：</p>
<ul>
<li><code>no-repeat</code> — 不重复。</li>
<li><code>repeat-x</code> —水平重复。</li>
<li><code>repeat-y</code> —垂直重复。</li>
<li><code>repeat</code> — 在两个方向重复。</li>
</ul>
<h4 id="调整背景图像的大小"><a href="#调整背景图像的大小" class="headerlink" title="调整背景图像的大小"></a><strong>调整背景图像的大小</strong></h4><p>在上面的例子中，我们有一个很大的图像，由于它比作为背景的元素大，所以最后被裁剪掉了。在这种情况下，我们可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。</p>
<p>你也可以使用关键字：</p>
<ul>
<li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li>
<li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li>
</ul>
<p>在下面的例子中，我使用了上面例子中的大图，并使用长度单位来调整方框内的大小。你可以看到这扭曲了图像。</p>
<p>试试下面：</p>
<ul>
<li>改变用于修改背景大小的长度单位。</li>
<li>去掉长度单位，看看使用<code>background-size: cover</code> or <code>background-size: contain</code>会发生什么。</li>
<li>如果您的图像小于盒子，您可以更改 background-repeat 的值来重复图像。</li>
</ul>
<h4 id="背景图像定位"><a href="#背景图像定位" class="headerlink" title="背景图像定位"></a><strong>背景图像定位</strong></h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a> 属性允许您选择背景图像显示在其应用到的盒子中的位置。它使用的坐标系中，框的左上角是 (0,0)，框沿着水平 (x) 和垂直 (y) 轴定位。</p>
<p><strong>备注：</strong> 默认的背景位置值是 (0,0)。</p>
<p>最常见的背景位置值有两个单独的值——一个水平值后面跟着一个垂直值。</p>
<p>你可以使用像<code>top</code>和<code>right</code>这样的关键字 (在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 页面上查找其他的关键字):</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top center;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length">长度值</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage">百分比</a>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">20px</span> <span class="hljs-number">10%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你也可以混合使用关键字，长度值以及百分比，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，您还可以使用 4-value 语法来指示到盒子的某些边的距离——在本例中，长度单位是与其前面的值的偏移量。所以在下面的 CSS 中，我们将背景从顶部调整 20px，从右侧调整 10px:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top <span class="hljs-number">20px</span> right <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a><strong>渐变背景</strong></h4><p>当渐变用于背景时，也可以使用像图像一样的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 属性设置。</p>
<p>您可以在 MDN 的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient">&#96;&#96;</a> 数据类型页面上，了解更多关于渐变的不同类型，以及使用它们可以做的事情。使用渐变的一个有趣方法是，使用 web 上可用的许多 CSS 渐变生成器之一，比如<a target="_blank" rel="noopener" href="https://cssgradient.io/">这个</a>。您可以创建一个渐变，然后复制并粘贴生成它的源代码。</p>
<p>在下面的示例中尝试一些不同的渐变。在这两个盒子里，我们分别有一个线性梯度，它延伸到整个盒子上，还有一个径向梯度，它有一个固定的大小，因此会重复。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">249</span>,<span class="hljs-number">255</span>,<span class="hljs-number">1</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.b</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(circle, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">249</span>,<span class="hljs-number">255</span>,<span class="hljs-number">1</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>);<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100px</span> <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="多个背景图像"><a href="#多个背景图像" class="headerlink" title="多个背景图像"></a><strong>多个背景图像</strong></h4><p>也可以有多个背景图像——在单个属性值中指定多个 <code>background-image</code> 值，用逗号分隔每个值。</p>
<p>当你这样做时，你可能会以背景图像互相重叠而告终。背景将与最后列出的背景图像层在堆栈的底部，背景图像在代码列表中最先出现的在顶端。</p>
<p>其它 <code>background-*</code> 属性，该属性值用逗号分隔的方式设置。例如下列 <code>background-image</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">image1.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image2.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image3.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image4.png</span>);<br><span class="hljs-attribute">background-repeat</span>: no-repeat, repeat-x, repeat;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>,  top right;<br></code></pre></td></tr></table></figure>

<p>不同属性的每个值，将与其他属性中相同位置的值匹配。例如，上面的 image1 的 <code>background-repeat</code> 值将是 <code>no-repeat</code>。但是，当不同的属性具有不同数量的值时，会发生什么情况呢？答案是较小数量的值会循环—在上面的例子中有四个背景图像，但是只有两个背景位置值。前两个位置值将应用于前两个图像，然后它们将再次循环—image3 将被赋予第一个位置值，image4 将被赋予第二个位置值。</p>
<h4 id="背景附加"><a href="#背景附加" class="headerlink" title="背景附加"></a><strong>背景附加</strong></h4><p>另一个可供选择的背景是指定他们如何滚动时，内容滚动。这是由 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a> 属性控制的，它可以接受以下值：</p>
<ul>
<li><code>scroll</code>: 使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li>
<li><code>fixed</code>: 使元素的背景固定在视图端口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。</li>
<li><code>local</code>: 这个值是后来添加的 (它只在 Internet Explorer 9+中受支持，而其他的在 IE4+中受支持)，因为滚动值相当混乱，在很多情况下并不能真正实现您想要的功能。局部值将背景固定在设置的元素上，因此当您滚动元素时，背景也随之滚动。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a> 属性只有在有内容要滚动时才会有效果，所以我们做了一个示例来演示这三个值之间的区别——看看 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html">background-attachment.html</a> (或者看看这儿的 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/tree/master/css/styling-boxes/backgrounds">源代码</a>))。</p>
<h4 id="使用-background-的简写"><a href="#使用-background-的简写" class="headerlink" title="使用 background 的简写"></a><strong>使用 background 的简写</strong></h4><p>正如我在本课开始时提到的，您将经常看到使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性指定的背景。这种简写允许您一次设置所有不同的属性。</p>
<p>如果使用多个背景，则需要为第一个背景指定所有普通属性，然后在逗号后面添加下一个背景。在下面的例子中，我们有一个渐变，它指定大小和位置，然后是一个无重复的图像背景，它指定位置，然后是一个颜色。</p>
<p>这里有一些规则，需要在简写背景属性时遵循，例如：</p>
<ul>
<li><code>background-color</code> 只能在逗号之后指定。</li>
<li><code>background-size</code> 值只能包含在背景位置之后，用’&#x2F;‘字符分隔，例如：<code>center/80%</code>。</li>
</ul>
<p>查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 的 MDN 页面，以查看所有的注意事项。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background</span>:   <br>    <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">2</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>) center center / <span class="hljs-number">400px</span> <span class="hljs-number">200px</span> no-repeat,<br><span class="hljs-built_in">url</span>(<span class="hljs-string">big-star.png</span>) center no-repeat, <br>    rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>背景的无障碍考虑</strong></p>
<p>当你把文字放在背景图片或颜色上面时，你应该注意你有足够的对比度让文字对你的访客来说是清晰易读的。如果指定了一个图像，并且文本将被放置在该图像的顶部，您还应该指定一个<code>background-color</code> ，以便在图像未加载时文本也足够清晰。</p>
<p>屏幕阅读者不能解析背景图像，因此背景图片应该只是纯粹的装饰；任何重要的内容都应该是 HTML 页面的一部分，而不是包含在背景中。</p>
<h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a><strong>边框</strong></h4><p>在学习盒子模型时，我们发现了边框如何影响盒子的大小。在这节课中，我们将看看如何创造性地使用边界。通常，当我们使用 CSS 向元素添加边框时，我们使用一个简写属性在一行 CSS 中设置边框的颜色、宽度和样式。我们可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 为一个框的所有四个边设置边框。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者我们可以只设置盒子的一个边，例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">.<span class="hljs-keyword">box </span>&#123;<br>  <span class="hljs-keyword">border-top: </span><span class="hljs-number">1</span>px solid <span class="hljs-keyword">black;</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure>

<p>这些简写的等价于：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span>: 1px;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以使用更加细粒度的属性：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">width</span>: 1px;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 这些顶部、右侧、底部和左侧边框属性还具有与文档写入模式相关的映射逻辑属性 (例如，从左到右或从右到左的文本，或从上到下)。在下一课中，我们将探讨这些问题，这包括处理不同的文本指示 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Handling_different_text_directions">详情</a>。</p>
<h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a><strong>圆角</strong></h4><p>通过使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a> 属性和与方框的每个角相关的长边来实现方框的圆角。可以使用两个长度或百分比作为值，第一个值定义水平半径，第二个值定义垂直半径。在很多情况下，您将只传递一个值，这两个值都将使用。</p>
<p>例如，要使一个盒子的四个角都有 10px 的圆角半径：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 10px;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或使右上角的水平半径为 1em，垂直半径为 10％：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-top-right-<span class="hljs-built_in">radius</span>: 1em <span class="hljs-number">10</span><span class="hljs-symbol">%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在下面的示例中设置了所有四个角，然后更改右上角的值使之不同。您可以使用这些值来更改圆角样式。查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a> 的属性页，查看可用的语法选项。</p>
<h3 id="2-4-处理不同方向的文本"><a href="#2-4-处理不同方向的文本" class="headerlink" title="2.4  处理不同方向的文本"></a>2.4  处理不同方向的文本</h3><p>目前为止我们在 CSS 学习中遇到的许多属性和属性值与显示器的物理尺度紧密相关。例如，我们会在上、右、下、左设置边框。这些物理尺寸与水平排布的文本相得益彰，并且，默认浏览器对方向从左到右的文本（如英文或法文）的支持，要优于从右到左的文本（如阿拉伯语）的支持。</p>
<p>然而，CSS 在最近几年得到了改进，以更好地支持不同方向的文本，包括从右到左，也包括从上到下的文本（如日文）——这些不同的方向属性被称为书写模式。随着学习的深入，当你开始试着对页面进行布局时，对书写模式的了解将会对你很有帮助，为此我们在这里加以介绍。</p>
<h4 id="什么是书写模式"><a href="#什么是书写模式" class="headerlink" title="什么是书写模式"></a>什么是书写模式</h4><p>CSS 中的书写模式是指文本的排列方向是横向还是纵向的。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a> 属性使我们从一种模式切换到另一种模式。为此，你不必使用一种竖向的语言——你还可以更改部分文字的方向以实现创新性的布局。</p>
<p>我们可以使用<code>writing-mode: vertical-rl</code>对一个标题的显示进行设置。现在，标题文本是竖向的了。竖向文本在平面设计中很常见，也可以为你的网页设计增添更加有趣的外观。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>的三个值分别是：</p>
<ul>
<li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li>
<li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li>
<li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li>
</ul>
<p>因此，<code>writing-mode</code>属性实际上设定的是页面上块级元素的显示方向——要么是从上到下，要么是从右到左，要么是从左到右。而这决定了文本的方向。</p>
<h4 id="书写模式、块级布局和内联布局"><a href="#书写模式、块级布局和内联布局" class="headerlink" title="书写模式、块级布局和内联布局"></a>书写模式、块级布局和内联布局</h4><p>我们已经讨论了块级布局和内联布局（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#block_and_inline_boxes">block and inline layout</a>），也知道外部显示类型元素分为块级元素和内联元素。如上所述，块级显示和内联显示与文本的书写模式（而非屏幕的物理显示）密切相关。如果你使用书写模式的显示是横向的，如英文，那么块在页面上的显示就是从上到下的。</p>
<p>用一个例子可以更清楚地说明这一点。下一个例子中有两个盒子，分别包含一个标题和一个段落。第一个盒子应用的是<code>writing-mode: horizontal-tb</code>，这是一个从上到下的横向的书写模式。第二个盒子应用的是<code>writing-mode: vertical-rl</code>，这是一个从右到左的纵向的书写模式。</p>
<p>当我们切换书写模式时，我们也在改变块和内联文本的方向。<code>horizontal-tb</code>书写模式下块的方向是从上到下的横向的，而 <code>vertical-rl</code>书写模式下块的方向是从右到左的纵向的。因此，块维度指的总是块在页面书写模式下的显示方向。而内联维度指的总是文本方向。</p>
<p>这张图展示了在水平书写模式下的两种维度。<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Handling_different_text_directions/horizontal-tb.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>这张图片展示了纵向书写模式下的两种维度。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Handling_different_text_directions/vertical.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>一旦你开始接触 CSS 布局，尤其是更新的布局方法，这些关于块级元素和内联元素的概念会变得非常重要。我之后会返回来再看。</p>
<h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><p>除了书写模式，我们还可以设置文本方向。正如上面所言，有些语言（如阿拉伯语）是横向书写的，但是是从右向左。当你在对页面布局进行创新时，你可能不这么使用——如果你只是想将某部分内容放到右边排列下来，还有其他方法可以选择——然而，重要的是能意识到，这其实是 CSS 本身功能的一部分。网页可不仅限于从左向右排列的语言！</p>
<p>由于书写模式和文本方向都是可变的，新的 CSS 布局方法不再定义从左到右和从上到下，而是将这些连同内联元素和块级元素的<em>开头</em>和<em>结尾</em>一起考量。现在不必过于担心，但是带着这些概念开始你的布局，你会发现这对你掌握 CSS 非常有用。</p>
<h4 id="逻辑属性和逻辑值"><a href="#逻辑属性和逻辑值" class="headerlink" title="逻辑属性和逻辑值"></a>逻辑属性和逻辑值</h4><p>我们之所以要在这里探讨书写模式和方向，是因为目前为止我们已经了解了很多与屏幕的物理显示密切相关的很多属性，而书写模式和方向在水平书写模式下会很有意义。</p>
<p>让我们再来看看那两个盒子——一个用<code>horizontal-tb</code>设定了书写模式，一个用<code>vertical-rl</code>设定了书写模式。我为这两个盒子分别设定了宽度（ <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>）。可以看到，当盒子处于纵向书写模式下时，宽度也发生了变化，从而导致文本超出了盒子的范围。</p>
<p>通过这一些列调整，我们想要的实际上是使宽和高随着书写模式一起变化。当处于纵向书写模式之下时，我们希望盒子可以向横向模式下一样得到拓宽。</p>
<p>为了更容易实现这样的转变，CSS 最近开发了一系列映射属性。这些属性用逻辑（<strong>logical</strong>）和相对变化（<strong>flow relative</strong>）代替了像宽<code>width</code>和高<code>height</code>一样的物理属性。</p>
<p>横向书写模式下，映射到<code>width</code>的属性被称作内联尺寸（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a>）——内联维度的尺寸。而映射<code>height</code>的属性被称为块级尺寸（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>），这是块级维度的尺寸。下面的例子展示了替换掉<code>width</code>的<code>inline-size</code>是如何生效的。</p>
<h4 id="逻辑外边距、边框和内边距属性"><a href="#逻辑外边距、边框和内边距属性" class="headerlink" title="逻辑外边距、边框和内边距属性"></a>逻辑外边距、边框和内边距属性</h4><p>我们在前面两节中学习了 CSS 的盒模型和 CSS 边框。在外边距、边框和内边距属性中，你会发现许多物理属性，例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a>、 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>。就像 width 和 height 有映射，这些属性也有相应的映射。</p>
<p><code>margin-top</code>属性的映射是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-block-start"><code>margin-block-start</code></a>——总是指向块级维度开始处的边距。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>属性映射到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-inline-start"><code>padding-inline-start</code></a>，这是应用到内联开始方向（这是该书写模式文本开始的地方）上的内边距。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>属性映射到的是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-block-end"><code>border-block-end</code></a>，也就是块级维度结尾处的边框。</p>
<p>下面是物理和逻辑属性之间的对比。</p>
<p><strong>如果你用<code>writing-mode</code>把盒子<code>.box</code>的书写模式改为<code>vertical-rl</code>，你将会看到尽管盒子的物理方向变了，盒子的物理属性仍然没变，然而逻辑属性会随着书写模式一起改变。</strong></p>
<p><strong>你还可以看到，二级标题<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements">&#96;&#96; (en-US)</a>有一个黑色的底部边框<code>border-bottom</code>。你知道如何使得底部边框无论在那种书写模式下都位于文本的下方吗？</strong></p>
<p>对于每一个普通边距，都有许多属性可以参考，你可以在 MDN 页面（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Logical_Properties">Logical Properties and Values</a>）查看所有映射属性。</p>
<p><strong>逻辑值</strong></p>
<p>目前为止我们看到的都是逻辑属性的名称。还有一些属性的取值是一些物理值（如<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>）。这些值同样拥有逻辑值映射（<code>block-start</code>、<code>inline-end</code>、<code>block-end</code>和<code>inline-start</code>）。</p>
<p>例如，你可以将一张图片移到左边，并使文本环绕图片。你可以将<code>left</code>替换为<code>inline-start</code> ，就像下面的例子中一样。</p>
<p><strong>将这个例子的书写模式改为<code>vertical-rl</code>，看看图片会发生什么。将<code>inline-start</code>改为<code>inline-end</code>来改变图片的移动。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box logical&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;big-star.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This box uses logical properties. The star image has been floated inline-start, it also has a margin on the inline-end and block-end.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">inline-size</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">writing-mode</span>: horizontal-tb;<br>&#125;<br><br><span class="hljs-selector-tag">img</span>&#123;<br>  <span class="hljs-attribute">float</span>: inline-start;<br>  <span class="hljs-attribute">margin-inline-end</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin-block-end</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之类，我们同样使用逻辑边距值来保证在任何书写模式下边距的位置都是对的。</p>
<p><strong>应该使用物理属性还是逻辑属性呢？</strong></p>
<p>逻辑属性是在物理属性之后出现的，因而最近才开始在浏览器中应用。你可以通过查看 MDN 的属性页面来了解浏览器对逻辑属性的支持情况。如果你并没有应用多种书写模式，那么现在你可能更倾向于使用物理属性，因为这些在你使用弹性布局和网格布局时非常有用。</p>
<h3 id="2-5-溢出的内容"><a href="#2-5-溢出的内容" class="headerlink" title="2.5 溢出的内容"></a>2.5 溢出的内容</h3><p>本节课，我们来了解一下 CSS 中另外一个重要的概念——<strong>溢出</strong>。溢出是在盒子无法容纳下太多的内容的时候发生的。在这篇教程里面，你将会学习到什么是溢出，以及如何控制它。</p>
<h4 id="什么是溢出？"><a href="#什么是溢出？" class="headerlink" title="什么是溢出？"></a>什么是溢出？</h4><p>我们知道，CSS 中万物皆盒，因此我们可以通过给<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>（或者 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着。CSS 给了你好几种工具来控制溢出，在学习的早期理解这些概念是很有用的。在你写 CSS 的时候你经常会遇到溢出的情形，尤其是当你以后更加深入到 CSS 布局的时候。</p>
<h4 id="CSS-尽力减少“数据损失”"><a href="#CSS-尽力减少“数据损失”" class="headerlink" title="CSS 尽力减少“数据损失”"></a>CSS 尽力减少“数据损失”</h4><p>我们从两个展示了在碰到溢出的时候，CSS 默认会如何处理的例子开始吧。</p>
<p>第一个例子是，一个盒子，在块方向上已经受到<code>height</code>的限制。然后我们已经加了过多的内容，以至于盒子里面没有空间容纳。内容正在从盒子里面溢出，并让自己把盒子下面的段落弄得一团糟。</p>
<p>第二个例子是一个单词，位于在内联方向上受到限制的盒子里面。盒子已经被做得小到无法放置那个单词的地步，于是那个单词就突破了盒子的限制。</p>
<p>你也许会好奇，为什么 CSS 默认会采取如此不整洁的方式，让内容这么凌乱地溢出出来呢？为何不把多余的内容隐藏起来，或者让盒子变大呢？</p>
<p>只要有可能，CSS 就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。在 CSS 的术语里面，这会导致一些内容消失，你的访客可能不会注意到这一点，如果消失的是表格上的提交按钮，没有人能填完这个表格，这是很麻烦的事情！所以 CSS 反而会把它以可见的形式溢出出去。这样做的结果就是，你会看到错误的 CSS 导致的一片混乱，或者最坏的情况也只是你的网站的访客会告诉你有些内容冒了出来，你的网站需要修缮。</p>
<p>如果你已经用<code>width</code>或者<code>height</code>限制住了一个盒子，CSS 假定，你知道你在做什么，而且你已经控制住了溢出的隐患。总之，在盒子里面需要放置文本的时候，限制住块方向的尺寸是会引起问题的，因为可能会有比你在设计网站的时候所预计的文本更多的文本，或者文本变大了——比如用户增加字体大小的时候。</p>
<p>在下面的几节课里，我们会看一下各种不同的控制尺寸的方式，以减少溢出的影响。但是，如果你需要固定的尺寸，你也可以控制溢出表现的形式。那么让我们接着读下去吧！</p>
<p><strong>overflow 属性</strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a>属性是你控制一个元素溢出的方式，它告诉浏览器你想怎样处理溢出。<code>overflow</code>的默认值为<code>visible</code>，这就是我们的内容溢出的时候，我们在默认情况下看到它们的原因。</p>
<p>如果你想在内容溢出的时候把它裁剪掉，你可以在你的盒子上设置<code>overflow: hidden</code>。这就会像它表面上所显示的那样作用——隐藏掉溢出。这可能会很自然地让东西消失掉，所以你只应该在判断隐藏内容不会引起问题的时候这样做。</p>
<p>也许你还会想在有内容溢出的时候加个滚动条？如果你用了<code>overflow: scroll</code>，那么你的浏览器总会显示滚动条，即使没有足够多引起溢出的内容。你可能会需要这样的样式，它避免了滚动条在内容变化的时候出现和消失。</p>
<p><strong>如果你移除了下面的盒子里的一些内容，你可以看一下，滚动条是否还会在没有能滚动的东西的时候保留。</strong></p>
<p>在以上的例子里面，我们仅仅需要在<code>y</code>轴方向上滚动，但是我们在两个方向上都有了滚动条。你可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-y"><code>overflow-y</code></a>属性，设置<code>overflow-y: scroll</code>来仅在<code>y</code>轴方向滚动。</p>
<p>你也可以用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-x"><code>overflow-x</code></a>，以在 x 轴方向上滚动，尽管这不是处理长英文词的好办法！如果你真的需要在小盒子里面和长英文词打交道，那么你可能要了解一下<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>或者<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap"><code>overflow-wrap</code></a>属性。除此以外，一些<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS">在 CSS 里面调整大小</a>这节课里面讨论过的方式可能会帮助你创建可以和有变化容量的内容相协调的盒子。</p>
<p>和<code>scroll</code>一样，在无论是否有多到需要 用滚动条的内容的时候，页面上都会显示一个滚动条。</p>
<p><strong>备注：</strong> 你可以用<code>overflow</code>属性指定 x 轴和 y 轴方向的滚动，同时使用两个值进行传递。如果指定了两个关键字，第一个对<code>overflow-x</code>生效而第二个对<code>overflow-y</code>生效。否则，<code>overflow-x</code>和<code>overflow-y</code>将会被设置成同样的值。例如，<code>overflow: scroll hidden</code>会把<code>overflow-x</code>设置成<code>scroll</code>，而<code>overflow-y</code>则为<code>hidden</code>。</p>
<p>如果你只是想让滚动条在有比盒子所能装下更多的内容的时候才显示，那么使用<code>overflow: auto</code>。此时由浏览器决定是否显示滚动条。桌面浏览器一般仅仅会在有足以引起溢出的内容的时候这么做。</p>
<p>移除一些内容，直到能够装在盒子里面，你还会看到滚动条消失了。</p>
<h4 id="溢出建立了块级排版上下文"><a href="#溢出建立了块级排版上下文" class="headerlink" title="溢出建立了块级排版上下文"></a>溢出建立了块级排版上下文</h4><p>CSS 中有所谓<strong>块级排版上下文</strong>（Block Formatting Context，BFC）<strong>的概念</strong>。现在你不用太过在意，但是你应该知道，在你使用诸如<code>scroll</code>或者<code>auto</code>的时候，你就建立了一个块级排版上下文。结果就是，你改变了<code>overflow</code>的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。激活了滚动动作，你的盒子里面所有的内容会被收纳，而且不会遮到页面上其他的物件，于是就产生了一个协调的滚动体验。</p>
<h4 id="网页设计时不需要的溢出"><a href="#网页设计时不需要的溢出" class="headerlink" title="网页设计时不需要的溢出"></a>网页设计时不需要的溢出</h4><p>现代网页布局的方式（正如<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout">CSS layout</a>模块中所介绍的那些）可以很好地处理溢出。我们不一定能预料到网页上会有多少内容，人们很好地设计它们，使得它们能与这种现状协调。但是在以往，开发者会更多地使用固定高度，尽力让毫无关联的盒子的底部对齐。这是很脆弱的，在旧时的应用里面，你偶尔会遇到一些盒子，它们的内容遮到了页面上的其他内容。如果你看到了，那么你现在应该知道，这就是溢出，理论上你应该能重新排布这些布局，使得它不必依赖于盒子尺寸的调整。</p>
<p>在开发网站的时候，你应该一直把溢出的问题挂在心头，你应该用或多或少的内容测试设计，增加文本的字号，确保你的 CSS 可以正常地协调。改变溢出属性的值，来隐藏内容或者增加滚动条，会是你仅仅在少数特别情况下需要的，例如在你确实需要一个可滚动盒子的时候。</p>
<h3 id="2-6-css的值与单位"><a href="#2-6-css的值与单位" class="headerlink" title="2.6 css的值与单位"></a>2.6 css的值与单位</h3><p>CSS 中使用的每个属性都允许拥有一个或一组值，查看 MDN 上的任何属性页将帮助你理解对任何特定属性有效的值。在本节课中，我们将学习一些最常用的值和单位。</p>
<h4 id="什么是-CSS-的值？"><a href="#什么是-CSS-的值？" class="headerlink" title="什么是 CSS 的值？"></a>什么是 CSS 的值？</h4><p>在 CSS 规范和 MDN 的属性页上，你将能够发现值的存在，因为它们将被尖括号包围，如<code>&lt;color&gt;</code>或<code>&lt;length&gt;</code>。当你看到值<code>&lt;color&gt;</code>对特定属性有效时，这意味着你可以使用任何有效的颜色作为该属性的值，如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">&#96;&#96;</a>参考页面所列。</p>
<p><strong>备注：</strong> 你还将看到被称为数据类型的 CSS 值。这些术语基本上是可以互换的——当你在 CSS 中看到一些被称为数据类型的东西时，它实际上只是一种表示值的奇特方式。</p>
<p><strong>备注：</strong> 是的，CSS 值倾向于使用尖括号表示，以区别于 CSS 属性 (例如<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a>属性和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value"></a> 数据类型)。你可能还会混淆 CSS 数据类型和 HTML 元素，因为它们都使用尖括号，但这不太可能——它们在完全不一样的上下文中使用。</p>
<p>在下面的例子中，我们使用关键字设置标题的颜色，使用<code>rgb()</code>函数设置背景：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">197</span>,<span class="hljs-number">93</span>,<span class="hljs-number">161</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>CSS 中的值类型是一种定义了一些可使用的值的集合的方式。这意味着如果你看到的 <code>&lt;color&gt;</code> 是有效的，那么你就不需要考虑可以使用哪种类型——不管是关键字、十六进制值还是 <code>rgb()</code> 函数等都是有效的。如果浏览器支持这些可用的 <code>&lt;color&gt;</code> 值，则可以使用它们当中的任意一个。MDN 上针对每个值类型的页面将提供有关浏览器支持的信息。例如，如果你查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">&#96;&#96;</a> 的页面，你将看到浏览器兼容性部分列出了不同类型的颜色值以及对它们的支持。</p>
<p>让我们来看看你可能经常遇到的一些值和单位类型，并提供一些示例，以便你尝试使用各种值的可能性。</p>
<h4 id="数字，长度和百分比"><a href="#数字，长度和百分比" class="headerlink" title="数字，长度和百分比"></a>数字，长度和百分比</h4><p>你可能会发现自己在 CSS 中使用了各种数值数据类型。以下全部归类为数值：</p>
<table>
<thead>
<tr>
<th align="left">数值类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer"><code>&lt;integer&gt;</code></a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer"><code>&lt;integer&gt;</code></a>是一个整数，比如 1024 或 -55。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number"><code>&lt;number&gt;</code></a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number"><code>&lt;number&gt;</code></a>表示一个小数——它可能有小数点后面的部分，也可能没有，例如 0.255、128 或 -1.2。</td>
</tr>
<tr>
<td align="left"><code>&lt;dimension&gt;</code></td>
<td align="left"><code>&lt;dimension&gt;</code>是一个<code>&lt;number&gt;</code>，它有一个附加的单位，例如 45deg、5s 或 10px。<code>&lt;dimension&gt;</code>是一个伞形类别，包括<code>&lt;length&gt;</code>、<code>&lt;angle&gt;</code>、<code>&lt;time&gt;</code>和<code>&lt;resolution&gt;</code>类型。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage"><code>percentage</code></a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage"><code>percentage</code></a>表示一些其他值的一部分，例如 50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。</td>
</tr>
</tbody></table>
<h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>最常见的数字类型是<code>&lt;length&gt;</code>，例如 10px(像素) 或 30em。CSS 中有两种类型的长度——相对长度和绝对长度。重要的是要知道它们之间的区别，以便理解他们控制的元素将变得有多大。</p>
<h4 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h4><p>以下都是<strong>绝对</strong>长度单位——它们与其他任何东西都没有关系，通常被认为总是相同的大小。</p>
<table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">名称</th>
<th align="left">等价换算</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cm</code></td>
<td align="left">厘米</td>
<td align="left">1cm &#x3D; 96px&#x2F;2.54</td>
</tr>
<tr>
<td align="left"><code>mm</code></td>
<td align="left">毫米</td>
<td align="left">1mm &#x3D; 1&#x2F;10th of 1cm</td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left">四分之一毫米</td>
<td align="left">1Q &#x3D; 1&#x2F;40th of 1cm</td>
</tr>
<tr>
<td align="left"><code>in</code></td>
<td align="left">英寸</td>
<td align="left">1in &#x3D; 2.54cm &#x3D; 96px</td>
</tr>
<tr>
<td align="left"><code>pc</code></td>
<td align="left">十二点活字</td>
<td align="left">1pc &#x3D; 1&#x2F;6th of 1in</td>
</tr>
<tr>
<td align="left"><code>pt</code></td>
<td align="left">点</td>
<td align="left">1pt &#x3D; 1&#x2F;72th of 1in</td>
</tr>
<tr>
<td align="left"><code>px</code></td>
<td align="left">像素</td>
<td align="left">1px &#x3D; 1&#x2F;96th of 1in</td>
</tr>
</tbody></table>
<p>这些值中的大多数在用于打印时比用于屏幕输出时更有用。例如，我们通常不会在屏幕上使用 cm。惟一一个你经常使用的值，估计就是 px(像素)。</p>
<h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><p>相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，你可以使文本或其他元素的大小与页面上的其他内容相对应。下表列出了 web 开发中一些最有用的单位。</p>
<table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">相对于</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>em</code></td>
<td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td>
</tr>
<tr>
<td align="left"><code>ex</code></td>
<td align="left">字符“x”的高度</td>
</tr>
<tr>
<td align="left"><code>ch</code></td>
<td align="left">数字“0”的宽度</td>
</tr>
<tr>
<td align="left"><code>rem</code></td>
<td align="left">根元素的字体大小</td>
</tr>
<tr>
<td align="left"><code>lh</code></td>
<td align="left">元素的 line-height</td>
</tr>
<tr>
<td align="left"><code>vw</code></td>
<td align="left">视窗宽度的 1%</td>
</tr>
<tr>
<td align="left"><code>vh</code></td>
<td align="left">视窗高度的 1%</td>
</tr>
<tr>
<td align="left"><code>vmin</code></td>
<td align="left">视窗较小尺寸的 1%</td>
</tr>
<tr>
<td align="left"><code>vmax</code></td>
<td align="left">视图大尺寸的 1%</td>
</tr>
</tbody></table>
<h4 id="ems-and-rems"><a href="#ems-and-rems" class="headerlink" title="ems and rems"></a>ems and rems</h4><p><code>em</code>和<code>rem</code>是你在从框到文本调整大小时最常遇到的两个相对长度。了解这些方法是如何工作的以及它们之间的区别是很有意义的，尤其是当你开始学习更复杂的主题时，比如样式化文本或 CSS 布局。下面的示例提供了一个演示。</p>
<p>HTML 是一组嵌套的列表—我们总共有三个列表，并且两个示例都有相同的 HTML。唯一的区别是第一个类具有 ems，第二个类具有 rems。</p>
<p>首先，我们将 16px 设置为<code>&lt;html&gt;</code>元素的字体大小。</p>
<p>概括地说，在排版属性中 em 单位的意思是“父元素的字体大小”。带有 ems 类的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>&lt;ul&gt;</code></a>内的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li"><code>&lt;li&gt;</code></a>元素从它们的父元素中获取大小。因此，每一个连续的嵌套级别都会逐渐变大，因为每个嵌套的字体大小都被设置为 1.3em—是其父嵌套字体大小的 1.3 倍。</p>
<p>概括地说，rem 单位的意思是“根元素的字体大小”。(“根 em”的 rem 标准。)<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>&lt;ul&gt;</code></a>内的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li"><code>&lt;li&gt;</code></a>元素和一个 rems 类从根元素 (<code>&lt;html&gt;)</code>中获取它们的大小。这意味着每一个连续的嵌套层都不会不断变大。</p>
<p>但是，如果你在 CSS 中更改<html>字体大小，你将看到所有其他相关内容都发生了更改，包括 rem 和 em 大小的文本。</p>
<h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h4><p>在许多情况下，百分比与长度的处理方法是一样的。百分比的问题在于，它们总是相对于其他值设置的。例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p>
<p>在下面的示例中，两个百分比大小的框和两个像素大小的框具有相同的类名。分别为 200px 和 40% 宽。</p>
<p>不同之处在于，第二组两个框位于一个 400 像素宽的包装器中。第二个 200px 宽的盒子和第一个一样宽，但是第二个 40% 的盒子现在是 400px 的 40%——比第一个窄多了！</p>
<p>尝试更改包装器的宽度或百分比值，看看这是如何工作的。</p>
<p>注意，虽然许多值接受长度或百分比，但也有一些值只接受长度。你可以在 MDN 属性引用页面上看到它能接受哪些值。如果允许的值包括<code>&lt;length-percent&gt;</code>，则可以使用长度或百分比。如果允许的值只包含<length>，则不可能使用百分比。</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>有些值接受数字，不添加任何单位。接受无单位数字的属性的一个例子是不透明度属性（<code>opacity</code> ），它控制元素的不透明度 (它的透明程度)。此属性接受 0(完全透明) 和 1(完全不透明) 之间的数字。</p>
<p>在下面的示例中，尝试将不透明度值更改为 0 到 1 之间的各种小数值，并查看框及其内容是如何变得透明或者不透明的。</p>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>在 CSS 中指定颜色的方法有很多，其中一些是最近才实现的。在 CSS 中，相同的颜色值可以在任何地方使用，无论你指定的是文本颜色、背景颜色还是其他颜色。</p>
<p>现代计算机的标准颜色系统是 24 位的，它允许通过不同的红、绿、蓝通道的组合显示大约 1670 万种不同的颜色，每个通道有 256 个不同的值 (256 x 256 x 256 &#x3D; 16,777,216)。让我们来看看在 CSS 中指定颜色的一些方法。</p>
<p><strong>备注：</strong> 在本教程中，我们将研究具有良好浏览器支持的常用指定颜色的方法；虽然还有其他的，但是他们没有很好的支持，也不太常见。</p>
<h4 id="颜色关键词"><a href="#颜色关键词" class="headerlink" title="颜色关键词"></a>颜色关键词</h4><p>在这学习示例或 MDN 上的其他示例中，你经常会看到使用的颜色关键字，因为它们是一种指定颜色的简单易懂的方式。有一些关键词，其中一些有相当有趣的名字！你可以在页面上看到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value"><code>&lt;color&gt;</code></a>值的完整列表。</p>
<p><strong>在下面的示例中尝试使用不同的颜色值，以了解它们是如何工作的。</strong></p>
<p><strong>十六进制 RGB 值</strong></p>
<p>你可能遇到的下一种颜色值类型是十六进制代码。每个十六进制值由一个散列&#x2F;磅符号 (#) 和六个十六进制数字组成，每个十六进制数字都可以取 0 到 f(代表 15) 之间的 16 个值中的一个——所以是 0123456789abcdef。每对值表示一个通道—红色、绿色和蓝色—并允许我们为每个通道指定 256 个可用值中的任意一个 (16 x 16 &#x3D; 256)。</p>
<p>这些值有点复杂，不太容易理解，但是它们比关键字更通用——你可以使用十六进制值来表示你想在配色方案中使用的任何颜色。</p>
<p><strong>RGB 和 RGBA 的值</strong></p>
<p>我们将在这里讨论的第三种方案是 RGB。RGB 值是一个函数—RGB()—它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似。RGB 的不同之处在于，每个通道不是由两个十六进制数字表示的，而是由一个介于 0 到 255 之间的十进制数字表示的——这有点容易理解。</p>
<p>你还可以使用 RGBA 颜色——它们的工作方式与 RGB 颜色完全相同，因此你可以使用任何 RGB 值，但是有第四个值表示颜色的 alpha 通道，它控制不透明度。如果将这个值设置为<code>0</code>，它将使颜色完全透明，而设置为<code>1</code>将使颜色完全不透明。介于两者之间的值提供了不同级别的透明度。</p>
<p><strong>备注：</strong> 在颜色上设置 alpha 通道与使用我们前面看到的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a>属性有一个关键区别。当你使用不透明度时，你让元素和它里面的所有东西都不透明，而使用 RGBA 颜色只让你指定的颜色不透明。</p>
<h4 id="HSL-和-HSLA-的值"><a href="#HSL-和-HSLA-的值" class="headerlink" title="HSL 和 HSLA 的值"></a>HSL 和 HSLA 的值</h4><p>与 RGB 相比，HSL 颜色模型的支持稍差一些 (在旧版本的 IE 中不支持)，它是在设计师们感兴趣之后实现的。<code>hsl()</code> 函数接受色调、饱和度和亮度值作为参数，而不是红色、绿色和蓝色值，这些值的不同方式组合，可以区分 1670 万种颜色：</p>
<ul>
<li><strong>色调</strong>：颜色的底色。这个值在 0 和 360 之间，表示色轮周围的角度。</li>
<li><strong>饱和度</strong>：颜色有多饱和？它的值为 0 - 100%，其中 0 为无颜色 (它将显示为灰色阴影)，100% 为全色饱和度</li>
<li><strong>亮度</strong>：颜色有多亮？它从 0 - 100% 中获取一个值，其中 0 表示没有光 (它将完全显示为黑色)，100% 表示完全亮 (它将完全显示为白色)</li>
</ul>
<p>就像 RGB 有 RGBA 一样，HSL 也有 HSLA 等效物，它使你能够指定 alpha 通道值。我已经在下面通过将 RGBA 示例更改为使用 HSLA 颜色来演示了这一点。</p>
<p>你可以在项目中使用这些颜色值中的任何一个。对于大多数项目，你可能会选择一个调色板，然后在整个项目中使用这些颜色——以及你所选择的定义这些颜色的方法。你可以混合使用不同的颜色模型，但是为了一致性，通常最好是你的整个项目使用相同的一个！</p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/image"><code>&lt;image&gt;</code></a> 数据类型用于图像为有效值的任何地方。它可以是一个通过 <code>url()</code>函数指向的实际图像文件，也可以是一个渐变。</p>
<p>在下面的例子中，我们演示了一个图像和一个渐变作为 CSS <code>background-image</code>属性的值。</p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position_value"><code>&lt;position&gt;</code></a> 数据类型表示一组 2D 坐标，用于定位一个元素，如背景图像 (通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>)。它可以使用关键字 (如 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, 以及<code>center</code> ) 将元素与 2D 框的特定边界对齐，以及表示框的顶部和左侧边缘偏移量的长度。</p>
<p>一个典型的位置值由两个值组成——第一个值水平地设置位置，第二个值垂直地设置位置。如果只指定一个轴的值，另一个轴将默认为 <code>center</code>。</p>
<p>在下面的示例中，我们使用关键字将背景图像从容器的顶部到右侧放置了 40px。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: right <span class="hljs-number">40px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="字符串和标识符"><a href="#字符串和标识符" class="headerlink" title="字符串和标识符"></a>字符串和标识符</h4><p>在上面的示例中，我们看到关键字被用作值的地方 (例如<code>&lt;color&gt;</code>关键字，如 <code>red</code>, <code>black</code>, <code>rebeccapurple</code>, and <code>goldenrod</code>)。这些关键字被更准确地描述为标识符，一个 CSS 可以理解的特殊值。因此它们没有使用引号括起来——它们不被当作字符串。</p>
<p>在某些地方可以使用 CSS 中的字符串，例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#generating_content_with_before_and_after">在指定生成的内容时</a>。在本例中，引用该值以证明它是一个字符串。在下面的示例中，我们使用非引号括起来的颜色关键字和引号括起来的内容字符串。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>我们将查看的最后一种类型的值是一组称为函数的值。在编程中，函数是一段可重用的代码，可以多次运行，以完成重复的任务，对开发人员和计算机都是如此。函数通常与 JavaScript、Python 或 c++等语言相关联，但它们也以属性值的形式存在于 CSS 中。我们已经在颜色部分看到了函数的作用——<code>rgb()</code>、<code>hsl()</code>等。用于从文件返回图像的值——<code>url()</code>——也是一个函数。</p>
<p>行为更类似于传统编程语言的值是<code>calc()</code>函数。这个函数使你能够在 CSS 中进行简单的计算。如果你希望计算出在为项目编写 CSS 时无法定义的值，并且需要浏览器在运行时为你计算出这些值，那么它特别有用。</p>
<p>例如，下面我们使用<code>calc()</code>使框宽为 20% + 100px。20% 是根据父容器.wrapper 的宽度来计算的，因此如果宽度改变，它也会改变。我们不能事先做这个计算，因为我们不知道父类的 20% 是多少，所以我们使用<code>calc()</code>来告诉浏览器为我们做这个计算。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">20%</span> + <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-7-在css中调整大小"><a href="#2-7-在css中调整大小" class="headerlink" title="2.7 在css中调整大小"></a>2.7 在css中调整大小</h3><p>在前面的课程中你已经看到了几种使用 CSS 为页面中元素设定尺寸的方法。在我们设计网页的时候，需要理解这些不同方法之间的差异。在本课程中，我们将总结设定元素尺寸的方法，并定义几个术语，这些内容将会在未来对你有所帮助。</p>
<h4 id="原始尺寸，或固有尺寸"><a href="#原始尺寸，或固有尺寸" class="headerlink" title="原始尺寸，或固有尺寸"></a>原始尺寸，或固有尺寸</h4><p>一个空的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>是没有尺寸的。如果你在你的 HTML 文件中添加一个空<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>并给予其边框（就像刚才我们为图像做的那样），你会在页面上看到一条线。这是边框被压缩后的效果— 它内部没有内容。在我们下面的例子中，边框宽度扩展到整个容器宽度，因为它是块级元素，而块级元素的行为就是这样的。它没有高度，或者说高度为 0，因为内部没有内容。</p>
<p>在上面的例子中，试着在空元素内部添加些内容。现在边框内包含一些文字了，因为元素的高度由其所含内容高度确定。再强调一次，这就是元素的固有尺寸 — 由其所包含的内容决定。</p>
<h4 id="设置具体的尺寸"><a href="#设置具体的尺寸" class="headerlink" title="设置具体的尺寸"></a>设置具体的尺寸</h4><p>我们当然可以给设计中的元素指定具体大小。当给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为<strong>外部尺寸</strong>。以上面例子中的 <code>&lt;div&gt;</code> 举例 — 我们可以给它一个具体的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 值，然后不论我们放什么内容进去它都是该尺寸。正如我们在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Overflowing_content">上一课</a>有关溢出的内容中所发现的，如果内容的数量超出了元素可容纳的空间，则设置的高度会导致内容溢出。</p>
<p>由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。</p>
<h4 id="使用百分数"><a href="#使用百分数" class="headerlink" title="使用百分数"></a>使用百分数</h4><p>许多时候，百分数是长度单位，正如我们在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units#percentages">Value and units 这节课中讨论的那样</a>，它们常常可与长度互换。当使用百分数时，你需要清楚，它是<strong>什么</strong>东西的百分数。对于一个处于另外一个容器当中的盒子，如果你给予了子盒子一个百分数作为宽度，那么它指的是父容器宽度的百分数。</p>
<p>这是因为百分数是以包含盒子的块为根据解析的。如果我们的<code>&lt;div&gt;</code>没有被指定百分数的值，那么它会占据 100% 的可用空间，因为它是块级别的元素。如果我们给了它一个百分数作为宽度，那么这就是它原来情况下可以占据空间的百分数。</p>
<h4 id="把百分数作为内外边距"><a href="#把百分数作为内外边距" class="headerlink" title="把百分数作为内外边距"></a>把百分数作为内外边距</h4><p>如果你把<code>margins</code>和<code>padding</code>设置为百分数的话，你会注意到一些奇怪的表现。在下面的例子里，我们有一个盒子，我们给了里面的盒子 10% 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>以及 10% 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>。盒子底部和顶部的内外边距，和左右外边距有同样的大小。</p>
<p>或许，你期望元素的上下外边距是其高度的百分比，元素的左右外边距是其宽度的百分比。但情况并非如此！</p>
<p>使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的<strong>内联尺寸</strong>进行计算的，也就是元素的水平宽度。在我们的示例中，所有的外边距或填充都是宽度的 10%。请记住一个事实，当你使用百分比作为元素外边距或填充的单位时，你将得到一个相同尺寸的外边距或填充。</p>
<h4 id="min-和max-尺寸"><a href="#min-和max-尺寸" class="headerlink" title="min-和max-尺寸"></a>min-和max-尺寸</h4><p>除了让万物都有一个确定的大小以外，我们可以让 CSS 给定一个元素的最大或最小尺寸。如果你有一个包含了变化容量的内容的盒子，而且你总是想让它<strong>至少</strong>有个确定的高度，你应该给它设置一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height"><code>min-height</code></a>属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。</p>
<p>在以下的示例中，你可以看到两个盒子，两个都有 150 像素的确定高度，左边的盒子有 150 像素高，右边的盒子有需要更多空间才能装下的内容，所以它变得比 150 像素高。</p>
<p>这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p>
<p>作为示例，如果你设定一个图像的属性为<code>width: 100%</code>，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。</p>
<p>如果你使用了<code>max-width: 100%</code>，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的 100%。</p>
<p>在下面的示例里，我们使用了两次相同的图片。第一次使用，属性值已设为<code>width: 100%</code>，位于比图片大的容器里，因此图片拉伸到了与容器相同的宽度；第二次的属性值则设为<code>max-width: 100%</code>，因此它并没有拉伸到充满容器；第三个盒子再一次包含了相同的图片，同时设定了<code>max-width: 100%</code>属性，这时你能看到它是怎样缩小来和盒子大小相适应的。</p>
<p>这个技术是用来让图片<strong>可响应</strong>的，所以在更小的设备上浏览的时候，它们会合适地缩放。你无论怎样都不应该用这个技术先载入大原始尺寸的图片，再对它们在浏览器中进行缩放。图像应该合适地调整尺寸，以使它们不会比预计中展示时所需要的最大尺寸大。下载过大的图像会造成你的网站变慢，如果用户使用按量收费的网络连接，会让用户花更多钱。</p>
<p><strong>备注：</strong>了解更多关于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图片技术</a>的事情。</p>
<h4 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h4><p>视口，即你在浏览器中看到的部分页面，也是有尺寸的。在 CSS 中，我们有与视口尺寸相关的度量单位，即意为视口宽度的<code>vw</code>单位，以及意为视口高度的 <code>vh</code>单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。</p>
<p><code>1vh</code>等于视口高度的 1%，<code>1vw</code>则为视口宽度的 1%.你可以用这些单位约束盒子的大小，还有文字的大小。在下面的示例里，我们有一个大小被设为 20vh 和 20vw 的盒子。这个盒子里面有一个字母<code>A</code>，其<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>属性被设成了 10vh。</p>
<p><strong>如果你改变了<code>vh</code>和<code>vw</code>的对应值，盒子和字体的大小也会改变；视口大小的变化也会让它们的大小变化，因为它们是依照视口来定大小的。想看到随着你改变视口大小的时候示例的变化的话，你需要在一个新浏览器视窗里面载入此示例，因为你可以控制该视窗的大小，同时上面示例所在的嵌入的<code>&lt;iframe&gt;</code>的大小即是对上面示例而言的视口。<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/sizing/vw-vh.html">打开此示例</a>，调整浏览器视窗的大小，观察在盒子和文本的大小上所发生的事情。</strong></p>
<p>在你的设计中，根据视口改变物件的大小是很有用的。例如，如果你想要在你其他内容之前，有一个充满整个视口的视觉宣传段落，让你的页面的那个部分有 100vh 高的话，会把剩下的内容推到视口的下面，只有向下滚动文档的时候它们才会出现。</p>
<h3 id="2-8-图像、媒体和表单元素"><a href="#2-8-图像、媒体和表单元素" class="headerlink" title="2.8 图像、媒体和表单元素"></a>2.8 图像、媒体和表单元素</h3><p>在这节课里，我们来看一下，CSS 是如何处理某些特殊元素的。图像、其他媒体和表格元素的表现和普通的盒子有些不同，这取决于你使用 CSS 格式化它们的能力。理解什么可能做到，什么不可能做到能够省些力气，本节课将会聚焦于一些你需要知道的主要的事情上。</p>
<h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><p>图像和视频被描述为**<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">替换元素</a>**。这意味着 CSS 不能影响它们的内部布局——而仅影响它们在页面上相对于其它元素的位置。但是，正如我们将看到的，CSS 可以对图像执行多种操作。</p>
<p>某些替换元素（例如图像和视频）也具有<strong>宽高比</strong>。这意味着它在水平（x）和垂直（y）方向上均具有大小，并且默认情况下将使用文件的固有尺寸进行显示。</p>
<h4 id="调整图像大小"><a href="#调整图像大小" class="headerlink" title="调整图像大小"></a>调整图像大小</h4><p>正如你从之前的几节课中所学到的那样，CSS 中万物皆盒。如果你把一张图片放在一个盒子里，而这张图片的原始长和宽比盒子的小或大，那么这张图要么缩在盒子里，要么就从盒子里面溢出。你需要决定如何处理这样的溢出。</p>
<p>下面的示例中有两个盒子，长宽均为 200 像素：</p>
<ul>
<li>一个包含了一张小于 200 像素的图像，它比盒子小，并且不会自动拉伸来充满盒子。</li>
<li>另一张图像大于 200 像素，溢出了盒子。</li>
</ul>
<p>那么该如何处理溢出问题呢？</p>
<p>正如我们在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS">之前的课程</a> 所学的那样，一个常用的方法是将一张图片的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a> 设为 100%。这将会使图片的尺寸小于等于盒子。这个技术也会对其他替换元素（例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"><code>&lt;video&gt;</code></a>，或者 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe"><code>&lt;iframe&gt;</code></a>。</p>
<p>你可以选择对容器内的图像作其它方式的处理。例如，你可能想把一张图像调整到能够完全盖住一个盒子的大小。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit"><code>object-fit</code></a> 属性可以在这里帮助你。当使用 <code>object-fit</code> 时，替换元素可以以多种方式被调整到合乎盒子的大小。</p>
<p>如果我们使用值 <code>contain</code>，图像就会被缩放到足以完整地放到盒子里面的大小。如果它和盒子的比例不同，将会出现“开天窗”的结果。</p>
<p>你可能也想试试 <code>fill</code> 值，它可以让图像充满盒子，但是不会维持比例。</p>
<h4 id="布局中的替换元素"><a href="#布局中的替换元素" class="headerlink" title="布局中的替换元素"></a>布局中的替换元素</h4><p>在对替换元素使用各种 CSS 布局时，你可能会发现他们的表现方式与其他元素有一些细节上的差异。例如，flex 或者 grid 布局中，默认情况下元素会被拉伸到充满整块区域。但是图像不会被拉伸，而会对齐到网格区域或者弹性容器的起始处。</p>
<p>你可以在下面的示例中看到这一现象。该示例有一个两列两行的网格容器，里面有四个物件。所有的 <code>&lt;div&gt;</code> 元素有自己的背景色，被拉伸到充满了行和列。但是，图像并没有被拉伸。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;star.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>  <span class="hljs-attribute">border-radius</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225195135107-20230305%2010:52:41.png" srcset="/blog/img/loading.gif" lazyload alt="image-20230225195135107"></p>
<p>如果你是按序阅读这些课程的，那么你可能还没有看到布局的部分。不过没关系，只要记住替换元素在成为网格或者弹性布局的一部分时，有不同的默认行为就好了。这一默认行为很有必要，因为它避免了替换元素被布局拉伸成奇怪的样子。</p>
<p>为了强制图像拉伸，以充满其所在的网格单元，你必须做类似于下面的事情：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这将会无条件地拉伸图像，所以很可能不会是你想要的。</p>
<h4 id="form-元素"><a href="#form-元素" class="headerlink" title="form 元素"></a>form 元素</h4><p>用 CSS 格式化表单元素是一个需要技巧的工作，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms">HTML 表单指南</a>包含了详细的格式化表单元素的指导，我不会在这里复述。本节需要介绍的是一些值得关注的关键基础内容。</p>
<p>很多表单控件是通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input"><code>&lt;form&gt;</code></a> 元素添加到网页上的。该元素定义了简单的表单区域，例如文字输入。更进一步还有 HTML5 新加入的更加复杂的区域，例如颜色和日期撷取器。另外还有一些其他元素，例如用于多行文本输入的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea"><code>&lt;textarea&gt;</code></a>，以及那些用来包含和标记表单特定部分的元素，例如<code>&lt;fieldset&gt;</code>和 <code>&lt;legend&gt;</code> 。</p>
<p>HTML5 还包含了允许 Web 开发者指定必填区域的特性，甚至还能检验填入内容的类型。如果用户输入了一些不符合要求的内容，或者未填写必填区域，浏览器会显示错误提示。不同的浏览器在给此类元素样式化和自定义方面不尽相同。</p>
<h4 id="样式化文本输入元素"><a href="#样式化文本输入元素" class="headerlink" title="样式化文本输入元素"></a>样式化文本输入元素</h4><p>允许文本输入的元素有很多，例如 <code>&lt;input type=&quot;text&quot;&gt;</code>，及其指定特定类型的元素，如 <code>&lt;input type=&quot;email&quot;&gt;</code> 以及 <code>&lt;textarea&gt;</code> 元素，这些都是相当容易样式化的，它们和页面上其他盒子的表现相同。只不过在不同的操作系统和浏览器上访问时这些元素默认的样式化方式可能不同。</p>
<p>在下面的示例中，我们已经将一些文本输入元素用 CSS 样式化了。可以看到，边框、内外边距之类的东西都如期生效了。现在，我们使用属性选择器来指向不同的输入类型，尝试通过改变边框、添加输入区域背景色、改变字体和内边距的方式来改变表单的外观。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;buttons&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span>,<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;email&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#999</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">2em</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span><span class="hljs-selector-pseudo">:hover</span>, <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>警告：</strong> 你应该谨慎改变表单样式，确保用户仍然能轻松辨认表单元素。原则上，你可以创建一个没有边框和背景的，几乎无法与周围的内容区分开来的输入表单，但这会使辨认和填写变得非常困难。</p>
<h4 id="继承和表单元素"><a href="#继承和表单元素" class="headerlink" title="继承和表单元素"></a>继承和表单元素</h4><p>在一些浏览器中，表单元素默认不会继承字体样式，因此如果你想要确保你的表单填入区域使用 body 中或者一个父元素中定义的字体，你需要向你的 CSS 中加入这条规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">font-family</span> : inherit;<br>  <span class="hljs-attribute">font-size</span> : <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="form-元素与-box-sizing"><a href="#form-元素与-box-sizing" class="headerlink" title="form 元素与 box-sizing"></a>form 元素与 box-sizing</h4><p>跨浏览器的 form 元素对于不同的挂件使用不同的盒子约束规则。你已经在我们的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型课</a>中学习了 <code>box-sizing</code> 属性，在样式化表单时候，你可以使用这一知识，确保在给 form 元素设定宽度和高度时可以有统一的体验。</p>
<p>为了保证统一，最好将所有元素的内外边距都设为 <code>0</code>，然后在单独进行样式化控制的时候将这些加回来。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="其他有用的设置"><a href="#其他有用的设置" class="headerlink" title="其他有用的设置"></a>其他有用的设置</h4><p>除了上面提到的规则以外，你也应该在 <code>&lt;textarea&gt;</code> 上设置 <code>overflow: auto</code> 以避免 IE 在不需要滚动条的时候显示滚动条：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="将一切都放在一起“重置”"><a href="#将一切都放在一起“重置”" class="headerlink" title="将一切都放在一起“重置”"></a>将一切都放在一起“重置”</h4><p>作为最后一步，我们可以将上面讨论过的各式属性包起来，成为以下的“表单重置”，以提供一个统一的在其上继续进行工作的地基，这包含了前三节提到的所有东西：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: inherit;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 通用样式表被许多开发者用作所有项目的一系列基础样式，典型就是那些做了和以上提到相似的事情的那些，在你开始自己的 CSS 作业前，它确保了跨浏览器的任何事情都被默认设定为统一样式。它们不像以往那么重要了，因为浏览器显著地要比以往更加统一。但是，如果你想要看一个例子，可以看看这个<a target="_blank" rel="noopener" href="http://necolas.github.io/normalize.css/">Normalize.css</a>，它被许多项目用作基础，是非常流行的样式表。</p>
<p>至于样式化表单的更加深入的信息，可以看下这些教程的 HTML 一节的这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Styling_web_forms">Styling HTML Forms</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Advanced_form_styling">Advanced Styling for HTML Forms</a></li>
</ul>
<h3 id="2-9-样式化表格"><a href="#2-9-样式化表格" class="headerlink" title="2.9 样式化表格"></a>2.9 样式化表格</h3><p>设计一个 HTML 表格不是世界上最迷人的工作，但有时我们必须这样做。本文提供了一个使 HTML 表格看起来不错的指南，其中一些功能在前面的文章中已作详细介绍。</p>
<h4 id="一个典型的风格化表格"><a href="#一个典型的风格化表格" class="headerlink" title="一个典型的风格化表格"></a>一个典型的风格化表格</h4><ol>
<li>首先，复制<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/punk-bands-unstyled.html">实例标记</a>到本地，下载这两个图像 (<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/noise.png">noise</a>和 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/leopardskin.jpg">leopardskin</a>)，然后将三个结果文件放在本地计算机的某个工作目录中。</li>
<li>接下来，创建一个名为<code>style.css</code>的新文件并将其保存在与其他文件相同的目录中。</li>
<li>将 CSS 链接到 HTML 中，将下面的 HTML 代码放到 HTML 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head">&#96;&#96;</a>中：</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<h4 id="间距和布局"><a href="#间距和布局" class="headerlink" title="间距和布局"></a>间距和布局</h4><p>我们需要做的第一件事是整理出空间&#x2F;布局——默认的表格样式是如此的拥挤！要做到这一点，请将以下 CSS 添加到您的 <code>style.css</code> 文件：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* spacing */</span><br><br><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">table-layout</span>: fixed;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">border-collapse</span>: collapse;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid purple;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">15%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">35%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Copy to Clipboard</p>
<p>需要注意的最重要的部分如下：</p>
<ul>
<li>在你的表上，给table-layout属性设置一个为fixed的值通常是一个好主意，因为它使表的行为在默认情况下更可预测。通常情况下，表列的尺寸会根据所包含的内容大小而变化，这会产生一些奇怪的结果。通过 table-layout: fixed，您可以根据列标题的宽度来规定列的宽度，然后适当地处理它们的内容。这就是为什么我们使用了thead th:nth-child(n) 选择了四个不同的标题 (:nth-child) 选择器（“选择第 n 个子元素，它是一个顺序排列的<code>&lt;th&gt;</code>元素，且其父元素是<code>&lt;thead&gt;</code>元素”）并给定了它们的百分比宽度。整个列宽度与列标题的宽度是一样的，这是一种很好的设定表列尺寸的方式。Chris Coyier 在Fixed Table Layouts中更详细地讨论了这一技术。 我们将它与一个 100% 的width组合在一起，这意味着该表将填充它放入的任何容器，并且能很好的响应（虽然它仍然需要更多的工作来让它在窄屏宽度上看起来很好）。</li>
<li>一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a>属性的<code>collapse</code>值对于任何表样式的工作来说都是一个标准的最佳实践。默认情况下，当您在表元素上设置边框时，它们之间将会有间隔，如下图所示：<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/no-border-collapse.png" srcset="/blog/img/loading.gif" lazyload alt="img">这看起来不太好 (虽然可能是你想要的样子，谁知道呢？)。使用 <code>border-collapse: collapse;</code> ，让边框合为一条，现在看起来好多了：<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/border-collapse.png" srcset="/blog/img/loading.gif" lazyload alt="img"></li>
<li>我们在整个表设置了一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>，这是必要的，因为我们将在表页眉和页脚后面设置一些边框——当你在表格外面没有一个边界而且以空隙结尾的时候，它看起来很奇怪，而且是不连贯的。</li>
<li>我们在<code>&lt;th&gt;</code>和<code>&lt;td&gt;</code>元素上设置了一些padding——这些元素使数据项有了一些空间，使表看起来更加清晰。</li>
</ul>
<p>此刻，我们的表看起来好多了：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-spacing.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="一些简单的排版"><a href="#一些简单的排版" class="headerlink" title="一些简单的排版"></a>一些简单的排版</h4><p>现在我们把类型整理一下。</p>
<p>首先，我们在Google Fonts上找到了一种适合于朋克乐队的字体的字体。如果你愿意，你可以去那里找一个不同的。现在，您只需替换我们提供的<code>&lt;link&gt;</code>元素和定制的font-family声明，并使用 Google 字体提供给您的内容。</p>
<p>首先，将下面的<code>&lt;link&gt;</code>元素添加到您的 HTML 头部，就在您现有的<code>&lt;link&gt;</code>元素之上：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&#x27;https://fonts.googleapis.com/css?family=Rock+Salt&#x27;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&#x27;stylesheet&#x27;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&#x27;text/css&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>现在将下面的 CSS 添加到您的<code>style.css</code>文件，在之前内容后面添加：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* typography */</span><br><br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;helvetica neue&#x27;</span>, helvetica, arial, sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Rock Salt&#x27;</span>, cursive;<br>&#125;<br><br><span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">2px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">1px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里没有什么特别的东西。我们通常会对字体样式进行调整，使其更易于阅读：</p>
<ul>
<li>我们已经设置了一个全局无衬线字体;这纯粹是一种风格上的选择。我们还在和元素的标题上设置了自定义字体，这是一种很不错的、很有朋克风格的外观。</li>
<li>我们在标题和单元格上设置了一些<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a>，因为我们觉得它有助于提高可读性。再次强调，这主要是一种风格上的选择。</li>
<li>我们在中的表格单元中对文本进行了居中对齐，使它们与标题对齐。默认情况下，单元格被赋予了一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a>的<code>left</code>值，并且标题被赋予了一个<code>center</code>值，但是通常情况下，让两者对齐看起来更好。标题字体的默认粗体值足以区分它们的外观。</li>
<li>我们在中对标题进行了右对齐，以便与它的数据点更好地关联。</li>
</ul>
<p>结果看起来更整洁一些：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-typography.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="图形和颜色"><a href="#图形和颜色" class="headerlink" title="图形和颜色"></a>图形和颜色</h4><p>现在轮到图形和颜色了！因为表格上充满“朋克“和“个性”，我们需要给它再搭配一些鲜艳的造型。别担心，你不必让你的表格”燥起来“，你可以选择一些更巧妙、更有品位的东西。</p>
<p>首先将下面的 CSS 添加到<code>style.css</code>文件中，在底部添加：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">thead</span>, <span class="hljs-selector-tag">tfoot</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">leopardskin.jpg</span>);<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> black;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>), <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>));<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid purple;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样，对于表格这里没有什么特别的，但有几件事值得注意。</p>
<p>我们已经将一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>添加到和，并将页眉和页脚的所有文本颜色<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a>更改为白色 (并给它一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a>)，这样它的可读性就更好了。你应该确保你的文字与你的背景形成鲜明的对比，使得它是可读的。</p>
<p>我们还为<code>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/th)和 </code>](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98%EF%BC%8C%E5%9C%A8%E9%A1%B5%E7%9C%89%E5%92%8C%E9%A1%B5%E8%84%9A%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E7%BA%B9%E7%90%86%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B9%9F%E4%B8%BA%E8%BF%99%E4%BA%9B%E5%85%83%E7%B4%A0%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E6%98%8E%E4%BA%AE%E7%9A%84%E7%B4%AB%E8%89%B2%E8%BE%B9%E6%A1%86%E3%80%82%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%B5%8C%E5%A5%97%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%82%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%A0%B7%E5%BC%8F%E5%B1%82%E5%8F%A0%E5%9C%A8%E4%B8%80%E8%B5%B7%E3%80%82%E6%98%AF%E7%9A%84%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BB%84%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E5%B1%9E%E6%80%A7%E5%80%BC%E6%9D%A5%E5%9C%A8%E5%92%8C">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)添加了一个线性渐变，在页眉和页脚中添加了一个漂亮的纹理，同时也为这些元素提供了一个明亮的紫色边框。有多个嵌套的元素是很有用的，这样您就可以将样式层叠在一起。是的，我们可以通过设置多组背景图像属性值来在和</a> 元素上同时使用背景图像和线性渐变，但是我们决定分开使用，因为考虑到不支持多个背景图像或线性渐变的老浏览器。</p>
<h4 id="斑马条纹图案"><a href="#斑马条纹图案" class="headerlink" title="斑马条纹图案"></a>斑马条纹图案</h4><p>我们想用一个单独的部分来展示如何实现斑马条纹（<strong>zebra stripes</strong>）——通过改变不同数据行的颜色，使表中交替行不同的数据行可以更容易地进行解析和读取。将下面的 CSS 添加到您的 <code>style.css</code> 文件底部：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(odd) &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff33cc</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(even) &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e495e4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">noise.png</span>);<br>&#125;<br><br><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff33cc</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>您在前面看到了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a>选择器用于选择特定的子元素。它也可以用一个公式作为参数，来选择一个元素序列。公式<code>2n-1</code>会选择所有奇数的子元素 (1、3、5 等)，而公式<code>2n</code>会选择所有偶数的子元素 (2、4、6 等等)。我们在代码中使用了<code>odd</code>和<code>even</code>的关键字，这与前面提到的公式作用完全相同。在这里，我们给奇数行和偶数行不同的 (醒目的) 颜色。</li>
<li>我们还为所有的行添加了一个重复的噪点背景色块（一个半透明的<code>.png</code>，有一点视觉上的扭曲）来提供一些纹理。</li>
<li>最后，我们给整个表格提供了一个纯的背景颜色，这样浏览器不支持<code>:nth-child</code>选择器仍然有它们的正文行的背景。</li>
</ul>
<p>这种颜色爆炸的结果如下：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-color.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>现在，这可能有点过头不符合你的品味，但我们在这里想要指出的一点是，表格并非只能是枯燥无味的，学术性的。</p>
<h4 id="样式化标题"><a href="#样式化标题" class="headerlink" title="样式化标题"></a>样式化标题</h4><p>对我们的表格还有最后一点处理——样式化标题。要做到这一点，请将以下内容添加到您的<code>style.css</code> 文件底部：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">caption</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Rock Salt&#x27;</span>, cursive;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>  <span class="hljs-attribute">caption-side</span>: bottom;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;<br>  <span class="hljs-attribute">text-align</span>: right;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">1px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里没有什么值得注意的地方，除了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/caption-side"><code>caption-side</code></a>属性，它被赋予了一个<code>bottom</code>的值。这就导致标题被放置在表格的底部，与其他声明一起提供了最后的外观（见预览版<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/styling-boxes/styling-tables/punk-bands-complete.html">punk-bands-complete.html</a>）：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-caption.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="表格样式小贴士"><a href="#表格样式小贴士" class="headerlink" title="表格样式小贴士"></a>表格样式小贴士</h4><p>在继续之前，我们认为我们将为您提供一个快速列表，列出了上面提到的最有用的点：</p>
<ul>
<li>使您的表格标记尽可能简单，并且保持灵活性，例如使用百分比，这样设计就更有响应性。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout"><code>table-layout</code></a><code>: fixed</code> 创建更可控的表布局，可以通过在标题<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>中设置<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>来轻松设置列的宽度。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a><code>: collapse</code> 使表元素边框合并，生成一个更整洁、更易于控制的外观。</li>
<li>使用, 和 将表格分割成逻辑块，并提供额外的应用 CSS 的地方，因此如果需要的话，可以更容易地将样式层叠在一起。</li>
<li>使用斑马线来让其他行更容易阅读。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a>直线对齐您的<code>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/th)和</code>](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)%E6%96%87%E6%9C%AC%EF%BC%8C%E4%BD%BF%E5%86%85%E5%AE%B9%E6%9B%B4%E6%95%B4%E6%B4%81%E3%80%81%E6%9B%B4%E6%98%93%E4%BA%8E%E8%B7%9F%E9%9A%8F%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)文本，使内容更整洁、更易于跟随。</a></li>
</ul>
<h3 id="2-10-网页安全字体"><a href="#2-10-网页安全字体" class="headerlink" title="2.10 网页安全字体"></a>2.10 网页安全字体</h3><p>说到字体可用性，只有某几个字体通常可以应用到所有系统，因此可以毫无顾忌地使用。这些都是所谓的 <strong>网页安全字体</strong>。</p>
<p>大多数时候，作为网页开发者，我们希望对用于显示我们的文本内容的字体有更具体的控制。问题在于，需要一个方法来知道当前正在浏览我们的网站网页的电脑，它有哪些可用字体。我们并不是总能在每种情况下都知道这一点，但是网络安全字体在几乎所有最常用的操作系统（Windows，Mac，最常见的 Linux 发行版，Android 和 iOS 版本）中都可用。</p>
<p>实际的 Web 安全字体列表将随着操作系统的发展而改变，但是可以认为下面的字体是网页安全的，至少对于现在来说 (它们中的许多都非常流行，这要感谢微软在 90 年代末和 21 世纪初期的倡议*<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Core_fonts_for_the_Web">Core fonts for the Web</a>* )：</p>
<table>
<thead>
<tr>
<th align="left">字体名称</th>
<th align="left">泛型</th>
<th align="left">注意</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Arial</td>
<td align="left">sans-serif</td>
<td align="left">通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但 Helvetica 被认为具有更好的形状，即使 Arial 更广泛地可用。</td>
</tr>
<tr>
<td align="left">Courier New</td>
<td align="left">monospace</td>
<td align="left">某些操作系统有一个 Courier New 字体的替代（可能较旧的）版本叫 Courier。使用 Courier New 作为 Courier 的首选替代方案，被认为是最佳做法。</td>
</tr>
<tr>
<td align="left">Georgia</td>
<td align="left">serif</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Times New Roman</td>
<td align="left">serif</td>
<td align="left">某些操作系统有一个 Times New Roman 字体的替代（可能较旧的）版本叫 Times。使用 Times 作为 Times New Roman 的首选替代方案，被认为是最佳做法。</td>
</tr>
<tr>
<td align="left">Trebuchet MS</td>
<td align="left">sans-serif</td>
<td align="left">您应该小心使用这种字体——它在移动操作系统上并不广泛。</td>
</tr>
<tr>
<td align="left">Verdana</td>
<td align="left">sans-serif</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>备注：</strong> 在各种资源中，<a target="_blank" rel="noopener" href="http://www.cssfontstack.com/">cssfontstack.com</a> 网站维护了一个可用在 Windows 和 Mac 操作系统上使用的网页安全字体的列表，这可以帮助决策网站的安全性。</p>
<p><strong>备注：</strong> 有一个可以下载来自一个网页的自定义字体的方法，允许你通过任何你想要的方法来定制你使用的字体：<strong>网页字体</strong>。这个有一点复杂，我们将在这个模块中的另一篇文章中讨论这一点。</p>
<h4 id="默认字体"><a href="#默认字体" class="headerlink" title="默认字体"></a>默认字体</h4><p>CSS 定义了 5 个常用的字体名称：<code>serif</code>, <code>sans-serif</code>, <code>monospace</code>, <code>cursive</code>, 和 <code>fantasy</code>. 这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。这是一种糟糕的情况，浏览器会尽力提供一个看上去合适的字体。 <code>serif</code>, <code>sans-serif</code> 和 <code>monospace</code> 是比较好预测的，默认的情况应该比较合理，另一方面，<code>cursive</code> 和 <code>fantasy</code> 是不太好预测的，我们建议使用它们的时候应该稍微注意一些，多多测试。</p>
<p>五个名称定义如下：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">定义</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>serif</code></td>
<td align="left">衬线字体，即有衬线的字体（衬线是指字体笔画尾端的小装饰，存在于某些印刷体字体中）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>sans-serif</code></td>
<td align="left">无衬线字体。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>monospace</code></td>
<td align="left">等宽字体，指包含的全部字符的宽度相同的字体，通常在编辑代码时使用。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>cursive</code></td>
<td align="left">手写字体，对于英文字符而言通常具有顺滑的连接笔画以模拟手写效果。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>fantasy</code></td>
<td align="left">装饰字体。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="字体栈"><a href="#字体栈" class="headerlink" title="字体栈"></a>字体栈</h4><p>由于你无法保证你想在你的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 你可以提供一个<strong>字体栈</strong> (<strong>font stack</strong>)，这样的话，浏览器就有多种字体可以选择了。只需包含一个 <code>font-family</code> 属性，其值由几个用逗号分离的字体名称组成。比如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Trebuchet MS&quot;</span>, Verdana, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Copy to Clipboard</p>
<p>在这种情况下，浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。</p>
<p>在字体栈的最后提供一个合适的通用的字体名称是个不错的办法，这样的话，即使列出的字体都无法使用，浏览器至少可以提供一个还算合适的选择。为了强调这一点，如果没有其他选项可用，那么段落将被赋予浏览器的默认衬线字体 - 通常是 Time New Roman - 这对于 sans-serif 字体是不利的！</p>
<p><strong>备注：</strong> 有一些字体名称不止一个单词，比如<code>Trebuchet MS</code> ，那么就需要用引号包裹。</p>
<h4 id="一个使用-font-family-的例子"><a href="#一个使用-font-family-的例子" class="headerlink" title="一个使用 font-family 的例子"></a>一个使用 font-family 的例子</h4><p>让我们把它添加到之前的例子上，给段落一个 sans-serif 的字体。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这给我们以下结果：</p>
<iframe class="sample-code-frame" title="一个使用 font-family 的例子 sample" id="frame_一个使用_font-family_的例子" width="100%" height="220" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8_font-family_%E7%9A%84%E4%BE%8B%E5%AD%90.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>在我们之前的模块中的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units">CSS values and units</a> 文章，我们回顾了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>. 字体大小 (通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 属性设置) 可以取大多数这些单位的值 (以及其他，比如百分比 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#percentages">percentages</a>)，然而你在调整字体大小时，最常用的单位是：</p>
<ul>
<li>px (像素): 将像素的值赋予给你的文本。这是一个绝对单位，它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。</li>
<li>em: 1em 等于我们设计的当前元素的父元素上设置的字体大小 (更加具体的话，比如包含在父元素中的大写字母 M 的宽度) 如果你有大量设置了不同字体大小的嵌套元素，这可能会变得棘手，但它是可行的，如下图所示。为什么要使用这个麻烦的单位呢？当你习惯这样做时，那么就会变得很自然，你可以使用em调整任何东西的大小，不只是文本。你可以有一个单位全部都使用 em 的网站，这样维护起来会很简单。</li>
<li>rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小， (i.e. <html>) ，而不是父元素。这可以让你更容易计算字体大小，但是遗憾的是， rem 不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用em 或 px, 或者是 polyfill 就像 REM-unit-polyfill. （这个单位在“CSS 的值和单位”一节也有讲解）</li>
</ul>
<p>元素的 font-size 属性是从该元素的父元素继承的。所以这一切都是从整个文档的根元素——<html>开始，浏览器的 font-size 标准设置的值为 16px。在根元素中的任何段落 (或者那些浏览器没有设置默认大小的元素)，会有一个最终的大小值：16px。其他元素也许有默认的大小，比如 <h1> (en-US) 元素有一个 2em 的默认值，所以它的最终大小值为 32px。当你开始更改嵌套元素的字体大小时，事情会变得棘手。比如，如果你有一个 <article> 元素在你的页面上，然后设置它的 font-size 为 1.5em (通过计算，可以得到大小为 24px)，然后想让 <article> 元素中的段落获得一个计算值为 20px 的大小，那么你应该使用多少 em。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- document base font-size is 16px --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span> <span class="hljs-comment">&lt;!-- If my font-size is 1.5em --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>My paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- How do I compute to 20px font-size? --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>你需要将 em 的值设置为 20&#x2F;24, 或者 <code>0.83333333em</code>. 这个计算可能比较复杂，所以当你设置的时候，你需要仔细一些。如果可以使用 rem 的话，那实现起来就变得简单不少，避免在可能的情况下设置容器元素的字体大小。</p>
<h4 id="一个简单的-size-示例"><a href="#一个简单的-size-示例" class="headerlink" title="一个简单的 size 示例"></a>一个简单的 size 示例</h4><p>当调整你的文本大小时，将文档 (document) 的基础 <code>font-size</code> 设置为 10px 往往是个不错的主意，这样之后的计算会变得简单，所需要的 (r)em 值就是想得到的像素的值除以 10，而不是 16。做完这个之后，你可以简单地调整在你的 HTML 中你想调整的不同类型文本的字体大小。在样式表的指定区域列出所有<code>font-size</code>的规则集是一个好主意，这样它们就可以很容易被找到。</p>
<p>我们的新结果是这样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.6rem</span>;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="一个简单的 size 示例 sample" id="frame_一个简单的_size_示例" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84_size_%E7%A4%BA%E4%BE%8B.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="字体样式、字体粗细、文本转换和文本装饰"><a href="#字体样式、字体粗细、文本转换和文本装饰" class="headerlink" title="字体样式、字体粗细、文本转换和文本装饰"></a>字体样式、字体粗细、文本转换和文本装饰</h4><p>CSS 提供了 4 种常用的属性来改变文本的样子：</p>
<ul>
<li><code>font-style</code>: 用来打开和关闭文本 italic (斜体)。可能的值如下 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态)：<ul>
<li><code>normal</code>: 将文本设置为普通字体 (将存在的斜体关闭)</li>
<li><code>italic</code>: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。</li>
<li><code>oblique</code>: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。</li>
</ul>
</li>
<li><code>font-weight</code>: 设置文字的粗体大小。这里有很多值可选 (比如-light, -normal,  -bold, -extrabold, -black, 等等), 不过事实上你很少会用到normal和bold以外的值：<ul>
<li><code>normal</code>, <code>bold</code>: 普通或者<strong>加粗</strong>的字体粗细</li>
<li><code>lighter</code>, <code>bolder</code>: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。<code>100</code>–<code>900</code>: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。</li>
</ul>
</li>
<li><code>text-transform</code>: 允许你设置要转换的字体。值包括：<ul>
<li><code>none</code>: 防止任何转型。</li>
<li><code>uppercase</code>: 将所有文本转为大写。</li>
<li><code>lowercase</code>: 将所有文本转为小写。</li>
<li><code>capitalize</code>: 转换所有单词让其首字母大写。</li>
<li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。</li>
</ul>
</li>
<li><code>text-decoration</code>: 设置&#x2F;取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为：<ul>
<li><code>none</code>: 取消已经存在的任何文本装饰。</li>
<li><code>underline</code>: 文本下划线。</li>
<li><code>overline</code>: 文本上划线</li>
<li><code>line-through</code>: 穿过文本的线。</li>
</ul>
</li>
</ul>
<p>你应该注意到<code>text-decoration</code>可以一次接受多个值，如果你想要同时添加多个装饰值，比如text-decoration: underline overline。同时注意<code>text-decoration</code>是一个缩写形式，它由<code>text-decoration-line</code>,<code>text-decoration-style</code>和<code>text-decoration-color</code>构成。你可以使用这些属性值的组合来创建有趣的效果，比如text-decoration: line-through red wavy.我们来看一下这几个属性添加到我们的例子中：</p>
<p>我们的新结果是这样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.6rem</span>;<br>  <span class="hljs-attribute">text-transform</span>: capitalize;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="字体样式、字体粗细、文本转换和文本装饰 sample" id="frame_字体样式、字体粗细、文本转换和文本装饰" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%E3%80%81%E5%AD%97%E4%BD%93%E7%B2%97%E7%BB%86%E3%80%81%E6%96%87%E6%9C%AC%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%87%E6%9C%AC%E8%A3%85%E9%A5%B0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h4><p>你可以为你的文本应用阴影，使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a> 属性。这最多需要 4 个值，如下例所示：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">text</span>-shadow: <span class="hljs-number">4</span>px <span class="hljs-number">4</span>px <span class="hljs-number">5</span>px red;<br></code></pre></td></tr></table></figure>

<p>4 个属性如下：</p>
<ol>
<li>阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>, 但是 px 是比较合适的。这个值必须指定。</li>
<li>阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上&#x2F;向下移动阴影，而不是左&#x2F;右。这个值必须指定。</li>
<li>模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为 0，这意味着没有模糊。可以使用大多数的 CSS 单位 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</li>
<li>阴影的基础颜色，可以使用大多数的 CSS 颜色单位 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#colors">CSS color unit</a>. 如果没有指定，默认为 <code>black</code>.</li>
</ol>
<p><strong>备注：</strong> 正偏移值可以向右移动阴影，但也可以使用负偏移值来左右移动阴影，例如 <code>-1px -1px</code>.</p>
<h4 id="多种阴影"><a href="#多种阴影" class="headerlink" title="多种阴影"></a>多种阴影</h4><p>您可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本，例如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">text</span>-shadow: -<span class="hljs-number">1</span>px -<span class="hljs-number">1</span>px <span class="hljs-number">1</span>px #aaa,<br>             <span class="hljs-attribute">0px</span> <span class="hljs-number">4</span>px <span class="hljs-number">1</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">5</span>),<br>             <span class="hljs-attribute">4px</span> <span class="hljs-number">4</span>px <span class="hljs-number">5</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">7</span>),<br>             <span class="hljs-attribute">0px</span> <span class="hljs-number">0</span>px <span class="hljs-number">7</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>如果我们把这个样式应用到我们 “Tommy the cat” 示例中的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements"><code>&lt;h1&gt;</code> (en-US)</a> 元素，就像这样：</p>
<iframe class="sample-code-frame" title="多种阴影 sample" id="frame_多种阴影" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%A4%9A%E7%A7%8D%E9%98%B4%E5%BD%B1.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> 你可以看到更多有趣的关于 <code>text-shadow</code> 使用的示例在 <a target="_blank" rel="noopener" href="https://www.sitepoint.com/moonlighting-css-text-shadow/">Moonlighting with CSS text-shadow</a>.</p>
<h4 id="文本布局"><a href="#文本布局" class="headerlink" title="文本布局"></a>文本布局</h4><p>有了基本的字体属性，我们来看看我们可以用来影响文本布局的属性。</p>
<h4 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a> 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同：</p>
<ul>
<li><code>left</code>: 左对齐文本。</li>
<li><code>right</code>: 右对齐文本。</li>
<li><code>center</code>: 居中文字</li>
<li><code>justify</code>: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>，打破一些更长的词语。</li>
</ul>
<p>如果我们应用 <code>text-align: center;</code> 到我们例子中的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements"><code>&lt;h1&gt;</code> (en-US)</a> 元素中，结果如下：</p>
<iframe class="sample-code-frame" title="文本对齐 sample" id="frame_文本对齐" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性设置文本每行之间的高，可以接受大多数单位 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 来获得 <code>line-height</code>。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的 1.5 倍，你可以使用这个：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">line</span>-height: <span class="hljs-number">1</span>.<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>把这个样式应用到我们示例中的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p"><code>&lt;p&gt;</code></a> 元素，结果如下：</p>
<iframe class="sample-code-frame" title="行高 sample" id="frame_行高" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E8%A1%8C%E9%AB%98.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="字母和单词间距"><a href="#字母和单词间距" class="headerlink" title="字母和单词间距"></a>字母和单词间距</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-spacing"><code>word-spacing</code></a> 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。你不会经常使用它们，但是可能可以通过它们，来获得一个特定的外观，或者让较为密集的文字更加可读。它们可以接受大多数单位 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</p>
<p>所以作为例子，如果我们把这个样式应用到我们的示例中的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p"><code>&lt;p&gt;</code></a> 段落的第一行：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们会得到下面的结果：</p>
<iframe class="sample-code-frame" title="字母和单词间距 sample" id="frame_字母和单词间距" width="100%" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%AD%97%E6%AF%8D%E5%92%8C%E5%8D%95%E8%AF%8D%E9%97%B4%E8%B7%9D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="其他一些值得看一下的属性"><a href="#其他一些值得看一下的属性" class="headerlink" title="其他一些值得看一下的属性"></a>其他一些值得看一下的属性</h4><p>以上属性让你了解如何开始在网页上设置文本，但是你可以使用更多的属性。我们只是想介绍最重要的。一旦你习惯使用上面的内容，你还应该探索以下几点：</p>
<p>Font 样式：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>: 在小型大写字母和普通文本选项之间切换。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-kerning"><code>font-kerning</code></a>: 开启或关闭字体间距选项。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-feature-settings"><code>font-feature-settings</code></a>: 开启或关闭不同的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenType">OpenType</a> 字体特性。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-alternates"><code>font-variant-alternates</code></a>: 控制给定的自定义字体的替代字形的使用。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-caps"><code>font-variant-caps</code></a>: 控制大写字母替代字形的使用。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-east-asian"><code>font-variant-east-asian</code> (en-US)</a>: 控制东亚文字替代字形的使用，像日语和汉语。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-ligatures"><code>font-variant-ligatures</code></a>: 控制文本中使用的连写和上下文形式。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-numeric"><code>font-variant-numeric</code></a>: 控制数字，分式和序标的替代字形的使用。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-position"><code>font-variant-position</code></a>: 控制位于上标或下标处，字号更小的替代字形的使用。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size-adjust"><code>font-size-adjust</code></a>: 独立于字体的实际大小尺寸，调整其可视大小尺寸。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>: 在给定字体的可选拉伸版本中切换。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-underline-position"><code>text-underline-position</code></a>: 指定下划线的排版位置，通过使用 <code>text-decoration-line</code> 属性的<code>underline</code> 值。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-rendering"><code>text-rendering</code></a>: 尝试执行一些文本渲染优化。</li>
</ul>
<p>文本布局样式：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-indent"><code>text-indent</code></a>: 指定文本内容的第一行前面应该留出多少的水平空间。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-overflow"><code>text-overflow</code></a>: 定义如何向用户表示存在被隐藏的溢出内容。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a>: 定义如何处理元素内部的空白和换行。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>: 指定是否能在单词内部换行。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>: 定义文本的方向 (这取决于语言，并且通常最好让 HTML 来处理这部分，因为它是和文本内容相关联的。)</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>: 为支持的语言开启或关闭连字符。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-break"><code>line-break</code></a>: 对东亚语言采用更强或更弱的换行规则。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align-last"><code>text-align-last</code></a>: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-orientation"><code>text-orientation</code></a>: 定义行内文本的方向。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap"><code>word-wrap</code></a>: 指定浏览器是否可以在单词内换行以避免超出范围。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</li>
</ul>
<h4 id="Font-简写"><a href="#Font-简写" class="headerlink" title="Font 简写"></a>Font 简写</h4><p>许多字体的属性也可以通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a> 的简写方式来设置 . 这些是按照以下顺序来写的： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style"><code>font-style</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a>, and <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a>.</p>
<p>如果你想要使用 <code>font</code> 的简写形式，在所有这些属性中，只有 <code>font-size</code> 和 <code>font-family</code> 是一定要指定的。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性之间必须放一个正斜杠。</p>
<p>一个完整的例子如下所示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font</span>: italic normal bold normal <span class="hljs-number">3em</span>/<span class="hljs-number">1.5</span> Helvetica, Arial, sans-serif;<br></code></pre></td></tr></table></figure>

<h3 id="2-11-样式化列表"><a href="#2-11-样式化列表" class="headerlink" title="2.11 样式化列表"></a>2.11 样式化列表</h3><h4 id="列表特定样式"><a href="#列表特定样式" class="headerlink" title="列表特定样式"></a>列表特定样式</h4><p>现在我们来看一下列表的一般间距，我们来研究一些列表具有的特定属性。我们从三个属性开始了解，这三个属性可以在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul">&#96;&#96;</a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol">&#96;&#96;</a> 元素上设置：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。</li>
</ul>
<h4 id="符号样式"><a href="#符号样式" class="headerlink" title="符号样式"></a>符号样式</h4><p>像上面所提及的， <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 属性允许你设置项目符号点的类型，在我们的例子中，我们在有序列表上设置了大写罗马数字：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ol</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">upper-roman</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>效果显示如下：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_lists/outer-bullets.png" srcset="/blog/img/loading.gif" lazyload alt="an ordered list with the bullet points set to appear outside the list item text."></p>
<p>您可以通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 参考页面查找到更多选项。</p>
<h4 id="项目符号位置"><a href="#项目符号位置" class="headerlink" title="项目符号位置"></a>项目符号位置</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> 设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。如上所示，默认值为 outside，这使项目符号位于列表项之外。</p>
<p>如果值设置为 inside，项目条目则位于行内。</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ol</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">upper-roman</span>;<br>  <span class="hljs-built_in">list-style-position:</span> <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_lists/inner-bullets.png" srcset="/blog/img/loading.gif" lazyload alt="an ordered list with the bullet points set to appear inside the list item text."></p>
<h4 id="使用自定义的项目符号图片"><a href="#使用自定义的项目符号图片" class="headerlink" title="使用自定义的项目符号图片"></a>使用自定义的项目符号图片</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> 属性允许对于项目符号使用自定义图片。其语法相当简单：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">star</span>.<span class="hljs-string">svg</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而，这个属性在控制项目符号的位置，大小等方面是有限的。您最好使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 系列属性，您将在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks">Styling boxes</a> 模块中了解更多信息。在这里我们仅做一点尝试！</p>
<p>结束我们的例子，我们样式化无序列表像这样（放到您之前所见的顶部）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">list-style-type</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.svg</span>);<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">1.6rem</span> <span class="hljs-number">1.6rem</span>;<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们的所做如下：</p>
<ul>
<li>将<code>&lt;ul&gt;</code> 的 padding-left 从默认的 40px设置为 20px，然后在列表项上设置相同的数值。这就是说，整个列表项仍然排列在列表中，但是列表项产生了一些用于背景图像的填充。如果我们没有设置填充，背景图像将与列表项文本重叠，这看起来会很乱。</li>
<li>将 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 设置为 none，以便默认情况下不会显示项目符号。我们将使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性来代替项目符号。</li>
<li>为每个无序列表项插入项目符号，其相应的属性如下：<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>: 充当项目符号的图片文件的参考路径</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>: 这定义了所选元素背景中的图像将出现在哪里 - 在我们的示例中设置 <code>0 0</code>，这意味着项目符号将出现在每个列表项的最左上侧。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>: 设置背景图片的大小。理想条件下，我们想要项目符号与列表项的大小相同（比列表项稍大或稍小亦可）。我们使用的尺寸为 1.6rem（16px），它非常吻合我们为项目符号设置的 20px 的填充，16px 加上 4px 的空格间距，可以使项目符号和列表项文本效果更好。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a>：默认条件下，背景图片不断复制直到填满整个背景空间，在我们的例子中，背景图片只需复制一次，所以我们设置值为 <code>no-repeat</code>。</li>
</ul>
</li>
</ul>
<p>效果显示如下：</p>
<p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/image-bullets.png" srcset="/blog/img/loading.gif" lazyload alt="an unordered list with the bullet points set as little star images"></p>
<h4 id="list-style-速记"><a href="#list-style-速记" class="headerlink" title="list-style 速记"></a>list-style 速记</h4><p>上述提到的三种属性可以用一个单独的速记属性 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style"><code>list-style</code></a> 来设置。例如：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span>;<br>  <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">example</span>.<span class="hljs-string">png</span>);<br>  <span class="hljs-built_in">list-style-position:</span> <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以被如下方式代替：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style:</span> <span class="hljs-string">square</span> <span class="hljs-string">url</span>(<span class="hljs-string">example</span>.<span class="hljs-string">png</span>) <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>属性值可以任意顺序排列，你可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside），如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。</p>
<h4 id="管理列表计数"><a href="#管理列表计数" class="headerlink" title="管理列表计数"></a>管理列表计数</h4><p>有时，您可能想在有序列表上进行不同的计数方式。例如：从 1 以外的数字开始，或向后倒数，或者按步或多于 1 计数。HTML 和 CSS 有一些工具可以帮助您</p>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-start"><code>start</code></a> 属性允许你从 1 以外的数字开始计数。示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<iframe class="sample-code-frame" title="start sample" id="frame_start" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.start.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-reversed"><code>reversed</code></a> 属性将启动列表倒计数。示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">reversed</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<iframe class="sample-code-frame" title="reversed sample" id="frame_reversed" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.reversed.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-value"><code>value</code></a> 属性允许设置列表项指定数值，示例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<iframe class="sample-code-frame" title="value sample" id="frame_value" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.value.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> 纵然你使用非数字的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a>, 你仍需要使用与数值同等意义的值作为 value 的属性。</p>
<h3 id="2-12-样式化链接"><a href="#2-12-样式化链接" class="headerlink" title="2.12 样式化链接"></a>2.12 样式化链接</h3><p>当为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks">links</a> 添加样式时，理解利用伪类有效地建立链接状态是很重要的，以及如何为链接添加样式来实现常用的功能，比如说导航栏、选项卡。我们将在本文中关注所有这些主题。</p>
<h4 id="让我们来看一些链接"><a href="#让我们来看一些链接" class="headerlink" title="让我们来看一些链接"></a>让我们来看一些链接</h4><p>根据最佳实践 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks">创建超链接</a> 中的练习，我们看到了如何在你的 HTML 中实现链接。在本篇文章中，我们会以这个知识为基础，向你展示将样式应用到链接的最佳实践。</p>
<h4 id="链接状态"><a href="#链接状态" class="headerlink" title="链接状态"></a>链接状态</h4><p>第一件需要理解的事情是链接状态的概念，链接存在时处于不同的状态，每一个状态都可以用对应的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors#pseudo-classes">伪类</a> 来应用样式：</p>
<ul>
<li><strong>Link (没有访问过的)</strong>: 这是链接的默认状态，当它没有处在其他状态的时候，它可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a> 伪类来应用样式。</li>
<li><strong>Visited</strong>: 这个链接已经被访问过了 (存在于浏览器的历史纪录), 它可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a> 伪类来应用样式。</li>
<li><strong>Hover</strong>: 当用户的鼠标光标刚好停留在这个链接，它可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a> 伪类来应用样式。</li>
<li><strong>Focus</strong>: 一个链接当它被选中的时候 (比如通过键盘的 Tab 移动到这个链接的时候，或者使用编程的方法来选中这个链接 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus"><code>HTMLElement.focus()</code> (en-US)</a>) 它可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a> 伪类来应用样式。</li>
<li><strong>Active</strong>: 一个链接当它被激活的时候 (比如被点击的时候)，它可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a> 伪类来应用样式。</li>
</ul>
<h4 id="默认的样式"><a href="#默认的样式" class="headerlink" title="默认的样式"></a>默认的样式</h4><p>下面的例子说明了一个链接的默认行为表现 (这里的 CSS 仅仅是为了放大和居中文本，使内容更加突出)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://mozilla.org&quot;</span>&gt;</span>A link to the Mozilla homepage<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="默认的样式 sample" id="frame_默认的样式" width="100%" height="120" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>当你观察默认样式的时候，你也许会注意到一些东西：</p>
<ul>
<li>链接具有下划线。</li>
<li>未访问过的 (Unvisited) 的链接是蓝色的。</li>
<li>访问过的 (Visited) 的链接是紫色的。</li>
<li>悬停 (Hover) 在一个链接的时候鼠标的光标会变成一个小手的图标。</li>
<li>选中 (Focus) 链接的时候，链接周围会有一个轮廓，你应该可以按 tab 来选中这个页面的链接 (在 Mac 上，你可能需要使用<em>Full Keyboard Access: All controls</em> 选项，然后再按下 Ctrl + F7 ，这样就可以起作用)</li>
<li>激活 (Active) 链接的时候会变成红色 (当你点击链接时，请尝试按住鼠标按钮。)</li>
</ul>
<p>有趣的是，这些默认的样式与 20 世纪 90 年代中期浏览器早期的风格几乎相同。这是因为用户知道以及期待链接就是这样变化的，如果链接的样式不同，就会让一些人感到奇怪。不过这不意味着你不应该为链接添加任何样式，只是你的样式不应该与用户预期的相差太大，你应该至少：</p>
<ul>
<li>为链接使用下划线，但是不要在其他内容上也用下划线，以作区分。如果你不想要带有下划线的链接，那你至少要用其他方法来高亮突出链接。</li>
<li>当用户悬停或选择 (hover 或者 focused) 的时候，使链接有相应的变化，并且在链接被激活 (active) 的时候，变化会有一些不同。可以使用以下 CSS 属性关闭&#x2F;更改默认样式：</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a> 文字的颜色</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor"><code>cursor</code></a> 鼠标光标的样式，你不应该把这个关掉，除非你有非常好的理由。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline"><code>outline</code></a> 文字的轮廓 (轮廓有点像边框，唯一的区别是边框占用了盒模型的空间，而轮廓没有；它只是设置在背景图片的顶部)。outline 是一个有用的辅助功能，所以在把它关掉之前考虑清楚；你至少应该将悬停 (hover) 状态的样式同时应用到选中 (focus) 状态上。</li>
</ul>
<p><strong>备注：</strong> 你不仅仅只限于上述属性来把样式应用到你的链接上，你可以用任何你喜欢的属性，就是不要搞得太疯狂！</p>
<h4 id="将样式应用到一些链接"><a href="#将样式应用到一些链接" class="headerlink" title="将样式应用到一些链接"></a>将样式应用到一些链接</h4><p>现在我们已经详细地看了默认的状态，让我们看一下典型的链接样式的设置。</p>
<p>开始之前，我们先写出我们的空规则集：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span> &#123;<br><br>&#125;<br><br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这几个规则的顺序是有意义的，因为链接的样式是建立在另一个样式之上的，比如，第一个规则的样式也会在后面的规则中生效，一个链接被激活 (activated) 的时候，它也是处于悬停 (hover) 状态的。如果你搞错了顺序，那么就可能不会产生正确的效果。要记住这个顺序，你可以尝试这样帮助记忆：<strong>L</strong>o<strong>V</strong>e <strong>F</strong>ears <strong>HA</strong>te.</p>
<p>现在让我们再添加一些信息，得到正确的样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#265301</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#437A16</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#BAE498</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#265301</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里还提供了一些示例 HTML，供你应用 CSS：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>There are several browsers available, such as <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.mozilla.org/zh-CN/firefox/&quot;</span>&gt;</span>Mozilla<br>Firefox<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google.com/chrome/index.html&quot;</span>&gt;</span>Google Chrome<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, and<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.microsoft.com/zh-CN/windows/microsoft-edge&quot;</span>&gt;</span>Microsoft Edge<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>把这两个放在一起，我们得到这样的结果：</p>
<iframe class="sample-code-frame" title="将样式应用到一些链接 sample" id="frame_将样式应用到一些链接" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%B0%86%E6%A0%B7%E5%BC%8F%E5%BA%94%E7%94%A8%E5%88%B0%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>那么我们在这里做了什么？这个看起来肯定和默认的样式不同，但仍然提供了一个熟悉的体验，好让用户知道发生了什么：</p>
<ul>
<li>第一和第二条规则和本次讨论关系不大。</li>
<li>第三个规则使用了 <code>a</code> 选择器，取消了默认的文本下划线和链接被选中（focus）时的轮廓（outline）（不同浏览器的默认行为可能不同），并为每个链接添加了少量的内边距（padding），所有这一切将在之后变得明确。</li>
<li>接着，我们使用<code>a:link</code>和<code>a:visited</code>选择器来设置未访问（unvisited）链接和访问过（visited）的链接的一点颜色上的变化，然后就能分辨开来了。</li>
<li>下面两条规则使用<code>a:focus</code>和<code>a:hover</code>来设置选中（focus）和悬停（hover）的链接为不同的背景颜色，再加上一个下划线，使链接更加突出。这里有两点需要注意：<ul>
<li>下划线是使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a> 创造的，而不是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a>，有一些人喜欢这样，因为前者比后者有更好的样式选项，并且绘制的位置会稍微低一点，所以不会穿过字母 (比如 字母 g 和 y 底部).</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>的值被设置为<code>1px solid</code>，没有指定颜色。这样做可以使边框采用和元素文本一样的颜色，这在这样的情况下是很有用的，因为链接的每种状态下，文本是不同的颜色。</li>
</ul>
</li>
<li>最后，<code>a:active</code> 用来给链接一个不同的配色方案，当链接被激活 (activated) 时，让链接被激活的时候更加明显。</li>
</ul>
<h4 id="动手练习：为你的链接添加样式"><a href="#动手练习：为你的链接添加样式" class="headerlink" title="动手练习：为你的链接添加样式"></a>动手练习：为你的链接添加样式</h4><p>在这个动手练习部分，我们希望你使用我们的空规则集，然后添加你自定义的规则，从而使链接看上去比较酷。发挥你的想象力，大胆地做吧。我们相信你可以想出一些更酷的东西，就像我们上面的例子一样。</p>
<p>如果你犯了错误，你都可以使用 <em>Reset 按钮来重置。</em> 如果你遇到了困难，可以按 <em>Show solution</em> 按钮来显示我们上文中的例子。</p>
<iframe class="sample-code-frame" title="动手练习：为你的链接添加样式 sample" id="frame_动手练习：为你的链接添加样式" width="700" height="800" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%8A%A8%E6%89%8B%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="在链接中包含图标"><a href="#在链接中包含图标" class="headerlink" title="在链接中包含图标"></a>在链接中包含图标</h4><p>常见的做法是在链接中包含图标，使链接提供更多关于链接指向的内容的信息。让我们来看一个简单的例子，例子中为一个外部链接 (链接指向的不是本站，而是外部站点)。这样的图标通常看起来像一个指向盒子的小箭头，比如，我们会使用<a target="_blank" rel="noopener" href="https://icons8.com/web-app/741/external-link">icons8.com 上的这个优秀的范例</a>。</p>
<p>让我们来看一些能给我们这个效果的 HTML 和 CSS。先是一些简单的等待你样式化的 HTML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>For more information on the weather, visit our <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;weather.html&quot;</span>&gt;</span>weather page<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>,<br>look at <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://en.wikipedia.org/wiki/Weather&quot;</span>&gt;</span>weather on Wikipedia<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, or check<br>out <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.extremescience.com/weather.htm&quot;</span>&gt;</span>weather on Extreme Science<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>接着是 CSS:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: purple;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;http&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;external-link-52.png&#x27;</span>) no-repeat <span class="hljs-number">100%</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">16px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">19px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="在链接中包含图标 sample" id="frame_在链接中包含图标" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%9C%A8%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8C%85%E5%90%AB%E5%9B%BE%E6%A0%87.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>那么这里发生了什么？我们将跳过大部分的 CSS，因为那些只是你之前看过的相同的信息。最后一条规则很有趣，这里，我们在外部链接上插入了一个自定义背景图片，这和上篇<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists#using_a_custom_bullet_image">自定义列表项目符号</a>文章的做法很像。这次，我们使用了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 简写，而不是分别使用多个属性。我们设置了我们想要插入的图片的路径，指定了 <code>no-repeat</code> ，这样我们只插入了一次图片，然后指定位置为 100%，使其出现在内容的右边，距离上方是 0px。</p>
<p>我们也使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a> 来指定要显示的背景图像的大小，为了满足响应式网站设计的需要，在图标更大，需要再重新调整它的大小的时候，这样做是很有帮助的。但是，这仅适用于 IE 9 及更高版本。所以你如果需要支持那些老的浏览器，只能调整图像的原始大小，然后插入。</p>
<p>最后，我们在链接上设置 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a> ，为背景图片留出空间，这样就不会让它和文本重叠了。</p>
<p>最后的问题，我们是如何只选中了外部链接的？如果你正确编写你的HTML 链接 ，你应该只会在外部链接上使用绝对 URL，如果链接是链接你的站点的其他部分，那么使用相对链接是更加高效的。因此“http”文本应该只出现在外部链接上，为此我们可以使用一个属性选择器——a[href*&#x3D;”http”] ——选中<code>&lt;a&gt;</code>元素，但是这样只会选中那些拥有 href 属性，且属性的值包含 “http” 的<code>&lt;a&gt;</code>的元素。</p>
<p>就这样啦，尝试重新审视上面的动手练习部分，尝试这种新技术！</p>
<p><strong>备注：</strong> 不要担心，如果你目前不熟悉 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks">backgrounds</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks">responsive web design (en-US)</a> ; 这些会在其他地方解释。</p>
<h4 id="样式化链接为按钮"><a href="#样式化链接为按钮" class="headerlink" title="样式化链接为按钮"></a>样式化链接为按钮</h4><p>目前在本文中探索的用法也可以用在其他方面。比如，悬停 (hover) 的状态可以为不同的元素应用样式，不只是链接，你也许会想添加悬停状态的样式到段落、列表项、或者是其他东西。</p>
<p>此外，在某些情况下，链接通常会应用样式，使它看上去的效果和按钮差不多，一个网站导航菜单通常是标记为一个列表，列表中包含链接，这可以很容易地被设计为看起来像一组控制按钮或是选项卡，主要是用于让用户可以访问站点的其他部分，现在让我们来看一看。</p>
<p>首先，一些 HTML:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Pizza<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Music<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Wombats<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Finland<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>接着，是我们的 CSS:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">19.5%</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0.625%</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">color</span>: black;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: red;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这给我们以下结果：</p>
<iframe class="sample-code-frame" title="样式化链接为按钮 sample" id="frame_样式化链接为按钮" width="100%" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E6%A0%B7%E5%BC%8F%E5%8C%96%E9%93%BE%E6%8E%A5%E4%B8%BA%E6%8C%89%E9%92%AE.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>让我们来解释一下这里发生了什么，主要是几个有趣的部分：</p>
<ul>
<li>我们的第二条规则删除了 <ul> 元素的默认的 padding，然后设置了它的宽度是外部容器 <body> (在这次条件下) 的 100% 。</li>
<li><li> 元素通常默认是块元素 (可见 types of CSS boxes 回顾)，意味着它们各自会占用一行。在这个例子中，我们创建了一组水平列表的链接，所以在第三条规则中，我们设置了 display 属性为 inline，这会导致列表中的每项内容都会一起出现在同一行，它们现在表现得就像内联元素。</li>
<li>第四条规则，主要是 <a> 元素的样式，这里比较复杂; 让我们一步一步来看：<ul>
<li>和前面的例子一样，我们首先关掉了 text-decoration 和 outline，我们不希望这些破坏我们链接的样子。<br>接着，我们设置 display 为 inline-block ，<a> 元素默认为内联元素，而且我们不希望它们像值为 block 时一样，线条超出自己的内容，我们确实想要控制它们的大小inline-block 允许我们这样做。</li>
<li>接着是尺寸的设置！我们要填满整个 <ul> 的宽度，为按钮之间留一些间距 (margin) (但不是右边边缘的间距)，我们有 5 个按钮需要容纳，所以它们的大小应该一样。为了做到这一点，我们设置 width 为 19.5%，然后 margin-right 为 0.625%. 你会注意到所有宽度加起来是 100.625%, 这样会让最后一个按钮溢出 <ul> ，然后显示到下一行中。但是，我们使用了下一条规则让它恢复到了 100%，这条规则选中了列表中的最后一个 <a>元素，然后删除了它的间距 (margin)。完成！</li>
<li>最后三条声明就比较简单了，主要是为链接各个状态添加了颜色。我们居中了每个链接中的文本，设置 line-height 为 3，让按钮有一些高度 (这也具有垂直居中文本的优点)，并设置文本的颜色为黑色。</li>
</ul>
</li>
</ul>
<p><strong>备注：</strong> 你也许会注意到 HTML 中的列表的每项内容都在同一行上，这是因为 inline-block 元素在页面上创建的空格换行符，就像几个字之间的空格，这样的空隙也许会破坏我们的水平导航菜单布局。所以我们删除了空格。你可以在 <a target="_blank" rel="noopener" href="https://css-tricks.com/fighting-the-space-between-inline-block-elements/">Fighting the space between inline block elements</a> 找到有关此问题的更多信息（和解决方案）。</p>
<h3 id="2-13-css布局"><a href="#2-13-css布局" class="headerlink" title="2.13 css布局"></a>2.13 css布局</h3><p>此刻，我们已经看过 CSS 的基础知识，如何设置文本的样式，以及如何设置和操作内容所在的框。现在是时候看看如何把你的盒子放在与视口相关的正确位置上。我们已经涵盖了必要的先决条件，所以我们现在可以深入到 CSS 布局，查看不同的显示设置，涉及浮动和定位的传统布局方法，以及像 flexbox 这样的现代布局工具。</p>
<p>CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口&#x2F;窗口的位置。在这个模块中将涉及更多关于页面<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Layout_mode">布局技术</a>的细节：</p>
<ul>
<li>正常布局流</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a>属性</li>
<li>弹性盒子</li>
<li>网格</li>
<li>浮动</li>
<li>定位</li>
<li>CSS 表格布局</li>
<li>多列布局</li>
</ul>
<p>每种技术都有它们的用途，各有优缺点，相互辅助。通过理解各个布局方法的设计理念，你能够找到构建你想要的网页需要的布局方案。</p>
<h4 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h4><p>正常布局流（normal flow）是指在不对页面进行任何布局控制时，浏览器默认的 HTML 布局方式。让我们快速地看一个 HTML 的例子：</p>
<p>注意，HTML 元素完全按照源码中出现的先后次序显示——第一个段落、无序列表、第二个段落。</p>
<p>出现在另一个元素下面的元素被描述为<strong>块</strong>元素，与出现在另一个元素旁边的<strong>内联元素</strong>不同，内联元素就像段落中的单个单词一样。</p>
<p>当你使用 css 创建一个布局时，你正在离开<strong>正常布局流</strong>，但是对于页面上的多数元素，<strong>正常布局流</strong>将完全可以创建你所需要的布局。从一个结构良好的 Html 文档开始是非常重要，因为你可以按照默认的方式来搭建页面，而不是自造车轮。</p>
<p>下列布局技术会覆盖默认的布局行为：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a></strong> 属性 — 标准的 value，比如<code>block</code>, <code>inline</code> 或者 <code>inline-block</code> 元素在正常布局流中的表现形式 (见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model#types_of_css_boxes">Types of CSS boxes</a>). 接着是全新的布局方式，通过设置<code>display</code>的值，比如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">CSS Grid</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">Flexbox</a>.</li>
<li><strong>浮动</strong>——应用 <strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a></strong> 值，诸如 <code>left</code> 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。</li>
<li><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a></strong> 属性 — 允许你精准设置盒子中的盒子的位置，正常布局流中，默认为 <code>static</code> ，使用其它值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。</li>
<li><strong>表格布局</strong>— 表格的布局方式可以用在非表格内容上，可以使用<code>display: table</code>和相关属性在非表元素上使用。</li>
<li><strong>多列布局</strong>— 这个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Columns">Multi-column layout</a> 属性 可以让块按列布局，比如报纸的内容就是一列一列排布的。</li>
</ul>
<h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>在 css 中实现页面布局的主要方法是设定display属性的值。此属性允许我们更改默认的显示方式。正常流中的所有内容都有一个display的值，用作元素的默认行为方式。例如，英文段落显示在一个段落的下面，这是因为它们的样式是display:block。如果在段落中的某个文本周围创建链接，则该链接将与文本的其余部分保持内联，并且不会打断到新行。这是因为<a>元素默认为display:inline。</p>
<p>您可以更改此默认显示行为。例如，<li>元素默认为display:block，这意味着在我们的英文文档中，列表项显示为一个在另一个之下。如果我们将显示值更改为inline，它们现在将显示在彼此旁边，就像单词在句子中所做的那样。事实上，您可以更改任何元素的display值，这意味着您可以根据它们的语义选择 html 元素，而不必关心它们的外观。他们的样子是你可以改变的。</p>
<p>除了可以通过将一些内容从<code>block</code>转换为<code>inline</code>（反之亦然）来更改默认表示形式之外，还有一些更大的布局方法以<code>display</code>值开始。但是，在使用这些属性时，通常需要调用其他属性。在讨论布局时，对我们来说最重要的两个值是 <code>display: flex</code> 和 <code>display: grid</code>。</p>
<h4 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h4><p>Flexbox 是 CSS 弹性盒子布局模块（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexible Box Layout</a> Module）的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。要使用 flexbox，你只需要在想要进行 flex 布局的父元素上应用<code>display: flex</code> ，所有直接子元素都将会按照 flex 进行布局。我们来看一个例子。</p>
<h4 id="设置-display-flex"><a href="#设置-display-flex" class="headerlink" title="设置 display:flex"></a>设置 display:flex</h4><p>下面这些 HTML 标记描述了一个 class 为<code>wrapper</code>的容器元素，它的内部有三个<code>&lt;div&gt;</code>元素。它们在我们的英文文档当中，会默认地作为块元素从上到下进行显示。</p>
<p>现在，当我们把<code>display: flex</code>添加到它的父元素时，这三个元素就自动按列进行排列。这是由于它们变成了*flex 项 (flex items)*，按照 flex 容器（也就是它们的父元素）的一些 flex 相关的初值进行 flex 布局：它们整整齐齐排成一行，是因为父元素上<code>flex-direction</code>的初值是<code>row</code>。它们全都被拉伸至和最高的元素高度相同，是因为父元素上<code>align-items</code>属性的初值是<code>stretch</code>。这就意味着所有的子元素都会被拉伸到它们的 flex 容器的高度，在这个案例里就是所有 flex 项中最高的一项。所有项目都从容器的开始位置进行排列，排列成一行后，在尾部留下一片空白。</p>
<h4 id="设置-flex-属性"><a href="#设置-flex-属性" class="headerlink" title="设置 flex 属性"></a>设置 flex 属性</h4><p>除了上述可以被应用到 flex 容器的属性以外，还有很多属性可以被应用到 flex 项 (flex items) 上面。这些属性可以改变 flex 项在 flex 布局中占用宽&#x2F;高的方式，允许它们通过伸缩来适应可用空间。</p>
<p>作为一个简单的例子，我们可以在我们的所有子元素上添加<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 属性，并赋值为<code>1</code>，这会使得所有的子元素都伸展并填充容器，而不是在尾部留下空白，如果有更多空间，那么子元素们就会变得更宽，反之，他们就会变得更窄。除此之外，如果你在 HTML 标记中添加了一个新元素，那么它们也会变得更小，来为新元素创造空间——不管怎样，最终它们会调整自己直到占用相同宽度的空间。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>    display: flex;<br>&#125;<br><br>.<span class="hljs-keyword">wrapper</span> &gt; div &#123;<br>    flex: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Copy to Clipboard</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>Copy to Clipboard</p>
<iframe class="sample-code-frame" title="设置 flex 属性 sample" id="frame_设置_flex_属性" width="300" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%AE%BE%E7%BD%AE_flex_%E5%B1%9E%E6%80%A7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> 为了找到更多关于 Flexbox 的信息，看看我们的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">Flexbox</a> 的文章。</p>
<h4 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h4><p>Flexbox 用于设计横向或纵向的布局，而 Grid 布局则被设计用于同时在两个维度上把元素按行和列排列整齐。</p>
<h4 id="设置-display-grid"><a href="#设置-display-grid" class="headerlink" title="设置 display: grid"></a>设置 display: grid</h4><p>同 flex 一样，你可以通过指定 display 的值来转到 grid 布局：<code>display: grid</code>。下面的例子使用了与 flex 例子类似的 HTML 标记，描述了一个容器和若干子元素。除了使用<code>display:grid</code>，我们还分别使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows"><code>grid-template-rows</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-columns"><code>grid-template-columns</code></a> 两个属性定义了一些行和列的轨道。定义了三个<code>1fr</code>的列，还有两个<code>100px</code>的行之后，无需再在子元素上指定任何规则，它们自动地排列到了我们创建的格子当中。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>    display: grid;<br>    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px;<br>    grid-gap: <span class="hljs-number">10</span>px;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box6</span>&quot;&gt;<span class="hljs-symbol">Six</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="设置 display: grid sample" id="frame_设置_display_grid" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%AE%BE%E7%BD%AE_display_grid.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="在网格内放置元素"><a href="#在网格内放置元素" class="headerlink" title="在网格内放置元素"></a>在网格内放置元素</h4><p>一旦你拥有了一个 grid，你也可以显式地将元素摆放在里面，而不是依赖于浏览器进行自动排列。在下面的第二个例子里，我们定义了一个和上面一样的 grid，但是这一次我们只有三个子元素。我们利用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column"><code>grid-column</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row"><code>grid-row</code></a> 两个属性来指定每一个子元素应该从哪一行&#x2F;列开始，并在哪一行&#x2F;列结束。这就能够让子元素在多个行&#x2F;列上展开。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box1</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box2</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box3</span> &#123;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="在网格内放置元素 sample" id="frame_在网格内放置元素" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%9C%A8%E7%BD%91%E6%A0%BC%E5%86%85%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> 这两个例子只是展示了 grid 布局的冰山一角，要深入了解 grid 布局，请参阅我们的文章<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">Grid Layout</a>。</p>
<p>这篇指南的其余部分介绍了其他的布局方式，它们与你的页面的主要布局结构关系不大，但是却能够帮助你实现特殊的操作。同时，只要你理解了每一个布局任务的初衷，你就能够马上意识到哪一种布局更适合你的组件。</p>
<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>把一个元素“浮动”(float) 起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流 (normal flow) 中移除，这时候其他的周围内容就会在这个被设置浮动 (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>) 的元素周围环绕。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性有四个可能的值：</p>
<ul>
<li><code>left</code> — 将元素浮动到左侧。</li>
<li><code>right</code> — 将元素浮动到右侧。</li>
<li><code>none</code> — 默认值，不浮动。</li>
<li><code>inherit</code> — 继承父元素的浮动属性。</li>
</ul>
<p>在下面这个例子当中，我们把一个<code>&lt;div&gt;</code>元素浮动到左侧，并且给了他一个右侧的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>，把文字推开。这给了我们文字环绕着这个<code>&lt;div&gt;</code>元素的效果，在现代网页设计当中，这是你唯一需要学会的事情。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;h1&gt;Simple float example&lt;/h1&gt;<br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;Float&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>&lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar <span class="hljs-built_in">id</span> metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, <span class="hljs-keyword">at</span> ultricies tellus laoreet sit amet. Sed auctor cursus massa <span class="hljs-keyword">at</span> porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut <span class="hljs-built_in">id</span> ornare felis, eget fermentum sapien.&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="浮动 sample" id="frame_浮动" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E6%B5%AE%E5%8A%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> CSS 浮动的知识会在我们关于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">浮动</a>的教程当中被详细地解释。除此之外，如果您想要了解在 Flexbox 和 Grid 布局出现之前我们是如何进行列布局的（仍然有可能碰到这种情形），请阅读我们关于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">传统布局方式</a>的文章。</p>
<h4 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h4><p>定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。定位 (positioning) 并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。</p>
<p>有一些非常有用的技术在特定的布局下依赖于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>属性。同时，理解定位 (positioning) 也能够帮助你理解正常布局流 (normal flow)，理解把一个元素移出正常布局流 (normal flow) 是怎么一回事。</p>
<p>有五种主要的定位类型需要我们了解：</p>
<ul>
<li><strong>静态定位</strong>（Static positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。</li>
<li><strong>相对定位</strong>（Relative positioning）允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计（design pinpointing）非常有用。</li>
<li><strong>绝对定位</strong>（Absolute positioning）将元素完全从页面的正常布局流（normal layout flow）中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 <code>&lt;html&gt;</code> 元素边缘固定，或者相对于该元素的<em>最近被定位祖先元素</em>（nearest positioned ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。</li>
<li><strong>固定定位</strong>（Fixed positioning）与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。</li>
<li><strong>粘性定位</strong>（Sticky positioning）是一种新的定位方式，它会让元素先保持和 <code>position: static</code> 一样的定位，当它的相对视口位置（offset from the viewport）达到某一个预设值时，它就会像 <code>position: fixed</code> 一样定位。</li>
</ul>
<h4 id="简单定位示例"><a href="#简单定位示例" class="headerlink" title="简单定位示例"></a>简单定位示例</h4><p>我们将展示一些示例代码来熟悉这些布局技术。这些示例代码都作用在下面这一个相同的 HTML 上：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-variable">&lt;h1&gt;</span>Positioning&lt;/h1&gt;<br><br><span class="hljs-variable">&lt;p&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br><span class="hljs-variable">&lt;p class=&quot;positioned&quot;&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br><span class="hljs-variable">&lt;p&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<p>该 HTML 将使用以下 CSS 默认样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<iframe class="sample-code-frame" title="简单定位示例 sample" id="frame_简单定位示例" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%AE%80%E5%8D%95%E5%AE%9A%E4%BD%8D%E7%A4%BA%E4%BE%8B.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对定位 (relative positioning) 让你能够把一个正常布局流 (normal flow) 中的元素从它的默认位置按坐标进行相对移动。比如将一个图标往下调一点，以便放置文字。我们可以通过下面的规则添加相对定位来实现效果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们给中间段落的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 一个 <code>relative</code>值——这属性本身不做任何事情，所以我们还添加了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a>属性。这些可以将受影响的元素向下向右移——这可能看起来和你所期待的相反，但你需要把它看成是左边和顶部的元素被“推开”一定距离，这就导致了它的向下向右移动。</p>
<p>添加此代码将给出以下结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>,.<span class="hljs-number">3</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>);<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="相对定位 sample" id="frame_相对定位" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位用于将元素移出正常布局流 (normal flow)，以坐标的形式相对于它的容器定位到 web 页面的任何位置，以创建复杂的布局。有趣的是，它经常被用于与相对定位和浮动的协同工作。</p>
<p>回到我们最初的非定位示例，我们可以添加以下的 CSS 规则来实现绝对定位：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们给我们的中间段一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>的 <code>absolute</code>值，并且和前面一样加上 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a> 和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a> 属性。但是，添加此代码将给出以下结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>,.<span class="hljs-number">3</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>);<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="绝对定位 sample" id="frame_绝对定位" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>这和之前截然不同！定位元素现在已经与页面布局的其余部分完全分离，并位于页面的顶部。其他两段现在靠在一起，好像之前那个中间段落不存在一样。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a>属性对绝对位置元素的影响不同于相对位置元素。在这一案例当中，他们没有指定元素相对于原始位置的移动程度。相反，在这一案例当中，它们指定元素应该从页面边界的顶部和左边的距离 (确切地说，是 <code>&lt;html&gt;</code>元素的距离)。我们也可以修改作为容器的那个元素（在这里是<code>&lt;html&gt;</code>元素），要了解这方面的知识，参见关于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">定位 (positioning)</a>的课程</p>
<p>我们现在暂时不讨论固定定位（fixed positioning）——它基本上以相同的方式工作，除了它仍然固定在浏览器窗口的边缘，而不是它定位的父节点的边缘。</p>
<h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><p>固定定位 (fixed positioning) 同绝对定位 (absolute positioning) 一样，将元素从文档流 (document flow) 当中移出了。但是，定位的坐标不会应用于”容器”边框来计算元素的位置，而是会应用于视口 (viewport) 边框。利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。</p>
<p>在这个例子里面，我们在 HTML 加了三段很长的文本来使得页面可滚动，又加了一个带有<code>position: fixed</code>的盒子。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Fixed positioning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;positioned&quot;</span>&gt;</span>Fixed<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 3.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="固定定位 sample" id="frame_固定定位" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h4><p>粘性定位 (sticky positioning) 是最后一种我们能够使用的定位方式。它将默认的静态定位 (static positioning) 和固定定位 (fixed positioning) 相混合。当一个元素被指定了<code>position: sticky</code>时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了<code>position: fixed</code>一样。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="粘性定位 sample" id="frame_粘性定位" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> 想要发现更多关于定位的信息，请参阅我们的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">Positioning</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Practical_positioning_examples">Practical positioning examples</a>文章。</p>
<h4 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h4><p>HTML 表格对于显示表格数据是很好的，但是很多年前——在浏览器中支持基本的 CSS 之前——web 开发人员过去也常常使用表格来完成整个网页布局——将它们的页眉、页脚、不同的列等等放在不同的表行和列中。这在当时是有效的，但它有很多问题——表布局是不灵活的，繁重的标记，难以调试和语义上的错误（比如，屏幕阅读器用户在导航表布局方面有问题）。</p>
<p>一个<code>&lt;table&gt;</code>标签之所以能够像表格那样展示，是由于 css 默认给<code>&lt;table&gt;</code>标签设置了一组 table 布局属性。当这些属性被应用于排列非<code>&lt;table&gt;</code>元素时，这种用法被称为“使用 CSS 表格”。</p>
<p>下面这个例子展示了一个这样的用法。使用 CSS 表格来进行布局，在现在这个时间点应该被认为是一种传统方法，它通常会被用于兼容一些不支持 Flexbox 和 Grid 的浏览器。</p>
<p>让我们来看一个例子。首先，创建 HTML 表单的一些简单标记。每个输入元素都有一个标签，我们还在一个段落中包含了一个标题。为了进行布局，每个标签&#x2F;输入对都封装在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First of all, tell us your name and age.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>First name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span>Last name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>Age:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>现在，我们例子中的 CSS。除了使用 display 属性外，大多数 CSS 都是相当普通的。 <code>&lt;form&gt;</code>,<code> &lt;div&gt;</code>, <code>&lt;label&gt;</code>和<code>&lt;input&gt;</code>被告知要分别显示表、表行和表单元——基本上，它们会像 HTML 表格标记一样，导致标签和输入在默认情况下排列整齐。我们所要做的就是添加一些大小、边缘等等，让一切看起来都好一点，我们就完成了。</p>
<p>你会注意到标题段落已经给出了 display: table-caption;——这使得它看起来就像一个表格<code>&lt;caption&gt;</code> ——同时出于设计需要，我们通过caption-side: bottom; 告诉标题应该展示在表格的底部，即使这个<code>&lt;p&gt;</code>标记在源码中是在<code>&lt;input&gt;</code>之前。这就能让你有一点灵活的弹性。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-row;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">label</span>, <span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">label</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">5%</span>;<br>  <span class="hljs-attribute">text-align</span>: right;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-caption;<br>  <span class="hljs-attribute">caption-side</span>: bottom;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#999</span>;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果如下：</p>
<iframe class="sample-code-frame" title="表格布局 sample" id="frame_表格布局" width="100%" height="170" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>你可以在 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/styling-boxes/box-model-recap/css-tables-example.html">css-tables-example.html</a> 看到预览版 (也可以见<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/box-model-recap/css-tables-example.html">源码</a>)</p>
<h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>多列布局模组给了我们 一种把内容按列排序的方式，就像文本在报纸上排列那样。由于在 web 内容里让你的用户在一个列上通过上下滚动来阅读两篇相关的文本是一种非常低效的方式，那么把内容排列成多列可能是一种有用的技术。</p>
<p>要把一个块转变成多列容器 (multicol container)，我们可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a>属性来告诉浏览器我们需要多少列，也可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a>来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。</p>
<p>在下面这个例子中，我们从一个 class 为<code>container</code>的<code>&lt;div&gt;</code>容器元素里边的一块 HTML 开始。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Multi-column layout<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们指定了该容器的<code>column-width</code>为 200 像素，这让浏览器创建了尽可能多的 200 像素的列来填充这一容器。接着他们共同使用剩余的空间来伸展自己的宽度。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="多列布局 sample" id="frame_多列布局" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h3 id="2-14-弹性盒子"><a href="#2-14-弹性盒子" class="headerlink" title="2.14 弹性盒子"></a>2.14 弹性盒子</h3><p>我们给的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flex</code> 的元素就像一个块级元素，但是它的子元素布局为 flex 项。下个部分将更详细地描述这些意味着什么。请注意，如果你希望该元素的子元素作为 flex 项，你也可以使用 <code>display</code> 值为 <code>inline-flex</code>，但是该元素的行为类似于行内元素。</p>
<h4 id="flex-模型说明"><a href="#flex-模型说明" class="headerlink" title="flex 模型说明"></a>flex 模型说明</h4><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png" srcset="/blog/img/loading.gif" lazyload alt="在从左到右的语言中，三个 flex 项并排放置在 flex 容器中。主轴——弹性容器布置 flex 方向上的轴——是水平的。主轴的两端是开始端和结束端，分别位于左侧和右侧。交叉轴是垂直的；垂直于主轴。交叉轴的开始端和结束端分别位于顶部和底部。flex 项沿着主轴排列，在这种情况下，宽度称为主轴尺寸，flex 项沿交叉轴排列，在这种情况下，高度称为交叉尺寸。"></p>
<ul>
<li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li>
<li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li>
<li>设置了 <code>display: flex</code> 的父元素，被称之为 <strong>flex 容器（flex container）。</strong></li>
<li>在 flex 容器中表现为弹性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）</li>
</ul>
<p>了解这些术语以便你阅读后续章节。如果你对使用的任何术语感到困惑，你可以随时返回这里。</p>
<h4 id="列还是行？"><a href="#列还是行？" class="headerlink" title="列还是行？"></a>列还是行？</h4><p>弹性盒子提供了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）——它默认值是 <code>row</code>，这使得它们在按你浏览器的默认语言方向排成一排（在英语&#x2F;中文浏览器中是从左到右）。</p>
<p>尝试将以下声明添加到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">&#96;&#96;</a> 元素的 css 规则里：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: column;<br></code></pre></td></tr></table></figure>



<p>你会看到，这会将那些元素设置为列布局，就像我们添加这些 CSS 之前。在继续之前，请从示例中删除此规则。</p>
<p><strong>备注：</strong> 你还可以使用 <code>row-reverse</code> 和 <code>column-reverse</code> 值反向排列 flex 项。用这些值试试看吧！</p>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>当你在布局中使用定宽或者定高的时候，可能会出现问题即处于容器中的弹性盒子子元素会溢出，破坏了布局。你可以看一下<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox-wrap0.html">弹性盒子——wrap0.html</a> 示例（你也可以拷贝到本地），如下所示：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example3.png" srcset="/blog/img/loading.gif" lazyload alt="简单弹性盒子示例，将所有 flex 项都布置在弹性容器的一行中。第八个 flex 项在浏览器窗口溢出，页面具有可见的水平和垂直滚动条，因为它无法容纳在窗口的宽度内，因为前七个 flex 项占用了视口中的可用空间。默认情况下，如果将弹性方向设置为行，浏览器会尝试将所有 flex 项放在一行中；如果弹性方向设置为列，则会尝试将所有 flex 项置于单列中。"></p>
<p>在这里我们看到，子代确实超出了它们的容器。解决此问题的一种方法是将以下声明添加到 section css 规则中：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">flex-<span class="hljs-keyword">wrap</span>: <span class="hljs-keyword">wrap</span><br></code></pre></td></tr></table></figure>

<p>同时，把以下规则也添加到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article"><code>&lt;article&gt;</code></a> 规则中：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: <span class="hljs-number">200px</span>;<br></code></pre></td></tr></table></figure>

<p>现在尝试一下吧；你会看到布局比原来好多了：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example4.png" srcset="/blog/img/loading.gif" lazyload alt="flex 项在弹性容器中分多行排列。flex-wrap 属性在弹性容器中设置为“wrap”，如果上一行中的 flex 项在弹性容器外溢出，则弹性容器中显示新行中的 flex 项。每个 flex 项的宽度为 200 像素。所有物品都被拉伸到相同的高度，与内容最多的 flex 项一样高。"></p>
<p>我们现在有多个行。每行都安装了尽可能多的 flex 项。任何溢出都会向下移动到下一行。在 article 上设置的 <code>flex：200px</code> 声明意味着每个声明将至少为 200px 宽。我们稍后会更详细地讨论这个属性。你可能还注意到，最后一行上的最后几个项每个都变得更宽，以便把整个行填满。</p>
<p>但是这里我们可以做得更多。首先，改变 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 属性值为 <code>row-reverse</code>——你会看到仍然有多行布局，但是每一行元素排列的方向和原来是相反的了。</p>
<h4 id="flex-flow-缩写"><a href="#flex-flow-缩写" class="headerlink" title="flex-flow 缩写"></a>flex-flow 缩写</h4><p>到这里，应当注意到存在着 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap"><code>flex-wrap</code></a>——的缩写 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-flow"><code>flex-flow</code></a>。比如，你可以将</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row;<br><span class="hljs-attribute">flex-wrap</span>: wrap;<br></code></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-flow</span>: row wrap;<br></code></pre></td></tr></table></figure>

<h4 id="flex-项的动态尺寸"><a href="#flex-项的动态尺寸" class="headerlink" title="flex 项的动态尺寸"></a>flex 项的动态尺寸</h4><p>现在让我们回到第一个例子，看看是如何控制 flex 项占用空间的比例的。打开你本地的 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox0.html">弹性盒子 0.html</a>，或者拷贝 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox1.html">弹性盒子 1.html</a> 作为新的开始（<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/css-layout/flexbox/flexbox1.html">查看线上</a>）。</p>
<p>第一步，将以下规则添加到 CSS 的底部：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。本例中，我们设置 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">&#96;&#96;</a> 元素的 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为它是一个比例，这意味着将每个 flex 项的设置为 400000 的效果和 1 的时候是完全一样的。</p>
<p>现在在上一个规则下添加：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在当你刷新，你会看到第三个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">&#96;&#96;</a> 元素占用了两倍的可用宽度和剩下的一样——现在总共有四个比例单位可用。前两个 flex 项各有一个，因此它们占用每个可用空间的 1&#x2F;4。第三个有两个单位，所以它占用 2&#x2F;4 或者说是 1&#x2F;2 的可用空间。</p>
<p>你还可以指定 flex 的最小值。尝试修改现有的 article 规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这表示“每个 flex 项将首先给出 200px 的可用空间，然后，剩余的可用空间将根据分配的比例共享”。尝试刷新，你会看到分配空间的差别。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example1.png" srcset="/blog/img/loading.gif" lazyload alt="简单的 flexbox 示例，flex 容器中有三个 flex 项。所有 flex 项的最低宽度为 200 像素——使用“flex”设置。前两个 flex 项的 flex 值为 1，第三个项的 flex 值为 2。这会将弹性容器中的剩余空间分成 4 个比例单位。前两个 flex 项各分配一个单元，第三个 flex 项分配两个单元，使第三个 flex 项比宽度相同的其他两个更宽。"></p>
<p>弹性盒子的真正价值可以体现在它的灵活性&#x2F;响应性，如果你调整浏览器窗口的大小，或者增加一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article"><code>&lt;artcle&gt;</code></a> 元素，这时的布局仍旧是好的。</p>
<h4 id="flex：缩写与全写"><a href="#flex：缩写与全写" class="headerlink" title="flex：缩写与全写"></a>flex：缩写与全写</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 是一个可以指定最多三个不同值的缩写属性：</p>
<ul>
<li>第一个就是上面所讨论过的无单位比例。可以单独指定全写 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow"><code>flex-grow</code></a> 属性的值。</li>
<li>第二个无单位比例——<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink"><code>flex-shrink</code></a>——一般用于溢出容器的 flex 项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。这是一个相当高级的弹性盒子功能，我们不会在本文中进一步说明。</li>
<li>第三个是上面讨论的最小值。可以单独指定全写 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis"><code>flex-basis</code></a> 属性的值。</li>
</ul>
<p>我们建议不要使用全写属性，除非你真的需要（比如要去覆盖之前写的）。使用全写会多写很多的代码，它们也可能有点让人困惑。</p>
<h4 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h4><p>还可以使用弹性盒子的功能让 flex 项沿主轴或交叉轴对齐。让我们一起看一下新例子——<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flex-align0.html">flex-align0.html</a>（<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/css-layout/flexbox/flex-align0.html">在线浏览</a>）——我们将会有一个整洁，灵活的按钮&#x2F;工具栏。此时，你看到了一个水平菜单栏，其中一些按钮卡在左上角，就像下面这样：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example5.png" srcset="/blog/img/loading.gif" lazyload alt="带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排列在一个弹性容器中。按钮卡在左上角，看起来不整洁。"></p>
<p>首先，拷贝一份到本地。</p>
<p>然后，将下面的 CSS 添加到例子的底部：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox_center_space-around.png" srcset="/blog/img/loading.gif" lazyload alt="带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排在一个弹性容器中。通过将对齐项属性设置为中心，flex 项位于横轴的中心。通过将 justify-content 属性设置为 space-around，flex 项沿着主轴均匀间隔。"></p>
<p>刷新一下页面，你就会看到这些按钮很好的垂直水平居中了。我们是通过下面所说的两个新的属性做到的。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 控制 flex 项在交叉轴上的位置。</p>
<ul>
<li>默认的值是 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。我们的第一个例子在默认情况下得到相等的高度的列的原因。</li>
<li>在上面规则中我们使用的 <code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。</li>
<li>你也可以设置诸如 <code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 了解更多。</li>
</ul>
<p>你可以用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-self"><code>align-self</code></a> 属性覆盖 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 的行为。比如，你可以这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">align-self</span>: flex-end;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>！<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox/flexbox_first-child_flex-end.png">带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排在一个弹性容器中。除第一个项外，所有 flex 项都通过将对齐项属性设置为中心，位于十字轴的中心或垂直居中。第一项与交叉轴末端的弹性容器底部齐平，对齐自属性设置 flex 端。flex 项沿着容器的主轴或宽度均匀间隔。</a></p>
<p>去看看它产生的效果，然后删除它。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content"><code>justify-content</code></a> 控制 flex 项在主轴上的位置。</p>
<ul>
<li>默认值是 <code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。</li>
<li>你也可以用 <code>flex-end</code> 来让 flex 项到结尾处。</li>
<li><code>center</code> 在 <code>justify-content</code> 里也是可用的，可以让 flex 项在主轴居中。</li>
<li>而我们上面用到的值 <code>space-around</code> 是很有用的——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li>
<li>还有一个值是 <code>space-between</code>，它和 <code>space-around</code> 非常相似，只是它不会在两端留下任何空间。</li>
</ul>
<p>在继续下面之前，多多使用提到过的属性吧，看看它们的效果。</p>
<h4 id="flex-项排序"><a href="#flex-项排序" class="headerlink" title="flex 项排序"></a>flex 项排序</h4><p>弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。</p>
<p>代码也很简单，将下面的 CSS 添加到示例代码下面。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>刷新下，然后你会看到“Smile”按钮移动到了主轴的末尾。下面我们谈下它实现的一些细节：</p>
<ul>
<li>所有 flex 项默认的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/order"><code>order</code></a> 值是 0。</li>
<li>order 值大的 flex 项比 order 值小的在显示顺序中更靠后。</li>
<li>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。</li>
<li>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。</li>
</ul>
<p>你也可以给 order 设置负值使它们比值为 0 的元素排得更前面。比如，你可以设置“Blush”按钮排在主轴的最前面：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="flex-嵌套"><a href="#flex-嵌套" class="headerlink" title="flex 嵌套"></a>flex 嵌套</h4><p>弹性盒子也能创建一些颇为复杂的布局。设置一个元素为 flex 项，那么他同样成为一个 flex 容器，它的孩子（直接子节点）也表现为弹性盒子。看一下 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/complex-flexbox.html">复杂弹性盒子.html</a>（<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/css-layout/flexbox/complex-flexbox.html">在线浏览</a>）。</p>
<p>这个例子的 HTML 是相当简单的。我们用一个<code>&lt;section&gt;</code>元素包含了三个<code> &lt;article&gt;</code>元素。第三个<code>&lt;article&gt;</code>元素包含了三个<code> &lt;div&gt;</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">section</span> - <span class="hljs-selector-tag">article</span><br>          <span class="hljs-selector-tag">article</span><br>          <span class="hljs-selector-tag">article</span> - <span class="hljs-selector-tag">div</span> - <span class="hljs-selector-tag">button</span><br>                    <span class="hljs-selector-tag">div</span>   <span class="hljs-selector-tag">button</span><br>                    <span class="hljs-selector-tag">div</span>   <span class="hljs-selector-tag">button</span><br>                          <span class="hljs-selector-tag">button</span><br>                          <span class="hljs-selector-tag">button</span><br></code></pre></td></tr></table></figure>

<p>现在让我们看一下布局用到的代码。</p>
<p>首先，我们设置 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section"><code>section</code></a> 的子节点布局为弹性盒子。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">section</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面我们给<code>&lt;article&gt;</code>元素设置 flex 值。特别注意这里的第二条 CSS 规则——我们设置第三个<code> &lt;article&gt;</code>元素的子节点的布局同样为 flex，但是属性值为列布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">3</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-flow</span>: column;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，我们选择了第一个<code> &lt;div&gt;</code>。首先使用 flex: 1 100px; 简单的给它一个最小的高度 100px，然后设置它的子节点（<code>&lt;button&gt; </code>元素）为 flex 项。在这里我们将它们放在一个包装行（wrap row）中，使它们居中对齐，就像我们在前面看到的单个按钮示例中做的那样。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-flow</span>: row wrap;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，我们给按钮设置大小，有意思的是我们给它一个值为 1 的 flex 属性。如果你调整浏览器窗口宽度，你会看到这是一个非常有趣的效果。按钮将尽可能占用最多的空间，尽可能多的堆在同一条线上，但是当它们不再适合在同一条线上，他们中的一些会到下一行去。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="跨浏览器兼容性"><a href="#跨浏览器兼容性" class="headerlink" title="跨浏览器兼容性"></a>跨浏览器兼容性</h4><p>大多数浏览器都支持弹性盒子，诸如 Firefox、Chrome、Opera、Microsoft Edge 和 IE 11，较新版本的 Android&#x2F;iOS 等等。但是你应该要意识到仍旧有被人使用的老浏览器不支持弹性盒子（或者支持，但是只是支持非常非常老版本的弹性盒子）。</p>
<p>虽然你只是在学习和实验，这不太要紧; 然而，如果你正在考虑在真实网站中使用弹性盒子，则需要进行测试，并确保在尽可能多的浏览器中你的用户体验仍然可以接受。</p>
<p>弹性盒子相较其他一些 CSS 特性可能更为棘手。例如，如果浏览器缺少 CSS 阴影，则该网站可能仍然可用。但是假如不支持弹性盒子功能就会完全打破布局，使其不可用。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Cross_browser_testing">跨浏览器测试</a>模块中讨论了克服跨浏览器支持问题的策略。</p>
<h3 id="2-15-网格"><a href="#2-15-网格" class="headerlink" title="2.15 网格"></a>2.15 网格</h3><p>CSS 网格是一个用于 web 的二维布局系统。利用网格，你可以把内容按照行与列的格式进行排版。另外，网格还能非常轻松地实现一些复杂的布局。关于使用网格进行页面排版，这篇文章包含了你需要的一切知识。</p>
<h4 id="什么是网格布局？"><a href="#什么是网格布局？" class="headerlink" title="什么是网格布局？"></a>什么是网格布局？</h4><p>网格是由一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。</p>
<p>一个网格通常具有许多的<strong>列（column）</strong>与<strong>行（row）</strong>，以及行与行、列与列之间的间隙，这个间隙一般被称为<strong>沟槽（gutter）</strong>。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids/grid.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><strong>备注：</strong> 任何有设计背景的人似乎都感到惊讶，CSS 没有内置的网格系统，而我们似乎使用各种次优方法来创建网格状的设计。正如你将在本文的最后一部分中发现的那样，这将被改变，但是你可能需要知道在未来一段时间内创建网格的现有方法。</p>
<h4 id="在-CSS-中创建自己的网格"><a href="#在-CSS-中创建自己的网格" class="headerlink" title="在 CSS 中创建自己的网格"></a>在 CSS 中创建自己的网格</h4><p>决定好你的设计所需要的网格后，你可以创建一个 CSS 网格版面并放入各类元素。我们先来看看网格的基础功能，然后尝试做一个简单的网格系统。</p>
<h4 id="定义一个网格"><a href="#定义一个网格" class="headerlink" title="定义一个网格"></a>定义一个网格</h4><p>和往常一样，你可以下载，然后在文本编辑器中打开并浏览教程的<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/main/css/css-layout/grids/0-starting-point.html">起始文件</a>（你可以<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/css-layout/grids/0-starting-point.html">在这里查看实时的效果</a>）。你会看到一个带有容器的示例，容器中有一些子项。默认情况下，子项按照正常布局流自顶而下排布。在这篇教程的第一部分，我们会从这开始，通过对这个文件做一些改变，来了解网格是如何工作的。</p>
<p>首先，我们通过把容器的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性设置为 <code>grid</code> ,来定义一个网格。与弹性盒子一样，将父容器改为网格布局后，他的直接子项会变为网格项。把下面的 css 规则加到你的文件中。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  <span class="hljs-keyword">display</span>: grid;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>与弹性盒子不同的是，在定义网格后，网页并不会马上发生变化。因为 <code>display: grid</code> 的声明只创建了一个只有一列的网格，所以子项还是会像正常布局流那样，自上而下、一个接一个的排布。</p>
<p>为了让我们的容器看起来更像一个网格，我们要给刚定义的网格加一些列。那就让我们加三个宽度为<code>200px</code>的列。当然，这里可以用任何长度单位，包括百分比。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在你的 CSS 中加入第二个规则。刷新页面后，你会看到子项们排进了新定义的网格中。</p>
<iframe class="sample-code-frame" title="定义一个网格 sample" id="frame_定义一个网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="使用-fr-单位的灵活网格"><a href="#使用-fr-单位的灵活网格" class="headerlink" title="使用 fr 单位的灵活网格"></a>使用 fr 单位的灵活网格</h4><p>除了长度和百分比，我们也可以用 <code>fr</code> 这个单位来灵活地定义网格的行与列的大小。这个单位代表网格容器中可用空间的一份，可能有点抽像，看看下面的例子吧。</p>
<p>使用下面的规则来修改你的网格轨道，创建 3 个宽度为 <code>1fr</code> 的列：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将窗口调窄（由于示例中设定了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>，可能需要很窄），你应该能看到每一列的宽度可以会随着可用空间变小而变小。<code>fr</code> 单位按比例划分了可用空间，如果没有理解，可以试着改一下数值，看看会发生什么，比如下面的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个定义里，第一列被分配了 <code>2fr</code> 可用空间，余下的两列各被分配了 <code>1fr</code> 的可用空间，这会使得第一列的宽度更大。另外，<code>fr</code>可以与一般的长度单位混合使用。比如设置 <code>grid-template-columns: 300px 2fr 1fr</code>，那么第一列宽度是<code>300px</code>，剩下的两列会根据剩余的可用空间按比例分配。</p>
<iframe class="sample-code-frame" title="使用 fr 单位的灵活网格 sample" id="frame_使用_fr_单位的灵活网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E4%BD%BF%E7%94%A8_fr_%E5%8D%95%E4%BD%8D%E7%9A%84%E7%81%B5%E6%B4%BB%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> <code>fr</code>单位分配的是<em>可用</em>空间而非<em>所有</em>空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。</p>
<h4 id="网格间隙"><a href="#网格间隙" class="headerlink" title="网格间隙"></a>网格间隙</h4><p>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap"><code>grid-column-gap</code> (en-US)</a> 属性来定义列间隙；使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap"><code>grid-row-gap</code> (en-US)</a> 来定义行间隙；使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/gap"><code>grid-gap</code> (en-US)</a> 可以同时设定两者。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>间隙距离可以用任何长度单位包括百分比来表示，但不能使用<code>fr</code>单位。</p>
<iframe class="sample-code-frame" title="网格间隙 sample" id="frame_网格间隙" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E7%BD%91%E6%A0%BC%E9%97%B4%E9%9A%99.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> <code>gap</code>属性曾经有一个<code>grid-</code>前缀，不过后来的标准进行了修改，目的是让他们能够在不同的布局方法中都能起作用。尽管现在这个前缀不会影响语义，但为了代码的健壮性，你可以把两个属性都写上。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="重复构建轨道组"><a href="#重复构建轨道组" class="headerlink" title="重复构建轨道组"></a>重复构建轨道组</h4><p>你可以使用<code>repeat</code>来重复构建具有某些宽度配置的某些列。举个例子，如果要创建多个等宽轨道，可以用下面的方法。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和之前一样，你仍然得到了 3 个 <code>1fr</code> 的列。第一个传入 repeat 函数的值（<code>3</code>）表明了后续列宽的配置要重复多少次，而第二个值（<code>1fr</code>）表示需要重复的构建配置，这个配置可以具有多个长度设定。例如<code>repeat(2, 2fr 1fr)</code>，如果你仍然不明白，可以实际测试一下效果，这相当于填入了 <code>2fr 1fr 2fr 1fr</code>。</p>
<h4 id="显式网格与隐式网格"><a href="#显式网格与隐式网格" class="headerlink" title="显式网格与隐式网格"></a>显式网格与隐式网格</h4><p>到目前为止，我们定义过了列，但还没有管过行。但在这之前，我们要来理解一下显式网格和隐式网格。显式网格是我们用 <code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。</p>
<p>隐式网格中生成的行&#x2F;列大小是参数默认是 <code>auto</code> ，大小会根据放入的内容自动调整。当然，你也可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows"><code>grid-auto-rows</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns"><code>grid-auto-columns</code></a>属性手动设定隐式网格轨道的大小。下面的例子将<code>grid-auto-rows</code>设为了<code>100px</code>，然后你可以看到那些隐式网格中的行（因为这个例子里没有设定<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows"><code>grid-template-rows</code></a>，因此，所有行都位于隐式网格内）现在都是 100 像素高了。</p>
<p>译者注：简单来说，隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显式网格自动生成的网格部分。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Copy to Clipboard</p>
<iframe class="sample-code-frame" title="显式网格与隐式网格 sample" id="frame_显式网格与隐式网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E6%98%BE%E5%BC%8F%E7%BD%91%E6%A0%BC%E4%B8%8E%E9%9A%90%E5%BC%8F%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe>

<h4 id="minmax-函数"><a href="#minmax-函数" class="headerlink" title="minmax() 函数"></a>minmax() 函数</h4><p>100 像素高的轨道有时可能会不够用，因为时常会有比 100 像素高的内容加进去。所以，我们可以将其设定为至少 100 像素，并且能够跟随内容来自动拓展尺寸，从而保证能容纳所有内容。显而易见，你很难知道网页上某个元素的尺寸在不同情况下会变成多少，一些额外的内容或者更大的字号就会导致许多能做到像素级精准的设计出现问题。所以，我们有了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 函数为一个行&#x2F;列的尺寸设置了取值范围。比如设定为 <code>minmax(100px, auto)</code>，那么尺寸就至少为 100 像素，并且如果内容尺寸大于 100 像素则会根据内容自动调整。在这里试一下把 <code>grid-auto-rows</code> 属性设置为<code>minmax</code>函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果所有网格内的内容均小于 100 像素，看起来不会有变化。但如果在某一项中放入很长的内容或者图片，你可以看到这个格子所在的哪一行的高度变成能刚好容纳内容的高度了。注意我们修改的是 <code>grid-auto-rows</code>，因此只会作用于隐式网格。当然，这一项属性也可以应用于显式网格，更多内容可以参考 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 页面。</p>
<h4 id="自动使用多列填充"><a href="#自动使用多列填充" class="headerlink" title="自动使用多列填充"></a>自动使用多列填充</h4><p>现在来试试把学到的关于网格的一切，包括 repeat 与 minmax 函数，组合起来，来实现一个非常有用的功能。某些情况下，我们需要让网格自动创建很多列来填满整个容器。通过设置<code>grid-template-columns</code>属性，我们可以实现这个效果，不过这一次我们会用到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat"><code>repeat</code></a> 函数中的一个关键字<code>auto-fill</code>来替代确定的重复次数。而函数的第二个参数，我们使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数来设定一个行&#x2F;列的最小值，以及最大值 <code>1fr</code>。</p>
<p>在你的文件中试试看，你也许可以用到以下的代码。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="自动使用多列填充 sample" id="frame_自动使用多列填充" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%88%97%E5%A1%AB%E5%85%85.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>你应该能看到形成了一个包含了许多至少 200 像素宽的列的网格，将容器填满。随着容器宽度的改变，网格会自动根据容器宽度进行调整，每一列的宽度总是大于 200 像素，并且容器总会被列填满。（This works because grid is creating as many 200 pixel columns as will fit into the container, then sharing whatever space is leftover between all of the columns — the maximum is 1fr which, as we already know, distributes space evenly between tracks.）</p>
<p>基于线的元素放置</p>
<p>在定义完了网格之后，我们要把元素放入网格中。我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。而对于阿拉伯语，第一条列分隔线在网格的最右边，因为阿拉伯文是从右往左书写的。</p>
<p>我们根据这些分隔线来放置元素，通过以下属性来指定从那条线开始到哪条线结束。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start"><code>grid-column-start</code> (en-US)</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-end"><code>grid-column-end</code> (en-US)</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-start"><code>grid-row-start</code> (en-US)</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-end"><code>grid-row-end</code> (en-US)</a></li>
</ul>
<p>这些属性的值均为分隔线序号，你也可以用以下缩写形式来同时指定开始与结束的线。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column"><code>grid-column</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row"><code>grid-row</code></a></li>
</ul>
<p>注意开始与结束的线的序号要使用<code>/</code>符号分开。</p>
<p>下载<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/css-layout/grids/8-placement-starting-point.html">这个文件</a>（或者查看<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/css-layout/grids/8-placement-starting-point.html">在线预览</a>）。文件中已经定义了一个网格以及一篇简单的文章位于网格之外。你可以看到元素已经被自动放置到了我们创建的网格中。</p>
<p>接下来，尝试用定义网格线的方法将所有元素放置到网格中。将以下规则加入到你的 css 的末尾：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="基于线的元素放置 sample" id="frame_基于线的元素放置" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%9A%84%E5%85%83%E7%B4%A0%E6%94%BE%E7%BD%AE.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> 你也可以用 <code>-1</code> 来定位到最后一条列分隔线或是行分隔线，并且可以用负数来指定倒数的某一条分隔线。但是这只能用于显式网格，对于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid">隐式网格</a><code>-1</code>不一定能定位到最后一条分隔线。</p>
<h4 id="使用-grid-template-areas-属性放置元素"><a href="#使用-grid-template-areas-属性放置元素" class="headerlink" title="使用 grid-template-areas 属性放置元素"></a>使用 grid-template-areas 属性放置元素</h4><p>另一种往网格放元素的方式是用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas"><code>grid-template-areas</code></a>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p>
<p>将之前基于线的元素放置代码删除（或者重新下载一份新的文件），然后加入以下 CSS 规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar content&quot;</span><br>    <span class="hljs-string">&quot;footer footer&quot;</span>;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">3</span>fr;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: header;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: content;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: sidebar;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: footer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>刷新页面，然后你应该能看到的元素会被放到与之前相同的地方，整个过程不需要我们指定任何分隔线序号。</p>
<iframe class="sample-code-frame" title="使用 grid-template-areas 属性放置元素 sample" id="frame_使用_grid-template-areas_属性放置元素" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E4%BD%BF%E7%94%A8_grid-template-areas_%E5%B1%9E%E6%80%A7%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><code>grid-template-areas</code>属性的使用规则如下：</p>
<ul>
<li>你需要填满网格的每个格子</li>
<li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li>
<li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li>
<li>一个连续的区域必须是一个矩形</li>
<li>使用<code>.</code>符号，让一个格子留空</li>
</ul>
<p>你可以在文件中尽情发挥你的想象来测试各种网格排版，比如把页脚放在内容之下，或者把侧边栏一直延伸到最底。这种直观的元素放置方式很棒，你在 CSS 中看到的就是实际会出现的排版效果。</p>
<h3 id="2-16-浮动"><a href="#2-16-浮动" class="headerlink" title="2.16 浮动"></a>2.16 浮动</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性最初只用于在成块的文本内浮动图像，但是现在它已成为在网页上创建多列布局的最常用工具之一。本文将阐述它的有关知识。</p>
<h4 id="浮动的背景知识"><a href="#浮动的背景知识" class="headerlink" title="浮动的背景知识"></a>浮动的背景知识</h4><p>最初，引入 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性是为了能让 Web 开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面上看到过。</p>
<p>但 Web 开发人员很快意识到，任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了。之前的 <a target="_blank" rel="noopener" href="https://css-tricks.com/snippets/css/drop-caps/">fancy paragraph example</a> 的课程展示了如何使用浮动创建一个有趣的 drop-cap（首字下沉）效果。</p>
<p>浮动曾被用来实现整个网站页面的布局，它使信息列得以横向排列（默认的设定则是按照这些列在源代码中出现的顺序纵向排列）。目前出现了更新更好的页面布局技术，所以使用浮动来进行页面布局应被看作<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">传统的布局方法</a>。</p>
<p>在这一章中，我们仅就浮动这一命令本身的性能展开讲解。</p>
<h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><p>让我们来探讨如何使用浮动。我们将从一个非常简单的例子开始，包括在图像周围浮动一个文本块。你可以在电脑上创建新的 <code>index.html</code> 文件，并以 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/html/introduction-to-html/getting-started/index.html">简单的 HTML 模板</a> 填充，在适当的地方插入以下代码。稍后你可以看到示例代码应该能呈现出的效果。</p>
<p>首先，我们写一些简单的 HTML——添加以下内容到 HTML 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a>内，删除之前<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a>里面的东西：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Simple float example<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>Float<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>现在将以下 CSS 应用到您的 HTML 中（使用 <code>&lt;style&gt;</code> 元素或 <code>&lt;link&gt;</code> 到单独的 .css 文件——由你选择）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">900px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">font</span>: .<span class="hljs-number">9em</span>/<span class="hljs-number">1.2</span> Arial, Helvetica, sans-serif;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你现在保存并刷新，你会看到和你预期的效果差不多——图片坐落在文本的上方，且保持正常布局流。</p>
<h4 id="使盒子浮动起来"><a href="#使盒子浮动起来" class="headerlink" title="使盒子浮动起来"></a>使盒子浮动起来</h4><p>为了使盒子浮动起来，向规则 <code>.box</code> 下添加 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a> 属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，如果您保存和刷新，你会看到类似下面的东西：</p>
<iframe class="sample-code-frame" title="使盒子浮动起来 sample" id="frame_使盒子浮动起来" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E4%BD%BF%E7%9B%92%E5%AD%90%E6%B5%AE%E5%8A%A8%E8%B5%B7%E6%9D%A5.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>让我们考虑一下浮动是如何工作的——浮动元素 (这个例子中的<code>&lt;div&gt;</code>元素) 会脱离正常的文档布局流，并吸附到其父容器的左边（这个例子中的<code>&lt;body&gt;</code>元素）。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</p>
<p>向右浮动的内容是一样的效果，只是反过来了——浮动元素会吸附到右边，而其他内容将从左侧环绕它。尝试将上一个例子中的浮动值改为 <code>right</code> ，再把 <code>margin-right</code> 换成 <code>margin-left</code> ，看看结果是什么。</p>
<h4 id="让浮动效果可视化"><a href="#让浮动效果可视化" class="headerlink" title="让浮动效果可视化"></a>让浮动效果可视化</h4><p>我们可以在浮动元素上应用 margin，将文字推开，但不能在文字上应用 margin 将浮动元素推走。这是因为浮动的元素脱离了正常文档流，紧随其后的元素排布在它的“后方”。你可以将示例代码进行更改，来观察到这个现象。</p>
<p>在紧随浮动盒子的第一段文字上添加 <code>special</code> 类，然后在你的 CSS 文件中添加如下规则，它会赋予跟随其后的段落一个背景色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了更清晰的看到效果，将浮动的 <code>margin-left</code> 改为 <code>margin</code> 以将周围全部空出来。如此代码效果所示，你可以看到段落的背景色处于浮动盒子之下。</p>
<iframe class="sample-code-frame" title="让浮动效果可视化 sample" id="frame_让浮动效果可视化" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E8%AE%A9%E6%B5%AE%E5%8A%A8%E6%95%88%E6%9E%9C%E5%8F%AF%E8%A7%86%E5%8C%96.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe>



<p>目标元素的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Visual_formatting_model#line_boxes">行内盒子</a>已被缩短，故文字会排布在浮动元素周围，但是浮动元素从正常文档流移出，故段落的盒子仍然保持全部宽度。</p>
<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>我们看到，一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也受到浮动元素的影响，我们需要 <em>停止</em> 它；这是通过添加 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 属性实现的。</p>
<p>在前例的 HTML 代码中，向浮动元素下方的第二个段落添加 <code>cleared</code> 类，然后向 CSS 文件中添加以下样式：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">.cleared &#123;<br>  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="清除浮动 sample" id="frame_清除浮动" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>应该看到，第二个段落已经停止了浮动，不会再跟随浮动元素排布了。<code>clear</code> 属性接受下列值：</p>
<ul>
<li><code>left</code>：停止任何活动的左浮动</li>
<li><code>right</code>：停止任何活动的右浮动</li>
<li><code>both</code>：停止任何活动的左右浮动</li>
</ul>
<h4 id="清除浮动元素周围的盒子"><a href="#清除浮动元素周围的盒子" class="headerlink" title="清除浮动元素周围的盒子"></a>清除浮动元素周围的盒子</h4><p>现在你知道了如何停止浮动元素其后元素的浮动行为。我们来看个例子，如果存在一个盒子 <em>同时</em> 包含了很高的浮动元素和一个很短的段落，会发生什么。</p>
<h4 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h4><p>改变你的文档结构，使得第一个段落与浮动的盒子共同处于类名为 <code>wrapper</code> 的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>div</code></a> 元素之下。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<span class="hljs-keyword">Float</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>  &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate.&lt;/p&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>在你的 CSS 代码中，为 <code>.wrapper</code> 类添加如下规则并重载页面：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>  background-color: rgb(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  padding: <span class="hljs-number">10</span>px;<br>  color: #fff;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此外，将原先的 <code>.cleared</code> 类移除：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">.cleared &#123;<br>  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你会看到，就像示例代码一样，如果将背景色属性置于段落上，那么这个背景色将处于浮动元素之下。</p>
<iframe class="sample-code-frame" title="问题所在 sample" id="frame_问题所在" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E9%97%AE%E9%A2%98%E6%89%80%E5%9C%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>再一次强调，这是因为浮动元素处于正常文档流之外，停止紧随其后元素的浮动并不像之前那样奏效。如果你想让盒子联合包住浮动的项目以及第一段文字，同时让紧随其后的内容从盒子中清除浮动，这就是一个问题。</p>
<p>有三种方法可以处理这个问题，其中的两种在所有浏览器中均可以奏效（虽然看上去有点“小技巧”），剩下的一种是可以处理问题的较新的解决方案。</p>
<h4 id="clearfix-小技巧"><a href="#clearfix-小技巧" class="headerlink" title="clearfix 小技巧"></a>clearfix 小技巧</h4><p>传统上，这个问题通常由所谓的 “clearfix 小技巧” 解决，其过程为：先向包含浮动内容及其本身的盒子后方插入一些生成的内容，并将生成的内容清除浮动。</p>
<p>向示例中添加以下 CSS 代码：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span>::<span class="hljs-keyword">after</span> &#123;<br>  content: &quot;&quot;;<br>  clear: <span class="hljs-keyword">both</span>;<br>  display: block;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在重载页面，盒子的浮动就应该清除了。这与在浮动盒子后手动添加诸如 <code>div</code> 的 HTML 元素，并设置其样式为 <code>clear:both</code> 是等效的。</p>
<iframe class="sample-code-frame" title="clearfix 小技巧 sample" id="frame_clearfix_小技巧" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.clearfix_%E5%B0%8F%E6%8A%80%E5%B7%A7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="使用-overflow"><a href="#使用-overflow" class="headerlink" title="使用 overflow"></a>使用 overflow</h4><p>一个替代的方案是将包裹元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 属性设置为除 <code>visible</code> 外的其他值。</p>
<p>移除上一节添加的 clearfix CSS 代码；在包裹元素上添加 <code>overflow: auto</code> 规则。现在，盒子应该再一次停止浮动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="使用 overflow sample" id="frame_使用_overflow" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E4%BD%BF%E7%94%A8_overflow.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>这个例子之所以能够生效，是因为创建了所谓的 <strong>块格式化上下文（BFC）</strong>。可以把它看作页面内部包含所需元素的一小块布局区域。如此设置可以让浮动元素包含在 BFC 及其背景之内。大部分情况下这种小技巧都可以奏效，但是可能会出现莫名其妙的滚动条或裁剪阴影，这是使用 overflow 带来的一些副作用。</p>
<h4 id="display-flow-root"><a href="#display-flow-root" class="headerlink" title="display: flow-root"></a>display: flow-root</h4><p>一个较为现代的方案是使用 <code>display</code> 属性的 <code>flow-root</code> 值。它可以无需小技巧来创建块格式化上下文（BFC），在使用上没有副作用。</p>
<p>从 <code>.wrapper</code> 中移除 <code>overflow: auto</code> 规则并添加 <code>display: flow-root</code>。如果你的浏览器支持该属性（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">支持的浏览器列表</a>），盒子就会停止浮动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">display</span>: flow-root;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="display flow-root sample" id="frame_display_flow-root" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.display_flow-root.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h3 id="2-17-定位"><a href="#2-17-定位" class="headerlink" title="2.17 定位"></a>2.17 定位</h3><p>定位允许你从正常的文档流布局中取出元素，并使它们具有不同的行为，例如放在另一个元素的上面，或者始终保持在浏览器视窗内的同一位置。本文解释的是定位 (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>) 的各种不同值，以及如何使用它们。</p>
<h4 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h4><p>定位是一个相当复杂的话题，所以我们深入了解代码之前，让我们审视一下布局理论，并让我们了解它的工作原理。</p>
<p>首先，围绕元素内容添加任何内边距、边界和外边距来布置单个元素盒子——这就是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型</a> ，我们前面看过。默认情况下，块级元素的内容宽度是其父元素的宽度的 100％，并且与其内容一样高。内联元素高宽与他们的内容高宽一样。你不能对内联元素设置宽度或高度——它们只是位于块级元素的内容中。如果要以这种方式控制内联元素的大小，则需要将其设置为类似块级元素 <code>display: block;</code>。</p>
<p>这只是解释了单个元素，但是元素相互之间如何交互呢？<strong>正常的布局流</strong>（在布局介绍文章中提到）是将元素放置在浏览器视口内的系统。默认情况下，块级元素在视口中垂直布局——每个都将显示在上一个元素下面的新行上，并且它们的外边距将分隔开它们。</p>
<p>内联元素表现不一样——它们不会出现在新行上；相反，它们互相之间以及任何相邻（或被包裹）的文本内容位于同一行上，只要在父块级元素的宽度内有空间可以这样做。如果没有空间，那么溢流的文本或元素将向下移动到新行。</p>
<p>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">外边距折叠</a>, 我们之前也遇到过。</p>
<h4 id="介绍-z-index"><a href="#介绍-z-index" class="headerlink" title="介绍 z-index"></a>介绍 z-index</h4><p>所有这些绝对定位很有趣，但还有另一件事我们还没有考虑到 ——当元素开始重叠，什么决定哪些元素出现在其他元素的顶部？在我们已经看到的示例中，我们在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。当我们有不止一个的时候呢？</p>
<p>尝试添加以下到你的 CSS，使第一段也是绝对定位：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">background</span>: lime;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，你将看到第一段的颜色为绿色，移出文档流程，并位于原始位置上方一点。它也堆叠在原始的 <code>.positioned</code> 段落下，其中两个重叠。这是因为 <code>.positioned</code> 段落是源顺序 (HTML 标记) 中的第二个段落，并且源顺序中后定位的元素将赢得先定位的元素。</p>
<p>你可以更改堆叠顺序吗？是的，你可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a>属性。 “z-index”是对 z 轴的参考。你可以从源代码中的上一点回想一下，我们使用水平（x 轴）和垂直（y 轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。 （0,0）位于页面（或元素）的左上角，x 和 y 轴跨页面向右和向下（适合从左到右的语言，无论如何）。</p>
<p>网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。</p>
<p>要更改堆叠顺序，请尝试将以下声明添加到 <code>p:nth-of-type(1)</code> 规则中：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>你现在应该可以看到完成的例子：</p>
<iframe class="sample-code-frame" title="介绍 z-index sample" id="frame_介绍_z-index" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Positioning/_sample_.%E4%BB%8B%E7%BB%8D_z-index.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>请注意，z-index 只接受无单位索引值；你不能指定你想要一个元素是 Z 轴上 23 像素—— 它不这样工作。较高的值将高于较低的值，这取决于你使用的值。使用 2 和 3 将产生与 300 和 40000 相同的效果。</p>
<p><strong>备注：</strong> 你可以在这里看到这个例子 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/css-layout/positioning/5_z-index.html"><code>5_z-index.html</code></a> (<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/css/css-layout/positioning/5_z-index.html">see source code</a>).</p>
<h3 id="2-18-多栏布局"><a href="#2-18-多栏布局" class="headerlink" title="2.18 多栏布局"></a>2.18 多栏布局</h3><p>多列布局声明提供了一种多列组织内容的方式，正如你在一些报纸中看到的那样。这篇文章介绍怎么使用这一特性。</p>
<h4 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h4><p>我们从一些很简单的 HTML 开始；用带有类 <code>container</code> 的简单包装，里面是标题和一些段落。</p>
<p>带有 .container 的 <div> 将成为我们 multicol 的容器。通过这两个属性开启 multicol column-count 或者 column-width (en-US)。 column-count 将创建指定数量的列，所以如果你把下面的 CSS 加到样式表里让后重载入页面，你将得到 3 列：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  column-<span class="hljs-keyword">count</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建的这些列具有弹性的宽度 — 由浏览器计算出每一列分配多少空间。</p>
<iframe class="sample-code-frame" title="三列布局 sample" id="frame_三列布局" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="设置列宽"><a href="#设置列宽" class="headerlink" title="设置列宽"></a>设置列宽</h4><p>像下面这样使用 <code>column-width</code> 更改 CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p>
<iframe class="sample-code-frame" title="设置列宽 sample" id="frame_设置列宽" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E8%AE%BE%E7%BD%AE%E5%88%97%E5%AE%BD.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="给多列增加样式"><a href="#给多列增加样式" class="headerlink" title="给多列增加样式"></a>给多列增加样式</h4><p>Multicol 创建的列无法单独的设定样式。不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。你有两个机会改变列的样式：</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 改变列间间隙。</li>
<li>用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule"><code>column-rule</code></a> 在列间加入一条分割线。</li>
</ul>
<p>以上面的代码为例，增加 <code>column-gap</code> 属性可以更改列间间隙。</p>
<p>你可以尝试不同的值 — 该属性接受任何长度单位。现在再加入 <code>column-rule</code>。和你之前遇到的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 属性类似， <code>column-rule</code> 是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-color"><code>column-rule-color</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-style"><code>column-rule-style</code></a>的缩写，接受同 <code>border</code> 一样的单位。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">column-rule</span>: <span class="hljs-number">4px</span> dotted <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>尝试设置不同的样式和颜色。</p>
<iframe class="sample-code-frame" title="给多列增加样式 sample" id="frame_给多列增加样式" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E7%BB%99%E5%A4%9A%E5%88%97%E5%A2%9E%E5%8A%A0%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>值得一提的是这条分割线本身并不占用宽度。它置于用 <code>column-gap</code> 创建的间隙内。如果需要更多空间，你需要增加 <code>column-gap</code> 的值。</p>
<h4 id="列与内容折断"><a href="#列与内容折断" class="headerlink" title="列与内容折断"></a>列与内容折断</h4><p>多列布局的内容被拆成碎块。和多页媒体上的内容表现大致一样 — 比如打印网页的时候。当你把内容放入多列布局容器内，内容被拆成碎块放进列中，内容折断（译者注：比如断词断句）使得这一效果可以实现。</p>
<p>有时，这种折断内容会降低阅读体验。在下面的举例中，我用 multicol 对一系列盒子布局，每一小块里有小标题和和一些文字。标题和文字可能被折断点拆开，从而降低阅读体验。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">250px</span>;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="列与内容折断 sample" id="frame_列与内容折断" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E5%88%97%E4%B8%8E%E5%86%85%E5%AE%B9%E6%8A%98%E6%96%AD.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="设置-break-inside"><a href="#设置-break-inside" class="headerlink" title="设置 break-inside"></a>设置 break-inside</h4><p>我们可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Fragmentation">CSS Fragmentation</a> 中声明的属性控制这一特性。这份规范提供了一些属性来控制 multicol 和多页媒体中的内容拆分、折断。比如，在规则 <code>.card</code> 上添加属性<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/break-inside"><code>break-inside</code></a>，并设值 <code>avoid</code> 。<code>.card</code> 是标题和文本的容器，我们不想拆开这个盒子。</p>
<p>现阶段，增加旧属性 <code>page-break-inside: avoid</code> 能够获得更好的浏览器支持。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">break-inside</span>: avoid;<br>  <span class="hljs-attribute">page-break-inside</span>: avoid;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>刷新页面，你的盒子就会呆在一起了。</p>
<iframe class="sample-code-frame" title="设置 break-inside sample" id="frame_设置_break-inside" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E8%AE%BE%E7%BD%AE_break-inside.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h3 id="2-19-响应式设计"><a href="#2-19-响应式设计" class="headerlink" title="2.19 响应式设计"></a>2.19 响应式设计</h3><p>早年设计 Web 时，页面是以适配特定的屏幕大小为考量创建的。如果用户正在使用比设计者考虑到的更小或者更大的屏幕，那么结果从多余的滚动条，到过长的行和没有被合理利用的空间，不一而足。随着人们使用的屏幕尺寸的种类越来越多，出现了响应式网页设计的概念（<em>responsive web design，RWD</em>），RWD 指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。这是改变我们设计多设备网页的方式的思想，在这篇文章里，我们将会帮你理解掌握它时所需知道的主要技能。</p>
<p>随着移动 Web 在早期的功能手机上开始成为现实，希望拥抱移动端的公司普遍希望为他们的网站创建一个有着不同的网址的移动版本（大多是像<em>m.example.com</em>或者<em>example.mobi</em>这类）。这意味着一个网站需要开发两个分开的版本，而且要保持时效性。</p>
<p>除此以外，这些移动网站的体验经常缩水。由于移动设备变得更加强大，足以显示完整的网站，对于那些被困在移动版网站的移动端用户来说，这是很折磨人的，他们因此也没法获取他们知道在支持所有功能的桌面版网站上能找到的信息。</p>
<h4 id="响应式设计之前的灵活布局"><a href="#响应式设计之前的灵活布局" class="headerlink" title="响应式设计之前的灵活布局"></a>响应式设计之前的灵活布局</h4><p>人们开发了许多方式，尽力解决建设网站时使用液态和固定宽度的方式所带来的弊端。2004 年，Cameron Adams 写了一篇题为《<a target="_blank" rel="noopener" href="https://www.themaninblue.com/writing/perspective/2004/09/21/">Resolution dependent layout</a>》的帖子，描述了一种可以创造适应多种屏幕分辨率的设计的方式。这种方式需要 JavaScript 来探测屏幕的分辨率，载入恰当的 CSS。</p>
<p>Zoe Mickley Gillenwater 深刻影响了<a target="_blank" rel="noopener" href="http://zomigi.com/blog/voices-that-matter-slides-available/">她的著作</a>，在里面描述并标准化了可变站点建立的不同方式，试图在充满屏幕和完全保持固定尺寸之间找到最佳平衡。</p>
<h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><p>“响应式设计”这个词是<a target="_blank" rel="noopener" href="https://alistapart.com/article/responsive-web-design/">Ethan Marcotte 在 2010 年首度提出的</a>，他将其描述为三种技术的混合使用。</p>
<ol>
<li>第一个是液态网格，这早先已由 Gillenwater 进行探讨，可以在 Marcotte 的文章《<a target="_blank" rel="noopener" href="https://alistapart.com/article/fluidgrids/">Fluid Grids</a>》（出版于 2009 年的《A List Apart》上）中读到。</li>
<li>第二个是<a target="_blank" rel="noopener" href="https://unstoppablerobotninja.com/entry/fluid-images">液态图像</a>的理念。通过使用相当简单的将设置<code>max-width</code>属性设置为<code>100%</code>的技术，图像可以在包含它们的列变得比图像原始尺寸窄的时候，缩放得更小，但总不会变得更大。这使得图像可以被缩放，以被放到一个灵活尺寸的列，而不是溢出出去，同时也不会在列宽于图像的时候，使图像变得太大以至于画质变得粗糙。</li>
<li>第三个关键的组件是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries">媒体查询</a>。媒体查询使以往 Cameron Adams 探讨过的、由 JavaScript 实现的布局类型切换，可以只使用 CSS 实现。和所有尺寸的屏幕都使用一种布局不同的是，布局是可以改变的：侧栏可以在小屏幕上重新布局，而替代用的导航栏也可以显示出来。</li>
</ol>
<p>需要你理解的很重要的一点是<strong>响应式 Web 设计不是单独的技术</strong>，它是描述 Web 设计的一种方式、或者是一组最佳实践的一个词，它是用来建立可以<strong>响应</strong>查看内容的设备的样式的一个词。在 Marcotte’s 原来的探索中，这意味着灵活网格（使用 float）和媒体查询，但是在这篇文章写就的几乎十年以后，Web 的响应式工作已经成为了默认做法。现代的 CSS 布局方式基本上就是响应式的，而且我们在 Web 平台上内置了新的东西，使得设计响应式站点变得容易。</p>
<p>这篇文章的余下部分会为你指出，在建立响应式站点的时候，你可能会用到的各式 Web 平台的特色功能。</p>
<h4 id="媒介查询"><a href="#媒介查询" class="headerlink" title="媒介查询"></a>媒介查询</h4><p>响应式设计仅仅是因为媒介查询才新兴起来的。媒介查询第三级规范已经在 2009 年成为了候选推荐，这意味着它可视为准备好在浏览器中开始支持了。媒介查询允许我们运行一系列测试，例如用户的屏幕是否大于某个宽度或者某个分辨率，并将 CSS 选择性地适应用户的需要应用在样式化页面上。</p>
<p>例如，下面的媒体查询进行测试，以知晓当前的 Web 页面是否被展示为屏幕媒体（也就是说不是印刷文档），且视口至少有 800 像素宽。用于<code>.container</code>选择器的 CSS 将只会在这两件前提存在的情况下应用。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">1em</span> <span class="hljs-number">2em</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你可以在一张样式表上加入多条媒体查询，调整整个页面或者部分页面以达到适应各式屏幕尺寸的最佳效果。媒体查询，以及样式改变时的点，被叫做<em>断点</em>（breakpoints）。</p>
<p>使用媒体查询时的一种通用方式是，为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局。这经常被描述为<strong>移动优先</strong>设计。</p>
<p>在 MDN 文档中的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries">媒体查询</a>中了解更多</p>
<h4 id="灵活网格"><a href="#灵活网格" class="headerlink" title="灵活网格"></a>灵活网格</h4><p>响应式站点不只是在断点之间改变它们的布局，它们是建立在灵活网格上的。一个灵活网格意味着你不需要适配每个可能使用的设备尺寸，然后为其建立一个精确到像素级的适配布局。那种方式在现存有如此多种不同大小设备的前提下是不可能实现的，比如至少在台式机上，人们并不总是让他们的浏览器窗口最大化的。</p>
<p>使用灵活网格，你只需要加进去一个断点，在内容看起来不齐整的时候改变设计。例如如果一行随着屏幕大小增加而增长得不可读的长，或者是一个盒子在变窄时把每行的两个单词挤到一起。</p>
<p>早年间进行响应式设计的时候，我们唯一的实现布局的选项是使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">float</a>。灵活浮动布局是这样实现的，让每个元素都有一个作为宽度的百分数，而且确保整个布局的和不会超过 100%。在他对于液态网格文章的原文中，Marcotte 详细描述了一种布局的法则，通过使用像素并把布局转化为百分数的方式设计。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">target / context <span class="hljs-operator">=</span> result<br></code></pre></td></tr></table></figure>

<p>例如如果我们的预期栏尺寸为 60 像素，而且它所在的上下文（或者容器）为 960 像素，我们在将零点二的空间移动到右边以后，用 960 去除 60，得到我们能够使用在我们的 CSS 上的值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.col</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6.25%</span>; <span class="hljs-comment">/* 60 / 960 = 0.0625 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方式将会在今天整个 Web 上的许多地方上看到，而且它被我们的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">Legacy layout methods</a>一文中的布局一节中记载。可能你将会在工作中遇到使用这种方式的站点，所以有必要理解它，即使是在你不用建立一个使用浮动基础的灵活网格的情况下。</p>
<h4 id="现代布局技术"><a href="#现代布局技术" class="headerlink" title="现代布局技术"></a>现代布局技术</h4><p>现代布局方式，例如<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout">多栏布局</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">伸缩盒</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">网格</a>默认是响应式的。它们都假设你在尽力创建一个可伸缩网格，而且给了你更容易这样做的方式。</p>
<h4 id="多个列"><a href="#多个列" class="headerlink" title="多个列"></a>多个列</h4><p>这些布局方式中最老的一个是多个列，即当你指定一个<code>column-count</code>的时候，这意指你希望把你的内容分成多少列。浏览器之后会算出这些列的大小，这是一个随着屏幕尺寸变化的尺寸。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  column-<span class="hljs-keyword">count</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你却去指定<code>column-width</code>的话，你是在指定一个<em>最小</em>宽度。浏览器会尽可能多数量地创建这一宽度的列，只要它们可以恰当地放进容器里面，然后将所有列之间的剩余空间共享出去。因而列的数量会随着空间的多少而改变。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">10em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="伸缩盒"><a href="#伸缩盒" class="headerlink" title="伸缩盒"></a>伸缩盒</h4><p>在伸缩盒中，初始的行为是，弹性的物件将参照容器里面的空间的大小，缩小和分布物件之间的空间。通过更改<code>flex-grow</code>和 <code>flex-shrink</code>的值，你可以指示在物件遇到周围有更多或者更少的空间的情况下，你所期望的物件表现。</p>
<p>在下面的示例中，和布局专题的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox#flexible_sizing_of_flex_items">Flexbox: Flexible sizing of flex items</a>中所描述的那样，使用了<code>flex: 1</code>的简写，可伸缩物件每个将会占据一份可伸缩容器中相等大小的空间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 作为一个示例，我们已经重构了上面的简单响应式布局，这次我们用了伸缩盒。你可以看看我们是怎么样才不再需要使用奇怪的百分数值来计算列的尺寸的：<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/rwd/flex-based-rwd.html">示例</a>、<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/rwd/flex-based-rwd.html">源代码</a>。</p>
<h4 id="CSS-网格"><a href="#CSS-网格" class="headerlink" title="CSS 网格"></a>CSS 网格</h4><p>在 CSS 网格布局中，<code>fr</code>单位许可了跨网格轨道可用空间的分布。下面的示例创建了一个有着 3 个大小为<code>1fr</code>的轨道的网格容器。这会创建三个列轨道，每个占据了容器中可用空间的一部分。你可以在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids#flexible_grids_with_the_fr_unit">Flexible grids with the fr unit</a>下的学习布局网格专题了解更多和这一方式相关的信息。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 网格布局版本的代码要更简单，因为我们可以在.wrapper 上定义列<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/rwd/grid-based-rwd.html">：示例</a>，<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/rwd/grid-based-rwd.html">源代码</a>。</p>
<h4 id="响应式图像"><a href="#响应式图像" class="headerlink" title="响应式图像"></a>响应式图像</h4><p>最简单的处理响应式图像的方式是在 Marcotte 的早年的关于响应式设计的文章上所描述的那样。基本来说，你可以用一张有着所需最大尺寸的图像。然后缩放它。这仍然是今日所使用的一种方式，而且在大多数样式表里面，你在某些地方可以找到下面的 CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方式有显然的弊端。图像有可能会显示得比它的原始尺寸小很多，以至于浪费带宽——一个移动端用户会下载几倍于他们在浏览器窗口中实际看到的大小的图像。此外，你可能不想在移动端和桌面端有相同的图像宽高比例。例如，在移动端，方形图像的表现会很好，但是在桌面端显示同样的内容则应用宽图像。或者，认识到移动端更小尺寸的图像的你也许会希望同时展示一张不同的图像，一张在小一点的屏幕上更容易理解的图像。这些东西不能简单通过缩放图像解决。</p>
<p>响应式图像，使用了<code>&lt;picture&gt;</code>元素和<code>&lt;img&gt; </code>srcset和sizes 特性，解决了这两个问题。你可以提供附带着“提示”（描述图像最适合的屏幕尺寸和分辨率的元数据）的多种尺寸，浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。</p>
<p>你也可以给用于不同尺寸的图像做“艺术指导”，为不同的屏幕尺寸提供不同的图像裁切或者完全不同的图像。</p>
<p>你可以在 MDN 这里的学习 HTML 一节中找到详细的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图像指南</a>。</p>
<h4 id="响应式排版"><a href="#响应式排版" class="headerlink" title="响应式排版"></a>响应式排版</h4><p>在早期的工作没有考虑的一个响应式设计的元素是响应式排版的理念。本质上讲，这描述了根据屏幕真实使用范围的多少，在媒体查询的同时改变字体大小。</p>
<p>在本例子中，我们想讲我们的一级标题设置为<code>4rem</code>，也就是说它将会有我们的基础字体的四倍大。这真的是个很大的标题！我们只想在大些的屏幕上有这么个超大的标题，那我们先弄个小点的标题，再使用媒体查询，在我们知道用户使用至少<code>1200px</code>的屏幕的时候，拿大些的尺寸覆写它。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>  <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们已经编辑了我们在上面的响应式网格示例，让它同时包含了使用了圈出方式的响应式类型。你也可以看下随着布局变为两栏，标题是怎样转换大小的。</p>
<p>移动端，标题变小了：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design/mdn-rwd-font-mobile.png" srcset="/blog/img/loading.gif" lazyload alt="A stacked layout with a small heading size."></p>
<p>但在桌面端，我们看到了大点的标题：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design/mdn-rwd-font-desktop.png" srcset="/blog/img/loading.gif" lazyload alt="A two column layout with a large heading."></p>
<p><strong>备注：</strong> 查看这个编排好的示例：<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/rwd/type-rwd.html">示例</a>，<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/rwd/type-rwd.html">源代码</a>。</p>
<p>正如这种排版方式展示的这样，你不需要让媒介查询只能改变页面的布局。它们也能用来调节每个元素，让它们在别的大小的屏幕上更加可用或者更具吸引力。</p>
<h4 id="使用视口单位实现响应式排版"><a href="#使用视口单位实现响应式排版" class="headerlink" title="使用视口单位实现响应式排版"></a>使用视口单位实现响应式排版</h4><p>一个有趣的方式是使用视口单位<code>vw</code>来实现响应式排版。<code>1vw</code>等同于视口宽度的百分之一，即如果你用<code>vw</code>来设定字体大小的话，字体的大小将总是随视口的大小进行改变。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6vw</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题在于，当做上面的事情的时候，因为文本总是随着视口的大小改变大小，用户失去了放缩任何使用<code>vw</code>单位的文本的能力。<strong>所以你永远都不要只用 viewport 单位设定文本。</strong></p>
<p>这里有一个解决方法，它使用了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc"><code>calc()</code></a>，如果你将<code>vw</code>单位加到了使用固定大小（例如<code>em</code>或者<code>rem</code>）的值组，那么文本仍然是可放缩的。基本来说，是<code>vw</code>加在了放缩后的值上。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">1.5rem</span> + <span class="hljs-number">3vw</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是说，我们只需要指定标题的字体大小一次，而不是为移动端设定它，然后再在媒介查询中重新定义它。字体会在你增加视口大小的时候逐渐增大。</p>
<p><strong>备注：</strong> 查看这种情况的一个编排好的示例： <a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/rwd/type-vw.html">示例</a>，<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/rwd/type-vw.html">源代码</a>。</p>
<h4 id="视口元标签"><a href="#视口元标签" class="headerlink" title="视口元标签"></a>视口元标签</h4><p>如果你看看一张响应式页面的 HTML 源代码，你通常将会在文档的<code>&lt;head&gt;</code>看到下面的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">&#96;&#96;</a>标签。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的 100%，在移动端以你所希望的为移动优化的大小展示文档。</p>
<p>为何需要这个？因为移动端浏览器倾向于在它们的视口宽度上说谎。</p>
<p>这个元标签的存在，是由于原来 iPhone 发布以后，人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为 960 像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本。其他的移动端浏览器（例如谷歌安卓上的）也是这么做的。用户可以在站点中放大、移动，查看他们感兴趣的那部分，但是这看起来很不舒服。如果你不幸遇到了一个没有响应式设计的网站，今天你还会看到这种情况。</p>
<p>麻烦的是，你的带断点和媒介查询的响应式设计不会在移动端浏览器上像预期那样工作。如果你有个窄屏布局，在 480 像素及以下的视口宽度下生效，但是视口是按 960 像素设定的，你将不会在移动端看到你的窄屏布局。通过设定<code>width=device-width</code>，你用设备的实际宽度覆写了苹果默认的<code>width=960px</code>，然后你的媒介查询就会像预期那样生效。</p>
<p><strong>所以你应该在你的文档头部*总是*包含上面那行 HTML。</strong></p>
<p>和视口元标签一起，你可以使用另外几个设定，但大体说来，上面那行就是你想要使用的。</p>
<ul>
<li><code>initial-scale</code>：设定了页面的初始缩放，我们设定为 1。</li>
<li><code>height</code>：特别为视口设定一个高度。</li>
<li><code>minimum-scale</code>：设定最小缩放级别。</li>
<li><code>maximum-scale</code>：设定最大缩放级别。</li>
<li><code>user-scalable</code>：如果设为<code>no</code>的话阻止缩放。</li>
</ul>
<p>你应该避免使用<code>minimum-scale</code>、<code>maximum-scale</code>，尤其是将<code>user-scalable</code>设为<code>no</code>。用户应该有权力尽可能大或小地进行缩放，阻止这种做法会引起访问性问题。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>响应式设计指的是一个响应浏览环境的网页或者应用设计。它涵盖了很多 CSS 和 HTML 的功能和技术，现在基本上就是我们默认建设网站的方式。想一下你在手机上访问的网站，遇到一个缩放的桌面版网站，或者你需要向侧边滚动来寻找东西的网站可能是相当不寻常的。这是因为 Web 已经迁移到了这种响应式设计的方式上。</p>
<p>在这些课里学到的布局方式的帮助下，实现响应式设计也变得愈加简单。如果你今天新近了解 Web 开发，那么你与响应式设计早期相比，手边有多得多的工具。因而，你有必要检查下你所引用的任何材料的年纪。尽管历史上的文章仍然有用，现代的 CSS 和 HTML 的使用让创建一个优雅且实用的设计变得远远更加容易，且无论你的访客使用什么设备浏览网站。</p>
<h3 id="2-20-媒体查询入门指南"><a href="#2-20-媒体查询入门指南" class="headerlink" title="2.20 媒体查询入门指南"></a>2.20 媒体查询入门指南</h3><p>最简单的媒体查询语法看起来是像这样的：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">@media media-<span class="hljs-keyword">type</span> and (media-feature-rule) &#123;<br>  /* <span class="hljs-type">CSS</span> rules go here */<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Copy to Clipboard</p>
<p>它由以下部分组成：</p>
<ul>
<li>一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；</li>
<li>一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试；</li>
<li>一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。</li>
</ul>
<h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><p>你可以指定的媒体类型为：</p>
<ul>
<li><code>all</code></li>
<li><code>print</code></li>
<li><code>screen</code></li>
<li><code>speech</code></li>
</ul>
<p>下面的媒体查询将会在页面被打印的时候把 body 设定为只有 12pt 大小。当页面在浏览器中载入的时候，它将不会生效。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> print &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12pt</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>备注：</strong>这里的媒体类型是和所谓的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type">MIME type</a>不同的东西。</p>
</blockquote>
<p><strong>备注：</strong> 在第三级媒体查询规范中，定义了其他一些媒体类型，它们已经不被建议使用，而且应该被避免使用。</p>
<blockquote>
<p><strong>备注：</strong>媒体类型是可选的，如果你没有在媒体查询中指示一个媒体类型的话，那么媒体查询默认会设为用于全部媒体类型。</p>
</blockquote>
<h4 id="媒体特征规则"><a href="#媒体特征规则" class="headerlink" title="媒体特征规则"></a>媒体特征规则</h4><p>在指定了类型以后，你可以用一条规则指向一种媒体特征。</p>
<h4 id="宽和高"><a href="#宽和高" class="headerlink" title="宽和高"></a>宽和高</h4><p>为了建立响应式设计（已经广受浏览器支持），我们一般最常探测的特征是视口宽度，而且我们可以使用<code>min-width</code>、<code>max-width</code>和<code>width</code>媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用 CSS。</p>
<p>这些特征是用来创建响应不同屏幕大小的布局的。例如，要想在视口正好是 600 像素的时候，让 body 的文本变为红色，你可能会使用下面的媒体查询。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/width.html">打开这个示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/width.html">查看源代码</a>。</p>
<p><code>width</code>（和<code>height</code>）媒体特征可以以数值范围使用，于是就有了<code>min-</code>或者<code>max-</code>的前缀，指示所给的值是最小值还是最大值。例如，要让颜色在视口窄于 400 像素的时候变成蓝色的话，可以用<code>max-width</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">400px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/max-width.html">打开示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/max-width.html">查看源代码</a>。</p>
<p>实践中，使用最小值和最大值对响应式设计有很多的用处，所以你会很少见到<code>width</code>或<code>height</code> 单独使用的情况。</p>
<p>还有许多其他媒体特征可以供你测试，尽管于 4 级和 5 级媒体查询规范中引入了一些新特征，它们受浏览器支持仍然有限。在 MDN 上，每个特征都已经同浏览器支持信息一同记载下来，你可以在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries#media_features">使用媒体查询：媒体特征</a>中找到一张完整的列表。</p>
<h4 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h4><p>一个受到良好支持的媒体特征是<code>orientation</code>，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变 body 文本颜色的话，可使用下面的媒体查询。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/orientation.html">打开此示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/orientation.html">查看源代码</a>。</p>
<p>标准的桌面视图是横放朝向的，在这种朝向上能够表现良好的设计，在处于竖放模式的手机或平板电脑上可能不会表现得这么好。对朝向的测试可以帮你建立一个为竖放设备优化的布局。</p>
<h4 id="使用指点设备"><a href="#使用指点设备" class="headerlink" title="使用指点设备"></a>使用指点设备</h4><p>作为四级规范的一部分，<code>hover</code>媒体特征被引入了进来。这种特征意味着你可以测试用户是否能在一个元素上悬浮，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">hover</span>: <span class="hljs-attribute">hover</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/hover.html">打开此示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/hover.html">查看源代码</a>。</p>
<p>如果我们知道用户不能悬浮的话，我们可以默认显示一些交互功能。对于能够悬浮的用户，我们可以选择在悬浮在链接上的时候，让这些功能可用。</p>
<p>还是在四级规范中，出现了<code>pointer</code>媒体特征。它可取三个值：<code>none</code>、<code>fine</code>和<code>coarse</code>。<code>fine</code>指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。<code>coarse</code>指针是你在触摸屏上的手指。<code>none</code>值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。</p>
<p>使用<code>pointer</code>可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。</p>
<h4 id="更复杂的媒体查询"><a href="#更复杂的媒体查询" class="headerlink" title="更复杂的媒体查询"></a>更复杂的媒体查询</h4><p>有了所有不同的可用的媒体查询，你可能想要把它们混合起来，或者建立查询列表——其中的任何一个都可以匹配生效。</p>
<h4 id="媒体查询中的“与”逻辑"><a href="#媒体查询中的“与”逻辑" class="headerlink" title="媒体查询中的“与”逻辑"></a>媒体查询中的“与”逻辑</h4><p>为了混合媒体特征，你可以以与在上面使用<code>and</code>很相同的方式，用<code>and</code>来混合媒体类型和特征。例如，我们可能会想要测得<code>min-width</code>和<code>orientation</code>，而 body 的文字只会在视口至少为 400 像素宽，且设备横放时变为蓝色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/and.html">打开此示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/and.html">查看源代码</a>。</p>
<h4 id="媒体查询中的“或”逻辑"><a href="#媒体查询中的“或”逻辑" class="headerlink" title="媒体查询中的“或”逻辑"></a>媒体查询中的“或”逻辑</h4><p>如果你有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。在下面的示例中，文本会在视口至少为 400 像素宽的时候<strong>或者</strong>设备处于横放状态的时候变为蓝色。如果其中的任何一项成立，那么查询就匹配上了。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@media <span class="hljs-keyword">screen </span><span class="hljs-keyword">and </span>(min-width: <span class="hljs-number">400</span>px), <span class="hljs-keyword">screen </span><span class="hljs-keyword">and </span>(<span class="hljs-keyword">orientation: </span>landscape) &#123;<br>    <span class="hljs-keyword">body </span>&#123;<br><span class="hljs-symbol">        color:</span> <span class="hljs-keyword">blue;</span><br><span class="hljs-keyword"></span>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/or.html">打开此示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/or.html">查看源代码</a>。</p>
<h4 id="媒体查询中的“非”逻辑"><a href="#媒体查询中的“非”逻辑" class="headerlink" title="媒体查询中的“非”逻辑"></a>媒体查询中的“非”逻辑</h4><p>你可以用<code>not</code>操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/not.html">打开此示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/not.html">查看源代码</a>。</p>
<h4 id="怎么选择断点"><a href="#怎么选择断点" class="headerlink" title="怎么选择断点"></a>怎么选择断点</h4><p>响应式设计的早期，许多设计者会尝试指向非常特定的屏幕尺寸。人们公布了流行的手机和平板的屏幕尺寸列表，以让设计者创建可以整齐地放在那些视口里面的设计。</p>
<p>现在有多得多的设备，以及多种多样的尺寸，让这种事变得不再可行。这也就是说，将所有的设计用在特定的尺寸上以外，一个更好的方法是在内容某种程度上开始变得混乱的时候，改变尺寸的设计。也许线太长了，或者盒子状的外侧栏开始挤在一起而难以阅读。那就是你想要使用媒体查询，将设计变得对剩余可用空间更加友好的时候。这种方式意味着，它无关使用的设备的确切大小，每个范围都被照顾到了。引入媒体查询的点就叫做<strong>断点</strong>。</p>
<p>火狐开发者工具中的<a target="_blank" rel="noopener" href="https://firefox-source-docs.mozilla.org/devtools-user/responsive_design_mode/index.html">响应式设计模式</a>能很好地帮助弄清楚断点应该设置在哪里。你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Media_queries/rwd-mode.png" srcset="/blog/img/loading.gif" lazyload alt="A screenshot of a layout in a mobile view in Firefox DevTools."></p>
<h4 id="主动学习：移动优先的响应式设计"><a href="#主动学习：移动优先的响应式设计" class="headerlink" title="主动学习：移动优先的响应式设计"></a>主动学习：移动优先的响应式设计</h4><p>泛泛地说，你可以采用两种方式实现响应式设计。你可以从桌面或者最宽的视图开始，然后随着视口变得越来越小，加上断点，把物件挪开；你也可以从最小的视图开始，随着视口变得越来越大，增添布局内容。第二种方式被叫做<strong>移动优先</strong>的响应式设计，很多时候是最值得仿效的做法。</p>
<p>用在最小的那个设备上的视图很多时候都是一个简单的单列内容，很像正常文本流显示的那样。这意味着，你很可能不需要为小设备做多少布局设计，合适地安排下你的源代码，默认情况下你就可以得到可读的布局。</p>
<p>下面的教程会领你用一个非常简单的布局熟悉这种方式。在生产站点上，你的媒体查询中可能会有更多的东西需要调整，但是它们的方法是完全一样的。</p>
<h4 id="教程：一个简单的移动优先布局"><a href="#教程：一个简单的移动优先布局" class="headerlink" title="教程：一个简单的移动优先布局"></a>教程：一个简单的移动优先布局</h4><p>我们的起始点是一个 HTML 文档，上面应用了一些 CSS，为布局的各部分加入了背景颜色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2em</span> auto;<br>    <span class="hljs-attribute">font</span>: <span class="hljs-number">1em</span>/<span class="hljs-number">1.3</span> Arial, Helvetica, sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span>,<br><span class="hljs-selector-tag">aside</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.2</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.7</span>);<br>&#125;<br><br><span class="hljs-selector-class">.related</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>, <span class="hljs-number">0.3</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们没有改变过任何布局，但是文件的源代码是以让内容可读的方式排列的。这个开头是重要的，也是能够确保内容在由屏幕阅读器读出来的时候，让其可以理解的一步。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Meet the team<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Blog<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Veggies!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;related&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sidebar&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>External vegetable-based links<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span>2019<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这个简单的布局在移动端上也能表现得很好。如果我们在开发者工具中的响应式设计模式里面查看这个布局的话，我们可以看到，它作为一个直截了当的站点移动版布局来说，表现得相当优秀。</p>
<p>在浏览器里<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/step1.html">打开步骤一</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step1.html">查看源代码</a>。</p>
<p><strong>如果你想要在我们继续的时候，按步骤来并尝试这个示例，在你的电脑上建立一个<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step1.html">step1.html</a>的本地副本。</strong></p>
<p>从这里开始，脱拽响应式设计的窗口，让它变得变得更宽，直到你看到一行变得非常长，有足够空间把导航栏放在一个水平行里面。这是我们加入第一个媒体查询的地方。我们将会使用 em，因为这意味着，如果用户已经增加了文本的大小，断点会在行差不多也是这样长，但是视口更宽的时候产生；而文本更小的时候，视口也会更窄。</p>
<p><strong>将下面的代码加到你的 step1.html 的 CSS 底部。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">40em</span>) &#123;<br>    <span class="hljs-selector-tag">article</span> &#123;<br>        <span class="hljs-attribute">display</span>: grid;<br>        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">3</span>fr <span class="hljs-number">1</span>fr;<br>        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> &#123;<br>        <span class="hljs-attribute">display</span>: flex;<br>    &#125;<br><br>    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">li</span> &#123;<br>        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 CSS 让我们的文章里面有了个两列布局，两栏分别是文章的内容和在 aside 元素中相关的信息。我们也已经用弹性盒把导航栏放在了一行里面。</p>
<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/step2.html">打开步骤二</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step2.html">查看源代码</a>。</p>
<p>让我们继续增加宽度，直到我们觉得这里有了足够多的空间来放置侧栏，再形成一列。在媒体查询中，我们会让 main 元素变成两栏网格。我们之后需要移除文章上的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a>，让两个侧栏和彼此对齐，然后我们将会往页脚的顶部加上一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 。一般来说，为了让设计看起来好看，这些小调整是你将会在每一个断点都需要做的。</p>
<p><strong>再往你的 step1.html 的 CSS 的底部加入下面的代码：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">70em</span>) &#123;<br>    <span class="hljs-selector-tag">main</span> &#123;<br>        <span class="hljs-attribute">display</span>: grid;<br>        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">3</span>fr <span class="hljs-number">1</span>fr;<br>        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">article</span> &#123;<br>        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">footer</span> &#123;<br>        <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">2em</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/step3.html">打开步骤三</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step3.html">查看源代码</a>。</p>
<p>如果你在不同的宽度下，看下最后的示例，你会看到设计是如何响应的，在可用的宽度下是如何表现为单栏、双栏或者三栏的。这是一个移动优先的响应式设计的非常简单的示例。</p>
<h4 id="你真的需要媒体查询吗？"><a href="#你真的需要媒体查询吗？" class="headerlink" title="你真的需要媒体查询吗？"></a>你真的需要媒体查询吗？</h4><p>弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。这些布局方式能否在不加入媒体查询的时候实现你想要的设计，总是值得考虑的一件事。例如，你可能想要一组卡片，至少为二百像素宽，并在主文章里尽可能多地放下这些二百像素的卡片。这可以用网格布局实现，而完全不使用媒体查询。</p>
<p>这可以由以下代码实现：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 3<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 4<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 5<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>&#125;<br><br><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器中<a target="_blank" rel="noopener" href="https://mdn.github.io/css-examples/learn/media-queries/grid.html">打开网格布局示例</a>，或者<a target="_blank" rel="noopener" href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/grid.html">查看源代码</a>。</p>
<p>在你的浏览器里打开这个示例，让屏幕变宽变窄，看一看列轨数目的变化。这个方法里面的好事是，网格不是靠视口宽度判断的，而是可以容纳组件的宽度。对媒体查询这章节的建议就是，你可能根本不需要它！但是，实践中你会发现，由媒体查询改进的现代布局方式的恰当使用，将会产生最佳效果。</p>
<h2 id="3-javascript"><a href="#3-javascript" class="headerlink" title="3 javascript"></a>3 javascript</h2><blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
</ol>
</blockquote>
<h3 id="3-1-javascript第一步"><a href="#3-1-javascript第一步" class="headerlink" title="3.1 javascript第一步"></a>3.1 javascript第一步</h3><p>JavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是实时的内容更新，交互式的地图，2D&#x2F;3D 动画，滚动播放的视频等等。JavaScript 怎能缺席。它是标准 Web 技术蛋糕的第三层，其中 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML">HTML</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS">CSS</a> 我们已经在学习中心的其他部分进行了详细的讲解。</p>
<p>示例：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>para.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, updateName);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入一个新的名字：&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;玩家 1：&#x27;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>JavaScript 语言核心之上所构建的功能更令人兴奋。<strong>应用程序接口（Application Programming Interfaces</strong>（<strong>API</strong>））将为你的代码提供额外的超能力。</p>
<p>API 通常分为两类。</p>
<p><strong>浏览器 API</strong> 内建于 web 浏览器中，它们可以将数据从周边计算机环境中筛选出来，还可以做实用的复杂工作。例如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model"><code>文档对象模型 API（DOM（Document Object Model）API）</code></a> 能通过创建、移除和修改 HTML，为页面动态应用新样式等手段来操作 HTML 和 CSS。比如当某个页面出现了一个弹窗，或者显示了一些新内容（像上文小 demo 中看到那样），这就是 DOM 在运行。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation"><code>地理位置 API（Geolocation API）</code></a> 获取地理信息。这就是为什么 <a target="_blank" rel="noopener" href="https://www.google.cn/maps">谷歌地图</a> 可以找到你的位置，而且标示在地图上。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API"><code>画布（Canvas）</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API"><code>WebGL</code></a> API 可以创建生动的 2D 和 3D 图像。人们正运用这些 web 技术制作令人惊叹的作品。参见 <a target="_blank" rel="noopener" href="https://www.chromeexperiments.com/webgl">Chrome Experiments</a> 以及 <a target="_blank" rel="noopener" href="https://webglsamples.org/">webglsamples</a>。</li>
<li>诸如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API"><code>WebRTC</code></a> 等 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery">影音类 API</a> 让你可以利用多媒体做一些非常有趣的事，比如在网页中直接播放音乐和影片，或用自己的网络摄像头获取录像，然后在其他人的电脑上展示（试用简易版 <a target="_blank" rel="noopener" href="http://chrisdavidmills.github.io/snapshot/">截图 demo</a> 以理解这个概念）。</li>
</ul>
<p><strong>第三方 API</strong> 并没有默认嵌入浏览器中，一般要从网上取得它们的代码和信息。比如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.twitter.com/overview/documentation">Twitter API</a>、<a target="_blank" rel="noopener" href="https://open.weibo.com/">新浪微博 API</a> 可以在网站上展示最新推文之类。</li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/maps/">谷歌地图 API</a>、<a target="_blank" rel="noopener" href="https://lbs.amap.com/">高德地图 API</a> 可以在网站嵌入定制的地图等等。</li>
</ul>
<h4 id="JavaScript-在页面上做了什么？"><a href="#JavaScript-在页面上做了什么？" class="headerlink" title="JavaScript 在页面上做了什么？"></a>JavaScript 在页面上做了什么？</h4><p>让我们简单回顾一下，浏览器在读取一个网页时都发生什么（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works#how_does_css_actually_work">CSS 如何工作</a> 一文中首次谈及）。浏览器在读取一个网页时，代码（HTML, CSS 和 JavaScript）将在一个运行环境（浏览器标签页）中得到执行。就像一间工厂，将原材料（代码）加工为一件产品（网页）。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript/execution.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>在 HTML 和 CSS 集合组装成一个网页后，浏览器的 JavaScript 引擎将执行 JavaScript 代码。这保证了当 JavaScript 开始运行之前，网页的结构和样式已经就位。</p>
<p>这样很好，因为 JavaScript 最普遍的用处是通过 DOM API（见上文）动态修改 HTML 和 CSS 来更新用户界面（user interface）。如果 JavaScript 在 HTML 和 CSS 就位之前加载运行，就会引发错误。</p>
<h4 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h4><p>每个浏览器标签页就是其自身用来运行代码的独立容器（这些容器用专业术语称为“运行环境”）。大多数情况下，每个标签页中的代码完全独立运行，而且一个标签页中的代码不能直接影响另一个标签页（或者另一个网站）中的代码。这是一个好的安全措施，如果不这样，黑客就可以从其他网站盗取信息，等等。</p>
<h4 id="JavaScript-运行次序"><a href="#JavaScript-运行次序" class="headerlink" title="JavaScript 运行次序"></a>JavaScript 运行次序</h4><p>当浏览器执行到一段 JavaScript 代码时，通常会按从上往下的顺序执行这段代码。这意味着你需要注意代码书写的顺序。比如，我们回到第一个例子中的 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>para.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, updateName);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入一个新的名字：&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;玩家 1：&#x27;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们选定一个文本段落（第 1 行)，然后给它附上一个事件监听器（第 3 行），使得在它被点击时，<code>updateName()</code> 代码块（code block） （5 – 8 行）便会运行。<code>updateName()</code> （这类可以重复使用的代码块称为“函数”）向用户请求一个新名字，然后把这个名字插入到段落中以更新显示。</p>
<p>如果你互换了代码里最初两行的顺序，会导致问题。浏览器<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/zh-CN/docs/Learn/Discover_browser_developer_tools">开发者控制台</a>将返回一个错误： <code>TypeError: para is undefined</code>。这意味着 <code>para</code> 对象还不存在，所以我们不能为它增添一个事件监听器。</p>
<h4 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a>解释代码 vs 编译代码</h4><p>作为程序员，你或许听说过这两个术语：<strong>解释</strong>（interpret）和 <strong>编译</strong>（compile）。在解释型语言中，代码自上而下运行，且实时返回运行结果。代码在由浏览器执行前，不需要将其转化为其他形式。代码将直接以文本格式（text form）被接收和处理。</p>
<p>相对的，编译型语言需要先将代码转化（编译）成另一种形式才能运行。比如 C&#x2F;C++ 先被编译成汇编语言，然后才能由计算机运行。程序将以二进制的格式运行，这些二进制内容是由程序源代码产生的。</p>
<p>JavaScript 是轻量级解释型语言。浏览器接受到 JavaScript 代码，并以代码自身的文本格式运行它。技术上，几乎所有 JavaScript 转换器都运用了一种叫做即时编译（just-in-time compiling）的技术；当 JavaScript 源代码被执行时，它会被编译成二进制的格式，使代码运行速度更快。尽管如此，JavaScript 仍然是一门解释型语言，因为编译过程发生在代码运行中，而非之前。</p>
<p>两种类型的语言各有优势，这个问题我们暂且不谈。</p>
<h4 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a>服务器端代码 vs 客户端代码</h4><p>你或许还听说过<strong>服务器端（server-side）</strong>和 **客户端（client-side）**代码这两个术语，尤其是在 web 开发时。客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。这就是**客户端 JavaScript**。</p>
<p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！JavaScript 也可用作服务器端语言，比如现在流行的 Node.js 环境，你可以在我们的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">动态网页 - 服务器端编程</a> 主题中找到更多关于服务器端 JavaScript 的知识。</p>
<h4 id="动态代码-vs-静态代码"><a href="#动态代码-vs-静态代码" class="headerlink" title="动态代码 vs 静态代码"></a>动态代码 vs 静态代码</h4><p>“<strong>动态</strong>”一词既适用于客户端 JavaScript，又适用于描述服务器端语言。是指通过按需生成新内容来更新 web 页面 &#x2F; 应用，使得不同环境下显示不同内容。服务器端代码会在服务器上动态生成新内容，例如从数据库中提取信息。而客户端 JavaScript 则在用户端浏览器中动态生成新内容，比如说创建一个新的 HTML 表格，用从服务器请求到的数据填充，然后在网页中向用户展示这个表格。两种情况的意义略有不同，但又有所关联，且两者（服务器端和客户端）经常协同作战。</p>
<p>没有动态更新内容的网页叫做“<strong>静态</strong>”页面<strong>，</strong>所显示的内容不会改变。</p>
<h4 id="内联-JavaScript-处理器"><a href="#内联-JavaScript-处理器" class="headerlink" title="内联 JavaScript 处理器"></a>内联 JavaScript 处理器</h4><p>注意，有时候你会遇到在 HTML 中存在着一丝真实的 JavaScript 代码。它或许看上去像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createParagraph</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;你点击了这个按钮！&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(para);<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;createParagraph()&quot;</span>&gt;点我呀&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure>



<p>你可以在下面尝试这个版本的 demo。</p>
<iframe class="sample-code-frame" title="内联 JavaScript 处理器 sample" id="frame_内联_javascript_处理器" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript/_sample_.%E5%86%85%E8%81%94_javascript_%E5%A4%84%E7%90%86%E5%99%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>这个 demo 与之前的两个功能完全一致，只是在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button"><code>&lt;button&gt;</code></a> 元素中包含了一个内联的 <code>onclick</code> 处理器，使得函数在按钮被按下时运行。</p>
<p><strong>然而请不要这样做。</strong> 这将使 JavaScript 污染到 HTML，而且效率低下。对于每个需要应用 JavaScript 的按钮，你都得手动添加 <code>onclick=&quot;createParagraph()&quot;</code> 属性。</p>
<p>可以使用纯 JavaScript 结构来通过一个指令选取所有按钮。下文的这段代码即实现了这一目的：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const buttons = document.query<span class="hljs-constructor">SelectorAll(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buttons.length ; i++) &#123;<br>  buttons<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">createParagraph</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样写乍看去比 <code>onclick</code> 属性要长一些，但是这样写会对页面上所有按钮生效，无论多少个，或添加或删除，完全无需修改 JavaScript 代码。</p>
<h4 id="脚本调用策略"><a href="#脚本调用策略" class="headerlink" title="脚本调用策略"></a>脚本调用策略</h4><p>要让脚本调用的时机符合预期，需要解决一系列的问题。这里看似简单，实际大有文章。最常见的问题就是：HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">文档对象模型</a> DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。</p>
<p>在上文的“内部”、“外部”示例中，JavaScript 调用于文档头处，解析 HTML 文档体之前。这样做是有隐患的，需要使用一些结构来避免错误发生。</p>
<p>“内部”示例使用了以下结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  . . .<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这是一个事件监听器，它监听浏览器的 “<code>DOMContentLoaded</code>“ 事件，即 HTML 文档体加载、解释完毕事件。事件触发时将调用 “ <code>. . .</code>“ 处的代码，从而避免了错误发生（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件</a> 的概念稍后学习）。</p>
<p>“外部”示例中使用了 JavaScript 的一项现代技术（<code>async</code> “异步”属性）来解决这一问题，它告知浏览器在遇到 <code>&lt;script&gt;</code> 元素时不要中断后续 HTML 内容的加载。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>上述情况下，脚本和 HTML 将一并加载，代码将顺利运行。</p>
<p><strong>备注：</strong> “外部”示例中 <code>async</code> 属性可以解决调用顺序问题，因此无需使用 <code>DOMContentLoaded</code> 事件。而 <code>async</code> 只能用于外部脚本，因此不适用于“内部”示例。</p>
<p>解决此问题的旧方法是：把脚本元素放在文档体的底端（<code>&lt;/body&gt;</code> 标签之前，与之相邻），这样脚本就可以在 HTML 解析完毕后加载了。此方案（以及上述的 <code>DOMContentLoaded</code> 方案）的问题是：只有在所有 HTML DOM 加载完成后才开始脚本的加载&#x2F;解析过程。对于有大量 JavaScript 代码的大型网站，可能会带来显著的性能损耗。这也是 <code>async</code> 属性诞生的初衷。</p>
<h4 id="async-和-defer"><a href="#async-和-defer" class="headerlink" title="async 和 defer"></a><code>async</code> 和 <code>defer</code></h4><p>上述的脚本阻塞问题实际有两种解决方案 —— <code>async</code> 和 <code>defer</code>。我们来依次讲解。</p>
<p>浏览器遇到 <code>async</code> 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，<code>async</code> 是最理想的选择。</p>
<p>比如，如果你的页面要加载以下三个脚本：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>三者的调用顺序是不确定的。<code>jquery.js</code> 可能在 <code>script2</code> 和 <code>script3</code> 之前或之后调用，如果这样，后两个脚本中依赖 <code>jquery</code> 的函数将产生错误，因为脚本运行时 <code>jquery</code> 尚未加载。</p>
<p>解决这一问题可使用 <code>defer</code> 属性，脚本将按照在页面中出现的顺序加载和运行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code> 必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code> 之前。</p>
<p>脚本调用策略小结：</p>
<ul>
<li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li>
<li>如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li>
</ul>
<h3 id="3-2-有趣的字符串方法"><a href="#3-2-有趣的字符串方法" class="headerlink" title="3.2 有趣的字符串方法"></a>3.2 有趣的字符串方法</h3><p>现在我们学习基本的字符串语法，让我们开始思考一下我们可以对内置方法的字符串做什么有用的操作，例如查找文本字符串的长度，加入和分割字符串，将字符串中的一个字符替换为另一个字符。</p>
<h4 id="获得字符串的长度"><a href="#获得字符串的长度" class="headerlink" title="获得字符串的长度"></a>获得字符串的长度</h4><p>这很简单 — 你可以很轻松的使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/length"><code>length</code></a> 属性。尝试输入以下的两行代码：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let browserType = <span class="hljs-string">&#x27;mozilla&#x27;</span>;<br>browserType.<span class="hljs-built_in">length</span>;<br></code></pre></td></tr></table></figure>

<p>这个结果应该返回一个数字：7，因为”mozilla”的长度为 7 个字符。说字符串的长度有用是有很多原因的，例如，你可能想算出一连串名字的长度，并用名字长度来作为名字排序的依据，亦或让一个用户知道他输入的用户名太长，已经超出了输入的字符串长度限制。</p>
<h4 id="检索特定字符串字符"><a href="#检索特定字符串字符" class="headerlink" title="检索特定字符串字符"></a>检索特定字符串字符</h4><p>在相关的注释中，您可以使用方括号表示法返回字符串中的任何字符 - 这意味着您可以在变量名的末尾包含方括号（[ ]）。在方括号内，您可以包含要返回的字符的编号，例如，您要检索第一个字母，可以这样做：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>电脑从 0 开始，不是 1！要检索任何字符串的最后一个字符，我们可以使用下面这行，将这种技术与我们上面看到的 length 属性相结合起来：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType[browserType.length-<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>“mozilla”的长度为 7，但由于计数从 0 开始，所以字符位置为 6，因此需要长度为<strong>length-1</strong>。例如，您可以使用它来查找一系列字符串的第一个字母，并按字母顺序排列。</p>
<h4 id="在字符串中查找子字符串并提取它"><a href="#在字符串中查找子字符串并提取它" class="headerlink" title="在字符串中查找子字符串并提取它"></a>在字符串中查找子字符串并提取它</h4><ol>
<li><p>有时候你会想要找出一个较小的字符串是否存在于一个较大的字符串中（我们通常会说一个字符串中存在一个子字符串）。这可以使用<code>indexOf()</code>方法来完成，该方法需要一个parameter (en-US)— 你想要搜索的子字符串。尝试以下：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;zilla&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>结果是 2，因为子字符串“zilla”从“mozilla”内的位置 2（0，1，2 —— 所以从第 3 个字符）开始。这样的代码可以用来过滤字符串。例如，假设我们有一个 Web 地址列表，但我们只想打印出包含“mozilla”的那些地址。</p>
</li>
<li><p>这可以用另一种可能更有效的方式来实现。尝试以下：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;vanilla&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>这应该会得到-1的结果 —— 当在主字符串中找不到子字符串（在本例中为“vanilla”）时将返回-1。 您可以使用它来查找不包含子串“mozilla”的所有字符串实例，或者如果使用否定运算符，请执行以下操作。你可以这样做：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(browserType.indexOf(<span class="hljs-string">&#x27;mozilla&#x27;</span>)</span></span> !== -<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-comment">// do stuff with the string</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>当你知道字符串中的子字符串开始的位置，以及想要结束的字符时，<code>slice()</code>可以用来提取它。尝试以下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">browserType</span>.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<p>这时返回”moz”——第一个参数是开始提取的字符位置，第二个参数是提取的最后一个字符的后一个位置。所以提取从第一个位置开始，直到但不包括最后一个位置。（此例中）你也可以说第二个参数等于被返回的字符串的长度。</p>
</li>
<li><p>此外，如果您知道要在某个字符之后提取字符串中的所有剩余字符，则不必包含第二个参数，而只需要包含要从中提取的字符位置 字符串中的其余字符。尝试以下：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType.slice(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>这返回“zilla” —— 这是因为 2 的字符位置是字母 z，并且因为没有包含第二个参数，所以返回的子字符串是字符串中的所有剩余字符。</p>
</li>
</ol>
<p><strong>备注：</strong> <code>slice()</code>的第二个参数是可选的：如果没有传入这个参数，分片结束位置会在原始字符串的末尾。这个方法也有其他的选项；学习<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice"><code>slice()</code></a>这页，来看看你还能发现什么其他作用。</p>
<h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><p>字符串方法<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase"><code>toLowerCase()</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"><code>toUpperCase()</code></a>字符串并将所有字符分别转换为小写或大写。例如，如果要在将数据存储在数据库中之前对所有用户输入的数据进行规范化，这可能非常有用。</p>
<p>让我们尝试输入以下几行来看看会发生什么：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> radData = &#x27;My NaMe Is MuD&#x27;;<br>radData.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>radData.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>;<br></code></pre></td></tr></table></figure>

<h4 id="替换字符串的某部分"><a href="#替换字符串的某部分" class="headerlink" title="替换字符串的某部分"></a>替换字符串的某部分</h4><p>您可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace()</code></a>方法将字符串中的一个子字符串替换为另一个子字符串。在基础的层面上，这个工作非常简单。你当然可以用它做一些更高级的事情，但目前我们不会涉及到。</p>
<p>它需要两个参数 - 要被替换下的字符串和要被替换上的字符串。尝试这个例子：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;moz&#x27;</span>,<span class="hljs-string">&#x27;van&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>注意，在实际程序中，想要真正更新 <code>browserType</code> 变量的值，您需要设置变量的值等于刚才的操作结果；它不会自动更新子串的值。所以事实上你需要这样写：<code>browserType = browserType.replace(&#39;moz&#39;,&#39;van&#39;);</code>。</p>
<h3 id="3-3-数组"><a href="#3-3-数组" class="headerlink" title="3.3 数组"></a>3.3 数组</h3><p>数组通常被描述为“像列表一样的对象”; 简单来说，数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。</p>
<h4 id="数组是什么？"><a href="#数组是什么？" class="headerlink" title="数组是什么？"></a>数组是什么？</h4><p>数组通常被描述为“像列表一样的对象”; 简单来说，数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。也许我们有一系列产品和价格存储在一个数组中，我们想循环遍历所有这些产品，并将它们打印在发票上，同时将所有产品的价格统计在一起，然后将总价格打印在底部。</p>
<p>如果我们没有数组，我们必须将每个产品存储在一个单独的变量中，然后调用打印的代码，并为每个产品单独添加。花费的时间要长得多，效率很低，而且也容易出错。如果我们有 10 个产品需要添加发票，那就只是有点麻烦而已，但是 100 个，或者 1000 个呢？我们稍后将在文章中使用这个例子。</p>
<p>像以前的文章一样，我们通过在 JavaScript 控制台中输入一些示例来了解数组的基础知识。我们在下面提供了一个（您也可以在单独的选项卡或窗口中打开此控制台，或者如果您愿意，请使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Tools_and_setup/What_are_browser_developer_tools">浏览器的开发者工具控制台</a>）。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>数组由方括号构成，其中包含用逗号分隔的元素列表。</p>
<ol>
<li><p>假设我们想在一个数组中存储一个购物清单 - 我们会做一些像下面这样的事情。在您的控制台中输入以下行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> shopping = [<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;milk&#x27;</span>, <span class="hljs-string">&#x27;cheese&#x27;</span>, <span class="hljs-string">&#x27;hummus&#x27;</span>, <span class="hljs-string">&#x27;noodles&#x27;</span>];<br>shopping;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在这种情况下，数组中的每个项目都是一个字符串，但请记住，您可以将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。您也可以混合和匹配项目类型 - 它们并不都是数字，字符串等。尝试下面这些：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let sequence</span> = [1, 1, 2, 3, 5, 8, 13];<br><span class="hljs-attribute">let random</span> = [<span class="hljs-string">&#x27;tree&#x27;</span>, 795, [0, 1, 2]];<br></code></pre></td></tr></table></figure>
</li>
<li><p>尝试创建您自己的几个数组，然后再继续往下看。</p>
</li>
</ol>
<h4 id="访问和修改数组元素"><a href="#访问和修改数组元素" class="headerlink" title="访问和修改数组元素"></a>访问和修改数组元素</h4><p>然后，您可以使用括号表示法访问数组中的元素，与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Useful_string_methods#%E6%A3%80%E7%B4%A2%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6">检索特定字符串字符</a> 的方法相同。</p>
<ol>
<li><p>在您的控制台中输入以下内容：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">shopping[<span class="hljs-number">0</span>];<br><span class="hljs-regexp">//</span> returns <span class="hljs-string">&quot;bread&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>您还可以简单地为单个数组元素提供新值来修改数组中的元素。例如：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">shopping[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;tahini&#x27;</span>;<br>shopping;<br><span class="hljs-regexp">//</span> shopping will now return [ <span class="hljs-string">&quot;tahini&quot;</span>, <span class="hljs-string">&quot;milk&quot;</span>, <span class="hljs-string">&quot;cheese&quot;</span>, <span class="hljs-string">&quot;hummus&quot;</span>, <span class="hljs-string">&quot;noodles&quot;</span> ]<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 我们以前说过，但还是提醒一下 —— 电脑从 0 开始计数！</p>
</li>
<li><p>请注意，数组中包含数组的话称之为多维数组。您可以通过将两组方括号链接在一起来访问数组内的另一个数组。例如，要访问数组内部的一个项目，即random数组中的第三个项目（参见上一节），我们可以这样做：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">random</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>在继续之前，尝试对您的数组示例进行一些修改。玩一玩，看看哪些有效，哪些无效。</p>
</li>
</ol>
<h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>你可以通过使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性获取数组的长度（数组中有多少项元素），这与查找字符串的长度（以字符为单位）完全相同。尝试以下代码：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">sequence.<span class="hljs-built_in">length</span>;<br><span class="hljs-comment">// should return 7</span><br></code></pre></td></tr></table></figure>

<p>虽然 length 属性也有其他用途，但最常用于循环（循环遍历数组中的所有项）。例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">let</span> <span class="hljs-keyword">sequence</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sequence</span><span class="hljs-variable">.length</span>; i++) &#123;<br>  console<span class="hljs-variable">.log</span>(<span class="hljs-keyword">sequence</span>[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>您将在以后的文章中正确地了解循环，但简而言之，这段代码的意思是：</p>
<ol>
<li>在数组中的元素编号 0 开始循环。</li>
<li>在元素编号等于数组长度的时候停止循环。这适用于任何长度的数组，但在这种情况下，它将在编号 7 的时候终止循环（这很好，因为我们希望最后一位元素的编号是 6）。</li>
<li>对于每个元素，使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/console/log">console.log()</a> 将其打印到浏览器控制台。</li>
</ol>
<h4 id="一些有用的数组方法"><a href="#一些有用的数组方法" class="headerlink" title="一些有用的数组方法"></a>一些有用的数组方法</h4><p>在本节中，我们将介绍一些相当有用的数组方法，这些方法允许我们将字符串拆分为字符串数组，反之亦然，以及添加或删除元素。</p>
<h4 id="字符串和数组之间的转换"><a href="#字符串和数组之间的转换" class="headerlink" title="字符串和数组之间的转换"></a>字符串和数组之间的转换</h4><p>通常，您会看到一个包含在一个长长的字符串中的原始数据，您可能希望将有用的项目分成更有用的表单，然后对它们进行处理，例如将它们显示在数据表中。为此，我们可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split()</code></a> 方法。在其最简单的形式中，这需要一个参数，您要将字符串分隔的字符，并返回分隔符之间的子串，作为数组中的项。</p>
<p><strong>备注：</strong> 好吧，从技术上讲，这是一个字符串方法，而不是一个数组方法，但是我们把它放在数组中，因为它在这里很合适。</p>
<ol>
<li><p>我们来玩一下这个方法，看看它是如何工作的。首先，在控制台中创建一个字符串：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let myData</span> = <span class="hljs-string">&#x27;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&#x27;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>现在我们用每个逗号分隔它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> myArray = myData.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>myArray;<br></code></pre></td></tr></table></figure>
</li>
<li><p>最后，尝试找到新数组的长度，并从中检索一些项目：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">myArray.length;<br>myArray[0]; // the first item in the<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>myArray[1]; // the second item in the<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>myArray[myArray.length-1]; // the last item in the array<br></code></pre></td></tr></table></figure>
</li>
<li><p>您也可以使用<code>join()</code>方法进行相反的操作。尝试以下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> myNewString = myArray.<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>myNewString;<br></code></pre></td></tr></table></figure>
</li>
<li><p>将数组转换为字符串的另一种方法是使用<code>toString()</code>方法。toString()可以比join()更简单，因为它不需要一个参数，但更有限制。使用join()可以指定不同的分隔符（尝试使用与逗号不同的字符运行步骤 4）。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">dogNames</span> = [<span class="hljs-string">&quot;Rocket&quot;</span>,<span class="hljs-string">&quot;Flash&quot;</span>,<span class="hljs-string">&quot;Bella&quot;</span>,<span class="hljs-string">&quot;Slugger&quot;</span>];<br>dogNames.<span class="hljs-built_in">toString</span>(); //Rocket,Flash,Bella,Slugger<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="添加和删除数组项"><a href="#添加和删除数组项" class="headerlink" title="添加和删除数组项"></a>添加和删除数组项</h4><p>我们还没有涵盖添加和删除数组元素，现在让我们来看看。我们将使用在上一节中最后提到的 <code>myArray</code> 数组。如果您尚未遵循该部分，请先在控制台中创建数组：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let myArray</span> = [<span class="hljs-string">&#x27;Manchester&#x27;</span>, <span class="hljs-string">&#x27;London&#x27;</span>, <span class="hljs-string">&#x27;Liverpool&#x27;</span>, <span class="hljs-string">&#x27;Birmingham&#x27;</span>, <span class="hljs-string">&#x27;Leeds&#x27;</span>, <span class="hljs-string">&#x27;Carlisle&#x27;</span>];<br></code></pre></td></tr></table></figure>

<p>首先，要在数组末尾添加或删除一个项目，我们可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a>。</p>
<ol>
<li><p>让我们先使用push()—— 注意，你需要添加一个或多个要添加到数组末尾的元素。尝试下面的代码：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">myArray.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;Cardiff&#x27;</span>);<br>myArray;<br>myArray.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;Bradford&#x27;</span>, <span class="hljs-string">&#x27;Brighton&#x27;</span>);<br>myArray;<br></code></pre></td></tr></table></figure>
</li>
<li><p>当方法调用完成时，将返回数组的新长度。如果要将新数组长度存储在变量中。例如：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Length</span> = myArray.push(<span class="hljs-string">&#x27;Bristol&#x27;</span>);<br>myArray;<br><span class="hljs-keyword">new</span><span class="hljs-type">Length</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>从数组中删除最后一个元素的话直接使用pop()就可以。例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">myArray.pop()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>当方法调用完成时，将返回已删除的项目。你也可以这样做：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let removedItem <span class="hljs-operator">=</span> myArray.pop()<span class="hljs-comment">;</span><br>myArray<span class="hljs-comment">;</span><br>removedItem<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift"><code>unshift()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift"><code>shift()</code></a> 从功能上与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a> 完全相同，只是它们分别作用于数组的开始，而不是结尾。</p>
<ol>
<li><p>首先unshift()——尝试一下这个命令：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">myArray.unshift(&#x27;Edinburgh&#x27;);<br>myArray;<br></code></pre></td></tr></table></figure>
</li>
<li><p>现在shift()—— 尝试一下！</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let removedItem <span class="hljs-operator">=</span> myArray.shift()<span class="hljs-comment">;</span><br>myArray<span class="hljs-comment">;</span><br>removedItem<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-4-事件介绍"><a href="#3-4-事件介绍" class="headerlink" title="3.4 事件介绍"></a>3.4 事件介绍</h3><p>事件是您在编程时系统内发生的动作或者发生的事情，系统响应事件后，如果需要，您可以某种方式对事件做出回应。例如：如果用户在网页上单击一个按钮，您可能想通过显示一个信息框来响应这个动作。在这篇文章中，我们将讨论一些关于事件的重要概念，并且观察它们在浏览器上如何运行。这篇文章不会面面俱到，仅聚焦于您现阶段需要掌握的知识。</p>
<h4 id="一系列事件"><a href="#一系列事件" class="headerlink" title="一系列事件"></a>一系列事件</h4><p>就像上面提到的，<strong>事件</strong>是您在编程时系统内发生的动作或者发生的事情——系统会在事件出现时产生或触发某种信号，并且会提供一个自动加载某种动作（列如：运行一些代码）的机制，比如在一个机场，当跑道清理完成，飞机可以起飞时，飞行员会收到一个信号，因此他们开始起飞。</p>
<p>在 Web 中，事件在浏览器窗口中被触发并且通常被绑定到窗口内部的特定部分 — 可能是一个元素、一系列元素、被加载到这个窗口的 HTML 代码或者是整个浏览器窗口。举几个可能发生的不同事件：</p>
<ul>
<li>用户在某个元素上点击鼠标或悬停光标。</li>
<li>用户在键盘中按下某个按键。</li>
<li>用户调整浏览器的大小或者关闭浏览器窗口。</li>
<li>一个网页停止加载。</li>
<li>提交表单。</li>
<li>播放、暂停、关闭视频。</li>
<li>发生错误。</li>
</ul>
<p>如果您想看看更多其他的事件，请移步至 MDN 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Events">Event reference</a>。</p>
<p>每个可用的事件都会有一个<strong>事件处理器</strong>，也就是事件触发时会运行的代码块。当我们定义了一个用来回应事件被激发的代码块的时候，我们说我们<strong>注册了一个事件处理器</strong>。注意事件处理器有时候被叫做<strong>事件监听器</strong>——从我们的用意来看这两个名字是相同的，尽管严格地来说这块代码既监听也处理事件。监听器留意事件是否发生，然后处理器就是对事件发生做出的回应。</p>
<p><strong>备注：</strong> 网络事件不是 JavaScript 语言的核心——它们被定义成内置于浏览器的 JavaScript APIs。</p>
<p>值得注意的是并不是只有 JavaScript 使用事件——大多的编程语言都有这种机制，并且它们的工作方式不同于 JavaScript。实际上，JavaScript 网页上的事件机制不同于在其他环境中的事件机制。</p>
<p>比如，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs">Node.js</a> 是一种非常流行的允许开发者使用 JavaScript 来建造网络和服务器端应用的运行环境。<a target="_blank" rel="noopener" href="https://nodejs.org/docs/latest-v5.x/api/events.html">Node.js event model</a> 依赖定期监听事件的监听器和定期处理事件的处理器——虽然听起来好像差不多，但是实现两者的代码是非常不同的，Node.js 使用像 on ( ) 这样的函数来注册一个事件监听器，使用 once ( ) 这样函数来注册一个在运行一次之后注销的监听器。 <a target="_blank" rel="noopener" href="https://nodejs.org/docs/latest-v5.x/api/http.html#http_event_connect">HTTP connect event docs</a> 提供了很多例子。</p>
<p>另外一个例子：您可以使用 JavaScript 来开发跨浏览器的插件（使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions">WebExtensions</a> 开发技术。事件模型和网站的事件模型是相似的，仅有一点点不同——事件监听属性使用驼峰命名法（如<code>onMessage</code>而不是<code>onmessage</code>），还需要与 <code>addListener</code> 函数结合，参见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage#examples">runtime.onMessage page</a> 上的一个例子。</p>
<h4 id="使用网页事件的方式"><a href="#使用网页事件的方式" class="headerlink" title="使用网页事件的方式"></a>使用网页事件的方式</h4><p>您可以通过多种不同的方法将事件侦听器代码添加到网页，以便在关联的事件被触发时运行它。在本节中，我们将回顾不同的机制，并讨论应该使用哪些机制。</p>
<h4 id="事件处理器属性"><a href="#事件处理器属性" class="headerlink" title="事件处理器属性"></a>事件处理器属性</h4><p><em>这些是我们的课程中最常见到的代码 - 存在于事件处理程序过程的属性中</em>。回到上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/click_event"><code>onclick</code></a> 是被用在这个情景下的事件处理器的属性，它就像 button 其他的属性（如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent"><code>btn.textContent</code></a>, or <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style"><code>btn.style</code> (en-US)</a>), 但是有一个特别的地方——当您将一些代码赋值给它的时候，只要事件触发代码就会运行。</p>
<p>您也可以将一个有名字的函数赋值给事件处理参数（正如我们在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Build_your_own_function">Build your own function</a> 中看到的），下面的代码也是这样工作的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br><br>btn.<span class="hljs-property">onclick</span> = bgChange;<br></code></pre></td></tr></table></figure>

<p>有很多事件处理参数可供选择，我们来做一个实验。</p>
<p>首先将 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventhandlerproperty.html">random-color-eventhandlerproperty.html</a> 复制到本地，然后用浏览器打开。别慌，这只是我们之前已经进行过的一个简单随机颜色的示例的代码复制。将 <code>btn.onclick</code> 依次换成其他值，在浏览器中观察效果。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/focus_event"><code>btn.onfocus</code></a>及<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/blur_event"><code>btn.onblur</code></a> — 颜色将于按钮被置于焦点或解除焦点时改变（尝试使用 Tab 移动至按钮上，然后再移开）。这些通常用于显示有关如何在置于焦点时填写表单字段的信息，或者如果表单字段刚刚填入不正确的值，则显示错误消息。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/dblclick_event"><code>btn.ondblclick</code></a> — 颜色将仅于按钮被双击时改变。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keypress_event"><code>window.onkeypress</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keydown_event"><code>window.onkeydown</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keyup_event"><code>window.onkeyup</code></a> — 当按钮被按下时颜色会发生改变。<code>keypress</code> 指的是通俗意义上的按下按钮 (按下并松开), 而 <code>keydown</code> 和 <code>keyup</code> 指的是按键动作的一部分，分别指按下和松开。注意如果你将事件处理器添加到按钮本身，它将不会工作 — 我们只能将它添加到代表整个浏览器窗口的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">window</a>对象中。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseover_event"><code>btn.onmouseover</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseout_event"><code>btn.onmouseout</code></a> — 颜色将会在鼠标移入按钮上方时发生改变，或者当它从按钮移出时。</li>
</ul>
<p>一些事件非常通用，几乎在任何地方都可以用（比如 onclick 几乎可以用在几乎每一个元素上），然而另一些元素就只能在特定场景下使用，比如我们只能在 video 元素上使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event">onplay (en-US)</a> 。</p>
<h4 id="内联事件处理器——请勿使用"><a href="#内联事件处理器——请勿使用" class="headerlink" title="内联事件处理器——请勿使用"></a>内联事件处理器——请勿使用</h4><p>你也许在你的代码中看到过这么一种写法：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;bgChange()&quot;</span>&gt;Press me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  const rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  document.body.style.backgroundColor = rndCol;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 您可以在<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventhandlerattributes.html">GitHub</a>上找到这个示例的完整源代码 (也可以<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-eventhandlerattributes.html">在线运行</a>).</p>
<p>在 Web 上注册事件处理程序的最早方法是类似于上面所示的<strong>事件处理程序 HTML 属性</strong>(也称为内联事件处理程序)—属性值实际上是当事件发生时要运行的 JavaScript 代码。上面的例子中调用一个在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script"><code>div</code></a>元素在同一个页面上，但也可以直接在属性内插入 JavaScript，例如：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello, this is my old-fashioned event handler!&#x27;);&quot;</span>&gt;Press me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure>

<p>你会发现 HTML 属性等价于对许多事件处理程序的属性；但是，你不应该使用这些 —— 他们被认为是不好的做法。使用一个事件处理属性似乎看起来很简单，如果你只是在做一些非常快的事情，但很快就变得难以管理和效率低下。</p>
<p>一开始，您不应该混用 HTML 和 JavaScript，因为这样文档很难解析——最好的办法是只在一块地方写 JavaScript 代码。</p>
<p>即使在单一文件中，内置事件处理器也不是一个好主意。一个按钮看起来还好，但是如果有一百个按钮呢？您得在文件中加上 100 个属性。这很快就会成为维护人员的噩梦。使用 Java Script，您可以给网页中的 button 都加上事件处理器。就像下面这样：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> buttons = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; buttons.length; i++) &#123;<br>  buttons[i].onclick = bgChange;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 将您的编程逻辑与内容分离也会让您的站点对搜索引擎更加友好。</p>
<h4 id="addEventListener-和-removeEventListener"><a href="#addEventListener-和-removeEventListener" class="headerlink" title="addEventListener() 和 removeEventListener()"></a>addEventListener() 和 removeEventListener()</h4><p>新的事件触发机制被定义在 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/DOM-Level-2-Events/">Document Object Model (DOM) Level 2 Events</a> Specification, 这个细则给浏览器提供了一个函数 — <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>。这个函数和事件处理属性是类似的，但是语法略有不同。我们可以重写上面的随机颜色背景代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, bgChange);<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 您可以在<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-addeventlistener.html">Github</a>上找到这个示例的完整源代码 (也可以 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-addeventlistener.html">在线运行</a>)。</p>
<p>在 <code>addEventListener()</code> 函数中，我们具体化了两个参数——我们想要将处理器应用上去的事件名称，和包含我们用来回应事件的函数的代码。注意将这些代码全部放到一个匿名函数中是可行的：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  document.body.style.backgroundColor = rndCol;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这个机制带来了一些相较于旧方式的优点。有一个相对应的方法，<code>removeEventListener()，</code>这个方法移除事件监听器。例如，下面的代码将会移除上个代码块中的事件监听器：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">btn.remove<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">bgChange</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>在这个简单的、小型的项目中可能不是很有用，但是在大型的、复杂的项目中就非常有用了，可以非常高效地清除不用的事件处理器，另外在其他的一些场景中也非常有效——比如您需要在不同环境下运行不同的事件处理器，您只需要恰当地删除或者添加事件处理器即可。</p>
<p>您也可以给同一个监听器注册多个处理器，下面这种方式不能实现这一点：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">myElement.onclick</span> = functionA<span class="hljs-comment">;</span><br><span class="hljs-attr">myElement.onclick</span> = functionB<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>第二行会覆盖第一行，但是下面这种方式就会正常工作了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">myElement.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">functionA</span>)</span>;<br>myElement.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">functionB</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>当元素被点击时两个函数都会工作：</p>
<p>此外，该事件机制还提供了许多其他强大的特性和选项。这对于本文来说有点超出范围，但是如果您想要阅读它们，请查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/removeEventListener"><code>removeEventListener()</code></a>参考页面。</p>
<h4 id="我该使用哪种机制？"><a href="#我该使用哪种机制？" class="headerlink" title="我该使用哪种机制？"></a>我该使用哪种机制？</h4><p>在三种机制中，您绝对不应该使用 HTML 事件处理程序属性 - 这些属性已经过时了，而且也是不好的做法，如上所述。</p>
<p>另外两种是相对可互换的，至少对于简单的用途：</p>
<ul>
<li>事件处理程序属性功能和选项会更少，但是具有更好的跨浏览器兼容性 (在 Internet Explorer 8 的支持下)，您应该从这些开始学起。</li>
<li>DOM Level 2 Events (<code>addEventListener()</code>, etc.) 更强大，但也可以变得更加复杂，并且支持不足（只支持到 Internet Explorer 9）。但是您也应该尝试这个方法，并尽可能地使用它们。</li>
</ul>
<p>第三种机制（DOM Level 2 Events (<code>addEventListener()</code>, etc.)）的主要优点是，如果需要的话，可以使用<code>removeEventListener()</code>删除事件处理程序代码，而且如果有需要，您可以向同一类型的元素添加多个监听器。例如，您可以在一个元素上多次调用<code>addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>，并可在第二个参数中指定不同的函数。对于事件处理程序属性来说，这是不可能的，因为后面任何设置的属性都会尝试覆盖较早的属性，例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">element.onclick <span class="hljs-operator">=</span> function1<span class="hljs-comment">;</span><br>element.onclick <span class="hljs-operator">=</span> function2<span class="hljs-comment">;</span><br>etc.<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 如果您在工作中被要求支持比 Internet Explorer 8 更老的浏览器，那么您可能会遇到困难，因为这些古老的浏览器会使用与现代浏览器不同的事件处理模型。但是不要害怕，大多数 JavaScript 库 (例如 jQuery ) 都内置了能够跨浏览器差异的函数。在你学习 JavaScript 旅程里的这个阶段，不要太担心这个问题。</p>
<h4 id="其他事件概念"><a href="#其他事件概念" class="headerlink" title="其他事件概念"></a>其他事件概念</h4><p>本节我们将简要介绍一些与事件相关的高级概念。在这一点并不需要完全理解透彻，但它可能有助于你解释一些经常会遇到的代码模式。</p>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>有时候在事件处理函数内部，您可能会看到一个固定指定名称的参数，例如<code>event</code>，<code>evt</code>或简单的<code>e</code>。这被称为<strong>事件对象</strong>，它被自动传递给事件处理函数，以提供额外的功能和信息。例如，让我们稍稍重写一遍我们的随机颜色示例：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params">e</span>) &#123;<br>  const rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  e.target.style.backgroundColor = rndCol;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(e);<br>&#125;<br><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, bgChange);<br></code></pre></td></tr></table></figure>

<p><strong>备注：</strong> 您可以在 Github 上查看这个示例的 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventobject.html">完整代码</a> ，或者在这里查看 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-eventobject.html">实时演示</a>。</p>
<p>在这里，您可以看到我们在函数中包括一个事件对象<code>e</code>，并在函数中设置背景颜色样式在 <code>e.target</code> 上——它指的是按钮本身。事件对象 <code>e</code> 的 <code>target</code> 属性始终是事件刚刚发生的元素的引用。所以在这个例子中，我们在按钮上设置一个随机的背景颜色，而不是页面。</p>
<p><strong>备注：</strong> 您可以使用任何您喜欢的名称作为事件对象 - 您只需要选择一个名称，然后可以在事件处理函数中引用它。开发人员最常使用 e &#x2F; evt &#x2F; event，因为它们很简单易记。坚持标准总是很好。</p>
<p>当您要在多个元素上设置相同的事件处理程序时，<code>e.target</code>非常有用，并且在发生事件时对所有元素执行某些操作。例如，你可能有一组 16 块方格，当它们被点击时就会消失。用 e.target 总是能准确选择当前操作的东西（方格）并执行操作让它消失，而不是必须以更困难的方式选择它。在下面的示例中 (请参见<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/useful-eventtarget.html">useful-eventtarget.html</a>完整代码;也可以在线运行<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/building-blocks/events/useful-eventtarget.html">running live</a>）我们使用 JavaScript 创建了 16 个<code>&lt;div&gt;</code>元素。接着我们使用 <code>document.querySelectorAll()</code>选择全部的元素，然后遍历每一个，为每一个元素都添加一个<code>onclick</code>单击事件，每当它们点击时就会为背景添加一个随机颜色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; divs.<span class="hljs-property">length</span>; i++) &#123;<br>  divs[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-title function_">bgChange</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出如下 (试着点击它 - 玩的开心):</p>
<iframe class="sample-code-frame" title="事件对象 sample" id="frame_事件对象" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>你遇到的大多数事件处理器的事件对象都有可用的标准属性和函数（方法）（请参阅完整列表 <code>Event</code> 对象引用）。然而，一些更高级的处理程序会添加一些专业属性，这些属性包含它们需要运行的额外数据。例如，媒体记录器 API 有一个<code>dataavailable</code>事件，它会在录制一些音频或视频时触发，并且可以用来做一些事情 (例如保存它，或者回放)。对应的<code>ondataavailable</code>处理程序的事件对象有一个可用的数据属性。</p>
<h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>有时，你会遇到一些情况，你希望事件不执行它的默认行为。最常见的例子是 Web 表单，例如自定义注册表单。当你填写详细信息并按提交按钮时，自然行为是将数据提交到服务器上的指定页面进行处理，并将浏览器重定向到某种“成功消息”页面（或 相同的页面，如果另一个没有指定。）</p>
<p>当用户没有正确提交数据时，麻烦就来了 - 作为开发人员，你希望停止提交信息给服务器，并给他们一个错误提示，告诉他们什么做错了，以及需要做些什么来修正错误。一些浏览器支持自动的表单数据验证功能，但由于许多浏览器不支持，因此建议你不要依赖这些功能，并实现自己的验证检查。我们来看一个简单的例子。</p>
<p>首先，一个简单的 HTML 表单，需要你填入名（first name）和姓（last name）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>First name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span>Last name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lname&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里我们用一个<code>onsubmit</code>事件处理程序（在提交的时候，在一个表单上发起<code>submit</code>事件）来实现一个非常简单的检查，用于测试文本字段是否为空。如果是，我们在事件对象上调用<code>preventDefault()</code>函数，这样就停止了表单提交，然后在我们表单下面的段落中显示一条错误消息，告诉用户什么是错误的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br><span class="hljs-keyword">const</span> fname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fname&#x27;</span>);<br><span class="hljs-keyword">const</span> lname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;lname&#x27;</span>);<br><span class="hljs-keyword">const</span> submit = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;submit&#x27;</span>);<br><span class="hljs-keyword">const</span> para = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>form.onsubmit = function(e) &#123;<br>  <span class="hljs-keyword">if</span> (fname.value === <span class="hljs-string">&#x27;&#x27;</span> || lname.value === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    e.preventDefault();<br>    para.textContent = <span class="hljs-string">&#x27;You need to fill in both names!&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，这是一种非常弱的表单验证——例如，用户输入空格或数字提交表单，表单验证并不会阻止用户提交——这不是我们例子想要达到的目的。输出如下：</p>
<iframe class="sample-code-frame" title="阻止默认行为 sample" id="frame_阻止默认行为" width="100%" height="140" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p><strong>备注：</strong> 查看完整的源代码 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/preventdefault-validation.html">preventdefault-validation.html</a> (也可以 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/building-blocks/events/preventdefault-validation.html">running live</a> )</p>
<h4 id="事件冒泡及捕获"><a href="#事件冒泡及捕获" class="headerlink" title="事件冒泡及捕获"></a>事件冒泡及捕获</h4><p>最后即将介绍的这个主题你常常不会深究，但如果你不理解这个主题，就会十分痛苦。事件冒泡和捕捉是两种机制，主要描述当在一个元素上有两个相同类型的事件处理器被激活会发生什么。为了容易理解，我们来看一个例子——在新标签页打开这个<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box.html">show-video-box.html</a> 例子（在这里可以查看源码 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html">source code</a>）。也可以在下面查看：</p>
<iframe class="sample-code-frame" title="事件冒泡及捕获 sample" id="frame_事件冒泡及捕获" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>这是一个非常简单的例子，它显示和隐藏一个包含 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"><code>video</code></a> 元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>div</code></a> 元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Display video<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hidden&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Your browser doesn&#x27;t support HTML video. Here is a <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span>&gt;</span>link to the video<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> instead.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当“button”元素按钮被单击时，将显示视频，它是通过将改变 <code>&lt;div&gt;</code> 的 class 属性值从 <code>hidden</code> 变为 <code>showing</code>(这个例子的 CSS 包含两个 <code>class</code>，它们分别控制这个 <code>&lt;div&gt;</code> 盒子在屏幕上显示还是隐藏。)：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const btn = document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br>const videoBox = document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">div</span>&#x27;)</span>;<br><br><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Video()</span> &#123;<br>  <span class="hljs-keyword">if</span> (videoBox.get<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;)</span><span class="hljs-operator"> === </span>&#x27;hidden&#x27;) &#123;<br>    videoBox.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;,&#x27;<span class="hljs-params">showing</span>&#x27;)</span>;<br>  &#125;<br>&#125;<br><br>btn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">displayVideo</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>然后我们再添加几个<code>click</code>事件处理器，第一个添加在<code>&lt;div&gt;</code>元素上，第二个添加在<code>&lt;video&gt;</code>元素上。这个想法是当视频 (<code>&lt;video&gt;</code>）外 <code>&lt;div&gt;</code>元素内这块区域被单击时，这个视频盒子应该再次隐藏；当单击视频 (<code>&lt;video&gt;</code>）本身，这个视频将开始播放。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">videoBox.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> videoBox.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;hidden&#x27;</span>));<br><br>const video = document.querySelector(<span class="hljs-string">&#x27;video&#x27;</span>);<br><br>video.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> video.play());<br></code></pre></td></tr></table></figure>

<p>但是有一个问题 - 当您点击<code>video</code>开始播放的视频时，它会在同一时间导致<code>&lt;div&gt;</code>也被隐藏。这是因为<code>video</code>在<code>&lt;div&gt;</code>之内 - <code>video</code>是<code>&lt;div&gt;</code>的一个子元素 - 所以点击<code>video</code>实际上是同时也运行<code>&lt;div&gt;</code>上的事件处理程序。</p>
<h4 id="对事件冒泡和捕捉的解释"><a href="#对事件冒泡和捕捉的解释" class="headerlink" title="对事件冒泡和捕捉的解释"></a>对事件冒泡和捕捉的解释</h4><p>当一个事件发生在具有父元素的元素上 (例如，在我们的例子中是<code>&lt;video&gt;</code>元素) 时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。在捕获阶段：</p>
<ul>
<li>浏览器检查元素的最外层祖先<code>&lt;html&gt;</code>，是否在捕获阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它。</li>
<li>然后，它移动到<code>&lt;html&gt;</code>中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。</li>
</ul>
<p>在冒泡阶段，恰恰相反：</p>
<ul>
<li>浏览器检查实际点击的元素是否在冒泡阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它</li>
<li>然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达<code>&lt;html&gt;</code>元素。</li>
</ul>
<p>在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册。因此，在我们当前的示例中，当您单击视频时，这个单击事件从 <code>&lt;video&gt;</code>元素向外冒泡直到<code>&lt;html&gt;</code>元素。沿着这个事件冒泡线路：</p>
<ul>
<li>它发现了<code>video.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>第一次开始播放。</li>
<li>接着它发现了（往外冒泡找到的） <code>videoBox.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>也隐藏起来了。</li>
</ul>
<h4 id="用-stopPropagation-修复问题"><a href="#用-stopPropagation-修复问题" class="headerlink" title="用 stopPropagation() 修复问题"></a>用 stopPropagation() 修复问题</h4><p>这是令人讨厌的行为，但有一种方法来解决它！标准事件对象具有可用的名为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>stopPropagation()</code></a>的函数，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在<strong>冒泡</strong>链上进一步扩大，因此将不会有更多事件处理器被运行 (不会向上冒泡)。所以，我们可以通过改变前面代码块中的第二个处理函数来解决当前的问题：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">video.onclick <span class="hljs-operator">=</span> function(e) &#123;<br>  e.stopPropagation()<span class="hljs-comment">;</span><br>  video.play()<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>你可以尝试把 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html">show-video-box.html source code</a> 拷贝到本地，然后自己动手修复它，或者在 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box-fixed.html">show-video-box-fixed.html</a> 页面查看修复结果（也可以在这里 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box-fixed.html">source code</a> 查看源码）。</p>
<p><strong>备注：</strong> 为什么我们要弄清楚捕捉和冒泡呢？那是因为，在过去糟糕的日子里，浏览器的兼容性比现在要小得多，Netscape（网景）只使用事件捕获，而 Internet Explorer 只使用事件冒泡。当 W3C 决定尝试规范这些行为并达成共识时，他们最终得到了包括这两种情况（捕捉和冒泡）的系统，最终被应用在现在浏览器里。</p>
<p><strong>备注：</strong> 如上所述，默认情况下，所有事件处理程序都是在冒泡阶段注册的，这在大多数情况下更有意义。如果您真的想在捕获阶段注册一个事件，那么您可以通过使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>注册您的处理程序，并将可选的第三个属性设置为 true。</p>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>冒泡还允许我们利用事件委托——这个概念依赖于这样一个事实，如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。</p>
<p>一个很好的例子是一系列列表项，如果你想让每个列表项被点击时弹出一条信息，您可以将<code>click</code>单击事件监听器设置在父元素<code>&lt;ul&gt;</code>上，这样事件就会从列表项冒泡到其父元素<code>&lt;ul&gt;</code>上。</p>
<p>这个的概念在 David Walsh 的博客上有更多的解释，并有多个例子——看看<a target="_blank" rel="noopener" href="https://davidwalsh.name/event-delegate">How JavaScript Event Delegation Works</a>.</p>
<h3 id="3-5-对象入门"><a href="#3-5-对象入门" class="headerlink" title="3.5 对象入门"></a>3.5 对象入门</h3><p>点表示法</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">name</span>.<span class="hljs-keyword">first</span><br><span class="hljs-built_in">name</span>.<span class="hljs-keyword">last</span><br></code></pre></td></tr></table></figure>

<p>括号表示法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">person<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;age&#x27;</span>]</span><br>person<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;name&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;first&#x27;</span>]</span><br></code></pre></td></tr></table></figure>

<h4 id="“this”的含义"><a href="#“this”的含义" class="headerlink" title="“this”的含义"></a>“this”的含义</h4><p>你也许在我们的方法里注意到了一些奇怪的地方，看这个例子：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">greeting: <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>  alert(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">&#x27;.&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你也许想知道”this”是什么，关键字”this”指向了当前代码运行时的对象 ( 原文：the current object the code is being written inside )——这里即指 person 对象，为什么不直接写 person 呢？当你学到下一篇<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript">Object-oriented JavaScript for beginners</a>文章时，我们开始使用构造器 (constructor) 时，”this”是非常有用的——它保证了当代码的上下文 (context) 改变时变量的值的正确性（比如：不同的 person 对象拥有不同的 name 这个属性，很明显 greeting 这个方法需要使用的是它们自己的 name）。</p>
<h4 id="基于原型的语言？"><a href="#基于原型的语言？" class="headerlink" title="基于原型的语言？"></a>基于原型的语言？</h4><p>JavaScript 常被描述为一种<strong>基于原型的语言 (prototype-based language)<strong>——每个对象拥有一个</strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<p>准确地说，这些属性和方法定义在 Object 的构造器函数 (constructor functions) 之上的<code>prototype</code>属性上，而非对象实例本身。</p>
<p>在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p>
<p><strong>备注：</strong> 理解对象的原型（可以通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf(obj)</code></a>或者已被弃用的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a>属性获得）与构造函数的 <code>prototype</code> 属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，<code>Object.getPrototypeOf(new Foobar())</code> 和 <code>Foobar.prototype</code> 指向着同一个对象。</p>
<h4 id="使用-Javascript-中的原型"><a href="#使用-Javascript-中的原型" class="headerlink" title="使用 Javascript 中的原型"></a>使用 Javascript 中的原型</h4><p>在 javascript 中，函数可以有属性。每个函数都有一个特殊的属性叫作<strong>原型（prototype）</strong>，正如下面所展示的。请注意，下面的代码是独立的一段 (在网页中没有其他代码的情况下，这段代码是安全的)。为了最好的学习体验，你最好打开一个控制台 (在 Chrome 和 Firefox 中，可以按 Ctrl+Shift+I 来打开) 切换到”控制台” 选项卡，复制粘贴下面的 JavaScript 代码，然后按回车来运行。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomething.prototype );<br><span class="hljs-comment">// It does not matter how you declare the function, a</span><br><span class="hljs-comment">//  function in javascript will always have a default</span><br><span class="hljs-comment">//  prototype property.</span><br><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomething.prototype );<br></code></pre></td></tr></table></figure>

<p>正如上面所看到的，<code>doSomething</code> 函数有一个默认的原型属性，它在控制台上面呈现了出来。运行这段代码之后，控制台上面应该出现了像这样的一个对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    constructor: ƒ <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>,<br>    __proto__: &#123;<br>        constructor: ƒ <span class="hljs-constructor">Object()</span>,<br>        hasOwnProperty: ƒ has<span class="hljs-constructor">OwnProperty()</span>,<br>        isPrototypeOf: ƒ is<span class="hljs-constructor">PrototypeOf()</span>,<br>        propertyIsEnumerable: ƒ property<span class="hljs-constructor">IsEnumerable()</span>,<br>        toLocaleString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>,<br>        toString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>,<br>        valueOf: ƒ value<span class="hljs-constructor">Of()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，我们可以添加一些属性到 doSomething 的原型上面，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    foo: <span class="hljs-string">&quot;bar&quot;</span>,<br>    constructor: ƒ <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>,<br>    __proto__: &#123;<br>        constructor: ƒ <span class="hljs-constructor">Object()</span>,<br>        hasOwnProperty: ƒ has<span class="hljs-constructor">OwnProperty()</span>,<br>        isPrototypeOf: ƒ is<span class="hljs-constructor">PrototypeOf()</span>,<br>        propertyIsEnumerable: ƒ property<span class="hljs-constructor">IsEnumerable()</span>,<br>        toLocaleString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>,<br>        toString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>,<br>        valueOf: ƒ value<span class="hljs-constructor">Of()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 <code>doSomething</code> 的实例。正确使用 new 运算符的方法就是在正常调用函数时，在函数名的前面加上一个 <code>new</code> 前缀。通过这种方法，在调用函数前加一个 <code>new</code> ，它就会返回一个这个函数的实例化对象。然后，就可以在这个对象上面添加一些属性。看。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>; <span class="hljs-comment">// add a property onto the prototype</span><br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>; <span class="hljs-comment">// add a property onto the object</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomeInstancing );<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    prop:</span> <span class="hljs-string">&quot;some value&quot;</span>,<br><span class="hljs-symbol">    __proto__:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        foo:</span> <span class="hljs-string">&quot;bar&quot;</span>,<br><span class="hljs-symbol">        constructor:</span> ƒ doSomething(),<br><span class="hljs-symbol">        __proto__:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            constructor:</span> ƒ Object(),<br><span class="hljs-symbol">            hasOwnProperty:</span> ƒ hasOwnProperty(),<br><span class="hljs-symbol">            isPrototypeOf:</span> ƒ isPrototypeOf(),<br><span class="hljs-symbol">            propertyIsEnumerable:</span> ƒ propertyIsEnumerable(),<br><span class="hljs-symbol">            toLocaleString:</span> ƒ toLocaleString(),<br><span class="hljs-symbol">            toString:</span> ƒ toString(),<br><span class="hljs-symbol">            valueOf:</span> ƒ valueOf()<br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>就像上面看到的，<code>doSomeInstancing</code> 的 <code>__proto__</code> 属性就是<code>doSomething.prototype</code>. 但是这又有什么用呢？好吧，当你访问 <code>doSomeInstancing</code> 的一个属性，浏览器首先查找 <code>doSomeInstancing</code> 是否有这个属性。如果 <code>doSomeInstancing</code> 没有这个属性，然后浏览器就会在 <code>doSomeInstancing</code> 的 <code>__proto__</code> 中查找这个属性 (也就是 doSomething.prototype). 如果 doSomeInstancing 的 <code>__proto__</code> 有这个属性，那么 doSomeInstancing 的 <code>__proto__</code> 上的这个属性就会被使用。否则，如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性，浏览器就会去查找 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性。默认情况下，所有函数的原型属性的 <code>__proto__</code> 就是 <code>window.Object.prototype</code>. 所以 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> (也就是 doSomething.prototype 的 <code>__proto__</code> (也就是 <code>Object.prototype</code>)) 会被查找是否有这个属性。如果没有在它里面找到这个属性，然后就会在 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 里面查找。然而这有一个问题：doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 不存在。最后，原型链上面的所有的 <code>__proto__</code> 都被找完了，浏览器所有已经声明了的 <code>__proto__</code> 上都不存在这个属性，然后就得出结论，这个属性是 <code>undefined</code>.</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomeInstancing.prop:      &quot;</span> + doSomeInstancing.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomeInstancing.foo:       &quot;</span> + doSomeInstancing.foo);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prop:           &quot;</span> + doSomething.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.foo:            &quot;</span> + doSomething.foo);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prototype.prop: &quot;</span> + doSomething.prototype.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prototype.foo:  &quot;</span> + doSomething.prototype.foo);<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">doSomeInstancing<span class="hljs-selector-class">.prop</span>:      some value<br>doSomeInstancing<span class="hljs-selector-class">.foo</span>:       bar<br>doSomething<span class="hljs-selector-class">.prop</span>:           undefined<br>doSomething<span class="hljs-selector-class">.foo</span>:            undefined<br>doSomething<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.prop</span>: undefined<br>doSomething<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.foo</span>:  bar<br></code></pre></td></tr></table></figure>

<p><strong>create()</strong></p>
<p>我们曾经讲过如何用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create()</code></a> 方法创建新的对象实例。</p>
<ol>
<li><p>例如，在上个例子的 JavaScript 控制台中输入：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var person2 <span class="hljs-operator">=</span> Object.create(person1)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>create()实际做的是从指定原型对象创建一个新的对象。这里以person1为原型对象创建了person2对象。在控制台输入：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">person2.<span class="hljs-emphasis">__proto__</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>结果返回对象<code>person1</code>。</p>
<h4 id="面向对象编程基本概念"><a href="#面向对象编程基本概念" class="headerlink" title="面向对象编程基本概念"></a>面向对象编程基本概念</h4><p>面向对象编程（OOP）是如今多种编程语言所实现的一种编程范式，包括 Java、C++。在本文中，我们会简要介绍面向对象编程（OOP）的基本概念，其中包括三个主要概念：<strong>类与实例</strong>、<strong>继承</strong>、<strong>封装</strong>。</p>
<p><strong>封装</strong></p>
<p>当其他部分的代码想要执行对象的某些操作时，可以借助对象向外部提供的接口完成操作，借此，对象保持了自身的内部状态不会被外部代码随意修改。也就是说，对象的内部状态保持了私有性，而外部代码只能通过对象所提供的接口访问和修改对象的内部状态，不能直接访问和修改对象的内部状态。保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为<strong>封装</strong>（encapsulation）。</p>
<p>封装的好处在于，当程序员需要修改一个对象的某个操作时，程序员只需要修改对象对应方法的内部实现即可，而不需要在所有代码中找出该方法的所有实现，并逐一修改。某种意义上来说，封装在对象内部和对象外部设立了一种特别的“防火墙”。</p>
<h3 id="3-6-异步javascript"><a href="#3-6-异步javascript" class="headerlink" title="3.6 异步javascript"></a>3.6 异步javascript</h3><p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p>
<p>浏览器提供的许多功能（尤其是最有趣的那一部分）可能需要很长的时间来完成，因此需要异步完成，例如：</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 发起 HTTP 请求</li>
<li>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia"><code>getUserMedia()</code></a> 访问用户的摄像头和麦克风</li>
<li>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker"><code>showOpenFilePicker()</code> (en-US)</a> 请求用户选择文件以供访问</li>
</ul>
<p>因此，即使你可能不需要经常<em>实现</em>自己的异步函数，你也很可能需要<em>正确使用</em>它们。</p>
<p>在这篇文章中，我们将从同步函数长时间运行时存在的问题开始，并以此进一步认识异步编程的必要性。</p>
<p>事件处理程序实际上就是异步编程的一种形式：你提供的函数（事件处理程序）将在事件发生时被调用（而不是立即被调用）。如果“事件”是“异步操作已经完成”，那么你就可以看到事件如何被用来通知调用者异步函数调用的结果的。</p>
<p>一些早期的异步 API 正是以这种方式来使用事件的。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API 可以让你用 JavaScript 向远程服务器发起 HTTP 请求。由于这样的操作可能需要很长的时间，所以它被设计成异步 API，你可以通过给 <code>XMLHttpRequest</code> 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。</p>
<p>下面的例子展示了这样的操作。点击“点击发起请求”按钮来发送一个请求。我们将创建一个新的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 并监听它的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadend_event"><code>loadend</code></a> 事件。而我们的事件处理程序则会在控制台中输出一个“完成！”的消息和请求的状态代码。</p>
<p>我们在添加了事件监听器后发送请求。注意，在这之后，我们仍然可以在控制台中输出“请求已发起”，也就是说，我们的程序可以在请求进行的同时继续运行，而我们的事件处理程序将在请求完成时被调用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xhr&quot;</span>&gt;</span>点击发起请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reload&quot;</span>&gt;</span>重载<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;event-log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> log = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.event-log&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#xhr&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>  xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;loadend&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    log.<span class="hljs-property">textContent</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;log.textContent&#125;</span>完成！状态码：<span class="hljs-subst">$&#123;xhr.status&#125;</span>`</span>;<br>  &#125;);<br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json&#x27;</span>);<br>  xhr.<span class="hljs-title function_">send</span>();<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;log.textContent&#125;</span>请求已发起\n`</span>;&#125;);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="事件处理程序 sample" id="frame_事件处理程序" width="600" height="120" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing/_sample_.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe>



<p>这就像我们在以前的模块中遇到的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件处理程序</a>，只是这次的事件不是像点击按钮那样的用户行为，而是某个对象的状态变化。</p>
<h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。正如我们刚刚所看到的：回调函数曾经是 JavaScript 中实现异步函数的主要方式。</p>
<p>然而，当回调函数本身需要调用其他同样接受回调函数的函数时，基于回调的代码会变得难以理解。当你需要执行一些分解成一系列异步函数的操作时，这将变得十分常见。例如下面这种情况：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">doStep1</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doStep2</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doStep3</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doOperation</span>() &#123;<br>  let result = 0;<br>  result = doStep1(result);<br>  result = doStep2(result);<br>  result = doStep3(result);<br>  console.log(`结果：$&#123;result&#125;`);<br>&#125;<br>doOperation();<br></code></pre></td></tr></table></figure>

<p>现在我们有一个被分成三步的操作，每一步都依赖于上一步。在这个例子中，第一步给输入的数据加 1，第二步加 2，第三步加 3。从输入 0 开始，最终结果是 6（0+1+2+3）。作为同步代码，这很容易理解。但是如果我们用回调来实现这些步骤呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep1</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">1</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep2</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">2</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep3</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">3</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doOperation</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">doStep1</span>(<span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-params">result1</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">doStep2</span>(result1, <span class="hljs-function"><span class="hljs-params">result2</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">doStep3</span>(result2, <span class="hljs-function"><span class="hljs-params">result3</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`结果：<span class="hljs-subst">$&#123;result3&#125;</span>`</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br><span class="hljs-title function_">doOperation</span>();<br></code></pre></td></tr></table></figure>

<p>因为必须在回调函数中调用回调函数，我们就得到了这个深度嵌套的 <code>doOperation()</code> 函数，这就更难阅读和调试了。在一些地方这被称为“回调地狱”或“厄运金字塔”（因为缩进看起来像一个金字塔的侧面）。</p>
<p>面对这样的嵌套回调，处理错误也会变得非常困难：你必须在“金字塔”的每一级处理错误，而不是在最高一级一次完成错误处理。</p>
<p>由于以上这些原因，大多数现代异步 API 都不使用回调。事实上，JavaScript 中异步编程的基础是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>，这也是我们下一篇文章要讲述的主题。</p>
<h4 id="如何使用promise"><a href="#如何使用promise" class="headerlink" title="如何使用promise"></a>如何使用promise</h4><p><strong>Promise</strong> 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。</p>
<h4 id="使用-fetch-API"><a href="#使用-fetch-API" class="headerlink" title="使用 fetch() API"></a>使用 fetch() API</h4><p>要做到这一点，我们将向服务器发出一个 <strong>HTTP 请求</strong>。在 HTTP 请求中，我们向远程服务器发送一个请求信息，然后它向我们发送一个响应。这次，我们将发送一个请求，从服务器上获得一个 JSON 文件。还记得在上一篇文章中，我们使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API 进行 HTTP 请求吗？那么，在这篇文章中，我们将使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> API，一个现代的、基于 Promise 的、用于替代 <code>XMLHttpRequest</code> 的方法。</p>
<p>把下列代码复制到你的浏览器 JavaScript 控制台中：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fetchPromise);<br><br>fetchPromise.then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`已收到响应：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;已发送请求……&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>我们在这里：</p>
<ol>
<li>调用 <code>fetch()</code> API，并将返回值赋给 <code>fetchPromise</code> 变量。</li>
<li>紧接着，输出 <code>fetchPromise</code> 变量，输出结果应该像这样：<code>Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;</code>。这告诉我们有一个 <code>Promise</code> 对象，它有一个 <code>state</code>属性，值是 <code>&quot;pending&quot;</code>。<code>&quot;pending&quot;</code> 状态意味着操作仍在进行中。</li>
<li>将一个处理函数传递给 Promise 的 <strong><code>then()</code></strong> 方法。当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象。</li>
<li>输出一条信息，说明我们已经发送了这个请求。</li>
</ol>
<p>完整的输出结果应该是这样的：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span> &#123; &lt;state&gt;: <span class="hljs-string">&quot;pending&quot;</span> &#125;<br>已发送请求……<br>已收到响应：<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure>

<p>请注意，<code>已发送请求……</code> 的消息在我们收到响应之前就被输出了。与同步函数不同，<code>fetch()</code> 在请求仍在进行时返回，这使我们的程序能够保持响应性。响应显示了 <code>200</code>（OK）的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">状态码</a>，意味着我们的请求成功了。</p>
<p>可能这看起来很像上一篇文章中的例子中我们把事件处理程序添加到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象中。但不同的是，我们这一次将处理程序传递到返回的 Promise 对象的 <code>then()</code> 方法中。</p>
<h4 id="链式使用-Promise"><a href="#链式使用-Promise" class="headerlink" title="链式使用 Promise"></a>链式使用 Promise</h4><p>在你通过 <code>fetch()</code> API 得到一个 <code>Response</code> 对象的时候，你需要调用另一个函数来获取响应数据。这次，我们想获得 JSON 格式的响应数据，所以我们会调用 <code>Response</code> 对象的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json"><code>json()</code></a> 方法。事实上，<code>json()</code> 也是异步的，因此我们必须连续调用两个异步函数。</p>
<p>试试这个：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise.then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  const jsonPromise = response.json();<br>  jsonPromise.then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在这个示例中，就像我们之前做的那样，我们给 <code>fetch()</code> 返回的 Promise 对象添加了一个 <code>then()</code> 处理程序。但这次我们的处理程序调用 <code>response.json()</code> 方法，然后将一个新的 <code>then()</code> 处理程序传递到 <code>response.json()</code> 返回的 Promise 中。</p>
<p>执行代码后应该会输出“baked beans”（“products.json”中第一个产品的名称）。</p>
<p>等等！还记得上一篇文章吗？我们好像说过，在回调中调用另一个回调会出现多层嵌套的情况？我们是不是还说过，这种“回调地狱”使我们的代码难以理解？这不是也一样吗，只不过变成了用 <code>then()</code> 调用而已？</p>
<p>当然如此。但 Promise 的优雅之处在于 <em><code>then()</code> 本身也会返回一个 Promise，这个 Promise 将指示 <code>then()</code> 中调用的异步函数的完成状态</em>。这意味着我们可以（当然也应该）把上面的代码改写成这样：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>不必在第一个 <code>then()</code> 的处理程序中调用第二个 <code>then()</code>，我们可以直接<em>返回</em> <code>json()</code> 返回的 Promise，并在该返回值上调用第二个 “then()”。这被称为 <strong>Promise 链</strong>，意味着当我们需要连续进行异步函数调用时，我们就可以避免不断嵌套带来的缩进增加。</p>
<p>在进入下一步之前，还有一件事要补充：我们需要在尝试读取请求之前检查服务器是否接受并处理了该请求。我们将通过检查响应中的状态码来做到这一点，如果状态码不是“OK”，就抛出一个错误：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.ok) &#123;<br>      throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">`HTTP error: <span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><p>这给我们带来了最后一个问题：我们如何处理错误？<code>fetch()</code> API 可能因为很多原因抛出错误（例如，没有网络连接或 URL 本身存在问题），我们也会在服务器返回错误消息时抛出一个错误。</p>
<p>在上一篇文章中，我们看到在嵌套回调中进行错误处理非常困难，我们需要在每一个嵌套层中单独捕获错误。</p>
<p><code>Promise</code> 对象提供了一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>catch()</code></a> 方法来支持错误处理。这很像 <code>then()</code>：你调用它并传入一个处理函数。然后，当异步操作<em>成功</em>时，传递给 <code>then()</code> 的处理函数被调用，而当异步操作<em>失败</em>时，传递给 <code>catch()</code> 的处理函数被调用。</p>
<p>如果将 <code>catch()</code> 添加到 Promise 链的末尾，它就可以在任何异步函数失败时被调用。于是，我们就可以将一个操作实现为几个连续的异步函数调用，并在一个地方处理所有错误。</p>
<p>试试这个版本的 <code>fetch()</code> 代码。我们使用 <code>catch()</code> 添加了一个错误处理函数，并修改了 URL（这样请求就会失败）。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.ok) &#123;<br>      throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;)<br>  .catch( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>尝试运行这个版本：你应该会看到 <code>catch()</code> 处理函数输出的错误。</p>
<h4 id="Promise-术语"><a href="#Promise-术语" class="headerlink" title="Promise 术语"></a>Promise 术语</h4><p>Promise 中有一些具体的术语值得我们弄清楚。</p>
<p>首先，Promise 有三种状态：</p>
<ul>
<li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。这是调用 <code>fetch()</code> 返回 Promise 时的状态，此时请求还在进行中。</li>
<li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。当 Promise 完成时，它的 <code>then()</code> 处理函数被调用。</li>
<li><strong>已拒绝（rejected）</strong>：意味着操作失败。当一个 Promise 失败时，它的 <code>catch()</code> 处理函数被调用。</li>
</ul>
<p>注意，这里的“成功”或“失败”的含义取决于所使用的 API：例如，<code>fetch()</code> 认为服务器返回一个错误（如<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404">404 Not Found</a>）时请求成功，但如果网络错误阻止请求被发送，则认为请求失败。</p>
<p>有时我们用 <strong>已敲定（settled）</strong> 这个词来同时表示 <strong>已兑现（fulfilled）</strong> 和 <strong>已拒绝（rejected）</strong> 两种情况。</p>
<p>如果一个 Promise 处于已决议（resolved）状态，或者它被“锁定”以跟随另一个 Promise 的状态，那么它就是 <strong>已兑现（fulfilled）</strong>。</p>
<p>文章 <a target="_blank" rel="noopener" href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/">Let’s talk about how to talk about promises</a> 对这些术语的细节做了很好的解释。</p>
<h4 id="合并使用多个-Promise"><a href="#合并使用多个-Promise" class="headerlink" title="合并使用多个 Promise"></a>合并使用多个 Promise</h4><p>当你的操作由几个异步函数组成，而且你需要在开始下一个函数之前完成之前每一个函数时，你需要的就是 Promise 链。但是在其他的一些情况下，你可能需要合并多个异步函数的调用，<code>Promise</code> API 为解决这一问题提供了帮助。</p>
<p>有时你需要所有的 Promise 都得到实现，但它们并不相互依赖。在这种情况下，将它们一起启动然后在它们全部被兑现后得到通知会更有效率。这里需要 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> 方法。它接收一个 Promise 数组，并返回一个单一的 Promise。</p>
<p>由<code>Promise.all()</code>返回的 Promise：</p>
<ul>
<li>当且仅当数组中<em>所有</em>的 Promise 都被兑现时，才会通知 <code>then()</code> 处理函数并提供一个包含所有响应的数组，数组中响应的顺序与被传入 <code>all()</code> 的 Promise 的顺序相同。</li>
<li>会被拒绝——如果数组中有<em>任何一个</em> Promise 被拒绝。此时，<code>catch()</code> 处理函数被调用，并提供被拒绝的 Promise 所抛出的错误。</li>
</ul>
<p>譬如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise3 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> response <span class="hljs-keyword">of</span> responses) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>这里我们向三个不同的 URL 发出三个 <code>fetch()</code> 请求。如果它们都被兑现了，我们将输出每个请求的响应状态。如果其中任何一个被拒绝了，我们将输出失败的情况。</p>
<p>根据我们提供的 URL，应该所有的请求都会被兑现，尽管因为第二个请求中请求的文件不存在，服务器将返回 <code>404</code>（Not Found）而不是 <code>200</code>（OK）。所以输出应该是：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/apis/</span>fetching-data<span class="hljs-regexp">/can-store/</span>products.json：<span class="hljs-number">200</span><br>https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/apis/</span>fetching-data<span class="hljs-regexp">/can-store/</span>not-found：<span class="hljs-number">404</span><br>https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/oojs/</span>json/superheroes.json：<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure>

<p>如果我们用一个错误编码的 URL 尝试同样的代码，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise3 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> response <span class="hljs-keyword">of</span> responses) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>……然后 <code>catch()</code> 处理程序将被运行，我们应该看到像这样的输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">获取失败：TypeError: Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">fetch</span><br></code></pre></td></tr></table></figure>

<p>有时，你可能需要等待一组 Promise 中的某一个 Promise 的执行，而不关心是哪一个。在这种情况下，你需要 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any()</code></a>。这就像 <code>Promise.all()</code>，不过在 Promise 数组中的任何一个被兑现时它就会被兑现，如果所有的 Promise 都被拒绝，它也会被拒绝。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise1 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>const fetchPromise2 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br>const fetchPromise3 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br>Promise.<span class="hljs-built_in">any</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>  &#125;)<br>  .catch( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>值得注意的是，在这种情况下，我们无法预测哪个获取请求会先被兑现。</p>
<p>这两个用于组合多个承诺的函数只是额外的 <code>Promise</code> 函数中的两个。要了解其余的内容，参见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 参考文档。</p>
<h4 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code></a> 关键字为你提供了一种更简单的方法来处理基于异步 Promise 的代码。在一个函数的开头添加 <code>async</code>，就可以使其成为一个异步函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> function <span class="hljs-title">myFunction</span>()</span> &#123;<br>  <span class="hljs-comment">// 这是一个异步函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在异步函数中，你可以在调用一个返回 Promise 的函数之前使用 <code>await</code> 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p>
<p>这使你能够编写像同步代码一样的异步函数。例如，我们可以用它来重写我们的 fetch 示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span><br>    <span class="hljs-comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span><br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span><br>    <span class="hljs-comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span><br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchProducts</span>();<br></code></pre></td></tr></table></figure>

<p>这里我们调用 <code>await fetch()</code>，我们的调用者得到的并不是 <code>Promise</code>，而是一个完整的 <code>Response</code> 对象，就好像 <code>fetch()</code> 是一个同步函数一样。</p>
<p>我们甚至可以使用 <code>try...catch</code> 块来处理错误，就像我们在写同步代码时一样。</p>
<p>但请注意，这个写法只在异步函数中起作用。异步函数总是返回一个 Pomise，所以你不能做这样的事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> json = <span class="hljs-title function_">fetchProducts</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);   <span class="hljs-comment">// json 是一个 Promise 对象，因此这句代码无法正常工作</span><br></code></pre></td></tr></table></figure>

<p>相反，你需要做一些事情，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> jsonPromise = <span class="hljs-title function_">fetchProducts</span>();<br>jsonPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>));<br></code></pre></td></tr></table></figure>

<p>你可能会在需要使用 Promise 链地方使用 <code>async</code> 函数，这也使得 Promise 的工作更加直观。</p>
<p>请记住，就像一个 Promise 链一样，<code>await</code> 强制异步操作以串联的方式完成。如果下一个操作的结果取决于上一个操作的结果，这是必要的，但如果不是这样，像 <code>Promise.all()</code> 这样的操作会有更好的性能。</p>
<h3 id="3-7-实现基于Promise的API"><a href="#3-7-实现基于Promise的API" class="headerlink" title="3.7 实现基于Promise的API"></a>3.7 实现基于Promise的API</h3><p>通常情况下，当你实现一个基于 promise 的 API 时，你会使用事件、普通回调，或者消息传递模型来包裹一个异步操作。你将会使用一个 <code>Promise</code> 对象来合理的处理操作的成功或者失败。</p>
<h4 id="实现-alarm-API"><a href="#实现-alarm-API" class="headerlink" title="实现 alarm() API"></a>实现 alarm() API</h4><p>在这个示例中我们将会实现一个基于 promise 的 alarm API，叫做 <code>alarm()</code> 。它将以被唤醒人的名字和一个在人被唤醒前以毫秒为单位的延迟作为参数。在延迟之后，本函数将会发送一个包含需要被唤醒人名字的 “Wake up!” 消息。</p>
<h4 id="用-setTimeout-包裹"><a href="#用-setTimeout-包裹" class="headerlink" title="用 setTimeout() 包裹"></a>用 setTimeout() 包裹</h4><p>我们将会使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout"><code>setTimeout()</code></a> 来实现 <code>alarm()</code> 函数。<code>setTimeout()</code> 以一个回调函数和一个以毫秒为单位的延迟作为参数。当调用 <code>setTimeout()</code> 时，它将启动一个设置为给定延迟的计时器，当时间过期时，它就会调用给定的回调函数。</p>
<p>在下面的例子中，我们使用一个回调函数和一个 1000 毫秒的延迟调用 <code>setTimeout()</code>：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;button <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;set-alarm&quot;</span>&gt;Set alarm&lt;/button&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setAlarm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    output.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Wake up!&#x27;</span>;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, setAlarm);<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="用 setTimeout() 包裹 sample" id="frame_用_settimeout_包裹" width="600" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E7%94%A8_settimeout_%E5%8C%85%E8%A3%B9.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h4 id="Promise-构造器"><a href="#Promise-构造器" class="headerlink" title="Promise() 构造器"></a>Promise() 构造器</h4><p>我们的 <code>alarm()</code> 函数返回一个在定时器过期时才会被兑现的 <code>Promise</code>。它将会传递一个 “Wake up!” 消息到 <code>then()</code> 处理器中，也会在当调用者提供一个负延迟值时拒绝这个 promise。</p>
<p>这里的关键组件是 <code>Promise()</code> 构造器。<code>Promise()</code> 构造器使用单个函数作为参数。我们把这个函数称作<code>执行器</code>（executor）。当你创建一个新的 promise 的时候你需要实现这个执行器。</p>
<p>这个执行器本身采用两个参数，这两个参数都是函数，通常被称作 <code>resolve</code> 和 <code>reject</code>。在你的执行器实现里，你调用原始的异步函数。如果异步函数成功了，就调用 <code>resolve</code>，如果失败了，就调用 <code>reject</code>。如果执行器函数抛出了一个错误，<code>reject</code> 会被自动调用。你可以将任何类型的单个参数传递到 <code>resolve</code> 和 <code>reject</code> 中。</p>
<p>所以我们可以像下面这样实现 <code>alarm()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此函数创建并且返回一个新的 <code>Promise</code>。对于执行器中的 promise，我们：</p>
<ul>
<li>检查 <code>delay</code>（延迟）是否为负数，如果是的话就抛出一个错误。</li>
<li>调用 <code>window.setTimeout()</code>，传递一个回调函数和 <code>delay</code>（延迟）。当计时器过期时回调会被调用，在回调函数内，我们调用了 <code>resolve</code>，并且传递了 <code>&quot;Wake up!&quot;</code> 消息。</li>
</ul>
<h4 id="使用-alarm-API"><a href="#使用-alarm-API" class="headerlink" title="使用 alarm() API"></a>使用 alarm() API</h4><p>这一部分同上一篇文章是相当相似的。我们可以调用 <code>alarm()</code>，在返回的 promise 中调用 <code>then()</code> 和 <code>catch()</code> 来设置 promise 兑现和拒绝状态的处理器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#name&#x27;</span>);<br><span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#delay&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">alarm</span>(name.<span class="hljs-property">value</span>, delay.<span class="hljs-property">value</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> output.<span class="hljs-property">textContent</span> = message)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> output.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Couldn&#x27;t set alarm: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="使用 alarm() API sample" id="frame_使用_alarm_api" width="600" height="160" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E4%BD%BF%E7%94%A8_alarm_api.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<p>尝试对 “Name” 和 “Delay” 设置不同的值。尝试为 “Delay” 设置一个负值。</p>
<h4 id="在-alarm-API-上使用-async-和-await"><a href="#在-alarm-API-上使用-async-和-await" class="headerlink" title="在 alarm() API 上使用 async 和 await"></a>在 alarm() API 上使用 async 和 await</h4><p>自从 <code>alarm()</code> 返回了一个 <code>Promise</code>，我们可以对它做任何我们可以对其他任何 promise 做的事情：<code>Promise.all()</code>，和 <code>async</code> &#x2F; <code>await</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#name&#x27;</span>);<br><span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#delay&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> message = <span class="hljs-keyword">await</span> <span class="hljs-title function_">alarm</span>(name.<span class="hljs-property">value</span>, delay.<span class="hljs-property">value</span>);<br>    output.<span class="hljs-property">textContent</span> = message;<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (error) &#123;<br>    output.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Couldn&#x27;t set alarm: <span class="hljs-subst">$&#123;error&#125;</span>`</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<iframe class="sample-code-frame" title="在 alarm() API 上使用 async 和 await sample" id="frame_在_alarm_api_上使用_async_和_await" width="600" height="160" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E5%9C%A8_alarm_api_%E4%B8%8A%E4%BD%BF%E7%94%A8_async_%E5%92%8C_await.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe>

<h3 id="3-8-workers简介"><a href="#3-8-workers简介" class="headerlink" title="3.8 workers简介"></a>3.8 workers简介</h3><p>在”异步 JavaScript” 模块的最后一篇文章中，我们将介绍 workers，它使您能够在单独执行 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Thread">线程</a> 中运行一些任务。</p>
<p>在本模块的第一篇文章中，我们看到了当在你的程序中具有一个长期运行的的同步任务时发生了什么 ── 整个窗口变得完全没有响应。从根本上讲，出现这种情况的原因是程序是单线程的。一个线程是程序遵循的一系列指令。因为程序由一个线程组成，它在同一时间只能做一件事情：所以如果它正在等待我们的长期运行的同步调用返回，它就不能做其他任何事情。</p>
<p>Workers 给了你在不同线程中运行某些任务的能力，因此你可以启动任务，然后继续其他的处理（例如处理用户操作）。</p>
<p>但是这是要付出代价的。对于多线程代码，你永远不知道你的线程什么时候将会被挂起，其他线程将会得到运行的机会。因此，如果两个线程都可以访问相同的变量，那么变量就有可能在任何时候发生意外的变化，这将导致很难发现的 Bug。</p>
<p>为了避免 Web 中的这些问题，你的主代码和你的 worker 代码永远不能直接访问彼此的变量。Workers 和主代码运行在完全分离的环境中，只有通过相互发送消息来进行交互。特别是，这意味着 workers 不能访问 DOM（窗口、文档、页面元素等等）。</p>
<p>有三种不同类型的 workers：</p>
<ul>
<li>dedicated workers</li>
<li>shared workers</li>
<li>service workers</li>
</ul>
<p>在本文中，我们将介绍第一类 workers 的一个例子，然后简要的讨论另外两类。</p>
<h4 id="使用-web-workers"><a href="#使用-web-workers" class="headerlink" title="使用 web workers"></a>使用 web workers</h4><p>还记得在第一篇文章中，我们有一个计算质数的页面吗？我们将使用一个 worker 来运行质数运算，因此我们的页面对用户操作保持响应。</p>
<h4 id="同步的质数生成器"><a href="#同步的质数生成器" class="headerlink" title="同步的质数生成器"></a>同步的质数生成器</h4><p>让我们先看一下我们上一个例子中的 JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePrimes</span>(<span class="hljs-params">quota</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">2</span>; c &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n); ++c) &#123;<br>      <span class="hljs-keyword">if</span> (n % c === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> primes = [];<br>  <span class="hljs-keyword">const</span> maximum = <span class="hljs-number">1000000</span>;<br><br>  <span class="hljs-keyword">while</span> (primes.<span class="hljs-property">length</span> &lt; quota) &#123;<br>    <span class="hljs-keyword">const</span> candidate = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (maximum + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(candidate)) &#123;<br>      primes.<span class="hljs-title function_">push</span>(candidate);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> primes;<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#generate&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> quota = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#quota&#x27;</span>).<span class="hljs-property">value</span>;<br>  <span class="hljs-keyword">const</span> primes = <span class="hljs-title function_">generatePrimes</span>(quota);<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">`Finished generating <span class="hljs-subst">$&#123;quota&#125;</span> primes!`</span>;<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#user-input&#x27;</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Try typing in here immediately after pressing &quot;Generate primes&quot;&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在这个程序中，在我们调用 <code>generatePrimes()</code> 之后，程序变得完全没有响应。</p>
<h4 id="用-worker-进行质数生成"><a href="#用-worker-进行质数生成" class="headerlink" title="用 worker 进行质数生成"></a>用 worker 进行质数生成</h4><p>在这个例子中，首先在 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/start">https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/start</a> 将文件拷贝到本地。在这个目录下有四个文件：</p>
<ul>
<li>index.html</li>
<li>style.css</li>
<li>main.js</li>
<li>generate.js</li>
</ul>
<p>“index.html” 文件和 “style.css” 文件已完成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span><span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;quota&quot;</span>&gt;</span>Number of primes:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;quota&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;quota&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1000000&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;generate&quot;</span>&gt;</span>Generate primes<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reload&quot;</span>&gt;</span>Reload<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user-input&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;62&quot;</span>&gt;</span>Try typing in here immediately after pressing &quot;Generate primes&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>“main.js” 和 “generate.js” 文件是空的。我们将向 “main.js” 中添加主代码，向 “generate.js” 中添加 worker 代码。</p>
<p>首先，我们可以看到 worker 代码被保存在一个与主代码隔离的脚本中。我们还可以看到，在上面的 “index.html” 中，只有主代码被包含在 <code>&lt;script&gt;</code> 标签中。</p>
<p>现在将下面的代码拷贝到 “main.js”中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 在 &quot;generate.js&quot; 中创建一个新的 worker</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;./generate.js&#x27;</span>);<br><br><span class="hljs-comment">// 当用户点击 &quot;Generate primes&quot; 时，给 worker 发送一条消息。</span><br><span class="hljs-comment">// 消息中的 command 属性是 &quot;generate&quot;, 还包含另外一个属性 &quot;quota&quot;，即要生成的质数。</span><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#generate&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> quota = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#quota&#x27;</span>).value;<br>  worker.postMessage(&#123;<br>    command: <span class="hljs-string">&#x27;generate&#x27;</span>,<br>    quota: quota<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 当 worker 给主线程回发一条消息时，为用户更新 output 框，包含生成的质数（从 message 中获取）。</span><br>worker.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, message =&gt; &#123;<br>  <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>).textContent = `Finished generating $&#123;message.data&#125; primes!`;<br>&#125;);<br><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#user-input&#x27;</span>).value = <span class="hljs-string">&#x27;Try typing in here immediately after pressing &quot;Generate primes&quot;&#x27;</span>;<br>  <span class="hljs-built_in">document</span>.location.reload();<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>首先，我们使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker"><code>Worker()</code></a> 构造函数创建 worker。我们传递一个指向 worker 脚本的 URL。只要 worker 被创建了，woker 脚本就会执行。</li>
<li>其次，与同步版本一样，我们向 “Generate primes” 按钮添加一个click事件处理器。但是现在，我们不再调用generatePrimes()函数，而是使用<code>worker.postMessage()</code>向 worker 发送一条消息。这条消息可以携带一个参数，在本示例中我们传递一个包含两个属性的 JSON 对象：<ul>
<li><code>command</code>：一个用于标识我们希望 worker 所做事情的字符串（以防我们的 worker 可以做多个事情）。</li>
<li><code>quota</code>：要生成的质数的数量。</li>
</ul>
</li>
<li>然后，我们向 worker 添加一个 <code>message</code> 消息处理器。这样 worker 就能告诉我们它是什么时候完成的，并且传递给我们任何结果数据。我们的处理器从消息的 <code>data</code> 属性获取数据，然后将其写入 output 元素（数据与 <code>quota</code> 是完全相同的，这虽然没有意义，但是这展示了其中原理）。</li>
<li>最后，我们为 “Reload” 按钮实现了 <code>click</code> 事件处理器。这与同步版本完全相同。</li>
</ul>
<p>现在到 worker 代码了。拷贝下面的代码到 “generate.js” 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听主线程中的消息。</span><br><span class="hljs-comment">// 如果消息中的 command 是 &quot;generate&quot;，则调用 `generatePrimse()`</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (message.<span class="hljs-property">data</span>.<span class="hljs-property">command</span> === <span class="hljs-string">&#x27;generate&#x27;</span>) &#123;<br>    <span class="hljs-title function_">generatePrimes</span>(message.<span class="hljs-property">data</span>.<span class="hljs-property">quota</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 生成质数 (非常低效)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePrimes</span>(<span class="hljs-params">quota</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">2</span>; c &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n); ++c) &#123;<br>      <span class="hljs-keyword">if</span> (n % c === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> primes = [];<br>  <span class="hljs-keyword">const</span> maximum = <span class="hljs-number">1000000</span>;<br><br>  <span class="hljs-keyword">while</span> (primes.<span class="hljs-property">length</span> &lt; quota) &#123;<br>    <span class="hljs-keyword">const</span> candidate = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (maximum + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(candidate)) &#123;<br>      primes.<span class="hljs-title function_">push</span>(candidate);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 完成后给主线程发送一条包含我们生成的质数数量的消息消息。</span><br>  <span class="hljs-title function_">postMessage</span>(primes.<span class="hljs-property">length</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>请记住，只要主脚本创建 worker，这些代码就会运行。</p>
<p>worker 要做的第一件事情就是开始监听来自主脚本的消息。这通过使用 <code>addEventListener()</code> 实现，它在 worker 中是一个全局函数。在 <code>message</code> 事件处理器内部，事件的 <code>data</code> 属性包含一个来自主脚本的参数的副本。如果主脚本传递 <code>generate</code> 命令，我们就调用 <code>generatePrimes()</code>，传入来自消息事件的 <code>quota</code> 值。</p>
<p><code>generatePrimes()</code> 函数与同步版本类似，只不过我们在完成后向主脚本发送一条消息，而不是返回一个值。我们对此使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/postMessage"><code>postMessage()</code> (en-US)</a> 函数，就像在 worker 中 <code>addEventListener</code>是全局函数一样。如我们所见，主脚本正在监听这条消息并且将会在收到消息后更新 DOM。</p>
<p><strong>备注：</strong> 要运行此站点，你必须运行一个本地 web 服务器，因为 file:&#x2F;&#x2F; URLs 不允许加载 workers。参考我们的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Tools_and_setup/set_up_a_local_testing_server">设置一个本地测试服务器</a>的指导。完成后，你应该可以点击 “Generate primes” 并且使你的主页面保持响应。 如果你在创建和运行这个样例的过程中有疑问，你可以在 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished">https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished</a> 查看完成后的版本，并且在 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished">https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished</a> 进行在线尝试。</p>
<h4 id="其他类型的-worker"><a href="#其他类型的-worker" class="headerlink" title="其他类型的 worker"></a>其他类型的 worker</h4><p>我们刚刚创建的 worker 被称为 <em>dedicated worker</em>。这意味着它由一个脚本实例使用。</p>
<p>不过，还有其他类型的 worker：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker"><code>SharedWorker</code></a> 可以由运行在不同窗口中的多个不同脚本共享。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API"><em>Service worker</em></a> 的行为就像代理服务器，缓存资源以便于 web 应用程序可以在用户离线时工作。他们是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps">渐进式 Web 应用</a>的关键组件。</li>
</ul>
<h3 id="3-9-客户端web-api简介"><a href="#3-9-客户端web-api简介" class="headerlink" title="3.9 客户端web api简介"></a>3.9 客户端web api简介</h3><h4 id="API-可以做什么？"><a href="#API-可以做什么？" class="headerlink" title="API 可以做什么？"></a>API 可以做什么？</h4><p>在主流浏览器中有大量的可用 API，您可以在代码中做许多的事情，对此可以查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN API index page</a>。</p>
<h4 id="常见浏览器-API"><a href="#常见浏览器-API" class="headerlink" title="常见浏览器 API"></a>常见浏览器 API</h4><p>特别地，您将使用的最常见的浏览器 API 类别（以及我们将更详细地介绍的）是：</p>
<ul>
<li><strong>操作文档的 API</strong>内置于浏览器中。最明显的例子是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">DOM（文档对象模型）</a>API，它允许您操作 HTML 和 CSS — 创建、移除以及修改 HTML，动态地将新样式应用到您的页面，等等。每当您看到一个弹出窗口出现在一个页面上，或者显示一些新的内容时，这都是 DOM 的行为。您可以在在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents">Manipulating documents</a>中找到关于这些类型的 API 的更多信息。</li>
<li><strong>从服务器获取数据的 API</strong> 用于更新网页的一小部分是相当好用的。这个看似很小的细节能对网站的性能和行为产生巨大的影响 — 如果您只是更新一个股票列表或者一些可用的新故事而不需要从服务器重新加载整个页面将使网站或应用程序感觉更加敏感和“活泼”。使这成为可能的 API 包括<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a>。您也可能会遇到描述这种技术的术语<strong>Ajax</strong>。您可以在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data">Fetching data from the server</a>找到关于类似的 API 的更多信息。</li>
<li><strong>用于绘制和操作图形的 API</strong>目前已被浏览器广泛支持 — 最流行的是允许您以编程方式更新包含在 HTML <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas"><code>canvas</code></a> 元素中的像素数据以创建 2D 和 3D 场景的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">Canvas</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API">WebGL</a>。例如，您可以绘制矩形或圆形等形状，将图像导入到画布上，然后使用 Canvas API 对其应用滤镜（如棕褐色滤镜或灰度滤镜），或使用 WebGL 创建具有光照和纹理的复杂 3D 场景。这些 API 经常与用于创建动画循环的 API（例如<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame"><code>window.requestAnimationFrame()</code></a>）和其他 API 一起不断更新诸如动画和游戏之类的场景。</li>
<li><strong>音频和视频 API</strong> 例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">Web Audio API</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API">WebRTC</a> 允许你使用多媒体来做一些非常有趣的事情，比如创建用于播放音频和视频的自定义 UI 控件，显示字幕字幕和你的视频，从网络摄像机抓取视频，通过画布操纵（见上），或在网络会议中显示在别人的电脑上，或者添加效果到音轨（如增益、失真、平移等） 。</li>
<li><strong>设备 API</strong>基本上是以对网络应用程序有用的方式操作和检索现代设备硬件中的数据的 API。我们已经讨论过访问设备位置数据的地理定位 API，因此您可以在地图上标注您的位置。其他示例还包括通过系统通知（参见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Notifications_API">Notifications API</a>）或振动硬件（参见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Vibration_API">Vibration API</a>）告诉用户 Web 应用程序有用的更新可用。</li>
<li><strong>客户端存储 API</strong>在 Web 浏览器中的使用变得越来越普遍 - 如果您想创建一个应用程序来保存页面加载之间的状态，甚至让设备在处于脱机状态时可用，那么在客户端存储数据将会是非常有用的。例如使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a>的简单的键 - 值存储以及使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>的更复杂的表格数据存储。</li>
</ul>
<h4 id="x3D-x3D-常见第三方-API-x3D-x3D"><a href="#x3D-x3D-常见第三方-API-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;常见第三方 API&#x3D;&#x3D;"></a>&#x3D;&#x3D;常见第三方 API&#x3D;&#x3D;</h4><p>第三方 API 种类繁多; 下列是一些比较流行的你可能迟早会用到的第三方 API:</p>
<ul>
<li>The <a target="_blank" rel="noopener" href="https://dev.twitter.com/overview/documentation">Twitter API</a>, 允许您在您的网站上展示您最近的推文等。</li>
<li>The <a target="_blank" rel="noopener" href="https://developers.google.com/maps/">Google Maps API</a> 允许你在网页上对地图进行很多操作（这很有趣，它也是 Google 地图的驱动器）。现在它是一整套完整的，能够胜任广泛任务的 API。其能力已经被<a target="_blank" rel="noopener" href="https://developers.google.com/maps/documentation/api-picker">Google Maps API Picker</a>见证。</li>
<li>The <a target="_blank" rel="noopener" href="https://developers.facebook.com/docs/">Facebook suite of API</a> 允许你将很多 Facebook 生态系统中的功能应用到你的 app，使之受益，比如说它提供了通过 Facebook 账户登录、接受应用内支付、推送有针对性的广告活动等功能。</li>
<li>The <a target="_blank" rel="noopener" href="https://developers.google.com/youtube/">YouTube API</a>, 允许你将 Youtube 上的视频嵌入到网站中去，同时提供搜索 Youtube，创建播放列表等众多功能。</li>
<li>The <a target="_blank" rel="noopener" href="https://www.twilio.com/">Twilio API</a>, 其为您的 app 提供了针对语音通话和视频聊天的框架，以及从您的 app 发送短信息或多媒体信息等诸多功能。</li>
</ul>
<p><strong>备注：</strong> 你可以在 <a target="_blank" rel="noopener" href="http://www.programmableweb.com/category/all/apis">Programmable Web API directory</a>.上发现更多关于第三方 API 的信息。</p>
<h3 id="3-10-客户端存储"><a href="#3-10-客户端存储" class="headerlink" title="3.10 客户端存储"></a>3.10 客户端存储</h3><p>在其他的 MDN 学习中我们已经讨论过 静态网站（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/First_steps/Client-Server_overview#static_sites">static sites</a>）和动态网站（ <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/First_steps/Client-Server_overview#dynamic_sites">dynamic sites</a>）的区别。大多数现代的 web 站点是动态的— 它们在服务端使用各种类型的数据库来存储数据 (服务端存储), 之后通过运行服务端（ <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">server-side</a>）代码来重新获取需要的数据，把其数据插入到静态页面的模板中，并且生成出 HTML 渲染到用户浏览上。</p>
<p>客户端存储以相同的原理工作，但是在使用上有一些不同。它是由 JavaScript APIs 组成的因此允许你在客户端存储数据 (比如在用户的机器上)，而且可以在需要的时候重新取得需要的数据。这有很多明显的用处，比如：</p>
<ul>
<li>个性化网站偏好（比如显示一个用户选择的窗口小部件，颜色主题，或者字体）。</li>
<li>保存之前的站点行为 (比如从先前的 session 中获取购物车中的内容，记住用户是否之前已经登陆过)。</li>
<li>本地化保存数据和静态资源可以使一个站点更快（至少让资源变少）的下载，甚至可以在网络失去链接的时候变得暂时可用。</li>
<li>保存 web 已经生产的文档可以在离线状态下访问。</li>
</ul>
<p>通常客户端和服务端存储是结合在一起使用的。例如，你可以从数据库中下载一个由网络游戏或音乐播放器应用程序使用的音乐文件，将它们存储在客户端数据库中，并按需要播放它们。用户只需下载音乐文件一次——在随后的访问中，它们将从数据库中检索。</p>
<p><strong>备注：</strong> 使用客户端存储 API 可以存储的数据量是有限的（可能是每个 API 单独的和累积的总量）;具体的数量限制取决于浏览器，也可能基于用户设置。有关更多信息，获取更多信息，请参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria">浏览器存储限制和清理标准</a>。</p>
<p>传统方法：cookies</p>
<p>客户端存储的概念已经存在很长一段时间了。从早期的网络时代开始，网站就使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">cookies</a> 来存储信息，以在网站上提供个性化的用户体验。它们是网络上最早最常用的客户端存储形式。 因为在那个年代，有许多问题——无论是从技术上的还是用户体验的角度——都是困扰着 cookies 的问题。这些问题非常重要，以至于当第一次访问一个网站时，欧洲居民会收到消息，告诉他们是否会使用 cookies 来存储关于他们的数据，而这是由一项被称为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E6%AC%A7%E7%9B%9Fcookie%E6%8C%87%E4%BB%A4">欧盟 Cookie 条例</a>的欧盟法律导致的。</p>
<p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/cookies-notice.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>由于这些原因，我们不会在本文中教你如何使用 cookie。毕竟它过时、存在各种<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%AE%89%E5%85%A8">安全问题</a>，而且无法存储复杂数据，而且有更好的、更现代的方法可以在用户的计算机上存储种类更广泛的数据。 cookie 的唯一优势是它们得到了非常旧的浏览器的支持，所以如果您的项目需要支持已经过时的浏览器（比如 Internet Explorer 8 或更早的浏览器），cookie 可能仍然有用，但是对于大多数项目（很明显不包括本站）来说，您不需要再使用它们了。其实 cookie 也没什么好说的，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie"><code>document.cookie</code></a>一把梭就完事了。</p>
<p><strong>备注：</strong> 为什么仍然有新创建的站点使用 cookies？这主要是因为开发人员的习惯，使用了仍然使用 cookies 的旧库，以及存在许多 web 站点，提供了过时的参考和培训材料来学习如何存储数据。</p>
<p>新流派：Web Storage 和 IndexedDB</p>
<p>现代浏览器有比使用 cookies 更简单、更有效的存储客户端数据的 API。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a> 提供了一种非常简单的语法，用于存储和检索较小的、由名称和相应值组成的数据项。当您只需要存储一些简单的数据时，比如用户的名字，用户是否登录，屏幕背景使用了什么颜色等等，这是非常有用的。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a> 为浏览器提供了一个完整的数据库系统来存储复杂的数据。这可以用于存储从完整的用户记录到甚至是复杂的数据类型，如音频或视频文件。</li>
</ul>
<p>您将在下面了解更多关于这些 API 的信息。</p>
<h4 id="未来：Cache-API"><a href="#未来：Cache-API" class="headerlink" title="未来：Cache API"></a>未来：Cache API</h4><p>一些现代浏览器支持新的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a> API。这个 API 是为存储特定 HTTP 请求的响应文件而设计的，它对于像存储离线网站文件这样的事情非常有用，这样网站就可以在没有网络连接的情况下使用。缓存通常与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker API</a> 组合使用，尽管不一定非要这么做。 Cache 和 Service Workers 的使用是一个高级主题，我们不会在本文中详细讨论它，尽管我们将在下面的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage#%E7%A6%BB%E7%BA%BF%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8">离线文件存储</a> 一节中展示一个简单的例子。</p>
<h4 id="存储简单数据"><a href="#存储简单数据" class="headerlink" title="存储简单数据"></a>存储简单数据</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a> 非常容易使用 — 你只需存储简单的 键名&#x2F;键值 对数据 (限制为字符串、数字等类型) 并在需要的时候检索其值。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>让我们来告诉你怎么做：</p>
<ol>
<li><p>第一步，访问 GitHub 上的 <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/index.html">web storage blank template</a> (在新标签页打开此<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/index.html">模板</a>)。</p>
</li>
<li><p>打开你浏览器开发者工具的 JavaScript 控制台。</p>
</li>
<li><p>你所有的 web storage 数据都包含在浏览器内两个类似于对象的结构中： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage"><code>localStorage</code></a>。第一种方法，只要浏览器开着，数据就会一直保存 (关闭浏览器时数据会丢失) ，而第二种会一直保存数据，甚至到浏览器关闭又开启后也是这样。我们将在本文中使用第二种方法，因为它通常更有用。</p>
</li>
<li><p><code>Storage.setItem()</code>方法允许您在存储中保存一个数据项——它接受两个参数：数据项的名字及其值。试着把它输入到你的 JavaScript 控制台（如果你愿意的话，可以把它的值改为你自己的名字！）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;Chris&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Storage.getItem()</code>方法接受一个参数——你想要检索的数据项的名称——并返回数据项的值。现在将这些代码输入到你的 JavaScript 控制台：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure>

<p>在输入第二行时，您应该会看到myName变量现在包含name数据项的值。</p>
</li>
<li><p><code>Storage.removeItem()</code>方法接受一个参数——你想要删除的数据项的名称——并从 web storage 中删除该数据项。在您的 JavaScript 控制台中输入以下几行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure>

<p>第三行现在应该返回null—name项已经不存在于 web storage 中。</p>
</li>
</ol>
<h4 id="数据会一直存在！"><a href="#数据会一直存在！" class="headerlink" title="数据会一直存在！"></a>数据会一直存在！</h4><p>web storage 的一个关键特性是，数据在不同页面加载时都存在（甚至是当浏览器关闭后，对 localStorage 的而言）。让我们来看看这个：</p>
<ol>
<li><p>再次打开我们的 Web Storage 空白模板，但是这次你要在不同的浏览器中打开这个教程！这样可以更容易处理。</p>
</li>
<li><p>在浏览器的 JavaScript 控制台中输入这几行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;Chris&#x27;</span>);<br><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure>

<p>你应该看到 name 数据项返回。</p>
</li>
<li><p>现在关掉浏览器再把它打开。</p>
</li>
<li><p>再次输入下面几行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure>

<p>你应该看到，尽管浏览器已经关闭，然后再次打开，但仍然可以使用该值。</p>
</li>
</ol>
<h4 id="为每个域名分离储存"><a href="#为每个域名分离储存" class="headerlink" title="为每个域名分离储存"></a>为每个域名分离储存</h4><p>每个域都有一个单独的数据存储区 (每个单独的网址都在浏览器中加载). 你 会看到，如果你加载两个网站（例如 google.com 和 amazon.com）并尝试将某个项目存储在一个网站上，该数据项将无法从另一个网站获取。</p>
<p>这是有道理的 - 你可以想象如果网站能够查看彼此的数据，就会出现安全问题！</p>
<h4 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h4><p>让我们通过编写一个简单的工作示例来应用这些新发现的知识，让你了解如何使用网络存储。我们的示例将允许你输入一个名称，然后该页面将刷新，以提供个性化问候。这种状态也会页面&#x2F;浏览器重新加载期间保持，因为这个名称存储在 Web Storage 中。</p>
<p>你可以在 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/web-storage/personal-greeting.html">personal-greeting.html</a> 中找到示例文件 —— 这包含一个具有标题，内容和页脚，以及用于输入您的姓名的表单的简单网站。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/web-storage-demo.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>让我们来构建示例，以便了解它的工作原理。</p>
<ol>
<li><p>首先，在您的计算机上的新目录中创建一个 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/web-storage/personal-greeting.html">personal-greeting.html</a> 文件的副本。</p>
</li>
<li><p>接下来，请注意我们的 HTML 如何引用一个名为<code>index.js</code>的 JavaScript 文件（请参见第 40 行）。我们需要创建它并将 JavaScript 代码写入其中。在与 HTML 文件相同的目录中创建一个<code>index.js</code>文件。</p>
</li>
<li><p>我们首先创建对所有需要在此示例中操作的 HTML 功能的引用 - 我们将它们全部创建为常量，因为这些引用在应用程序的生命周期中不需要更改。将以下几行添加到你的 JavaScript 文件中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 创建所需的常量</span><br><span class="hljs-keyword">const</span> rememberDiv = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.remember&#x27;</span>);<br><span class="hljs-keyword">const</span> forgetDiv = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.forget&#x27;</span>);<br><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br><span class="hljs-keyword">const</span> nameInput = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#entername&#x27;</span>);<br><span class="hljs-keyword">const</span> submitBtn = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#submitname&#x27;</span>);<br><span class="hljs-keyword">const</span> forgetBtn = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#forgetname&#x27;</span>);<br><br><span class="hljs-keyword">const</span> h1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);<br><span class="hljs-keyword">const</span> personalGreeting = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.personal-greeting&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>接下来，我们需要包含一个小小的事件监听器，以在按下提交按钮时阻止实际的提交表单动作自身，因为这不是我们想要的行为。在您之前的代码下添加此代码段：在你之前的代码后添加这段代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 当按钮按下时阻止表单提交</span><br>form.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">submit</span>&#x27;, <span class="hljs-params">function</span>(<span class="hljs-params">e</span>)</span> &#123;<br>  e.prevent<span class="hljs-constructor">Default()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>现在我们需要添加一个事件监听器，当单击“Say hello”按钮时，它的处理函数将会运行。这些注释详细解释了每一处都做了什么，但实际上我们在这里获取用户输入到文本输入框中的名字并使用setItem()将它保存在网络存储中，然后运行一个名为nameDisplayCheck()的函数来处理实际的网站文本的更新。将此添加到代码的底部：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// run function when the &#x27;Say hello&#x27; button is clicked</span><br>submitBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">function</span>()</span> &#123;<br>  <span class="hljs-comment">// store the entered name in web storage</span><br>  localStorage.set<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">name</span>&#x27;, <span class="hljs-params">nameInput</span>.<span class="hljs-params">value</span>)</span>;<br>  <span class="hljs-comment">// run nameDisplayCheck() to sort out displaying the</span><br>  <span class="hljs-comment">// personalized greetings and updating the form display</span><br>  name<span class="hljs-constructor">DisplayCheck()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>此时，我们还需要一个事件处理程序，以便在单击“Forget”按钮时运行一个函数——且仅在单击“Say hello”按钮（两种表单状态来回切换）后才显示。在这个功能中，我们使用</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">removeItem()</span><br></code></pre></td></tr></table></figure>

<p>从网络存储中删除项目</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">name</span><br></code></pre></td></tr></table></figure>

<p>，然后再次运行</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">nameDisplayCheck</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>以更新显示。将其添加到底部：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// run function when the &#x27;Forget&#x27; button is clicked</span><br>forgetBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">function</span>()</span> &#123;<br>  <span class="hljs-comment">// Remove the stored name from web storage</span><br>  localStorage.remove<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">name</span>&#x27;)</span>;<br>  <span class="hljs-comment">// run nameDisplayCheck() to sort out displaying the</span><br>  <span class="hljs-comment">// generic greeting again and updating the form display</span><br>  name<span class="hljs-constructor">DisplayCheck()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>现在是时候定义</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">nameDisplayCheck</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>函数本身了。在这里，我们通过使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>作为测试条件来检查 name 数据项是否已经存储在 Web Storage 中。如果它已被存储，则该调用的返回值为true; 如果没有，它会是false。如果是true，我们会显示个性化问候语，显示表格的“forget”部分，并隐藏表格的“Say hello”部分。如果是false，我们会显示一个通用问候语，并做相反的事。再次将下面的代码添到底部：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> define the nameDisplayCheck() <span class="hljs-keyword">function</span><br><span class="hljs-keyword">function</span> nameDisplayCheck() &#123;<br>  <span class="hljs-regexp">//</span> check whether the <span class="hljs-string">&#x27;name&#x27;</span> data item is stored <span class="hljs-keyword">in</span> web Storage<br>  <span class="hljs-keyword">if</span>(localStorage.getItem(<span class="hljs-string">&#x27;name&#x27;</span>)) &#123;<br>    <span class="hljs-regexp">//</span> If it is, display personalized greeting<br>    let name = localStorage.getItem(<span class="hljs-string">&#x27;name&#x27;</span>);<br>    h1.textContent = <span class="hljs-string">&#x27;Welcome, &#x27;</span> + name;<br>    personalGreeting.textContent = <span class="hljs-string">&#x27;Welcome to our website, &#x27;</span> + name + <span class="hljs-string">&#x27;! We hope you have fun while you are here.&#x27;</span>;<br>    <span class="hljs-regexp">//</span> hide the <span class="hljs-string">&#x27;remember&#x27;</span> part of the form and show the <span class="hljs-string">&#x27;forget&#x27;</span> part<br>    forgetDiv.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>    rememberDiv.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> not, display generic greeting<br>    h1.textContent = <span class="hljs-string">&#x27;Welcome to our website &#x27;</span>;<br>    personalGreeting.textContent = <span class="hljs-string">&#x27;Welcome to our website. We hope you have fun while you are here.&#x27;</span>;<br>    <span class="hljs-regexp">//</span> hide the <span class="hljs-string">&#x27;forget&#x27;</span> part of the form and show the <span class="hljs-string">&#x27;remember&#x27;</span> part<br>    forgetDiv.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>    rememberDiv.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>最后但同样重要的是，我们需要在每次加载页面时运行nameDisplayCheck()函数。如果我们不这样做，那么个性化问候不会在页面重新加载后保持。将以下代码添加到代码的底部：document.body.onload &#x3D; nameDisplayCheck;</p>
</li>
</ol>
<p>你的例子完成了 - 做得好！现在剩下的就是保存你的代码并在浏览器中测试你的 HTML 页面。你可以在这里看到我们的<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/personal-greeting.html">完成版本并在线运行</a>。</p>
<p><strong>备注：</strong> 在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">Using the Web Storage API</a> 中还有一个稍微复杂点儿的示例。</p>
<p><strong>备注：</strong> 在完成版本的源代码中， <code>&lt;script src=&quot;index.js&quot; defer&gt;&lt;/script&gt;</code> 一行里， <code>defer</code> 属性指明在页面加载完成之前，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script">&#96;&#96;</a>元素的内容不会执行。</p>
<h4 id="存储复杂数据"><a href="#存储复杂数据" class="headerlink" title="存储复杂数据"></a>存储复杂数据</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>（有时简称 IDB）是可以在浏览器中访问的一个完整的数据库系统，在这里，你可以存储复杂的关系数据。其种类不限于像字符串和数字这样的简单值。你可以在一个 IndexedDB 中存储视频，图像和许多其他的内容。</p>
<p>但是，这确实是有代价的：使用 IndexedDB 要比 Web Storage API 复杂得多。在本节中，我们仅仅只能浅尝辄止地一提它的能力，不过我们会给你足够基础知识以帮助你开始。</p>
<h4 id="通过一个笔记存储示例演示"><a href="#通过一个笔记存储示例演示" class="headerlink" title="通过一个笔记存储示例演示"></a>通过一个笔记存储示例演示</h4><p>在这里，我们将向您介绍一个示例，该示例允许您在浏览器中存储笔记并随时查看和删除它们，在我们进行时，我们将解释 IDB 的最基本部分并让您自己构建注释。</p>
<p>这个应用看起来像这样：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/idb-demo.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>每个笔记都有一个标题和一些正文，每个都可以单独编辑。我们将在下面通过的 JavaScript 代码提供详细的注释，以帮助您了解正在发生的事情。</p>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>1、首先，将 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index.html"><code>index.html</code></a>, <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/style.css"><code>style.css</code></a>, 和 <a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index-start.js"><code>index-start.js</code></a> 文件的本地副本放入本地计算机上的新目录中。</p>
<p>2、浏览这些文件。您将看到 HTML 非常简单：具有页眉和页脚的网站，以及包含显示注释的位置的主内容区域，以及用于在数据库中输入新注释的表单。CSS 提供了一些简单的样式，使其更清晰。JavaScript 文件包含五个声明的常量，其中包含对将显示注释的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul">&#96;&#96;</a> 元素的引用，标题和正文 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input">&#96;&#96;</a> 元素，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">&#96;&#96;</a>本身，以及<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">&#96;&#96;</a>。</p>
<p>3、将您的 JavaScript 文件重命名为 <code>index.js</code> 。您现在可以开始向其添加代码了。</p>
<h4 id="数据库初始设置"><a href="#数据库初始设置" class="headerlink" title="数据库初始设置"></a>数据库初始设置</h4><p>现在让我们来看看为了建立数据库必须首先要做什么。</p>
<ol>
<li><p>在常量声明下，加入这几行：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">// Create an<span class="hljs-built_in"> instance </span>of a db object for us to store the open database in<br>let db;<br></code></pre></td></tr></table></figure>

<p>这里我们声明了一个叫db的变量 — 这将在之后被用来存储一个代表数据库的对象。我们将在几个地方使用它，所以我们为了方便使用而在这里把它声明为全局的。</p>
</li>
<li><p>接着，在你的代码最后添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们将把所有的后续代码写在这个window.onload事件处理函数内，这个函数将在 window 的<code>load</code>事件被触发时调用，为了确保我们没有在应用完整加载前试图使用 IndexedDB 功能（如果我们不这么做，它会失败）。</p>
</li>
<li><p>在window.onload处理程序内，添加以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Open our database; it is created if it doesn&#x27;t already exist</span><br><span class="hljs-comment">// (see onupgradeneeded below)</span><br><span class="hljs-keyword">let</span> request = <span class="hljs-variable language_">window</span>.<span class="hljs-property">indexedDB</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>此行创建一个request变量，目的是打开note数据库的1</p>
<p>版本。如果notes数据库不存在，则后续代码将为您创建。您将在 IndexedDB 中经常看到此请求模式。数据库操作需要时间。您不希望在等待结果时挂起浏览器，因此数据库操作是异步的，这意味着它们不会立即发生，而是在将来的某个时刻发生，并且在完成后会收到通知。 要在 IndexedDB 中处理此问题，您需要创建一个请求对象（可以随意命名 - 命名为request，可以表明它的用途）。然后，在请求完成或者失败时，使用事件处理程序来运行代码，您将在下面看到这些代码。</p>
<p><strong>备注：</strong> 版本号很重要。如果要升级数据库（例如：更改表结构），则必须使用增加的版本号或者<code>onupgradeneeded</code>处理程序内指定的不同模式（请参阅下文）等再次运行代码。在这个简单教程中，我们不讨论数据库升级。</p>
<ol>
<li><p>在之前添加的事件处理程序下方添加以下代码 - 在window.onload处理程序内：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// onerror handler signifies that the database didn&#x27;t open successfully</span><br>request.onerror = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Database failed to open&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// onsuccess handler signifies that the database opened successfully</span><br>request.onsuccess = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Database opened successfully&#x27;</span>);<br><br>  <span class="hljs-comment">// Store the opened database object in the db variable. This is used a lot below</span><br>  db = request.result;<br><br>  <span class="hljs-comment">// Run the displayData() function to display the notes already in the IDB</span><br>  displayData();<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果系统返回：请求失败，<code>request.onerror</code> (en-US)将会运行。这将允许你对这个问题做出响应。在我们的简单示例中，只是将消息打印到 JavaScript 控制台。 如果系统返回：请求成功，表明成功打开数据库，<code>request.onsuccess</code> (en-US)将会运行。如果是这种情况，则表示已打开数据库的对象在<code>request.result</code> (en-US)属性中变为可用，从而允许我们操作数据库。我们将它存储在db吗，我们之前创建的变量中供以后使用。我们还运行一个名为displayData()的自定义函数，它把数据库中的数据显示在元素 ( 或 HTML 无序列表元素）代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的。通常情况下，无序列表项的头部可以是几种形式，如一个点，一个圆形或方形。头部的风格并不是在页面的 HTML 描述定义，但在其相关的 CSS 可以用 list-style-type 属性。”&gt;<code>&lt;ul&gt;</code>。我们现在运行它，以便在页面加载时显示数据库中已有的注释。您将在稍后看到此定义。</p>
</li>
</ol>
</li>
<li><p>最后，对于本节，我们可能会添加最重要的事件处理程序来设置数据库：<code>request.onupgradeneeded</code> (en-US)。如果尚未设置数据库，或者使用比现有存储数据库更大的版本号打开数据库（执行升级时），则运行此处理程序。在上一个处理程序下面添加以下代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Setup the database tables if this has not already been done</span><br>request.onupgradeneeded = <span class="hljs-keyword">function</span>(e) &#123;<br>  <span class="hljs-comment">// Grab a reference to the opened database</span><br>  <span class="hljs-keyword">let</span> db = e.target.result;<br><br>  <span class="hljs-comment">// Create an objectStore to store our notes in (basically like a single table)</span><br>  <span class="hljs-comment">// including a auto-incrementing key</span><br>  <span class="hljs-keyword">let</span> objectStore = db.create<span class="hljs-constructor">ObjectStore(&#x27;<span class="hljs-params">notes</span>&#x27;, &#123; <span class="hljs-params">keyPath</span>: &#x27;<span class="hljs-params">id</span>&#x27;, <span class="hljs-params">autoIncrement</span>:<span class="hljs-params">true</span> &#125;)</span>;<br><br>  <span class="hljs-comment">// Define what data items the objectStore will contain</span><br>  objectStore.create<span class="hljs-constructor">Index(&#x27;<span class="hljs-params">title</span>&#x27;, &#x27;<span class="hljs-params">title</span>&#x27;, &#123; <span class="hljs-params">unique</span>: <span class="hljs-params">false</span> &#125;)</span>;<br>  objectStore.create<span class="hljs-constructor">Index(&#x27;<span class="hljs-params">body</span>&#x27;, &#x27;<span class="hljs-params">body</span>&#x27;, &#123; <span class="hljs-params">unique</span>: <span class="hljs-params">false</span> &#125;)</span>;<br><br>  console.log(&#x27;Database setup complete&#x27;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这是我们定义数据库的模式（结构）的地方; 也就是说，它包含的列（或字段）集。这里我们首先从e.target.result（事件目标的result属性）中获取对现有数据库的引用，该引用是request对象。这相当于处理程序db &#x3D; request.result;内部的行onsuccess，但我们需要在此单独执行此操作，因为onupgradeneeded处理程序（如果需要）将在onsuccess处理程序之前运行，这意味着db如果我们不这样做，该值将不可用。 然后<code>IDBDatabase.createObjectStore()</code>，我们使用在打开的数据库中创建一个新的对象库。这相当于传统数据库系统中的单个表。我们给它起了名称注释，并且还指定了一个autoIncrement名为的关键字段id在每个新记录中，这将自动赋予增量值 - 开发人员不需要明确地设置它。作为密钥，该id字段将用于唯一标识记录，例如删除或显示记录时。 我们还使用以下<code>IDBObjectStore.createIndex()</code> (en-US)方法创建另外两个索引（字段）:(title每个音符将包含一个标题），以及body（包含音符的正文）。</p>
</li>
</ol>
<p>因此，通过设置这个简单的数据库模式，当我们开始向数据库添加记录时，每个记录都会沿着这些行表示为一个对象：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  title:</span> <span class="hljs-string">&quot;Buy milk&quot;</span>,<br><span class="hljs-symbol">  body:</span> <span class="hljs-string">&quot;Need both cows milk and soya.&quot;</span>,<br><span class="hljs-symbol">  id:</span> <span class="hljs-number">8</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="添加数据到数据库"><a href="#添加数据到数据库" class="headerlink" title="添加数据到数据库"></a>添加数据到数据库</h4><p>现在让我们看一下如何将记录添加到数据库中。这将使用我们页面上的表单完成。</p>
<p>在您之前的事件处理程序下面（但仍在<code>window.onload</code>处理程序中），添加以下行，该行设置一个<code>onsubmit</code>处理程序，该处理程序运行<code>addData()</code>在提交表单时调用的函数（当 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方。”&gt;&#96;&#96;</a>按下提交时导致成功提交表单）：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">Create</span> an onsubmit <span class="hljs-keyword">handler</span> so that <span class="hljs-keyword">when</span> the form <span class="hljs-keyword">is</span> submitted the addData() <span class="hljs-keyword">function</span> <span class="hljs-keyword">is</span> run<br>form.onsubmit = addData;<br></code></pre></td></tr></table></figure>

<p>现在让我们定义一下这个<code>addData()</code>功能。在上一行下面添加：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// Define the addData() function</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addData</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// prevent default - we don&#x27;t want the form to submit in the conventional way</span><br>  e.preventDefault();<br><br>  <span class="hljs-comment">// grab the values entered into the form fields and store them in an object ready for being inserted into the DB</span><br>  let newItem = &#123; <span class="hljs-attr">title</span>: titleInput.value, <span class="hljs-attr">body</span>: bodyInput.value &#125;;<br><br>  <span class="hljs-comment">// open a read/write db transaction, ready for adding the data</span><br>  let transaction = db.transaction([<span class="hljs-string">&#x27;notes&#x27;</span>], <span class="hljs-string">&#x27;readwrite&#x27;</span>);<br><br>  <span class="hljs-comment">// call an object store that&#x27;s already been added to the database</span><br>  let objectStore = transaction.objectStore(<span class="hljs-string">&#x27;notes&#x27;</span>);<br><br>  <span class="hljs-comment">// Make a request to add our newItem object to the object store</span><br>  <span class="hljs-keyword">var</span> request = objectStore.add(newItem);<br>  request.onsuccess = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// Clear the form, ready for adding the next entry</span><br>    titleInput.value = <span class="hljs-string">&#x27;&#x27;</span>;<br>    bodyInput.value = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// Report on the success of the transaction completing, when everything is done</span><br>  transaction.oncomplete = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Transaction completed: database modification finished.&#x27;</span>);<br><br>    <span class="hljs-comment">// update the display of data to show the newly added item, by running displayData() again.</span><br>    displayData();<br>  &#125;;<br><br>  transaction.onerror = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Transaction not opened due to error&#x27;</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这很复杂; 打破它，我们：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault"><code>Event.preventDefault()</code></a>在事件对象上运行以停止以传统方式实际提交的表单（这将导致页面刷新并破坏体验）。</li>
<li>创建一个表示要输入数据库的记录的对象，并使用表单输入中的值填充它。请注意，我们不必明确包含一个<code>id</code>值 - 正如我们提前详细说明的那样，这是自动填充的。</li>
<li>使用该方法打开对象存储的<code>readwrite</code>事务。此事务对象允许我们访问对象存储，以便我们可以对其执行某些操作，例如添加新记录。<code>notes</code><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction"><code>IDBDatabase.transaction()</code> (en-US)</a></li>
<li>使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/objectStore"><code>IDBTransaction.objectStore()</code> (en-US)</a>方法访问对象库，将结果保存在 <code>objectStore</code> 变量中。</li>
<li>使用添加新记录到数据库<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBObjectStore/add"><code>IDBObjectStore.add()</code></a>。这创建了一个请求对象，与我们之前看到的方式相同。</li>
<li>在生命周期的关键点添加一堆事件处理程序<code>request</code>以及<code>transaction</code>运行代码。请求成功后，我们会清除表单输入，以便输入下一个注释。交易完成后，我们<code>displayData()</code>再次运行该功能以更新页面上的注释显示。</li>
</ul>
<h4 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h4><p>我们已经<code>displayData()</code>在代码中引用了两次，所以我们可能更好地定义它。将其添加到您的代码中，位于上一个函数定义之下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Define the displayData() function</span><br><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Data()</span> &#123;<br>  <span class="hljs-comment">// Here we empty the contents of the list element each time the display is updated</span><br>  <span class="hljs-comment">// If you ddn&#x27;t do this, you&#x27;d get duplicates listed each time a new note is added</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list</span>.firstChild) &#123;<br>    <span class="hljs-built_in">list</span>.remove<span class="hljs-constructor">Child(<span class="hljs-params">list</span>.<span class="hljs-params">firstChild</span>)</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Open our object store and then get a cursor - which iterates through all the</span><br>  <span class="hljs-comment">// different data items in the store</span><br>  <span class="hljs-keyword">let</span> objectStore = db.transaction(&#x27;notes&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">notes</span>&#x27;)</span>;<br>  objectStore.<span class="hljs-keyword">open</span><span class="hljs-constructor">Cursor()</span>.onsuccess = <span class="hljs-keyword">function</span>(e) &#123;<br>    <span class="hljs-comment">// Get a reference to the cursor</span><br>    <span class="hljs-keyword">let</span> cursor = e.target.result;<br><br>    <span class="hljs-comment">// If there is still another data item to iterate through, keep running this code</span><br>    <span class="hljs-keyword">if</span>(cursor) &#123;<br>      <span class="hljs-comment">// Create a list item, h3, and p to put each data item inside when displaying it</span><br>      <span class="hljs-comment">// structure the HTML fragment, and append it inside the list</span><br>      <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>      <span class="hljs-keyword">let</span> h3 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">h3</span>&#x27;)</span>;<br>      <span class="hljs-keyword">let</span> para = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">p</span>&#x27;)</span>;<br><br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">h3</span>)</span>;<br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">para</span>)</span>;<br>      <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br><br>      <span class="hljs-comment">// Put the data from the cursor inside the h3 and para</span><br>      h3.textContent = cursor.value.title;<br>      para.textContent = cursor.value.body;<br><br>      <span class="hljs-comment">// Store the ID of the data item inside an attribute on the listItem, so we know</span><br>      <span class="hljs-comment">// which item it corresponds to. This will be useful later when we want to delete items</span><br>      listItem.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">data</span>-<span class="hljs-params">note</span>-<span class="hljs-params">id</span>&#x27;, <span class="hljs-params">cursor</span>.<span class="hljs-params">value</span>.<span class="hljs-params">id</span>)</span>;<br><br>      <span class="hljs-comment">// Create a button and place it inside each listItem</span><br>      <span class="hljs-keyword">let</span> deleteBtn = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">deleteBtn</span>)</span>;<br>      deleteBtn.textContent = &#x27;Delete&#x27;;<br><br>      <span class="hljs-comment">// Set an event handler so that when the button is clicked, the deleteItem()</span><br>      <span class="hljs-comment">// function is run</span><br>      deleteBtn.onclick = deleteItem;<br><br>      <span class="hljs-comment">// Iterate to the next item in the cursor</span><br>      cursor.continue<span class="hljs-literal">()</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Again, if list item is empty, display a &#x27;No notes stored&#x27; message</span><br>      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>.firstChild) &#123;<br>        <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>        listItem.textContent = &#x27;No notes stored.&#x27;<br>        <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br>      &#125;<br>      <span class="hljs-comment">// if there are no more cursor items to iterate through, say so</span><br>      console.log(&#x27;Notes all displayed&#x27;);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次，让我们打破这个：</p>
<ul>
<li>首先，我们清空 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>ul</code></a> 元素的内容，然后填充更新的内容。如果您不这样做，那么每次更新时都会添加大量重复内容。</li>
<li>接下来，我们<code>notes</code>使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction"><code>IDBDatabase.transaction()</code> (en-US)</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/objectStore"><code>IDBTransaction.objectStore()</code> (en-US)</a>我们一样得到对象存储的引用<code>addData()</code>，除了这里我们将它们链接在一行中。</li>
<li>下一步是使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBObjectStore/openCursor"><code>IDBObjectStore.openCursor()</code></a>方法打开对游标的请求 - 这是一个可用于迭代对象存储中的记录的构造。我们将一个<code>onsuccess</code>处理程序链接到该行的末尾以使代码更简洁 - 当成功返回游标时，运行处理程序。</li>
<li>我们<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBCursor"><code>IDBCursor</code></a>使用 let 获取对游标本身（对象）的引用<code>cursor = e.target.result</code>。</li>
<li>接下来，我们检查光标是否包含来自数据存储区（<code>if(cursor)&#123; ... &#125;</code>）的记录 - 如果是这样，我们创建一个 DOM 片段，用记录中的数据填充它，然后将其插入页面（<code>&lt;ul&gt;</code>元素内部）。我们还包括一个删除按钮，当单击该按钮时，将通过运行该<code>deleteItem()</code>功能删除该注释，我们将在下一节中查看。</li>
<li>在<code>if</code>块结束时，我们使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/continue"><code>IDBCursor.continue()</code> (en-US)</a>方法将光标前进到数据存储区中的下一条记录，然后<code>if</code>再次运行块的内容。如果有另一个要迭代的记录，这会导致它被插入到页面中，然后<code>continue()</code>再次运行，依此类推。</li>
<li>当没有更多记录要迭代时，<code>cursor</code>将返回<code>undefined</code>，因此<code>else</code>块将运行而不是<code>if</code>块。此块检查是否有任何注释被插入<code>&lt;ul&gt;</code>- 如果没有，它会插入一条消息，说没有存储注释。</li>
</ul>
<h4 id="删除一条笔记"><a href="#删除一条笔记" class="headerlink" title="删除一条笔记"></a>删除一条笔记</h4><p>如上所述，当按下笔记的删除按钮时，笔记将被删除。这是通过<code>deleteItem()</code>函数实现的，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Define the deleteItem() function</span><br><span class="hljs-keyword">function</span> delete<span class="hljs-constructor">Item(<span class="hljs-params">e</span>)</span> &#123;<br>  <span class="hljs-comment">// retrieve the name of the task we want to delete. We need</span><br>  <span class="hljs-comment">// to convert it to a number before trying it use it with IDB; IDB key</span><br>  <span class="hljs-comment">// values are type-sensitive.</span><br>  <span class="hljs-keyword">let</span> noteId = <span class="hljs-constructor">Number(<span class="hljs-params">e</span>.<span class="hljs-params">target</span>.<span class="hljs-params">parentNode</span>.<span class="hljs-params">getAttribute</span>(&#x27;<span class="hljs-params">data</span>-<span class="hljs-params">note</span>-<span class="hljs-params">id</span>&#x27;)</span>);<br><br>  <span class="hljs-comment">// open a database transaction and delete the task, finding it using the id we retrieved above</span><br>  <span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-literal">[&#x27;<span class="hljs-identifier">notes</span>&#x27;]</span>, &#x27;readwrite&#x27;);<br>  <span class="hljs-keyword">let</span> objectStore = transaction.<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">notes</span>&#x27;)</span>;<br>  <span class="hljs-keyword">let</span> request = objectStore.delete(noteId);<br><br>  <span class="hljs-comment">// report that the data item has been deleted</span><br>  transaction.oncomplete = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-comment">// delete the parent of the button</span><br>    <span class="hljs-comment">// which is the list item, so it is no longer displayed</span><br>    e.target.parentNode.parentNode.remove<span class="hljs-constructor">Child(<span class="hljs-params">e</span>.<span class="hljs-params">target</span>.<span class="hljs-params">parentNode</span>)</span>;<br>    console.log(&#x27;Note &#x27; + noteId + &#x27; deleted.&#x27;);<br><br>    <span class="hljs-comment">// Again, if list item is empty, display a &#x27;No notes stored&#x27; message</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>.firstChild) &#123;<br>      <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>      listItem.textContent = &#x27;No notes stored.&#x27;;<br>      <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第一部分可以使用一些解释 - 我们检索要删除<code>Number(e.target.parentNode.getAttribute(&#39;data-note-id&#39;))</code>的记录的 ID - 回想一下记录的 ID 是在第一次显示时保存在<code>data-note-id</code>属性中的<code>&lt;li&gt;</code>。但是，我们需要通过全局内置的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number">Number（）</a>对象传递属性，因为它当前是一个字符串，否则将无法被数据库识别。</li>
<li>然后，我们使用我们之前看到的相同模式获取对对象存储的引用，并使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete"><code>IDBObjectStore.delete()</code> (en-US)</a>方法从数据库中删除记录，并将 ID 传递给它。</li>
<li>当数据库事务完成后，我们<code>&lt;li&gt;</code>从 DOM 中删除注释，然后再次检查以查看它是否<code>&lt;ul&gt;</code>为空，并根据需要插入注释。</li>
</ul>
<p>就是这样了！你的例子现在应该有效。</p>
<p>如果您遇到问题，请随时<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/indexeddb/notes/">查看我们的实例</a>（请参阅<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index.js">源代码</a>）。</p>
<h4 id="通过-IndexedDB-存储复杂数据"><a href="#通过-IndexedDB-存储复杂数据" class="headerlink" title="通过 IndexedDB 存储复杂数据"></a>通过 IndexedDB 存储复杂数据</h4><p>如上所述，IndexedDB 可用于存储不仅仅是简单的文本字符串。您可以存储任何您想要的东西，包括复杂的对象，如视频或图像 blob。并且它比任何其他类型的数据更难实现。</p>
<p>为了演示如何操作，我们编写了另一个名为<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/tree/master/javascript/apis/client-side-storage/indexeddb/video-store">IndexedDB 视频存储的</a>示例（请参阅<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/indexeddb/video-store/">此处也可以在此处运行</a>）。首次运行示例时，它会从网络下载所有视频，将它们存储在 IndexedDB 数据库中，然后在 UI 内部 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">&#96;&#96;</a> 元素中显示视频。第二次运行它时，它会在数据库中找到视频并从那里获取它们而不是显示它们 - 这使得后续加载更快，占用空间更少。</p>
<p>让我们来看看这个例子中最有趣的部分。我们不会全部看 - 它的很多内容与上一个示例类似，代码注释得很好。</p>
<ol>
<li><p>对于这个简单的例子，我们已经存储了视频的名称以获取数组 opf 对象：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const videos</span> = [<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;crystal&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;elf&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;frog&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;monster&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;pig&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;rabbit&#x27;</span> &#125;<br>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>首先，一旦数据库成功打开，我们就运行一个init()函数。这会遍历不同的视频名称，尝试加载由videos数据库中的每个名称标识的记录。 如果在数据库中找到每个视频（通过查看request.result评估是否容易检查true- 如果记录不存在，那么undefined），视频文件（存储为 blob）和视频名称将直接传递给displayVideo()函数以放置它们在用户界面中。如果没有，视频名称将传递给fetchVideoFromNetwork()函数…你猜对了 - 从网络中获取视频。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> init<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-comment">// Loop through the video names one by one</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; videos.length; i++) &#123;<br>    <span class="hljs-comment">// Open transaction, get object store, and get() each video by name</span><br>    <span class="hljs-keyword">let</span> objectStore = db.transaction(&#x27;videos&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">videos</span>&#x27;)</span>;<br>    <span class="hljs-keyword">let</span> request = objectStore.get(videos<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.name);<br>    request.onsuccess = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>      <span class="hljs-comment">// If the result exists in the database (is not undefined)</span><br>      <span class="hljs-keyword">if</span>(request.result) &#123;<br>        <span class="hljs-comment">// Grab the videos from IDB and display them using displayVideo()</span><br>        console.log(&#x27;taking videos from IDB&#x27;);<br>        display<span class="hljs-constructor">Video(<span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">mp4</span>, <span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">webm</span>, <span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">name</span>)</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Fetch the videos from the network</span><br>        fetch<span class="hljs-constructor">VideoFromNetwork(<span class="hljs-params">videos</span>[<span class="hljs-params">i</span>])</span>;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>以下片段是从内部fetchVideoFromNetwork()获取的 - 这里我们使用两个单独<code>fetch()</code>请求获取视频的 MP4 和 WebM 版本。然后，我们使用该<code>Body.blob()</code>方法将每个响应的主体提取为 blob，为我们提供可以在以后存储和显示的视频的对象表示。 我们在这里遇到了一个问题 - 这两个请求都是异步的，但我们只想在两个 promises 都满足时尝试显示或存储视频。幸运的是，有一种处理这种问题的内置方法 -<code>Promise.all()</code>。这需要一个参数 - 引用您要检查放置在数组中的履行的所有单个承诺 - 并且本身是基于承诺的。 当所有这些承诺都履行完毕时，all()承诺将通过包含所有个人履行价值的数组来实现。在all()块中，您可以看到我们displayVideo()之前调用函数，就像在 UI 中显示视频一样，然后我们也调用storeVideo()函数将这些视频存储在数据库中。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let mp4Blob = <span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;videos/&#x27;</span> + video.name + <span class="hljs-string">&#x27;.mp4&#x27;</span>).<span class="hljs-keyword">then</span>(response =&gt;<br>  response.blob()<br>);<br>let webmBlob = <span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;videos/&#x27;</span> + video.name + <span class="hljs-string">&#x27;.webm&#x27;</span>).<span class="hljs-keyword">then</span>(response =&gt;<br>  response.blob()<br>);;<br><br>// <span class="hljs-keyword">Only</span> run the next code <span class="hljs-keyword">when</span> <span class="hljs-keyword">both</span> promises have fulfilled<br>Promise.<span class="hljs-keyword">all</span>([mp4Blob, webmBlob]).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-keyword">values</span>) &#123;<br>  // display the video fetched <span class="hljs-keyword">from</span> the network <span class="hljs-keyword">with</span> displayVideo()<br>  displayVideo(<span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">values</span>[<span class="hljs-number">1</span>], video.name);<br>  // store it <span class="hljs-keyword">in</span> the IDB <span class="hljs-keyword">using</span> storeVideo()<br>  storeVideo(<span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">values</span>[<span class="hljs-number">1</span>], video.name);<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>我们storeVideo()先来看看吧。这与您在上一个示例中看到的用于向数据库添加数据的模式非常相似 - 我们打开一个readwrite事务并获取对象存储引用videos，创建一个表示要添加到数据库的记录的对象，然后使用它添加它<code>IDBObjectStore.add()</code>。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> store<span class="hljs-constructor">Video(<span class="hljs-params">mp4Blob</span>, <span class="hljs-params">webmBlob</span>, <span class="hljs-params">name</span>)</span> &#123;<br>  <span class="hljs-comment">// Open transaction, get object store; make it a readwrite so we can write to the IDB</span><br>  <span class="hljs-keyword">let</span> objectStore = db.transaction(<span class="hljs-literal">[&#x27;<span class="hljs-identifier">videos</span>&#x27;]</span>, &#x27;readwrite&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">videos</span>&#x27;)</span>;<br>  <span class="hljs-comment">// Create a record to add to the IDB</span><br>  <span class="hljs-keyword">let</span> record = &#123;<br>    mp4 : mp4Blob,<br>    webm : webmBlob,<br>    name : name<br>  &#125;<br><br>  <span class="hljs-comment">// Add the record to the IDB using add()</span><br>  <span class="hljs-keyword">let</span> request = objectStore.add(record);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>最后但并非最不重要的是，我们displayVideo()创建了在 UI 中插入视频然后将它们附加到页面所需的 DOM 元素。最有趣的部分如下所示 - 要在<video>元素中实际显示我们的视频 blob，我们需要使用该<code>URL.createObjectURL()</code>方法创建对象 URL（指向存储在内存中的视频 blob 的内部 URL）。完成后，我们可以将对象 URL 设置为<code>&lt;source&gt;</code>元素src属性的值，并且它可以正常工作。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Video(<span class="hljs-params">mp4Blob</span>, <span class="hljs-params">webmBlob</span>, <span class="hljs-params">title</span>)</span> &#123;<br>  <span class="hljs-comment">// Create object URLs out of the blobs</span><br>  <span class="hljs-keyword">let</span> mp4URL = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>create<span class="hljs-constructor">ObjectURL(<span class="hljs-params">mp4Blob</span>)</span>;<br>  <span class="hljs-keyword">let</span> webmURL = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>create<span class="hljs-constructor">ObjectURL(<span class="hljs-params">webmBlob</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  </span><span class="hljs-keyword">let</span> video = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">video</span>&#x27;)</span>;<br>  video.controls = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">let</span> source1 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">source</span>&#x27;)</span>;<br>  source1.src = mp4URL;<br>  source1.<span class="hljs-keyword">type</span> = &#x27;video/mp4&#x27;;<br>  <span class="hljs-keyword">let</span> source2 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">source</span>&#x27;)</span>;<br>  source2.src = webmURL;<br>  source2.<span class="hljs-keyword">type</span> = &#x27;video/webm&#x27;;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="离线文件存储"><a href="#离线文件存储" class="headerlink" title="离线文件存储"></a>离线文件存储</h4><p>上面的示例已经说明了如何创建一个将大型资产存储在 IndexedDB 数据库中的应用程序，从而无需多次下载它们。这已经是对用户体验的一个很大的改进，但仍然有一件事 - 每次访问网站时仍然需要下载主要的 HTML，CSS 和 JavaScript 文件，这意味着当没有网络连接时，它将无法工作。</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/ff-offline.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>这就是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">服务工作者</a>和密切相关的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache">Cache API 的</a>用武之地。</p>
<p>服务工作者是一个 JavaScript 文件，简单地说，它是在浏览器访问时针对特定来源（网站或某个域的网站的一部分）进行注册的。注册后，它可以控制该来源的可用页面。它通过坐在加载的页面和网络之间以及拦截针对该来源的网络请求来实现这一点。</p>
<p>当它拦截一个请求时，它可以做任何你想做的事情（参见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API#other_use_case_ideas">用例思路</a>），但经典的例子是离线保存网络响应，然后提供响应请求而不是来自网络的响应。实际上，它允许您使网站完全脱机工作。</p>
<p>Cache API 是另一种客户端存储机制，略有不同 - 它旨在保存 HTTP 响应，因此与服务工作者一起工作得非常好。</p>
<p><strong>备注：</strong> 现在大多数现代浏览器都支持服务工作者和缓存。在撰写本文时，Safari 仍在忙着实施它，但它应该很快就会存在。</p>
<h4 id="一个-service-worker-例子"><a href="#一个-service-worker-例子" class="headerlink" title="一个 service worker 例子"></a>一个 service worker 例子</h4><p>让我们看一个例子，让你对这可能是什么样子有所了解。我们已经创建了另一个版本的视频存储示例，我们在上一节中看到了 - 这个功能完全相同，只是它还通过服务工作者将 Cache，CSS 和 JavaScript 保存在 Cache API 中，允许示例脱机运行！</p>
<p>请参阅<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/">IndexedDB 视频存储，其中服务工作者正在运行</a>，并且还可以<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/tree/master/javascript/apis/client-side-storage/cache-sw/video-store-offline">查看源代码</a>。</p>
<h4 id="注册服务工作者"><a href="#注册服务工作者" class="headerlink" title="注册服务工作者"></a>注册服务工作者</h4><p>首先要注意的是，在主 JavaScript 文件中放置了一些额外的代码（请参阅<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.js">index.js</a>）。首先，我们进行特征检测测试，以查看<code>serviceWorker</code>该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator"><code>Navigator</code></a>对象中是否有该成员。如果返回 true，那么我们知道至少支持服务工作者的基础知识。在这里，我们使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register"><code>ServiceWorkerContainer.register()</code></a>方法将<code>sw.js</code>文件中包含的服务工作者注册到它所驻留的源，因此它可以控制与它或子目录相同的目录中的页面。当其承诺履行时，服务人员被视为已注册。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// Register service worker to control making site work offline</span><br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;serviceWorker&#x27;</span> in navigator) &#123;<br>  navigator.serviceWorker<br>           .register(<span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js&#x27;</span>)<br>           .then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Service Worker Registered&#x27;</span>); &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>备注：</strong> <code>sw.js</code>文件的给定路径是相对于站点源的，而不是包含代码的 JavaScript 文件。服务人员在<code>https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js</code>。原点是<code>https://mdn.github.io</code>，因此给定的路径必须是<code>/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js</code>。如果您想在自己的服务器上托管此示例，则必须相应地更改此示例。这是相当令人困惑的，但出于安全原因，它必须以这种方式工作。</p>
<h4 id="安装-service-worker"><a href="#安装-service-worker" class="headerlink" title="安装 service worker"></a>安装 service worker</h4><p>下次访问服务工作者控制下的任何页面时（例如，重新加载示例时），将针对该页面安装服务工作者，这意味着它将开始控制它。发生这种情况时，<code>install</code>会向服务工作人员发起一个事件; 您可以在服务工作者本身内编写代码来响应安装。</p>
<p>让我们看一下<a target="_blank" rel="noopener" href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js">sw.js</a>文件（服务工作者）中的一个例子。您将看到安装侦听器已注册<code>self</code>。此<code>self</code>关键字是一种从服务工作文件内部引用服务工作者的全局范围的方法。</p>
<p>在<code>install</code> 处理程序内部，我们使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent/waitUntil"><code>ExtendableEvent.waitUntil()</code></a>事件对象上可用的方法来表示浏览器不应该完成服务工作者的安装，直到其中的 promise 成功完成。</p>
<p>这是我们在运行中看到 Cache API 的地方。我们使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/open"><code>CacheStorage.open()</code></a>方法打开一个可以存储响应的新缓存对象（类似于 IndexedDB 对象存储）。此承诺通过<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a>表示<code>video-store</code>缓存的对象来实现。然后，我们使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/addAll"><code>Cache.addAll()</code></a>方法获取一系列资产并将其响应添加到缓存中。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.addEventListener(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span> &#123;<br> e.waitUntil(<br>   caches.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;video-store&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cache)</span></span> &#123;<br>     <span class="hljs-keyword">return</span> cache.addAll([<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.html&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.js&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/style.css&#x27;</span><br>     ]);<br>   &#125;)<br> );<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这就是现在，安装完成。</p>
<h4 id="响应未来的请求"><a href="#响应未来的请求" class="headerlink" title="响应未来的请求"></a>响应未来的请求</h4><p>在我们的 HTML 页面上注册并安装了服务工作者，并且所有相关资产都添加到我们的缓存中，我们几乎准备好了。还有一件事要做，写一些代码来响应进一步的网络请求。</p>
<p>这就是第二位代码的<code>sw.js</code>作用。我们向服务工作者全局范围添加另一个侦听器，该范围在<code>fetch</code>引发事件时运行处理函数。只要浏览器在服务工作者注册的目录中请求资产，就会发生这种情况。</p>
<p>在处理程序内部，我们首先记录所请求资产的 URL。然后，我们使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith"><code>FetchEvent.respondWith()</code></a>方法为请求提供自定义响应。</p>
<p>在这个块中，我们<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/match"><code>CacheStorage.match()</code></a>用来检查是否可以在任何缓存中找到匹配的请求（即匹配 URL）。如果未找到匹配，或者<code>undefined</code>如果未找到匹配，则此承诺将满足匹配的响应。</p>
<p>如果找到匹配项，我们只需将其作为自定义响应返回。如果没有，我们从网络中<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">获取（）</a>响应并返回该响应。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.addEventListener(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(e.request.url);<br>  e.respondWith(<br>    caches.<span class="hljs-built_in">match</span>(e.request).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response)</span></span> &#123;<br>      <span class="hljs-keyword">return</span> response || fetch(e.request);<br>    &#125;)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这就是我们简单的服务工作者。您可以使用它们进行更多的负载 - 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/mdn/serviceworker-cookbook/">服务工作者手册</a>。感谢 Paul Kinlan 在他的文章中<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/codelabs/offline/">添加服务工作者和离线到您的 Web 应用程序</a>，这启发了这个简单的例子。</p>
<h4 id="测试离线示例"><a href="#测试离线示例" class="headerlink" title="测试离线示例"></a>测试离线示例</h4><p>要测试我们的<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/">服务工作者示例</a>，您需要加载它几次以确保它已安装。完成后，您可以：</p>
<ul>
<li>尝试拔掉网络连接&#x2F;关闭 Wifi。</li>
<li>如果您使用的是 Firefox，请选择<em>文件&gt;脱机工作</em>。</li>
<li>转到 devtools，然后选择<em>Application&gt; Service Workers</em>，如果您使用的是 Chrome，请选中<em>Offline</em>选中。</li>
</ul>
<p>如果再次刷新示例页面，您仍应该看到它加载得很好。所有内容都是脱机存储的 - 缓存中的页面资源以及 IndexedDB 数据库中的视频。</p>
<h1 id="that’s-it"><a href="#that’s-it" class="headerlink" title="that’s it"></a>that’s it</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/css/">#css</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>css</div>
      <div>https://yoonalis.github.io/blog/2022/11/20/css/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2022/11/20/webpack/" title="webpack">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">webpack</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2022/11/20/%E5%85%9A%E8%AF%BE/" title="党课">
                        <span class="hidden-mobile">党课</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
