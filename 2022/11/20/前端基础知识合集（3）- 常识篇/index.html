

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.jpg">
  <link rel="icon" href="/blog/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Azure">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础知识合集（3）- 常识篇">
<meta property="og:url" content="https://yoonalis.github.io/blog/2022/11/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86%EF%BC%883%EF%BC%89-%20%E5%B8%B8%E8%AF%86%E7%AF%87/index.html">
<meta property="og:site_name" content="Azure&#39;s blog">
<meta property="og:description" content="前端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yoonalis.github.io/blog/img/web3.jpg">
<meta property="article:published_time" content="2022-11-20T13:49:55.367Z">
<meta property="article:modified_time" content="2023-03-18T05:09:19.402Z">
<meta property="article:author" content="Azure">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yoonalis.github.io/blog/img/web3.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>前端基础知识合集（3）- 常识篇 - Azure&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoonalis.github.io","root":"/blog/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Azure</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/album/">
                <i class="iconfont icon-images"></i>
                album
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端基础知识合集（3）- 常识篇"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-20 21:49" pubdate>
          2022年11月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          86k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          720 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端基础知识合集（3）- 常识篇</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前端基础知识合集（3）-常识篇"><a href="#前端基础知识合集（3）-常识篇" class="headerlink" title="前端基础知识合集（3）- 常识篇"></a>前端基础知识合集（3）- 常识篇</h1><h2 id="1-HTTP-x2F-HTML-x2F-浏览器"><a href="#1-HTTP-x2F-HTML-x2F-浏览器" class="headerlink" title="1 HTTP&#x2F;HTML&#x2F;浏览器"></a>1 HTTP&#x2F;HTML&#x2F;浏览器</h2><h2 id="2-实用的BOM属性对象方法"><a href="#2-实用的BOM属性对象方法" class="headerlink" title="2 实用的BOM属性对象方法"></a>2 实用的BOM属性对象方法</h2><p>什么是Bom?Bom是浏览器对象。有哪些常用的Bom属性呢？ </p>
<p>(1)location对象 </p>
<p>location.href–返回或设置当前文档的URL </p>
<p>location.search – 返回 URL 中的查询字符串部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu">http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu</a> 返回包括(?)后面的 内容 ?id&#x3D;5&amp;name&#x3D;dreamdu location.hash – 返回 URL#后面的内容，如果没有#，返回空 </p>
<p>location.host – 返回 URL 中的域名部分，例如<a target="_blank" rel="noopener" href="http://www.dreamdu.com/">www.dreamdu.com</a> </p>
<p>location.hostname – 返回 URL 中的主域名部分，例如 dreamdu.com </p>
<p>location.pathname – 返回 URL 的域名后的部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com/xhtml/">http://www.dreamdu.com/xhtml/</a> 返回&#x2F;xhtml&#x2F; </p>
<p>location.port – 返回 URL 中的端口部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com:8080/xhtml/">http://www.dreamdu.com:8080/xhtml/</a> </p>
<p>location.protocol – 返回 URL 中的协议部分。例 如 <a target="_blank" rel="noopener" href="http://www.dreamdu.com:8080/xhtml/">http://www.dreamdu.com:8080/xhtml/</a> 返回(&#x2F;&#x2F;)前面的内容 http: location.assign –设置当前文档的 URL </p>
<p>location.replace()– 设置当前文档的 URL，并且在 history 对象的地址列表中移除 这个 URL location.replace(url); location.reload() – 重载当前页面</p>
<p>(2)history对象 </p>
<p>history.go() – 前进或后退指定的页面数 history.go(num); </p>
<p>history.back() – 后退一页 </p>
<p>history.forward() – 前进一页 </p>
<p>(3)Navigator对象 </p>
<p>navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) </p>
<p>navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie</p>
<h2 id="3-HTML5-drag-api"><a href="#3-HTML5-drag-api" class="headerlink" title="3 HTML5 drag api"></a>3 HTML5 drag api</h2><p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 </p>
<p>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 </p>
<p>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</p>
<p>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 </p>
<p>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 </p>
<p>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 </p>
<p>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</p>
<p><strong>接下来我们看一个简单的例子：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc0b0b0bd1b4dfab7db7fcb7dca12ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="DnD-1.gif"></p>
<p>代码地址：<a href="https://link.juejin.cn/?target=https://codepen.io/wuzhengyan2015/pen/abwxVEV">codepen.io&#x2F;wuzhengyan2…</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drop-area&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drag-el&quot;</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>window.onload = () =&gt; &#123;<br>  const dragEl = document.querySelector(&#x27;#drag-el&#x27;)<br>  const dropArea = document.querySelector(&#x27;#drop-area&#x27;)<br><br>  dragEl.addEventListener(&#x27;dragstart&#x27;, (event) =&gt; &#123;<br>    event.dataTransfer.setData(&#x27;text/plain&#x27;, event.target.id)<br>  &#125;)<br>  dropArea.addEventListener(&#x27;dragover&#x27;, (event) =&gt; &#123;<br>    event.preventDefault()<br>  &#125;)<br>  dropArea.addEventListener(&#x27;drop&#x27;, (event) =&gt; &#123;<br>    const id = event.dataTransfer.getData(&#x27;text/plain&#x27;)<br>    dropArea.appendChild(document.getElementById(id))<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述例子就一个简单的拖放操作，让我们看下例子中拖放的三个重要点都是怎么实现的。</p>
<ol>
<li>元素可拖拽：DOM 属性上设置 draggable&#x3D;true</li>
<li>元素可放置：监听 dragover 事件，事件中调用 preventDefault</li>
<li>拖放数据传递；可拖拽元素监听 dragstart 事件，调用 dataTransfer 对象的 setData 方法，可放置元素监听 drop 事件，使用 dataTransfer 对象的 getData 方法获取设置的数据。</li>
</ol>
<p>可以看到，一个拖放操作实现起来还是很简洁的。</p>
<h2 id="4-序列化-x2F-反序列化"><a href="#4-序列化-x2F-反序列化" class="headerlink" title="4 序列化&#x2F;反序列化"></a>4 序列化&#x2F;反序列化</h2><p>序列化：js中的object转化为字符串</p>
<p>1.使用toJSONString</p>
<p><code>var last=obj.toJSONString(); //将JSON对象转化为JSON字符</code></p>
<p>2.使用stringify</p>
<p><code>var last=JSON.stringify(obj); //将JSON对象转化为JSON字符  </code></p>
<p>3.json转字符串函数</p>
<pre><code class="hljs">    var json = &#123;a:1,b:2,c:3&#125;;
    var arr = [];
    for ( name in json) &#123;
        arr.push(name+&#39;:&#39;+json[name]);
    &#125;
    var str = arr.join(&#39;,&#39;);
    alert(str);
</code></pre>
<p>反序列化：json字符串转化为object</p>
<p>1.eval</p>
<p><code>var obj=eval(&quot;(&quot;+data+&quot;)&quot;);  </code></p>
<p>2.使用parseJSON</p>
<p><code>var obj = data.parseJSON(); //由JSON字符串转换为JSON对象  </code></p>
<p>3.使用parse</p>
<p><code>var obj = JSON.parse(data); //由JSON字符串转换为JSON对象 </code></p>
<p>4.使用封装函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convertCartStrToObj</span>(<span class="hljs-params">cartStr</span>)&#123;        <br>         <span class="hljs-keyword">var</span> obj =&#123;&#125;;<br>        <span class="hljs-comment">//将字符串name:17dian,key:123456,tel:18810701077 按“,”拆分成数组[&quot;name:17dian&quot;, &quot;key:123456&quot;, &quot;tel:18810701077&quot;]</span><br>         <span class="hljs-keyword">var</span> arrVal = cartStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);  <br>         <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arrVal.<span class="hljs-property">length</span> ;i++)&#123;<br>                  data = arrVal[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>); <span class="hljs-comment">// 在将每一项拆分 例如arrVal[0]时 data =[&quot;name&quot;, &quot;17dian&quot;]</span><br>                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>                  obj[data[<span class="hljs-number">0</span>]] = data[<span class="hljs-number">1</span>]; <span class="hljs-comment">//给对象添加属性</span><br>         &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-web-worker"><a href="#5-web-worker" class="headerlink" title="5 web worker"></a>5 web worker</h2><p>Web Worker (工作线程) 是 HTML5 中提出的概念，分为两种类型，专用线程（Dedicated Web Worker） 和共享线程（Shared Web Worker）。专用线程仅能被创建它的脚本所使用（一个专用线程对应一个主线程），而共享线程能够在不同的脚本中使用（一个共享线程对应多个主线程）。</p>
<p>专用线程可以看做是默认情况的 Web Worker，其加上修饰词的目的是为了与共享线程进行区分。本文会较为严格地区分两者，可能较为累赘，但个人认为这是必要的。如果单纯以 <code>Web Worker</code> 字样出现的地方指的是两者都会有的情况。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Web Worker 的意义在于可以将一些耗时的数据处理操作从主线程中剥离，使主线程更加专注于页面渲染和交互。</p>
<ul>
<li>懒加载</li>
<li>文本分析</li>
<li>流媒体数据处理</li>
<li>canvas 图形绘制</li>
<li>图像处理</li>
<li>…</li>
</ul>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ul>
<li>有同源限制</li>
<li>无法访问 DOM 节点</li>
<li>运行在另一个上下文中，无法使用Window对象</li>
<li>Web Worker 的运行不会影响主线程，但与主线程交互时仍受到主线程单线程的瓶颈制约。换言之，如果 Worker 线程频繁与主线程进行交互，主线程由于需要处理交互，仍有可能使页面发生阻塞</li>
<li>共享线程可以被多个浏览上下文（Browsing context）调用，但所有这些浏览上下文必须同源（相同的协议，主机和端口号）</li>
</ul>
<h3 id="浏览器支持度"><a href="#浏览器支持度" class="headerlink" title="浏览器支持度"></a>浏览器支持度</h3><p>根据 CanI Use 网站的统计，目前约有 93.05% 的浏览器支持专用线程。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af51cf353eb148529ba8041ad484e5bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image"></p>
<p>而对于共享线程，则仅有大约 41.66% 的浏览器支持。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d24fb447b7e340e1b186ec890dfdef54~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image"></p>
<p>由于专用线程和共享线程的构造方法都包含在 window 对象中，我们在使用两者之前可以对浏览器的支持性进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">Worker</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>复制代码<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">SharedWorker</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>专用线程由 <code>Worker()</code>方法创建，可以接收两个参数，第一个参数是必填的脚本的位置，第二个参数是可选的配置对象，可以指定 <code>type</code>、<code>credentials</code>、<code>name</code> 三个属性。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>)<br>// var <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>, &#123; name: <span class="hljs-string">&#x27;dedicatedWorker&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>共享线程使用 <code>Shared Worker()</code> 方法创建，同样支持两个参数，用法与 <code>Worker()</code> 一致。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> SharedWorker(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>值得注意的是，因为 Web Worker 有同源限制，所以在本地调试的时候也需要通过启动本地服务器的方式访问，使用 <code>file://</code> 协议直接打开的话将会抛出异常。</p>
<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>Worker 线程和主线程都通过 <code>postMessage()</code> 方法发送消息，通过 <code>onmessage</code> 事件接收消息。在这个过程中数据并不是被共享的，而是被复制的。值得注意的是 <code>Error</code> 和 <code>Function</code> 对象不能被结构化克隆算法复制，如果尝试这么做的话会导致抛出 <code>DATA_CLONE_ERR</code> 的异常。另外，<code>postMessage()</code> 一次只能发送一个对象， 如果需要发送多个参数可以将参数包装为数组或对象再进行传递。</p>
<p>关于 <code>postMessage()</code> 和结构化克隆算法（The structured clone algorithm）将在本文最后进行阐述。</p>
<p>下面是专用线程数据传递的示例。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 主线程</span><br><span class="hljs-selector-tag">var</span> worker = new <span class="hljs-built_in">Worker</span>(&#x27;worker.js&#x27;)<br>worker<span class="hljs-selector-class">.postMessage</span>([<span class="hljs-number">10</span>, <span class="hljs-number">24</span>])<br>worker<span class="hljs-selector-class">.onmessage</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>    console<span class="hljs-selector-class">.log</span>(e.data)<br>&#125;<br><br><span class="hljs-comment">// Worker 线程</span><br>onmessage = function (e) &#123;<br>    if (e.data.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">postMessage</span>(e.data[<span class="hljs-number">1</span>] - e.data[<span class="hljs-number">0</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Worker 线程中，<code>self</code> 和 <code>this</code> 都代表子线程的全局对象。对于监听 <code>message</code> 事件，以下的四种写法是等同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法 1</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 2</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 3</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 写法 4</span><br>onmessage = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>主线程通过 <code>MessagePort</code> 访问专用线程和共享线程。专用线程的 port 会在线程创建时自动设置，并且不会暴露出来。与专用线程不同的是，共享线程在传递消息之前，端口必须处于打开状态。MDN 上的 <code>MessagePort</code> 关于 <code>start()</code> 方法的描述是：</p>
<blockquote>
<p>Starts the sending of messages queued on the port (only needed when using EventTarget.addEventListener; it is implied when using MessagePort.onmessage.)</p>
</blockquote>
<p>这句话经过试验，可以理解为 <code>start()</code> 方法是与 <code>addEventListener</code> 配套使用的。如果我们选择 <code>onmessage</code> 进行事件监听，那么将隐含调用 <code>start()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 业务逻辑</span><br>&#125;<br>复制代码<br><span class="hljs-keyword">var</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;shared-worker.js&#x27;</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 业务逻辑</span><br>&#125;, <span class="hljs-literal">false</span>)<br>sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">start</span>() <span class="hljs-comment">// 需要显式打开</span><br></code></pre></td></tr></table></figure>

<p>在传递消息时，<code>postMessage()</code> 方法和 <code>onmessage</code> 事件必须通过端口对象调用。另外，在 Worker 线程中，需要使用 <code>onconnect</code> 事件监听端口的变化，并使用端口的消息处理函数进行响应。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 主线程<br>sharedWorker.port.postMessage(<span class="hljs-section">[10, 24]</span>)<br><span class="hljs-attr">sharedWorker.port.onmessage</span> = function (e) &#123;<br>    console.log(e.data)<br>&#125;<br><br>// Worker 线程<br><span class="hljs-attr">onconnect</span> = function (e) &#123;<br>    let <span class="hljs-attr">port</span> = e.ports[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-attr">port.onmessage</span> = function (e) &#123;<br>        if (e.data.length &gt; 1) &#123;<br>            port.postMessage(e.data<span class="hljs-section">[1]</span> - e.data<span class="hljs-section">[0]</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="关闭-Worker"><a href="#关闭-Worker" class="headerlink" title="关闭 Worker"></a>关闭 Worker</h3><p>可以在主线程中使用 <code>terminate()</code> 方法或在 Worker 线程中使用 <code>close()</code> 方法关闭 worker。这两种方法是等效的，但比较推荐的用法是使用 <code>close()</code>，防止意外关闭正在运行的 Worker 线程。Worker 线程一旦关闭 Worker 后 Worker 将不再响应。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 主线程</span><br>worker<span class="hljs-selector-class">.terminate</span>()<br><br><span class="hljs-comment">// Dedicated Worker 线程中</span><br>self<span class="hljs-selector-class">.close</span>()<br><br><span class="hljs-comment">// Shared Worker 线程中</span><br>self<span class="hljs-selector-class">.port</span><span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>可以通过在主线程或 Worker 线程中设置 <code>onerror</code> 和 <code>onmessageerror</code> 的回调函数对错误进行处理。其中，<code>onerror</code> 在 Worker 的 <code>error</code> 事件触发并冒泡时执行，<code>onmessageerror</code> 在 Worker 收到的消息不能进行反序列化时触发(本人经过尝试没有办法触发 <code>onmessageerror</code> 事件，如果在 worker 线程使用 <code>postMessage</code> 方法传递一个 Error 或 Function 对象会因为无法序列化优先被 <code>onerror</code> 方法捕获，而根本不会进入反序列化的过程)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程</span><br>worker.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 主线程使用专用线程</span><br>worker.<span class="hljs-property">onmessageerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 主线程使用共享线程</span><br>worker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessageerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// worker 线程</span><br>onerror = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="加载外部脚本"><a href="#加载外部脚本" class="headerlink" title="加载外部脚本"></a>加载外部脚本</h3><p>Web Worker 提供了 <code>importScripts()</code> 方法，能够将外部脚本文件加载到 Worker 中。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">importScripts</span>(&#x27;script1.js&#x27;)<br><span class="hljs-built_in">importScripts</span>(&#x27;script2.js&#x27;)<br><br><span class="hljs-comment">// 以上写法等价于</span><br><span class="hljs-built_in">importScripts</span>(&#x27;script1.js&#x27;, &#x27;script2.js&#x27;)<br></code></pre></td></tr></table></figure>

<h3 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h3><p>Worker 可以生成子 Worker，但有两点需要注意。</p>
<ul>
<li>子 Worker 必须与父网页同源</li>
<li>子 Worker 中的 URI 相对于父 Worker 所在的位置进行解析</li>
</ul>
<h3 id="嵌入式-Worker"><a href="#嵌入式-Worker" class="headerlink" title="嵌入式 Worker"></a>嵌入式 Worker</h3><p>目前没有一类标签可以使 Worker 的代码像 <code>&lt;script&gt;</code> 元素一样嵌入网页中，但我们可以通过 <code>Blob()</code> 将页面中的 Worker 代码进行解析。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;worker&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;javascript/worker&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 这段代码不会被 JS 引擎直接解析，因为类型是 &#x27;javascript/worker&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 在这里写 Worker 线程的逻辑</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> workerScript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#worker&#x27;</span>).<span class="hljs-property">textContent</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([workerScript], &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/javascript&quot;</span>&#125;)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="关于-postMessage"><a href="#关于-postMessage" class="headerlink" title="关于 postMessage"></a>关于 postMessage</h3><p>Web Worker 中，Worker 线程和主线程之间使用结构化克隆算法（The structured clone algorithm）进行数据通信。结构化克隆算法是一种通过递归输入对象构建克隆的算法，算法通过保存之前访问过的引用的映射，避免无限遍历循环。这一过程可以理解为，在发送方使用类似 <code>JSON.stringfy()</code> 的方法将参数序列化，在接收方采用类似 <code>JSON.parse()</code> 的方法反序列化。</p>
<p>但是，一次数据传输就需要同时经过序列化和反序列化，如果数据量大的话，这个过程本身也可能造成性能问题。因此， Worker 中提出了 <code>Transferable Objects</code> 的概念，当数据量较大时，我们可以选择在将主线程中的数据直接移交给 Worker 线程。值得注意的是，这种转移是彻底的，一旦数据成功转移，主线程将不能访问该数据。这个移交的过程仍然通过 <code>postMessage</code> 进行传递。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">postMessage</span>(message, transferList)<br></code></pre></td></tr></table></figure>

<p>例如，传递一个 ArrayBuffer 对象</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">let <span class="hljs-attr">aBuffer</span> = new ArrayBuffer(<span class="hljs-number">1</span>)<br>worker.postMessage(&#123; data: aBuffer &#125;, <span class="hljs-section">[aBuffer]</span>)<br></code></pre></td></tr></table></figure>

<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>Worker 工作在一个 <code>WorkerGlobalDataScope</code> 的上下文中。每一个 <code>WorkerGlobalDataScope</code> 对象都有不同的 <code>event loop</code>。这个 <code>event loop</code> 没有关联浏览器上下文（browsing context），它的任务队列也只有事件（events）、回调（callbacks）和联网的活动（networking activity）。</p>
<p>每一个 <code>WorkerGlobalDataScope</code> 都有一个 <code>closing</code> 标志，当这个标志设为 <code>true</code> 时，任务队列将丢弃之后试图加入任务队列的任务，队列中已经存在的任务不受影响（除非另有指定）。同时，定时器将停止工作，所有挂起（pending）的后台任务将会被删除。</p>
<h3 id="Worker-中可以使用的函数和类"><a href="#Worker-中可以使用的函数和类" class="headerlink" title="Worker 中可以使用的函数和类"></a>Worker 中可以使用的函数和类</h3><p>由于 Worker 工作的上下文不同于普通的浏览器上下文，因此不能访问 window 以及 window 相关的 API，也不能直接操作 DOM。Worker 中提供了 <code>WorkerNavigator</code> 和 <code>WorkerLocation</code> 接口，它们分别是 window 中 <code>Navigator</code> 和 <code>Location</code> 的子集。除此之外，Worker 还提供了涉及时间、存储、网络、绘图等多个种类的接口，以下列举了其中的一部分，更多的接口可以参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers">MDN 文档</a>。</p>
<h4 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h4><ul>
<li>clearInterval()</li>
<li>clearTimeout()</li>
<li>setInterval()</li>
<li>setTimeout</li>
</ul>
<h4 id="Worker-相关"><a href="#Worker-相关" class="headerlink" title="Worker 相关"></a>Worker 相关</h4><ul>
<li>importScripts()</li>
<li>close()</li>
<li>postMessage()</li>
</ul>
<h4 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h4><ul>
<li>Cache</li>
<li>IndexedDB</li>
</ul>
<h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><ul>
<li>Fetch</li>
<li>WebSocket</li>
<li>XMLHttpRequest</li>
</ul>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">使用 Web Workers - Web APIs | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker">Worker | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort">MessagePort | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https://html.spec.whatwg.org/multipage/workers.html">HTML Standard - Web workers</a></li>
<li><a href="https://link.juejin.cn/?target=https://www.html5rocks.com/zh/tutorials/workers/basics/">Web Workers 的基本信息</a></li>
</ul>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://fed.taobao.org/blog/taofed/do71ct/canvas-performance">Canvas 最佳实践 - 淘宝FED</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Worklet">Worklet</a></li>
</ul>
<h2 id="6-iframe"><a href="#6-iframe" class="headerlink" title="6 iframe"></a>6 iframe</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近几年微前端很火，火到有时候项目里面用到了iframe还要偷偷摸摸地藏起来生怕被别人知道了，因为担心被人质疑：你为什么不用微前端方案？直到最近笔者接手一个项目，需要将现有的一个系统整体嵌入到另外一个系统（一共20多个页面），在被微前端坑了几次之后，回过头发现，iframe真香！</p>
<p>qiankun的作者有一篇<a href="https://link.juejin.cn/?target=https://www.yuque.com/kuitos/gky7yw/gesexv?spm=ata.21736010.0.0.25c06df01VID5V">《Why Not Iframe》</a> 介绍了iframe的优缺点（不过作者还有一篇<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/391248835">《你可能并不需要微前端》</a>给微前端降降火），诚然iframe确实存在很多缺点，但是在选择一个方案的时候还是要具体场景具体分析，它可能在当下很流行，但它不一定在任何时候都是最优解：iframe的这些缺点对我来说是否能够接受？它的缺点是否有其它方法可以弥补？使用它到底是利大于弊还是弊大于利？我们需要在优缺点之间找到一个平衡。</p>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ba7b4fe292438c9f84f8d095b032a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="iframe适合的场景"><a href="#iframe适合的场景" class="headerlink" title="iframe适合的场景"></a>iframe适合的场景</h3><p>由于iframe的一些限制，部分场景并不适合用iframe，比如像下面这种iframe只占据页面中间部分区域，由于父页面已经有一个滚动条了，为了避免出现双滚动条，只能动态计算iframe的内容高度赋值给iframe，使得iframe高度完全撑满，但这样带来的问题是弹窗很难处理，如果居中的话一般弹窗都相对的是iframe内容高度而不是屏幕高度，从而导致弹窗可能看不见，如果固定弹窗top又会导致弹窗跟随页面滚动，而且稍有不慎iframe内容高度计算有一点点偏差就会出现双滚动条。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7744c2ded9794f58bb3e9fde13f4c90c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>所以：</p>
<ul>
<li>如果页面本身比较简单，是一个没有弹窗、浮层、高度也是固定的纯信息展示页的话，用iframe一般没什么问题；</li>
<li>如果页面是包含弹窗、信息提示、或者高度不是固定的话，需要看<strong>iframe是否占据了全部的内容区域</strong>，如果是像下图这种经典的导航+菜单+内容结构、并且整个内容区域都是iframe，那么可以放心大胆地尝试iframe，否则，需要慎重考虑方案选型。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/117cf442197848b9a39a9338917a2c0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>为什么一定要满足“iframe占据全部内容区域”这个条件呢？可以想象一下下面这种场景，滚动条出现在页面中间应该大部分人都无法接受：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe05936603d64af49474f44cb8bb6f51~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="实战：A系统接入B系统"><a href="#实战：A系统接入B系统" class="headerlink" title="实战：A系统接入B系统"></a>实战：A系统接入B系统</h3><p>满足“iframe占据全部内容区域”条件的场景，iframe的几个缺点都比较好解决。下面通过一个实际案例来详细介绍将一个线上在运行的系统接入到另外一个系统的全过程。以笔者前段时间刚完成的ACP（全称Alibaba.com Pay，阿里巴巴国际站旗下一站式全球收款平台，下称A系统）接入生意贷（下称B系统）为例，已知：</p>
<ul>
<li>ACP和生意贷都是MPA页面；</li>
<li>ACP系统在此之前没有接入其他系统的先例，生意贷是第一个；</li>
<li>生意贷作为被接入系统，本次需要接入的一共有20多个页面，且服务端包含大量业务逻辑以及跳转控制，有些页面想看看长什么样子都非常困难，需要在Node层mock大量接口；</li>
<li>接入时需要做功能删减，部分接口入参需要调整；</li>
<li>生意贷除了接入到ACP系统中，之前还接入过AMES系统，本次接入需要兼容这部分历史逻辑；</li>
</ul>
<p>我们希望的效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb51daa3fdf44218567982b65ac5517~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>假设我们新增一个页面 <code>/fin/base.html?entry=xxx </code>作为我们A系统承接B系统的地址，A系统有类似如下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    state = &#123;<br>        currentEntry: decodeURIComponent(iutil.getParam(&#x27;entry&#x27;) || &#x27;&#x27;) || &#x27;&#x27;,<br>    &#125;;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> &lt;div&gt;<br>            &lt;iframe id=<span class="hljs-string">&quot;microFrontIframe&quot;</span> src=&#123;<span class="hljs-keyword">this</span>.state.currentEntry&#125;/&gt;<br>        &lt;/div&gt;;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="隐藏原系统导航菜单"><a href="#隐藏原系统导航菜单" class="headerlink" title="隐藏原系统导航菜单"></a>隐藏原系统导航菜单</h4><p>因为是接入到另外一个系统，所以需要将原系统的菜单和导航等都通过一个类似“hideLayout”的参数去隐藏。</p>
<h4 id="前进后退处理"><a href="#前进后退处理" class="headerlink" title="前进后退处理"></a>前进后退处理</h4><p>需要特别注意的是，iframe页面内部的跳转虽然不会让浏览器地址栏发生变化，但是却会产生一个看不见的“history记录”，也就是点击前进或后退按钮（<code>history.forward()</code>或<code>history.back()</code>）可以让iframe页面也前进后退，但是地址栏无任何变化。</p>
<p>所以准确来说前进后退无需我们做任何处理，我们要做的就是让浏览器地址栏同步更新即可。</p>
<blockquote>
<p>如果要禁用浏览器的上述默认行为，一般只能在iframe跳转时通知父页面更新整个<code>&lt;iframe /&gt;DOM</code>节点。</p>
</blockquote>
<h4 id="URL的同步更新"><a href="#URL的同步更新" class="headerlink" title="URL的同步更新"></a>URL的同步更新</h4><p>让URL同步更新需要处理2个问题，一个是什么时候去触发更新的动作，一个是URL更新的规律，即父页面的URL地址（A系统）与iframe的URL地址（B系统）映射关系的维护。</p>
<p>保证URL同步更新功能正常需要满足这3种情况：</p>
<ul>
<li>case1: 页面刷新，iframe能够加载正确页面；</li>
<li>case2: 页面跳转，浏览器地址栏能够正确更新；</li>
<li>case3: 点击浏览器的前进或后退，地址栏和iframe都能够同步变化；</li>
</ul>
<h3 id="什么时候更新URL地址"><a href="#什么时候更新URL地址" class="headerlink" title="什么时候更新URL地址"></a>什么时候更新URL地址</h3><p>首先想到的肯定是在iframe加载完发送一个通知给父页面，父页面通过<code>history.replaceState</code>去更新URL。</p>
<blockquote>
<p>为什么不是<code>history.pushState</code>呢？因为前面提到过，浏览器默认会产生一条历史记录，我们只需要更新地址即可，如果用pushState会产生2条记录。</p>
</blockquote>
<p>B系统：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> postMessage = <span class="hljs-keyword">function</span>(<span class="hljs-params">type, data</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span> !== <span class="hljs-variable language_">window</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: type,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: data,</span><br><span class="language-javascript">        &#125;, <span class="hljs-string">&#x27;*&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-comment">// 为了让URL地址尽早地更新，这段代码需要尽可能前置，例如可以直接放在document.head中</span></span><br><span class="language-javascript"><span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;afterHistoryChange&#x27;</span>, &#123; <span class="hljs-attr">url</span>: location.<span class="hljs-property">href</span> &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>A系统：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; data, <span class="hljs-keyword">type</span> &#125; = e.<span class="hljs-property">data</span> || &#123;&#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;afterHistoryChange&#x27;</span> &amp;&amp; data?.<span class="hljs-property">url</span>) &#123;<br>        <span class="hljs-comment">// 这里先采用一个兜底的URL承接任意地址</span><br>        <span class="hljs-keyword">const</span> entry = <span class="hljs-string">`/fin/base.html?entry=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data.url)&#125;</span>`</span>;<br>        <span class="hljs-comment">// 地址不一样才需要更新</span><br>        <span class="hljs-keyword">if</span> (location.<span class="hljs-property">pathname</span> + location.<span class="hljs-property">search</span> !== entry) &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, entry);<br>        &#125;<br>    &#125;<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="优化URL的更新速度"><a href="#优化URL的更新速度" class="headerlink" title="优化URL的更新速度"></a>优化URL的更新速度</h3><p>按照上面的方法实现后可以发现，URL虽然可以更新但是速度有点慢，点击跳转后一般需要等待7-800毫秒地址栏才会更新，有点美中不足。可以把地址栏的更新在“跳转后”基础之上再加一个“跳转前”。为此我们必须有一个全局的beforeRedirect钩子，先不考虑它的具体实现：</p>
<p>B系统：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beforeRedirect</span>(<span class="hljs-params">href</span>) </span>&#123;<br>    <span class="hljs-title function_ invoke__">postMessage</span>(<span class="hljs-string">&#x27;beforeHistoryChange&#x27;</span>, &#123; <span class="hljs-attr">url</span>: href &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>A系统：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; data, <span class="hljs-keyword">type</span> &#125; = e.<span class="hljs-property">data</span> || &#123;&#125;;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;beforeHistoryChange&#x27;</span> || <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;afterHistoryChange&#x27;</span>) &amp;&amp; data?.<span class="hljs-property">url</span>) &#123;<br>        <span class="hljs-comment">// 这里先采用一个兜底的URL承接任意地址</span><br>        <span class="hljs-keyword">const</span> entry = <span class="hljs-string">`/fin/base.html?entry=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data.url)&#125;</span>`</span>;<br>        <span class="hljs-comment">// 地址不一样才需要更新</span><br>        <span class="hljs-keyword">if</span> (location.<span class="hljs-property">pathname</span> + location.<span class="hljs-property">search</span> !== entry) &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, entry);<br>        &#125;<br>    &#125;<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>加上上述代码之后，点击iframe中的跳转链接，URL会实时更新，浏览器的前进后退功能也正常。</p>
<blockquote>
<p>为什么需要同时保留跳转前和跳转后呢？因为如果只保留跳转前，只能满足前面的case1和case2，case3无法满足，也就是点击后退按钮只有iframe会后退，URL地址不会更新。</p>
</blockquote>
<h3 id="美化URL地址"><a href="#美化URL地址" class="headerlink" title="美化URL地址"></a>美化URL地址</h3><p>简单的使用<code>/fin/base.html?entry=xxx</code>这样的通用地址虽然能用，但是不太美观，而且很容易被人看出来是iframe实现的，比较没有诚意，所以如果被接入系统的页面数量在可枚举范围内，建议给每个地址维护一个新的短地址。</p>
<p>首先，新增一个SPA页面<code>/fin/*.html</code>，和前面的<code>/fin/base.html</code>指向同一个页面，然后维护一个URL地址的映射，类似这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// A系统地址到B系统地址映射</span><br><span class="hljs-keyword">const</span> entryMap = &#123;<br>    <span class="hljs-string">&#x27;/fin/home.html&#x27;</span>: <span class="hljs-string">&#x27;https://fs.alibaba.com/xxx/home.htm?hideLayout=1&#x27;</span>,<br>    <span class="hljs-string">&#x27;/fin/apply.html&#x27;</span>: <span class="hljs-string">&#x27;https://fs.alibaba.com/xxx/apply?hideLayout=1&#x27;</span>,<br>    <span class="hljs-string">&#x27;/fin/failed.html&#x27;</span>: <span class="hljs-string">&#x27;https://fs.aibaba.com/xxx/failed?hideLayout=1&#x27;</span>,<br>    <span class="hljs-comment">// 省略</span><br>&#125;;<br><span class="hljs-keyword">const</span> iframeMap = &#123;&#125;; <span class="hljs-comment">// 同时再维护一个子页面 -&gt; 父页面URL映射</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">in</span> entryMap) &#123;<br>    iframeMap[entryMap[entry].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">0</span>]] = entry;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">currentEntry</span>: <span class="hljs-built_in">decodeURIComponent</span>(iutil.<span class="hljs-title function_">getParam</span>(<span class="hljs-string">&#x27;entry&#x27;</span>) || <span class="hljs-string">&#x27;&#x27;</span>) || entryMap[location.<span class="hljs-property">pathname</span>] || <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;microFrontIframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;this.state.currentEntry&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>同时完善一下更新URL地址部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// base.html继续用作兜底</span><br><span class="hljs-keyword">let</span> entry = <span class="hljs-string">`/fin/base.html?entry=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data.url)&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> [path, search] = data.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>);<br><span class="hljs-keyword">if</span> (iframeMap[path]) &#123;<br>    entry = <span class="hljs-string">`<span class="hljs-subst">$&#123;iframeMap[path]&#125;</span>?<span class="hljs-subst">$&#123;search || <span class="hljs-string">&#x27;&#x27;</span>&#125;</span>`</span>;<br>&#125;<br><span class="hljs-comment">// 地址不一样才需要更新</span><br><span class="hljs-keyword">if</span> (location.<span class="hljs-property">pathname</span> + location.<span class="hljs-property">search</span> !== entry) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, entry);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>省略参数透传部分代码。</p>
</blockquote>
<h3 id="全局跳转拦截"><a href="#全局跳转拦截" class="headerlink" title="全局跳转拦截"></a>全局跳转拦截</h3><p>为什么一定要做全局跳转拦截呢？一个因为我们需要把hideLayout参数一直透传下去，否则就会点着点着突然出现下面这种双菜单的情况：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/110b0f09df6e4f559ff36540fd89f385~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>另一个是有些页面在被嵌入前是当前页面打开的，但是被嵌入后不能继续在当前iframe打开，比如支付宝付款这种第三方页面，想象一下下面这种情况会不会觉得很怪？所以这类页面一定要做特殊处理让它跳出去而不是当前页面打开。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/063c839ca02f452aa7ff77098edba2a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>URL跳转可以分为服务端跳转和浏览器跳转，浏览器跳转又包括A标签跳转、location.href跳转、window.open跳转、historyAPI跳转等；</p>
<p>而根据是否新标签打开又可以分为以下4种场景：</p>
<ol>
<li>继续当前iframe打开，需要隐藏原系统的所有layout；</li>
<li>当前父页面打开第三方页面，不需要任何layout；</li>
<li>新开标签打开第三方页面（如支付宝页面），不需要做特殊处理；</li>
<li>新开标签打开宿主页面，需要把原系统layout替换成新layout；</li>
</ol>
<p>为此，先定义好一个<code>beforeRedirect</code>方法，由于新标签打开有<code>target=&quot;_blank&quot;</code>和<code>window.open</code>等方式，父页面打开有<code>target=&quot;_parent&quot;</code>和<code>window.parent.location.href</code>等方式，为了更好的统一封装，我们把特殊情况的跳转统一在<code>beforeRedirect</code>处理好，并约定只有有返回值的情况才需要后续继续处理跳转：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 维护一个需要做特殊处理的第三方页面列表<br>const <span class="hljs-attr">thirdPageList</span> = [<br>    <span class="hljs-string">&#x27;https://service.alibaba.com/&#x27;</span>,<br>    <span class="hljs-string">&#x27;https://sale.alibaba.com/xxx/&#x27;</span>,<br>    <span class="hljs-string">&#x27;https://alipay.com/xxx/&#x27;</span>,<br>    // ...<br>]<span class="hljs-comment">;</span><br>/**<br> * 封装统一的跳转拦截钩子，处理参数透传和一些特殊情况<br> * @param &#123;*&#125; href 要跳转的地址，允许传入相对路径<br> * @param &#123;*&#125; isNewTab 是否要新标签打开<br> * @param &#123;*&#125; isParentOpen 是否要在父页面打开<br> * @returns 返回处理好的跳转地址，如果没有返回值则表示不需要继续处理跳转<br> */<br>function beforeRedirect(href, isNewTab) &#123;<br>    if (!href) &#123;<br>        return<span class="hljs-comment">;</span><br>    &#125;<br>    // 传过来的href可能是相对路径，为了做统一判断需要转成绝对路径<br>    if (href.indexOf(&#x27;http&#x27;) !== 0) &#123;<br>        var <span class="hljs-attr">a</span> = document.createElement(<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">;</span><br>        <span class="hljs-attr">a.href</span> = href<span class="hljs-comment">;</span><br>        <span class="hljs-attr">href</span> = a.href<span class="hljs-comment">;</span><br>    &#125;<br>    // 如果命中白名单<br>    if (thirdPageList.some(<span class="hljs-attr">item</span> =&gt; href.indexOf(item) === <span class="hljs-number">0</span>)) &#123;<br>        if (isNewTab) &#123;<br>            // _rawOpen参见后面 window.open 拦截<br>            window._rawOpen(href)<span class="hljs-comment">;</span><br>        &#125; else &#123;<br>            // 第三方页面如果不是新标签打开就一定是父页面打开<br>            <span class="hljs-attr">window.parent.location.href</span> = href<span class="hljs-comment">;</span><br>        &#125;<br>        return<span class="hljs-comment">;</span><br>    &#125;<br>    // 需要从当前URL继续往下透传的参数<br>    var <span class="hljs-attr">params</span> = [<span class="hljs-string">&#x27;hideLayout&#x27;</span>, <span class="hljs-string">&#x27;tracelog&#x27;</span>]<span class="hljs-comment">;</span><br>    for (var <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; params.length; i++) &#123;</span><br>        var <span class="hljs-attr">value</span> = getParam(params[i], location.href)<span class="hljs-comment">;</span><br>        if (value) &#123;<br>            <span class="hljs-attr">href</span> = setParam(params[i], value, href)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    if (isNewTab) &#123;<br>        let <span class="hljs-attr">entry</span> = `/fin/base.html?entry=<span class="hljs-variable">$&#123;encodeURIComponent(href)&#125;</span>`<span class="hljs-comment">;</span><br>        const <span class="hljs-section">[path, search]</span> = href.split(&#x27;?&#x27;)<span class="hljs-comment">;</span><br>        if (iframeMap<span class="hljs-section">[path]</span>) &#123;<br>            <span class="hljs-attr">entry</span> = `<span class="hljs-variable">$&#123;iframeMap[path]&#125;</span>?<span class="hljs-variable">$&#123;search || &#x27;&#x27;&#125;</span>`<span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-attr">href</span> = `https://payment.alibaba.com<span class="hljs-variable">$&#123;entry&#125;</span>`<span class="hljs-comment">;</span><br>        window._rawOpen(href)<span class="hljs-comment">;</span><br>        return<span class="hljs-comment">;</span><br>    &#125;<br>    // 如果是以iframe方式嵌入，向父页面发送通知<br>    postMessage(&#x27;beforeHistoryChange&#x27;, &#123; url: href &#125;)<span class="hljs-comment">;</span><br>    return href<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="服务端跳转拦截"><a href="#服务端跳转拦截" class="headerlink" title="服务端跳转拦截"></a>服务端跳转拦截</h3><p>服务端主要是对301或302重定向跳转进行拦截，以Egg为例，只要重写 <code>ctx.redirect</code> 方法即可。</p>
<h3 id="A标签跳转拦截"><a href="#A标签跳转拦截" class="headerlink" title="A标签跳转拦截"></a>A标签跳转拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ini">document.addEventListener(&#x27;click&#x27;, function (e) &#123;<br>    var <span class="hljs-attr">target</span> = e.target || &#123;&#125;<span class="hljs-comment">;</span><br>    // A标签可能包含子元素，点击目标可能不是A标签本身，这里只简单判断2层<br>    if (<span class="hljs-attr">target.tagName</span> === <span class="hljs-string">&#x27;A&#x27;</span> || (target.parentNode &amp;&amp; target.parentNode.tagName === <span class="hljs-string">&#x27;A&#x27;</span>)) &#123;<br>        <span class="hljs-attr">target</span> = target.tagName === <span class="hljs-string">&#x27;A&#x27;</span> ? target : target.parentNode<span class="hljs-comment">;</span><br>        var <span class="hljs-attr">href</span> = target.href<span class="hljs-comment">;</span><br>        // 不处理没有配置href或者指向JS代码的A标签<br>        if (!href || href.indexOf(&#x27;javascript&#x27;) === 0) &#123;<br>            return<span class="hljs-comment">;</span><br>        &#125;<br>        var <span class="hljs-attr">newHref</span> = beforeRedirect(href, target.target === <span class="hljs-string">&#x27;_blank&#x27;</span>)<span class="hljs-comment">;</span><br>        // 没有返回值一般是已经处理了跳转，需要禁用当前A标签的跳转<br>        if (!newHref) &#123;<br>            <span class="hljs-attr">target.target</span> = <span class="hljs-string">&#x27;_self&#x27;</span><span class="hljs-comment">;</span><br>            <span class="hljs-attr">target.href</span> = <span class="hljs-string">&#x27;javascript:;&#x27;</span><span class="hljs-comment">;</span><br>        &#125; else if (newHref !== href) &#123;<br>            <span class="hljs-attr">target.href</span> = newHref<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;, true)<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="location-href拦截"><a href="#location-href拦截" class="headerlink" title="location.href拦截"></a>location.href拦截</h3><p>location.href拦截至今是一个困扰前端界的难题，这里只能采用一个折中的方法：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 由于 location.href 无法重写，只能实现一个 <span class="hljs-attr">location2.href</span> = <span class="hljs-string">&#x27;&#x27;</span><br>if (Object.defineProperty) &#123;<br>    <span class="hljs-attr">window.location2</span> = &#123;&#125;<span class="hljs-comment">;</span><br>    Object.defineProperty(window.location2, &#x27;href&#x27;, &#123;<br>        get: function() &#123;<br>            return location.href<span class="hljs-comment">;</span><br>        &#125;,<br>        set: function(href) &#123;<br>            var <span class="hljs-attr">newHref</span> = beforeRedirect(href)<span class="hljs-comment">;</span><br>            if (newHref) &#123;<br>                <span class="hljs-attr">location.href</span> = newHref<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;,<br>    &#125;)<span class="hljs-comment">;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>因为我们<strong>不仅实现了location.href的写，location.href的读也一起实现了</strong>，所以可以放心大胆的进行全局替换。找到对应前端工程，首先全局搜索<code>window.location.href</code>，批量替换成<code>(window.location2 || window.location).href</code>，然后再全局搜索<code>location.href</code>，批量替换成<code>(window.location2 || window.location).href</code>（思考一下为什么一定是这个顺序呢）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48ae09523b6f46269362ec9025f51406~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>另外需要注意，有些跳转可能是写在npm包里面的，这种情况只能npm也跟着替换一下了，并没有其它更好办法。</p>
</blockquote>
<h3 id="window-open拦截"><a href="#window-open拦截" class="headerlink" title="window.open拦截"></a>window.open拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">tempOpenName</span> = <span class="hljs-string">&#x27;_rawOpen&#x27;</span><span class="hljs-comment">;</span><br>if (!window<span class="hljs-section">[tempOpenName]</span>) &#123;<br>    window<span class="hljs-section">[tempOpenName]</span> = window.open<span class="hljs-comment">;</span><br>    <span class="hljs-attr">window.open</span> = function(url, name, features) &#123;<br>        <span class="hljs-attr">url</span> = beforeRedirect(url, <span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br>        if (url) &#123;<br>            window<span class="hljs-section">[tempOpenName]</span>(url, name, features)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="history-pushState拦截"><a href="#history-pushState拦截" class="headerlink" title="history.pushState拦截"></a>history.pushState拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">tempName</span> = <span class="hljs-string">&#x27;_rawPushState&#x27;</span><span class="hljs-comment">;</span><br>if (!window.history<span class="hljs-section">[tempName]</span>) &#123;<br>    window.history<span class="hljs-section">[tempName]</span> = window.history.pushState<span class="hljs-comment">;</span><br>    <span class="hljs-attr">window.history.pushState</span> = function(state, title, url) &#123;<br>        <span class="hljs-attr">url</span> = beforeRedirect(url)<span class="hljs-comment">;</span><br>        if (url) &#123;<br>            window.history<span class="hljs-section">[tempName]</span>(state, title, url)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="history-replaceState拦截"><a href="#history-replaceState拦截" class="headerlink" title="history.replaceState拦截"></a>history.replaceState拦截</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">var <span class="hljs-attr">tempName</span> = <span class="hljs-string">&#x27;_rawReplaceState&#x27;</span><span class="hljs-comment">;</span><br>if (!window.history<span class="hljs-section">[tempName]</span>) &#123;<br>    window.history<span class="hljs-section">[tempName]</span> = window.history.replaceState<span class="hljs-comment">;</span><br>    <span class="hljs-attr">window.history.replaceState</span> = function(state, title, url) &#123;<br>        <span class="hljs-attr">url</span> = beforeRedirect(url)<span class="hljs-comment">;</span><br>        if (url) &#123;<br>            window.history<span class="hljs-section">[tempName]</span>(state, title, url)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="全局loading处理"><a href="#全局loading处理" class="headerlink" title="全局loading处理"></a>全局loading处理</h3><p>完成上述步骤后，基本上已经看不出来是iframe了，但是跳转的时候中间有短暂的白屏会有一点顿挫感，体验不算很流畅，这时候可以给iframe加一个全局的loading，开始跳转前显示，页面加载完再隐藏：</p>
<p>B系统：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;iframeDOMContentLoaded&#x27;</span>, &#123; <span class="hljs-attr">url</span>: location.<span class="hljs-property">href</span> &#125;);<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>A系统：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; data, <span class="hljs-keyword">type</span> &#125; = e.<span class="hljs-property">data</span> || &#123;&#125;;<br>    <span class="hljs-comment">// iframe 加载完毕</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;iframeDOMContentLoaded&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>&#125;);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;beforeHistoryChange&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 此时页面并没有立即跳转，需要再稍微等待一下再显示loading</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>&#125;), <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>除此之外还需要利用iframe自带的onload加一个兜底，防止iframe页面没有上报 <code>iframeDOMContentLoaded</code> 事件导致loading不消失：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// iframe自带的onload做兜底</span><br>iframeOnLoad = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>&#125;);<br>&#125;<br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">&#123;this.state.loading&#125;</span> <span class="hljs-attr">tip</span>=<span class="hljs-string">&quot;正在加载...&quot;</span> <span class="hljs-attr">inline</span>=<span class="hljs-string">&#123;false&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;microFrontIframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;this.state.currentEntry&#125;</span> <span class="hljs-attr">onLoad</span>=<span class="hljs-string">&#123;this.iframeOnLoad&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Loading</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>还需要注意，当新标签页打开页面时并不需要显示loading，需要注意区分。</p>
<h3 id="弹窗居中问题"><a href="#弹窗居中问题" class="headerlink" title="弹窗居中问题"></a>弹窗居中问题</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77b8181ef065464580ca0f6480bf66be~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>当前场景下弹窗个人觉得并不需要处理，因为菜单的宽度有限，不仔细看的话甚至都没注意到弹窗没有居中：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b6f64672caa4e3e80b4032e73a5926a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>如果非要处理的话也不麻烦，覆盖一下原来页面弹窗的样式，当包含<code>hideLayout</code>参数时，让弹窗的位置分别向左移动<code>menuWidth/2</code>、向上移动<code>navbarHeight/2</code>即可（遮罩位置不能动、也动不了）。</p>
<p>添加了<code>marginLeft=-120px</code>、<code>marginTop=-30px</code> 后的弹窗效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed44aa14e065408cbe3056441579a5f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>其实不难看出，最终效果和SPA几乎无异，而且菜单和导航本来就是无刷新的，页面跳转没有割裂感：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ef290a47e84bb6ae1e9fa7727a8af1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>上述方案有几个没有提到的点：</p>
<ul>
<li>方案成立的前提是建立在2个系统共用一套用户体系，否则需要对2个系统的登录体系进行打通，一般包括账号绑定、A系统默认免登B系统，等等，这需要一定额外的工作量；</li>
<li>参数的透传与删除，例如我希望除了hideLayout参数之外其它URL参数全部在父子页面之间透传；</li>
<li>埋点，数据上报的时候需要增加一个额外参数来标识流量来自另外一个系统；</li>
</ul>
<p>在第一次摸索方案时可能需要花费一些时间，但是在熟悉之后，如果后续还有类似把B系统接入A系统的需求，在没有特殊情况且顺利的前提下可能花费1-2天时间即可完成，最重要的是大部分工作都是全局生效的，不会随着页面的增多而导致工作量增加，测试回归的成本也非常低，只需要验证所有页面跳转、展示等是否正常，功能本身一般不会有太大问题，而如果是微前端方案的话需要从头到尾全部仔仔细细测试一遍，开发和测试的成本都不可估量。</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7185070739064619068">https://juejin.cn/post/7185070739064619068</a></p>
</blockquote>
<h2 id="7-addEventListener参数"><a href="#7-addEventListener参数" class="headerlink" title="7 addEventListener参数"></a>7 addEventListener参数</h2><p><code>element.addEventListener(event, function, useCapture)</code></p>
<h3 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>event</em></td>
<td align="left">必须。字符串，指定事件名。  <strong>注意:</strong> 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。  <strong>提示：</strong> 所有 HTML DOM 事件，可以查看我们完整的 <a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM Event 对象参考手册</a>。</td>
</tr>
<tr>
<td align="left"><em>function</em></td>
<td align="left">必须。指定要事件触发时执行的函数。  当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</td>
</tr>
<tr>
<td align="left"><em>useCapture</em></td>
<td align="left">可选。布尔值，指定事件是否在捕获或冒泡阶段执行。  可能值:true - 事件句柄在捕获阶段执行false- false- 默认。事件句柄在冒泡阶段执行</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myBtn&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;Hello World&quot;</span>;<br> <br>&#125;);<br> <br></code></pre></td></tr></table></figure>

<p>提示： 使用 removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄。</p>
<p>参数值</p>
<p>event 必须。字符串，指定事件名。</p>
<p>注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。</p>
<p>function 必须。指定要事件触发时执行的函数。</p>
<p>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</p>
<p>useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。</p>
<p>可能值:</p>
<p>true - 事件句柄在捕获阶段执行</p>
<p>false- false- 默认。事件句柄在冒泡阶段执行</p>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>click 当用户点击某个对象时调用的事件句柄。</p>
<p>contextmenu 在用户点击鼠标右键打开上下文菜单时触发</p>
<p>dblclick 当用户双击某个对象时调用的事件句柄。</p>
<p>mousedown 鼠标按钮被按下。</p>
<p>mouseenter 当鼠标指针移动到元素上时触发。</p>
<p>mouseleave 当鼠标指针移出元素时触发</p>
<p>mousemove 鼠标被移动。</p>
<p>mouseover 鼠标移到某元素之上。</p>
<p>mouseout 鼠标从某元素移开。</p>
<p>mouseup 鼠标按键被松开。</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>属性 描述 DOM</p>
<p>keydown 某个键盘按键被按下。</p>
<p>keypress 某个键盘按键被按下并松开。</p>
<p>keyup 某个键盘按键被松开。</p>
<p>框架&#x2F;对象（Frame&#x2F;Object）事件</p>
<p>abort 图像的加载被中断。 ( )</p>
<p>beforeunload 该事件在即将离开页面（刷新或关闭）时触发</p>
<p>error 在加载文档或图像时发生错误。 ( , 和 )</p>
<p>hashchange 该事件在当前 URL 的锚部分发生修改时触发。</p>
<p>load 一张页面或一幅图像完成加载。</p>
<p>pageshow 该事件在用户访问页面时触发</p>
<p>pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发</p>
<p>resize 窗口或框架被重新调整大小。</p>
<p>scroll 当文档被滚动时发生的事件。</p>
<p>unload 用户退出页面。 ( 和 )</p>
<h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><p>blur 元素失去焦点时触发</p>
<p>change 该事件在表单元素的内容改变时触发( , , , 和 )</p>
<p>focus 元素获取焦点时触发</p>
<p>focusin 元素即将获取焦点是触发</p>
<p>focusout 元素即将失去焦点是触发</p>
<p>input 元素获取用户输入是触发</p>
<p>reset 表单重置时触发</p>
<p>search 用户向搜索域输入文本时触发 (</p>
<h4 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h4><p>copy 该事件在用户拷贝元素内容时触发</p>
<p>cut 该事件在用户剪切元素内容时触发</p>
<p>paste 该事件在用户粘贴元素内容时触发</p>
<h4 id="打印事件"><a href="#打印事件" class="headerlink" title="打印事件"></a>打印事件</h4><p>afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发</p>
<p>beforeprint 该事件在页面即将开始打印时触发</p>
<h4 id="拖动事件"><a href="#拖动事件" class="headerlink" title="拖动事件"></a>拖动事件</h4><p>drag 该事件在元素正在拖动时触发</p>
<p>dragend 该事件在用户完成元素的拖动时触发</p>
<p>dragenter 该事件在拖动的元素进入放置目标时触发</p>
<p>dragleave 该事件在拖动元素离开放置目标时触发</p>
<p>dragover 该事件在拖动元素在放置目标上时触发</p>
<p>dragstart 该事件在用户开始拖动元素时触发</p>
<p>drop 该事件在拖动元素放置在目标区域时触发</p>
<h4 id="多媒体（Media）事件"><a href="#多媒体（Media）事件" class="headerlink" title="多媒体（Media）事件"></a>多媒体（Media）事件</h4><p>abort 事件在视频&#x2F;音频（audio&#x2F;video）终止加载时触发。</p>
<p>canplay 事件在用户可以开始播放视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>canplaythrough 事件在视频&#x2F;音频（audio&#x2F;video）可以正常播放且无需停顿和缓冲时触发。</p>
<p>durationchange 事件在视频&#x2F;音频（audio&#x2F;video）的时长发生变化时触发。</p>
<p>emptied The event occurs when the current playlist is empty</p>
<p>ended 事件在视频&#x2F;音频（audio&#x2F;video）播放结束时触发。</p>
<p>error 事件在视频&#x2F;音频（audio&#x2F;video）数据加载期间发生错误时触发。</p>
<p>loadeddata 事件在浏览器加载视频&#x2F;音频（audio&#x2F;video）当前帧时触发触发。</p>
<p>loadedmetadata 事件在指定视频&#x2F;音频（audio&#x2F;video）的元数据加载后触发。</p>
<p>loadstart 事件在浏览器开始寻找指定视频&#x2F;音频（audio&#x2F;video）触发。</p>
<p>pause 事件在视频&#x2F;音频（audio&#x2F;video）暂停时触发。</p>
<p>play 事件在视频&#x2F;音频（audio&#x2F;video）开始播放时触发。</p>
<p>playing 事件在视频&#x2F;音频（audio&#x2F;video）暂停或者在缓冲后准备重新开始播放时触发。</p>
<p>progress 事件在浏览器下载指定的视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>ratechange 事件在视频&#x2F;音频（audio&#x2F;video）的播放速度发送改变时触发。</p>
<p>seeked 事件在用户重新定位视频&#x2F;音频（audio&#x2F;video）的播放位置后触发。</p>
<p>seeking 事件在用户开始重新定位视频&#x2F;音频（audio&#x2F;video）时触发。</p>
<p>stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。</p>
<p>suspend 事件在浏览器读取媒体数据中止时触发。</p>
<p>timeupdate 事件在当前的播放位置发送改变时触发。</p>
<p>volumechange 事件在音量发生改变时触发。</p>
<p>waiting 事件在视频由于要播放下一帧而需要缓冲时触发。</p>
<h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><p>animationend 该事件在 CSS 动画结束播放时触发</p>
<p>animationiteration 该事件在 CSS 动画重复播放时触发</p>
<p>animationstart 该事件在 CSS 动画开始播放时触发</p>
<h4 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h4><p>transitionend 该事件在 CSS 完成过渡后触发。</p>
<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发</p>
<p>online 该事件在浏览器开始在线工作时触发。</p>
<p>offline 该事件在浏览器开始离线工作时触发。</p>
<p>popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。</p>
<h2 id="8-cookie、sessionStorage和localStorage的区别"><a href="#8-cookie、sessionStorage和localStorage的区别" class="headerlink" title="8 cookie、sessionStorage和localStorage的区别"></a>8 cookie、sessionStorage和localStorage的区别</h2><p>一、 概念的理解</p>
<h3 id="webstorage本地存储"><a href="#webstorage本地存储" class="headerlink" title="webstorage本地存储"></a>webstorage本地存储</h3><p>1）webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage</p>
<p>2）localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信</p>
<p>3）sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>
<p>4）WebStorage的目标</p>
<p>提供一种在cookie之外存储会话数据的路径</p>
<p>提供一种存储大量可以跨会话存在的数据的机制</p>
<p>HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）</p>
<p>5）作用域的不同：</p>
<p>不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p>
<p>6）存储大小：</p>
<p>localStorage和sessionStorage的存储数据大小一般都是：5MB</p>
<p>7）存储位置：</p>
<p>localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信</p>
<p>8）存储内容类型：</p>
<p>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p>
<p>9）获取方式：</p>
<p>localStorage：window.localStorage;；sessionStorage：window.sessionStorage;</p>
<p>10）应用场景：</p>
<p>localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据，而sessionStorage：敏感账号一次性登录</p>
<p>11）WebStorage的优点：</p>
<p>存储空间更大：cookie为4KB，而WebStorage是5MB</p>
<p>节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量</p>
<p>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便</p>
<p>快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快</p>
<p>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题</p>
<p>WebStorage提供了一些方法，数据操作比cookie方便</p>
<p>setItem (key, value) —— 保存数据，以键值对的方式储存信息。</p>
<p>getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。</p>
<p>removeItem (key) —— 删除单个数据，根据键值移除对应的信息。</p>
<p>clear () —— 删除所有的数据</p>
<p>key (index) —— 获取某个索引的key</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>1）HTTP Cookie简称cookie,在HTTP请求发送Set-Cookie HTTP头作为响应的一部分。通过name&#x3D;value的形式存储</p>
<p>2）cookie的构成：</p>
<p>名称：name(不区分大小写,但最好认为它是区分的)</p>
<p>值:value(通过URL编码:encodeURIComponent)</p>
<p>域</p>
<p>路径</p>
<p>失效时间:一般默认是浏览器关闭失效,可以自己设置失效时间</p>
<p>安全标志:设置安全标志后只有SSL连接的时候才发送到服务器</p>
<p>3）cookie的作用:主要用于保存登录信息</p>
<p>4）生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>
<p>5）cookie的优点：具有极高的扩展性和可用性</p>
<p>通过良好的编程，控制保存在cookie中的session对象的大小</p>
<p>通过加密和安全传输技术，减少cookie被破解的可能性</p>
<p>只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失</p>
<p>控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie</p>
<p>6）cookie的缺点：</p>
<p>cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉</p>
<p>安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用</p>
<p>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用</p>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>1）sessionStorage是Storage类型的一个对象，拥有clear(),getItem(name),key(index),removeItem(name),setItem(name,value)方法</p>
<p>2）sessionStorage对象存储特定于某个会话的数据,也就是该数据只保持到浏览器关闭</p>
<p>3）将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据</p>
<p>4）sessionStorage为临时保存</p>
<p>localStorage</p>
<p>1）localStorage也是Storage类型的一个对象</p>
<p>2）在HTML5中localStorage作为持久保存在客户端数据的方案取代了globalStorage(globalStorage必须指定域名)</p>
<p>3）localStorage会永久存储会话数据，除非removeItem,否则会话数据一直存在</p>
<p>4）将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用</p>
<p>5）localStorage为永久保存</p>
<p>图示说明：</p>
<p>注意：时刻注意XSS注入的风险，因为可以在控制台直接访问它们，所以不要存入敏感数据</p>
<h3 id="区别的比较"><a href="#区别的比较" class="headerlink" title="区别的比较"></a>区别的比较</h3><p>本地储存localStorage与cookie的区别</p>
<p>1）cookie在浏览器与服务器之间来回传递</p>
<p>sessionStorage和localStorage不会把数据发给服务器，仅在本地保存</p>
<p>2）数据有效期不同</p>
<p>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<p>sessionStorage：仅在当前浏览器窗口关闭前有效</p>
<p>localStorage 始终有效，长期保存</p>
<p>3）cookie数据还有路径的概念，可以限制cookie只属于某个路径下</p>
<p>存储大小也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>4）作用域不用</p>
<p>sessionStorage不在不同的浏览器窗口中共享</p>
<p>localStorage在所有同源窗口中都是共享的</p>
<p>cookie也是在所有同源窗口中都是共享的</p>
<p>WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便</p>
<h4 id="cookie、session和localStorage的区别"><a href="#cookie、session和localStorage的区别" class="headerlink" title="cookie、session和localStorage的区别"></a>cookie、session和localStorage的区别</h4><p>1）cookie的内容主要包括：名字、值、过期时间、路径和域，路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失，这种生命期为浏览器会话期的cookie被称为会话cookie</p>
<p>2）会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。</p>
<p>3）当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</p>
<h4 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h4><p>1）cookie数据存放在客户的浏览器上，session数据放在服务器上</p>
<p>2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</p>
<p>3）session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</p>
<p>4）单个cookie保存的数*据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</p>
<p>5）建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中</p>
<p>6）session保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息</p>
<p>7）session中保存的是对象，cookie中保存的是字符串</p>
<p>8）session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的</p>
<h4 id="web-Storage和cookie的区别"><a href="#web-Storage和cookie的区别" class="headerlink" title="web Storage和cookie的区别"></a>web Storage和cookie的区别</h4><p>1）Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用</p>
<p>2）web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie</p>
<p>3）但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生</p>
<p>sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的</p>
<p>4）Web Storage的好处</p>
<p>减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递</p>
<p>快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示</p>
<p>临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便</p>
<h4 id="浏览器本地存储与服务器端存储的区别"><a href="#浏览器本地存储与服务器端存储的区别" class="headerlink" title="浏览器本地存储与服务器端存储的区别"></a>浏览器本地存储与服务器端存储的区别</h4><p>1）数据既可以在浏览器本地存储，也可以在服务器端存储</p>
<p>2）浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据</p>
<p>3）服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据</p>
<p>4）服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端 ，服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上</p>
<p>5）服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期</p>
<p>6）服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据</p>
<h4 id="sessionStorage、localStorage和cookie的区别"><a href="#sessionStorage、localStorage和cookie的区别" class="headerlink" title="sessionStorage、localStorage和cookie的区别"></a>sessionStorage、localStorage和cookie的区别</h4><p>1）相同点是都是保存在浏览器端、且同源的</p>
<p>2）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
<p>3）存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>4）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>5）作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
<p>6）web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p>
<p>7）web Storage的api接口使用更方便</p>
<h4 id="sessionStorage与页面js数据对象的区别"><a href="#sessionStorage与页面js数据对象的区别" class="headerlink" title="sessionStorage与页面js数据对象的区别"></a>sessionStorage与页面js数据对象的区别</h4><p>1）页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了</p>
<p>2）sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在</p>
<h2 id="9-HTTP备忘录-常用状态码-amp-请求头-amp-响应头-amp-Cookies及请求方法合集"><a href="#9-HTTP备忘录-常用状态码-amp-请求头-amp-响应头-amp-Cookies及请求方法合集" class="headerlink" title="9 HTTP备忘录 | 常用状态码&amp;请求头&amp;响应头&amp;Cookies及请求方法合集"></a>9 HTTP备忘录 | 常用状态码&amp;请求头&amp;响应头&amp;Cookies及请求方法合集</h2><h3 id="HTTP和HTTPS的区别图解"><a href="#HTTP和HTTPS的区别图解" class="headerlink" title="HTTP和HTTPS的区别图解"></a>HTTP和HTTPS的区别图解</h3><p>HTTPS和HTTP相比多了一层加密</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3687ac32cfd4d5191c0cb1e99df44e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002153855635"></p>
<h3 id="HTTP的缓存"><a href="#HTTP的缓存" class="headerlink" title="HTTP的缓存"></a>HTTP的缓存</h3><p>HTTP缓存处理流程</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae548403c531494381177b51fca77ff1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20210920225414298"></p>
<h4 id="1-什么是缓存？"><a href="#1-什么是缓存？" class="headerlink" title="1. 什么是缓存？"></a>1. 什么是缓存？</h4><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力</p>
<p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。</p>
<p>HTTP 1.0协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取。</p>
<blockquote>
<p>另：</p>
</blockquote>
<ul>
<li>Expires因为是对时间设定的，且时间是Greenwich Mean Time （GMT），而不是本地时间，所以对时间要求较高。</li>
</ul>
<h4 id="2-浏览器是如何判断是否使用缓存的"><a href="#2-浏览器是如何判断是否使用缓存的" class="headerlink" title="2. 浏览器是如何判断是否使用缓存的"></a>2. 浏览器是如何判断是否使用缓存的</h4><p>第一次请求：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bbc2df77f4f6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>第二次请求相同网页：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bbaefa56810f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="3-缓存的类别"><a href="#3-缓存的类别" class="headerlink" title="3. 缓存的类别"></a>3. 缓存的类别</h4><p>浏览器缓存分为强缓存和协商缓存</p>
<h5 id="强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status-Code-200-OK"><a href="#强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status-Code-200-OK" class="headerlink" title="强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK"></a>强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bc0c7e54f6ec~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bdbc4b9c8720~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>200 form memory cache : 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</p>
</blockquote>
<blockquote>
<p>200 from disk cache： 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</p>
</blockquote>
<blockquote>
<p>优先访问memory cache,其次是disk cache，最后是请求网络资源</p>
</blockquote>
<h5 id="协商缓存-向服务器发送请求，服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源；"><a href="#协商缓存-向服务器发送请求，服务器会根据这个请求的request-header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response-header通知浏览器从缓存中读取资源；" class="headerlink" title="协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；"></a>协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8bc3172e3a167~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h4 id="4-强缓存和协商缓存的header参数"><a href="#4-强缓存和协商缓存的header参数" class="headerlink" title="4. 强缓存和协商缓存的header参数"></a>4. 强缓存和协商缓存的header参数</h4><p><strong>强缓存：</strong></p>
<p>Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求</p>
<p>Cache-Control：当值设为max-age&#x3D;300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
<p>cache-control：除了该字段外，还有下面几个比较常用的设置值：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；<br>（<span class="hljs-number">2</span>） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；<br>（<span class="hljs-number">3</span>）<span class="hljs-built_in">public</span>：指示响应可被任何缓存区缓存；<br>（<span class="hljs-number">4</span>）private：只能针对个人用户，而不能被代理服务器缓存；<br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span>：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回<span class="hljs-number">304</span>，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上<span class="hljs-keyword">Cache</span>-Control:     no-<span class="hljs-keyword">cache</span>是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。<br>（<span class="hljs-number">6</span>）<span class="hljs-keyword">no</span>-store：禁止一切缓存（这个才是响应不被缓存的意思）。复制代码<br></code></pre></td></tr></table></figure>

<blockquote>
<p>cache-control是http1.1的头字段，expires是http1.0的头字段,如果expires和cache-control同时存在，cache-control会覆盖expires，建议两个都写。</p>
</blockquote>
<p><strong>协商缓存：</strong></p>
<p>Last-Modifed&#x2F;If-Modified-Since和Etag&#x2F;If-None-Match是分别成对出现的，呈一一对应关系</p>
<h5 id="Etag-x2F-If-None-Match："><a href="#Etag-x2F-If-None-Match：" class="headerlink" title="Etag&#x2F;If-None-Match："></a>Etag&#x2F;If-None-Match：</h5><p>Etag：</p>
<blockquote>
<p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。 Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p>
</blockquote>
<p>If-None-Match:</p>
<blockquote>
<p>当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304</p>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/6/16a8c60fb0ef49f0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><h5 id="Last-Modifed-x2F-If-Modified-Since："><a href="#Last-Modifed-x2F-If-Modified-Since：" class="headerlink" title="Last-Modifed&#x2F;If-Modified-Since："></a>Last-Modifed&#x2F;If-Modified-Since：</h5><p>Last-Modified：</p>
<blockquote>
<p>浏览器向服务器发送资源最后的修改时间</p>
</blockquote>
<p>If-Modified-Since：</p>
<blockquote>
<p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。</p>
</blockquote>
<blockquote>
<ul>
<li>Last-Modifed&#x2F;If-Modified-Since的时间精度是秒，而Etag可以更精确。</li>
<li>Etag优先级是高于Last-Modifed的，所以服务器会优先验证Etag</li>
<li>Last-Modifed&#x2F;If-Modified-Since是http1.0的头字段</li>
</ul>
</blockquote>
<p><strong>Expires</strong> ：时间不准</p>
<p><strong>Cache- Control的值有</strong></p>
<ul>
<li><strong>max-age</strong> :单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>
<li><strong>no-cache</strong> :不使用强缓存，需要与服务器验证缓存是否新鲜</li>
<li><strong>no-store</strong> :禁止使用缓存(包括协商缓存)每次都向服务器请求最新的资源</li>
<li><strong>must-revalidate</strong> :在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>ETag&#x2F;lf-None-Match</strong>,：hash 码，代表的是一个资源的标识符</p>
<p><strong>Last- Modified&#x2F;lf- Modified-Since</strong>：文件的最后修改时间</p>
<h3 id="HTTP的常用状态码"><a href="#HTTP的常用状态码" class="headerlink" title="HTTP的常用状态码"></a>HTTP的常用状态码</h3><p><strong>200</strong>	 ：OK，客户端请求成功</p>
<p><strong>301</strong> ：资源(网页等)被永久转移到其它URL</p>
<p><strong>302</strong> ：临时跳转</p>
<p><strong>401</strong>	 ：Unauthorized -请求未经授权</p>
<p><strong>404</strong>  ：请求资源不存在，可能是输入了错误的URL</p>
<p><strong>500</strong>  ：服务器内部发生了不可预期的错误</p>
<p><strong>504</strong>  ： Gateway Timeout-网关或者代理的服务器无法在规定的时间内获得想要的响应。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddc22d21b8684815908eddc6831c32b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20210920192949824"></p>
<h3 id="HTTP常用请求头（Request-Headers）"><a href="#HTTP常用请求头（Request-Headers）" class="headerlink" title="HTTP常用请求头（Request Headers）"></a>HTTP常用请求头（Request Headers）</h3><p><strong>Accept</strong>： 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd96c4225f594de0acdb374c2d7de3bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161729473"></p>
<p><strong>Content-Type</strong>： 客户端发送出去实体内容的类型</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/262ac1dda217486a9ac9e32cd46320f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161801679"></p>
<p><strong>Cache-Control</strong>： 指定请求和响应遵循的缓存机制，如no-cache</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c71a74455c2493c985e9efa5fb11117~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002163255317"></p>
<p><strong>If-Modified-Since</strong>： 对应服务端的<code>Last-Modified</code>,用来匹配看文件是否变动，只能精确到1s之内</p>
<p><strong>Expires</strong>： 缓存控制，在这个时间内不会请求，直接使用缓存，服务端时间</p>
<p><strong>Max-age</strong>： 代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存</p>
<p><strong>If-None-Match</strong>： 对应服务端的ETag,用来匹配文件内容是否改变（非常精确）</p>
<p><strong>Cookie</strong>： 有cookie并且<strong>同域</strong>访问时会自动带上</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/523692dd113c49c18c56cbec1dc54b53~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002155443610"></p>
<p><strong>Referer</strong>： 该页面的来源URL（适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b44922d5149c4c1fb361c12a6009d605~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161835593"></p>
<p><strong>Origin</strong>： 最初的请求是从哪里发起的（只会精确到端口)）,Origin比Referer更尊重隐私</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97abc0d0bf3f4a6db0f6b66d2f0b0198~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002161858626"></p>
<p><strong>User-Agent</strong>： 用户客户端的一些必要信息，如UA头部等</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fd3a146500c48a78ab0738bc707cd01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002155948600"></p>
<h3 id="HTTP常用响应头（Response-Headers）"><a href="#HTTP常用响应头（Response-Headers）" class="headerlink" title="HTTP常用响应头（Response Headers）"></a>HTTP常用响应头（Response Headers）</h3><p><strong>Content-Type</strong>： 服务端返回的实体内容的类型</p>
<p><strong>Cache-Control</strong>： 指定请求和响应遵循的缓存机制，如no-cache</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/795a8b82a5d645f98ed827646526fde0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002163336562"></p>
<p><strong>Last-Modified</strong>：</p>
<p>请求资源的最后修改时间</p>
<p><strong>Expires</strong>： 应该在什么时候认为文档已经过期，从而不再缓存它</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a14b1d358f3045f081d34a41cfa6aa18~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002163349623"></p>
<p><strong>Max-age</strong>： 客户端的本地资源应该缓存多少秒，开启了	Cache-Control	后有效</p>
<p><strong>ETag</strong>： 资源的特定版本的标识符，<code>Etags</code>类似于指纹</p>
<p><strong>Set-Cookie</strong>： 设置和页面关联的cookie,服务器通过这个头部把cookie传给客户端</p>
<p><strong>Server</strong>： 服务器的一些相关信息</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1724879a9bc24812b024b9610539009b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image-20211002160637134"></p>
<p><strong>Access-Control-Allow-Origin</strong>： 服务器端允许的请求Origin头部(譬如为*)</p>
<h3 id="HTTP的各类请求方法"><a href="#HTTP的各类请求方法" class="headerlink" title="HTTP的各类请求方法"></a>HTTP的各类请求方法</h3><p><strong>GET</strong>：</p>
<p>请求一个指定资源的表示形式.使用GET的请求应该只被用于获取数据</p>
<p><strong>POST</strong>：</p>
<p>用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</p>
<p><strong>PUT</strong>：</p>
<p>用请求有效载荷替换目标资源的所有当前表示</p>
<p><strong>DELETE</strong>：</p>
<p>删除指定的资源</p>
<p><strong>HEAD</strong>：</p>
<p>请求一个与GET请求的响应相同的响应，但没有响应体</p>
<p><strong>CONNECT</strong>：</p>
<p>建立一个到由目标资源标识的服务器的隧道。</p>
<p><strong>OPTIONS</strong>：</p>
<p>用于描述目标资源的通信选项。</p>
<p><strong>TRACE</strong>：</p>
<p>沿着到目标资源的路径执行一个消息环回测试。</p>
<p><strong>PATCH</strong>：</p>
<p>用于对资源应用部分修改。</p>
<h3 id="视频直播协议"><a href="#视频直播协议" class="headerlink" title="视频直播协议"></a>视频直播协议</h3><table>
<thead>
<tr>
<th>协议</th>
<th>描述</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>HLS</td>
<td>1、HTTP Live Streaming, Apple公司 2、基于HTTP协议 3、把一段视频流，分成一个个小的基于HTTP的文件来下载</td>
<td>跨平台</td>
</tr>
<tr>
<td>RTMP</td>
<td>1、Real Time Messaging Protocol 2、Adobe公司 3、基于TCP</td>
<td>时延低</td>
</tr>
<tr>
<td>HTTP - FLV</td>
<td>1、基于HTTP 2、http+flv，将音视频数据封装成FLV格式，然后通过HTTP协议传输给客户端</td>
<td>时延低</td>
</tr>
</tbody></table>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Set-Cookie - response</p>
<table>
<thead>
<tr>
<th>Name&#x3D;value</th>
<th>各种cookie的名称和值</th>
</tr>
</thead>
<tbody><tr>
<td>Expires&#x3D;Date</td>
<td>Cookie的有效期，缺省时Cookie仅在浏览器关闭之前有效。</td>
</tr>
<tr>
<td>Path&#x3D; Path</td>
<td>限制指定Cookie的发送范围的文件目录，默认为当前</td>
</tr>
<tr>
<td>Domain&#x3D;domain</td>
<td>限制cookie生效的域名，默认为创建cookie的服务域名</td>
</tr>
<tr>
<td>secure</td>
<td>仅在HTTPS安全连接时，才可以发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>JavaScript脚本无法获得Cookie</td>
</tr>
<tr>
<td><code>SameSite=[None/Strict/Lax]</code></td>
<td>- None同站、跨站请求都可发送 - Strict仅在同站发送 - 允许与顶级导航一起发送，并将与第三方网站发起的GET请求一起发送</td>
</tr>
</tbody></table>
<h2 id="10-前端优化"><a href="#10-前端优化" class="headerlink" title="10 前端优化"></a>10 前端优化</h2><p>降低请求量：合并资源，减少 HTTP 请求数，minify &#x2F; gzip 压缩，webP，lazyLoad。 </p>
<p>加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。</p>
<p> 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。 </p>
<p>渲染：JS&#x2F;CSS 优化，加载顺序，服务端渲染，pipeline</p>
<h2 id="11-GET和POST的区别"><a href="#11-GET和POST的区别" class="headerlink" title="11 GET和POST的区别"></a>11 GET和POST的区别</h2><p>get 参数通过 url 传递，post 放在 request body 中。</p>
<p>get 请求在url 中传递的参数是有长度限制的，而 post 没有。 </p>
<p>get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。</p>
<p>get 请求只能进行url 编码，而 post 支持多种编码方式</p>
<p>get 请求会浏览器主动 cache，而 post 支持多种编码方式。 </p>
<p>get 请求参数会被完整保留在浏览历史记录里，而post 中的参数不会被保留。</p>
<p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器&#x2F;服务器 的限制，导致他们在应用过程中体现出一些不同。 </p>
<p>GET产生一个TCP数据包；POST 产生两个TCP数据包。（对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<h2 id="12-在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？"><a href="#12-在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？" class="headerlink" title="12 在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？"></a>12 在地址栏输入一个url，到这个页面呈现出来，中间会发生什么？</h2><p>输入 url 后，首先需要找到这个 url 域名的服务器 ip。</p>
<p>为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存，</p>
<p>缓存中没有则查找系统的 hosts 文件中是否有记录，</p>
<p>如果没有则查询 DNS 服务器，</p>
<p>得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一 个 http 请求 ，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据 ，并将这个 http 请求封装在一个 tcp 包中，这个 tcp 包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，</p>
<p>因为 html 是一个树形结构，浏览器根据这个html 来构建 DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码 ，这会造成阻塞，这就是为什么推荐 JS 代码应该放在html 代码的后面，之后根据外部样式，内部样式，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如 script，meta 标签和排除 display 为none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等 资源 ，在解析 DOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，</p>
<p>当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过 Cache-Control、Last-Modify、Expires 等首部字段控制。 Cache- Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求 这些有设置了缓存的数据时，会先查看是否过期，如果没有过期则直接使用本地缓 存，过期则请求并在服务器校验文件是否修改，如果上一次响应设置了 ETag 值会在 这次请求的时候作为 If-None-Match 的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。</p>
<h2 id="13-http2-0的特性"><a href="#13-http2-0的特性" class="headerlink" title="13 http2.0的特性"></a>13 http2.0的特性</h2><p>• http2.0 的特性如下： 1、内容安全，应为 http2.0 是基于https 的，天然具有安全特性，通过 http2.0 的特 性可以 避免单纯使用https的性能下降 2、二进制格式，http1.X 的解析是基于文本的，http2.0 将所有的传输信息分割为更 小 的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展 性，比如引入了帧来传输数据和指令 3、多路复用，这个功能相当于是长连接的增强，每个 request 请求可以随机的混杂在 一起，接收方可以根据request 的id将request 再归属到各自不同的服务端请求里 面，另 外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先 级的资 源，可以优先传输。</p>
<h2 id="14-csrf和xss网络攻击及防范"><a href="#14-csrf和xss网络攻击及防范" class="headerlink" title="14 csrf和xss网络攻击及防范"></a>14 csrf和xss网络攻击及防范</h2><p>CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了 恶 意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用 来制 造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候 CSRF 就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是 可 以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的 话：使用验证码，检查 https 头部的 refer，使用 token </p>
<p>XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行 攻 击，比如获取 cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型 是 攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反 射 型的话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中，防御 的话为 cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。</p>
<p>XSS 防御的总体思路是：对输入(和 URL 参数)进行过滤，对输出进行编码。也就是对提 交的所有内容进行过滤，对 url 中的参数进行过滤，过滤掉会导致脚本执行的相关内 容 ；然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。虽然 对 输入过滤可以被绕过，但是也还是会拦截很大一部分的 XSS 攻击。 </p>
<p>防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并 验证；在 HTTP 头中自定义属性并验证。</p>
<h2 id="15-元素居中"><a href="#15-元素居中" class="headerlink" title="15 元素居中"></a>15 元素居中</h2><h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><p>父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。 </p>
<p>父元素固定宽高，子元素设置 position:absolute，margin：auto 平均分配margin css3 属 性 transform。子元素设置 position:absolute;left:50%;top: 50%;transform: translate(- 50%,-50%);即可。 </p>
<p>将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。</p>
<p> 弹性布局 display:flex。设置 align-items: center;justify-content: center</p>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>法一：父元素 display:flex,align-items:center; </p>
<p>法二：元素绝对定位，top:50%，margin-top：-（高度&#x2F;2） </p>
<p>法三：高度不确定用 transform：translateY（-50%）</p>
<p> 法四：父元素 </p>
<h2 id="16-处理溢出"><a href="#16-处理溢出" class="headerlink" title="16 处理溢出"></a>16 处理溢出</h2><p>text-overflow 属性，值为 clip 是修剪文本；ellipsis 为显示省略符号来表被修剪的 文本； string 为使用给定的字符串来代表被修剪的文本。</p>
<h2 id="17-bfc"><a href="#17-bfc" class="headerlink" title="17 bfc"></a>17 bfc</h2><p>BFC 也就是常说的块格式化上下文，这是一个独立的渲染区域，规定了内部如何布局 ，并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算，触发 BFC 的规则有根元 素，浮动元素，position 为 absolute 或 fixed 的元素，display 为 inline-block，table-cell， table-caption，flex，inline-flex，overflow 不为 visible 的元素。</p>
<h2 id="18-calc属性"><a href="#18-calc属性" class="headerlink" title="18 calc属性"></a>18 calc属性</h2><p>Calc 用户动态计算长度值，任何长度值都可以使用 calc()函数计算，需要注意的是，运 算符前后都需要保留一个空格，例如：width:calc(100% - 10px)；</p>
<h2 id="19-table"><a href="#19-table" class="headerlink" title="19 table"></a>19 table</h2><p>Display:table 和本身 table 是相对应的，区别在于，display：table 的 css 声明能 够让一个 html 元素和它的子节点像 table 元素一样，使用基于表格的 css 布局，是我 们能够轻松定 义一个单元格的边界，背景等样式，而不会产生因为使用了 table 那样 的制表标签导致 的语义化问题。 之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写出来的文件比用 table 边写出来的文件小，而且 table 必须在页面完全加载后才显示，div 则是逐行显 示，table 的嵌套性太多，没有 div简洁。</p>
<h2 id="20-闭包"><a href="#20-闭包" class="headerlink" title="20 闭包"></a>20 闭包</h2><p>先了解一些变量的作用域：</p>
<p>变量的作用域包括两种：全局变量和局部变量。</p>
<p>全局变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;<br><span class="hljs-title function_">f1</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>局部变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<span class="hljs-comment">//局部变量</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<span class="hljs-comment">//n is not defined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="一、简单理解闭包"><a href="#一、简单理解闭包" class="headerlink" title="一、简单理解闭包"></a>一、简单理解闭包</h3><p>先看一下MDN关于闭包的定义：</p>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
</blockquote>
<p>重点的一句：<strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</strong></p>
<p>现在不理解也没关系，继续往下看：</p>
<p>学习一个概念时，最好的方法就是找它的demo，从demo中理解和分析，下面先看一段代码，这是一个最简单的闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> f2<span class="hljs-comment">//返回内部函数f2，这样在f1中就能读取f2的数据和函数等价于window.f2 = f2;</span><br>  <br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<ul>
<li>首先定义个普通函数f1；</li>
<li>在f1中再定义一个普通函数f2、和在f1函数中的内部变量n;</li>
<li>在f1中返回函数f2(确切说，在f1中返回了f2的引用);</li>
<li>将f1的返回值赋值给变量result；</li>
<li>执行result</li>
</ul>
<p>在上边的代码中，f1函数里面嵌套了一个函数f2，并且f2调用了f1的变量，那么变量n和函数f2组合就成了一个闭包。</p>
<p>那为什么是闭包呢？我们可以根据上边MDN对闭包的定义这句话（<strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域。</strong>）进行分析，我们再看一张图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e69a7ec327436d8aedf7b92828e961~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="image.png"></p>
<p>f1是一个外部函数，变量n是外部函数的局部变量，f2是嵌套在f1中的一个内部函数，在<strong>内部函数f2中调用了外部函数f1的变量n</strong>,所以f2和变量n就组成了一个闭包。</p>
<p>那么，我们就可以得出产生闭包的条件：</p>
<ul>
<li>一个<strong>外部函数里面嵌套着一个内部函数</strong>；比如外部函数f1里面嵌套了一个内部函数f2</li>
<li>一个嵌套的<strong>内部函数调用了外部函数的内部变量或函数</strong>；比如f2内部函数调用了外部函数f1的变量n 只要满足以上两个条件，就产生了闭包。</li>
</ul>
<p>那你可能会问为什么要return f1呢？</p>
<p>因为在JS中，只要内部函数才能够读取外部函数的内部变量或数据，反之则不行，如果你不return f2，那你将无法使用f2这个闭包，return f2是为了在f1中能使用f2的变量和数据，与闭包没有关系的。</p>
<p>那到底什么是闭包呢？</p>
<p>可以通俗理解成：<strong>闭包就是有权访问另一个函数作用域中内部变量或数据的函数</strong>，因为在JS中，只要内部函数能能够读取外部函数的变量或数据，反之就不行，所有可以将<strong>闭包简单理解成，定义在一个函数内部的函数。</strong></p>
<p>总结：</p>
<p><strong>闭包就是有权访问另一个函数内部变量的函数。</strong></p>
<p><strong>闭包产生的原因：内部函数存在对外部函数局部变量的引用就会导致闭包。</strong></p>
<p>到这里相信你也已经对闭包有了一个简单的了解了，但是单单是了解还是不够的，我们学学习一样技术，最重要的就是要学以致用，那我们继续往下了解吧。</p>
<h3 id="二、闭包的经典使用场景"><a href="#二、闭包的经典使用场景" class="headerlink" title="二、闭包的经典使用场景"></a>二、闭包的经典使用场景</h3><h4 id="1、return一个内部函数，读取内部函数的变量；"><a href="#1、return一个内部函数，读取内部函数的变量；" class="headerlink" title="1、return一个内部函数，读取内部函数的变量；"></a>1、return一个内部函数，读取内部函数的变量；</h4><p>最大的一个用途就是前面提到的可以：读取内部函数的变量；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2；<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2、函数作为参数"><a href="#2、函数作为参数" class="headerlink" title="2、函数作为参数"></a>2、函数作为参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f3</span>(<span class="hljs-params">p</span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1001</span>;<br>  <span class="hljs-title function_">p</span>();<br>&#125;<br><br><span class="hljs-title function_">f3</span>(<span class="hljs-title function_">f1</span>());<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3、IIFE（自执行函数）"><a href="#3、IIFE（自执行函数）" class="headerlink" title="3、IIFE（自执行函数）"></a>3、IIFE（自执行函数）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>&#125;)()<br><span class="hljs-comment">//999</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边的代码中f1( )是一个闭包，调用了全局变量n（即调用了window下的变量n）;</p>
<h4 id="4、循环赋值"><a href="#4、循环赋值" class="headerlink" title="4、循环赋值"></a>4、循环赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;,<span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br><span class="hljs-comment">//1,2,3,4,5,6,7,8,9,10依次打印</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5、使用回调函数就是在使用闭包"><a href="#5、使用回调函数就是在使用闭包" class="headerlink" title="5、使用回调函数就是在使用闭包"></a>5、使用回调函数就是在使用闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">n</span> = <span class="hljs-number">999</span>;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">n</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="6、将外部函数创建的变量值始终保持在内存中；"><a href="#6、将外部函数创建的变量值始终保持在内存中；" class="headerlink" title="6、将外部函数创建的变量值始终保持在内存中；"></a>6、将外部函数创建的变量值始终保持在内存中；</h4><p>可以看下下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n++);<br>  &#125;<br>  result f2<br>&#125;<br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码中f1的内部变量n一直存在内存中，不会在f1调用结束后被自动清除。 再看另一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  nAdd = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    n+=<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  result f2<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//999</span><br><span class="hljs-title function_">nAdd</span>();<br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//1000</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码中函数f1的返回值赋值给了全局变量result，函数f1的返回值实际上就是f2函数，可以理解为f2被赋值给了全局变量result，这就导致了f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束之后，被垃圾回收机制(GC机制)回收，所有很容易造成<strong>内存泄漏</strong>。</p>
<p>内存泄漏，就是一些你访问不到或用不到的变量，还占据着内存空间，不能被再次利用起来。</p>
<h4 id="7、封装对象的私有对象和私有方法；"><a href="#7、封装对象的私有对象和私有方法；" class="headerlink" title="7、封装对象的私有对象和私有方法；"></a>7、封装对象的私有对象和私有方法；</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>)&#123;<br>     privateCounter += val;<br>   &#125;<br>   <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">increment</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">decrement</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">value</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> privateCounter;<br>      &#125;<br>   &#125;<br> &#125;)();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="三、-使用闭包需要注意什么？"><a href="#三、-使用闭包需要注意什么？" class="headerlink" title="三、 使用闭包需要注意什么？"></a>三、 使用闭包需要注意什么？</h3><p>因为使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制（简称GC机制）回收，多度使用闭包会过度占用内存，造成内存泄漏。</p>
<h3 id="四、闭包相关的面试题"><a href="#四、闭包相关的面试题" class="headerlink" title="四、闭包相关的面试题"></a>四、闭包相关的面试题</h3><p>1、简述什么是闭包，闭包的作用是什么？写出一个简单的闭包例子。</p>
<p>2、闭包会造成内存泄漏吗？</p>
<blockquote>
<p>会，因为使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制回收，多度使用闭包会过度占用内存，造成内存泄漏。</p>
</blockquote>
<p>3、for循环和闭包(必刷题)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<span class="hljs-comment">//3</span><br>data[<span class="hljs-number">1</span>]();<span class="hljs-comment">//3</span><br>data[<span class="hljs-number">2</span>]();<span class="hljs-comment">//3</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>上边代码的变量i属于一个全局变量，公用一个作用域，所有输出是3个3； 使用闭包改善上边的写法达到预期的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(data[j] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;,<span class="hljs-number">0</span>)<br>  &#125;)(i)<br>&#125;<br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br>复制代码<br></code></pre></td></tr></table></figure>

<p>4、请写出以下代码的输出结果：</p>
<p>第一题4-1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;<br>    n++<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br>  &#125;<br>  <span class="hljs-title function_">f2</span>();<br>  <span class="hljs-keyword">return</span> f2<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">f1</span>();<span class="hljs-comment">//21</span><br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//22</span><br><span class="hljs-title function_">result</span>();<span class="hljs-comment">//23</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<span class="hljs-comment">//10</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第二题4-2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">x</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>)&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> add5 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> add10 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">10</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add5</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">//7</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add10</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">//12</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第三题4-3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>)&#123;<br>     privateCounter += val;<br>   &#125;<br>   <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-attr">increment</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">decrement</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>     &#125;,<br>     <span class="hljs-attr">value</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> privateCounter;<br>      &#125;<br>   &#125;<br> &#125;)();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>());<span class="hljs-comment">//1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>第四题4-4：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> makeCounter = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>) &#123;<br>    privateCounter += val;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>    &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>    &#125;,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> privateCounter;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter1</span> = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter2</span> = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//0</span><br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//2</span><br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter2</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>

<p>Counter1和Counter2是两个独立的闭包，一个闭包变量的值改变不会影响到另一个闭包的变量。</p>
<p>第五题4-5：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">//10 10 10 10 10 10 10 10 10 10每隔1秒输出10，一共10个10</span><br></code></pre></td></tr></table></figure>

<p>因为setTimeout是异步的，for循环是同步的，同步代码执行完，i已经是10了，异步代码才开始执行，所以i最后打印的是10。</p>
<p>如果将var换成let，打印的结果也不一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<span class="hljs-comment">//1,2,3,4,5,6,7,8,9,10</span><br></code></pre></td></tr></table></figure>

<p>在for循环中使用var,那i就是一个全局变量，循环结束之后i的值为10。</p>
<h2 id="21-js的节流和防抖"><a href="#21-js的节流和防抖" class="headerlink" title="21 js的节流和防抖"></a>21 js的节流和防抖</h2><blockquote>
<p>节流与防抖的作用都是防止函数多次调用。区别在于，假如用户一直触发这个函数，且每次触发函数的间隔小于阙值，防抖的情况下只会调用一次，而节流会每隔一定时间调用函数。</p>
</blockquote>
<h4 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h4><blockquote>
<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>节流与防抖<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">	    <span class="hljs-selector-id">#container</span>&#123;</span><br><span class="language-css">	        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#444</span>; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">	    &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-keyword">var</span> count = <span class="hljs-number">1</span>;</span><br><span class="language-javascript">	<span class="hljs-keyword">var</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserAction</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">	    container.<span class="hljs-property">innerHTML</span> = count++;</span><br><span class="language-javascript">	&#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-comment">// container.onmousemove = getUserAction;</span></span><br><span class="language-javascript">	container.<span class="hljs-property">onmousemove</span> = <span class="hljs-title function_">debounce</span>(getUserAction, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;</span><br><span class="language-javascript">	    <span class="hljs-keyword">var</span> timeout;</span><br><span class="language-javascript">	    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">	        <span class="hljs-built_in">clearTimeout</span>(timeout)</span><br><span class="language-javascript">	        timeout = <span class="hljs-built_in">setTimeout</span>(func, wait);</span><br><span class="language-javascript">	    &#125;</span><br><span class="language-javascript">	&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里核心思路就是建立一个定时器，重写onmousemove方法，一旦触发onmousemove，先清除定时器，随后再开一个定时器，指定时间后执行函数。这就实现了一个简易的防抖，指定时间内重复触发函数只会执行一次。已经很好的解决了高频重复触发的问题，但因为直接重写了onmousemove函数，this与event均丢失了。</p>
<p>先解决this指向问题，正常在onmousemove函数中，this指向的应该是调用函数的对象，也就是container，因为在debounce中返回了真正重写onmousemove的函数，形成了一个闭包，导致this丢失。指定this指向的方法有apply与call，用法差别只在参数，call需要的是一个数组，这里就用apply。</p>
<p>修改后的debounce函数为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>    <span class="hljs-keyword">var</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout)<br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            func.<span class="hljs-title function_">apply</span>(context)<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决event参数，正常在onmousemove函数中有一个event，指向当前的事件对象。因为debounce函数返回的是一个匿名函数，可以通过arguments属性来获取参数，该属性是一个由函数参数组成的类数组。</p>
<p>修改后的debounce：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>    <span class="hljs-keyword">var</span> timeout;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>        <span class="hljs-built_in">clearTimeout</span>(timeout)<br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            func.<span class="hljs-title function_">apply</span>(context, args)<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><blockquote>
<p>规定在一个单位时间内，只能触发一次函数。如果这个函数单位时间内触发多次函数，只有一次生效。</p>
</blockquote>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。 我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<ul>
<li><p>使用时间戳</p>
<p>当时间触发时，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> context, args;<br>  <span class="hljs-keyword">var</span> previous = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>      context = <span class="hljs-variable language_">this</span>;<br>      args = <span class="hljs-variable language_">arguments</span>;<br>      <span class="hljs-keyword">if</span> (now - previous &gt; wait) &#123;<br>          func.<span class="hljs-title function_">apply</span>(context, args);<br>          previous = now;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用定时器</p>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>    <span class="hljs-keyword">var</span> timeout;<br>    <span class="hljs-keyword">var</span> previous = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        context = <span class="hljs-variable language_">this</span>;<br>        args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (!timeout) &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>                func.<span class="hljs-title function_">apply</span>(context, args)<br>            &#125;, wait)<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这两种方式都是将函数放到定时器里，js并不会立即去执行该函数，因为js是单线程的，定时器里的函数属于异步函数，异步函数会被放置在事件队列中，当同步代码执行完后，才会依次执行事件队列中的代码。如果需要立即执行改函数，就需要小小的改动下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>    <span class="hljs-keyword">var</span> timeout, context, args, result;<br>    <span class="hljs-keyword">var</span> previous = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">var</span> later = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        previous = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        timeout = <span class="hljs-literal">null</span>;<br>        func.<span class="hljs-title function_">apply</span>(context, args)<br>    &#125;;<br><br>    <span class="hljs-keyword">var</span> throttled = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">//下次触发 func 剩余的时间</span><br>        <span class="hljs-keyword">var</span> remaining = wait - (now - previous);<br>        context = <span class="hljs-variable language_">this</span>;<br>        args = <span class="hljs-variable language_">arguments</span>;<br>         <span class="hljs-comment">// 如果没有剩余的时间了或者你改了系统时间</span><br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) &#123;<br>            <span class="hljs-keyword">if</span> (timeout) &#123;<br>                <span class="hljs-built_in">clearTimeout</span>(timeout);<br>                timeout = <span class="hljs-literal">null</span>;<br>            &#125;<br>            previous = now;<br>            func.<span class="hljs-title function_">apply</span>(context, args);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timeout) &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(later, remaining);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> throttled;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方式有个比较巧妙地方就是他计算了下次触发函数的剩余时间，上面根据时间戳方式实现节流是直接比较当前时间戳与上一个时间戳，这里来用时间间隔减去当前时间戳与上一个时间戳之差，计算结果就是函数下次触发的剩余时间，如果这个剩余时间大于0，表明将要停止节流函数，立即清除定时器，立即执行函数。</p>
<p>完整代码：<a href="https://link.juejin.cn/?target=https://github.com/jinxudong996/blog/blob/main/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/code/debounce/index.html">github.com&#x2F;jinxudong99…</a></p>
</li>
</ul>
<h2 id="22-js中的垃圾回收机制"><a href="#22-js中的垃圾回收机制" class="headerlink" title="22 js中的垃圾回收机制"></a>22 js中的垃圾回收机制</h2><p>本文主要围绕JS引擎相关知识，来深入了解底层运行逻辑，这对于日常开发维护高性能Javascript代码以及排查代码性能问题有着很好的帮助。关于JS引擎底层的垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化，实现对JS内存管理以及内存溢出的处理。</p>
<p>那么我们需要考虑几个问题：</p>
<ul>
<li>什么是垃圾回收机制（GC）？</li>
<li>垃圾是怎样产生的？</li>
<li>为什么要进行垃圾回收？</li>
<li>Javascript的内存是如何管理的？</li>
<li>Chrome浏览器又是如何进行垃圾回收的？</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在Javascript编程中，内存管理大概分成三个步骤，也是内存的生命周期：</p>
<ul>
<li>分配你所需系统内存的空间</li>
<li>使用分配到的内存进行读写操作</li>
<li>不需要使用内存时，将空间进行释放和归还</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ca5e11ded7433cbf09a98a70856d29~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (4).png"></p>
<p>与其它手动管理内存的语言不一样的是，在Javascript中，当我们创建变量时，系统会给对象进行自动分配对应的内存空间以及闲置资源回收，也就是不需要我们手动进行分配。但是，正是因为垃圾回收机制导致开发者有着错误的感觉，就是他们不用关心内存管理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;yichuan&quot;</span>;<span class="hljs-comment">//给字符串分配栈内存</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;<span class="hljs-comment">//给数值分配栈内存</span><br><br><span class="hljs-comment">//给对象以及包含的值分配堆内存</span><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;onechuan&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">19</span><br>&#125;<br><span class="hljs-comment">//给数组以及包含的值分配堆内存</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;yichuan&quot;</span>,<span class="hljs-string">&quot;onechuan&quot;</span>,<span class="hljs-number">18</span>];<br><span class="hljs-comment">//给函数对象分配堆内存</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">x,y</span>)&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在前面《Javascript的数据类型知多少》文中，我们知道了基础数据类型和引用数据类型的分配机制，即：</p>
<ul>
<li>简单数据类型内存保存在固定的栈空间中，可直接通过值进行访问</li>
<li>引用数据类型的值大小不固定，其引用地址保存在栈空间、引用所指向的值保存在堆空间中，需要通过引用进行访问</li>
</ul>
<p>栈内存中的基本数据类型，可以直接通过操作系统进行处理，而堆内存中的引用数据类型的值大小不确定，因此需要JS的引擎通过垃圾回收机制进行处理。</p>
<h3 id="内存回收机制（GC）"><a href="#内存回收机制（GC）" class="headerlink" title="内存回收机制（GC）"></a>内存回收机制（GC）</h3><p>Javascript的V8引擎被限制了内存的使用，因此根据不同操作系统的内存大小会不一样。</p>
<p>V8引擎最初设计是作为浏览器的引擎，并未考虑占据过多的内存空间，随着web技术工程化的发展，占据了越来越多的内存空间。又由于被v8的会回收机制所限制，这样就引起了js执行的线程被挂起，会影响当前执行的页面应用性能。</p>
<p><strong>垃圾回收算法：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清楚或释放内存。</strong> 但是垃圾回收算法是个不完美的方案，因为某块内存是否还可用，属于不可预判的问题，也就意味着单纯依靠算法是解决不了的。还有为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了。</p>
<p>我们知道了垃圾是如何产生的，那么我们应该如何清除呢？在浏览器的发展历史上有两种解决策略：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除分为：标记阶段和清除阶段。</p>
<p>首先它会遍历堆内存上所有的对象，分别给它们打上标记，然后在代码执行过程结束之后，对所使用过的变量取消标记。在清除阶段再把具有标记的内存对象进行整体清除，从而释放内存空间。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae628622e794fcdaba8012668c44385~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (5).png"></p>
<p>整个标记清除算法大致过程就像下面这样</p>
<ul>
<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记</li>
<li>然后从各个根对象开始遍历，把还在被上下文变量引用的变量标记去掉标记</li>
<li>清理所有带有标牌机的变量，销毁并回收它们所占用的内存空间</li>
<li>最后垃圾回收程序做一次内存清理</li>
</ul>
<p>使用标记清除策略的最重要的优点在于简单，无非是标记和不标记的差异。通过标记清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，这就造成出现内存碎片的问题。内存碎片多了后，如果要存储一个新的需要占据较大内存空间的对象，就会造成影响。对于通过标记清除产生的内存碎片，还是需要通过标记整理策略进行解决。</p>
<p>简而言之：</p>
<ul>
<li>优点：简单</li>
<li>缺点：内存碎片化、分配速度慢</li>
</ul>
<h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>经过标记清除策略整理后，老生代内存中因此产生了许多内存碎片，如果不进行清理内存碎片，就会对存储造成影响。</p>
<p><strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决标记清除的两个缺点。它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00446ce9546a4194832617a5fb7b07c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (6).png"></p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数是一种不常见的垃圾回收策略，其思路就是对每个值都记录其的引用次数。具体的：</p>
<ul>
<li>当变量进行声明并赋值后，值的引用数为1。</li>
<li>当同一个值被赋值给另一个变量时，引用数+1</li>
<li>当保存该值引用的变量被其它值覆盖时，引用数-1</li>
<li>当该值的引用数为0时，表示无法再访问该值了，此时就可以放心地将其清除并回收内存。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() 	<span class="hljs-comment">// 此对象的引用计数为 1（a引用）</span><br><span class="hljs-keyword">let</span> b = a 		<span class="hljs-comment">// 此对象的引用计数是 2（a,b引用）</span><br>a = <span class="hljs-literal">null</span>  		<span class="hljs-comment">// 此对象的引用计数为 1（b引用）</span><br>b = <span class="hljs-literal">null</span> 	 	<span class="hljs-comment">// 此对象的引用计数为 0（无引用）</span><br>...			<span class="hljs-comment">// GC 回收此对象</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>这种回收策略看起来很方便，但是当其进行循环引用时就会出现问题，会造成大量的内存不会被释放。当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一。</p>
<h3 id="V8对于垃圾回收机制的优化"><a href="#V8对于垃圾回收机制的优化" class="headerlink" title="V8对于垃圾回收机制的优化"></a>V8对于垃圾回收机制的优化</h3><p>大多数浏览器都是基于标记清除算法，不同的只是在运行垃圾回收的频率具有差异。V8 对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化。</p>
<h4 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h4><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。</p>
<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。</p>
<p>V8 整个堆内存的大小就等于新生代加上老生代的内存，对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51af8d575c54ea9bccfccacf828144b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (7).png"></p>
<h4 id="新生代内存回收"><a href="#新生代内存回收" class="headerlink" title="新生代内存回收"></a>新生代内存回收</h4><p>在64操作系统下分配为32MB，因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是能够理解。</p>
<p>对于新生代内存的回收，通常是通过Scavenge 的算法进行垃圾回收，就是将新生代内存进行一分为二，正在被使用的内存空间称为使用区，而限制状态的内存空间称为空闲区。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dac4e1334124e048f0e8a69126e2d7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="未命名文件 (8).png"> 新生代内存回收的原理是：</p>
<ul>
<li>新加入的对象都会存放在使用区，当使用区快写满时就进行一次垃圾清理操作。</li>
<li>在开始进行垃圾回收时，新生代回收器会对使用区内的对象进行标记</li>
<li>标记完成后，需要对使用区内的活动对象拷贝到空闲区进行排序</li>
<li>而后进入垃圾清理阶段，将非活动对象占用的内存空间进行清理</li>
<li>最后对使用区和空闲区进行交换，使用区-&gt;空闲区，空闲区-&gt;使用区</li>
</ul>
<p>新生代中的变量如果经过回收之后依然一直存在，那么会放入到老生代内存中，只要是已经经历过一次Scavenge算法回收的，就可以晋升为老生代内存的对象。</p>
<h4 id="老生代内存回收"><a href="#老生代内存回收" class="headerlink" title="老生代内存回收"></a>老生代内存回收</h4><p>当然，Scavenge算法也有其适用场景范围，对于内存空间较大的就不适合使用Scavenge算法。此时应该使用Mark-Sweep（标记清除）和Mark-Compact（标记整理）的策略进行老生代内存中的垃圾回收。</p>
<p>首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。</p>
<p>同样的标记清除策略会产生内存碎片，因此还需要进行标记整理策略进行优化。</p>
<h3 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h3><p>内存泄漏，指在JS中已经分配内存地址的对象由于长时间未进行内存释放或无法清除，造成了长期占用内存，使得内存资源浪费，最终导致运行的应用响应速度变慢以及最终崩溃的情况。</p>
<p>在代码中创建对象和变量时会占据内存，但是<strong>JS基于自己的内存回收机制是可以确定哪些变量不再需要，并将其进行清除</strong>。但是，当你的代码中存在逻辑缺陷时，你以为你已经不需要，但是程序中还存在这引用，这就导致程序运行完后并没有进行合适的回收所占有的内存空间。运行时间越长占用内存越多，随之出现的问题就是：性能不佳、高延迟、频繁崩溃。</p>
<p>造成内存泄漏的常见原因有：</p>
<ul>
<li><strong>过多的缓存</strong>。及时清理过多的缓存。</li>
<li><strong>滥用闭包</strong>。尽量避免使用大量的闭包。</li>
<li><strong>定时器或回调太多</strong>。与节点或数据相关联的计时器不再需要时，DOM节点对象可以清除，整个回调函数也不再需要。可是，计时器回调函数仍然没有被回收（计时器停止才会被回收）。当不需要setTimeout或setInterval时，<strong>定时器没有被清除</strong>，定时器的糊掉函数以及其内部依赖的变量都不能被回收，<strong>会造成内存泄漏</strong>。解决方法：在定时器完成工作时，需要手动清除定时器。</li>
<li><strong>太多无效的DOM引用</strong>。DOM删除了，但是节点的引用还在，导致GC无法实现对其所占内存的回收。解决方法：给删除的DOM节点引用设置为null。</li>
<li><strong>滥用全局变量。</strong>全局变量是根据定义无法被垃圾回收机制进行收集的，因此需要特别注意临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，请确保将其指定为null或在完成后重新分配它。解决方法：使用严格模式。</li>
<li><strong>从外到内执行appendChild。</strong>此时即使调用removeChild也无法进行释放内存。解决方法：从内到外appendChild。</li>
<li><strong>反复重写同一个数据会造成内存大量占用</strong>，但是IE浏览器关闭后会被释放。</li>
<li><strong>注意程序逻辑</strong>，避免编写『死循环』之类的代码。</li>
<li><strong>DOM对象和JS对象相互引用</strong>。</li>
</ul>
<p>关于内存泄漏，如果你想要更好地排查以及提前避免问题的发生，最好的解决方法是通过熟练使用Chrome的内存剖析工具，多分析多定位Chrome帮你分析保留的内存快照，来查看持续占用大量内存的对象。</p>
<h2 id="23-eval"><a href="#23-eval" class="headerlink" title="23 eval"></a>23 eval</h2><p>解析成js并执行。</p>
<p>语法：<code>eval(string)</code></p>
<h2 id="24-实现一个once函数，只执行一次"><a href="#24-实现一个once函数，只执行一次" class="headerlink" title="24 实现一个once函数，只执行一次"></a>24 实现一个once函数，只执行一次</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ones</span>(<span class="hljs-params">func</span>)&#123;<br>    <span class="hljs-keyword">var</span> tag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">if</span>(tag==<span class="hljs-literal">true</span>)&#123;<br>            func.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>,<span class="hljs-variable language_">arguments</span>);<br>            tag=<span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="25-将原生的ajax封装成promise"><a href="#25-将原生的ajax封装成promise" class="headerlink" title="25 将原生的ajax封装成promise"></a>25 将原生的ajax封装成promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myNewAjax=<span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,url);<br>        xhr.<span class="hljs-title function_">send</span>(data);<br>        xhr.<span class="hljs-property">onreadystatechange</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span>==<span class="hljs-number">200</span>&amp;&amp;readyState==<span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-keyword">var</span> json=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);<br>                <span class="hljs-title function_">resolve</span>(json)<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span>==<span class="hljs-number">4</span>&amp;&amp;xhr.<span class="hljs-property">status</span>!=<span class="hljs-number">200</span>)&#123;<br>                <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="26-setTimeout、setInterval和requestAnimationFrame的不同"><a href="#26-setTimeout、setInterval和requestAnimationFrame的不同" class="headerlink" title="26 setTimeout、setInterval和requestAnimationFrame的不同"></a>26 setTimeout、setInterval和requestAnimationFrame的不同</h2><p>与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔，大多数电 脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。大多数浏览器都 会对重绘 操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验 也不会有 提升。因此，最平滑动画的最佳循环间隔是 1000ms&#x2F;60，约等于 16.6ms。 RAF 采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的 任 务多的话， 会响应setTimeout和setInterval真正运行时的时间间隔。 </p>
<p>特点： </p>
<p>（1）requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或 回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 </p>
<p>（2）在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这 当 然就意味着更少的 CPU、GPU 和内存使用量 </p>
<p>（3）requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会 自 动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节 省了 CPU 开销</p>
<h2 id="27-代码执行顺序"><a href="#27-代码执行顺序" class="headerlink" title="27 代码执行顺序"></a>27 代码执行顺序</h2><p><a target="_blank" rel="noopener" href="https://github.com/forthealllight/blog/issues/5">从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue · Issue #5 · forthealllight&#x2F;blog (github.com)</a></p>
<h3 id="1-问题的引出"><a href="#1-问题的引出" class="headerlink" title="1. 问题的引出"></a>1. 问题的引出</h3><p>event loop都不陌生，是指主线程从“任务队列”中循环读取任务，比如</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">1</span>：<br><br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">//输出2,1</span><br></code></pre></td></tr></table></figure>

<p>在上述的例子中，我们明白首先执行主线程中的同步任务，当主线程任务执行完毕后，再从event loop中读取任务，因此先输出2，再输出1。</p>
<p>event loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。比如下面一个例子：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">2</span>：<br><br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>Promise.resolve().then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//输出为  1  2 3</span><br></code></pre></td></tr></table></figure>

<p>先输出1，没有问题，因为是同步任务在主线程中优先执行，这里的问题是setTimeout和Promise.then任务的执行优先级是如何定义的。</p>
<h3 id="2-Job-queue中的执行顺序"><a href="#2-Job-queue中的执行顺序" class="headerlink" title="2 . Job queue中的执行顺序"></a>2 . Job queue中的执行顺序</h3><p>在Job queue中的队列分为两种类型：macro-task和microTask。我们举例来看执行顺序的规定，我们设</p>
<p>macro-task队列包含任务: <em><strong>a1, a2 , a3</strong></em><br>micro-task队列包含任务: <em><strong>b1, b2 , b3</strong></em></p>
<p>执行顺序为，首先执行marco-task队列开头的任务，也就是 <em><strong>a1</strong></em> 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行<em><strong>b1, b2 , b3</strong></em>，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。</p>
<p>了解完了macro-task和micro-task两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：</p>
<p>macro-task队列真实包含任务：</p>
<p><em><strong>*script(主程序代码),setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering*</strong></em></p>
<p>micro-task队列真实包含任务：<br><em><strong>process.nextTick, Promises, Object.observe, MutationObserver</strong></em></p>
<p>由此我们得到的执行顺序应该为：</p>
<p><em><strong>script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I&#x2F;O——&gt;UI rendering</strong></em></p>
<p>在ES6中macro-task队列又称为ScriptJobs，而micro-task又称PromiseJobs</p>
<h3 id="3-真实环境中执行顺序的举例"><a href="#3-真实环境中执行顺序的举例" class="headerlink" title="3 . 真实环境中执行顺序的举例"></a>3 . 真实环境中执行顺序的举例</h3><h4 id="1-setTimeout和promise"><a href="#1-setTimeout和promise" class="headerlink" title="(1) setTimeout和promise"></a>(1) setTimeout和promise</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例<span class="hljs-number">3</span>:<br><br>setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>Promise.resolve().then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>我们先以第1小节的例子为例，这里遵循的顺序为：</p>
<p><em><strong>script(主程序代码)——&gt;promise——&gt;setTimeout</strong></em><br>对应的输出依次为：1 ——&gt;2————&gt;3</p>
<h4 id="2-process-nextTick和promise、setTimeout"><a href="#2-process-nextTick和promise、setTimeout" class="headerlink" title="(2) process.nextTick和promise、setTimeout"></a>(2) process.nextTick和promise、setTimeout</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例子<span class="hljs-number">4</span>：<br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>   resolve();<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)&#125;);<br><br>process.nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">//输出2,6,5,3,4,1</span><br></code></pre></td></tr></table></figure>

<p>这个例子就比较复杂了，这里要注意的一点在定义promise的时候，promise构造部分是同步执行的，这样问题就迎刃而解了。</p>
<p>首先分析Job queue的执行顺序：</p>
<p><em><strong>script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</strong></em></p>
<p>I) <em><strong>主体部分</strong></em>： 定义promise的构造部分是同步的，<br>因此先输出2 ，主体部分再输出6（同步情况下，就是严格按照定义的先后顺序）</p>
<p>II)<em><strong>process.nextTick</strong></em>: 输出5</p>
<p>III）<em><strong>promise</strong></em>： 这里的promise部分，严格的说其实是promise.then部分，输出的是3,4</p>
<p>IV) <em><strong>setTimeout</strong></em> ： 最后输出1</p>
<p>综合的执行顺序就是： 2——&gt;6——&gt;5——&gt;3——&gt;4——&gt;1</p>
<h4 id="3-更复杂的例子"><a href="#3-更复杂的例子" class="headerlink" title="(3)更复杂的例子"></a>(3)更复杂的例子</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)&#125;,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>   setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;resolve()&#125;,<span class="hljs-number">0</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)&#125;);<br><br>process.nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//输出的是  2 6 5 1 3 4</span><br></code></pre></td></tr></table></figure>

<p>这种情况跟我们（2）中的例子，区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p>
<h2 id="28-深入理解JS中的事件发射器（Event-Emitters）"><a href="#28-深入理解JS中的事件发射器（Event-Emitters）" class="headerlink" title="28 深入理解JS中的事件发射器（Event Emitters）"></a>28 深入理解JS中的事件发射器（Event Emitters）</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>先看一个<code>DOM</code>事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-comment">/* do something with the event */</span>)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>以上代码在<code>button</code>上添加了一个事件监听器，每当点击<code>button</code>的时候，点击事件被触发出去并且同时调用<code>callback</code>函数。</p>
<p>有很多时候可能会有需要触发自定义事件的需求，不单单只是一个点击事件，假设有这样一个需要触发一个基于其他触发器的事件，并且需要有一个事件响应的，可以自定义一个<code>event emitter</code>来实现。</p>
<p>一个<code>event emitter</code>就是监听一个<code>event</code>，触发一个回调函数，然后<code>emit</code>一个带有<code>value</code>的事件的一种模式，有时候也称为<code>pub/sub</code>模型或者监听器。</p>
<p>在JavaScript中的一种实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">event</span> = <span class="hljs-keyword">new</span> EventEmitter();<br><br><span class="hljs-keyword">event</span>.subscribe(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-keyword">value</span> =&gt; (n = <span class="hljs-keyword">value</span>));<br><br><span class="hljs-keyword">event</span>.emit(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">// n: 18</span><br><br><span class="hljs-keyword">event</span>.emit(<span class="hljs-string">&quot;THUNDER_ON_THE_MOUNTAIN&quot;</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// n: 5</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们订阅了一个叫做 <code>THUNDER_ON_THE_MOUNTAIN</code>的事件，并且当事件被 <code>emitted</code> 的时候，回调函数 <code>value =&gt; (n = value)</code> 也会被触发，可以调用 <code>emit()</code>来<code>emit</code>该事件。</p>
<p>这在与异步代码交互的时候，如果有不在当前模块下的值需要更新时十分有用。</p>
<p>一个真实的例子就是<a href="https://link.juejin.cn/?target=https://react-redux.js.org/">React Redux</a>， <code>Redux</code>需要一种通知外部其内部的值已经更新的机制，其允许<code>React</code>调用<code>setState()</code>并重新渲染UI来获取哪些值已经改变，这个地方也是使用<code>event emitter</code>来实现的。 <code>Redux store</code>有一个传入一个提供新的<code>store</code>的回调函数作为参数的订阅函数，在这个订阅函数中，调用了 <code>React Redux</code>的以新<code>store</code>的值调用了<code>setState()</code>方法的 <code>&lt;Provider&gt;</code> 组件，可以<a href="https://link.juejin.cn/?target=https://github.com/reduxjs/react-redux/blob/master/src/components/Provider.js%23L36">在此</a>查看。</p>
<p>现在我们的应用有了两个不同的部分，一部分是<code>React UI</code>，另一部分是<code>Redux store</code>，谁也说不清楚事件究竟是被那一部分触发的。</p>
<h3 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h3><p>先看一个简单的<code>event emitter</code>，其中使用了<code>class</code>，在这个<code>class</code>中跟踪事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  public <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>事件</li>
</ul>
<p>定义一个事件接口，用来存储一个每一个<code>key</code>都是一个事件名并且各自的值都是回调函数组成的数组的空白对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">Events</span> &#123;<br>  [<span class="hljs-attr">key</span>: string]: <span class="hljs-title class_">Function</span>[];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &quot;event&quot;: [fn],</span><br><span class="hljs-comment">  &quot;event_two&quot;: [fn]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>使用数组的原因是因为每一个事件都可能有多个<code>subscriber</code>，因为<code>element.addEventLister(&quot;click&quot;)</code>可能会被多次调用。</p>
<ul>
<li>订阅</li>
</ul>
<p>现在需要处理订阅的事件，在上面的例子中，<code>subscribe()</code>函数接收两个参数：一个<code>name</code>和一个<code>callback</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">event.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;named event&quot;</span>, <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br></code></pre></td></tr></table></figure>

<p>定义一个<code>subscribe</code>方法来接收这两个参数，只需把这两个参数添加到类内部的<code>this.events</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>发射</li>
</ul>
<p>到此可以订阅事件了，接下来，当一个新事件发射的时候需要触发回调函数，当触发的时候，将使用<code>(emit(&quot;event&quot;))</code>中存储的事件名和需要传递到回调函数<code>(emit(&quot;event&quot;, value))</code>的任意值，我们可以简单地传递任意参数到回调函数在第一个参数后面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">emit</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">void</span> &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然我们知道了我们希望发射的事件，可以使用<code>this.events[name]</code>来查看，返回的是一个回调函数的数组。</p>
<ul>
<li>取消订阅</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: string, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>  (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码返回一个带有<code>unsubscribe</code>方法的对象，可以使用箭头函数<code>() =&gt;</code>来获取传递给父对象参数的作用域，在这个函数中，使用<code>&gt;&gt;&gt;</code><a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it">操作符</a>可以找到传递给父级回调函数的索引，在这里使用可以保证我们每次在回调函数数组上调用<code>splice()</code> 的时候总是可以取到一个真正的数字，即使<code>indexOf()</code> 都不能返回数字也行。 可以这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> subscription = event.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;event&quot;</span>, <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br><br>subscription.<span class="hljs-title function_">unsubscribe</span>();<br></code></pre></td></tr></table></figure>

<p>到此，我们就可以取消这一个特别的订阅了，而且不影响其他的订阅。</p>
<ul>
<li>完整实现</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Events</span> &#123;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Function</span>[];<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">events?: Events</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = events || &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, cb: <span class="hljs-built_in">Function</span></span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">emit</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">void</span> &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>实例</li>
</ul>
<p><a href="https://link.juejin.cn/?target=https://codepen.io/charliewilco/pen/gEoErR">codepen.io&#x2F;charliewilc…</a></p>
<p>上述代码中，首先在另外一个事件回调中使用了<code>event emitter</code>，在这种情况下，一个<code>event emitter</code>是用来清除一些逻辑，在GitHub上选择一个仓库，获取详情，缓存详情，并更新DOM去显示这些详情。在订阅回调函数中从网络或者缓存中获取结果并更新，可以这样做的原因是当我们发射时间的时候从列表中给了回调函数一个随机的仓库。</p>
<p>现在来考虑一些不太一样的东西，在一个应用中，可能会有许多状态需要登录之后才可以触发，并且可能会有多个订阅器来处理用户试图退出的操作。因为已经发射了一个带<code>false</code>值的事件，每一个订阅器都可以使用这个值，并且需要判断是否需要重定向页面，移除cookie或者禁用表单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> events = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br><br>events.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-literal">false</span>);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  buttonEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;disabled&quot;</span>, !isLogged);<br>&#125;);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">replace</span>(!isLoggedIn ? <span class="hljs-string">&quot;/login&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>&#125;);<br><br>events.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;authentication&quot;</span>, <span class="hljs-function"><span class="hljs-params">isLoggedIn</span> =&gt;</span> &#123;<br>  !isLoggedIn &amp;&amp; cookies.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;auth_token&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>最后</li>
</ul>
<p>要让<code>emitters</code>能工作，有几点需要考虑：</p>
<ul>
<li>需要在<code>emit()</code>函数中使用<code>forEach</code>或者<code>map</code>来确保我们能创建新的订阅器或者取消订阅。</li>
<li>当一个<code>EventEmitter</code>类被实例化之后，可以传递一个预定义的事件到事件接口。</li>
<li>可以不需要使用<code>class</code>，来实现，个人喜好，但是使用<code>class</code>使事件存储在哪里会更加清晰。 可以在一个函数中实现，如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">emitter</span>(<span class="hljs-params">e?: Events</span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">events</span>: <span class="hljs-title class_">Events</span> = e || &#123;&#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    events,<br>    <span class="hljs-attr">subscribe</span>: <span class="hljs-function">(<span class="hljs-params">name: string, cb: <span class="hljs-built_in">Function</span></span>) =&gt;</span> &#123;<br>      (events[name] || (events[name] = [])).<span class="hljs-title function_">push</span>(cb);<br><br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>          events[name] &amp;&amp; events[name].<span class="hljs-title function_">splice</span>(events[name].<span class="hljs-title function_">indexOf</span>(cb) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;;<br>    &#125;,<br>    <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">name: string, ...args: any[]</span>) =&gt;</span> &#123;<br>      (events[name] || []).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(...args));<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="29-js数组常用方法"><a href="#29-js数组常用方法" class="headerlink" title="29 js数组常用方法"></a>29 js数组常用方法</h2><h3 id="一、改变原数组的方法"><a href="#一、改变原数组的方法" class="headerlink" title="一、改变原数组的方法"></a>一、改变原数组的方法</h3><h4 id="1-push（）-末尾添加数据"><a href="#1-push（）-末尾添加数据" class="headerlink" title="1.push（） 末尾添加数据"></a><strong>1.push（） 末尾添加数据</strong></h4><p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong> 就是往数组末尾添加数据</p>
<p><strong>返回值:</strong>  就是这个数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //push">var arr = [10, 20, 30, 40]<br>res = arr.push(20)<br>console.log(arr);//[10,20,30,40,20]<br>console.log(res);//5<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-pop（）-末尾出删除数据"><a href="#2-pop（）-末尾出删除数据" class="headerlink" title="2. pop（） 末尾出删除数据"></a>2. pop（） 末尾出删除数据</h4><p><strong>语法:</strong> <strong>数组名.pop()</strong></p>
<p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p>
<p><strong>返回值:</strong> 就是你删除的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //pop">var arr = [10, 20, 30, 40] <br>res =arr.pop()<br>console.log(arr);//[10,20,30]<br>console.log(res);//40<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3-unshift（）-头部添加数据"><a href="#3-unshift（）-头部添加数据" class="headerlink" title="3.unshift（） 头部添加数据"></a>3.unshift（） 头部添加数据</h4><p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong>  就是在数组的头部添加数据</p>
<p><strong>返回值:</strong> 就是数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //pop"> var arr = [10, 20, 30, 40]<br> res=arr.unshift(99)<br> console.log(arr);//[99,10,20,30,40]<br> console.log(res);//5<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-shift（）-头部删除数据"><a href="#4-shift（）-头部删除数据" class="headerlink" title="4.shift（） 头部删除数据"></a>4.shift（） 头部删除数据</h4><p><strong>语法:</strong> <strong>数组名.shift()</strong></p>
<p><strong>作用:</strong>  头部删除一个数据</p>
<p><strong>返回值:</strong>  就是删除掉的那个数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //shift"> var arr = [10, 20, 30, 40]<br> res=arr.shift()<br> console.log(arr);[20,30,40]<br> console.log(res);10<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-reverse（）-翻转数组"><a href="#5-reverse（）-翻转数组" class="headerlink" title="5.reverse（） 翻转数组"></a>5.reverse（） 翻转数组</h4><p><strong>语法:</strong> <strong>数组名.reverse()</strong></p>
<p><strong>作用:</strong> 就是用来翻转数组的</p>
<p><strong>返回值:</strong> 就是翻转好的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure>

<h4 id="6-sort（）-排序"><a href="#6-sort（）-排序" class="headerlink" title="6.sort（） 排序"></a>6.sort（） 排序</h4><p>语法一: 数组名.sort()会排序 会按照位排序</p>
<p>语法二: 数组名.sort(function (a,b) {return a-b})  会正序排列</p>
<p>语法三: 数组名.sort(function (a,b) {return b-a})  会倒序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //sort()">var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]<br>arr.sort()<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(a-b)&#125;)<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(b-a)&#125;)<br>console.log(arr);<br></code></pre></td></tr></table></figure>

<h4 id="7-splice（）-截取数组"><a href="#7-splice（）-截取数组" class="headerlink" title="7.splice（）  截取数组"></a>7.splice（）  截取数组</h4><p>语法一: 数组名.splice(开始索引,多少个)</p>
<p>作用: 就是用来截取数组的</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<p>语法二: 数组名.splice(开始索引,多少个,你要插入的数据)</p>
<p>作用: 删除并插入数据</p>
<p>注意: 从你的开始索引起</p>
<p>返回值: 是一个新数组 里面就是你截取出来的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr);<br>console.log(res);<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr);<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h3 id="二、不改变原数组的方法"><a href="#二、不改变原数组的方法" class="headerlink" title="二、不改变原数组的方法"></a>二、不改变原数组的方法</h3><h4 id="1-concat（）合并数组"><a href="#1-concat（）合并数组" class="headerlink" title="1.concat（）合并数组"></a>1.concat（）合并数组</h4><p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p>
<p><strong>作用:</strong>  合并数组的</p>
<p><strong>返回值:</strong>  一个新的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //concat">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.concat(20,&quot;小敏&quot;,50)<br>console.log(arr) <br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-join（）-数组转字符串"><a href="#2-join（）-数组转字符串" class="headerlink" title="2.join（） 数组转字符串"></a>2.join（） 数组转字符串</h4><p><strong>语法:</strong> <strong>数组名.join(‘</strong> <strong>连接符’)</strong></p>
<p><strong>作用:</strong> 就是把一个数组转成字符串</p>
<p><strong>返回值:</strong>  就是转好的一个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //join">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.join(&quot;+&quot;)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<h4 id="3-slice（）截取数组的一部分数据"><a href="#3-slice（）截取数组的一部分数据" class="headerlink" title="3.slice（）截取数组的一部分数据"></a>3.slice（）截取数组的一部分数据</h4><p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p>
<p><strong>作用:</strong> 就是截取数组中的一部分数据</p>
<p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p>
<p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-indexOf-从左检查数组中有没有这个数值"><a href="#4-indexOf-从左检查数组中有没有这个数值" class="headerlink" title="4.indexOf 从左检查数组中有没有这个数值"></a>4.indexOf 从左检查数组中有没有这个数值</h4><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr)<br>console.log(res);<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-lastIndexOf-从右检查数组中有没有这个数值"><a href="#5-lastIndexOf-从右检查数组中有没有这个数值" class="headerlink" title="5.lastIndexOf 从右检查数组中有没有这个数值"></a>5.lastIndexOf 从右检查数组中有没有这个数值</h4><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p>
<p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p>
<p>如果有就返回该数据<strong>第一次</strong>出现的索引</p>
<p>如果没有返回 -1</p>
<p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="三、ES6新增的数组方法"><a href="#三、ES6新增的数组方法" class="headerlink" title="三、ES6新增的数组方法"></a>三、ES6新增的数组方法</h3><h4 id="1-forEach-用来循环遍历的-for"><a href="#1-forEach-用来循环遍历的-for" class="headerlink" title="1. forEach()  用来循环遍历的 for"></a>1. forEach()  用来循环遍历的 for</h4><p>语法: 数组名.forEach(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来循环遍历数组的 代替了我们的for</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2-map-映射数组的"><a href="#2-map-映射数组的" class="headerlink" title="2.map  映射数组的"></a>2.map  映射数组的</h4><p>语法: 数组名.map(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来映射</p>
<p>返回值: 必然是一个数组 一个映射完毕的数组；这个数组合原数组长度一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //map">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.map(function (item) &#123;<br>    return item*1000<br>&#125;)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="3-filter-过滤数组"><a href="#3-filter-过滤数组" class="headerlink" title="3.filter  过滤数组"></a>3.filter  过滤数组</h4><p>语法: 数组名.filter(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来过滤数组的</p>
<p>返回值: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(res);<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="4-every-判断数组是不是满足所有条件"><a href="#4-every-判断数组是不是满足所有条件" class="headerlink" title="4.every  判断数组是不是满足所有条件"></a>4.every  判断数组是不是满足所有条件</h4><p>语法: 数组名.every(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> 只有所有的都满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要有一个不满足返回的就是<span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值 注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //every">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="5-some（）-数组中有没有满足条件的"><a href="#5-some（）-数组中有没有满足条件的" class="headerlink" title="5.some（） 数组中有没有满足条件的"></a>5.some（） 数组中有没有满足条件的</h4><p>语法: 数组名.some(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> 只有有一个满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要都不满足返回的就是<span class="hljs-literal">false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>返回值: 是一个布尔值</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res);//true<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="6-find（）用来获取数组中满足条件的第一个数据"><a href="#6-find（）用来获取数组中满足条件的第一个数据" class="headerlink" title="6.find（）用来获取数组中满足条件的第一个数据"></a>6.find（）用来获取数组中满足条件的第一个数据</h4><p>语法: 数组名.find(function (item,index,arr) {})</p>
<ul>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 用来获取数组中满足条件的数据</p>
<p>返回值: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p>
<p>注意: 要以return的形式执行返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res)//4<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="7-reduce（）叠加后的效果"><a href="#7-reduce（）叠加后的效果" class="headerlink" title="7.reduce（）叠加后的效果"></a>7.reduce（）叠加后的效果</h4><p>语法: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p>
<ul>
<li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li>
<li>item : 这个表示的是数组中的每一项</li>
<li>index : 这个表示的是每一项对应的索引</li>
<li>arr : 这个表示的是原数组</li>
</ul>
<p>作用: 就是用来叠加的</p>
<p>返回值: 就是叠加后的结果</p>
<p>注意: 以return的形式书写返回条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //reduce">var arr = [1, 2, 3, 4, 5]<br>var res = arr.reduce(function (prev, item) &#123;<br>    return prev *= item<br>&#125;, 1)<br>console.log(res);//120<br><br></code></pre></td></tr></table></figure>



<h2 id="30-js-字符串常用方法"><a href="#30-js-字符串常用方法" class="headerlink" title="30 js 字符串常用方法"></a>30 js 字符串常用方法</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d56c8218f0154011855b78607c7bd3e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="JS字符串方法.png"></p>
<h3 id="1-获取字符串长度"><a href="#1-获取字符串长度" class="headerlink" title="1. 获取字符串长度"></a>1. 获取字符串长度</h3><p>JavaScript中的字符串有一个length属性，该属性可以用来获取字符串的长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-property">length</span>   <span class="hljs-comment">// 输出结果：5</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="2-获取字符串指定位置的值"><a href="#2-获取字符串指定位置的值" class="headerlink" title="2. 获取字符串指定位置的值"></a>2. 获取字符串指定位置的值</h3><p>charAt()和charCodeAt()方法都可以通过索引来获取指定位置的值：</p>
<ul>
<li>charAt() 方法获取到的是指定位置的字符；</li>
<li>charCodeAt()方法获取的是指定位置字符的Unicode值。</li>
</ul>
<h4 id="（1）charAt"><a href="#（1）charAt" class="headerlink" title="（1）charAt()"></a>（1）charAt()</h4><p>charAt() 方法可以返回指定位置的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">charAt</span>(index)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>index表示字符在字符串中的索引值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 输出结果：e </span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们知道，字符串也可以通过索引值来直接获取对应字符，那它和charAt()有什么区别呢？来看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 输出结果：e </span><br>str[<span class="hljs-number">1</span>]         <span class="hljs-comment">// 输出结果：e </span><br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出结果：&#x27;&#x27; </span><br>str[<span class="hljs-number">5</span>]         <span class="hljs-comment">// 输出结果：undefined</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>可以看到，当index的取值不在str的长度范围内时，str[index]会返回undefined，而charAt(index)会返回空字符串；除此之外，str[index]不兼容ie6-ie8，charAt(index)可以兼容。</p>
<h4 id="（2）charCodeAt"><a href="#（2）charCodeAt" class="headerlink" title="（2）charCodeAt()"></a>（2）charCodeAt()</h4><p><code>charCodeAt()</code>：该方法会返回指定索引位置字符的 Unicode 值，返回值是 0 - 65535 之间的整数，表示给定索引处的 UTF-16 代码单元，如果指定位置没有字符，将返回 <strong>NaN</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// &quot;b&quot; --&gt; 98</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过这个方法，可以获取字符串中指定Unicode编码值范围的字符。比如，数字0～9的Unicode编码范围是: 48～57，可以通过这个方法来筛选字符串中的数字，当然如果你更熟悉正则表达式，会更方便。</p>
<h3 id="3-检索字符串是否包含特定序列"><a href="#3-检索字符串是否包含特定序列" class="headerlink" title="3. 检索字符串是否包含特定序列"></a>3. 检索字符串是否包含特定序列</h3><p>这5个方法都可以用来检索一个字符串中是否包含特定的序列。其中前两个方法得到的指定元素的索引值，并且只会返回第一次匹配到的值的位置。后三个方法返回的是布尔值，表示是否匹配到指定的值。</p>
<p>注意：这5个方法都对大小写敏感！</p>
<h4 id="（1）indexOf"><a href="#（1）indexOf" class="headerlink" title="（1）indexOf()"></a>（1）indexOf()</h4><p><code>indexOf()</code>：查找某个字符，<strong>有则返回第一次匹配到的位置</strong>，否则返回-1，其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">indexOf</span>(searchvalue,fromindex)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，规定需检索的字符串值；</li>
<li>fromindex：可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 string.length - 1。如省略该，则从字符串的首字符开始检索。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefgabc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;a&quot;</span>));   <span class="hljs-comment">// 输出结果：0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;z&quot;</span>));   <span class="hljs-comment">// 输出结果：-1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// 输出结果：9</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）lastIndexOf"><a href="#（2）lastIndexOf" class="headerlink" title="（2）lastIndexOf()"></a>（2）lastIndexOf()</h4><p><code>lastIndexOf()</code>：查找某个字符，有则返回最后一次匹配到的位置，否则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcabc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;a&quot;</span>));  <span class="hljs-comment">// 输出结果：3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;z&quot;</span>));  <span class="hljs-comment">// 输出结果：-1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法和indexOf()类似，只是查找的顺序不一样，indexOf()是正序查找，lastIndexOf()是逆序查找。</p>
<h4 id="（3）includes"><a href="#（3）includes" class="headerlink" title="（3）includes()"></a>（3）includes()</h4><p><code>includes()</code>：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。该方法的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">includes</span>(searchvalue, start)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要查找的字符串；</li>
<li>start：可选，设置从那个位置开始查找，默认为 0。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;o&#x27;</span>)  <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;z&#x27;</span>)  <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 输出结果：false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（4）startsWith"><a href="#（4）startsWith" class="headerlink" title="（4）startsWith()"></a>（4）startsWith()</h4><p><code>startsWith()</code>：该方法用于检测字符串<strong>是否以指定的子字符串开始</strong>。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Helle&#x27;</span>) <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;wo&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 输出结果：true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（5）endsWith"><a href="#（5）endsWith" class="headerlink" title="（5）endsWith()"></a>（5）endsWith()</h4><p><code>endsWith()</code>：该方法用来判断当前字符串<strong>是否是以指定的子字符串结尾</strong>。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">endsWith</span>(searchvalue, length)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需，要搜索的子字符串；</li>
<li>length： 设置字符串的长度，默认值为原始字符串长度 string.length。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)       <span class="hljs-comment">// 输出结果：true</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;llo&#x27;</span>)     <span class="hljs-comment">// 输出结果：false</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;llo&#x27;</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出结果：true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>可以看到，当第二个参数设置为5时，就会从字符串的前5个字符中进行检索，所以会返回true。</p>
<h3 id="4-连接多个字符串"><a href="#4-连接多个字符串" class="headerlink" title="4. 连接多个字符串"></a>4. 连接多个字符串</h3><p>concat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">concat</span>(string1, string2, ..., stringX)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>其中参数 string1, string2, …, stringX 是必须的，他们将被连接为一个字符串的一个或多个字符串对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;efg&quot;</span>));          <span class="hljs-comment">//输出结果：&quot;abcefg&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;efg&quot;</span>,<span class="hljs-string">&quot;hijk&quot;</span>)); <span class="hljs-comment">//输出结果：&quot;abcefghijk&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>虽然concat()方法是专门用来拼接字符串的，但是在开发中使用最多的还是加操作符+，因为其更加简单。</p>
<h3 id="5-字符串分割成数组"><a href="#5-字符串分割成数组" class="headerlink" title="5. 字符串分割成数组"></a>5. 字符串分割成数组</h3><p>split() 方法用于把一个字符串分割成字符串数组。该方法不会改变原始字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">split</span>(separator,limit)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>separator：必需。字符串或正则表达式，从该参数指定的地方分割 string。</li>
<li>limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;c&quot;</span>);    <span class="hljs-comment">// 输出结果：[&quot;ab&quot;, &quot;def&quot;]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">4</span>)   <span class="hljs-comment">// 输出结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] </span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果把空字符串用作 separator，那么字符串中的每个字符之间都会被分割。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);     <span class="hljs-comment">// 输出结果：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>其实在将字符串分割成数组时，可以同时拆分多个分割符，使用正则表达式即可实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-string">&quot;apples,bananas;cherries&quot;</span><br><span class="hljs-keyword">const</span> fruits = list.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[,;]/</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits);  <span class="hljs-comment">// 输出结果：[&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="6-截取字符串"><a href="#6-截取字符串" class="headerlink" title="6. 截取字符串"></a>6. 截取字符串</h3><p>substr()、substring()和 slice() 方法都可以用来截取字符串。</p>
<h4 id="（1）-slice"><a href="#（1）-slice" class="headerlink" title="（1） slice()"></a>（1） slice()</h4><p>slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">slice</span>(start,end)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。</li>
<li>end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</li>
</ul>
<p>上面说了，如果start是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdef&quot; </span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);     <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; </span><br>str.<span class="hljs-title function_">slice</span>();      <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; </span><br>str.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">2</span>);    <span class="hljs-comment">// 输出结果：&quot;fg&quot;</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h4 id="（2）-substr"><a href="#（2）-substr" class="headerlink" title="（2） substr()"></a>（2） substr()</h4><p>substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">substr</span>(start,length)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>start	必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</li>
<li>length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; </span><br>str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; 相当于截取[1,str.length-1]</span><br>str.<span class="hljs-title function_">substr</span>();    <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; 相当于截取[0,str.length-1]</span><br>str.<span class="hljs-title function_">substr</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;g&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）-substring"><a href="#（3）-substring" class="headerlink" title="（3） substring()"></a>（3） substring()</h4><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">substring</span>(<span class="hljs-keyword">from</span>, to)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。</li>
<li>to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</li>
</ul>
<p><strong>注意：</strong> 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">// 输出结果：&quot;bcdef&quot; [1,6)</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 输出结果：&quot;bcdefg&quot; [1,str.length-1]</span><br>str.<span class="hljs-title function_">substring</span>();    <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot; [0,str.length-1]</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出结果 &quot;bcdef&quot; [1,6)</span><br>str.<span class="hljs-title function_">substring</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// 输出结果：&quot;abcdefg&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法返回的子串<strong>包括开始处的字符</strong>，但<strong>不包括结束处的字符</strong>。</p>
<h3 id="7-字符串大小写转换"><a href="#7-字符串大小写转换" class="headerlink" title="7. 字符串大小写转换"></a>7. 字符串大小写转换</h3><p>toLowerCase() 和 toUpperCase()方法可以用于字符串的大小写转换。</p>
<h4 id="（1）toLowerCase"><a href="#（1）toLowerCase" class="headerlink" title="（1）toLowerCase()"></a>（1）toLowerCase()</h4><p><code>toLowerCase()</code>：该方法用于把字符串转换为小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;adABDndj&quot;</span>;<br>str.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// 输出结果：&quot;adabdndj&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）toUpperCase"><a href="#（2）toUpperCase" class="headerlink" title="（2）toUpperCase()"></a>（2）toUpperCase()</h4><p><code>toUpperCase()</code>：该方法用于把字符串转换为大写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;adABDndj&quot;</span>;<br>str.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// 输出结果：&quot;ADABDNDJ&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>我们可以用这个方法来将字符串中第一个字母变成大写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> word = <span class="hljs-string">&#x27;apple&#x27;</span><br>word = word[<span class="hljs-number">0</span>].<span class="hljs-title function_">toUpperCase</span>() + word.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(word) <span class="hljs-comment">// 输出结果：&quot;Apple&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="8-字符串模式匹配"><a href="#8-字符串模式匹配" class="headerlink" title="8. 字符串模式匹配"></a>8. 字符串模式匹配</h3><p>replace()、match()和search()方法可以用来匹配或者替换字符。</p>
<h4 id="（1）replace"><a href="#（1）replace" class="headerlink" title="（1）replace()"></a>（1）replace()</h4><p><code>replace()</code>：该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">replace</span>(searchvalue, newvalue)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>searchvalue：必需。规定子字符串或要替换的模式的 RegExp 对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</li>
<li>newvalue：必需。一个字符串值。规定了替换文本或生成替换文本的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>) <span class="hljs-comment">// 输出结果：abzdef</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>执行一个全局替换, 忽略大小写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;Mr Blue has a blue house and a blue car&quot;</span>;<br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/blue/gi</span>, <span class="hljs-string">&quot;red&quot;</span>);    <span class="hljs-comment">// 输出结果：&#x27;Mr red has a red house and a red car&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p>
<h4 id="（2）match"><a href="#（2）match" class="headerlink" title="（2）match()"></a>（2）match()</h4><p><code>match()</code>：该方法用于在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">match</span>(regexp)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法的参数 regexp 是必需的，规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。</p>
<p><strong>注意：</strong> 该方法返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-string">&quot;c&quot;</span>)) <span class="hljs-comment">// [&quot;c&quot;, index: 2, input: &quot;abcdef&quot;, groups: undefined]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）search"><a href="#（3）search" class="headerlink" title="（3）search()"></a>（3）search()</h4><p><code>search()</code>方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">search</span>(searchvalue)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法的参数 regex 可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。</p>
<p><strong>注意：</strong> 要执行忽略大小写的检索，请追加标志 i。该方法不执行全局匹配，它将忽略标志 g，也就是只会返回第一次匹配成功的结果。如果没有找到任何匹配的子串，则返回 -1。</p>
<p><strong>返回值：</strong> 返回 str 中第一个与 regexp 相匹配的子串的起始位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/bcd/</span>)   <span class="hljs-comment">// 输出结果：1</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="9-移除字符串收尾空白符"><a href="#9-移除字符串收尾空白符" class="headerlink" title="9. 移除字符串收尾空白符"></a>9. 移除字符串收尾空白符</h3><p>trim()、trimStart()和trimEnd()这三个方法可以用于移除字符串首尾的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。</p>
<h4 id="（1）trim"><a href="#（1）trim" class="headerlink" title="（1）trim()"></a>（1）trim()</h4><p>trim() 方法用于移除字符串首尾空白符，该方法不会改变原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;  abcdef  &quot;</span><br>str.<span class="hljs-title function_">trim</span>()    <span class="hljs-comment">// 输出结果：&quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>注意，该方法不适用于null、undefined、Number类型。</p>
<h4 id="（2）trimStart"><a href="#（2）trimStart" class="headerlink" title="（2）trimStart()"></a>（2）trimStart()</h4><p>trimStart() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的开头删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br><br>s.<span class="hljs-title function_">trimStart</span>()   <span class="hljs-comment">// &quot;abc  &quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（3）trimEnd"><a href="#（3）trimEnd" class="headerlink" title="（3）trimEnd()"></a>（3）trimEnd()</h4><p>trimEnd() 方法的的行为与<code>trim()</code>一致，不过会返回一个<strong>从原始字符串的结尾删除了空白的新字符串</strong>，不会修改原始字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br><br>s.<span class="hljs-title function_">trimEnd</span>()   <span class="hljs-comment">// &quot;  abc&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="10-获取字符串本身"><a href="#10-获取字符串本身" class="headerlink" title="10. 获取字符串本身"></a>10. 获取字符串本身</h3><p>valueOf()和toString()方法都会返回字符串本身的值，感觉用处不大。</p>
<h4 id="（1）valueOf"><a href="#（1）valueOf" class="headerlink" title="（1）valueOf()"></a>（1）valueOf()</h4><p><code>valueOf()</code>：返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">valueOf</span>()) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）toString"><a href="#（2）toString" class="headerlink" title="（2）toString()"></a>（2）toString()</h4><p><code>toString()</code>：返回字符串对象本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="11-重复一个字符串"><a href="#11-重复一个字符串" class="headerlink" title="11. 重复一个字符串"></a>11. 重复一个字符串</h3><p>repeat() 方法返回一个新字符串，表示将原字符串重复n次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)     <span class="hljs-comment">// 输出结果：&quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 输出结果：&quot;hellohello&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">0</span>)    <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是小数，会向下取整：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2.9</span>) <span class="hljs-comment">// 输出结果：&quot;nana&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是负数或者Infinity，会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-title class_">Infinity</span>)   <span class="hljs-comment">// RangeError</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(-<span class="hljs-number">1</span>)         <span class="hljs-comment">// RangeError</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(-<span class="hljs-number">0.9</span>)   <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数是NaN，就等同于 0：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-title class_">NaN</span>)    <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果repeat的参数是字符串，则会先转换成数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-string">&#x27;na&#x27;</span>)   <span class="hljs-comment">// 输出结果：&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-string">&#x27;3&#x27;</span>)    <span class="hljs-comment">// 输出结果：&quot;nanana&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="12-补齐字符串长度"><a href="#12-补齐字符串长度" class="headerlink" title="12. 补齐字符串长度"></a>12. 补齐字符串长度</h3><p>padStart()和padEnd()方法用于补齐字符串的长度。如果某个字符串不够指定长度，会在头部或尾部补全。</p>
<h4 id="（1）padStart"><a href="#（1）padStart" class="headerlink" title="（1）padStart()"></a>（1）padStart()</h4><p><code>padStart()</code>用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 </p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;x&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;ababx&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;abax&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果省略第二个参数，默认使用空格补全长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// &#x27;   x&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>padStart()的常见用途是为数值补全指定位数，笔者最近做的一个需求就是将返回的页数补齐为三位，比如第1页就显示为001，就可以使用该方法来操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;1&quot;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)   <span class="hljs-comment">// 输出结果： &#x27;001&#x27;</span><br><span class="hljs-string">&quot;15&quot;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)  <span class="hljs-comment">// 输出结果： &#x27;015&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）padEnd"><a href="#（2）padEnd" class="headerlink" title="（2）padEnd()"></a>（2）padEnd()</h4><p><code>padEnd()</code>用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xabab&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;xaba&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="13-字符串转为数字"><a href="#13-字符串转为数字" class="headerlink" title="13. 字符串转为数字"></a>13. 字符串转为数字</h3><p>parseInt()和parseFloat()方法都用于将字符串转为数字。</p>
<h4 id="（1）parseInt"><a href="#（1）parseInt" class="headerlink" title="（1）parseInt()"></a>（1）parseInt()</h4><p>parseInt() 方法用于可解析一个字符串，并返回一个整数。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(string, radix)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>该方法有两个参数：</p>
<ul>
<li>string：必需。要被解析的字符串。</li>
<li>radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</li>
</ul>
<p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>);			  <span class="hljs-comment">// 输出结果：10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;17&quot;</span>,<span class="hljs-number">8</span>);		  <span class="hljs-comment">// 输出结果：15 (8+7)</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;010&quot;</span>);		  <span class="hljs-comment">// 输出结果：10 或 8</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>当参数 radix 的值以 “0x” 或 “0X” 开头，将以 16 为基数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0x10&quot;</span>)      <span class="hljs-comment">// 输出结果：16</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;50&quot;</span>, <span class="hljs-number">1</span>)      <span class="hljs-comment">// 输出结果：NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;50&quot;</span>, <span class="hljs-number">40</span>)     <span class="hljs-comment">// 输出结果：NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>只有字符串中的第一个数字会被返回，当遇到第一个不是数字的字符为止:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;40 4years&quot;</span>)   <span class="hljs-comment">// 输出结果：40</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果字符串的第一个字符不能被转换为数字，就会返回 NaN：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;new100&quot;</span>)     <span class="hljs-comment">// 输出结果：NaN</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>字符串开头和结尾的空格是允许的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;  60  &quot;</span>)    <span class="hljs-comment">// 输出结果： 60</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="（2）parseFloat"><a href="#（2）parseFloat" class="headerlink" title="（2）parseFloat()"></a>（2）parseFloat()</h4><p>parseFloat() 方法可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(string)<br>复制代码<br></code></pre></td></tr></table></figure>

<p>parseFloat 将它的字符串参数解析成为浮点数并返回。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.00&quot;</span>)      <span class="hljs-comment">// 输出结果：10.00</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.01&quot;</span>)      <span class="hljs-comment">// 输出结果：10.01</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;-10.01&quot;</span>)     <span class="hljs-comment">// 输出结果：-10.01</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;40.5 years&quot;</span>) <span class="hljs-comment">// 输出结果：40.5</span><br><br>复制代码<br></code></pre></td></tr></table></figure>

<p>如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;new40.5&quot;</span>)    <span class="hljs-comment">// 输出结果：NaN</span><br></code></pre></td></tr></table></figure>

<h2 id="30-写一个深度拷贝"><a href="#30-写一个深度拷贝" class="headerlink" title="30 写一个深度拷贝"></a>30 写一个深度拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//判断一个对象的具体类型</span><br><span class="hljs-keyword">const</span> mapType = <span class="hljs-string">&#x27;[object Map]&#x27;</span>;<br><span class="hljs-keyword">const</span> setType = <span class="hljs-string">&#x27;[object Set]&#x27;</span>;<br><span class="hljs-keyword">const</span> arrayType = <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br><span class="hljs-keyword">const</span> objectType = <span class="hljs-string">&#x27;[object Object]&#x27;</span>;<br><span class="hljs-keyword">const</span> deepmap = [mapType, setType, arrayType, objectType]<br><br><span class="hljs-keyword">const</span> boolType = <span class="hljs-string">&#x27;[object Boolean]&#x27;</span>;<br><span class="hljs-keyword">const</span> dateType = <span class="hljs-string">&#x27;[object Date]&#x27;</span>;<br><span class="hljs-keyword">const</span> numberType = <span class="hljs-string">&#x27;[object Number]&#x27;</span>;<br><span class="hljs-keyword">const</span> stringType = <span class="hljs-string">&#x27;[object String]&#x27;</span>;<br><span class="hljs-keyword">const</span> symbolType = <span class="hljs-string">&#x27;[object Symbol]&#x27;</span>;<br><span class="hljs-keyword">const</span> errorType = <span class="hljs-string">&#x27;[object Error]&#x27;</span>;<br><span class="hljs-keyword">const</span> regexpType = <span class="hljs-string">&#x27;[object RegExp]&#x27;</span>;<br><span class="hljs-keyword">const</span> funcType = <span class="hljs-string">&#x27;[object Function]&#x27;</span>;<br><br><span class="hljs-comment">//先考虑是否是对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> target;<br>    <span class="hljs-keyword">return</span> target != <span class="hljs-literal">null</span> &amp;&amp; (type === <span class="hljs-string">&#x27;object&#x27;</span> || type === <span class="hljs-string">&#x27;function&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">call</span>(target)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getInit</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> target.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneSymbol</span>(<span class="hljs-params">targe</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span>.<span class="hljs-title function_">call</span>(targe));<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneRegExp</span>(<span class="hljs-params">regexp</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(regexp.<span class="hljs-property">source</span>, reFlags.<span class="hljs-title function_">exec</span>(regexp))<br>    result.<span class="hljs-property">lastIndex</span> = regexp.<span class="hljs-property">lastIndex</span><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneOtherType</span>(<span class="hljs-params">targe, type</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ctor</span> = targe.<span class="hljs-property">constructor</span>;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">boolType</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">numberType</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">stringType</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">errorType</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">dateType</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(targe);<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">regexpType</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneRegExp</span>(targe);<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">symbolType</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneSymbol</span>(targe);<br>        <span class="hljs-keyword">case</span> <span class="hljs-attr">funcType</span>:<br>            <span class="hljs-keyword">return</span> target;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clonedeep</span>(<span class="hljs-params">target, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>    <span class="hljs-comment">//处理基本数据类型</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br>    <span class="hljs-comment">//处理引用类型</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(target)) &#123;<br>            <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(target)<br>        &#125;<br>        map.<span class="hljs-title function_">set</span>(target, result)<br>        <span class="hljs-keyword">let</span> result<br>        <span class="hljs-keyword">const</span> type = <span class="hljs-title function_">getType</span>(target)<br>        <span class="hljs-comment">//处理可继续遍历对象</span><br>        <span class="hljs-keyword">if</span> (deepmap.<span class="hljs-title function_">includes</span>(type)) &#123;<br>            result = <span class="hljs-title function_">getInit</span>(target)<br>            <span class="hljs-comment">// 处理 Set</span><br>            <span class="hljs-keyword">if</span> (type === setType) &#123;<br>                target.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                    result.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepclone</span>(value, map));<br>                &#125;);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-comment">// 处理 Map</span><br>            <span class="hljs-keyword">if</span> (type === mapType) &#123;<br>                target.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>                    result.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">deepclone</span>(value, map));<br>                &#125;);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-comment">//处理对象或者数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;<br>                result[key] = <span class="hljs-title function_">clonedeep</span>(target[key], map);<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">cloneOtherType</span>(targe, type)<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h2 id="31-js的继承"><a href="#31-js的继承" class="headerlink" title="31 js的继承"></a>31 js的继承</h2><h4 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h4><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<p>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>(); <br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>()); <span class="hljs-comment">// true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-title function_">alert</span>(instance1.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(); <br><span class="hljs-title function_">alert</span>(instance2.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="2、借用构造函数继承"><a href="#2、借用构造函数继承" class="headerlink" title="2、借用构造函数继承"></a>2、借用构造函数继承</h4><p>使用父类的构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类（不使用原型）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>=[<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>];<br>&#125;<br><span class="hljs-keyword">function</span>  <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//继承自SuperType</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br>instance1.<span class="hljs-property">color</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-title function_">alert</span>(instance1.<span class="hljs-property">color</span>);<span class="hljs-comment">//&quot;red,green,blue,black&quot;</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-title function_">alert</span>(instance2.<span class="hljs-property">color</span>);<span class="hljs-comment">//&quot;red,green,blue&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将SuperType中的属性复制一份。</p>
<p>缺点：</p>
<ul>
<li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性&#x2F;方法</li>
<li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<h4 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h4><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-comment">// 继承属性</span><br>  <span class="hljs-comment">// 第二次调用SuperType()</span><br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-comment">// 构建原型链</span><br><span class="hljs-comment">// 第一次调用SuperType()</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>(); <br><span class="hljs-comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">SubType</span>; <br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-title function_">alert</span>(instance1.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br>instance1.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">//&quot;Nicholas&quot;;</span><br>instance1.<span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">//29</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-title function_">alert</span>(instance2.<span class="hljs-property">colors</span>); <span class="hljs-comment">//&quot;red,blue,green&quot;</span><br>instance2.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">//&quot;Greg&quot;;</span><br>instance2.<span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">//27</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c010c537ff8~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>缺点：</p>
<ul>
<li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性name，color。</li>
<li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性name，color。</li>
</ul>
<p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性&#x2F;方法。</p>
<h4 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h4><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">obj</span>)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>object()对传入其中的对象执行了一次<code>浅复制</code>，将构造函数F的原型直接指向传入的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-keyword">var</span> anotherPerson = <span class="hljs-title function_">object</span>(person);<br>anotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br>anotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Rob&quot;</span>);<br><br><span class="hljs-keyword">var</span> yetAnotherPerson = <span class="hljs-title function_">object</span>(person);<br>yetAnotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Linda&quot;</span>;<br>yetAnotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Barbie&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(person.<span class="hljs-property">friends</span>);   <span class="hljs-comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<p>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。</p>
<h4 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h4><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">original</span>)&#123;<br>  <span class="hljs-keyword">var</span> clone = <span class="hljs-title function_">object</span>(original); <span class="hljs-comment">// 通过调用 object() 函数创建一个新对象</span><br>  clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-comment">// 以某种方式来增强对象</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> clone; <span class="hljs-comment">// 返回这个对象</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> anotherPerson = <span class="hljs-title function_">createAnother</span>(person);<br>anotherPerson.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">//&quot;hi&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>缺点（同原型式继承）：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<h4 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h4><p>结合借用构造函数传递参数和寄生模式实现继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>)&#123;<br>  <span class="hljs-keyword">var</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span><br>  prototype.<span class="hljs-property">constructor</span> = subType;                    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br>  subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;                      <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span><br>&#125;<br><br><span class="hljs-comment">// 父类初始化实例属性和原型属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 将父类原型指向子类</span><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>, <span class="hljs-title class_">SuperType</span>);<br><br><span class="hljs-comment">// 新增子类原型属性</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;xyc&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;lxy&quot;</span>, <span class="hljs-number">23</span>);<br><br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span><br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p>
<p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p>
<h4 id="7、混入方式继承多个对象"><a href="#7、混入方式继承多个对象" class="headerlink" title="7、混入方式继承多个对象"></a>7、混入方式继承多个对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyClass</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title class_">SuperClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>     <span class="hljs-title class_">OtherSuperClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继承一个类</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">SuperClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 混合其它</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">OtherSuperClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 重新指定constructor</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">MyClass</span>;<br><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">// do something</span><br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>Object.assign</code>会把  <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>
<h4 id="8、ES6类继承extends"><a href="#8、ES6类继承extends" class="headerlink" title="8、ES6类继承extends"></a>8、ES6类继承extends</h4><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-comment">// constructor</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">height, width</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Getter</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">area</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calcArea</span>()<br>    &#125;<br>    <br>    <span class="hljs-comment">// Method</span><br>    <span class="hljs-title function_">calcArea</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> rectangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rectangle.<span class="hljs-property">area</span>);<br><span class="hljs-comment">// 输出 200</span><br><br>-----------------------------------------------------------------<br><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Rectangle</span> &#123;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(length, length);<br>    <br>    <span class="hljs-comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Square&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">area</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> square = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>(<span class="hljs-number">10</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(square.<span class="hljs-property">area</span>);<br><span class="hljs-comment">// 输出 100</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_inherits</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>  <br>    <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span><br>    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br>    <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span><br>    subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType &amp;&amp; superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>        <span class="hljs-attr">constructor</span>: &#123;<br>            <span class="hljs-attr">value</span>: subType,<br>            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">if</span> (superType) &#123;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-property">setPrototypeOf</span> <br>            ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(subType, superType) <br>            : subType.<span class="hljs-property">__proto__</span> = superType;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、函数声明和类声明的区别</p>
<p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(); <br><span class="hljs-comment">// ReferenceError</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>2、ES5继承和ES6继承的区别</p>
<ul>
<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li>
<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>
</ul>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000011917606">《javascript高级程序设计》笔记：继承</a><br><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN之Object.create()</a><br>[MDN之Class](</p>
</blockquote>
<h1 id="that’s-it"><a href="#that’s-it" class="headerlink" title="that’s it"></a>that’s it</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端基础知识合集（3）- 常识篇</div>
      <div>https://yoonalis.github.io/blog/2022/11/20/前端基础知识合集（3）- 常识篇/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Azure</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2022/11/20/css/" title="css">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">css</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2022/11/09/git/" title="git常用操作">
                        <span class="hidden-mobile">git常用操作</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
