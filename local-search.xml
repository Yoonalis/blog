<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文选题</title>
    <link href="/blog/2022/12/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2022/12/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="论文选题"><a href="#论文选题" class="headerlink" title="论文选题"></a>论文选题</h1><p>pick one</p><h2 id="深度学习相关"><a href="#深度学习相关" class="headerlink" title="深度学习相关"></a>深度学习相关</h2><h3 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h3><p>tensorflow</p><p>pytorch</p><h3 id="2-必备知识点"><a href="#2-必备知识点" class="headerlink" title="2. 必备知识点"></a>2. 必备知识点</h3><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><h5 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h5><p>一个常见的结构：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_06-34-17-20221204%2021:56:32.png" alt="Snipaste_2022-12-04_06-34-17"></p><p>输入层:比如一张图像</p><p>从输入层到隐藏层:H&#x3D;X*W1+b1</p><p>隐藏层到输出层:Y&#x3D;H*W2+b2</p><p>通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是如果你还对线性代数的计算有印象的话，应该会知道：一系列线性方程的运算最终都可以用一个线性方程表示。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话神经网络就失去了意义。</p><p>所以这里要对网络注入灵魂：<strong>激活层</strong>。</p><p>简而言之，激活层是为矩阵运算的结果添加非线性的。常用的激活函数有三种，分别是阶跃函数、Sigmoid和ReLU。不要被奇怪的函数名吓到，其实它们的形式都很简单，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_06-39-19-20221204%2021:56:48.png" alt="Snipaste_2022-12-04_06-39-19"></p><p>阶跃函数：当输入小于等于0时，输出0；当输入大于0时，输出1。</p><p>Sigmoid：当输入趋近于正无穷&#x2F;负无穷时，输出无限接近于1&#x2F;0。</p><p>ReLU：当输入小于0时，输出0；当输入大于0时，输出等于输入。</p><p>其中，阶跃函数输出值是跳变的，且只有二值，较少使用；Sigmoid函数在当x的绝对值较大时，曲线的斜率变化很小（梯度消失），并且计算较复杂；ReLU是当前较为常用的激活函数。</p><p>需要注意的是，每个隐藏层计算（矩阵线性运算）之后，都需要加一层激活层，要不然该层线性计算是没有意义的。</p><p>softmax:对输出结果正规化处理,简单来说分三步进行：（1）以e为底对所有元素求指数幂；（2）将所有指数幂求和；（3）分别将这些指数幂与该和做商。</p><p>交叉熵损失（Cross Entropy Error）：一种直观的解决方法，是用1减去Softmax输出的概率，不过更为常用且巧妙的方法是，求<strong>对数的负数</strong>。</p><p>还是用90%举例，对数的负数就是：-log0.9&#x3D;0.046</p><p><strong>我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。</strong></p><p>一句话复习一下：<strong>神经网络的传播都是形如Y&#x3D;WX+b的矩阵运算；为了给矩阵运算加入非线性，需要在隐藏层中加入激活层；输出层结果需要经过Softmax层处理为概率值，并通过交叉熵损失来量化当前网络的优劣。</strong></p><h5 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h5><p>反向传播就是一个<strong>参数优化</strong>的过程，优化对象就是网络中的所有W和b（因为其他所有参数都是确定的）。</p><p>神经网络的神奇之处，就在于它可以自动做W和b的优化，在深度学习中，参数的数量有时会上亿，不过其优化的原理和我们这个两层神经网络是一样的。</p><p>常用方法：</p><p>梯度下降法</p><p>迭代法</p><p> 反向传播算法（Backpropagation）是目前用来训练人工神经网络（Artificial Neural Network，ANN）的最常用且最有效的算法。其主要思想是：<br>（1）将训练集数据输入到ANN的输入层，经过隐藏层，最后达到输出层并输出结果，这是ANN的前向传播过程；<br>（2）由于ANN的输出结果与实际结果有误差，则计算估计值与实际值之间的误差，并将该误差从输出层向隐藏层反向传播，直至传播到输入层；<br>（3）在反向传播的过程中，根据误差调整各种参数的值；不断迭代上述过程，直至收敛。</p><h4 id="cnn：卷积神经网络"><a href="#cnn：卷积神经网络" class="headerlink" title="cnn：卷积神经网络"></a>cnn：卷积神经网络</h4><p>如果用全连接神经网络处理大尺寸图像具有三个明显的缺点：</p><p>（1）首先将图像展开为向量会丢失空间信息；</p><p>（2）其次参数过多效率低下，训练困难；</p><p>（3）同时大量的参数也很快会导致网络过拟合。</p><p>而使用卷积神经网络可以很好地解决上面的三个问题。</p><p>卷积神经网络的各层中的神经元是3维排列的：宽度、高度和深度。其中的宽度和高度是很好理解的，因为本身卷积就是一个二维模板，但是在卷积神经网络中的深度指的是<strong>激活数据体</strong>的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数。举个例子来理解什么是宽度，高度和深度，假如使用CIFAR-10中的图像是作为卷积神经网络的输入，该<strong>输入数据体</strong>的维度是32x32x3（宽度，高度和深度）。<strong>我们将看到，层中的神经元将只与前一层中的一小块区域连接，而不是采取全连接方式。</strong>对于用来分类CIFAR-10中的图像的卷积网络，其最后的输出层的维度是1x1x10，因为在卷积神经网络结构的最后部分将会把全尺寸的图像压缩为包含分类评分的一个向量，<strong>向量是在深度方向排列的</strong>。下面是全连接神经网络与卷积神经网络的对比：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_07-04-52-20221204%2021:57:09.png" alt="Snipaste_2022-12-04_07-04-52"></p><p>典型的 CNN 由3个部分构成：</p><ol><li>卷积层</li><li>池化层</li><li>全连接层</li></ol><p>卷积层负责提取图像中的局部特征；池化层用来大幅降低参数量级(降维)；全连接层类似传统神经网络的部分，用来输出想要的结果。</p><p>卷积层的运算过程如下图，用一个卷积核扫完整张图片：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/f144f-2019-06-19-juanji-20221204%2021:58:52.gif" alt="f144f-2019-06-19-juanji"></p><p>在具体应用中，往往有多个卷积核，可以认为，每个卷积核代表了一种图像模式，如果某个图像块与此卷积核卷积出的值大，则认为此图像块十分接近于此卷积核。如果我们设计了6个卷积核，可以理解：我们认为这个图像上有6种底层纹理模式，也就是我们用6中基础模式就能描绘出一副图像。</p><p>池化层简单说就是下采样，他可以大大降低数据的维度。其过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/3fd53-2019-06-19-chihua-20221204%2021:59:11.gif" alt="3fd53-2019-06-19-chihua"></p><p>上图中，我们可以看到，原始图片是20×20的，我们对其进行下采样，采样窗口为10×10，最终将其下采样成为一个2×2大小的特征图。</p><p>之所以这么做的原因，是因为即使做完了卷积，图像仍然很大（因为卷积核比较小），所以为了降低数据维度，就进行下采样。</p><p>总结：池化层相比卷积层可以更有效的降低数据维度，这么做不但可以大大减少运算量，还可以有效的避免过拟合。</p><p>经过卷积层和池化层处理过的数据输入到全连接层，得到最终想要的结果。</p><p>经过卷积层和池化层降维过的数据，全连接层才能”跑得动”，不然数据量太大，计算成本高，效率低下。</p><p>典型的 CNN 并非只是上面提到的3层结构，而是多层结构，例如 LeNet-5 的结构就是卷积层 – 池化层- 卷积层 – 池化层 – 卷积层 – 全连接层</p><h4 id="gnn：图神经网络"><a href="#gnn：图神经网络" class="headerlink" title="gnn：图神经网络"></a>gnn：图神经网络</h4><p>图(graph)是一种数据结构，图神经网络(Graph Neural Network)应该是深度学习在图结构数据上的一些模型、方法和应用。常见的图结构由节点(node)和边(edge)构成，节点包含了实体(entity)信息，边包含实体间的关系(relation)信息。现在许多学习任务都需要**处理图结构的数据，比如物理系统建模(physics system)、学习分子指纹(molecular fingerprints)、蛋白质接口预测(protein interface)以及疾病分类(classify diseases)**，这些都需要模型能够从图结构的输入中学习相关的知识。</p><p>首先，标准的神经网络比如CNN和RNN不能够适当地处理图结构输入，因为它们都需要节点的特征按照一定的顺序进行排列，但是，<strong>对于图结构而言，并没有天然的顺序而言</strong>，如果使用顺序来完整地表达图的话，那么就需要将图分解成所有可能的序列，然后对序列进行建模，显然，这种方式非常的冗余以及计算量非常大，与此相反，<strong>GNN采用在每个节点上分别传播(propagate)的方式进行学习</strong>，由此忽略了节点的顺序，相当于GNN的输出会随着输入的不同而不同。</p><p>另外，<strong>图结构的边表示节点之间的依存关系</strong>，然而，传统的神经网络中，依存关系是通过节点特征表达出来的，也就是说，传统的神经网络不是显式地表达中这种依存关系，而是通过不同节点特征来间接地表达节点之间的关系。通常来说，<strong>GNN通过邻居节点的加权求和来更新节点的隐藏状态</strong>。</p><p>最后，就是<strong>对于高级的人工智能来说，推理是一个非常重要的研究主题</strong>，人类大脑的推理过程基本上都是基于图的方式，这个图是从日常的生活经历中学习得到的。GNN尝试从非结构化数据比如情景图片和故事文本中产生结构化的图，并通过这些图来生成更高级的AI系统。</p><p><strong>论文对GNN的模型分类如下：</strong></p><ul><li>图卷积网络(Graph convolutional networks)和图注意力网络(graph attention networks)，因为涉及到传播步骤(propagation step)。</li><li>图的空域网络(spatial-temporal networks)，因为该模型通常用在动态图(dynamic graph)上。</li><li>图的自编码(auto-encoder)，因为该模型通常使用无监督学习(unsupervised)的方式。</li><li>图生成网络(generative networks)，因为是生成式网络。</li></ul><blockquote><p>更多资料可参考 [这里][<a href="https://zhuanlan.zhihu.com/p/76025331]">https://zhuanlan.zhihu.com/p/76025331]</a></p></blockquote><h4 id="rnn：递归神经网络"><a href="#rnn：递归神经网络" class="headerlink" title="rnn：递归神经网络"></a>rnn：递归神经网络</h4><p>适合序列数据 – 一串相互依赖的数据流的场景</p><p>典型的集中序列数据：</p><ol><li>文章里的文字内容</li><li>语音里的音频内容</li><li>股票市场中的价格走势</li><li>……</li></ol><p>RNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/f0116-2019-07-02-rnn-1-20221204%2021:59:34.gif" alt="f0116-2019-07-02-rnn-1"></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_07-54-59-20221204%2021:59:44.png" alt="Snipaste_2022-12-04_07-54-59"></p><p>&#x3D;&#x3D;应用场景：文本生成　机器翻译　语音识别　生成图像描述　视频标记&#x3D;&#x3D;</p><h4 id="lstm：长短期记忆递归神经网络"><a href="#lstm：长短期记忆递归神经网络" class="headerlink" title="lstm：长短期记忆递归神经网络"></a>lstm：长短期记忆递归神经网络</h4><p>RNN 是一种死板的逻辑，越晚的输入影响越大，越早的输入影响越小，且无法改变这个逻辑。</p><p>LSTM从被设计之初就被用于解决一般递归神经网络中普遍存在的<strong>长期依赖问题</strong>，使用LSTM可以有效的传递和表达长时间序列中的信息并且不会导致长时间前的有用信息被忽略（遗忘）。与此同时，LSTM还可以解决RNN中的梯度消失&#x2F;爆炸问题。</p><p>Gated Recurrent Unit – GRU 是 LSTM 的一个变体。他保留了 LSTM 划重点，遗忘不重要信息的特点，在long-term 传播的时候也不会被丢失。</p><p>GRU 主要是在 LSTM 的模型上做了一些简化和调整，在训练数据集比较大的情况下可以节省很多时间。</p><p>详细实现可参考 <a href="https://zhuanlan.zhihu.com/p/123857569">这里</a></p><h4 id="分类-回归-聚类-降维-有监督-无监督"><a href="#分类-回归-聚类-降维-有监督-无监督" class="headerlink" title="分类\回归\聚类\降维\有监督\无监督"></a>分类\回归\聚类\降维\有监督\无监督</h4><p>1，给定一个样本特征 , 我们希望预测其对应的属性值 , 如果是离散的, 那么这就是一个分类问题，反之，如果 是连续的实数, 这就是一个回归问题。<br>2，如果给定一组样本特征 , 我们没有对应的属性值 , 而是想发掘这组样本在二维空间的分布, 比如分析哪些样本靠的更近，哪些样本之间离得很远, 这就是属于聚类问题。<br>3，如果我们想用维数更低的子空间来表示原来高维的特征空间, 那么这就是降维问题。</p><h4 id="元学习"><a href="#元学习" class="headerlink" title="元学习"></a>元学习</h4><p>通常在机器学习里，我们会使用某个场景的大量数据来训练模型；然而当场景发生改变，模型就需要重新训练。但是对于人类而言，一个小朋友成长过程中会见过许多物体的照片，某一天，当Ta（第一次）仅仅看了几张狗的照片，就可以很好地对狗和其他物体进行区分。</p><p>元学习Meta Learning，含义为学会学习，即learn to learn，就是带着这种对人类这种“学习能力”的期望诞生的。Meta Learning希望使得模型获取一种“学会学习”的能力，使其可以在获取已有“知识”的基础上快速学习新的任务。</p><p>需要注意的是，虽然同样有“预训练”的意思在里面，但是元学习的内核区别于迁移学习（Transfer Learning）。</p><p>详细研究可参考 [李宏毅视频][<a href="https://www.youtube.com/@HungyiLeeNTU/search?query=meta%5D">https://www.youtube.com/@HungyiLeeNTU/search?query=meta]</a></p><h4 id="restnet"><a href="#restnet" class="headerlink" title="restnet"></a>restnet</h4><p>卷积神经网络在图像分类领域具有非常广泛的应用，从理论上讲，越深的网络结构，其拟合能力应该越强，如16层的VGG16的拟合能力要强于5层的LeNet。然而，何恺明等人通过实验发现，当网络的深度达到一定程度时，网络的性能不升反降，并且这种性能的下降不是由过拟合引起的，因为深度网络的训练误差和测试误差都比浅层网络高，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-24-48-20221204%2021:59:56.png" alt="Snipaste_2022-12-04_08-24-48"></p><p>为改善上述问题，何恺明等人提出了深度残差学习框架。</p><p>常规的神经网络，是将卷积层、全连接层等结构按照一定的顺序简单地连接到一起，每层结构仅接受来自上一层的信息，并在本层处理后传递给下一层。当网络层次加深后，这种单一的连接方式会导致神经网络性能退化。所谓的残差学习，就是在上述的单一连接方式的基础上，加入了“<strong>短连接</strong>”（shortcut connections），如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-25-42-20221204%2022:00:04.png" alt="Snipaste_2022-12-04_08-25-42"></p><p>短连接能跨越几个层，将输入x直接映射到输出端（类似于电路中的短路），与输出相加。这样做导致的直接结果就是，在神经网络中加入上述的结构不再会导致神经网络的退化，考虑最坏的情况也不过是F(x)为0，这相当于网络没有加深，与之前一致。但是如果加入的层有效，就能使网络的性能得到提升。从数学的角度来看，上述结构的输入为x，输出H(x)为：</p><p>H(x)&#x3D;F(x)+xH(x)&#x3D;F(x)+x</p><p>其中F(x)称为残差函数，变换上式可得：</p><p>F(x)&#x3D;H(x)−xF(x)&#x3D;H(x)−x</p><p>显然，该结构中加入的短连接是没有参数的，因此学习H(x)的参数与学习F(x)的参数本质上是一样的，但是将函数优化为0或者在0附近显然更容易。因此，残差学习，学习的就是残差函数F(x)的参数。</p><p>论文原文中给出了两种ResNet的基本单元结构，其中左边的单元用于较浅的网络，如ResNet18、ResNet34，右边的单元则用于较深的网络，如ResNet50、ResNet101等。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-32-49-20221204%2022:00:13.png" alt="Snipaste_2022-12-04_08-32-49"></p><p>首先，无论是左边还是右边的单元，都是由卷积层和激活函数构成的。左边的单元由2个大小为3x3的卷积层与2个ReLU激活函数构成，右边的单元由2个1x1、1个3x3的卷积层和3个ReLU激活函数构成。至于卷积核的的通道（channel）数，则由单元的具体位置决定。通常卷积神经网络在提取图像特征的过程种，卷积核都会从“大卷积核、低通道数量“层层递进到到”小卷积核、多通道数量“。因此，在实际应用的过程种，短连接跨越的卷积层的通道数量有所改变是非常常见的。原论文中给出了直接连接、填零连接和映射连接三种具体的短连接形式。当实际单元的输入通道数与输出相同时，如上图左，则短连接<strong>直接连接</strong>即可。若输入通道数与输出不相同，如上图右，输入的维度为64，输出却是256，此时输入x无法与F(x)直接相加。<strong>填零连接</strong>就是将多出的维度全部填充0后再进行相加，这个方法不会引入额外的参数。<strong>映射连接</strong>则是通过矩阵变换，利用大小为1x1的卷积层扩展输入的维度后再进行相加。短连接跨越通道数不同的卷积层时，卷积执行的步长为2，这刚好缩小特征矩阵的大小，并增加了特征的通道数。</p><p>原论文中给出了如下5个具体的ResNet网络，这些网络都由上述的基本单元构成。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_08-35-51-20221204%2022:00:22.png" alt="Snipaste_2022-12-04_08-35-51"></p><h3 id="3-opencv：跨平台计算机视觉库"><a href="#3-opencv：跨平台计算机视觉库" class="headerlink" title="3.opencv：跨平台计算机视觉库"></a>3.opencv：跨平台计算机视觉库</h3><p><a href="https://opencv.org/">官网</a></p><h4 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h4><h4 id="阈值与平滑处理"><a href="#阈值与平滑处理" class="headerlink" title="阈值与平滑处理"></a>阈值与平滑处理</h4><h4 id="图像形态学操作"><a href="#图像形态学操作" class="headerlink" title="图像形态学操作"></a>图像形态学操作</h4><h4 id="图像梯度计算"><a href="#图像梯度计算" class="headerlink" title="图像梯度计算"></a>图像梯度计算</h4><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><h4 id="图像金字塔与轮廓检测"><a href="#图像金字塔与轮廓检测" class="headerlink" title="图像金字塔与轮廓检测"></a>图像金字塔与轮廓检测</h4><h4 id="直方图与傅里叶变换"><a href="#直方图与傅里叶变换" class="headerlink" title="直方图与傅里叶变换"></a>直方图与傅里叶变换</h4><h4 id="图像特征"><a href="#图像特征" class="headerlink" title="图像特征"></a>图像特征</h4><h4 id="相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪"><a href="#相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪" class="headerlink" title="相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪"></a>相关实践：数字识别、OCR识别、全景图像拼接、车位识别、答题卡判卷、背景建模、光流估计、目标追踪</h4><h3 id="4-物体检测：yolo"><a href="#4-物体检测：yolo" class="headerlink" title="4. 物体检测：yolo"></a>4. 物体检测：yolo</h3><p>YOLO系列是one-stage且是基于<a href="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6&spm=1001.2101.3001.7020">深度</a>学习的回归方法，而R-CNN、Fast-RCNN、Faster-RCNN等是two-stage且是基于深度学习的分类方法。</p><p><a href="https://github.com/pjreddie/darknet">YOLO官网</a></p><h4 id="YOLO-v1"><a href="#YOLO-v1" class="headerlink" title="YOLO v1"></a>YOLO v1</h4><p>论文地址：<a href="https://arxiv.org/abs/1506.02640">https://arxiv.org/abs/1506.02640</a></p><p>官方代码：<a href="https://github.com/pjreddie/darknet">https://github.com/pjreddie/darknet</a></p><p>YOLOv1的核心思想：</p><p>YOLOv1的核心思想就是利用整张图作为网络的输入，直接在输出层回归bounding box的位置和bounding box所属的类别。</p><p>实现方法：</p><ul><li>将一幅图像分成SxS个网格(grid cell)，如果某个object的中心落在这个网格中，则这个网格就负责预测这个object。</li><li>每个网格要预测B个bounding box，每个bounding box除了要回归自身的位置之外，还要附带预测一个confidence值。这个confidence代表了所预测的box中含有object的置信度和这个box预测的有多准两重信息，其值是这样计算的：$P_r(Object) * IOU_{pred}^{truth}$，该表达式含义：如果有object落在一个grid cell里，则第一项取1，否则取0。 第二项是预测的bounding box和实际的groundtruth之间的IoU值。 </li><li>每个bounding box要预测(x, y, w, h)和confidence共5个值，每个网格还要预测一个类别信息，记为C类。则SxS个网格，每个网格要预测B个bounding box还要预测C个categories。输出就是S x S x (5*B+C)的一个tensor。</li></ul><p>注意：class信息是针对每个网格的，confidence信息是针对每个bounding box的。</p><p><strong>举例</strong></p><p>在PASCAL VOC中，图像输入为448x448像素，取S&#x3D;7，B&#x3D;2，一共有20个类别(C&#x3D;20)。则输出就是7x7x(2x5+20)的一个tensor。整个网络结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-44-35-20221204%2022:00:36.png" alt="Snipaste_2022-12-04_18-44-35"></p><ul><li>在test的时候，每个网格预测的class信息和bounding box预测的confidence信息相乘，就得到每个bounding box的class-specific confidence score，得到每个box的class-specific confidence score以后，设置阈值，滤掉得分低的boxes，对保留的boxes进行NMS处理，就得到最终的检测结果。</li></ul><p>注意：<br>由于输出层为全连接层，因此在检测时，YOLOv1模型的输入只支持与训练图像相同的输入分辨率。<br>虽然每个格子可以预测B个bounding box，但是最终只选择IOU最高的bounding box作为物体检测输出，即每个格子最多只预测出一个物体。当物体占画面比例较小，如图像中包含畜群或鸟群时，每个格子包含多个物体，但却只能检测出其中一个。</p><p><strong>简单的概括就是：</strong></p><ul><li>给个一个输入图像，首先将图像划分成7*7的网格；</li><li>对于每个网格，我们都预测2个边框（包括每个边框是目标的置信度以及每个边框区域在多个类别上的概率）；</li><li>根据上一步可以预测出7<em>7</em>2个目标窗口，然后根据阈值去除可能性比较低的目标窗口，最后NMS去除冗余窗口即可。</li></ul><p>YOLO的缺点</p><ul><li>YOLO对相互靠的很近的物体和很小的群体检测效果不好，这是因为一个网格中只预测了两个框，并且只属于一类；</li><li>同一类物体出现的新的不常见的长宽比和其他情况时，泛化能力偏弱；</li><li>由于损失函数的问题，定位误差是影响检测效果的主要原因。尤其是大小物体的处理上，还有待加强。</li></ul><h4 id="YOLO-v2"><a href="#YOLO-v2" class="headerlink" title="YOLO v2"></a>YOLO v2</h4><p>论文地址：<a href="https://arxiv.org/abs/1612.08242">https://arxiv.org/abs/1612.08242</a></p><p>官方代码：<a href="http://pjreddie.com/darknet/yolo/">http://pjreddie.com/darknet/yolo/</a></p><p>YOLOv2相对v1版本，在继续保持处理速度的基础上，从预测<strong>更准确（Better）</strong>，<strong>速度更快（Faster）</strong>，<strong>识别对象更多（Stronger）</strong>这三个方面进行了改进。其中识别更多对象也就是扩展到能够检测9000种不同对象，称之为<strong>YOLO9000</strong>。</p><p>文章提出了一种新的训练方法–联合训练算法，这种算法可以把这两种的数据集混合到一起。使用一种分层的观点对物体进行分类，用巨量的分类数据集数据来扩充检测数据集，从而把两种不同的数据集混合起来。联合训练算法的基本思路就是：同时在检测数据集和分类数据集上训练物体检测器（Object Detectors ），用检测数据集的数据学习物体的准确位置，用分类数据集的数据来增加分类的类别量、提升健壮性。</p><p>YOLO9000就是使用联合训练算法训练出来的，他拥有9000类的分类信息，这些分类信息学习自ImageNet分类数据集，而物体位置检测则学习自COCO检测数据集。</p><p>YOLOv1有很多缺点，作者希望改进的方向是:<strong>改善recall，提升定位的准确度</strong>，同时保持分类的准确度。</p><h5 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h5><p><strong>Batch Normalization</strong><br>批量归一化有助于解决反向传播过程中的梯度消失和梯度爆炸问题，降低对一些超参数（比如学习率、网络参数的大小范围、激活函数的选择）的敏感性，并且每个batch分别进行归一化的时候，起到了一定的正则化效果（YOLOv2不再使用dropout），从而能够获得更好的收敛速度和收敛效果。</p><p>使用Batch Normalization对网络进行优化，让网络提高了收敛性，同时还消除了对其他形式的正则化（regularization）的依赖。通过对YOLOv2的每一个卷积层增加Batch Normalization，最终使得mAP提高了2%，同时还使model正则化。使用Batch Normalization可以从model中去掉Dropout，而不会产生过拟合。</p><p><strong>High resolution classifier</strong><br>用于图像分类的训练样本很多，而标注了边框的用于训练目标检测的样本相比而言就少了很多，因为标注边框的人工成本比较高。所以目标检测模型通常都先用图像分类样本训练卷积层，提取图像特征，但这引出另一个问题，就是图像分类样本的分辨率不是很高。所以YOLOv1使用ImageNet的图像分类样本采用 224<em>224 作为输入，来训练CNN卷积层。然后在训练目标检测时，检测用的图像样本采用更高分辨率的 448</em>448 像素图像作为输入，但这样不一致的输入分辨率肯定会对模型性能有一定影响。</p><p>所以YOLOv2在采用 224<em>224 图像进行分类模型预训练后，再采用 448</em>448 高分辨率样本对分类模型进行微调（10个epoch），使网络特征逐渐适应 448<em>448 的分辨率。然后再使用 448</em>448 的检测样本进行训练，缓解了分辨率突然切换造成的影响，最终通过使用高分辨率，mAP提升了4%。</p><p><strong>Convolution with anchor boxes</strong></p><p>YOLOv1包含有全连接层，从而能直接预测Bounding Boxes的坐标值。Faster R-CNN算法只用卷积层与Region Proposal Network来预测Anchor Box的偏移值与置信度，而不是直接预测坐标值，YOLOv2作者发现通过预测偏移量而不是坐标值能够简化问题，让神经网络学习起来更容易。</p><p>借鉴Faster RCNN的做法，YOLOv2也尝试采用先验框（anchor）。在每个grid预先设定一组不同大小和宽高比的边框，来覆盖整个图像的不同位置和多种尺度，这些先验框作为预定义的候选区在神经网络中将检测其中是否存在对象，以及微调边框的位置。</p><p>之前YOLOv1并没有采用先验框，并且每个grid只预测两个bounding box，也就是整个图像只有98个bounding box。YOLOv2如果每个grid采用9个先验框，总共有13<em>13</em>9&#x3D;1521个先验框。所以最终YOLOv2去掉了全连接层，使用Anchor Boxes来预测 Bounding Boxes。作者去掉了网络中一个Pooling层，这让卷积层的输出能有更高的分辨率，同时对网络结构进行收缩让其运行在416<em>416而不是448</em>448。</p><p>由于图片中的物体都倾向于出现在图片的中心位置，特别是那种比较大的物体，所以有一个单独位于物体中心的位置用于预测这些物体。YOLOv2的卷积层采用32这个值来下采样图片，所以通过选择416*416用作输入尺寸最终能输出一个13*13的Feature Map。使用Anchor Box会让精确度稍微下降，但用了它能让YOLOv2能预测出大于一千个框，同时recall达到88%，mAP达到69.2%。<br><strong>Dimension clusters</strong><br>之前Anchor Box的尺寸是手动选择的，所以尺寸还有优化的余地。YOLOv2尝试统计出更符合样本中对象尺寸的先验框，这样就可以减少网络微调先验框到实际位置的难度。YOLOv2的做法是对训练集中标注的边框进行K-means聚类分析，以寻找尽可能匹配样本的边框尺寸。如果我们用标准的欧式距离的k-means，尺寸大的框比小框产生更多的错误。因为我们的目的是提高IOU分数，这依赖于Box的大小，所以距离度量的使用：</p><p>其中，centroid是聚类时被选作中心的边框，box就是其它边框，d就是两者间的“距离”，IOU越大，“距离”越近。YOLOv2给出的聚类分析结果如下图所示，通过分析实验结果（Figure 2），在model复杂性与high recall之间权衡之后，选择聚类分类数K&#x3D;5。<br>Direct location prediction<br>用Anchor Box的方法，会让model变得不稳定，尤其是在最开始几次迭代的时候。大多数不稳定因素产生自预测Box的(x,y)位置的时候。按照之前YOLOv1的方法，网络不会预测偏移量，而是根据YOLOv1中的网格单元的位置来直接预测坐标，这就让Ground Truth的值介于0到1之间。而为了让网络的结果能落在这一范围内，网络使用一个 Logistic Activation来对于网络预测结果进行限制，让结果介于0到1之间。 网络在每一个网格单元中预测出5个Bounding Boxes，每个Bounding Boxes有五个坐标值tx，ty，tw，th，t0，他们的关系见下图。假设一个网格单元对于图片左上角的偏移量是cx，cy，Bounding Boxes Prior的宽度和高度是pw，ph，那么预测的结果见下图右面的公式：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-56-44-20221204%2022:00:49.png" alt="Snipaste_2022-12-04_18-56-44"></p><p><strong>Fine-Grained Features</strong><br>目标检测面临的一个问题是图像中的需要检测的目标会有大有小，输入图像经过多层网络提取特征，最后输出的特征图中（比如YOLOv2中输入416<em>416经过卷积网络下采样最后输出是13</em>13），较小的对象可能特征已经不明显甚至被忽略掉了。为了更好的检测出一些比较小的对象，最后输出的特征图需要保留一些更细节的信息。于是YOLOv2引入一种称为passthrough层的方法在特征图中保留一些细节信息。具体来说，就是在最后一个pooling之前，特征图的大小是26<em>26</em>512，将其1拆4，直接传递（passthrough）到pooling后（并且又经过一组卷积）的特征图，两者叠加到一起作为输出的特征图。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-58-27-20221204%2022:01:01.png" alt="Snipaste_2022-12-04_18-58-27"></p><p>具体怎样将1个特征图拆成4个特征图，见下图，图中示例的是1个4<em>4拆成4个2</em>2，因为深度不变，所以没有画出来。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_18-58-53-20221204%2022:01:10.png" alt="Snipaste_2022-12-04_18-58-53"></p><p><strong>Multi-ScaleTraining</strong></p><p>作者希望YOLOv2能健壮的运行于不同尺寸的图片之上，所以把这一想法用于训练model中。区别于之前的补全图片的尺寸的方法，YOLOv2每迭代几次都会改变网络参数。每10个Batch，网络会随机地选择一个新的图片尺寸，由于使用了下采样参数是32，所以不同的尺寸大小也选择为32的倍数{320，352…..608}，最小320<em>320，最大608</em>608，网络会自动改变尺寸，并继续训练的过程。这一政策让网络在不同的输入尺寸上都能达到一个很好的预测效果，同一网络能在不同分辨率上进行检测。当输入图片尺寸比较小的时候跑的比较快，输入图片尺寸比较大的时候精度高，所以你可以在YOLOv2的速度和精度上进行权衡。</p><p><strong>YOLOv2 Faster</strong></p><p>YOLOv1的backbone使用的是GoogleLeNet，速度比VGG-16快，YOLOv1完成一次前向过程只用8.52 billion 运算，而VGG-16要30.69billion，但是YOLOv1精度稍低于VGG-16。</p><p>YOLOv2基于一个新的分类model，有点类似与VGG。YOLOv2使用3*3filter，每次Pooling之后都增加一倍Channels的数量。YOLOv2使用Global Average Pooling，使用Batch Normilazation来让训练更稳定，加速收敛，使model规范化。最终的model–Darknet19，有19个卷积层和5个maxpooling层，处理一张图片只需要5.58 billion次运算，在ImageNet上达到72.9%top-1精确度，91.2%top-5精确度。</p><p>网络训练在 ImageNet 1000类分类数据集上训练了160epochs，使用随机梯度下降，初始学习率为0.1， polynomial rate decay with a power of 4, weight decay of 0.0005 and momentum of 0.9 。训练期间使用标准的数据扩大方法：随机裁剪、旋转、变换颜色（hue）、变换饱和度（saturation）， 变换曝光度（exposure shifts）。在训练时，把整个网络在更大的448*448分辨率上Fine Turnning 10个 epoches，初始学习率设置为0.001，这种网络达到达到76.5%top-1精确度，93.3%top-5精确度。</p><p>网络去掉了最后一个卷积层，而加上了三个3<em>3卷积层，每个卷积层有1024个Filters，每个卷积层紧接着一个1</em>1卷积层。对于VOC数据，网络预测出每个网格单元预测五个Bounding Boxes，每个Bounding Boxes预测5个坐标和20类，所以一共125个Filters，增加了Passthough层来获取前面层的细粒度信息，网络训练了160epoches，初始学习率0.001，数据扩大方法相同，对COCO与VOC数据集的训练对策相同。</p><h4 id="YOLO-v3"><a href="#YOLO-v3" class="headerlink" title="YOLO v3"></a>YOLO v3</h4><p>论文地址：<a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf">https://pjreddie.com/media/files/papers/YOLOv3.pdf</a> </p><p>这张图很好的总结了YOLOv3的结构，让我们对YOLO有更加直观的理解。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-04-40-20221204%2022:01:21.png" alt="Snipaste_2022-12-04_19-04-40"></p><p>DBL: 代码中的Darknetconv2d_BN_Leaky，是YOLOv3的基本组件，就是卷积+BN+Leaky relu。<br>resn：n代表数字，有res1，res2, … ,res8等等，表示这个res_block里含有多少个res_unit。不懂resnet请戳这儿</p><p>concat：张量拼接；将darknet中间层和后面的某一层的上采样进行拼接。拼接的操作和残差层add的操作是不一样的，拼接会扩充张量的维度，而add只是直接相加不会导致张量维度的改变。</p><p><strong>Backbone：darknet-53</strong></p><p>为了达到更好的分类效果，作者自己设计训练了darknet-53，在ImageNet数据集上实验发现这个darknet-53，的确很强，相对于ResNet-152和ResNet-101，darknet-53不仅在分类精度上差不多，计算速度还比ResNet-152和ResNet-101强多了，网络层数也比他们少。</p><p>YOLOv3使用了darknet-53的前面的52层（没有全连接层），YOLOv3这个网络是一个全卷积网络，大量使用残差的跳层连接，并且为了降低池化带来的梯度负面效果，作者直接摒弃了POOLing，用conv的stride来实现降采样。在这个网络结构中，使用的是步长为2的卷积来进行降采样。</p><p>为了加强算法对小目标检测的精确度，YOLOv3中采用类似FPN的upsample和融合做法（最后融合了3个scale，其他两个scale的大小分别是26×26和52×52），在多个scale的feature map上做检测。</p><p>作者在3条预测支路采用的也是全卷积的结构，其中最后一个卷积层的卷积核个数是255，是针对COCO数据集的80类：3*(80+4+1)&#x3D;255，3表示一个grid cell包含3个bounding box，4表示框的4个坐标信息，1表示objectness score。</p><p>网络中作者进行了三次检测，分别是在32倍降采样，16倍降采样，8倍降采样时进行检测，这样在多尺度的feature map上检测跟SSD有点像。在网络中使用up-sample（上采样）的原因:网络越深的特征表达效果越好，比如在进行16倍降采样检测，如果直接使用第四次下采样的特征来检测，这样就使用了浅层特征，这样效果一般并不好。如果想使用32倍降采样后的特征，但深层特征的大小太小，因此YOLOv3使用了步长为2的up-sample（上采样），把32倍降采样得到的feature map的大小提升一倍，也就成了16倍降采样后的维度。同理8倍采样也是对16倍降采样的特征进行步长为2的上采样，这样就可以使用深层特征进行detection。</p><p>作者通过上采样将深层特征提取，其维度是与将要融合的特征层维度相同的（channel不同）。如下图所示，85层将13×13×256的特征上采样得到26×26×256，再将其与61层的特征拼接起来得到26×26×768。为了得到channel255，还需要进行一系列的3×3，1×1卷积操作，这样既可以提高非线性程度增加泛化性能提高网络精度，又能减少参数提高实时性。52×52×255的特征也是类似的过程。</p><p><strong>Bounding Box</strong></p><p>YOLOv3的Bounding Box由YOLOv2又做出了更好的改进。在YOLOv2和YOLOv3中，都采用了对图像中的object采用k-means聚类。feature map中的每一个cell都会预测3个边界框（bounding box） ，每个bounding box都会预测三个东西：（1）每个框的位置（4个值，中心坐标tx和ty，框的高度bh和宽度bw），（2）一个objectness prediction ，（3）N个类别，coco数据集80类，voc20类。</p><p>三次检测，每次对应的感受野不同，32倍降采样的感受野最大，适合检测大的目标，所以在输入为416×416时，每个cell的三个anchor box为(116 ,90); (156 ,198); (373 ,326)。16倍适合一般大小的物体，anchor box为(30,61); (62,45); (59,119)。8倍的感受野最小，适合检测小目标，因此anchor box为(10,13); (16,30); (33,23)。所以当输入为416×416时，实际总共有（52×52+26×26+13×13）×3&#x3D;10647个proposal box。</p><p><strong>LOSS Function</strong></p><p>YOLOv3重要改变之一：No more softmaxing the classes。YOLOv3现在对图像中检测到的对象执行多标签分类。</p><p>logistic回归用于对anchor包围的部分进行一个目标性评分(objectness score)，即这块位置是目标的可能性有多大。这一步是在predict之前进行的，可以去掉不必要anchor，可以减少计算量。</p><p>如果模板框不是最佳的即使它超过我们设定的阈值，我们还是不会对它进行predict。不同于Faster R-CNN的是，YOLOv3只会对1个prior进行操作，也就是那个最佳prior。而logistic回归就是用来从9个anchor priors中找到objectness score(目标存在可能性得分)最高的那一个。logistic回归就是用曲线对prior相对于 objectness score映射关系的线性建模。</p><ul><li>首先，YOLOv3要先build target，因为我们知道正样本是label与anchor box iou大于0.5的组成，所以我们根据label找到对应的anchor box。如何找出label中存放着[image,class,x(归一化),y,w(归一化),h],我们可以用这些坐标在对应13×13 Or 26×26 or 52×52的map中分别于9个anchor算出iou，找到符合要求的，把索引与位置记录好。用记录好的索引位置找到predict的anchor box。</li><li>xywh是由均方差来计算loss的，其中预测的xy进行sigmoid来与lable xy求差，label xy是grid cell中心点坐标，其值在0-1之间，所以predict出的xy要sigmoid。</li><li>分类用的多类别交叉熵，置信度用的二分类交叉熵。只有正样本才参与class，xywh的loss计算，负样本只参与置信度loss。</li></ul><h4 id="YOLO-v4"><a href="#YOLO-v4" class="headerlink" title="YOLO v4"></a>YOLO v4</h4><p>YOLOv4: Optimal Speed and Accuracy of Object Detection</p><p>论文：<a href="https://arxiv.org/abs/2004.10934">https://arxiv.org/abs/2004.10934</a></p><p>代码：<a href="https://github.com/AlexeyAB/darknet">https://github.com/AlexeyAB/darknet</a></p><p>YOLOv4其实是一个结合了大量前人研究技术，加以组合并进行适当创新的算法，实现了速度和精度的完美平衡。可以说有许多技巧可以提高卷积神经网络(CNN)的准确性，但是某些技巧仅适合在某些模型上运行，或者仅在某些问题上运行，或者仅在小型数据集上运行；我们来码一码这篇文章里作者都用了哪些调优手段：加权残差连接(WRC),跨阶段部分连接(CSP),跨小批量标准化(CmBN),自对抗训练(SAT),Mish激活,马赛克数据增强,CmBN,DropBlock正则化,CIoU Loss等等。经过一系列的堆料，终于实现了目前最优的实验结果：43.5％的AP(在Tesla V100上，MS COCO数据集的实时速度约为65FPS)。</p><p>先直接上<code>YOLOv4</code>的整体原理图(来源网络)如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-17-31-20221204%2022:01:36.png" alt="Snipaste_2022-12-04_19-17-31"></p><p>我们前面知道在YOLOv3中，特征提取网络使用的是Darknet53，而在YOLOv4中，对Darknet53做了一点改进，借鉴了CSPNet，CSPNet全称是Cross Stage Partial Networks，也就是跨阶段局部网络。CSPNet解决了其他大型卷积神经网络框架Backbone中网络优化的梯度信息重复问题，将梯度的变化从头到尾地集成到特征图中，因此减少了模型的参数量和FLOPS数值，既保证了推理速度和准确率，又减小了模型尺寸。<br>CSPNet实际上是基于Densnet的思想，复制基础层的特征映射图，通过dense block发送副本到下一个阶段，从而将基础层的特征映射图分离出来。这样可以有效缓解梯度消失问题(通过非常深的网络很难去反推丢失信号) ，支持特征传播，鼓励网络重用特征，从而减少网络参数数量。CSPNet思想可以和ResNet、ResNeXt和DenseNet结合，目前主要有CSPResNext50 和CSPDarknet53两种改造Backbone网络。</p><p>考虑到几方面的平衡：输入网络分辨率&#x2F;卷积层数量&#x2F;参数数量&#x2F;输出维度。一个模型的分类效果好不见得其检测效果就好，想要检测效果好需要以下几点：</p><ul><li>更大的网络输入分辨率——用于检测小目标</li><li>更深的网络层——能够覆盖更大面积的感受野</li><li>更多的参数——更好的检测同一图像内不同size的目标</li></ul><p>为了增大感受野，作者还使用了<code>SPP-block</code>，使用<code>PANet</code>代替<code>FPN</code>进行参数聚合以适用于不同<code>level</code>的目标检测。</p><p><code>SPP-Net</code>全称<code>Spatial Pyramid Pooling Networks</code>，当时主要是用来解决不同尺寸的特征图如何进入全连接层的，直接看下图，下图中对任意尺寸的特征图直接进行固定尺寸的池化，来得到固定数量的特征。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-20-50-20221204%2022:01:46.png" alt="Snipaste_2022-12-04_19-20-50"></p><p>如上图，以3个尺寸的池化为例，对特征图进行一个最大值池化，即一张特征图得取其最大值，得到1<em>d(d是特征图的维度)个特征；对特征图进行网格划分为2x2的网格，然后对每个网格进行最大值池化，那么得到4</em>d个特征；同样，对特征图进行网格划分为4x4个网格，对每个网格进行最大值池化，得到16*d个特征。 接着将每个池化得到的特征合起来即得到固定长度的特征个数（特征图的维度是固定的），接着就可以输入到全连接层中进行训练网络了。用到这里是为了增加感受野。</p><p><code>YOLOv4</code>使用<code>PANet</code>(<code>Path Aggregation Network</code>)代替<code>FPN</code>进行参数聚合以适用于不同<code>level</code>的目标检测, <code>PANet</code>论文中融合的时候使用的方法是<code>Addition</code>，<code>YOLOv4</code>算法将融合的方法由加法改为<code>Concatenation</code>。</p><p><strong>激活函数</strong></p><p>对激活函数的研究一直没有停止过，<code>ReLU</code>还是统治着深度学习的激活函数，不过，这种情况有可能会被<code>Mish</code>改变。<code>Mish</code>是另一个与<code>ReLU</code>和<code>Swish</code>非常相似的激活函数。正如论文所宣称的那样，<code>Mish</code>可以在不同数据集的许多深度网络中胜过它们。公式为：$y &#x3D; x*tanh(ln(1+e^x))$</p><p>Mish是一个平滑的曲线，平滑的激活函数允许更好的信息深入神经网络，从而得到更好的准确性和泛化；在负值的时候并不是完全截断，允许比较小的负梯度流入。实验中，随着层深的增加，ReLU激活函数精度迅速下降，而Mish激活函数在训练稳定性、平均准确率(1%-2.8%)、峰值准确率(1.2% - 3.6%)等方面都有全面的提高。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-28-33-20221204%2022:01:57.png" alt="Snipaste_2022-12-04_19-28-33"></p><p><strong>自对抗训练(SAT)</strong></p><p>SAT为一种新型数据增强方式。在第一阶段，神经网络改变原始图像而不是网络权值。通过这种方式，神经网络对其自身进行一种对抗式的攻击，改变原始图像，制造图像上没有目标的假象。在第二阶段，训练神经网络对修改后的图像进行正常的目标检测。</p><p>Self-Adversarial Training是在一定程度上抵抗对抗攻击的数据增强技术。CNN计算出Loss, 然后通过反向传播改变图片信息，形成图片上没有目标的假象，然后对修改后的图像进行正常的目标检测。需要注意的是在SAT的反向传播的过程中，是不需要改变网络权值的。 使用对抗生成可以改善学习的决策边界中的薄弱环节，提高模型的鲁棒性。因此这种数据增强方式被越来越多的对象检测框架运用。</p><p>YOLO v5</p><p>YOLOv4出现之后不久，YOLOv5横空出世。YOLOv5在YOLOv4算法的基础上做了进一步的改进，检测性能得到进一步的提升。虽然YOLOv5算法并没有与YOLOv4算法进行性能比较与分析，但是YOLOv5在COCO数据集上面的测试效果还是挺不错的。大家对YOLOv5算法的创新性半信半疑，有的人对其持肯定态度，有的人对其持否定态度。在我看来，YOLOv5检测算法中还是存在很多可以学习的地方，虽然这些改进思路看来比较简单或者创新点不足，但是它们确定可以提升检测算法的性能。其实工业界往往更喜欢使用这些方法，而不是利用一个超级复杂的算法来获得较高的检测精度。<br>YOLOv5是一种单阶段目标检测算法，该算法在YOLOv4的基础上添加了一些新的改进思路，使其速度与精度都得到了极大的性能提升。主要的改进思路如下所示：</p><p>输入端：在模型训练阶段，提出了一些改进思路，主要包括Mosaic数据增强、自适应锚框计算、自适应图片缩放；</p><p>基准网络：融合其它检测算法中的一些新思路，主要包括：Focus结构与CSP结构；</p><p>Neck网络：目标检测网络在BackBone与最后的Head输出层之间往往会插入一些层，Yolov5中添加了FPN+PAN结构；</p><p>Head输出层：输出层的锚框机制与YOLOv4相同，主要改进的是训练时的损失函数GIOU_Loss，以及预测框筛选的DIOU_nms。</p><p>网络架构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-30-57-20221204%2022:02:07.png" alt="Snipaste_2022-12-04_19-30-57"></p><p>上图展示了YOLOv5目标检测算法的整体框图。对于一个目标检测算法而言，我们通常可以将其划分为4个通用的模块，具体包括：输入端、基准网络、Neck网络与Head输出端，对应于上图中的4个红色模块。YOLOv5算法具有4个版本，具体包括：YOLOv5s、YOLOv5m、YOLOv5l、YOLOv5x四种，本文重点讲解YOLOv5s，其它的版本都在该版本的基础上对网络进行加深与加宽。</p><ul><li>输入端-输入端表示输入的图片。该网络的输入图像大小为608*608，该阶段通常包含一个图像预处理阶段，即将输入图像缩放到网络的输入大小，并进行归一化等操作。在网络训练阶段，YOLOv5使用Mosaic数据增强操作提升模型的训练速度和网络的精度；并提出了一种自适应锚框计算与自适应图片缩放方法。</li><li>基准网络-基准网络通常是一些性能优异的分类器种的网络，该模块用来提取一些通用的特征表示。YOLOv5中不仅使用了CSPDarknet53结构，而且使用了Focus结构作为基准网络。</li><li>Neck网络-Neck网络通常位于基准网络和头网络的中间位置，利用它可以进一步提升特征的多样性及鲁棒性。虽然YOLOv5同样用到了SPP模块、FPN+PAN模块，但是实现的细节有些不同。</li><li>Head输出端-Head用来完成目标检测结果的输出。针对不同的检测算法，输出端的分支个数不尽相同，通常包含一个分类分支和一个回归分支。YOLOv4利用GIOU_Loss来代替Smooth L1 Loss函数，从而进一步提升算法的检测精度。</li></ul><p>YOLO v5基础组件</p><ul><li>CBL-CBL模块由Conv+BN+Leaky_relu激活函数组成，如上图中的模块1所示。</li><li>Res unit-借鉴ResNet网络中的残差结构，用来构建深层网络，CBM是残差模块中的子模块，如上图中的模块2所示。</li><li>CSP1_X-借鉴CSPNet网络结构，该模块由CBL模块、Res unint模块以及卷积层、Concate组成而成，如上图中的模块3所示。</li><li>CSP2_X-借鉴CSPNet网络结构，该模块由卷积层和X个Res unint模块Concate组成而成，如上图中的模块4所示。</li><li>Focus-如上图中的模块5所示，Focus结构首先将多个slice结果Concat起来，然后将其送入CBL模块中。</li><li>SPP-采用1×1、5×5、9×9和13×13的最大池化方式，进行多尺度特征融合，如上图中的模块6所示。</li></ul><blockquote><p>yolo系列参考 [这里][<a href="https://blog.csdn.net/qq_40716944/article/details/114822515?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=5%5D">https://blog.csdn.net/qq_40716944/article/details/114822515?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-114822515-blog-105157452.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=5]</a></p></blockquote><h3 id="5-图像分割-x2F-语义分割"><a href="#5-图像分割-x2F-语义分割" class="headerlink" title="5. 图像分割&#x2F;语义分割"></a>5. 图像分割&#x2F;语义分割</h3><h4 id="unet"><a href="#unet" class="headerlink" title="unet"></a>unet</h4><p>Unet可以说是<strong>最常用、最简单</strong>的一种分割模型了，它简单、高效、易懂、容易构建、可以从小数据集中训练。</p><p>Unet已经是非常老的分割模型了，是2015年《U-Net: Convolutional Networks for Biomedical Image Segmentation》提出的模型，论文链接：<a href="https://arxiv.org/abs/1505.04597">https://arxiv.org/abs/1505.04597</a></p><p>在Unet之前，则是更老的FCN网络，FCN是Fully Convolutional Netowkrs的碎屑，不过这个<strong>基本上是一个框架，到现在的分割网络，谁敢说用不到卷积层呢。</strong> 不过FCN网络的准确度较低，不比Unet好用。现在还有Segnet，Mask RCNN，DeepLabv3+等网络，不过今天我先介绍Unet，毕竟一口吃不成胖子。</p><p>网络结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_19-35-40-20221204%2022:02:18.png" alt="Snipaste_2022-12-04_19-35-40"></p><p>这个结构就是先对图片进行卷积和池化，在Unet论文中是池化4次，比方说一开始的图片是224x224的，那么就会变成112x112，56x56,28x28,14x14四个不同尺寸的特征。<strong>然后我们对14x14的特征图做上采样或者反卷积，得到28x28的特征图，这个28x28的特征图与之前的28x28的特征图进行通道伤的拼接concat，然后再对拼接之后的特征图做卷积和上采样，得到56x56的特征图，再与之前的56x56的特征拼接，卷积，再上采样，经过四次上采样可以得到一个与输入图像尺寸相同的224x224的预测结果。</strong></p><p>其实整体来看，这个也是一个Encoder-Decoder的结构。</p><p>Unet网络非常的简单，前半部分就是特征提取，后半部分是上采样。在一些文献中把这种结构叫做<strong>编码器-解码器结构</strong>，由于网络的整体结构是一个大些的英文字母U，所以叫做U-net。</p><ul><li>Encoder：左半部分，由两个3x3的卷积层（RELU）再加上一个2x2的maxpooling层组成一个下采样的模块（后面代码可以看出）；</li><li>Decoder：有半部分，由一个上采样的卷积层（去卷积层）+特征拼接concat+两个3x3的卷积层（ReLU）反复构成（代码中可以看出来）；</li></ul><p>Unet的好处我感觉是：网络层越深得到的特征图，有着更大的视野域，浅层卷积关注纹理特征，深层网络关注本质的那种特征，所以深层浅层特征都是有格子的意义的；另外一点是通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回。</p><p>注：大多数医疗影像语义分割任务都会首先用Unet作为baseline</p><p>附一个比较清晰的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">double_conv2d_bn</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,in_channels,out_channels,kernel_size=<span class="hljs-number">3</span>,strides=<span class="hljs-number">1</span>,padding=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-built_in">super</span>(double_conv2d_bn,self).__init__()<br>        self.conv1 = nn.Conv2d(in_channels,out_channels,<br>                               kernel_size=kernel_size,<br>                              stride = strides,padding=padding,bias=<span class="hljs-literal">True</span>)<br>        self.conv2 = nn.Conv2d(out_channels,out_channels,<br>                              kernel_size = kernel_size,<br>                              stride = strides,padding=padding,bias=<span class="hljs-literal">True</span>)<br>        self.bn1 = nn.BatchNorm2d(out_channels)<br>        self.bn2 = nn.BatchNorm2d(out_channels)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        out = F.relu(self.bn1(self.conv1(x)))<br>        out = F.relu(self.bn2(self.conv2(out)))<br>        <span class="hljs-keyword">return</span> out<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">deconv2d_bn</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,in_channels,out_channels,kernel_size=<span class="hljs-number">2</span>,strides=<span class="hljs-number">2</span></span>):<br>        <span class="hljs-built_in">super</span>(deconv2d_bn,self).__init__()<br>        self.conv1 = nn.ConvTranspose2d(in_channels,out_channels,<br>                                        kernel_size = kernel_size,<br>                                       stride = strides,bias=<span class="hljs-literal">True</span>)<br>        self.bn1 = nn.BatchNorm2d(out_channels)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        out = F.relu(self.bn1(self.conv1(x)))<br>        <span class="hljs-keyword">return</span> out<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Unet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Unet,self).__init__()<br>        self.layer1_conv = double_conv2d_bn(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)<br>        self.layer2_conv = double_conv2d_bn(<span class="hljs-number">8</span>,<span class="hljs-number">16</span>)<br>        self.layer3_conv = double_conv2d_bn(<span class="hljs-number">16</span>,<span class="hljs-number">32</span>)<br>        self.layer4_conv = double_conv2d_bn(<span class="hljs-number">32</span>,<span class="hljs-number">64</span>)<br>        self.layer5_conv = double_conv2d_bn(<span class="hljs-number">64</span>,<span class="hljs-number">128</span>)<br>        self.layer6_conv = double_conv2d_bn(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>)<br>        self.layer7_conv = double_conv2d_bn(<span class="hljs-number">64</span>,<span class="hljs-number">32</span>)<br>        self.layer8_conv = double_conv2d_bn(<span class="hljs-number">32</span>,<span class="hljs-number">16</span>)<br>        self.layer9_conv = double_conv2d_bn(<span class="hljs-number">16</span>,<span class="hljs-number">8</span>)<br>        self.layer10_conv = nn.Conv2d(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,kernel_size=<span class="hljs-number">3</span>,<br>                                     stride=<span class="hljs-number">1</span>,padding=<span class="hljs-number">1</span>,bias=<span class="hljs-literal">True</span>)<br>        <br>        self.deconv1 = deconv2d_bn(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>)<br>        self.deconv2 = deconv2d_bn(<span class="hljs-number">64</span>,<span class="hljs-number">32</span>)<br>        self.deconv3 = deconv2d_bn(<span class="hljs-number">32</span>,<span class="hljs-number">16</span>)<br>        self.deconv4 = deconv2d_bn(<span class="hljs-number">16</span>,<span class="hljs-number">8</span>)<br>        <br>        self.sigmoid = nn.Sigmoid()<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br>        conv1 = self.layer1_conv(x)<br>        pool1 = F.max_pool2d(conv1,<span class="hljs-number">2</span>)<br>        <br>        conv2 = self.layer2_conv(pool1)<br>        pool2 = F.max_pool2d(conv2,<span class="hljs-number">2</span>)<br>        <br>        conv3 = self.layer3_conv(pool2)<br>        pool3 = F.max_pool2d(conv3,<span class="hljs-number">2</span>)<br>        <br>        conv4 = self.layer4_conv(pool3)<br>        pool4 = F.max_pool2d(conv4,<span class="hljs-number">2</span>)<br>        <br>        conv5 = self.layer5_conv(pool4)<br>        <br>        convt1 = self.deconv1(conv5)<br>        concat1 = torch.cat([convt1,conv4],dim=<span class="hljs-number">1</span>)<br>        conv6 = self.layer6_conv(concat1)<br>        <br>        convt2 = self.deconv2(conv6)<br>        concat2 = torch.cat([convt2,conv3],dim=<span class="hljs-number">1</span>)<br>        conv7 = self.layer7_conv(concat2)<br>        <br>        convt3 = self.deconv3(conv7)<br>        concat3 = torch.cat([convt3,conv2],dim=<span class="hljs-number">1</span>)<br>        conv8 = self.layer8_conv(concat3)<br>        <br>        convt4 = self.deconv4(conv8)<br>        concat4 = torch.cat([convt4,conv1],dim=<span class="hljs-number">1</span>)<br>        conv9 = self.layer9_conv(concat4)<br>        outp = self.layer10_conv(conv9)<br>        outp = self.sigmoid(outp)<br>        <span class="hljs-keyword">return</span> outp<br>    <br><br>model = Unet()<br>inp = torch.rand(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">224</span>,<span class="hljs-number">224</span>)<br>outp = model(inp)<br><span class="hljs-built_in">print</span>(outp.shape)<br>==&gt; torch.Size([<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>])<br></code></pre></td></tr></table></figure><h4 id="u2net"><a href="#u2net" class="headerlink" title="u2net"></a>u2net</h4><p>论文：<a href="https://arxiv.org/pdf/2005.09007.pdf">https://arxiv.org/pdf/2005.09007.pdf</a></p><p>代码：<a href="https://codeload.github.com/NathanUA/U-2-Net/zip/master">https://codeload.github.com/NathanUA/U-2-Net/zip/master</a></p><p>U2net是基于unet提出的一种新的网络结构，同样基于encode-decode，作者参考FPN，Unet，在此基础之上提出了一种新模块RSU(ReSidual U-blocks) 经过测试，对于分割物体前背景取得了惊人的效果。同样具有较好的实时性，经过测试在P100上前向时间仅为18ms(56fps)。</p><p>网络结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-15-07-20221204%2022:02:32.png" alt="Snipaste_2022-12-04_20-15-07"></p><p>其实这个网络结构以及把一整个u2net完整的表示出来了，作者提出了一种名为RSU的新模块。对于每个RSU本身就是一个小号的Unet，最后所有的RSU用一种类似FPN的结构连接在一起。类似down-top top-down。通过这种方式来增加多尺度能力。获得了极为优秀的分割结果。</p><p>从这个结构可以很容易的看出，所谓的RSU其实就是一个很简单的Unet</p><p>作者通过类似FPN的结构，将多个Unet输出结果进行组合。最后进行合并，得到mask，通过多个loss在不同层的表现来进行更新。取得了非常理想的效果。</p><p>下面是整个U2net代码细节的介绍：</p><p>由于这个代码写的相对比较。。嗯。写的比较清晰，所以和以往的介绍不一样，我以代码注释的形式介绍好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">U2NET</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,in_ch=<span class="hljs-number">3</span>,out_ch=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-built_in">super</span>(U2NET,self).__init__()<br>        self.stage1 = RSU7(in_ch,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>)<br><span class="hljs-comment">#对于每一个RSU来说，本质其实就是一个Unet，多个下采样多个上采样</span><br><br>        self.pool12 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage2 = RSU6(<span class="hljs-number">64</span>,<span class="hljs-number">32</span>,<span class="hljs-number">128</span>)<br>        self.pool23 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage3 = RSU5(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>,<span class="hljs-number">256</span>)<br>        self.pool34 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage4 = RSU4(<span class="hljs-number">256</span>,<span class="hljs-number">128</span>,<span class="hljs-number">512</span>)<br>        self.pool45 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage5 = RSU4F(<span class="hljs-number">512</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>)<br>        self.pool56 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br>        self.stage6 = RSU4F(<span class="hljs-number">512</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>)<br>        <span class="hljs-comment"># decoder</span><br>        self.stage5d = RSU4F(<span class="hljs-number">1024</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>)<br>        self.stage4d = RSU4(<span class="hljs-number">1024</span>,<span class="hljs-number">128</span>,<span class="hljs-number">256</span>)<br>        self.stage3d = RSU5(<span class="hljs-number">512</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>)<br>        self.stage2d = RSU6(<span class="hljs-number">256</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>)<br>        self.stage1d = RSU7(<span class="hljs-number">128</span>,<span class="hljs-number">16</span>,<span class="hljs-number">64</span>)<br>        self.side1 = nn.Conv2d(<span class="hljs-number">64</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side2 = nn.Conv2d(<span class="hljs-number">64</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side3 = nn.Conv2d(<span class="hljs-number">128</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side4 = nn.Conv2d(<span class="hljs-number">256</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side5 = nn.Conv2d(<span class="hljs-number">512</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.side6 = nn.Conv2d(<span class="hljs-number">512</span>,out_ch,<span class="hljs-number">3</span>,padding=<span class="hljs-number">1</span>)<br>        self.outconv = nn.Conv2d(<span class="hljs-number">6</span>,out_ch,<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br><br>        hx = x<br>        <span class="hljs-comment">#stage 1</span><br>        hx1 = self.stage1(hx)<br>        <span class="hljs-comment">#通过一个个Unet得到相应的mask</span><br>        hx = self.pool12(hx1)<br>        <span class="hljs-comment">#stage 2</span><br>        hx2 = self.stage2(hx)<br>        hx = self.pool23(hx2)<br>        <span class="hljs-comment">#stage 3</span><br>        hx3 = self.stage3(hx)<br>        hx = self.pool34(hx3)<br>        <span class="hljs-comment">#stage 4</span><br>        hx4 = self.stage4(hx)<br>        hx = self.pool45(hx4)<br>        <span class="hljs-comment">#stage 5</span><br>        hx5 = self.stage5(hx)<br>        hx = self.pool56(hx5)<br>        <span class="hljs-comment">#stage 6</span><br>        hx6 = self.stage6(hx)<br>        hx6up = _upsample_like(hx6,hx5)<br>        <span class="hljs-comment">#-------------------- decoder --------------------</span><br>        hx5d = self.stage5d(torch.cat((hx6up,hx5),<span class="hljs-number">1</span>))<br>        <span class="hljs-comment">#这里类似FPN。每个block的输出结果和上一个（下一个block）结果做融合（cat），然后输出。</span><br>        hx5dup = _upsample_like(hx5d,hx4)<br>        <span class="hljs-comment">#由于每个block做了下采样，为了resize到原图，需要做一个上采样，这里作者直接用的双线性插值做的上采样</span><br>        hx4d = self.stage4d(torch.cat((hx5dup,hx4),<span class="hljs-number">1</span>))<br>        hx4dup = _upsample_like(hx4d,hx3)<br>        hx3d = self.stage3d(torch.cat((hx4dup,hx3),<span class="hljs-number">1</span>))<br>        hx3dup = _upsample_like(hx3d,hx2)<br>        hx2d = self.stage2d(torch.cat((hx3dup,hx2),<span class="hljs-number">1</span>))<br>        hx2dup = _upsample_like(hx2d,hx1)<br>        hx1d = self.stage1d(torch.cat((hx2dup,hx1),<span class="hljs-number">1</span>))<br><br><br>        <span class="hljs-comment">#side output</span><br>        d1 = self.side1(hx1d)<br><span class="hljs-comment">#这里本质就是把每一个block输出结果，转换成WxHx1的mask最后过一个sigmod就可以得到每个block输出的概率图。</span><br>        d2 = self.side2(hx2d)<br>        d2 = _upsample_like(d2,d1)<br><br>        d3 = self.side3(hx3d)<br>        d3 = _upsample_like(d3,d1)<br><br>        d4 = self.side4(hx4d)<br>        d4 = _upsample_like(d4,d1)<br><br>        d5 = self.side5(hx5d)<br>        d5 = _upsample_like(d5,d1)<br><br>        d6 = self.side6(hx6)<br>        d6 = _upsample_like(d6,d1)<br><br>        d0 = self.outconv(torch.cat((d1,d2,d3,d4,d5,d6),<span class="hljs-number">1</span>))<br><span class="hljs-comment">#6个blovk cat一起之后做特征融合，然后再做输出，结果就是d0的结果，其他的输出都是为了计算loss</span><br>        <span class="hljs-keyword">return</span> F.sigmoid(d0), F.sigmoid(d1), F.sigmoid(d2), F.sigmoid(d3), F.sigmoid(d4), F.sigmoid(d5), F.sigmoid(d6)<br><br></code></pre></td></tr></table></figure><p>具体的对于每个RSU来说</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RSU7</span>(nn.Module):<span class="hljs-comment">#UNet07DRES(nn.Module):</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_ch=<span class="hljs-number">3</span>, mid_ch=<span class="hljs-number">12</span>, out_ch=<span class="hljs-number">3</span></span>):<br>        <span class="hljs-built_in">super</span>(RSU7,self).__init__()<br><br>        self.rebnconvin = REBNCONV(in_ch,out_ch,dirate=<span class="hljs-number">1</span>)<br><br>        self.rebnconv1 = REBNCONV(out_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool1 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv2 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool2 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv3 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool3 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv4 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool4 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv5 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.pool5 = nn.MaxPool2d(<span class="hljs-number">2</span>,stride=<span class="hljs-number">2</span>,ceil_mode=<span class="hljs-literal">True</span>)<br><br>        self.rebnconv6 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">1</span>)<br><br>        self.rebnconv7 = REBNCONV(mid_ch,mid_ch,dirate=<span class="hljs-number">2</span>)<br><br>        self.rebnconv6d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv5d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv4d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv3d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv2d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,mid_ch,dirate=<span class="hljs-number">1</span>)<br>        self.rebnconv1d = REBNCONV(mid_ch*<span class="hljs-number">2</span>,out_ch,dirate=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,x</span>):<br><br>        hx = x<br>        hxin = self.rebnconvin(hx)<br><br>        hx1 = self.rebnconv1(hxin)<br>        hx = self.pool1(hx1)<br><br>        hx2 = self.rebnconv2(hx)<br>        hx = self.pool2(hx2)<br><br>        hx3 = self.rebnconv3(hx)<br>        hx = self.pool3(hx3)<br><br>        hx4 = self.rebnconv4(hx)<br>        hx = self.pool4(hx4)<br><br>        hx5 = self.rebnconv5(hx)<br>        hx = self.pool5(hx5)<br><br>        hx6 = self.rebnconv6(hx)<br><br>        hx7 = self.rebnconv7(hx6)<br><br>        hx6d =  self.rebnconv6d(torch.cat((hx7,hx6),<span class="hljs-number">1</span>))<br>        hx6dup = _upsample_like(hx6d,hx5)<br><span class="hljs-comment">#双线性差值做的上采样</span><br>        hx5d =  self.rebnconv5d(torch.cat((hx6dup,hx5),<span class="hljs-number">1</span>))<br>        hx5dup = _upsample_like(hx5d,hx4)<br><br>        hx4d = self.rebnconv4d(torch.cat((hx5dup,hx4),<span class="hljs-number">1</span>))<br>        hx4dup = _upsample_like(hx4d,hx3)<br><br>        hx3d = self.rebnconv3d(torch.cat((hx4dup,hx3),<span class="hljs-number">1</span>))<br>        hx3dup = _upsample_like(hx3d,hx2)<br><br>        hx2d = self.rebnconv2d(torch.cat((hx3dup,hx2),<span class="hljs-number">1</span>))<br>        hx2dup = _upsample_like(hx2d,hx1)<br><br>        hx1d = self.rebnconv1d(torch.cat((hx2dup,hx1),<span class="hljs-number">1</span>))<br><br>        <span class="hljs-keyword">return</span> hx1d + hxin<br></code></pre></td></tr></table></figure><p>对应结构图本质其实是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-17-55-20221204%2022:02:46.png" alt="Snipaste_2022-12-04_20-17-55"></p><p>RSU和ResNet的残差结构其实非常的相似。只不过将权重层换成了Unet而已。</p><p>最后我们来看下loss：</p><p>由于作者把U2net分成了多个block，每个block输出一个loss，那么最后整个模型的loss本质其实就是7个loss相加（6个block输出结果加1个特征融合后的结果）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">muti_bce_loss_fusion</span>(<span class="hljs-params">d0, d1, d2, d3, d4, d5, d6, labels_v</span>):<br><br>loss0 = bce_loss(d0,labels_v)<br>loss1 = bce_loss(d1,labels_v)<br>loss2 = bce_loss(d2,labels_v)<br>loss3 = bce_loss(d3,labels_v)<br>loss4 = bce_loss(d4,labels_v)<br>loss5 = bce_loss(d5,labels_v)<br>loss6 = bce_loss(d6,labels_v)<br><br>loss = loss0 + loss1 + loss2 + loss3 + loss4 + loss5 + loss6<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l0: %3f, l1: %3f, l2: %3f, l3: %3f, l4: %3f, l5: %3f, l6: %3f\n&quot;</span>%(loss0.data[<span class="hljs-number">0</span>],loss1.data[<span class="hljs-number">0</span>],loss2.data[<span class="hljs-number">0</span>],loss3.data[<span class="hljs-number">0</span>],loss4.data[<span class="hljs-number">0</span>],loss5.data[<span class="hljs-number">0</span>],loss6.data[<span class="hljs-number">0</span>]))<br><br><span class="hljs-keyword">return</span> loss0, loss<br><br><span class="hljs-comment">#每个mask计算二值交叉熵最后相加</span><br>d0, d1, d2, d3, d4, d5, d6 = net(inputs_v)<br>        loss2, loss = muti_bce_loss_fusion(d0, d1, d2, d3, d4, d5, d6, labels_v)<br><br>        loss.backward()<br>        optimizer.step()<br></code></pre></td></tr></table></figure><p>可以说整个代码清晰简单好懂。但是效果确实好，我觉得好的分割检测模型就该这样，大道至简。</p><p>分割结果如下图所示，在我的实际使用中发现，如果只是前背景分割不涉及语义分割，在几个项目中有极为优秀的表现，即使背景很复杂，同时实时性非常优秀（p100前向能做到18ms）。</p><h4 id="deeplab"><a href="#deeplab" class="headerlink" title="deeplab"></a>deeplab</h4><p>DeepLab系列一共有四篇文章，分别对应DeepLab V1、DeepLab V2、DeepLab V3和DeepLab V3+。</p><p><strong>DeepLab V1</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1606.00915">Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFs</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/TheLegendAli/DeepLab-Context">TheLegendAli&#x2F;DeepLab-Context</a></p><p><strong>DeepLab V2</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1606.00915">DeepLab: Semantic Image Segmentation with Deep Convolutional Nets, Atrous Convolution, and Fully Connected CRFs</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/DrSleep/tensorflow-deeplab-resnet">DrSleep&#x2F;tensorflow-deeplab-resnet</a></p><p><strong>DeepLab V3</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1706.05587">Rethinking Atrous Convolution for Semantic Image Segmentation</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/eveningdong/DeepLabV3-Tensorflow">leonndong&#x2F;DeepLabV3-Tensorflow</a></p><p><strong>DeepLab V3+</strong></p><p>论文题目：<a href="https://link.juejin.cn/?target=https://arxiv.org/abs/1802.02611">Encoder-Decoder with Atrous Separable Convolution for Semantic Image Segmentation</a></p><p>开源代码：<a href="https://link.juejin.cn/?target=https://github.com/jfzhang95/pytorch-deeplab-xception">jfzhang95&#x2F;pytorch-deeplab-xception</a></p><p>图像分割CNN是根据classification这种high-level semantics改编的，但CNN做语义分割时精准度不够，根本原因是 DCNNs 的高级特征的平移不变性，即高层次特征映射，根源于重复的池化和下采样会丢失localization信息，即无法对像素点精确定位语义（low-level semantics）。</p><p>针对下采样或池化降低分辨率，DeepLab采用了空洞卷积代替池化操作来扩展感受野，获取更多的上下文信息。同时DeepLab v1v2 结合了深度卷积神经网络（DCNNs）和概率图模型（DenseCRFs）的方法。DeepLab v2提出了串行的ASPP模块，ASPP增强了网络在多尺度下多类别分割时的鲁棒性， 使用不同的采样比例与感受野提取输入特征，能在多个尺度上捕获目标与上下文信息，虽然大大扩展了卷积核的感受野，但<strong>随着感受野越来越接近图像大小，会退化为1x1卷积。</strong></p><p>为了解决这个问题，<strong>DeepLab v3改进了ASPP空洞卷积空间金字塔池化层，不同的dilation卷积并行操作，然后归一尺寸后求和</strong>。ASPP模块借鉴PSPNet思想，通过不同采样率的空洞卷积并行采样，捕捉图像不同尺度的上下文信息。</p><p>DeepLab v3+通过添加一个简单而有效的解码器模块扩展DeepLab v3以优化分割结果，在PASCAL VOC 2012数据集和Cityscapes数据集中分别取得了89%和82.1%的MIOU。</p><p><strong>语义分割面临的主要挑战</strong></p><p><strong>分辨率</strong> 连续的池化或下采样操作会导致图像的分辨率大幅度下降，从而损失了原始信息， 且在上采样过程中难以恢复。因此，越来越多的网络都在试图减少分辨率的损失， 比如使用空洞卷积，或者用步长为2的卷积操作代替池化。</p><p><strong>多尺度特征</strong> 同一张图片中不同大小物体的分割精度不同，因为不同尺度卷积核对不同大小物体的分割效果不同。在分辨率较小的情况下，小物体的位置信息经常被丢失，通过设置不同参数的卷积层或池化层， 提取到不同尺度的特征图。将这些特征图送入网络做融合，对于整个网络性能的提升很大。但是由于图像金字塔的多尺度输入，造成计算时保存了大量的梯度，从而导致对硬件的要求很高。</p><h5 id="deeplab-v1"><a href="#deeplab-v1" class="headerlink" title="deeplab v1"></a>deeplab v1</h5><p>DeepLab v1是结合了深度卷积神经网络（DCNNs）和概率图模型（DenseCRFs）的方法</p><p>深度卷积神经网络（DCNNs）采用FCN思想，修改VGG16网络，得到 coarse score map并插值到原图像大小，使用Atrous convolution得到更dense且感受野不变的feature map</p><p>概率图模型（DenseCRFs）借用fully connected CRF对从DCNNs得到的分割结果进行细节上的refine。</p><p>DeepLab v1：VGG16+空洞卷积+CRF对边缘分割结果进行后处理。针对下采样或池化降低分辨率，DeepLab采用了空洞卷积来扩展感受野，获取更多的上下文信息。同时，采用完全连接的条件随机场（CRF）提高模型捕获细节的能力。</p><p><strong>网络结构</strong></p><p>把全连接层（fc6、fc7、fc8）改成卷积层（端到端训练） 2.把最后两个池化层（pool4、pool5）的步长2改成1（保证feature的分辨率下降到原图的1&#x2F;8）。 3.把最后三个卷积层（conv5_1、conv5_2、conv5_3）的dilate rate设置为2，且第一个全连接层的dilate rate设置为4（保持感受野）。 4.把最后一个全连接层fc8的通道数从1000改为21（分类数为21）。 5.第一个全连接层fc6， 通道数从4096变为1024， 卷积核大小从7x7变为3x3，后续实验中发现此处的dilate rate为12时（LargeFOV），效果最好。</p><p>网络变形： DeepLab-MSc：类似FCN，加入特征融合 DeepLab-7×7：替换全连接的卷积核大小为7× 7 DeepLab-4×4：替换全连接的卷积核大小为4× 4 DeepLab-LargeFOV：替换全连接的卷积核大小为3×3，空洞率为12</p><p>损失函数：交叉熵 + softmax 优化器：SGD + momentum 0.9 batchsize：20 学习率：10^−3（每经过2000个epoch，学习率 * 0.1）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-29-10-20221204%2022:02:59.png" alt="Snipaste_2022-12-04_20-29-10"></p><h5 id="deeplab-v2"><a href="#deeplab-v2" class="headerlink" title="deeplab v2"></a>deeplab v2</h5><p>VGG16&#x2F;ResNet+串行的ASPP模块+CRF对边缘分割结果进行后处理。添加了ASPP空洞卷积空间金字塔池化层，通过不同的dilation卷积串行操作，来取代导致浅层特征损失的池化操作，大大扩大了感受野。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-29-29-20221204%2022:03:13.png" alt="Snipaste_2022-12-04_20-29-29"></p><p>空洞卷积：稠密映射，标准3×3卷积（rate为1），感受野为3；空洞卷积（rate为2），卷积核尺寸为5x5，感受野为7；空洞卷积（rate为4），卷积核尺寸为9x9，感受野为15。</p><p><strong>Network&amp;ASPP</strong></p><p>ASPP模块构成——&gt;DeepLab v1到DeepLab v2的进化——&gt;基于VGG16的DeepLab v2在v1的基础上做了进一步调整（FC6-FC8替换为ASPP）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-32-20-20221204%2022:03:22.png" alt="Snipaste_2022-12-04_20-32-20"></p><p><strong>实验设置</strong></p><p>损失函数：交叉熵 + softmax 优化器：SGD + momentum 0.9 Batchsize：20 学习率策略：step：10^−3（每经过2000个epoch，学习率 * 0.1）</p><p>网络变形： LargeFOV：3×3卷积 + rate&#x3D;12(DeepLab v1最好结果) ASPP-S：r &#x3D; 2, 4, 8, 12 ASPP-L：r &#x3D; 6, 12, 18, 24</p><h5 id="deeplab-v3"><a href="#deeplab-v3" class="headerlink" title="deeplab v3"></a>deeplab v3</h5><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-32-58-20221204%2022:03:54.png" alt="Snipaste_2022-12-04_20-32-58"></p><p>Deeplab v3：ResNet+改进后的并行ASPP模块。随着采样率的增大，有效滤波器权重的数量（应用于有效特征的权重而不是padding补充的0）变少，在空洞率接近特征映射大小的极端情况下，3×3滤波器不是捕获整个图像上下文，而是退化为简单的1×1卷积（只有中心滤波器权重是有效的）。因此，v3使用了并行ASPP模块，最后一个分支拼接全局池化模块来捕获全局上下文信息。</p><p><strong>语义分割常用特征提取框架</strong></p><ol><li>图像金字塔：从输入图像入手，将不同尺度的图像分别送入网络进行特征提取，后期再融合。</li><li>编解码结构：编码器部分利用下采样进行特征提取，解码器部分利用上采样还原特征图尺寸。 </li><li>深度网络vs空洞卷积：经典分类算法利用连续下采样提取特征，而空洞卷积是利用不同的采样率。 </li><li>空间金字塔结构：除ASPP外，仍有其他网络使用了该思想，如SPPNet、PSPNet等。</li></ol><p><strong>网络结构</strong></p><p>经典分类算法网络架构，如ResNet ——&gt; DeepLab v3空洞卷积串行网络结构 ——&gt; DeepLab v3空洞卷积并行网络结构（调整了ASPP模块）</p><p><strong>实验设置</strong></p><p>裁剪尺寸：裁剪图片至513x513（为了更好的拟合空洞率） 学习率策略：采用poly策略，原理同v2</p><p>BN层策略：当output_stride&#x3D;16时，batchsize&#x3D;16，同时BN层做参数衰减decay&#x3D;0.9997。在增强的数据集上，以初始学习率0.007训练30K后，冻结BN层参数。当output_stride&#x3D;8时，batchsize&#x3D;8，使用初始学习率0.001训练30K。</p><h5 id="deeplab-v3-1"><a href="#deeplab-v3-1" class="headerlink" title="deeplab v3+"></a>deeplab v3+</h5><p>DeepLabv3+的核心是通过添加一个简单而有效的解码器模块来恢复对象边界（沿着对象边界来细化分割结果），扩展了DeepLab v3。以Xcepition&#x2F;ResNet为骨架，采用深度可分离卷积进行编码，在多尺度特征提取ASPP模块后再接一个简单的解码器模块。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-35-03-20221204%2022:04:02.png" alt="Snipaste_2022-12-04_20-35-03"></p><p><strong>补充知识：深度可分离卷积</strong></p><p>标准卷积：标准输入图片尺寸为12×12×3，用1个5×5×3的卷积核进行卷积操作，会得到8×8×1的输出； 用256个5×5×3的卷积核进行卷积操作，会得到8×8×256的输出。 参数计算：256×5×5×3 &#x3D; 19200</p><p>分组卷积：组卷积是对输入特征图进行分组，每组分别进行卷积。 假设输入特征图的尺寸为C<em>H</em>W (12× 5×5)，输出特征图的数量为N (6)个，如果设定要分成G (3)个groups，则每组的输入特征图数量为C&#x2F;G (4)，每 组 的 输出特征图数量为N&#x2F;G (2)，每个卷积核的尺寸为(C&#x2F;G)<em>K</em>K (4×5×5)，卷积核的总数仍为N (6)个，每组的卷积核数量为N&#x2F;G (2)，每个卷积核只与其同组的输入特征图进行卷积，卷积核的总参数量为N*(C&#x2F;G)<em>K</em>K，可见，总参数量减少为原来的1&#x2F;G。</p><p>深度可分离卷积是组卷积的一种极端情况，也就是输入有多少个通道，对应的分组就有多少个组，即分组的组数&#x3D;输入特征图的通道数。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-36-24-20221204%2022:04:14.png" alt="Snipaste_2022-12-04_20-36-24"></p><p>深度可分离卷积 &#x3D; 深度卷积 + 逐点卷积</p><p>深度卷积：每个5×5×1的卷积核对应输入图像中的一个通道，得到三个8×8×1的输出， 拼接后得到8×8×3的结果</p><p>逐点卷积：设置256个1×1×3的卷积核，对深度卷积的输出再进行卷积操作，最终得到 8×8×256的输出</p><p>参数计算：*深度卷积参数 &#x3D; 5×5×3 &#x3D; 75 逐点卷积参数 &#x3D; 256×1×1×3 &#x3D; 768 总参数 &#x3D; 75 + 768 &#x3D; 843 &lt;&lt; 19200</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-37-18-20221204%2022:04:24.png" alt="Snipaste_2022-12-04_20-37-18"></p><p>网络结构</p><p>编码器：</p><ol><li>使用DeepLab v3作为编码器结构，输出与输入尺寸之比16(output_stride &#x3D; 16)。</li><li>ASPP：一个1×1卷积 + 三个3×3卷积(rate &#x3D; {6, 12, 18}) + 全局平均池化。</li></ol><p>解码器：</p><ol><li>先把encoder的结果上采样4倍（双线性插值），然后与编码器中相对应尺寸的特征图进行拼接融合，再进行3x3的卷积， 最后上采样4倍得到最终结果</li><li>融合低层次信息前，先进行1x1的卷积， 目的是降低通道数。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-38-00-20221204%2022:04:35.png" alt="Snipaste_2022-12-04_20-38-00"></p><p>DeepLab v3+对Xception进行了微调：</p><ol><li><p>更深的Xception结构，原始middle flow迭代8次，微调后迭代16次。 </p></li><li><p>所有max pooling结构被stride&#x3D;2的深度可分离卷积替代。 </p></li><li><p>每个3x3的depthwise convolution（结合了空洞卷积）后都跟BN和Relu。</p></li></ol><h5 id="deeplab总结"><a href="#deeplab总结" class="headerlink" title="deeplab总结"></a>deeplab总结</h5><p>v1：修改经典分类网络(VGG16)，将空洞卷积应用于模型中，试图解决分辨率过低及提取多尺度特征问题，用CRF做后处理（VGG16+空洞卷积+CRF对边缘分割结果进行后处理）</p><p>v2：设计ASPP模块，将空洞卷积的性能发挥到最大，沿用VGG16作为主网络，尝试使用ResNet-101进行对比实验，用CRF做后处理（VGG16&#x2F;ResNet+串行的ASPP模块+CRF对边缘分割结果进行后处理）</p><p>v3：以ResNet为主网络，设计了一种串行和一种并行的DCNN网络，微调ASPP模块，取消CRF做后处理（ResNet+改进后的并行ASPP模块）</p><p>v3+：以ResNet或Xception为主网络，结合编解码结构设计了一种新的算法模型，以v3作为编码器结构，另行设计了解码器结构，取消CRF做后处理（ResNet&#x2F;Xception+并行的ASPP模块+编码器结构）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-39-38-20221204%2022:04:44.png" alt="Snipaste_2022-12-04_20-39-38"></p><h4 id="maskrcnn"><a href="#maskrcnn" class="headerlink" title="maskrcnn"></a>maskrcnn</h4><h3 id="6-行为识别：对于视频序列"><a href="#6-行为识别：对于视频序列" class="headerlink" title="6. 行为识别：对于视频序列"></a>6. 行为识别：对于视频序列</h3><h4 id="slowfast"><a href="#slowfast" class="headerlink" title="slowfast"></a>slowfast</h4><p>SlowFast是Facebook在2019年ICCV的一篇视频识别论文，受到灵长类动物的视网膜神经细胞种类的启发（大约80%的细胞（P-cells）以低频运作，可以识别细节信息；而大约20%的细胞（M-cells）则以高频运作，对时间的变化敏感）。作者<strong>提出了一种新的快慢网络SlowFast架构，来实现两个分支分别对时间与空间维度进行处理分析</strong>。在Kinetics-400动作识别benchmark与AVA动作检测benchmark中得到了state-of-art的结果。</p><p>SlowFast算法整体由两个卷积分支组成：</p><ul><li><strong>Slow分支</strong>：较少的帧数以及较大的通道数学习空间语义信息。</li><li><strong>Fast分支</strong>：较大的帧数以及较少的通道数学习运动信息</li></ul><p>计算量与通道数的平方成正比，Fast分支由于通道数较少，其比较轻量化，仅仅占用整体20%的计算量。</p><p>Slow分支使用一个较大的步长τ来采集视频帧，通常设置τ为16，如果针对帧率为30的视频，这意味着大约1秒可以采集2帧，即T&#x3D;2。slow分支通道数为D，</p><p>Fast分支使用一个较小的步长来采集视频帧，步长为τ&#x2F;α，其中α通常设置为8，因此针对帧率为30的视频，1秒可以采集15帧（αT）。<strong>Fast分支通过使用较小的通道数（β D）来保持轻量化，β通常设置为的⅛</strong>。</p><p>Slow通道和Fast通道都使用3D卷积的RestNet模型。在每个分支的末端，SlowFast执行全局平均池化，然后concat两个通道的特征进行类别预测。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-44-41-20221204%2022:05:02.png" alt="Snipaste_2022-12-04_20-44-41"></p><p>上图是一个SlowFast网络结构。卷积核的尺寸记作{T×S², C} ，其中T、S和C分别表示时序temporal, 空间spatial和频道Channel的数目。stride记作{temporal stride, spatial stride ^ 2}。 α &#x3D; 8 ，β &#x3D; 1&#x2F;8。τ &#x3D; 16。绿色表示高一些的时序分辨率，Fast通道中的橙色表示较少的通道。</p><p><strong>侧向连接</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-47-29-20221204%2022:05:12.png" alt="Snipaste_2022-12-04_20-47-29"></p><p>Slow与Fast分支提取的特征需要进行融合，如上图，SlowFast采用的是将Fast分支的特征通过侧向连接（Lateral connections）送入Slow分支进行混合。但是两个分支的特征维度是不一致的（Fast分支是{αT, S², βC} 而Slow分支是 {T, S², αβC}），因此SlowFast需要对Fast分支的结果进行数据变换。</p><p>论文给出了三种进行数据变换的技术思路，其中第三个思路在实践中最有效。</p><ol><li>Time-to-channel：将{αT, S², βC} 的特征变形为 {T , S², αβC}之后就行融合，就是说把α帧压入一帧</li><li>Time-strided采样：简单地每隔α帧进行采样，{αT , S², βC} 就变换为 {T , S², βC}</li><li>Time-strided卷积: 用一个5×1×1的3d卷积， 输出通道为2βC，步长为 α.</li></ol><p>这三种方案的实验结果如下图所示，Time-Strided卷积的效果最好。</p><p>此外作者还尝试了双向侧链接，即将Slow分支结果也送入Fast分支，但是对性能没有改善。</p><h4 id="3d卷积"><a href="#3d卷积" class="headerlink" title="3d卷积"></a>3d卷积</h4><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_20-58-44-20221204%2022:05:26.png" alt="Snipaste_2022-12-04_20-58-44"></p><p>a)和b)分别为2D卷积用于单通道图像和多通道图像的情况（多通道图像可以指同一张图片的3个颜色通道，也可以指多张堆叠在一起的图片）。对于每一个滤波器（卷积核），输出一张二维的特征图，多通道的信息被完全压缩了。输出的通道数由滤波器个数决定，有几个滤波器，输出就有几个通道。</p><p>而c)中3D卷积的输出仍然为3D的特征图。</p><p>现在考虑一个视频段输入，其大小为 c∗l∗h∗w ，其中c为图像通道(一般为3)，l为视频序列的长度，h和w分别为视频的宽与高。进行一次kernel_size为3∗3∗3，stride为1，padding&#x3D;‘same’，n_filters&#x3D;K的3D 卷积后，输出的大小为K∗l∗h∗w。池化同理。</p><p><strong>卷积核的维度</strong></p><p>卷积核的维度指的的进行滑窗操作的维度，而滑窗操作不在channel维度上进行，不管有几个channel，它们都共享同一个滑窗位置（虽然2D多channel卷积的时候每个channel上的卷积核权重是独立的，但滑窗位置是共享的）。所以在讨论卷积核维度的时候，是不把channel维加进去的。</p><p>2D conv的卷积核就是(c, k_h, k_w)，因此，对于RGB图像做2D卷积，卷积核可以是conv2D(3,3) 而不该是conv3D(3,3,3)</p><p>3D conv的卷积核就是(c, k_d, k_h, k_w)，其中k_d就是多出来的第三维，根据具体应用，在视频中就是时间维，在CT图像中就是层数维</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-03-07-20221204%2022:05:35.png" alt="Snipaste_2022-12-04_21-03-07"></p><p>针对单通道，与2D卷积不同之处在于，输入图像多了一个 depth 维度，故输入大小为(1, depth, height, width)，卷积核也多了一个k_d维度，因此卷积核在输入3D图像的空间维度（height,width和depth维度）上均进行滑窗操作，每次滑窗与 (k_d, k_h, k_w) 窗口内的values进行相关操作，得到输出3D图像中的一个value，最终输出一个3D的特征图。</p><p>这里的3D不是通道导致的，而是深度（多层切片，多帧视频），因此，虽然输入和卷积核和输出都是3D的，但都可以是单通道的。</p><p>针对多通道，输入大小为(3, depth, height, width)，与2D多通道卷积的操作类似，对于每次滑窗，卷积核同时与3个channels上的 (k_d, k_h, k_w) 窗口内的所有values进行相关操作，得到输出3D图像中的一个value。</p><p>由于3D卷积中的卷积核是3D的，因此在每个channel下使用的是同样的参数，权重共享。不同于2D多通道下的卷积核，后者在每一个channel使用的权重是一样的，不同的通道权重可能不一样。</p><h4 id="实践：视频异常检测"><a href="#实践：视频异常检测" class="headerlink" title="实践：视频异常检测"></a>实践：视频异常检测</h4><h3 id="7-transformer"><a href="#7-transformer" class="headerlink" title="7. transformer"></a>7. transformer</h3><h4 id="在视觉的应用vit"><a href="#在视觉的应用vit" class="headerlink" title="在视觉的应用vit"></a>在视觉的应用vit</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>重点介绍ViT原理，同时简单介绍三篇相关论文，这四篇论文的源码见 <a href="https://link.zhihu.com/?target=https://github.com/google-research/vision_transformer">https://github.com/google-research/vision_transformer</a></p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2010.11929">arXiv:2010.11929</a>：An image is worth 16x16 words: Transformers for image recognition at scale（ViT大法，一般人没钱做的工作）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2105.01601">arXiv:2105.01601</a>：MLP-Mixer: An all-MLP Architecture for Vision （用MLPs替代self-attention可以得到和ViT同样好的结果）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.01548">arXiv:2106.01548</a>：When Vision Transformers Outperform ResNets without Pre-training or Strong Data Augmentations （不使用大规模预训练和强数据增强ViT是否依然可以表现优秀）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.10270">arXiv:2106.10270</a>：How to train your ViT? Data, Augmentation, and Regularization in Vision Transformers （通过大量实验，总共训练了超过5w个ViT，教你如何训练自己的ViT模型，以及数据增广和模型正则化什么时候有用）</p><p>有关transformer结构和原理，大家可以参考：<a href="https://zhuanlan.zhihu.com/p/410258597">Transformer解析</a></p><p>本文重点介绍ViT原理，同时简单介绍三篇相关论文，这四篇论文的源码见 <a href="https://link.zhihu.com/?target=https://github.com/google-research/vision_transformer">https://github.com/google-research/vision_transformer</a></p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2010.11929">arXiv:2010.11929</a>：An image is worth 16x16 words: Transformers for image recognition at scale（ViT大法，一般人没钱做的工作）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2105.01601">arXiv:2105.01601</a>：MLP-Mixer: An all-MLP Architecture for Vision （用MLPs替代self-attention可以得到和ViT同样好的结果）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.01548">arXiv:2106.01548</a>：When Vision Transformers Outperform ResNets without Pre-training or Strong Data Augmentations （不使用大规模预训练和强数据增强ViT是否依然可以表现优秀）</p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2106.10270">arXiv:2106.10270</a>：How to train your ViT? Data, Augmentation, and Regularization in Vision Transformers （通过大量实验，总共训练了超过5w个ViT，教你如何训练自己的ViT模型，以及数据增广和模型正则化什么时候有用）</p><p>有关transformer结构和原理，大家可以参考：<a href="https://zhuanlan.zhihu.com/p/410258597">Transformer解析</a></p><h5 id="vit"><a href="#vit" class="headerlink" title="vit"></a>vit</h5><p>ViT是2020年Google团队提出的将Transformer应用在图像分类的模型，虽然不是第一篇将transformer应用在视觉任务的论文，但是因为其模型“简单”且效果好，可扩展性强（scalable，模型越大效果越好），成为了transformer在CV领域应用的里程碑著作，也引爆了后续相关研究</p><p>把最重要的说在最前面，ViT原论文中最核心的结论是，当拥有足够多的数据进行预训练的时候，ViT的表现就会超过CNN，突破transformer缺少归纳偏置的限制，可以在下游任务中获得较好的迁移效果</p><p>但是当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，因为Transformer和CNN相比缺少归纳偏置（inductive bias），即一种先验知识，提前做好的假设。CNN具有两种归纳偏置，一种是局部性（locality&#x2F;two-dimensional neighborhood structure），即图片上相邻的区域具有相似的特征；一种是平移不变形（translation equivariance）， f(g(x))&#x3D;g(f(x)) ，其中g代表卷积操作，f代表平移操作。当CNN具有以上两种归纳偏置，就有了很多先验信息，需要相对少的数据就可以学习一个比较好的模型</p><p>ViT将输入图片分为多个patch（16x16），再将每个patch投影为固定长度的向量送入Transformer，后续encoder的操作和原始Transformer中完全相同。但是因为对图片分类，因此在输入序列中加入一个特殊的token，该token对应的输出即为最后的类别预测</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-11-40-20221204%2022:05:53.png" alt="Snipaste_2022-12-04_21-11-40"></p><p>按照上面的流程图，一个ViT block可以分为以下几个步骤</p><p>(1) patch embedding：例如输入图片大小为224x224，将图片分为固定大小的patch，patch大小为16x16，则每张图像会生成224x224&#x2F;16x16&#x3D;196个patch，即输入序列长度为<strong>196</strong>，每个patch维度16x16x3&#x3D;<strong>768</strong>，线性投射层的维度为768xN (N&#x3D;768)，因此输入通过线性投射层之后的维度依然为196x768，即一共有196个token，每个token的维度是768。这里还需要加上一个特殊字符cls，因此最终的维度是<strong>197x768</strong>。到目前为止，已经通过patch embedding将一个视觉问题转化为了一个seq2seq问题</p><p>(2) positional encoding（standard learnable 1D position embeddings）：ViT同样需要加入位置编码，位置编码可以理解为一张表，表一共有N行，N的大小和输入序列长度相同，每一行代表一个向量，向量的维度和输入序列embedding的维度相同（768）。注意位置编码的操作是sum，而不是concat。加入位置编码信息之后，维度依然是<strong>197x768</strong></p><p>(3) LN&#x2F;multi-head attention&#x2F;LN：LN输出维度依然是197x768。多头自注意力时，先将输入映射到q，k，v，如果只有一个头，qkv的维度都是197x768，如果有12个头（768&#x2F;12&#x3D;64），则qkv的维度是197x64，一共有12组qkv，最后再将12组qkv的输出拼接起来，输出维度是197x768，然后在过一层LN，维度依然是<strong>197x768</strong></p><p>(4) MLP：将维度放大再缩小回去，197x768放大为197x3072，再缩小变为<strong>197x768</strong></p><p>一个block之后维度依然和输入相同，都是197x768，因此可以堆叠多个block。最后会将特殊字符cls对应的输出 zL0 作为encoder的最终输出 ，代表最终的image presentation（另一种做法是不加cls字符，对所有的tokens的输出做一个平均），后面接一个MLP进行图片分类</p><p>关于image presentation</p><p>是否可以直接使用average pooling得到最终的image presentation，而不加特殊字符cls，通过实验表明，同样可以使用average pooling，原文ViT是为了尽可能是模型结构接近原始的Transformer，所以采用了类似于BERT的做法，加入特殊字符</p><p>关于positional encoding</p><p>1-D 位置编码：例如3x3共9个patch，patch编码为1到9</p><p>2-D 位置编码：patch编码为11,12,13,21,22,23,31,32,33，即同时考虑X和Y轴的信息，每个轴的编码维度是D&#x2F;2</p><p>实际实验结果表明，不管使用哪种位置编码方式，模型的精度都很接近，甚至不适用位置编码，模型的性能损失也没有特别大。原因可能是ViT是作用在image patch上的，而不是image pixel，对网络来说这些patch之间的相对位置信息很容易理解，所以使用什么方式的位置编码影像都不大</p><p>关于CNN+Transformer</p><p>既然CNN具有归纳偏置的特性，Transformer又具有很强全局归纳建模能力，使用CNN+Transformer的混合模型是不是可以得到更好的效果呢？将224x224图片送入CNN得到16x16的特征图，拉成一个向量，长度为196，后续操作和ViT相同</p><p>关于输入图片大小</p><p>通常在一个很大的数据集上预训练ViT，然后在下游任务相对小的数据集上微调，已有研究表明在分辨率更高的图片上微调比在在分辨率更低的图片上预训练效果更好（It is often beneficial to fine-tune at higher resolution than pre-training）（参考<em>2019-NIPS-Fixing the train test resolution discrepancy</em>）</p><p>当输入图片分辨率发生变化，输入序列的长度也发生变化，虽然ViT可以处理任意长度的序列，但是预训练好的位置编码无法再使用（例如原来是3x3，一种9个patch，每个patch的位置编码都是有明确意义的，如果patch数量变多，位置信息就会发生变化），一种做法是使用插值算法，扩大位置编码表。但是如果序列长度变化过大，插值操作会损失模型性能，这是ViT在微调时的一种局限性</p><p>当在很大的数据集上预训练时，ViT性能超越CNN。</p><h5 id="MLPs"><a href="#MLPs" class="headerlink" title="MLPs"></a>MLPs</h5><p>ViT作者团队出品，在CNN和Transformer大火的背景下，舍弃了卷积和注意力机制，提出了MLP-Mixer，一个完全基于MLPs的结构，其MLPs有两种类型，分别是<strong>channel-mixing MLPs</strong>和<strong>token-mixing MLPs</strong>，前者独立作用于image patches（融合通道信息），后者跨image patches作用（融合空间信息）。实验结果表明该结构和SOTA方法同样出色，证明了convolution和attention不是必要操作，如果将其替换为简单的MLP，模型依然可以完美work</p><p>mixer结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-18-33-20221204%2022:06:06.png" alt="Snipaste_2022-12-04_21-18-33"></p><p>类似于ViT，首先进行patch embedding操作，一个Mixer Layer中包含了channel-mixing MLPs和token-mixing MLPs，但是Mixer不适用positional encoding，因为token-mixing MLPs对输入tokens的顺序非常敏感</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-23-06-20221204%2022:06:17.png" alt="Snipaste_2022-12-04_21-23-06"></p><p>token-mixing MLPs：允许信息在空间维度交互，独立作用于每一个channel，作用于列，融合不同token的特征</p><p>channel-mixing MLPs：允许信息在通道交互，独立作用于每一个token，作用于行，融合不同channel的特征</p><p>输入image的分辨率为 H×W ，patch的分辨率为 P×P，则patch的数量 S&#x3D;HW&#x2F;P2 ，所有的patch拉直后线性投影到维度 C ，则得到Mixer Layer的输入 X∈RS×C 。token-mixing MLPs作用于 X 的列，特征维度不发生变化（ RS→RS ），channel-mixing MLPs作用于 X 的行，特征维度同样不发生变化（ RC→RC ）。每一个MLP包含两个全连接层和一个非线性激活（GELU），一个Mixer layers的公式如下，计算复杂度和输入patches的数量成线性关系（ViT是平方关系）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-24-02-20221204%2022:06:25.png" alt="Snipaste_2022-12-04_21-24-02"></p><p>需要注意token-mixing MLPs共享参数，channel-mixing MLPs同样共享参数，因此避免了当输入特征维度增加（ C 变大）或者输入序列长度增加（ S 变大）时，模型参数量急剧增加的情况，极大减少了内存消耗</p><p>模型最后接global average pooling+a linear classifier</p><p><strong>实验结果</strong></p><p>当在大规模数据集上预训练（100million images），Mixer可以接近CNNs和Transformers的SOTA表现，在ImageNet上达到87.94%的top-1 accuracy；当在更小规模数据集上预训练时（10million），结合一些regularization techniques，Mixer可以接近ViT的性能，但是稍逊于CNN</p><h5 id="without-Pre-training-or-Strong-Data-Augmentations"><a href="#without-Pre-training-or-Strong-Data-Augmentations" class="headerlink" title="without Pre-training or Strong Data Augmentations"></a>without Pre-training or Strong Data Augmentations</h5><p>ViTs和MLPs的相关研究目前大多都非常依赖海量数据，在大规模数据集上的预训练以及强数据增广都是基本操作，但是在模型实际优化过程中依然存在诸多困难，比如对初始化和学习率非常敏感。因此作者从损失几何（loss geometry&#x2F;loss landscape geometry）的角度探究ViTs和MLP-Mixers（从损失几何的角度说白了就是用SAM方法对loss做平滑），<strong>旨在让模型摆脱对大规模预训练以及强数据增广的依赖</strong>，提升模型在训练阶段对数据的利用效率，以及推理阶段的泛华能力（intending to improve the models’ data efficiency at training and generalization at inference）</p><p>通过可视化和 Hessian 发现了收敛模型极其尖锐的局部最小值（sharp local minima of the converged models），因此使用最近提出的锐度感知优化器（sharpness-aware optimizer&#x2F;sharpness-aware minimizer，<strong>SAM</strong>）提高平滑度（promote smoothness），得到更加平滑的损失函数（much flatter loss landspace&#x2F; smoothed loss landspace），大大提升了ViTs和MLPs在多个任务上的准确度和鲁棒性，包括监督、对抗、对比、迁移学习等（使用简单的 Inception 式预处理，ViT-B&#x2F;16 和 Mixer-B&#x2F;16 在 ImageNet 上的top-1准确率分别提升了5.3% 和11.0%）</p><p>改进的平滑度归因于前几层中较稀疏的激活神经元（the improved smoothness attributes to sparser active&#x2F;activated neurons in the first few layers）。在没有大规模预训练或强数据增强的情况下，在 ImageNet 上从头开始训练时，所得 ViT 的性能优于类似大小和吞吐量（throughput）的 ResNet。还拥有更敏锐的注意力图（more perceptive attention maps）</p><h5 id="how-to-train-your-vit"><a href="#how-to-train-your-vit" class="headerlink" title="how to train your vit"></a>how to train your vit</h5><p>ViT在很多视觉任务上都展现了相当优秀的性能，但是和CNN相比，缺少归纳偏置让ViT应用于小数据集时非常依赖模型正则化（model regularization）和数据增广（data augmentation）（把模型正则化和数据增广合起来简称AugReg）</p><p>作者使用系统性的实证研究方法（systematic empirical study），探究训练数据量、AugReg、模型大小、计算成本的interpaly（相互影响&#x2F;影响），说白了就是做了大量实验，用实验结果说明问题，总共训练了超过50000个ViT模型，结果发布在了 <a href="https://link.zhihu.com/?target=https://github.com/rwightman/pytorch-image-models">https://github.com/rwightman/pytorch-image-models</a> 和 <a href="https://link.zhihu.com/?target=https://github.com/google-research/vision_">https://github.com/google-research/vision_ transformer</a></p><p>实验表明，当增加计算成本（Improved compute&#x2F;Increased compute budget），即让模型训练更长时间已达到一定的性能，同时使用AugReg会带来意想不到的效果：在ImageNet-21k（14million）上训练的ViT模型，和在JFT-300M上训练的ViT模型相比拥有更好的性能。同时大量实验也揭示了各类techniques的对模型性能的影响，以及什么时候AugReg对模型性能有益&#x2F;什么时候无益</p><p>作者还对ViT迁移学习进行了深入分析。结论是<strong>即使下游数据似乎与预训练数据只有微弱的关联，迁移学习仍然是最佳选择。</strong>作者分析还表明，对于迁移学习来说，训练数据更多的模型和数据增强更多的模型相比较（among similarly performing pre-trained models），前者可能是更好的选择，下游任务性能表现更好。该研究的意义在哪，当我们的计算成本有限时，可以通过本研究的结论选择一种方式，更高效的优化ViT模型</p><h4 id="swintransformer"><a href="#swintransformer" class="headerlink" title="swintransformer"></a>swintransformer</h4><p>“Swin Transformer: Hierarchical Vision Transformer using Shifted Windows” 是MSRA今年三月份上传到arXiv的一篇论文，论文中提出了一种新型的Transformer架构(Swin Transformer)，其利用滑动窗口和分层结构使得Swin Transformer成为了机器视觉领域新的Backbone，在图像分类、目标检测、语义分割等多种机器视觉任务中达到了SOTA水平。</p><p>Paper：<a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2103.14030v1?ref=hackernoon.com">https://arxiv.org/abs/2103.14030v1?ref=hackernoon.comarxiv.org/abs/2103.14030v1?ref=hackernoon.com</a></p><p>Transformer应用在机器视觉领域遇到的问题：</p><ol><li>图片的scale变化非常大，非固定标准</li><li>相较于文本信息，图片有更大的分辨率，Transformer的计算复杂度是token数量的平方(图1,每个token都要与其他token计算QK值)，如果将每个像素值算作一个token，其计算量非常大，不利于在多种机器视觉任务中的应用</li></ol><p>Swin Transformer 解决以上问题的方法</p><ol><li>通过与CNN相似的分层结构来处理图片，使得模型能够灵活处理不同尺度的图片</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-31-45-20221204%2022:06:38.png" alt="Snipaste_2022-12-04_21-31-45"></p><p>其中涉及到窗口self-attention计算，不重叠窗口间的联系，mask的计算，相对位置编码的计算。</p><ol start="2"><li>Swin Transformer 采用的是window self-attention，降低了计算复杂度。</li></ol><p>假设一张图片共有 h∗w 个patches(每个patches是原图4*4像素区域），每个窗口包括 M∗M 个patches，根据图1，</p><p>原始Transformer self-attention计算复杂度 &#x3D; $(hw)^2$</p><p>在Swin Transformer中采用的是window self-attention，其计算复杂度为窗口计算复杂度*窗口数量，窗口数量&#x3D; $h∗w&#x2F;M^2$ ,窗口计算复杂度&#x3D; $(M2)^2$ ，</p><p>Swin Transformer self-attention计算复杂度 &#x3D; $h∗w&#x2F;M^2∗(M^2)^2&#x3D;M^2∗(hw)$</p><p>计算复杂度由patches数量的平方关系降低到线性关系。</p><p>论文的总体结构图</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-34-43-20221204%2022:06:50.png" alt="Snipaste_2022-12-04_21-34-43"></p><p>程序的逻辑框架图</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-35-11-20221204%2022:07:00.png" alt="Snipaste_2022-12-04_21-35-11"></p><p>程序主要分为三个部分：</p><ol><li><p>图像处理：将RGB像素分辨率的图像转化为patches分辨率图像并根据具体模型大小改变输入通道数(图5)。</p></li><li><p>Swin Transformer stage：实现window self-attention及shifted window self-attention，通过Patch Merging实现分层结构，降低计算复杂度并能够处理不同尺度的图片。图片中*2代表此处有两个Swin Transformer Block，模型大小不同对应的Swin Transformer Block个数不同(图5)。</p></li><li><p>不同视觉任务输出：不同任务有不同的输出，此处以图像分类任务为例进行说明，所以Part2输出根据任务要求转换成对应的输出。</p></li></ol><p><strong>论文和程序中都要注意三个不同的概念，分别是resolution&#x2F; patches&#x2F; windows</strong></p><p><strong>resolution:</strong> 输入图片的分辨率是像素分辨率，程序Part 1 输入图片是像素分辨率，但是Part 2程序中对应的H&#x2F;W是patches 分辨率，不是像素分辨率。</p><p><strong>patches:</strong> 图像4<em>4像素区域称为一个patch，分类任务输入图像像素分辨率是224</em>224，patch_size &#x3D; 4，所以patches__resolution &#x3D; 56*56</p><p><strong>windows:</strong> 窗口大小由patches定义的，不是像素定义的，论文及程序中window_size &#x3D; 7，说明一个window有7*7&#x3D;49个patches</p><h4 id="基于transformer的detr目标检测"><a href="#基于transformer的detr目标检测" class="headerlink" title="基于transformer的detr目标检测"></a>基于transformer的detr目标检测</h4><p><a href="https://link.zhihu.com/?target=https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123460205.pdf">DETR</a>的全称是DEtection TRansformer，是Facebook提出的基于Transformer的端到端目标检测网络，发表于ECCV2020，代码已开源：</p><p>作为Transformer用在目标检测领域的开山之作，DETR是CV领域学习Transformer绕不过的一道坎。前人栽树后人乘凉，学习一些经典的思路和代码对自己的提升也是巨大的。</p><p>DETR的思路和传统的目标检测的本质思路有相似之处，但表现方式很不一样。传统的方法比如Anchor-based方法本质上是对预定义的密集anchors进行类别的分类和边框系数的回归。DETR则是将目标检测视为一个集合预测问题（集合和anchors的作用类似）。由于Transformer本质上是一个序列转换的作用，因此，可以将DETR视为一个从图像序列到一个集合序列的转换过程。该集合实际上就是一个<strong>可学习的位置编码</strong>（文章中也称为object queries或者output positional encoding，代码中叫作query_embed）。</p><p>网络结构</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-37-34-20221204%2022:07:10.png" alt="Snipaste_2022-12-04_21-37-34"></p><p>DETR使用的Transformer结构和原始版本稍有不同：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/Snipaste_2022-12-04_21-38-20-20221204%2022:07:19.png" alt="Snipaste_2022-12-04_21-38-20"></p><p>详情了解：<a href="https://zhuanlan.zhihu.com/p/348060767">这里</a></p><h3 id="8-3d点云"><a href="#8-3d点云" class="headerlink" title="8. 3d点云"></a>8. 3d点云</h3><h4 id="pointnet"><a href="#pointnet" class="headerlink" title="pointnet"></a>pointnet</h4><h4 id="pointnet-1"><a href="#pointnet-1" class="headerlink" title="pointnet++"></a>pointnet++</h4><h4 id="点云补全pf-net"><a href="#点云补全pf-net" class="headerlink" title="点云补全pf-net"></a>点云补全pf-net</h4><h4 id="点云配准"><a href="#点云配准" class="headerlink" title="点云配准"></a>点云配准</h4><h3 id="9-目标追踪与姿态估计"><a href="#9-目标追踪与姿态估计" class="headerlink" title="9. 目标追踪与姿态估计"></a>9. 目标追踪与姿态估计</h3><blockquote><p> YOLO系列 + Deepsort系列 + Openpose系列</p></blockquote><h4 id="姿态估计openpose"><a href="#姿态估计openpose" class="headerlink" title="姿态估计openpose"></a>姿态估计openpose</h4><p>得到人体各个关键点位置，将他们按顺序进行拼接</p><p>难点：遮挡、匹配</p><p>COCO数据集提供17个关键点（openpose为18个关键点：脖子：左肩膀右肩膀做平均）</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920212233033-20220920%2021:22:33.png" alt="image-20220920212233033"></p><p>Top-down方法：先检测得到所有人的框（目标检测），再对每一个框进行姿态估计输出结果。优点：准；缺点：依赖目标检测、非极大值抑制会让重叠目标或小目标丢失、算法复杂度和人数成正比，不适合实时</p><p><strong>Multi-Person Pose Estimation using Part Affinity Fields</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920214803080-20220920%2021:48:03.png" alt="image-20220920214803080"></p><p>获得关键点：通过热度图得到每一个关键点的预测结果（每个关键点单独预测，18个关键点需要18张特征图）</p><p>拼接：找到最合适的拼接方向PAF（19个拼接方式，19*2个特征图）</p><blockquote><p>在标签中，设计PAF来表示关键点连接向量</p><p>PAF标签定义：将两个关键点的V向量做成单位向量，在手臂上任何一点P的向量与V一致，论文中给定了距离阈值</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920220704638-20220920%2022:07:04.png" alt="image-20220920220704638"/><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220920220955266-20220920%2022:09:55.png" alt="image-20220920220955266" style="zoom:50%;" /><p>求$X_{j_1}$和$X_{j_2}$间各点的PAF在险段上投影的积分，线段上各点的PAF方向如果与线段的方向越接近权值就越大</p><p>找每个头和每个左肩膀投影的得分值，找到最大的，就是最好最合适的方向</p></blockquote><p>匹配方法：固定成二分，可以直接套用匈牙利算法，每个点先与其他一个点做匹配</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921140114594-20220921%2014:01:14.png" alt="image-20220921140114594"></p><p><strong>整体框架：</strong></p><ul><li>分别经过两个分支得到各自预测结果</li><li>基于各分支结果组成骨架</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921140403694-20220921%2014:04:03.png" alt="image-20220921140403694"></p><p>最早：Convolutional Pose Machines:</p><ul><li>为OpenPose后面的工作奠定了基础，也可以当作基础框架</li><li>通过多个stage来不断优化关键点位置（stage1预测完全错误，2，3在纠正）</li><li>stage越多相当于层数越深，模型感受野越大，姿态估计需要更大感受野</li><li>每个stage都要加损失函数，需要中间过程也做得好</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921140654630-20220921%2014:06:54.png" alt="image-20220921140654630"></p><p>openpose的做法：</p><ul><li>两个网络结构分别搞定：1.关键点预测，2.姿势的‘亲和力’向量</li><li>多个stage，相当于纠正的过程，不断调整预测结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921141931643-20220921%2014:19:31.png" alt="image-20220921141931643"></p><blockquote><p>代码：</p><p>预存：Realtime_Multi-Person_Pose_Estimation</p><p>github相关：（关键词：openpose）</p><p>Hzzone pytorch-openpose：<a href="https://github.com/Hzzone/pytorch-openpose">https://github.com/Hzzone/pytorch-openpose</a></p><p>c++版的，star更多所以还是放在这里吧：<a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a></p></blockquote><h4 id="deepsort"><a href="#deepsort" class="headerlink" title="deepsort"></a>deepsort</h4><p>卡尔曼滤波</p><ul><li><p>根据已知信息估计最优位置</p></li><li><p>本质是优化估计算法</p></li><li><p>例如估计人在下一帧的位置</p></li><li><p>基于估计值和观测值进行综合（如下一帧预测值和下一帧检测值）</p></li><li><p>卡尔曼增益的目的是让最优估计值的方差更小，相当于一个权重值，怎么利用估计和观测决定了卡尔曼滤波的核心作用</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921153305685-20220921%2015:33:05.png" alt="image-20220921153305685"></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921153606066-20220921%2015:36:06.png" alt="image-20220921153606066"></p><ul><li>两大核心模块：prediction和update</li><li>预测阶段：预测状态估计值及其协方差（在单状态中，协方差矩阵就是其方差，他是预测状态中的不确定性的度量&#x2F;噪声导致的）</li><li>更新阶段：基于预测值更新参数，预测完需要根据观测值来修正，修正后的状态值去估计下一帧</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921154801512-20220921%2015:48:01.png" alt="image-20220921154801512"></p><p>追踪问题需要考虑的状态：</p><ul><li><p>均值（Mean）：8维向量表示为 x &#x3D; [cx, cy, r, h, vx, vy, vr, vh]</p></li><li><p>中心坐标（cx, cy），宽高比r，高h，以及各自的速度变化值组成</p></li><li><p>协方差矩阵：表示目标位置信息的不确定性，由8*8的矩阵表示</p></li><li><p>追踪过程也要分为两个阶段</p></li><li><p>每一个track都要预测下一时刻的状态，并基于检测到的结果来修正（匀速、线性）</p></li></ul><p>匈牙利算法：</p><ul><li>在完成匹配的同时最小化代价矩阵</li><li>算法过程：</li><li>对于矩阵的每一行，减去其中最小的元素</li><li>对于矩阵的每一列，减去其中最小的元素</li><li>（3）用最少的水平线或垂直线覆盖矩阵中所有的0</li><li>如果线的数量&#x3D;N，则找到了最优分配，算法结束，否则下一步</li><li>找到没有被任何线覆盖的最小元素，每个没被线覆盖的行减去这个元素，每个被线覆盖的列加上这个元素，返回（3）</li></ul><blockquote><p>调用：sklearn:linear_assignment(); scipy:linear_sum_assignment()</p></blockquote><ul><li>运动信息匹配（卡尔曼估计）、外观匹配（ReID）、IOU匹配（BBOX）</li></ul><p>ReID特征：</p><ul><li>追踪人所以用到了ReID，如果追踪其他目标需要自己训练</li><li>对输入的bbox进行特征提取，返回128维特征</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921170526712-20220921%2017:05:26.png" alt="image-20220921170526712"></p><ul><li>根据当前检测的所有bbox与当前所有track，先得到其所有ReID特征</li><li>当前每一个track均存了一个特征序列（就是每一次匹配会保留一份特征）</li><li>例如一个track有5份128维向量，选其与每个bbox余弦距离最小的作为输入</li><li>track保存的特征数量是有上限的，默认参数是100个</li></ul><p>追踪任务基本流程：</p><ul><li>目标检测+追踪（对检测的bbox提取各项特征后进行匹配）</li></ul><p>前身：sort算法（只对位置和运动信息进行匹配，不关注里面的内容）</p><ol><li><p>卡尔曼预测与更新</p></li><li><p>匈牙利匹配返回结果</p></li></ol><ul><li>将预测后的tracks和当前帧中的detections进行匹配（IOU匹配）</li><li>没有REID等深度学习特征</li></ul><p><strong>deepsort算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921192135436-20220921%2019:21:35.png" alt="image-20220921192135436"></p><ul><li>级联匹配:代价函数由运动特征(卡尔曼预测)与ReID特征计算的距离组成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220921192412849-20220921%2019:24:12.png" alt="image-20220921192412849"></p><p><strong>追踪流程拆解：</strong></p><ul><li>第一帧：检测得到10个bbox，此时没有track</li><li>对每一帧的检测结果，都会经过NMS和置信度阈值来筛选</li><li>不会执行任何的deepsort追踪操作</li><li>对当前10个检测结果分别初始化track</li><li>第二帧：检测得到11个bbox，如何跟上一帧初始化的track匹配呢？</li><li>进行IOU匹配（级联匹配需要对confirmed track，现在还没有）</li><li>此时匹配到10个track，注意匹配到的更新卡夫曼参数</li><li>还有一个bbox没有匹配到，为其新建一个bbox</li><li>第三帧：检测得到12个bbox，当前还没有confirm的track（命中3次）</li><li>前面创建了11个track要继续与12个bbox进行IOU匹配</li><li>其中一个track没有匹配上（此时是非confirm的，将其删除）</li><li>有10个track已经命中3次了，将其状态更改为confirm</li><li>第四帧：检测得到14个bbox，不仅要做IOU还要做级联匹配</li><li>对前面10个confirm的track进行级联匹配（优先），然后再IOU</li><li>只有confirm的track才会可视化在输出结果中</li><li>注意每次匹配到的track一定要更新其卡夫曼参数</li></ul><p><strong>追踪流程拆解总结：</strong></p><ul><li>检测得到当前帧的bbox（其实追踪好坏主要取决于检测结果）</li><li>track分为：confirmed和unconfirmed，待遇不同</li><li>对于confirmed要先进行级联匹配，优先级高，连续70帧没被匹配上会被删除</li><li>代价矩阵包括ReID特征构建的余弦距离与运动信息构建的马氏距离</li><li>对于级联匹配玩剩下的和当前是unconfirmed与剩下的bbox进行IOU匹配</li><li>经过级联与IOU匹配后就得到了所有匹配结果，同时要更新track参数</li><li>对于匹配成功的track，连续命中三次以上才能转换成confirmed</li><li>对于没有匹配成功的track，如果它是unconfirmed则删除</li></ul><blockquote><p>代码：</p><p>Yolov5_DeepSort_Pytorch</p><p>github地址：</p><p>mikel-brostrom &#x2F; Yolov5_DeepSort_Pytorch：<a href="https://github.com/mikel-brostrom/Yolov5_StrongSORT_OSNet">https://github.com/mikel-brostrom/Yolov5_StrongSORT_OSNet</a></p></blockquote><h3 id="10-行人重识别"><a href="#10-行人重识别" class="headerlink" title="10. 行人重识别"></a>10. 行人重识别</h3><h4 id="基于注意力机制的reld"><a href="#基于注意力机制的reld" class="headerlink" title="基于注意力机制的reld"></a>基于注意力机制的reld</h4><blockquote><p>来源论文：Relation-Aware Global Attention，2020，CVPR</p></blockquote><p>主要贡献：</p><ol><li><p>对channel做权重</p></li><li><p>对空间做权重</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922145630351-20220922%2014:56:30.png" alt="image-20220922145630351"></p><blockquote><p>代码：</p><p>github地址：</p><p>microsoft &#x2F; Relation-Aware-Global-Attention-Networks：<a href="https://github.com/microsoft/Relation-Aware-Global-Attention-Networks">https://github.com/microsoft/Relation-Aware-Global-Attention-Networks</a></p><p>以resnet50为基础、</p><p>入口：main_imgreid.py，先写参数</p></blockquote><h4 id="基于attention的行人重识别"><a href="#基于attention的行人重识别" class="headerlink" title="基于attention的行人重识别"></a>基于attention的行人重识别</h4><h4 id="基于行人局部特征融合"><a href="#基于行人局部特征融合" class="headerlink" title="基于行人局部特征融合"></a>基于行人局部特征融合</h4><blockquote><p> 论文来源：Relation Network for Person Re-identification</p></blockquote><p>整体流程：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922161312974-20220922%2016:13:13.png" alt="image-20220922161312974"></p><p>流程解析：</p><ol><li>先对整体进行特征提取：现将数据resize，输入到resnet</li><li>将特征图分块，直接在h纬度进行截取</li><li>计算GCP特征：avg-max</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922161615425-20220922%2016:16:15.png" alt="image-20220922161615425"></p><ol start="4"><li>one vs rest：有点类似attention</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922161825106-20220922%2016:18:25.png" alt="image-20220922161825106"></p><ol start="5"><li>损失函数：依然是分类损失和triple loss，在六个点各计算了两种损失</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922162634214-20220922%2016:26:34.png" alt="image-20220922162634214"></p><blockquote><p>代码：Relation Network for Person Re-identification</p><p>github:<a href="https://github.com/cvlab-yonsei/RRID">https://github.com/cvlab-yonsei/RRID</a></p></blockquote><h4 id="基于图模型"><a href="#基于图模型" class="headerlink" title="基于图模型"></a>基于图模型</h4><h4 id="基于拓扑图：针对遮挡现象"><a href="#基于拓扑图：针对遮挡现象" class="headerlink" title="基于拓扑图：针对遮挡现象"></a>基于拓扑图：针对遮挡现象</h4><blockquote><p>来源论文：Learning Relation and Topology for Occluded Person Re-Identification</p></blockquote><p>提出了三阶段的模型，重点解决遮蔽现象的局部特征：</p><ol><li>关键点局部特征提取</li><li>图卷积融合关键点特征</li><li>基于图匹配的方式来计算相似度并训练模型</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922171534923-20220922%2017:15:35.png" alt="image-20220922171534923"></p><p>一阶段：关键点局部特征提取</p><ul><li>选择一个pose estimation即可</li><li>得到的是各个关键点的热度图信息</li><li>通过热度图得到原始特征图的局部特征</li><li>同样也加了多个损失（local和global）</li><li>local和global的都要进行训练</li><li>全局特征是global average pooling得到</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922190549304-20220922%2019:05:49.png" alt="image-20220922190549304"></p><p>二阶段：局部特征关系整合（图卷积）</p><ul><li><p>通过加入关系更好的利用局部特征</p></li><li><p>先初始化邻接矩阵来进行图卷积（局部特征关系整合：得到邻接矩阵A来指导每个关键点特征如何跟其他关键点特征 进行计算，并且A矩阵也要进行学习）</p></li><li><p>邻接矩阵在学习过程中更新（顶点数：13个局部+1全局）（利用差异特征来学习邻接矩阵A）（用A来指导如何利用不同关键点的特征进行组合，最终再与输入的局部特征进行整合。）</p></li><li><p>更新完后与设定的模型mask。设定的模型没有的边直接删除</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922194657966-20220922%2020:04:12.png" alt="image-20220922194657966"></p><p>三阶段：图匹配</p><ul><li>回到AP、AN问题</li><li>输入两张图像（经过了前两阶段后的结果）</li><li>计算他们之间的相似度（其实输入是两组，第一组A,P; 第二组，A,N; ）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922201207388-20220922%2020:12:07.png" alt="image-20220922201207388"></p><ul><li>图匹配就是要一个相似度矩阵U</li><li>例如14*14，表示两个图之间的关系</li><li>这里面是一个交叉的过程(cross)，分别交叉来得到各自匹配的特征结果</li><li>引入新的损失函数：验证损失</li><li>就是sigmoid(emb1, emb2)的结果</li></ul><p>每个阶段都有损失，前两个阶段的local和global，后一个阶段的Classification Loss&#x2F;Triplet Loss</p><blockquote><p>代码：HOReID</p></blockquote><h3 id="11-gan生成对抗网络"><a href="#11-gan生成对抗网络" class="headerlink" title="11. gan生成对抗网络"></a>11. gan生成对抗网络</h3><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922204254337-20220922%2020:42:54.png" alt="image-20220922204254337"></p><blockquote><p>代码：gan</p></blockquote><p>主要是生成器、判别器、损失</p><h4 id="cyclegan-图像合成"><a href="#cyclegan-图像合成" class="headerlink" title="cyclegan 图像合成"></a>cyclegan 图像合成</h4><ul><li>junyanz &#x2F; pytorch-CycleGAN-and-pix2pix：<a href="https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix">https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220922214545626-20220922%2021:45:45.png" alt="image-20220922214545626"></p><h4 id="stargan"><a href="#stargan" class="headerlink" title="stargan"></a>stargan</h4><p>Cycle-Gan中如果要生成一种效果，需要训练一组配对的G和D(2+2)，如果需要多种效果，stargan可以用一个模型完成，stargan已经迭代到了第二版本</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923143240344-20220923%2014:32:40.png" alt="image-20220923143240344"></p><ul><li>G额外接受了编码信息（one-hot）</li><li>D也同样接受，只需一个D与G</li><li>整体流程类似cycle-gan，但只用一个G就可以生成效果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923143818459-20220923%2014:38:18.png" alt="image-20220923143818459"></p><p><strong>整体流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923144903516-20220923%2014:49:03.png" alt="image-20220923144903516"></p><p>详细展示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923145546095-20220923%2014:55:46.png" alt="image-20220923145546095"></p><p>不仅是图像，也可以用于声音领域：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923145636573-20220923%2014:56:36.png" alt="image-20220923145636573"></p><p>v2版本</p><ul><li>多了mapping notwork和style encoder</li></ul><p>整体网络模型</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923150316715-20220923%2015:03:16.png" alt="image-20220923150316715"></p><p>Style reconstruction（编码器训练）</p><ul><li>风格编码器损失函数：$L_{sty} &#x3D; E_{x,\tilde y,z}[||\tilde s - E_{\tilde y}(G(x,\tilde s))||_1]$</li><li>其中 $\tilde s$ 是由mapping网络所得到的结果</li><li>相当于先给G一组风格向量，让它去生成，再对结果的结果进行编码</li><li>让编码后得到的风格向量与输入的mapping网络向量越接近越好</li></ul><p>Style diversification（多样化训练）</p><ul><li>结果得生成一些，多样化损失：$L_{ds} &#x3D; E_{x,\tilde y,z_1,z_2}[||G(x,\tilde s_1)-G(x,\tilde s_2||1]$</li><li>两组随机向量$z_1$，$z_2$通过mapping网络可以得到$s_1$与$s_2$：$\tilde s_i &#x3D; F_{\tilde y}(z_i) \text{for}\ i \in {1,2}$ </li><li>为了结果丰富，要使得当下计算结果越大越好，求损失时去负号</li></ul><p>cycle loss</p><ul><li>转换的只是特色，主体要保留：$L_{cyc} &#x3D; E_{x,y,\tilde y,z}[||x - G(G(x,\tilde s),\tilde s||_1]$</li><li>其中：$\tilde s &#x3D; E_y(x)$也就是原始图像本身的风格向量</li><li>训练时可以保证乳香不至于变得太离谱</li><li>这个损失函数其实与cycle gan基本是一样的</li></ul><blockquote><p>代码：stargan-v2</p><p>github：<a href="https://github.com/clovaai/stargan-v2">https://github.com/clovaai/stargan-v2</a></p></blockquote><h4 id="starganvc2-变声器"><a href="#starganvc2-变声器" class="headerlink" title="starganvc2 变声器"></a>starganvc2 变声器</h4><blockquote><p>来源论文：StarGAN-VC2: Rethinking Conditional Methods for StarGAN-Based Voice Conversion</p><p>相关资料：<a href="https://www.kecl.ntt.co.jp/people/kaneko.takuhiro/projects/stargan-vc2/index.html">https://www.kecl.ntt.co.jp/people/kaneko.takuhiro/projects/stargan-vc2/index.html</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923204726970-20220923%2020:47:27.png" alt="image-20220923204726970"></p><p>类似变声器，转换语音特征的同时留下语音内容</p><p>VC：Voice Conversion</p><ul><li>构建变声器：思想类似stargan，细节完全不同</li><li>需要输入：1. 声音数据；2. 标签编码</li><li>整体来说还是GAN模型，主要解决数据特征提取，网络模型定义</li><li>Stargan-vc2是升级版，前身还有cyclegan-vc和stargan-vc</li></ul><p>输入数据</p><ul><li>VCC2016和VCC2018（这个数据比较小，也可以用其他的）</li><li>4个人的声音数据，相当于4个domain，他们之间相互转换</li><li>论文中选择的特征为：MCEPs；log F0；APs</li><li>输入特征为：batchsize*1*35*128（35是特征个数，128是指定特征纬度）</li><li>频率：每秒钟波峰所发生的数目称之为信号的频率，用单位千赫兹(kHz)表示</li><li>0.1毫秒完成4.8次采样，则1秒48000次采样，采样率48KHZ</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923211127864-20220923%2021:11:27.png" alt="image-20220923211127864"></p><p>预处理</p><ul><li>16KHZ重采样（经验值，与论文一致）</li><li>预加重：补偿高频信号，让高频信号权重更大一些，因为它信息多</li><li>分帧：类似时间窗口，得到多个特征段</li><li>论文中没有详细介绍预处理内容，源码中按照常用套路来做</li></ul><p>特征汇总</p><ul><li>基频特征(F0)：声音可以分解成不同频率的正弦波，其中最低的那个</li><li>频谱包络：语音是一个时序信号，如采样频率为16kHz的音频文件（每秒包含16000个采样点）分帧后得到了多个子序列，然后对每个子序列进行傅立叶变换操作，就得到了频率-振幅图（也就是描述频率-振幅图变化趋势的）</li><li>Aperiodic参数：基于F0与频谱包络计算得到</li></ul><p>MFCC</p><ul><li><p>梅尔倒谱系数：</p><p>流程：连续语音–预加重–加窗分帧–FFT（傅立叶变换）–MEL滤波器组–对数运算–DCT</p></li><li><p>通俗解释：FFT之后就把语音转换到频域，MEL滤波器变换后相当于得到更符合人类听觉的效果</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923215302181-20220923%2021:53:02.png" alt="image-20220923215302181" style="zoom:50%;" /></li><li><p>最后DCT相当于提取每一帧的包络（这里面特征多）</p></li></ul><p>网络架构</p><ul><li>生成器：输入就是提取好的特征，输出也就是特征</li><li>编码-解码的过程，其中引入了IN和GLU单元</li></ul><p>Instance Normalization</p><ul><li>变声期改变风格，不改变内容</li><li>编码时要留住原始内容，就要去掉声音中特性的部分</li><li>解码时要放大特性，需要再处理解码特征</li><li>Instance Normalization和Adaptive Instance Normalization</li><li>IN：使当前特征更平稳更平缓</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923220524738-20220923%2022:05:24.png" alt="image-20220923220524738"></p><ul><li>Adain：解码时要突出特色</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923221322759-20220923%2022:13:22.png" alt="image-20220923221322759"></p><p>小细节</p><ul><li>上采样与下采样：都是老路子，stride &#x3D; 2来下采样，反卷积来上采样</li><li>PixelShuffle(Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network)：Pixelshuffle会为 (∗ , r^2 x C, H, W) 的Tensor给reshape成 (∗ , C, rH, rW)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923221947540-20220923%2022:19:47.png" alt="image-20220923221947540"></p><p>判别器</p><ul><li>GSP：global sum pooling：一个特征图压缩成一个点，batch*512*h*w压缩成batch*512</li><li>标签通过embedding编码成512维特征（batch*512），内积得到batch个判别结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220923222013672-20220923%2022:20:13.png" alt="image-20220923222013672"></p><p>损失：对抗损失、分类损失、循环一致性损失</p><blockquote><p>代码：pytorch-StarGAN-VC2-master</p></blockquote><h4 id="超分辨率重构"><a href="#超分辨率重构" class="headerlink" title="超分辨率重构"></a>超分辨率重构</h4><blockquote><p>来源论文：Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network</p><p><a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Ledig_Photo-Realistic_Single_Image_CVPR_2017_paper.pdf">https://openaccess.thecvf.com/content_cvpr_2017/papers/Ledig_Photo-Realistic_Single_Image_CVPR_2017_paper.pdf</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220924163001559-20220924%2016:30:01.png" alt="image-20220924163001559"></p><blockquote><p>代码：srgan</p><p><a href="https://github.com/tensorlayer/srgan">https://github.com/tensorlayer/srgan</a></p></blockquote><h4 id="基于gan的图像补全"><a href="#基于gan的图像补全" class="headerlink" title="基于gan的图像补全"></a>基于gan的图像补全</h4><blockquote><p>来源论文：Globally and Locally Consistent Image Completion</p><p><a href="http://iizuka.cs.tsukuba.ac.jp/projects/completion/data/completion_sig2017.pdf">http://iizuka.cs.tsukuba.ac.jp/projects/completion/data/completion_sig2017.pdf</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220924165154555-20220924%2016:51:54.png" alt="image-20220924165154555"></p><p>网络结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220924165236234-20220924%2016:52:36.png" alt="image-20220924165236234"></p><p>特征分两部分提取：局部的和全局的，进行一致性表达</p><p>整个网络由三大块组成：</p><ul><li>修复网络：把有空白的图像修复成正常的，完全由全卷积组成，不使用池化层</li><li>全局判别器：帮助训练</li><li>局部判别器：帮助训练</li></ul><blockquote><p>代码：基于GAN的图像补全实战&#x2F;glcic</p><p>其他相关：<a href="https://github.com/otenim/GLCIC-PyTorch">https://github.com/otenim/GLCIC-PyTorch</a></p></blockquote><h3 id="12-强化学习"><a href="#12-强化学习" class="headerlink" title="12. 强化学习"></a>12. 强化学习</h3><p>强化学习就是不断与环境交互，需要大量的模拟数据来训练，训练就是不断尝试的过程，设置奖励机制，中间过程也可以设置奖励。</p><ul><li>机器人要不断与环境交互</li><li>互动就是得到下一步的指示（Action）</li><li>按照指示走下去势必会改变环境</li><li>继续与环境交互得到新的指示，并结合奖励机制来学习要不要这样做</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927140839750-20220927%2014:08:39.png" alt="image-20220927140839750"></p><p>如何通过状态得到当前合适的行为？</p><ul><li>通过神经网络，输入为state，输出为action</li><li>主要问题：如何训练网络？不是分类或回归任务了</li></ul><p>深度学习和强化学习的区别</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927142616581-20220927%2014:26:16.png" alt="image-20220927142616581"></p><h4 id="ppo算法"><a href="#ppo算法" class="headerlink" title="ppo算法"></a>ppo算法</h4><blockquote><p>Proximal Policy Optimization</p><p>关注目标函数定义方法、如何实际进行求解</p></blockquote><p>网络的输入与输出</p><ul><li>一次游戏的记录结果</li><li>包括了每一步的状态与行动 (trajectory) ：$\tau &#x3D; {s_1,a_1,s_2,a_2,s_3,…,s_T,a_T }$</li></ul><p>游戏的行为如何产生？</p><ul><li>其中$p(s_{t+1} | s_t,a_t)$是游戏自带的，$p_\theta(a_t|s_t)$是模型输出的结果，其中奖励是由当前第一步的action和state共同决定的（游戏提供的规则）</li><li>当前模型恰好得到了如下的游戏记录：</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927144811119-20220927%2014:48:11.png" alt="image-20220927144811119" style="zoom:40%;" /><p>需要优化的是网络中的权重参数</p><ul><li><p>找到最优的 $\theta$ ，使得总奖励最大：$\theta ^\star &#x3D; \arg \max \limits_\theta E_{\tau - p_\theta(\tau)}[\sum \limits_t r(s_t,a_t)]$</p></li><li><p>加入期望，即便相同的 $\theta$ 得到的action也可能不同</p></li><li><p>大数定律：穷举以接近：（ i 表示玩了多少次，t 表示一次多少steps）</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927150533422-20220927%2015:05:33.png" alt="image-20220927150533422" style="zoom:33%;" /><ul><li>计算梯度：$\pi_\theta (\tau)$ 表示当前序列可能性，$r(\tau)$ 作为奖励</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927151416552-20220927%2015:14:16.png" alt="image-20220927151416552" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927151114134-20220927%2015:11:14.png" alt="image-20220927151114134" style="zoom:33%;" /><ul><li>化简到最终要求解的梯度：更新参数：$\theta \leftarrow \theta + \alpha ▼_\theta J(\theta)$（梯度上升）</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927152016136-20220927%2015:20:16.png" alt="image-20220927152016136" style="zoom:33%;" /><p>铁三角训练模型：</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927152447107-20220927%2015:24:47.png" alt="image-20220927152447107" style="zoom:50%;" /><p>如何获得这么多游戏数据？</p><ul><li><p>持续游戏，并记录每场游戏的情况（$\tau ^1:(s_1^1,a_1^1) (s_2^1,a_2^1)，\tau^2:(s_1^2,a_1^2)(s_2^2,a_2^2)$）和奖励（$R(\tau^1)， R(\tau^2)$）</p></li><li><p>把数据带入最终要求的梯度公式求解即可</p></li></ul><p>改进：</p><ul><li><p>baseline方法：总的奖励与 $\theta$ 无关，可以看作一个权重项，可以做归一化，但有些游戏以奖励为主，惩罚较少，此时可以对总的奖励进行一个去均值操作：$R(\tau ^n) - b$ ，其中，$b &#x3D; 1&#x2F;N\sum^N_{i&#x3D;1}r(\tau)（减去平均均值即去均值）</p></li><li><p>On policy和Off policy：</p><ul><li>On policy：就是训练数据由当前agent与不断环境交互得到</li><li>Off policy：找一个 $\bar{\pi}(\tau)$ 去替代 $\pi_\theta(\tau)$</li><li>使用On policy策略训练太慢，做一批数据只是迭代一次</li></ul></li><li><p>Importance Sampling</p><ul><li>梯度策略要求我们不断产生样本数据：</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927160851782-20220927%2016:08:51.png" alt="image-20220927160851782" style="zoom:33%;" /><ul><li>用另一种分布代替当前的分布：从 P 这个分布中不断采样 X ，再把 X 带入到 f(x) 中，再求 f(x) 的期望值，P’ 上场，将P换下来</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927160958859-20220927%2016:09:58.png" alt="image-20220927160958859" style="zoom:33%;" /><ul><li><p>要满足的要求：P 与 P‘ 要尽量接近</p></li><li><p>从 P’ 中sample出数据供 $\theta$进行训练（这一批数据可以训练多次）</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927161622056-20220927%2016:16:22.png" alt="image-20220927161622056" style="zoom:33%;" /></li><li><p>条件限制：$\pi_{\theta’}$ 和 $\pi_\theta$ 要相近（KL-divergence）：$D_{KL}(\pi_{\theta’}||\pi_\theta) &#x3D; E_{\pi_{\theta’}}[\log \pi_\theta - \log \pi_{\theta’}]$</p></li><li><p>直观解释：$||\theta’ - \theta||^2 \le \epsilon$，实际中是二者经过网络的预测结果尽可能差不多</p></li><li><p>实际中可以直接拿训练模型的前一次迭代参数，PPO2的限制条件如下：</p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927164713758-20220927%2016:47:13.png" alt="image-20220927164713758" style="zoom:33%;" /></li><li><p>总结：用前一步迭代结果的 $\theta$ 产生大量数据，供当前 $\theta$ 进行学习</p></li></ul></li></ul><blockquote><p>代码：PPO-PyTorch</p></blockquote><p>ActionCritic组合</p><ul><li><p>让模型与当前的水平匹配，将 $R(\tau^n)-b$ 更新为 $R(\tau^n)-value$，value是critic网络要学习的结果</p></li><li><p>在PPO2版本中，限制好范围，例如 ε 取0.2；A&gt;0 是好事，此时 $p_\theta (a_t|s_t)$ 要越大越好，但有上界!</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927193416972-20220927%2019:34:17.png" alt="image-20220927193416972" style="zoom:50%;" /><h4 id="q-learning和dqn算法"><a href="#q-learning和dqn算法" class="headerlink" title="q-learning和dqn算法"></a>q-learning和dqn算法</h4><p>眼前顺势奖励 + 记忆经验奖励</p><ul><li>瞬时奖励：做了一个动作就能获得的奖励</li><li>记忆经验奖励：按照训练时的经验，上一个动作发生后，接下来怎么做才能获得更大的奖励</li><li>DQN就是用神经网络来预测</li></ul><p>Q-learning</p><ul><li>收集数据：${(s_i,a_i,s_i’,r_i)}$，也就是玩游戏的记录，状态、动作、下个状态、奖励</li><li>令目标等于：$y_i \leftarrow r(s_i,a_i) + \gamma \max_{a_i’}Q_\empty (s_i’,s_i’)$</li><li>目标函数：$\arg \max_\empty 1&#x2F;2 \sum_i||Q_\empty(s_i,a_i)-y_i||$</li></ul><p>以密室逃脱为例</p><ul><li>设定5是终点，到5会有更大奖励</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927204326236-20220927%2020:43:26.png" alt="image-20220927204326236"></p><ul><li>初始化Q和R：Q现在看起来是一个空表，要不断进行填充(行为state，列为action)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927204414122-20220927%2020:44:14.png" alt="image-20220927204414122"></p><ul><li><p>迭代方式：Q(state, action) &#x3D; R(state, action) + Gamma * Max[A(next state, all actions)]</p></li><li><p>举例如：Q(1,5) &#x3D; Q(1,5) + 0.8 * Max[Q(5,1), Q(5,4), Q(5,5)] &#x3D; 100 + 0.8 * 0 &#x3D; 100</p></li><li><p>其中0.8是折扣因子，相当于经验记忆奖励的权重</p></li><li><p>重复迭代，得到收敛后的模型结果</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927205147353-20220927%2020:51:47.png" alt="image-20220927205147353"></p><p>DQN</p><ul><li>先玩一阵，得到记录数据，从记录中取一个batch，target与main相同网络结构，损失函数就是回归问题</li><li>状态很难穷举时，Q(s,a) 可以用神经网络来做</li><li>数据获取：构建一个replay buffers，用的时候去里面取一个batch就行</li><li>off policy策略</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927205433174-20220927%2020:54:33.png" alt="image-20220927205433174" style="zoom:50%;" /><blockquote><p>代码：DQN</p></blockquote><p>改进：Rainbow，加上各种套路（Double-DQN，Dueling-DQN，MultiStep）</p><p>Double-DQN</p><ul><li>随着游戏的进行，期望的Q会越大越大!</li><li>引入一个双重保险B：$Q_{\empty A}(s,a) \leftarrow r + \gamma Q_{\empty B}(s’, \arg \underset {a’}\max Q_{\empty A}(s’,a’))$</li></ul><p>Dueling-DQN</p><ul><li>让网络有举一反三的能力，而不是一次更新当前的结果</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927213822044-20220927%2021:38:22.png" alt="image-20220927213822044" style="zoom:80%;" /><ul><li>网络结构中多输出一个S值，可以当作偏置项：$Q(s,a) &#x3D; A(s,a) + V(s)$</li><li>其实就是让网络能同时更新相同state下不同action可能导致的结果，一般迭代的时候就更新当前状态下，某一个action的结果</li><li>限制网络不要只更新A值：让A中所有列的值加起来恒为0</li></ul><p>MultiStep-DQN</p><ul><li>将眼界放远，不光看眼前，还要看下N步的结果</li><li>MultiStep就是计算Q值的时候选择多个时间步</li></ul><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20220927215705350-20220927%2021:57:05.png" alt="image-20220927215705350" style="zoom:30%;" /><ul><li>同梯度下降中的，随机&#x2F;批量，这个就是小批量</li></ul><p>Continuous actions</p><ul><li>针对连续值</li><li>可以采样：遍历尽可能多的情况，得到一个最大值就好了</li><li>为此，重新定义一个Q网络，输出三个结果，分别是向量、矩阵、值</li><li>新的Q：$Q_\empty (s,a) &#x3D; -1&#x2F;2(a-\mu_\empty(s))^TP_\empty(s)(a-\mu_\empty(s)) + V_\empty(s)$</li><li>因为$(a-\mu_\empty(s))^TP_\empty(s)(a-\mu_\empty(s))$恒为正，所以$action &#x3D; \mu_\empty(s)$</li><li>此时带入Q(s,a)即可求出：$max_aQ_\empty(s,a) &#x3D; V_\empty(s)$</li></ul><h4 id="actor-critic算法-a3c"><a href="#actor-critic算法-a3c" class="headerlink" title="actor-critic算法(a3c)"></a>actor-critic算法(a3c)</h4><p>优势函数</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221007215340539-20221007%2021:53:40.png" alt="image-20221007215340539"></p><ul><li>函数表达式：$A^\pi(s_t,a_t) &#x3D; Q^\pi(s_t,a_t) - V^\pi(s_t)$</li><li>就是在状态s下，选择某一动作有多好，Q相当于得到的，V是期望的（平均）</li><li>如果A值是正的，则正激励</li></ul><p>两个网络训练有难度，做近似简化为一个网络：$A^\pi(s_t,a_t) \approx r(s_t,a_t) + V^\pi(s_{t+1}) - V^\pi(s_t)$</p><p>AC整体流程</p><ol><li>获取数据：${s_i,a_i}$（不断与环境交互，通过策略$\pi_\theta (a|s)$</li><li>前向传播计算：$A^\pi(s_i,a_i) &#x3D; r(s_i,a_i) + V_\empty^\pi(s’_i) - V_\empty^\pi(s_i)$</li><li>计算梯度：$\nabla _\theta J(\theta) \approx \sum_i \nabla_\theta log \pi_\theta(a_i|s_i)A^\pi(s_i,a_i)$</li><li>更新参数：$\theta \longleftarrow \theta + \alpha\nabla_\theta J(\theta)$</li></ol><p>多个智能体（多线程），每一个都单独与环境交互</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221012202537913-20221012%2020:25:38.png" alt="image-20221012202537913"></p><p>损失函数</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221012202556945-20221012%2020:25:57.png" alt="image-20221012202556945"></p><blockquote><p>代码例：Super-mario（用A3C玩超级马里奥）</p></blockquote><h3 id="13-模型部署与剪枝优化"><a href="#13-模型部署与剪枝优化" class="headerlink" title="13. 模型部署与剪枝优化"></a>13. 模型部署与剪枝优化</h3><h4 id="tensorrt"><a href="#tensorrt" class="headerlink" title="tensorrt"></a>tensorrt</h4><h4 id="tensorflow-serving"><a href="#tensorflow-serving" class="headerlink" title="tensorflow-serving"></a>tensorflow-serving</h4><h4 id="network-slimming"><a href="#network-slimming" class="headerlink" title="network-slimming"></a>network-slimming</h4><h4 id="mobilenet"><a href="#mobilenet" class="headerlink" title="mobilenet"></a>mobilenet</h4><h3 id="14-自然语言处理"><a href="#14-自然语言处理" class="headerlink" title="14. 自然语言处理"></a>14. 自然语言处理</h3><h3 id="15-bert"><a href="#15-bert" class="headerlink" title="15.bert"></a>15.bert</h3><h3 id="16-知识图谱"><a href="#16-知识图谱" class="headerlink" title="16. 知识图谱"></a>16. 知识图谱</h3><p>应用领域：</p><ul><li>搜索引擎</li><li>医疗查询（智能问答助手、辅助决策）</li><li>金融：反欺诈</li><li>推荐系统</li></ul><p>数据从哪里来：一段话：抽取实体、语义标签、二元关系、多元关系、事件</p><p>大量设计nlp技术</p><p>关系做得准确才可靠</p><p>常用技术点</p><ul><li><p>命名实体识别</p></li><li><p>给词打上标签</p></li><li><p>将标签和意图转换成sql</p></li><li><p>基于实体与关系构建知识图谱网络图（关系抽取）</p></li><li><p>实体统一 &#x2F; 指代消解</p></li></ul><p>Graph embedding</p><ul><li>风控模型中对节点进行编码</li><li>根据用户关系（通讯录）建立算法模型（Deep walk），获得用户向量</li><li>根据特征编码做预测分析</li><li>难点在于如何编码（算法）才能更准确体现这个用户的情况</li></ul><p>知识融合</p><ul><li>融合特征，得到最终的向量</li></ul><h4 id="图数据库：neo4j"><a href="#图数据库：neo4j" class="headerlink" title="图数据库：neo4j"></a>图数据库：neo4j</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs neo4j">Neo4j增删改查：<br><br>增：<br>增加一个节点<br>create (n:Person &#123;name:&#x27;我&#x27;,age:31&#125;)<br>带有关系属性<br>create (p:Person&#123;name:&quot;我&quot;,age:&quot;31&quot;&#125;)-[:包工程&#123;金额:10000&#125;]-&gt;(n:Person&#123;name:&quot;好大哥&quot;,age:&quot;35&quot;&#125;)<br><br>删<br>create (n:Person &#123;name:&#x27;TYD&#x27;,age:31&#125;)<br>match (n:Person&#123;name:&quot;TYD&quot;&#125;) delete n<br>删除关系<br>match (p:Person&#123;name:&quot;我&quot;,age:&quot;31&quot;&#125;)-[f:包工程]-&gt;(n:Person&#123;name:&quot;好大哥&quot;,age:&quot;35&quot;&#125;)<br>delete f<br><br>改：<br>加上标签<br>match (t:Person) where id(t)=789 set t:好人return t<br>加上属性<br>match (a:好人) where id(a)=789 set a.战斗力=200 return a<br>修改属性<br>match (a:好人) where id(a)=789 set a.战斗力=500 return a<br><br>查：(查操作太多啦，直接参考neo4j例子就好)<br>match (p:Person) - [:包工程] -&gt; (n:Person) return p,n<br>快速清空数据库：<br>MATCH (n)<br>DETACH DELETE n<br></code></pre></td></tr></table></figure><blockquote><p>使用python操作neo4j示例：pandasDemo</p></blockquote><h4 id="基于知识图谱的医疗问答系统（可运行）"><a href="#基于知识图谱的医疗问答系统（可运行）" class="headerlink" title="基于知识图谱的医疗问答系统（可运行）"></a>基于知识图谱的医疗问答系统（可运行）</h4><blockquote><p>代码：QAmedicalKG</p><p>运行：build_medicalgraph -&gt; chatbot_graph</p></blockquote><h4 id="文本数据关系抽取"><a href="#文本数据关系抽取" class="headerlink" title="文本数据关系抽取"></a>文本数据关系抽取</h4><blockquote><p>代码：Extraction</p><p>参考：<a href="http://ltp.ai/index.html">http://ltp.ai/index.html</a></p></blockquote><p>依存句法</p><p>语义角色标注</p><h4 id="金融平台风控模型"><a href="#金融平台风控模型" class="headerlink" title="金融平台风控模型"></a>金融平台风控模型</h4><blockquote><p>来源竞赛：<a href="http://openresearch.rong360.com/#/">http://openresearch.rong360.com/#/</a></p></blockquote><p>deepwalk</p><h4 id="医学糖尿病数据命名实体识别"><a href="#医学糖尿病数据命名实体识别" class="headerlink" title="医学糖尿病数据命名实体识别"></a>医学糖尿病数据命名实体识别</h4><h3 id="17-语音识别"><a href="#17-语音识别" class="headerlink" title="17. 语音识别"></a>17. 语音识别</h3><h4 id="seq2seq-x2F-las模型"><a href="#seq2seq-x2F-las模型" class="headerlink" title="seq2seq&#x2F;las模型"></a>seq2seq&#x2F;las模型</h4><p>encoder - attation - decoder</p><p>teacher forching: 用true label传到下一个，以防错误传播</p><blockquote><p>LAS模型语音识别代码：LAS-Pytorch</p></blockquote><h4 id="语音分离-convtasnet"><a href="#语音分离-convtasnet" class="headerlink" title="语音分离 convtasnet"></a>语音分离 convtasnet</h4><p>输入为混合的声音，输出各个讲话者单独的声音</p><p>经典的Deep Clustering</p><ol><li>拿到声音信号</li><li>做embedding：每个点变成向量，当做一个样本</li><li>对当前样本做一个聚类（k-means等）</li><li>把得到的label结果当作mask矩阵即可，分离出来，就得到k个mask</li><li>用mask还原到原始数据，得到k个结果，分离结束</li></ol><p>Cons-TasNet</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221015163640876-20221015%2016:36:41.png" alt="image-20221015163640876"></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20221015163712334-20221015%2016:37:12.png" alt="image-20221015163712334"></p><p>网络结构细节</p><ul><li>全卷积</li><li>更大的感受野：多次重复1-D卷积、空洞卷积、DW卷积（depthwise、pointwise）</li><li>纯语音输入输出</li><li>end to end</li></ul><blockquote><p>代码：Conv-TasNet</p></blockquote><h4 id="语音合成-tacotron"><a href="#语音合成-tacotron" class="headerlink" title="语音合成 tacotron"></a>语音合成 tacotron</h4><blockquote><p>地址：<a href="https://github.com/NVIDIA/tacotron2">https://github.com/NVIDIA/tacotron2</a></p><p>代码：语音合成tacotron2实战</p></blockquote><h3 id="18-推荐系统"><a href="#18-推荐系统" class="headerlink" title="18. 推荐系统"></a>18. 推荐系统</h3><h4 id="协同过滤与矩阵分解"><a href="#协同过滤与矩阵分解" class="headerlink" title="协同过滤与矩阵分解"></a>协同过滤与矩阵分解</h4><p>基于用户的协同过滤算法（算相似度）</p><p>基于物品的协同过滤算法（算相似度）</p><p>矩阵分解（让矩阵更容易）</p><p>矩阵分解中的隐式与显式情况解决思路</p><p>基于用户的协同过滤</p><ul><li>找到相似用户（相似度计算）</li><li>属性特征、行为特征等都可以当作计算输入</li><li>用的不多：用户多、数据稀疏、计算相似度矩阵较难、新用户问题</li></ul><p>基于物品的协同过滤</p><ul><li>先得到用户和商品的交互数据</li><li>经常被同时购买的商品</li><li>用的较多：商品种类比较少、属性比较固定、适合非实时场景</li></ul><p>矩阵分解</p><ul><li>推荐系统中用的最多的方法</li><li>User-item（m * n）分解为user（m * k）和item（k * n）两个矩阵</li></ul><p>隐向量：特征的高维表达</p><p>目标函数</p><ul><li><p>类似回归方程：$min_{X,Y}\sum_{r_{ui\neq0}}(r_{ui} - x_u^Ty_i)^2 + \lambda(\sum_u||x_u||^2_2 + \sum_i||y_i||^2_2)$</p></li><li><p>用户矩阵 X ，商品矩阵 Y</p></li><li><p>额外引入正则化惩罚项</p></li><li><p>再加入用户偏置项（bu）与商品偏置项（bi）</p></li></ul><p>隐式情况分析</p><ul><li><p>观看时间、点击次数等指标</p></li><li><p>定义置信度：$c_{ui} &#x3D; 1 + \alpha r_{ui}$</p></li><li><p>置信度默认为1，表示用户没有产生行为的商品；行为越多，置信度越大</p></li><li><p>重新定义评分：$$p_{ui} &#x3D; \begin{cases} 1&amp; {r_{ui} &gt; 0}\0&amp; {r_{ui} &#x3D; 0}\end{cases}$$</p></li><li><p>新的优化目标：$G(x_*,y_*) &#x3D; (\sum_{u,i}c_{ui}(p_{ui}-x_u^Ty_i)^2) + \lambda(\sum_u||x_u||^2 + \sum_i||y_i||^2)$</p></li><li><p>总结就是置信度越大，预测得越准</p></li><li><p>求解过程交替使用最小二乘法，先固定y优化x，再固定x优化y</p></li></ul><p>Embedding</p><ul><li><p>兴趣标签</p></li><li><p>用户画像</p></li><li><p>行为序列（点击历史）</p></li></ul><h4 id="fm与deepfm"><a href="#fm与deepfm" class="headerlink" title="fm与deepfm"></a>fm与deepfm</h4><h4 id="常用工具包"><a href="#常用工具包" class="headerlink" title="常用工具包"></a>常用工具包</h4><h3 id="19-diffusion-model"><a href="#19-diffusion-model" class="headerlink" title="19. diffusion model"></a>19. diffusion model</h3>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>深度学习</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>umi基础</title>
    <link href="/blog/2022/11/28/umi/"/>
    <url>/blog/2022/11/28/umi/</url>
    
    <content type="html"><![CDATA[<h1 id="Umi"><a href="#Umi" class="headerlink" title="Umi"></a>Umi</h1><p>Umi，中文可发音为<strong>乌米</strong>，是可扩展的企业级前端应用框架。Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。</p><p>Umi 是蚂蚁集团的底层前端框架，已直接或间接地服务了 3000+ 应用，包括 java、node、H5 无线、离线（Hybrid）应用、纯前端 assets 应用、CMS 应用等。他已经很好地服务了我们的内部用户，同时希望他也能服务好外部用户。</p><p>它主要具备以下功能：</p><ul><li>🎉 <strong>可扩展</strong>，Umi 实现了完整的生命周期，并使其插件化，Umi 内部功能也全由插件完成。此外还支持插件和插件集，以满足功能和垂直域的分层需求。</li><li>📦 <strong>开箱即用</strong>，Umi 内置了路由、构建、部署、测试等，仅需一个依赖即可上手开发。并且还提供针对 React 的集成插件集，内涵丰富的功能，可满足日常 80% 的开发需求。</li><li>🐠 <strong>企业级</strong>，经蚂蚁内部 3000+ 项目以及阿里、优酷、网易、飞猪、口碑等公司项目的验证，值得信赖。</li><li>🚀 <strong>大量自研</strong>，包含微前端、组件打包、文档工具、请求库、hooks 库、数据流等，满足日常项目的周边需求。</li><li>🌴 <strong>完备路由</strong>，同时支持配置式路由和约定式路由，同时保持功能的完备性，比如动态路由、嵌套路由、权限路由等等。</li><li>🚄 <strong>面向未来</strong>，在满足需求的同时，我们也不会停止对新技术的探索。比如 dll 提速、modern mode、webpack@5、自动化 external、bundler less 等等。</li></ul><h2 id="umi-临时文件"><a href="#umi-临时文件" class="headerlink" title=".umi 临时文件"></a>.umi 临时文件</h2><p>.umi 临时目录是整个 Umi 项目的发动机，你的入口文件、路由等等都在这里，这些是由 umi 内部插件及三方插件生成的。</p><p>你通常会在 .umi 下看到以下目录，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">+ .umi<br>  + core     <span class="hljs-comment"># 内部插件生成</span><br>  + pluginA  <span class="hljs-comment"># 外部插件生成</span><br>  + presetB  <span class="hljs-comment"># 外部插件生成</span><br>  + umi.ts   <span class="hljs-comment"># 入口文件</span><br></code></pre></td></tr></table></figure><p>临时文件是 Umi 框架中非常重要的一部分，框架或插件会根据你的代码生成临时文件，这些原来需要放在项目里的脏乱差的部分都被藏在了这里。</p><p>你可以在这里调试代码，但不要在 .git 仓库里提交他，因为他的临时性，每次启动 umi 时都会被删除并重新生成。</p><h2 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yarn build<br>✔ Webpack  Compiled successfully <span class="hljs-keyword">in</span> 17.17s<br> DONE  Compiled successfully <span class="hljs-keyword">in</span> 17167ms                                       8:26:25 PM<br>Build success.✨  Done <span class="hljs-keyword">in</span> 20.79s.<br></code></pre></td></tr></table></figure><p>构建产物默认生成到 <code>./dist</code> 下，然后通过 tree 命令查看，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tree ./dist<br>./dist├── index.html├── umi.css└── umi.js<br></code></pre></td></tr></table></figure><h3 id="本地验证"><a href="#本地验证" class="headerlink" title="本地验证"></a>本地验证</h3><p>发布之前，可以通过 <code>serve</code> 做本地验证，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yarn global add serve$ serve ./dist<br>   ┌────────────────────────────────────────────────────┐   │                                                    │   │   Serving!                                         │   │                                                    │   │   - Local:            http://localhost:5000        │   │   - On Your Network:  http://192.168.12.34:5000    │   │                                                    │   │   Copied <span class="hljs-built_in">local</span> address to clipboard!               │   │                                                    │   └────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><p>访问 <a href="http://localhost:5000/">http://localhost:5000</a>，正常情况下应该是和执行 <code>yarn start</code> 时是一致的。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>本地验证完，就可以部署了。你需要把 <code>dist</code> 目录部署到服务器上。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>一个基础的 Umi 项目大致是这样的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs unknown">.<br>├── package.json<br>├── .umirc.ts<br>├── .env<br>├── dist<br>├── mock<br>├── public<br>└── src<br>    ├── .umi<br>    ├── layouts/index.tsx<br>    ├── pages<br>        ├── index.less<br>        └── index.tsx<br>    └── app.ts<br></code></pre></td></tr></table></figure><h3 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h3><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>包含插件和插件集，以 <code>@umijs/preset-</code>、<code>@umijs/plugin-</code>、<code>umi-preset-</code> 和 <code>umi-plugin-</code> 开头的依赖会被自动注册为插件或插件集。</p><h4 id="umirc-ts"><a href="#umirc-ts" class="headerlink" title=".umirc.ts"></a>.umirc.ts</h4><p>配置文件，包含 umi 内置功能和插件的配置。</p><h4 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h4><p>环境变量。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs unknown">PORT=8888<br>COMPRESS=none<br></code></pre></td></tr></table></figure><h4 id="dist-目录"><a href="#dist-目录" class="headerlink" title="dist 目录"></a>dist 目录</h4><p>执行 <code>umi build</code> 后，产物默认会存放在这里。</p><h4 id="mock-目录"><a href="#mock-目录" class="headerlink" title="mock 目录"></a>mock 目录</h4><p>存储 mock 文件，此目录下所有 js 和 ts 文件会被解析为 mock 文件。</p><h4 id="public-目录"><a href="#public-目录" class="headerlink" title="public 目录"></a>public 目录</h4><p>此目录下所有文件会被 copy 到输出路径。</p><h3 id="src-目录"><a href="#src-目录" class="headerlink" title="/src 目录"></a><code>/src</code> 目录</h3><h4 id="umi-目录"><a href="#umi-目录" class="headerlink" title=".umi 目录"></a>.umi 目录</h4><p>临时文件目录，比如入口文件、路由等，都会被临时生成到这里。<strong>不要提交 .umi 目录到 git 仓库，他们会在 umi dev 和 umi build 时被删除并重新生成。</strong></p><h4 id="layouts-x2F-index-tsx"><a href="#layouts-x2F-index-tsx" class="headerlink" title="layouts&#x2F;index.tsx"></a>layouts&#x2F;index.tsx</h4><p>约定式路由时的全局布局文件。</p><h4 id="pages-目录"><a href="#pages-目录" class="headerlink" title="pages 目录"></a>pages 目录</h4><p>所有路由组件存放在这里。</p><h4 id="app-ts"><a href="#app-ts" class="headerlink" title="app.ts"></a>app.ts</h4><p>运行时配置文件，可以在这里扩展运行时的能力，比如修改路由、修改 render 方法等。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Umi 在 <code>.umirc.ts</code> 或 <code>config/config.ts</code> 中配置项目和插件，支持 es6。一份常见的配置如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  base: <span class="hljs-string">&#x27;/docs/&#x27;</span>,<br>  publicPath: <span class="hljs-string">&#x27;/static/&#x27;</span>,<br>  <span class="hljs-built_in">hash</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-built_in">history</span>: &#123;<br>    <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;hash&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果项目的配置不复杂，推荐在 <code>.umirc.ts</code> 中写配置； 如果项目的配置比较复杂，可以将配置写在 <code>config/config.ts</code> 中，并把配置的一部分拆分出去，比如路由配置可以拆分成单独的 <code>routes.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// config/routes.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [    &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;index&#x27;</span> &#125;,];<br><span class="hljs-comment">// config/config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;  <br>    <span class="hljs-attr">routes</span>: routes,<br>&#125;);<br></code></pre></td></tr></table></figure><p>推荐两种配置方式二选一，<code>.umirc.ts</code> 优先级更高。</p><h3 id="TypeScript-提示"><a href="#TypeScript-提示" class="headerlink" title="TypeScript 提示"></a>TypeScript 提示</h3><p>如果你想在写配置时也有提示，可以通过 umi 的 <code>defineConfig</code> 方法定义配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;  <br>    <span class="hljs-attr">routes</span>: [    <br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,  <br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://img.alicdn.com/tfs/TB1EV1pv.T1gK0jSZFhXXaAtVXa-1204-838.png" alt="img"></p><h3 id="本地临时配置"><a href="#本地临时配置" class="headerlink" title="本地临时配置"></a>本地临时配置</h3><p>可以新建 <code>.umirc.local.ts</code>，这份配置会和 <code>.umirc.ts</code> 做 deep merge 后形成最终配置。</p><blockquote><p>注：<code>.umirc.local.ts</code> 仅在 <code>umi dev</code> 时有效。<code>umi build</code> 时不会被加载。</p></blockquote><p>比如，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .umirc.ts 或者 config/config.tsexport default &#123; a: 1, b: 2 &#125;;</span><br><span class="hljs-comment">// .umirc.local.ts 或者 config/config.local.tsexport default &#123; c: &#x27;local&#x27; &#125;;</span><br></code></pre></td></tr></table></figure><p>拿到的配置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>config/config.ts</code> 对应的是 <code>config/config.local.ts</code></li><li><code>.local.ts</code> 是本地验证使用的临时配置，请将其添加到 <code>.gitignore</code>，<strong>务必不要提交到 git 仓库中</strong></li><li><code>.local.ts</code> 配置的优先级最高，比 <code>UMI_ENV</code> 指定的配置更高</li></ul><h3 id="多环境多份配置"><a href="#多环境多份配置" class="headerlink" title="多环境多份配置"></a>多环境多份配置</h3><p>可以通过环境变量 <code>UMI_ENV</code> 区分不同环境来指定配置。</p><p>举个例子，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .umirc.js 或者 config/config.jsexport default &#123; a: 1, b: 2 &#125;;</span><br><span class="hljs-comment">// .umirc.cloud.js 或者 config/config.cloud.jsexport default &#123; b: &#x27;cloud&#x27;, c: &#x27;cloud&#x27; &#125;;</span><br><span class="hljs-comment">// .umirc.local.js 或者 config/config.local.jsexport default &#123; c: &#x27;local&#x27; &#125;;</span><br></code></pre></td></tr></table></figure><p>不指定 <code>UMI_ENV</code> 时，拿到的配置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>指定 <code>UMI_ENV=cloud</code> 时，拿到的配置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;cloud&#x27;</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;local&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h2><p>运行时配置和配置的区别是他跑在浏览器端，基于此，我们可以在这里写函数、jsx、import 浏览器端依赖等等，注意不要引入 node 依赖。</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>约定 <code>src/app.tsx</code> 为运行时配置。</p><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><h5 id="modifyClientRenderOpts-fn"><a href="#modifyClientRenderOpts-fn" class="headerlink" title="modifyClientRenderOpts(fn)"></a>modifyClientRenderOpts(fn)</h5><p>修改 clientRender 参数。</p><p>比如在微前端里动态修改渲染根节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> isSubApp = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyClientRenderOpts</span>(<span class="hljs-params">memo</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ...memo,<br>    <span class="hljs-attr">rootElement</span>: isSubApp ? <span class="hljs-string">&#x27;sub-root&#x27;</span> : memo.<span class="hljs-property">rootElement</span>,    <br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="patchRoutes-routes"><a href="#patchRoutes-routes" class="headerlink" title="patchRoutes({ routes })"></a>patchRoutes({ routes })</h5><p>修改路由。</p><p>比如在最前面添加一个 <code>/foo</code> 路由，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> patchRoutes(&#123; routes &#125;) &#123;<br>  routes.unshift(&#123;<br>    path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>    exact: <span class="hljs-literal">true</span>,<br>    component: require(<span class="hljs-string">&#x27;@/extraRoutes/foo&#x27;</span>).default,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如和 <code>render</code> 配置配合使用，请求服务端根据响应动态更新路由，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> extraRoutes;<br><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> patchRoutes(&#123; routes &#125;) &#123;  merge(routes, extraRoutes);&#125;<br><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> render(oldRender) &#123;  fetch(<span class="hljs-string">&#x27;/api/routes&#x27;</span>).<span class="hljs-keyword">then</span>(res=&gt;res.json()).<span class="hljs-keyword">then</span>((res) =&gt; &#123;     extraRoutes = res.routes;    oldRender();  &#125;)&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>直接修改routes，不需要返回</li></ul><h5 id="render-oldRender-Function"><a href="#render-oldRender-Function" class="headerlink" title="render(oldRender: Function)"></a>render(oldRender: Function)</h5><p>覆写 render。</p><p>比如用于渲染之前做权限校验，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">import &#123; <span class="hljs-built_in">history</span> &#125; from <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> render(oldRender) &#123;  fetch(<span class="hljs-string">&#x27;/api/auth&#x27;</span>).<span class="hljs-keyword">then</span>(auth =&gt; &#123;    <span class="hljs-keyword">if</span> (auth.isLogin) &#123; oldRender() &#125;    <span class="hljs-keyword">else</span> &#123;       history.push(<span class="hljs-string">&#x27;/login&#x27;</span>);       oldRender()    &#125;  &#125;);&#125;<br></code></pre></td></tr></table></figure><h5 id="onRouteChange-routes-matchedRoutes-location-action"><a href="#onRouteChange-routes-matchedRoutes-location-action" class="headerlink" title="onRouteChange({ routes, matchedRoutes, location, action })"></a>onRouteChange({ routes, matchedRoutes, location, action })</h5><p>在初始加载和路由切换时做一些事情。</p><p>比如用于做埋点统计，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> onRouteChange(&#123; location, routes, action &#125;) &#123;<br>  bacon(location.pathname);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如用于设置标题，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> onRouteChange(&#123; matchedRoutes &#125;) &#123;<br>  <span class="hljs-keyword">if</span> (matchedRoutes.length) &#123;<br>    document.title = matchedRoutes[matchedRoutes.length - 1].route.title || <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="rootContainer-LastRootContainer-args"><a href="#rootContainer-LastRootContainer-args" class="headerlink" title="rootContainer(LastRootContainer, args)"></a>rootContainer(LastRootContainer, args)</h5><p>修改交给 react-dom 渲染时的根组件。</p><p>比如用于在外面包一个 Provider，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> <span class="hljs-keyword">function</span> rootContainer(container) &#123;<br>  <span class="hljs-built_in">return</span> React.createElement(ThemeProvider, null, container);<br>&#125;<br></code></pre></td></tr></table></figure><p>args 包含：</p><ul><li>routes，全量路由配置</li><li>plugin，运行时插件机制</li><li>history，history 实例</li></ul><h3 id="更多配置项"><a href="#更多配置项" class="headerlink" title="更多配置项"></a>更多配置项</h3><p>Umi 允许插件注册运行时配置，如果你使用插件，肯定会在插件里找到更多运行时的配置项。</p><h2 id="约定式路由"><a href="#约定式路由" class="headerlink" title="约定式路由"></a>约定式路由</h2><p>除配置式路由外，Umi 也支持约定式路由。约定式路由也叫文件路由，就是不需要手写配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。</p><p><strong>如果没有 routes 配置，Umi 会进入约定式路由模式</strong>，然后分析 <code>src/pages</code> 目录拿到路由配置。</p><p>比如以下文件结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>  └── pages<br>    ├── index.tsx<br>    └── users.tsx<br></code></pre></td></tr></table></figure><p>会得到以下路由配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users&#x27;</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><p>需要注意的是，满足以下任意规则的文件不会被注册为路由，</p><ul><li>以 <code>.</code> 或 <code>_</code> 开头的文件或目录</li><li>以 <code>d.ts</code> 结尾的类型定义文件</li><li>以 <code>test.ts</code>、<code>spec.ts</code>、<code>e2e.ts</code> 结尾的测试文件（适用于 <code>.js</code>、<code>.jsx</code> 和 <code>.tsx</code> 文件）</li><li><code>components</code> 和 <code>component</code> 目录</li><li><code>utils</code> 和 <code>util</code> 目录</li><li>不是 <code>.js</code>、<code>.jsx</code>、<code>.ts</code> 或 <code>.tsx</code> 文件</li><li>文件内容不包含 JSX 元素</li></ul><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>约定 <code>[]</code> 包裹的文件或文件夹为动态路由。</p><p>比如：</p><ul><li><code>src/pages/users/[id].tsx</code> 会成为 <code>/users/:id</code></li><li><code>src/pages/users/[id]/settings.tsx</code> 会成为 <code>/users/:id/settings</code></li></ul><p>举个完整的例子，比如以下文件结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>  └── pages<br>    └── [post]<br>      ├── index.tsx<br>      └── comments.tsx<br>    └── <span class="hljs-built_in">users</span><br>      └── [<span class="hljs-built_in">id</span>].tsx<br>    └── index.tsx<br></code></pre></td></tr></table></figure><p>会生成路由配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/[id]&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:post/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/[post]/index&#x27;</span> &#125;,<br>  &#123;<br>    <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:post/comments&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/[post]/comments&#x27;</span>,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><h3 id="动态可选路由"><a href="#动态可选路由" class="headerlink" title="动态可选路由"></a>动态可选路由</h3><p>约定 <code>[ $]</code> 包裹的文件或文件夹为动态可选路由。</p><p>比如：</p><ul><li><code>src/pages/users/[id$].tsx</code> 会成为 <code>/users/:id?</code></li><li><code>src/pages/users/[id$]/settings.tsx</code> 会成为 <code>/users/:id?/settings</code></li></ul><p>举个完整的例子，比如以下文件结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>  └── pages<br>    └── [post$]<br>      └── comments.tsx<br>    └── <span class="hljs-built_in">users</span><br>      └── [<span class="hljs-built_in">id</span>$].tsx<br>    └── index.tsx<br></code></pre></td></tr></table></figure><p>会生成路由配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id?&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/[id$]&#x27;</span> &#125;,<br>  &#123;<br>    <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:post?/comments&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/[post$]/comments&#x27;</span>,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>Umi 里约定目录下有 <code>_layout.tsx</code> 时会生成嵌套路由，以 <code>_layout.tsx</code> 为该目录的 layout。layout 文件需要返回一个 React 组件，并通过 <code>props.children</code> 渲染子组件。</p><p>比如以下目录结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>└── pages<br>    └── <span class="hljs-built_in">users</span><br>        ├── _layout.tsx<br>        ├── index.tsx<br>        └── list.tsx<br></code></pre></td></tr></table></figure><p>会生成路由，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/_layout&#x27;</span>,<br>    <span class="hljs-attr">routes</span>: [<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/index&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users/list&#x27;</span> &#125;,<br>    ]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="全局-layout"><a href="#全局-layout" class="headerlink" title="全局 layout"></a>全局 layout</h3><p>约定 <code>src/layouts/index.tsx</code> 为全局路由。返回一个 React 组件，并通过 <code>props.children</code> 渲染子组件。</p><p>比如以下目录结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>└── src<br>    ├── layouts<br>    │   └── index.tsx<br>    └── pages<br>        ├── index.tsx<br>        └── users.tsx<br></code></pre></td></tr></table></figure><p>会生成路由，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/layouts/index&#x27;</span>,<br>    <span class="hljs-attr">routes</span>: [<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users&#x27;</span> &#125;,<br>    ],<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><p>一个自定义的全局 <code>layout</code> 如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">IRouteComponentProps</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">&#123; children, location, route, history, match &#125;: IRouteComponentProps</span>) &#123;  <span class="hljs-keyword">return</span> children&#125;<br></code></pre></td></tr></table></figure><h3 id="不同的全局-layout"><a href="#不同的全局-layout" class="headerlink" title="不同的全局 layout"></a>不同的全局 layout</h3><p>你可能需要针对不同路由输出不同的全局 layout，Umi 不支持这样的配置，但你仍可以在 <code>src/layouts/index.tsx</code> 中对 <code>location.path</code> 做区分，渲染不同的 layout 。</p><p>比如想要针对 <code>/login</code> 输出简单布局，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SimpleLayout</span>&gt;</span>&#123; props.children &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">SimpleLayout</span>&gt;</span></span>  &#125;<br>  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>      &#123; props.children &#125;      <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span>    <span class="hljs-tag">&lt;/&gt;</span></span>  );&#125;<br></code></pre></td></tr></table></figure><h3 id="404-路由"><a href="#404-路由" class="headerlink" title="404 路由"></a>404 路由</h3><p>约定 <code>src/pages/404.tsx</code> 为 404 页面，需返回 React 组件。</p><p>比如以下目录结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>└── pages<br>    ├── 404.tsx<br>    ├── index.tsx<br>    └── users.tsx<br></code></pre></td></tr></table></figure><p>会生成路由，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/index&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/users&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/pages/404&#x27;</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><p>这样，如果访问 <code>/foo</code>，<code>/</code> 和 <code>/users</code> 都不能匹配，会 fallback 到 404 路由，通过 <code>src/pages/404.tsx</code> 进行渲染。</p><h3 id="权限路由"><a href="#权限路由" class="headerlink" title="权限路由"></a>权限路由</h3><p>通过指定高阶组件 <code>wrappers</code> 达成效果。</p><p>如下，<code>src/pages/user</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>user profile<span class="hljs-tag">&lt;/&gt;</span></span>&#125;<br><span class="hljs-title class_">User</span>.<span class="hljs-property">wrappers</span> = [<span class="hljs-string">&#x27;@/wrappers/auth&#x27;</span>]<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">User</span><br></code></pre></td></tr></table></figure><p>然后在 <code>src/wrappers/auth</code> 中，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Redirect</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; &#123;  <span class="hljs-keyword">const</span> &#123; isLogin &#125; = <span class="hljs-title function_">useAuth</span>();  <span class="hljs-keyword">if</span> (isLogin) &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; props.children &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> /&gt;</span></span>;  &#125;&#125;<br></code></pre></td></tr></table></figure><p>这样，访问 <code>/user</code>，就通过 <code>useAuth</code> 做权限校验，如果通过，渲染 <code>src/pages/user</code>，否则跳转到 <code>/login</code>，由 <code>src/pages/login</code> 进行渲染。</p><h3 id="扩展路由属性"><a href="#扩展路由属性" class="headerlink" title="扩展路由属性"></a>扩展路由属性</h3><p>支持在代码层通过导出静态属性的方式扩展路由。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HomePage</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;<br><span class="hljs-title class_">HomePage</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;Home Page&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HomePage</span>;<br></code></pre></td></tr></table></figure><p>其中的 <code>title</code> 会附加到路由配置中。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="插件的-id-和-key"><a href="#插件的-id-和-key" class="headerlink" title="插件的 id 和 key"></a>插件的 id 和 key</h3><p>每个插件都会对应一个 id 和一个 key，<strong>id 是路径的简写</strong>，<strong>key 是进一步简化后用于配置的唯一值</strong>。</p><p>比如插件 <code>/node_modules/@umijs/plugin-foo/index.js</code>，通常来说，其 id 为 <code>@umijs/plugin-foo</code>，key 为 <code>foo</code>。</p><h3 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a>启用插件</h3><p>插件有多种启用方式，</p><h4 id="package-json-依赖"><a href="#package-json-依赖" class="headerlink" title="package.json 依赖"></a>package.json 依赖</h4><p>Umi 会自动检测 <code>dependencies</code> 和 <code>devDependencies</code> 里的 umi 插件，比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@umijs/preset-react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>那么 <code>@umijs/preset-react</code> 会自动被注册，无需在配置里重复声明。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>在配置里可通过 <code>presets</code> 和 <code>plugins</code> 配置插件，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;./preset&#x27;</span>, <span class="hljs-string">&#x27;foo/presets&#x27;</span>],<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;./plugin&#x27;</span>],<br>&#125;<br></code></pre></td></tr></table></figure><p>通常用于几种情况：</p><ol><li>项目相对路径的插件</li><li>非 npm 包入口文件的插件</li></ol><p>注意：</p><ul><li>请不要配置 npm 包的插件，否则会报重复注册的错误</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>还可通过环境变量 <code>UMI_PRESETS</code> 和 <code>UMI_PLUGINS</code> 注册额外插件。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ UMI_PRESETS=/a/b/preset.js umi dev<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>项目里不建议使用，通常用于基于 umi 的框架二次封装</li></ul><h3 id="检查插件注册情况"><a href="#检查插件注册情况" class="headerlink" title="检查插件注册情况"></a>检查插件注册情况</h3><h4 id="通过命令行"><a href="#通过命令行" class="headerlink" title="通过命令行"></a>通过命令行</h4><p>可以执行以下命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi plugin list<br><span class="hljs-comment"># 顺便看看他们分别用了哪些 key$ umi plugin list --key</span><br></code></pre></td></tr></table></figure><p>结果通常如下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Plugins:<br>    - @umijs/preset-built-in [key: builtIn] (preset)    - @@/registerMethods [key: registerMethods]    - @@/routes [key: routes]    - @@/generateFiles/core/history [key: <span class="hljs-built_in">history</span>]    - @@/generateFiles/core/plugin [key: plugin]    - @@/generateFiles/core/routes [key: routes]    - ...<br></code></pre></td></tr></table></figure><h4 id="在插件里感知其他插件"><a href="#在插件里感知其他插件" class="headerlink" title="在插件里感知其他插件"></a>在插件里感知其他插件</h4><p>可通过 <code>api.hasPlugins(pluginId[])</code> 和 <code>api.hasPresets(pluginId[])</code> 的方式感知其他插件，详见插件 API。</p><h3 id="禁用插件"><a href="#禁用插件" class="headerlink" title="禁用插件"></a>禁用插件</h3><p>有两种方式可禁用插件，</p><h4 id="配置-key-为-false"><a href="#配置-key-为-false" class="headerlink" title="配置 key 为 false"></a>配置 key 为 false</h4><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mock</span>: <span class="hljs-literal">false</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>会禁用 Umi 内置的 mock 插件及其功能。</p><h4 id="在插件里禁用其他插件"><a href="#在插件里禁用其他插件" class="headerlink" title="在插件里禁用其他插件"></a>在插件里禁用其他插件</h4><p>可通过 <code>api.skipPlugins(pluginId[])</code> 的方式禁用，详见插件 API。</p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>通过插件的 key 来配置插件，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mock</span>: &#123; <span class="hljs-attr">exclude</span>: [<span class="hljs-string">&#x27;./foo&#x27;</span>] &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 mock 是 mock 插件的 key。</p><p>再比如我们安装一个插件 <code>umi-plugin-bar</code>，其 key 默认是 <code>bar</code>，就可以这么配置，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">bar</span>: &#123; ...balabala &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h2><p>Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发独立自主，不会被服务端的开发所阻塞。</p><h3 id="约定式-Mock-文件"><a href="#约定式-Mock-文件" class="headerlink" title="约定式 Mock 文件"></a>约定式 Mock 文件</h3><p>Umi 约定 <code>/mock</code> 文件夹下所有文件为 mock 文件。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── mock<br>    ├── api.ts<br>    └── users.ts<br>└── src<br>    └── pages<br>        └── index.tsx<br></code></pre></td></tr></table></figure><p><code>/mock</code> 下的 <code>api.ts</code> 和 <code>users.ts</code> 会被解析为 mock 文件。</p><h3 id="编写-Mock-文件"><a href="#编写-Mock-文件" class="headerlink" title="编写 Mock 文件"></a>编写 Mock 文件</h3><p>如果 <code>/mock/api.ts</code> 的内容如下，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// 支持值为 Object 和 Array  &#x27;GET /api/users&#x27;: &#123; users: [1, 2] &#125;,</span><br>  <span class="hljs-comment">// GET 可忽略  &#x27;/api/users/1&#x27;: &#123; id: 1 &#125;,</span><br>  <span class="hljs-comment">// 支持自定义函数，API 参考 express@4  &#x27;POST /api/users/create&#x27;: (req, res) =&gt; &#123;    // 添加跨域请求头    res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);    res.end(&#x27;ok&#x27;);  &#125;,&#125;</span><br></code></pre></td></tr></table></figure><p>然后访问 <code>/api/users</code> 就能得到 <code>&#123; users: [1,2] &#125;</code> 的响应，其他以此类推。</p><h3 id="配置-Mock"><a href="#配置-Mock" class="headerlink" title="配置 Mock"></a>配置 Mock</h3><p>详见<a href="https://v3.umijs.org/config#mock">配置#mock</a>。</p><h3 id="如何关闭-Mock？"><a href="#如何关闭-Mock？" class="headerlink" title="如何关闭 Mock？"></a>如何关闭 Mock？</h3><p>可以通过配置关闭，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mock</span>: <span class="hljs-literal">false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以通过环境变量临时关闭，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ MOCK=none umi dev<br></code></pre></td></tr></table></figure><h3 id="引入-Mock-js"><a href="#引入-Mock-js" class="headerlink" title="引入 Mock.js"></a>引入 Mock.js</h3><p><a href="http://mockjs.com/">Mock.js</a> 是常用的辅助生成模拟数据的三方库，借助他可以提升我们的 mock 数据能力。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> mockjs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mockjs&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// 使用 mockjs 等三方库  &#x27;GET /api/tags&#x27;: mockjs.mock(&#123;    &#x27;list|100&#x27;: [&#123; name: &#x27;@city&#x27;, &#x27;value|1-100&#x27;: 50, &#x27;type|0-2&#x27;: 1 &#125;],  &#125;),&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="umi-build"><a href="#umi-build" class="headerlink" title="umi build"></a>umi build</h3><p>编译构建 web 产物。通常需要针对部署环境，做特定的配置和环境变量修改。相关详情，请查阅<a href="https://v3.umijs.org/zh-CN/docs/deployment">部署</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi build<br>✔ Webpack  Compiled successfully <span class="hljs-keyword">in</span> 5.54s<br>  DONE  Compiled successfully <span class="hljs-keyword">in</span> 5547ms<br>Build success.✨  Done <span class="hljs-keyword">in</span> 9.77s.<br></code></pre></td></tr></table></figure><p>默认产物输出到项目的 <code>dist</code> 文件夹，你可以通过修改配置 <code>outputPath</code> 指定产物输出目录。 默认编译时会将 <code>public</code> 文件夹内的所有文件，原样拷贝到 <code>dist</code> 目录，如果你不需要这个特性，可以通过配置 <code>chainWebpack</code> 来删除它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">chainWebpack</span>(<span class="hljs-params">memo, &#123; env, webpack &#125;</span>) &#123;<br>    <span class="hljs-comment">// 删除 umi 内置插件</span><br>    memo.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;copy&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果 <code>public</code> 里面存在产物同名文件，如 <code>index.html</code>，将会导致产物文件被覆盖。</p></blockquote><h3 id="umi-dev"><a href="#umi-dev" class="headerlink" title="umi dev"></a>umi dev</h3><p>启动本地开发服务器进行项目的开发调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi dev<br></code></pre></td></tr></table></figure><p>启动在浏览器中运行的开发服务器，并监视源文件变化，自动热加载。</p><p>默认使用 <code>8000</code> 端口，如果 <code>8000</code> 端口被占用，将会使用 <code>8001</code> 端口，以此类推。 你可以通过设置环境变量 <code>PORT</code> 来指定开发端口号。更多环境变量配置，请查阅<a href="https://v3.umijs.org/docs/env-variables">环境变量</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">umi devStarting the development server...<br>✔ Webpack  Compiled successfully <span class="hljs-keyword">in</span> 2.27s<br>  DONE  Compiled successfully <span class="hljs-keyword">in</span> 2276ms<br>  App running at:  - Local:   http://localhost:8000 (copied to clipboard)  - Network: http://192.168.50.236:8000<br></code></pre></td></tr></table></figure><p>开启开发服务还会同时提供一个 Network 的链接，你可以在能访问到你当前运行设备的其他设备中预览页面。</p><blockquote><p>注意：如果是在开启了VPN，或者虚拟机等复杂的网络环境中，这个地址很可能会错误。你可以通过访问你真实可用 <code>ip</code> 的对应端口号来访问开发页面。</p></blockquote><h3 id="umi-generate"><a href="#umi-generate" class="headerlink" title="umi generate"></a>umi generate</h3><p>内置的生成器功能，内置的类型有 <code>page</code> ，用于生成最简页面。支持别名调用 <code>umi g</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi generate &lt;<span class="hljs-built_in">type</span>&gt; &lt;name&gt; [options]<br></code></pre></td></tr></table></figure><p>这个命令支持扩展，通过 <code>api.registerGenerator</code> 注册，你可以通过插件来实现自己常用的生成器。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Generator</span>, <span class="hljs-title class_">IApi</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">const</span> createPagesGenerator = <span class="hljs-keyword">function</span> (<span class="hljs-params">&#123; api &#125;: &#123; api: IApi &#125;</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Generator</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">opts: <span class="hljs-built_in">any</span></span>) &#123;      <span class="hljs-variable language_">super</span>(opts);    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-title function_">writing</span>(<span class="hljs-params"></span>) &#123;&#125;  &#125;;&#125;<br>api.<span class="hljs-title function_">registerGenerator</span>(&#123;  <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;pages&#x27;</span>,  <span class="hljs-title class_">Generator</span>: <span class="hljs-title function_">createPageGenerator</span>(&#123; api &#125;),&#125;);<br>umi generate page pageName<br>umi generate page pageName --typescript<br>umi generate page pageName --less<br></code></pre></td></tr></table></figure><p>更多使用类型和参数，请查阅提供生成器扩展的插件的文档。</p><h3 id="umi-plugin"><a href="#umi-plugin" class="headerlink" title="umi plugin"></a>umi plugin</h3><p>快速查看当前项目使用到的所有的 <code>umi</code> 插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi plugin &lt;<span class="hljs-built_in">type</span>&gt; [options]<br></code></pre></td></tr></table></figure><p>当前支持的 <code>type</code> 是 <code>list</code>，可选参数 <code>key</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi plugin list<br>Plugins:<br>  - @umijs/preset-built-in (preset)  - ./node_modules/umi/lib/plugins/umiAlias<br>✨  Done <span class="hljs-keyword">in</span> 2.27s.<br>$ umi plugin list --key<br>Plugins:<br>  - @umijs/preset-built-in [key: builtIn]  (preset)  - ./node_modules/umi/lib/plugins/umiAlias  [key: builtIn]<br>✨  Done <span class="hljs-keyword">in</span> 2.27s.<br></code></pre></td></tr></table></figure><h3 id="umi-help"><a href="#umi-help" class="headerlink" title="umi help"></a>umi help</h3><p>umi 命令行的简易帮助文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi <span class="hljs-built_in">help</span> &lt;<span class="hljs-built_in">command</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="umi-version"><a href="#umi-version" class="headerlink" title="umi version"></a>umi version</h3><p>查看当前使用的 umi 的版本号，可以使用别名 <code>-v</code> 调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi version<br>$ umi -v<br></code></pre></td></tr></table></figure><h3 id="umi-webpack"><a href="#umi-webpack" class="headerlink" title="umi webpack"></a>umi webpack</h3><p>查看 umi 使用的 webpack 配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi webpack [options]<br></code></pre></td></tr></table></figure><p>参数，</p><table><thead><tr><th>可选参数</th><th>说明</th></tr></thead><tbody><tr><td>rules</td><td>查看 webpack.module.rules 配置详情</td></tr><tr><td>rule&#x3D;[name]</td><td>查看 webpack.module.rules 中某个规则的配置详情</td></tr><tr><td>plugins</td><td>查看 webpack.plugins 配置详情</td></tr><tr><td>plugin&#x3D;[name]</td><td>查看 webpack.plugins 中某个插件的配置详情</td></tr></tbody></table><p>示例，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ umi webpack<br>&#123;  mode: <span class="hljs-string">&#x27;development&#x27;</span>,  devtool: <span class="hljs-string">&#x27;cheap-module-source-map&#x27;</span>,  node:&#123; &#125;,  output:&#123; &#125;,  resolve:&#123; &#125;,  module:&#123;    rules:[ ]  &#125;,  plugins:[ ],  entry:&#123; &#125;&#125;<br>$ umi webpack --rules<br>[  <span class="hljs-string">&#x27;js&#x27;</span>,  <span class="hljs-string">&#x27;ts-in-node_modules&#x27;</span>,  <span class="hljs-string">&#x27;js-in-node_modules&#x27;</span>,  <span class="hljs-string">&#x27;images&#x27;</span>,  <span class="hljs-string">&#x27;svg&#x27;</span>,  <span class="hljs-string">&#x27;fonts&#x27;</span>,  <span class="hljs-string">&#x27;plaintext&#x27;</span>,  <span class="hljs-string">&#x27;css&#x27;</span>,  <span class="hljs-string">&#x27;less&#x27;</span>]<br>$ umi webpack --rule=js<br>&#123;  <span class="hljs-built_in">test</span>: /\.(js|mjs|jsx|ts|tsx)$/,  include: [ <span class="hljs-string">&#x27;xx/umi&#x27;</span> ],  exclude: [ /node_modules/ ],  use:[    &#123;      loader:<span class="hljs-string">&#x27;xx/babel-loader/lib/index.js&#x27;</span>,      options: &#123;        sourceType: <span class="hljs-string">&#x27;unambiguous&#x27;</span>      &#125;    &#125;  ]&#125;<br>$ umi webpack --plugins<br>[  <span class="hljs-string">&#x27;extract-css&#x27;</span>,  <span class="hljs-string">&#x27;define&#x27;</span>,  <span class="hljs-string">&#x27;progress&#x27;</span>,  <span class="hljs-string">&#x27;copy&#x27;</span>,  <span class="hljs-string">&#x27;friendly-error&#x27;</span>,  <span class="hljs-string">&#x27;hmr&#x27;</span>]<br>$ umi webpack --plugin=extract-css<br>MiniCssExtractPlugin &#123;  options:&#123;    filename: <span class="hljs-string">&#x27;[name].css&#x27;</span>,    moduleFilename: [Function: moduleFilename],    ignoreOrder: <span class="hljs-literal">true</span>,    chunkFilename: <span class="hljs-string">&#x27;[name].chunk.css&#x27;</span>  &#125;&#125;<br></code></pre></td></tr></table></figure><p>默认会打印 development 的配置，如需查看 production 配置，需要指定环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ NODE_ENV=production umi webpack<br>&#123;  mode: <span class="hljs-string">&#x27;production&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-CSS"><a href="#使用-CSS" class="headerlink" title="使用 CSS"></a>使用 CSS</h2><blockquote><p>本文档以 css 为示例，把后缀换成 <code>.less</code> 同样适用。</p></blockquote><h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><p>Umi 中约定 <code>src/global.css</code> 为全局样式，如果存在此文件，会被自动引入到入口文件最前面。</p><p>比如用于覆盖样式，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.ant-select-selection</span> &#123;<br>  <span class="hljs-attribute">max-height</span>: <span class="hljs-number">51px</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h3><p>Umi 会自动识别 CSS Modules 的使用，你把他当做 CSS Modules 用时才是 CSS Modules。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// CSS Modulesimport styles from &#x27;./foo.css&#x27;;</span><br><span class="hljs-comment">// 非 CSS Modulesimport &#x27;./foo.css&#x27;;</span><br></code></pre></td></tr></table></figure><h3 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h3><p>Umi 内置支持 less，不支持 sass 和 stylus，但如果有需求，可以通过 chainWebpack 配置或者 umi 插件的形式支持。</p><h3 id="CSS-中引入三方库"><a href="#CSS-中引入三方库" class="headerlink" title="CSS 中引入三方库"></a>CSS 中引入三方库</h3><p>TODO：别名的使用。</p><h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><h3 id="JS-里使用图片"><a href="#JS-里使用图片" class="headerlink" title="JS 里使用图片"></a>JS 里使用图片</h3><p>通过 require 引用相对路径的图片。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;require(</span>&#x27;<span class="hljs-attr">.</span>/<span class="hljs-attr">foo.png</span>&#x27;)&#125; /&gt;</span></span><br></code></pre></td></tr></table></figure><p>支持别名，比如通过 <code>@</code> 指向 src 目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;require(</span>&#x27;@/<span class="hljs-attr">foo.png</span>&#x27;)&#125; /&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="JS-里使用svg"><a href="#JS-里使用svg" class="headerlink" title="JS 里使用svg"></a>JS 里使用svg</h3><p><strong>组件式引入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ReactComponent</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Logo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./logo.svg&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Analysis</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#123;90&#125;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;120&#125;</span> /&gt;</span></span>&#125;<br></code></pre></td></tr></table></figure><p><strong>url式引入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> logoSrc <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./logo.svg&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Analysis</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;logoSrc&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> /&gt;</span></span>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-里使用图片"><a href="#CSS-里使用图片" class="headerlink" title="CSS 里使用图片"></a>CSS 里使用图片</h3><p>通过相对路径引用。</p><p>比如，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./foo.png</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 里也支持别名，但需要在前面加 <code>~</code> 前缀，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">~@/foo.png</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>这是 webpack 的规则，如果切到其他打包工具，可能会有变化</li><li>less 中同样适用</li></ol><h3 id="图片路径问题"><a href="#图片路径问题" class="headerlink" title="图片路径问题"></a>图片路径问题</h3><p>项目中使用图片有两种方式，</p><ol><li>先把图片传到 cdn，然后在 JS 和 CSS 中使用图片的绝对路径</li><li>把图片放在项目里，然后在 JS 和 CSS 中通过相对路径的方式使用</li></ol><p>前者不会有任何问题；后者，如果在 JS 中引用相对路径的图片时，在发布时会根据 publicPath 引入绝对路径，所以就算没有开启 dynamicImport 时，也需要注意 publicPath 的正确性。</p><h3 id="Base64-编译"><a href="#Base64-编译" class="headerlink" title="Base64 编译"></a>Base64 编译</h3><p>通过相对路径引入图片的时候，如果图片小于 10K，会被编译为 Base64，否则会被构建为独立的图片文件。</p><p>10K 这个阈值可以通过 <a href="https://v3.umijs.org/zh-CN/config#inlinelimit">inlineLimit 配置</a>修改。</p><h3 id="使用-CDN"><a href="#使用-CDN" class="headerlink" title="使用 CDN"></a>使用 CDN</h3><p>TODO</p><h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><h3 id="启用按需加载"><a href="#启用按需加载" class="headerlink" title="启用按需加载"></a>启用按需加载</h3><p><strong>常见使用场景</strong>：组件体积太大，不适合直接计入 bundle 中，以免影响首屏加载速度。例如：某组件 HugeA 包含巨大的实现 &#x2F; 依赖了巨大的三方库，且该组件 HugeA 的使用不在首屏显示范围内，可被单独拆出。这时候，<code>dynamic</code> 就该上场了。</p><p>为了简化部署成本，按需加载功能默认是关闭的，你需要在使用之前先通过配置开启，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">dynamicImport</span>: &#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用按需加载"><a href="#使用按需加载" class="headerlink" title="使用按需加载"></a>使用按需加载</h3><h4 id="按需加载组件-dynamic"><a href="#按需加载组件-dynamic" class="headerlink" title="按需加载组件 dynamic"></a>按需加载组件 <code>dynamic</code></h4><p>**为什么使用 <code>dynamic</code>**：封装了使用一个异步组件需要做的状态维护工作，开发者可以更专注于自己的业务组件开发，而不必关心 code spliting、async module loading 等等技术细节。</p><p>通常搭配 <a href="https://github.com/tc39/proposal-dynamic-import">动态 import 语法</a> 使用。</p><p><strong>封装一个异步组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; dynamic &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">dynamic</span>(&#123;  <span class="hljs-attr">loader</span>: <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 这里的注释 webpackChunkName 可以指导 webpack 将该组件 HugeA 以这个名字单独拆出去    const &#123; default: HugeA &#125; = await import(/* webpackChunkName: &quot;external_A&quot; */ &#x27;./HugeA&#x27;);    return HugeA;  &#125;,&#125;);</span><br></code></pre></td></tr></table></figure><p><strong>使用异步组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">AsyncHugeA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AsyncHugeA&#x27;</span>;<br><span class="hljs-comment">// 像使用普通组件一样即可// dynamic 为你做:// 1. 异步加载该模块的 bundle// 2. 加载期间 显示 loading（可定制）// 3. 异步组件加载完毕后，显示异步组件export default () =&gt; &#123;  return &lt;AsyncHugeA /&gt;;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="快速刷新（Fast-Refresh）"><a href="#快速刷新（Fast-Refresh）" class="headerlink" title="快速刷新（Fast Refresh）"></a>快速刷新（Fast Refresh）</h2><blockquote><p>快速刷新（Fast Refresh）是 React 官方为 React Native 开发的模块热替换（HMR）方案，由于其核心实现与平台无关，同时也适用于 Web。</p></blockquote><p>Fast Refresh 功能最大的特性是：开发环境下，可以<strong>保持组件状态</strong>，同时编辑提供<strong>即时反馈</strong>。</p><h3 id="怎样使用？"><a href="#怎样使用？" class="headerlink" title="怎样使用？"></a>怎样使用？</h3><p>在<a href="https://v3.umijs.org/zh-CN/docs/config">配置文件</a>加上 <code>fastRefresh: &#123;&#125;</code> 即可开启</p><p>这张 gif 动图展示的是使用 Fast Refresh 特性的开发体验，可以看出，修改组件代码后，用户名和密码<strong>状态保持</strong>，这将提升应用本地研发体验。</p><p><img src="https://gw.alipayobjects.com/zos/antfincdn/B2biHHW6s%24/fast-refresh.gif" alt="img"></p><p>开发方式上与平时没有区别，正常地修改、保存、预览，只是在效果反馈上，体验更加好。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>有些情况下，维持状态并不是预期，所以为了可靠起见，Fast Refresh 遇到以下情况一概不保留状态（remount）：</p><ul><li>Class 类组件一律重刷（remount），状态会被重置，包括高阶组件返回的 Class 组件</li><li>不纯组件模块，所编辑的模块除导出 React 组件外，还导出了其它模块</li><li>特殊的，还可以通过 <code>// @refresh reset</code> 指令（在源码文件中任意位置加上这行注释）强制重刷（remount），最大限度地保证可用性</li></ul><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>推荐写函数命名组件，例如：</p><p>✅ Good:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Foo</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Foo</span>;<br></code></pre></td></tr></table></figure><p>❌ Bad:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="TypeError-Cannot-read-property-‘forEach’-of-undefined"><a href="#TypeError-Cannot-read-property-‘forEach’-of-undefined" class="headerlink" title="TypeError: Cannot read property ‘forEach’ of undefined"></a>TypeError: Cannot read property ‘forEach’ of undefined</h4><p>请检查浏览器扩展 React DevTools 的版本，是否小于 v4，请升级至 v4 版本可解决。<a href="https://github.com/umijs/umi/issues/6432">issue#6432</a></p><h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><h3 id="默认方案"><a href="#默认方案" class="headerlink" title="默认方案"></a>默认方案</h3><p>Umi 默认对新手友好，所以默认不做按需加载处理，<code>umi build</code> 后输出 <code>index.html</code>、<code>umi.js</code> 和 <code>umi.css</code> 三个文件。</p><h3 id="不输出-html-文件"><a href="#不输出-html-文件" class="headerlink" title="不输出 html 文件"></a>不输出 html 文件</h3><p>某些场景 html 文件交给后端输出，前端构建并不需要输出 html 文件，可配置环境变量 <code>HTML=none</code> 实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ HTML=none umi build<br></code></pre></td></tr></table></figure><h3 id="部署-html-到非根目录"><a href="#部署-html-到非根目录" class="headerlink" title="部署 html 到非根目录"></a>部署 html 到非根目录</h3><p>经常有同学问这个问题：</p><blockquote><p>为什么我本地开发是好的，部署后就没反应了，而且没有报错？</p></blockquote><p><strong>没有报错！</strong> 这是应用部署在非根路径的典型现象。为啥会有这个问题？因为路由没有匹配上，比如你把应用部署在 <code>/xxx/</code> 下，然后访问 <code>/xxx/hello</code>，而代码里匹配的是 <code>/hello</code>，那就匹配不上了，而又没有定义 fallback 的路由，比如 404，那就会显示空白页。</p><p>怎么解决？</p><p>可通过配置 <a href="https://v3.umijs.org/zh-CN/config#base">base</a> 解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  base: <span class="hljs-string">&#x27;/path/to/your/app/root&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用-hash-history"><a href="#使用-hash-history" class="headerlink" title="使用 hash history"></a>使用 hash history</h3><p>可通过配置 <a href="https://v3.umijs.org/zh-CN/config#history">history</a> 为 <code>hash</code> 为解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-built_in">history</span>: &#123; <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;hash&#x27;</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="按需加载-1"><a href="#按需加载-1" class="headerlink" title="按需加载"></a>按需加载</h3><p>要实现按需加载，需配置 <a href="https://v3.umijs.org/zh-CN/config#dynamicimport">dynamicImport</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">dynamicImport</span>: &#123;&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="静态资源在非根目录或-cdn"><a href="#静态资源在非根目录或-cdn" class="headerlink" title="静态资源在非根目录或 cdn"></a>静态资源在非根目录或 cdn</h3><p>这时，就需要配置 <a href="https://v3.umijs.org/zh-CN/config#publicpath">publicPath</a>。至于 publicPath 是啥？具体看 <a href="https://webpack.js.org/configuration/output/#output-publicpath">webpack 文档</a>，把他指向静态资源（js、css、图片、字体等）所在的路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;http://yourcdn/path/to/static/&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-runtime-的-publicPath"><a href="#使用-runtime-的-publicPath" class="headerlink" title="使用 runtime 的 publicPath"></a>使用 runtime 的 publicPath</h3><p>对于需要在 html 里管理 publicPath 的场景，比如在 html 里判断环境做不同的输出，可通过配置 <a href="https://v3.umijs.org/zh-CN/config/#runtimepublicpath">runtimePublicPath</a> 为解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">runtimePublicPath</span>: <span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在 html 里输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">publicPath</span> = &lt;%= <span class="hljs-variable constant_">YOUR</span> <span class="hljs-variable constant_">PUBLIC_PATH</span> %&gt;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h3><p>在一些场景中，无法做服务端的 html fallback，即让每个路由都输出 index.html 的内容，那么就要做静态化。</p><p>比如上面的例子，我们在 .umirc.js 里配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">exportStatic</span>: &#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行 umi build，会为每个路由输出一个 html 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs unknown">./dist<br>├── index.html<br>├── list<br>│   └── index.html<br>└── static<br>    ├── pages__index.5c0f5f51.async.js<br>    ├── pages__list.f940b099.async.js<br>    ├── umi.2eaebd79.js<br>    └── umi.f4cb51da.css<br></code></pre></td></tr></table></figure><blockquote><p>注意：静态化暂不支持有变量路由的场景。</p></blockquote><h3 id="HTML-后缀"><a href="#HTML-后缀" class="headerlink" title="HTML 后缀"></a>HTML 后缀</h3><p>有些静态化的场景里，是不会自动读索引文件的，比如支付宝的容器环境，那么就不能生成这种 html 文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs unknown">├── index.html<br>├── list<br>│   └── index.html<br></code></pre></td></tr></table></figure><p>而是生成，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs unknown">├── index.html<br>└── list.html<br></code></pre></td></tr></table></figure><p>配置方式是在 .umirc.js 里，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">exportStatic</span>: &#123;<br>    <span class="hljs-attr">htmlSuffix</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>umi build 会生成，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs unknown">./dist<br>├── index.html<br>├── list.html<br>└── static<br>    ├── pages__index.5c0f5f51.async.js<br>    ├── pages__list.f940b099.async.js<br>    ├── umi.2924fdb7.js<br>    └── umi.cfe3ffab.css<br></code></pre></td></tr></table></figure><h3 id="静态化后输出到任意路径"><a href="#静态化后输出到任意路径" class="headerlink" title="静态化后输出到任意路径"></a>静态化后输出到任意路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">exportStatic</span>: &#123;<br>    <span class="hljs-attr">htmlSuffix</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">dynamicRoot</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>umi框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css</title>
    <link href="/blog/2022/11/20/css/"/>
    <url>/blog/2022/11/20/css/</url>
    
    <content type="html"><![CDATA[<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><blockquote><ol><li><a href="https://www.w3school.com.cn/css/index.asp">https://www.w3school.com.cn/css/index.asp</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn">https://developer.mozilla.org/zh-CN/docs/Learn</a></li></ol></blockquote><p><img src="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics/css-declaration-small.png" alt="图解 CSS 声明"></p><p>整个结构称为 <strong>规则集</strong>（通常简称“规则”），各部分释义如下：</p><ul><li><p>选择器（<strong>Selector</strong>）</p><p>HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 <code>p</code> 元素）。要给不同元素添加样式只需要更改选择器就行了。</p></li><li><p>声明（<strong>Declaration</strong>）</p><p>一个单独的规则，如 <code>color: red;</code> 用来指定添加样式元素的<strong>属性</strong>。</p></li><li><p>属性（<strong>Properties</strong>）</p><p>改变 HTML 元素样式的途径。（本例中 <code>color</code> 就是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p">&#96;&#96;</a> 元素的属性。）CSS 中，由编写人员决定修改哪个属性以改变规则。</p></li><li><p>属性的值（Property value）</p><p>在属性的右边，冒号后面即<strong>属性的值</strong>，它从指定属性的众多外观中选择一个值（我们除了 <code>red</code> 之外还有很多属性值可以用于 <code>color</code> ）。</p></li></ul><p>注意其他重要的语法：</p><ul><li>每个规则集（除了选择器的部分）都应该包含在成对的大括号里（<code>&#123;&#125;</code>）。</li><li>在每个声明里要用冒号（<code>:</code>）将属性与属性值分隔开。</li><li>在每个规则集里要用分号（<code>;</code>）将各个声明分隔开。</li></ul><p>如果要同时修改多个属性，只需要将它们用分号隔开，就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-选择器"><a href="#2-1-选择器" class="headerlink" title="2.1 选择器"></a>2.1 选择器</h3><h4 id="不同类型的选择器"><a href="#不同类型的选择器" class="headerlink" title="不同类型的选择器"></a><strong>不同类型的选择器</strong></h4><p>选择器有许多不同的类型。上面只介绍了<strong>元素选择器</strong>，用来选择 HTML 文档中给定的元素。但是选择操作可以更加具体。下面是一些常用的选择器类型：</p><table><thead><tr><th align="left">选择器名称</th><th align="left">选择的内容</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">元素选择器（也称作标签或类型选择器）</td><td align="left">所有指定 (该) 类型的 HTML 元素</td><td align="left"><code>p</code> 选择 <code>&lt;p&gt;</code></td></tr><tr><td align="left">ID 选择器</td><td align="left">具有特定 ID 的元素（单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID）</td><td align="left"><code>#my-id</code> 选择 <code>&lt;p id=&quot;my-id&quot;&gt;</code> 或 <code>&lt;a id=&quot;my-id&quot;&gt;</code></td></tr><tr><td align="left">类选择器</td><td align="left">具有特定类的元素（单一页面中，一个类可以有多个实例）</td><td align="left"><code>.my-class</code> 选择 <code>&lt;p class=&quot;my-class&quot;&gt;</code> 和 <code>&lt;a class=&quot;my-class&quot;&gt;</code></td></tr><tr><td align="left">属性选择器</td><td align="left">拥有特定属性的元素</td><td align="left"><code>img[src]</code> 选择 <code>&lt;img src=&quot;myimage.png&quot;&gt;</code> 而不是 <code>&lt;img&gt;</code></td></tr><tr><td align="left">伪（Pseudo）类选择器</td><td align="left">特定状态下的特定元素（比如鼠标指针悬停）</td><td align="left"><code>a:hover</code> 仅在鼠标指针悬停在链接上时选择 <code>&lt;a&gt;</code>。</td></tr></tbody></table><h4 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a><strong>选择器列表</strong></h4><p>如果你有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。例如，如果我的<code>h1</code>和<code>.special</code>类有相同的 CSS，那么我可以把它们写成两个分开的规则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>我也可以将它们组合起来，在它们之间加上一个逗号，变为选择器列表。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>空格可以在逗号前或后，你可能还会发现如果每个选择器都另起一行，会更好读些。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的实时示例中，试着把两个有相同声明的选择器组合起来。外观在组合起来以后应该还是一样的。</p><p>当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。</p><h4 id="选择器种类"><a href="#选择器种类" class="headerlink" title="选择器种类"></a><strong>选择器种类</strong></h4><p><strong>标签属性选择器</strong></p><p>这组选择器根据一个元素上的某个标签的属性的存在以选择元素的不同方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>或者根据一个有特定值的标签属性是否存在来选择：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a><strong>伪类与伪元素</strong></h4><p>这组选择器包含了伪类，用来样式化一个元素的特定状态。例如<code>:hover</code>伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。例如，<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行，类似<code>&lt;span&gt;</code>包在了第一个被格式化的行外面，然后选择这个<code>&lt;span&gt;</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h4><p>最后一组选择器可以将其他选择器组合起来，更复杂的选择元素。下面的示例用运算符（<code>&gt;</code>）选择了<code>&lt;article&gt;</code>元素的初代子元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a><strong>全局选择器</strong></h4><p>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容，比如，它紧随在其他元素以及邻代运算符之后的时候）。下面的示例中，我们已经用全局选择器，移去了所有元素上的外边距。这就是说，和浏览器以外边距隔开标题和段的方式默认加上的样式不同的是，每个物件都紧紧地挨在一起，我们不能那么容易就看清楚不同的段。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种行为有时能在“重置样式表”中看到，其中所有浏览器所做的样式化都会被忽略。这些一度很受欢迎，但是把所有的样式化忽略掉的话，通常就是指，你必须做把这些样式带回来的工作！因此我们应小心使用全局选择器，以处理诸如下面所述之类的很特殊的情况。</p><p>全局选择器的一种用法是让选择器更易读，更明显地表明它们的作用。例如，如果我想选中任何<code>&lt;article&gt;</code>元素的第一子元素，不论它是什么元素，都给它加粗，我可以将<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a>选择器（我们将会在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">伪类和伪元素</a>课中进一步了解）用作<code>&lt;article&gt;</code>元素选择器的一个后代选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> <span class="hljs-selector-pseudo">:first</span>-child &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这会和<code>article:first-child</code>混淆，而后者选择了作为其他元素的第一子元素的<code>&lt;article&gt;</code>元素。</p><p>为了避免这种混淆，我们可以向<code>:first-child</code>选择器加入全局选择器，这样选择器所做的事情很容易就能看懂。选择器正选中<code>&lt;article&gt;</code>元素的<em>任何</em>第一子元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> *<span class="hljs-selector-pseudo">:first</span>-child &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多个类被应用的时候指向一个元素"><a href="#多个类被应用的时候指向一个元素" class="headerlink" title="多个类被应用的时候指向一个元素"></a><strong>多个类被应用的时候指向一个元素</strong></h4><p>你能对一个元素应用多个类，然后分别指向它们，或者仅仅在选择器中存在所有这些类的时候选择这一元素。在你的站点上，构建可以以不同方式组合起来的组件的时候，这会有用。</p><p>在下面的示例中，有一个包含了一条笔记的<code>&lt;div&gt;</code>。灰色的边框在盒子带有<code>notebox</code>类的时候应用。如果它还有一个<code>warning</code>或是<code>danger</code>类，我们改变<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a>。</p><p>为了告诉浏览器我们只想匹配带有所有这些类的元素，我们可以将这些类不加空格地连成一串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox&quot;</span>&gt;</span><br>    This is an informational note.<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox warning&quot;</span>&gt;</span><br>    This note shows a warning.<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;notebox danger&quot;</span>&gt;</span><br>    This note shows danger!<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;danger&quot;</span>&gt;</span><br>    This won&#x27;t get styled — it also needs to have the notebox class<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.notebox</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#666</span>;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.warning</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: orange;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.danger</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: red;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225135912071-20230305%2010:50:47.png" alt="image-20230225135912071"></p><h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a><strong>ID 选择器</strong></h4><p>ID 选择器开头为<code>#</code>而非句点，不过基本上和类选择器是同种用法。可是在一篇文档中，一个 ID 只会用到一次。它能选中设定了<code>id</code>的元素，你可以在 ID 前面加上类型选择器，只指向元素和 ID 都匹配的类。在下面的示例里，你可以看看这两种用法。</p><p><em>备注：</em>正如我们在和特定性相关的课里面学到的那样，ID 所指特定，会优先于大多数其他选择器。所以很难处理它们。大多数情况下，给一个元素加个类，而不是使用 ID，会更好。不过要是 ID 是唯一一种指定这个元素的方式的话——也许是因为你没法访问标记标记因此不能编辑——这种方式可行。</p><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><p>从 HTML 的学习中，你已经知道，元素可以带有属性，它提供了关于如何标记的更详细信息。CSS 中，你能用属性选择器来选中带有特定属性的元素。本节课中，我们将会为你展示如何使用这些很有用的选择器。</p><p><strong>存否和值选择器</strong></p><p>这些选择器允许基于一个元素自身是否存在（例如<code>href</code>）或者基于各式不同的按属性值的匹配，来选取元素。</p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[attr]</code></td><td align="left"><code>a[title]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td></tr><tr><td align="left"><code>[attr=value]</code></td><td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td></tr><tr><td align="left"><code>[attr~=value]</code></td><td align="left"><code>p[class~=&quot;special&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td></tr><tr><td align="left">&#96;[attr</td><td align="left">&#x3D;value]&#96;</td><td align="left">&#96;div[lang</td></tr></tbody></table><p>下面的示例中，你可以看到这些选择器是怎样使用的。</p><ul><li>使用<code>li[class]</code>，我们就能匹配任何有 class 属性的选择器。这匹配了除了第一项以外的所有项。</li><li><code>li[class=&quot;a&quot;]</code>匹配带有一个<code>a</code>类的选择器，不过不会选中一部分值为<code>a</code>而另一部分是另一个用空格隔开的值的类，它选中了第二项。</li><li><code>li[class~=&quot;a&quot;]</code>会匹配一个<code>a</code>类，不过也可以匹配一列用空格分开、包含<code>a</code>类的值，它选中了第二和第三项。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Attribute presence and value selectors<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a b&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ab&quot;</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class]</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">200%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class~=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225140919072-20230305%2010:51:16.png" alt="image-20230225140919072"></p><p><strong>子字符串匹配选择器</strong></p><p>这些选择器让更高级的属性的值的子字符串的匹配变得可行。例如，如果你有<code>box-warning</code>和<code>box-error</code>类，想把开头为“box-”字符串的每个物件都匹配上的话，你可以用<code>[class^=&quot;box-&quot;]</code>来把它们两个都选中。</p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[attr^=value]</code></td><td align="left"><code>li[class^=&quot;box-&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td></tr><tr><td align="left"><code>[attr$=value]</code></td><td align="left"><code>li[class$=&quot;-box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td></tr><tr><td align="left"><code>[attr*=value]</code></td><td align="left"><code>li[class*=&quot;box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td></tr></tbody></table><p>下个示例展示了这些选择器的用法：</p><ul><li><code>li[class^=&quot;a&quot;]</code>匹配了任何值开头为<code>a</code>的属性，于是匹配了前两项。</li><li><code>li[class$=&quot;a&quot;]</code>匹配了任何值结尾为<code>a</code>的属性，于是匹配了第一和第三项。</li><li><code>li[class*=&quot;a&quot;]</code>匹配了任何值的字符串中出现了<code>a</code>的属性，于是匹配了所有项。</li></ul><p><strong>大小写敏感</strong></p><p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。这个标记告诉浏览器，要以大小写不敏感的方式匹配 ASCII 字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式，进行匹配——HTML 中是大小写敏感的。</p><p>下面的示例中，第一个选择器将会匹配一个开头为<code>a</code>的值，这样它只匹配了第一项，因为另外两项开头是大写的 A。第二个选择器使用了大小写不敏感的标记，于是匹配了所有项。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span> i]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>备注：</em>此外还有一个更加新的<code>s</code>值，它会强制在上下文的匹配正常为大小写不敏感的时候，强行要求匹配时大小写敏感。不过，在浏览器中它不太受支持，而且在上下文为 HTML 时也没啥用。</p><h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p>下一组我们将了解的选择器被称为<strong>伪类</strong>和<strong>伪元素</strong>。这一类选择器的数量众多，通常用于很明确的目的。一旦你了解了如何使用它们，你便可以通过查阅列表来寻找合适的那一项以完成你想要的选择。与之前一样，每个选择器相关的 MDN 页面都将帮助你了解各浏览器的支持情况。</p><p><strong>什么是伪类</strong></p><p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。</p><p>伪类就是开头为冒号的关键字：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">:pseudo-class-name<br></code></pre></td></tr></table></figure><p>我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a>伪类选择器——这将<em>一直</em>选中文章中的第一个子元素，我们将不再需要编辑 HTML（编辑 HTML 并不总是可行，也许是因为它是由一个 CMS 生成的）。</p><p>所有的伪类以同样的方式实现。它们选中你的文档中处于某种状态的那部分，表现得就像是你已经向你的 HTML 加入类一样。看下 MDN 上的另外几个示例：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></li></ul><p>更多伪类用法参考：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-broken">https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-broken</a></p><h4 id="用户行为伪类"><a href="#用户行为伪类" class="headerlink" title="用户行为伪类"></a>用户行为伪类</h4><p>一些伪类只会在用户以某种方式和文档交互的时候应用。这些<strong>用户行为伪类</strong>，有时叫做<strong>动态伪类</strong>，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。案例包括：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a>——上面提到过，只会在用户将指针挪到元素上的时候才会激活，一般就是链接元素。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a>——只会在用户使用键盘控制，选定元素的时候激活。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">color</span>: rebeccapurple;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>:hotpink;<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>伪元素</strong></p><p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:</span><span class="hljs-symbol">:pseudo-element-name</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p></blockquote><p>例如，如果你想选中一段的第一行，你可以把它用一个<code>&lt;span&gt;</code>元素包起来，然后使用元素选择器；不过，如果包起来的单词&#x2F;字符数目长于或者短于父元素的宽度，这样做会失败。由于我们一般不会知道一行能放下多少单词&#x2F;字符——因为屏幕宽度或者字体大小改变的时候这也会变——通过改变 HTML 的方式来可预测地这么做是不可能的。</p><p><code>::first-line</code>伪元素选择器会值得信赖地做到这件事——即使单词&#x2F;字符的数目改变，它也只会选中第一行。</p><p>这表现得就像是<code>&lt;span&gt;</code>神奇地包在第一个被格式化的行一样，每当行长改变的时候还会更新。</p><p>你可以看到它把两段的第一行都选中了。</p><p><strong>把伪类和伪元素组合起来</strong></p><p>如果你想让第一段的第一行加粗，你需要把<code>:first-child</code>和<code>::first-line</code>选择器放到一起。试着编辑前面的实时示例，让它使用下面的 CSS。这里的意思是，我们想选择一个<code>&lt;article&gt;</code>元素里面的第一个<code>&lt;p&gt;</code>元素的第一行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child<span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">120%</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生成带有::before 和::after 的内容</strong></p><p>有一组特别的伪元素，它们和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性一同使用，使用 CSS 将内容插入到你的文档中中。c</p><p>你能用这些插入一个文本字符串，和在下面的实时示例里那样。试着改变<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性的文本值，看看输出是怎么改变的。你也能改变<code>::before</code>伪元素为<code>::after</code>，看到这段文本插入到了元素的末尾而不是开头。</p><p>从 CSS 插入文本字符串，我们并不会在 Web 浏览器上经常这么做，因为对于一些屏幕阅读器来说，文本是不可见的，而且对于未来别人的查找和编辑也不是很方便。</p><p>这些伪元素的更推荐的用法是插入一个图标，例如下面的示例加入的一个小箭头，作为一个视觉性的提示，而且我们并不希望屏幕阅读器读出它。</p><p>这些伪元素经常用于插入空字符串，其后可以像页面上的其他元素被样式化。</p><p>下个示例，我们已经用 <code>::before</code>伪元素加入了个空字符串。我们把它设为了<code>display: block</code>，以让它可以用 width 和 height 进行样式化。然后我们可以用 CSS 像任何元素那样样式化。你可以摆弄 CSS，改变它的外观和行为。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>Content in the box in my HTML page.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225142817596-20230305%2010:51:40.png" alt="image-20230225142817596"></p><p><code>::before</code>和<code>::after</code>伪元素与<code>content</code>属性的共同使用，在 CSS 中被叫做“生成内容”，而且你会见到这种技术被用于完成各种任务。<a href="http://www.cssarrowplease.com/">CSS Arrow Please</a>网站就是一个著名的示例，它帮你用 CSS 生成一个箭头。在你创建你的箭头的时候看下 CSS，你将会看到实际使用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a>伪元素。无论什么时候你看到了这些选择器，都要看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性，以了解文档中添加了什么。</p><h4 id="x3D-x3D-参考节-x3D-x3D"><a href="#x3D-x3D-参考节-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;参考节&#x3D;&#x3D;"></a>&#x3D;&#x3D;参考节&#x3D;&#x3D;</h4><p>有很多伪类和伪元素，所以有一个用于参考的列表会有用。下面是列出它们的表格，链接到了 MDN 上它们的参考页。把这作为参考，看看你能选中什么。</p><p><strong>伪类</strong></p><table><thead><tr><th align="left">选择器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a></td><td align="left">在用户激活（例如点击）元素的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link"><code>:any-link</code></a></td><td align="left">匹配一个链接的<code>:link</code>和<code>:visited</code>状态。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:blank"><code>:blank</code></a></td><td align="left">匹配空输入值的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input">&#96;&#96;元素</a>。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked"><code>:checked</code></a></td><td align="left">匹配处于选中状态的单选或者复选框。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:current"><code>:current</code> (en-US)</a></td><td align="left">匹配正在展示的元素，或者其上级元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default"><code>:default</code></a></td><td align="left">匹配一组相似的元素中默认的一个或者更多的 UI 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir"><code>:dir</code></a></td><td align="left">基于其方向性（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/dir"><code>dir</code></a>属性或者 CSS<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>属性的值）匹配一个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled"><code>:disabled</code></a></td><td align="left">匹配处于关闭状态的用户界面元素</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty"><code>:empty</code></a></td><td align="left">匹配除了可能存在的空格外，没有子元素的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled"><code>:enabled</code></a></td><td align="left">匹配处于开启状态的用户界面元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first"><code>:first</code></a></td><td align="left">匹配<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Paged_Media">分页媒体</a>的第一页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a></td><td align="left">匹配兄弟元素中的第一个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type"><code>:first-of-type</code></a></td><td align="left">匹配兄弟元素中第一个某种类型的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a></td><td align="left">当一个元素有焦点的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible"><code>:focus-visible</code></a></td><td align="left">当元素有焦点，且焦点对用户可见的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within"><code>:focus-within</code></a></td><td align="left">匹配有焦点的元素，以及子代元素有焦点的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:future"><code>:future</code> (en-US)</a></td><td align="left">匹配当前元素之后的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a></td><td align="left">当用户悬浮到一个元素之上的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate"><code>:indeterminate</code></a></td><td align="left">匹配未定态值的 UI 元素，通常为<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input/checkbox">复选框</a>。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range"><code>:in-range</code></a></td><td align="left">用一个区间匹配元素，当值处于区间之内时匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></td><td align="left">匹配诸如<code>&lt;input&gt;</code>的位于不可用状态的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang"><code>:lang</code></a></td><td align="left">基于语言（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang">lang</a>属性的值）匹配元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></td><td align="left">匹配兄弟元素中最末的那个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type"><code>:last-of-type</code></a></td><td align="left">匹配兄弟元素中最后一个某种类型的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left"><code>:left</code></a></td><td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 (en-US)</a>中，匹配左手边的页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a></td><td align="left">匹配未曾访问的链接。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:local-link"><code>:local-link</code> (en-US)</a></td><td align="left">匹配指向和当前文档同一网站页面的链接。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a></td><td align="left">匹配传入的选择器列表中的任何选择器。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not"><code>:not</code></a></td><td align="left">匹配作为值传入自身的选择器未匹配的物件。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a></td><td align="left">匹配一列兄弟元素中的元素——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type"><code>:nth-of-type</code></a></td><td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child"><code>:nth-last-child</code></a></td><td align="left">匹配一列兄弟元素，从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type"><code>:nth-last-of-type</code></a></td><td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素），从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></td><td align="left">匹配没有兄弟元素的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type"><code>:only-of-type</code></a></td><td align="left">匹配兄弟元素中某类型仅有的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional"><code>:optional</code></a></td><td align="left">匹配不是必填的 form 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range"><code>:out-of-range</code></a></td><td align="left">按区间匹配元素，当值不在区间内的的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:past"><code>:past</code> (en-US)</a></td><td align="left">匹配当前元素之前的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown"><code>:placeholder-shown</code></a></td><td align="left">匹配显示占位文字的 input 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:playing"><code>:playing</code> (en-US)</a></td><td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:paused"><code>:paused</code> (en-US)</a></td><td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only"><code>:read-only</code></a></td><td align="left">匹配用户不可更改的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write"><code>:read-write</code></a></td><td align="left">匹配用户可更改的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required"><code>:required</code></a></td><td align="left">匹配必填的 form 元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right"><code>:right</code></a></td><td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 (en-US)</a>中，匹配右手边的页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a></td><td align="left">匹配文档的根元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope"><code>:scope</code></a></td><td align="left">匹配任何为参考点元素的的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid"><code>:valid</code></a></td><td align="left">匹配诸如<code>&lt;input&gt;</code>元素的处于可用状态的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target"><code>:target</code></a></td><td align="left">匹配当前 URL 目标的元素（例如如果它有一个匹配当前<a href="https://en.wikipedia.org/wiki/Fragment_identifier">URL 分段</a>的元素）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a></td><td align="left">匹配已访问链接。</td></tr></tbody></table><p><strong>伪元素</strong></p><table><thead><tr><th align="left">选择器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a></td><td align="left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a></td><td align="left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter"><code>::first-letter</code></a></td><td align="left">匹配元素的第一个字母。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line"><code>::first-line</code></a></td><td align="left">匹配包含此伪元素的元素的第一行。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error"><code>::grammar-error</code></a></td><td align="left">匹配文档中包含了浏览器标记的语法错误的那部分。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection"><code>::selection</code></a></td><td align="left">匹配文档中被选择的那部分。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error"><code>::spelling-error</code></a></td><td align="left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td></tr></tbody></table><h4 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h4><p>我们要了解的最后一种选择器被命名为关系选择器（Combinator），这是因为它们在其他选择器之间和其他选择器与文档内容的位置之间建立了一种有用的关系的缘故。</p><p><strong>后代选择器</strong></p><p>后代选择器——典型用单个空格（” “）字符——组合两个选择器，比如，第二个选择器匹配的元素被选择，如果他们有一个祖先（父亲，父亲的父亲，父亲的父亲的父亲，等等）元素匹配第一个选择器。选择器利用后代组合符被称作后代选择器。</p><p>下面的示例中，我们只会匹配处于带有<code>.box</code>类的元素里面的<code>&lt;p&gt;</code>元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Text in .box<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Text not in .box<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>子代关系选择器</strong></p><p>子代关系选择器是个大于号（<code>&gt;</code>），只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。例如，只选中作为<code>&lt;article&gt;</code>的直接子元素的<code>&lt;p&gt;</code>元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p><strong>邻接兄弟</strong></p><p>邻接兄弟选择器（<code>+</code>）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件。例如，选中所有紧随<code>&lt;p&gt;</code>元素之后的<code>&lt;img&gt;</code>元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>通用兄弟</strong></p><p>如果你想选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（<code>~</code>）。要选中所有的<code>&lt;p&gt;</code>元素后<em>任何地方</em>的<code>&lt;img&gt;</code>元素，我们会这样做：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> ~ <span class="hljs-selector-tag">img</span><br></code></pre></td></tr></table></figure><p><strong>使用关系选择器</strong></p><p>你能用关系选择器，将任何在我们前面的学习过程中学到的选择器组合起来，选出你的文档中的一部分。例如如果我们想选中为<code>&lt;ul&gt;</code>的直接子元素的带有“a”类的列表项的话，我可以用下面的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class=<span class="hljs-string">&quot;a&quot;</span>]</span>  &#123;  &#125;<br></code></pre></td></tr></table></figure><p>不过，建立一长列选中你的文档中很明确的部分的选择器的时候，小心一些。这些 CSS 规则难以复用，因为你让选择器在表示标记文本中的元素的相对位置上过于明确。</p><p>建立简单的一个类，然后把它应用到有需求的元素上，经常会是更好的做法。不过话说回来，如果你需要让你的文档变换一下样式，但是没法编辑 HTML（也许是因为它由 CMS 生成）的话，你的关系选择器的知识会派上用场。</p><h3 id="2-2-盒模型"><a href="#2-2-盒模型" class="headerlink" title="2.2 盒模型"></a>2.2 盒模型</h3><p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用 CSS 实现准确布局、处理元素排列的关键。</p><p>本文围绕“盒模型”为主题展开。旨在于完成学习后，您能够在“理解盒装模型原理”的基础上，完成更加复杂的布局任务。 </p><h4 id="块级盒子（Block-box）和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box）和 内联盒子（Inline box）"></a><strong>块级盒子（Block box）和 内联盒子（Inline box）</strong></h4><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)。这两种盒子会在<strong>页面流</strong>（page flow）和元素之间的关系方面表现出不同的行为：</p><p>一个被定义成块级的（block）盒子会表现出以下行为：</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性可以发挥作用</li><li>内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题 (<code>&lt;h1&gt;</code>等) 和段落 (<code>&lt;p&gt;</code>) 默认情况下都是块级的盒子。</p><p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下：</p><ul><li>盒子不会产生换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性将不起作用。</li><li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li><li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。</li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><p><strong>补充：内部和外部显示类型</strong></p><p>在这里最好也解释下<strong>内部</strong> 和 <strong>外部</strong> 显示类型。如上所述，css 的 box 模型有一个外部显示类型，来决定盒子是块级还是内联。</p><p>同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 **<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow">正常文档流</a> **布局，也意味着它们和其他块元素以及内联元素一样 (如上所述).</p><p>但是，我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。该盒子的所有直接子元素都会成为 flex 元素，会根据<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">弹性盒子（Flexbox）</a>规则进行布局，稍后您将了解这些规则。</p><p>当你进一步了解 css 布局的更多细节的时候，你会了解到 <code>flex</code>，和其他内部显示类型会用到的值，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids"><code>grid</code></a> 。</p><p>块级和内联布局是 web 上默认的行为 —— 正如上面所述，它有时候被称为 <em>正常文档流</em>，因为如果没有其他说明，我们的盒子布局默认是块级或者内联。</p><h4 id="不同显示的例子"><a href="#不同显示的例子" class="headerlink" title="不同显示的例子"></a>不同显示的例子</h4><p>让我们继续看看别的例子。下面三个 html 元素，都有一个外部显示类型 <code>block</code>。第一个是一个段落，在 CSS 中加了边框。浏览器把它渲染成一个块级盒子，所以段落从新的一行开始，而且宽度占满一行。</p><p>第二个是一个列表，布局属性是 <code>display: flex</code>。将在容器中建立一个 flex 布局，但是每个列表是一个块级元素 —— 像段落一样 —— 会充满整个容器的宽度并且换行。</p><p>下面有个块级段落，里面有两个 <code>&lt;span&gt;</code> 元素。正常情况下是 <code>inline</code>，但是其中一个加了 block 类，设置属性 <code>display: block</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am a paragraph. A short one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item One<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item Two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item Three<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am another paragraph. Some of the <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;block&quot;</span>&gt;</span>words<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> have been wrapped in a <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span element<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>, <br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid rebeccapurple;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.block</span>,<br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue;<br>  <span class="hljs-attribute">padding</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-selector-class">.block</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225145508512-20230305%2010:52:00.png" alt="image-20230225145508512"></p><p>我们可以看到 <code>inline</code> 元素在下面例子中的表现。 <code>&lt;span&gt;</code> 在第一段默认是内联元素所以不换行。</p><p>还有一个 <code>&lt;ul&gt;</code> 设置为 <code>display: inline-flex</code>，使得在一些 flex 元素外创建一个内联框。</p><p>最后设置两个段落为 <code>display: inline</code>。inline flex 容器和段落在一行上而不是像块级元素一样换行。</p><p><strong>你可以修改 <code>display: inline</code> 为 <code>display: block</code> 或者 <code>display: inline-flex</code> 改为 <code>display: flex</code> 来观察显示模式切换。</strong></p><p>在后面的内容中会遇到诸如弹性盒子布局的内容；现在需要记住的是， <code>display</code> 属性可以改变盒子的外部显示类型是块级还是内联，这将会改变它与布局中的其他元素的显示方式。</p><p>剩下的内容，我们会专注于外部显示类型。</p><h4 id="什么是-CSS-盒模型？"><a href="#什么是-CSS-盒模型？" class="headerlink" title="什么是 CSS 盒模型？"></a>什么是 CSS 盒模型？</h4><p>完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。</p><p><strong>盒模型的各个部分</strong></p><p>CSS 中组成一个块级盒子需要：</p><ul><li><strong>Content box</strong>: 这个区域是用来显示内容，大小可以通过设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>.</li><li><strong>Padding box</strong>: 包围在内容区域外部的空白区域；大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a> 相关属性设置。</li><li><strong>Border box</strong>: 边框盒包裹内容和内边距。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 相关属性设置。</li><li><strong>Margin box</strong>: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 相关属性设置。</li></ul><p>如下图：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/box-model.png" alt="Diagram of the box model"></p><p><strong>标准盒模型</strong></p><p>在标准模型中，如果你给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 <em>content box</em>。padding 和 border 再加上设置的宽高一起决定整个盒子的大小。见下图。</p><p>假设定义了 <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>, and <code>padding</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">350px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用标准模型，实际占用空间的宽高分别为：宽度 &#x3D; 410px (350 + 25 + 25 + 5 + 5)，高度 &#x3D; 210px (150 + 25 + 25 + 5 + 5)。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/standard-box-model.png" alt="Showing the size of the box when the standard box model is being used."></p><p><strong>备注：</strong> margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到 margin。</p><p><strong>替代（IE）盒模型</strong></p><p>你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的 ! 因为这个原因，css 还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width &#x3D; 350px, height &#x3D; 150px).</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model/alternate-box-model.png" alt="Showing the size of the box when the alternate box model is being used."></p><p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 <code>box-sizing: border-box</code> 来实现。这样就可以告诉浏览器使用 <code>border-box</code> 来定义区域，从而设定您想要的大小。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你希望所有元素都使用替代模式，而且确实很常用，设置 <code>box-sizing</code> 在 <code>&lt;html&gt;</code> 元素上，然后设置所有元素继承该属性，正如下面的例子。如果想要深入理解，请看 <a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">the CSS Tricks article on box-sizing</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br>*, *<span class="hljs-selector-pseudo">::before</span>, *<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: inherit;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 一个有趣的历史记录 ——Internet Explorer 默认使用替代盒模型，没有可用的机制来切换。（译者注：IE8+ 支持使用 <code>box-sizing</code> 进行切换）</p><h4 id="外边距，内边距，边框"><a href="#外边距，内边距，边框" class="headerlink" title="外边距，内边距，边框"></a><strong>外边距，内边距，边框</strong></h4><p>您已经在上面的示例中看到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性。该示例中使用的是属性的<strong>简写</strong>，允许我们一次设置盒子的四个边。这些简写等价于分别控制盒子的不同边的普通写法。</p><p>接下来，我们更详细地研究这些属性：</p><p><strong>外边距</strong></p><p>外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p><p>我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>属性一次控制一个元素的所有边距，或者每边单独使用等价的普通属性控制：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-left"><code>margin-left</code></a></li></ul><p><strong>边框</strong></p><p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p><p>为边框设置样式时，有大量的属性可以使用——有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。</p><p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性一次设置所有四个边框的宽度、颜色和样式。</p><p>分别设置每边的宽度、颜色和样式，可以使用：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></li></ul><p>设置所有边的颜色、样式或宽度，请使用以下属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></li></ul><p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-style"><code>border-top-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-color"><code>border-top-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-width"><code>border-right-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-style"><code>border-right-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-color"><code>border-right-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-width"><code>border-bottom-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-style"><code>border-bottom-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-color"><code>border-bottom-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-width"><code>border-left-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-style"><code>border-left-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-color"><code>border-left-color</code></a></li></ul><p><strong>设置边框的颜色、样式或宽度，可以使用最细粒度的普通属性或者简写属性。在下面的示例中，我们使用了各种普通属性或者简写属性来创建边框。尝试一下不同的属性，以检查您是否理解它们是如何工作的。MDN 中的边框属性页面为您提供可用的不同边框样式的信息。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">5px</span> dotted green;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> double <span class="hljs-built_in">rgb</span>(<span class="hljs-number">23</span>,<span class="hljs-number">45</span>,<span class="hljs-number">145</span>);<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333333</span>;<br>  <span class="hljs-attribute">border-top-style</span>: dotted;<br>  <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border-bottom-color</span>: hotpink;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内边距</strong></p><p>内边距位于边框和内容区域之间。与外边距不同，您不能有负数量的内边距，所以值必须是 0 或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p><p>我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>简写属性控制元素所有边，或者每边单独使用等价的普通属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-top"><code>padding-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-bottom"><code>padding-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a></li></ul><p><strong>盒子模型和内联盒子</strong></p><p>以上所有的方法都完全适用于块级盒子。有些属性也可以应用于内联盒子，例如由<code>&lt;span&gt;</code>元素创建的那些内联盒子。</p><p>在下面的示例中，我们在一个段落中使用了<code>&lt;span&gt;</code>，并对其应用了宽度、高度、边距、边框和内边距。可以看到，宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p><p><strong>使用 display: inline-block</strong></p><p>display 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用：您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p><p>一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果：</p><ul><li>设置<code>width</code> 和<code>height</code> 属性会生效。</li><li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li></ul><p>但是，它不会跳转到新行，如果显式添加 <code>width</code> 和 <code>height</code> 属性，它只会变得比其内容更大。</p><p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<code>&lt;a&gt;</code> 是像 <code>&lt;span&gt;</code> 一样的内联元素；你可以使用 <code>display: inline-block</code> 来设置内边距，让用户更容易点击链接。</p><p>这种情况在导航栏中很常见。下面的导航使用 flexbox 显示在一行中，我们为 <code>&lt;a&gt;</code> 元素添加了内边距，因为我们希望能够在 <code>&lt;a&gt;</code> 在鼠标移动到上面时改变背景色。内边距似乎覆盖了 <code>&lt;ul&gt;</code> 元素上的边框。这是因为 <code>&lt;a&gt;</code> 是一个内联元素。</p><p>使用 <code>.links-list a</code> 选择器将 <code>display: inline-block</code> 添加到样式规则中，你将看到它是如何通过内边距推开其他元素来修复这个问题的。</p><p>这就是你需要了解的关于盒子模型的大部分内容。如果以后你发现对于盒模型的布局仍有困惑，你将会回来温故这些内容。</p><h3 id="2-3-背景与边框"><a href="#2-3-背景与边框" class="headerlink" title="2.3 背景与边框"></a>2.3 背景与边框</h3><p>在这节课中，我们来看看，使用 CSS 背景和边框来做一些，具有一些创造性的事情。渐变、背景图像和圆角，背景和边框的巧妙运用是 CSS 中许多样式问题的答案。</p><h4 id="css的背景样式"><a href="#css的背景样式" class="headerlink" title="css的背景样式"></a>css的背景样式</h4><p>CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性是我们将在本课中学习的许多普通背景属性的简写。如果您在样式表中发现了一个复杂的背景属性，可能会觉得难以理解，因为可以同时传入这么多值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">2</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>) center center / <span class="hljs-number">400px</span> <span class="hljs-number">200px</span> no-repeat,<br>  <span class="hljs-built_in">url</span>(<span class="hljs-string">big-star.png</span>) center no-repeat, rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure><p>在本教程的后面部分，我们将返回到简写的工作方式，但是首先，我们通过分开使用各个普通背景属性的方式，看一下在 CSS 中使用背景可以做哪些不同的事情。</p><p><strong>背景颜色</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color"><code>background-color</code></a> 属性定义了 CSS 中任何元素的背景颜色。属性接受任何有效的<code>&lt;color&gt;值</code>。背景色扩展到元素的内容和内边距的下面。</p><p><strong>背景图片</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 属性允许在元素的背景中显示图像。在下面的例子中，我们有两个方框——一个是比方框大的背景图像，另一个是星星的小图像。</p><p><strong>如果除了背景图像外，还指定了背景颜色，则图像将显示在颜色的顶部。</strong></p><h4 id="控制背景平铺"><a href="#控制背景平铺" class="headerlink" title="控制背景平铺"></a><strong>控制背景平铺</strong></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a> 属性用于控制图像的平铺行为。可用的值是：</p><ul><li><code>no-repeat</code> — 不重复。</li><li><code>repeat-x</code> —水平重复。</li><li><code>repeat-y</code> —垂直重复。</li><li><code>repeat</code> — 在两个方向重复。</li></ul><h4 id="调整背景图像的大小"><a href="#调整背景图像的大小" class="headerlink" title="调整背景图像的大小"></a><strong>调整背景图像的大小</strong></h4><p>在上面的例子中，我们有一个很大的图像，由于它比作为背景的元素大，所以最后被裁剪掉了。在这种情况下，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。</p><p>你也可以使用关键字：</p><ul><li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li><li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li></ul><p>在下面的例子中，我使用了上面例子中的大图，并使用长度单位来调整方框内的大小。你可以看到这扭曲了图像。</p><p>试试下面：</p><ul><li>改变用于修改背景大小的长度单位。</li><li>去掉长度单位，看看使用<code>background-size: cover</code> or <code>background-size: contain</code>会发生什么。</li><li>如果您的图像小于盒子，您可以更改 background-repeat 的值来重复图像。</li></ul><h4 id="背景图像定位"><a href="#背景图像定位" class="headerlink" title="背景图像定位"></a><strong>背景图像定位</strong></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a> 属性允许您选择背景图像显示在其应用到的盒子中的位置。它使用的坐标系中，框的左上角是 (0,0)，框沿着水平 (x) 和垂直 (y) 轴定位。</p><p><strong>备注：</strong> 默认的背景位置值是 (0,0)。</p><p>最常见的背景位置值有两个单独的值——一个水平值后面跟着一个垂直值。</p><p>你可以使用像<code>top</code>和<code>right</code>这样的关键字 (在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 页面上查找其他的关键字):</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top center;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length">长度值</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage">百分比</a>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">20px</span> <span class="hljs-number">10%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以混合使用关键字，长度值以及百分比，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，您还可以使用 4-value 语法来指示到盒子的某些边的距离——在本例中，长度单位是与其前面的值的偏移量。所以在下面的 CSS 中，我们将背景从顶部调整 20px，从右侧调整 10px:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: top <span class="hljs-number">20px</span> right <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a><strong>渐变背景</strong></h4><p>当渐变用于背景时，也可以使用像图像一样的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a> 属性设置。</p><p>您可以在 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient">&#96;&#96;</a> 数据类型页面上，了解更多关于渐变的不同类型，以及使用它们可以做的事情。使用渐变的一个有趣方法是，使用 web 上可用的许多 CSS 渐变生成器之一，比如<a href="https://cssgradient.io/">这个</a>。您可以创建一个渐变，然后复制并粘贴生成它的源代码。</p><p>在下面的示例中尝试一些不同的渐变。在这两个盒子里，我们分别有一个线性梯度，它延伸到整个盒子上，还有一个径向梯度，它有一个固定的大小，因此会重复。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">249</span>,<span class="hljs-number">255</span>,<span class="hljs-number">1</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.b</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(circle, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">249</span>,<span class="hljs-number">255</span>,<span class="hljs-number">1</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>);<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100px</span> <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多个背景图像"><a href="#多个背景图像" class="headerlink" title="多个背景图像"></a><strong>多个背景图像</strong></h4><p>也可以有多个背景图像——在单个属性值中指定多个 <code>background-image</code> 值，用逗号分隔每个值。</p><p>当你这样做时，你可能会以背景图像互相重叠而告终。背景将与最后列出的背景图像层在堆栈的底部，背景图像在代码列表中最先出现的在顶端。</p><p>其它 <code>background-*</code> 属性，该属性值用逗号分隔的方式设置。例如下列 <code>background-image</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">image1.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image2.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image3.png</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">image4.png</span>);<br><span class="hljs-attribute">background-repeat</span>: no-repeat, repeat-x, repeat;<br><span class="hljs-attribute">background-position</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>,  top right;<br></code></pre></td></tr></table></figure><p>不同属性的每个值，将与其他属性中相同位置的值匹配。例如，上面的 image1 的 <code>background-repeat</code> 值将是 <code>no-repeat</code>。但是，当不同的属性具有不同数量的值时，会发生什么情况呢？答案是较小数量的值会循环—在上面的例子中有四个背景图像，但是只有两个背景位置值。前两个位置值将应用于前两个图像，然后它们将再次循环—image3 将被赋予第一个位置值，image4 将被赋予第二个位置值。</p><h4 id="背景附加"><a href="#背景附加" class="headerlink" title="背景附加"></a><strong>背景附加</strong></h4><p>另一个可供选择的背景是指定他们如何滚动时，内容滚动。这是由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a> 属性控制的，它可以接受以下值：</p><ul><li><code>scroll</code>: 使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li><li><code>fixed</code>: 使元素的背景固定在视图端口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。</li><li><code>local</code>: 这个值是后来添加的 (它只在 Internet Explorer 9+中受支持，而其他的在 IE4+中受支持)，因为滚动值相当混乱，在很多情况下并不能真正实现您想要的功能。局部值将背景固定在设置的元素上，因此当您滚动元素时，背景也随之滚动。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a> 属性只有在有内容要滚动时才会有效果，所以我们做了一个示例来演示这三个值之间的区别——看看 <a href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html">background-attachment.html</a> (或者看看这儿的 <a href="https://github.com/mdn/learning-area/tree/master/css/styling-boxes/backgrounds">源代码</a>))。</p><h4 id="使用-background-的简写"><a href="#使用-background-的简写" class="headerlink" title="使用 background 的简写"></a><strong>使用 background 的简写</strong></h4><p>正如我在本课开始时提到的，您将经常看到使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性指定的背景。这种简写允许您一次设置所有不同的属性。</p><p>如果使用多个背景，则需要为第一个背景指定所有普通属性，然后在逗号后面添加下一个背景。在下面的例子中，我们有一个渐变，它指定大小和位置，然后是一个无重复的图像背景，它指定位置，然后是一个颜色。</p><p>这里有一些规则，需要在简写背景属性时遵循，例如：</p><ul><li><code>background-color</code> 只能在逗号之后指定。</li><li><code>background-size</code> 值只能包含在背景位置之后，用’&#x2F;‘字符分隔，例如：<code>center/80%</code>。</li></ul><p>查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 的 MDN 页面，以查看所有的注意事项。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background</span>:   <br>    <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">105deg</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">2</span>) <span class="hljs-number">39%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">51</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">1</span>) <span class="hljs-number">96%</span>) center center / <span class="hljs-number">400px</span> <span class="hljs-number">200px</span> no-repeat,<br><span class="hljs-built_in">url</span>(<span class="hljs-string">big-star.png</span>) center no-repeat, <br>    rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>背景的无障碍考虑</strong></p><p>当你把文字放在背景图片或颜色上面时，你应该注意你有足够的对比度让文字对你的访客来说是清晰易读的。如果指定了一个图像，并且文本将被放置在该图像的顶部，您还应该指定一个<code>background-color</code> ，以便在图像未加载时文本也足够清晰。</p><p>屏幕阅读者不能解析背景图像，因此背景图片应该只是纯粹的装饰；任何重要的内容都应该是 HTML 页面的一部分，而不是包含在背景中。</p><h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a><strong>边框</strong></h4><p>在学习盒子模型时，我们发现了边框如何影响盒子的大小。在这节课中，我们将看看如何创造性地使用边界。通常，当我们使用 CSS 向元素添加边框时，我们使用一个简写属性在一行 CSS 中设置边框的颜色、宽度和样式。我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 为一个框的所有四个边设置边框。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以只设置盒子的一个边，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">.<span class="hljs-keyword">box </span>&#123;<br>  <span class="hljs-keyword">border-top: </span><span class="hljs-number">1</span>px solid <span class="hljs-keyword">black;</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure><p>这些简写的等价于：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span>: 1px;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用更加细粒度的属性：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">width</span>: 1px;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 这些顶部、右侧、底部和左侧边框属性还具有与文档写入模式相关的映射逻辑属性 (例如，从左到右或从右到左的文本，或从上到下)。在下一课中，我们将探讨这些问题，这包括处理不同的文本指示 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Handling_different_text_directions">详情</a>。</p><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a><strong>圆角</strong></h4><p>通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a> 属性和与方框的每个角相关的长边来实现方框的圆角。可以使用两个长度或百分比作为值，第一个值定义水平半径，第二个值定义垂直半径。在很多情况下，您将只传递一个值，这两个值都将使用。</p><p>例如，要使一个盒子的四个角都有 10px 的圆角半径：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 10px;<br>&#125;<br></code></pre></td></tr></table></figure><p>或使右上角的水平半径为 1em，垂直半径为 10％：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">border</span>-top-right-<span class="hljs-built_in">radius</span>: 1em <span class="hljs-number">10</span><span class="hljs-symbol">%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在下面的示例中设置了所有四个角，然后更改右上角的值使之不同。您可以使用这些值来更改圆角样式。查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a> 的属性页，查看可用的语法选项。</p><h3 id="2-4-处理不同方向的文本"><a href="#2-4-处理不同方向的文本" class="headerlink" title="2.4  处理不同方向的文本"></a>2.4  处理不同方向的文本</h3><p>目前为止我们在 CSS 学习中遇到的许多属性和属性值与显示器的物理尺度紧密相关。例如，我们会在上、右、下、左设置边框。这些物理尺寸与水平排布的文本相得益彰，并且，默认浏览器对方向从左到右的文本（如英文或法文）的支持，要优于从右到左的文本（如阿拉伯语）的支持。</p><p>然而，CSS 在最近几年得到了改进，以更好地支持不同方向的文本，包括从右到左，也包括从上到下的文本（如日文）——这些不同的方向属性被称为书写模式。随着学习的深入，当你开始试着对页面进行布局时，对书写模式的了解将会对你很有帮助，为此我们在这里加以介绍。</p><h4 id="什么是书写模式"><a href="#什么是书写模式" class="headerlink" title="什么是书写模式"></a>什么是书写模式</h4><p>CSS 中的书写模式是指文本的排列方向是横向还是纵向的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a> 属性使我们从一种模式切换到另一种模式。为此，你不必使用一种竖向的语言——你还可以更改部分文字的方向以实现创新性的布局。</p><p>我们可以使用<code>writing-mode: vertical-rl</code>对一个标题的显示进行设置。现在，标题文本是竖向的了。竖向文本在平面设计中很常见，也可以为你的网页设计增添更加有趣的外观。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>的三个值分别是：</p><ul><li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li><li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li><li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li></ul><p>因此，<code>writing-mode</code>属性实际上设定的是页面上块级元素的显示方向——要么是从上到下，要么是从右到左，要么是从左到右。而这决定了文本的方向。</p><h4 id="书写模式、块级布局和内联布局"><a href="#书写模式、块级布局和内联布局" class="headerlink" title="书写模式、块级布局和内联布局"></a>书写模式、块级布局和内联布局</h4><p>我们已经讨论了块级布局和内联布局（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#block_and_inline_boxes">block and inline layout</a>），也知道外部显示类型元素分为块级元素和内联元素。如上所述，块级显示和内联显示与文本的书写模式（而非屏幕的物理显示）密切相关。如果你使用书写模式的显示是横向的，如英文，那么块在页面上的显示就是从上到下的。</p><p>用一个例子可以更清楚地说明这一点。下一个例子中有两个盒子，分别包含一个标题和一个段落。第一个盒子应用的是<code>writing-mode: horizontal-tb</code>，这是一个从上到下的横向的书写模式。第二个盒子应用的是<code>writing-mode: vertical-rl</code>，这是一个从右到左的纵向的书写模式。</p><p>当我们切换书写模式时，我们也在改变块和内联文本的方向。<code>horizontal-tb</code>书写模式下块的方向是从上到下的横向的，而 <code>vertical-rl</code>书写模式下块的方向是从右到左的纵向的。因此，块维度指的总是块在页面书写模式下的显示方向。而内联维度指的总是文本方向。</p><p>这张图展示了在水平书写模式下的两种维度。<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Handling_different_text_directions/horizontal-tb.png" alt="img"></p><p>这张图片展示了纵向书写模式下的两种维度。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Handling_different_text_directions/vertical.png" alt="img"></p><p>一旦你开始接触 CSS 布局，尤其是更新的布局方法，这些关于块级元素和内联元素的概念会变得非常重要。我之后会返回来再看。</p><h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><p>除了书写模式，我们还可以设置文本方向。正如上面所言，有些语言（如阿拉伯语）是横向书写的，但是是从右向左。当你在对页面布局进行创新时，你可能不这么使用——如果你只是想将某部分内容放到右边排列下来，还有其他方法可以选择——然而，重要的是能意识到，这其实是 CSS 本身功能的一部分。网页可不仅限于从左向右排列的语言！</p><p>由于书写模式和文本方向都是可变的，新的 CSS 布局方法不再定义从左到右和从上到下，而是将这些连同内联元素和块级元素的<em>开头</em>和<em>结尾</em>一起考量。现在不必过于担心，但是带着这些概念开始你的布局，你会发现这对你掌握 CSS 非常有用。</p><h4 id="逻辑属性和逻辑值"><a href="#逻辑属性和逻辑值" class="headerlink" title="逻辑属性和逻辑值"></a>逻辑属性和逻辑值</h4><p>我们之所以要在这里探讨书写模式和方向，是因为目前为止我们已经了解了很多与屏幕的物理显示密切相关的很多属性，而书写模式和方向在水平书写模式下会很有意义。</p><p>让我们再来看看那两个盒子——一个用<code>horizontal-tb</code>设定了书写模式，一个用<code>vertical-rl</code>设定了书写模式。我为这两个盒子分别设定了宽度（ <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>）。可以看到，当盒子处于纵向书写模式下时，宽度也发生了变化，从而导致文本超出了盒子的范围。</p><p>通过这一些列调整，我们想要的实际上是使宽和高随着书写模式一起变化。当处于纵向书写模式之下时，我们希望盒子可以向横向模式下一样得到拓宽。</p><p>为了更容易实现这样的转变，CSS 最近开发了一系列映射属性。这些属性用逻辑（<strong>logical</strong>）和相对变化（<strong>flow relative</strong>）代替了像宽<code>width</code>和高<code>height</code>一样的物理属性。</p><p>横向书写模式下，映射到<code>width</code>的属性被称作内联尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a>）——内联维度的尺寸。而映射<code>height</code>的属性被称为块级尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>），这是块级维度的尺寸。下面的例子展示了替换掉<code>width</code>的<code>inline-size</code>是如何生效的。</p><h4 id="逻辑外边距、边框和内边距属性"><a href="#逻辑外边距、边框和内边距属性" class="headerlink" title="逻辑外边距、边框和内边距属性"></a>逻辑外边距、边框和内边距属性</h4><p>我们在前面两节中学习了 CSS 的盒模型和 CSS 边框。在外边距、边框和内边距属性中，你会发现许多物理属性，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a>、 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>。就像 width 和 height 有映射，这些属性也有相应的映射。</p><p><code>margin-top</code>属性的映射是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-block-start"><code>margin-block-start</code></a>——总是指向块级维度开始处的边距。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>属性映射到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-inline-start"><code>padding-inline-start</code></a>，这是应用到内联开始方向（这是该书写模式文本开始的地方）上的内边距。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>属性映射到的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-block-end"><code>border-block-end</code></a>，也就是块级维度结尾处的边框。</p><p>下面是物理和逻辑属性之间的对比。</p><p><strong>如果你用<code>writing-mode</code>把盒子<code>.box</code>的书写模式改为<code>vertical-rl</code>，你将会看到尽管盒子的物理方向变了，盒子的物理属性仍然没变，然而逻辑属性会随着书写模式一起改变。</strong></p><p><strong>你还可以看到，二级标题<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements">&#96;&#96; (en-US)</a>有一个黑色的底部边框<code>border-bottom</code>。你知道如何使得底部边框无论在那种书写模式下都位于文本的下方吗？</strong></p><p>对于每一个普通边距，都有许多属性可以参考，你可以在 MDN 页面（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Logical_Properties">Logical Properties and Values</a>）查看所有映射属性。</p><p><strong>逻辑值</strong></p><p>目前为止我们看到的都是逻辑属性的名称。还有一些属性的取值是一些物理值（如<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>）。这些值同样拥有逻辑值映射（<code>block-start</code>、<code>inline-end</code>、<code>block-end</code>和<code>inline-start</code>）。</p><p>例如，你可以将一张图片移到左边，并使文本环绕图片。你可以将<code>left</code>替换为<code>inline-start</code> ，就像下面的例子中一样。</p><p><strong>将这个例子的书写模式改为<code>vertical-rl</code>，看看图片会发生什么。将<code>inline-start</code>改为<code>inline-end</code>来改变图片的移动。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box logical&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;big-star.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This box uses logical properties. The star image has been floated inline-start, it also has a margin on the inline-end and block-end.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">inline-size</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">writing-mode</span>: horizontal-tb;<br>&#125;<br><br><span class="hljs-selector-tag">img</span>&#123;<br>  <span class="hljs-attribute">float</span>: inline-start;<br>  <span class="hljs-attribute">margin-inline-end</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin-block-end</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之类，我们同样使用逻辑边距值来保证在任何书写模式下边距的位置都是对的。</p><p><strong>应该使用物理属性还是逻辑属性呢？</strong></p><p>逻辑属性是在物理属性之后出现的，因而最近才开始在浏览器中应用。你可以通过查看 MDN 的属性页面来了解浏览器对逻辑属性的支持情况。如果你并没有应用多种书写模式，那么现在你可能更倾向于使用物理属性，因为这些在你使用弹性布局和网格布局时非常有用。</p><h3 id="2-5-溢出的内容"><a href="#2-5-溢出的内容" class="headerlink" title="2.5 溢出的内容"></a>2.5 溢出的内容</h3><p>本节课，我们来了解一下 CSS 中另外一个重要的概念——<strong>溢出</strong>。溢出是在盒子无法容纳下太多的内容的时候发生的。在这篇教程里面，你将会学习到什么是溢出，以及如何控制它。</p><h4 id="什么是溢出？"><a href="#什么是溢出？" class="headerlink" title="什么是溢出？"></a>什么是溢出？</h4><p>我们知道，CSS 中万物皆盒，因此我们可以通过给<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>（或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着。CSS 给了你好几种工具来控制溢出，在学习的早期理解这些概念是很有用的。在你写 CSS 的时候你经常会遇到溢出的情形，尤其是当你以后更加深入到 CSS 布局的时候。</p><h4 id="CSS-尽力减少“数据损失”"><a href="#CSS-尽力减少“数据损失”" class="headerlink" title="CSS 尽力减少“数据损失”"></a>CSS 尽力减少“数据损失”</h4><p>我们从两个展示了在碰到溢出的时候，CSS 默认会如何处理的例子开始吧。</p><p>第一个例子是，一个盒子，在块方向上已经受到<code>height</code>的限制。然后我们已经加了过多的内容，以至于盒子里面没有空间容纳。内容正在从盒子里面溢出，并让自己把盒子下面的段落弄得一团糟。</p><p>第二个例子是一个单词，位于在内联方向上受到限制的盒子里面。盒子已经被做得小到无法放置那个单词的地步，于是那个单词就突破了盒子的限制。</p><p>你也许会好奇，为什么 CSS 默认会采取如此不整洁的方式，让内容这么凌乱地溢出出来呢？为何不把多余的内容隐藏起来，或者让盒子变大呢？</p><p>只要有可能，CSS 就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。在 CSS 的术语里面，这会导致一些内容消失，你的访客可能不会注意到这一点，如果消失的是表格上的提交按钮，没有人能填完这个表格，这是很麻烦的事情！所以 CSS 反而会把它以可见的形式溢出出去。这样做的结果就是，你会看到错误的 CSS 导致的一片混乱，或者最坏的情况也只是你的网站的访客会告诉你有些内容冒了出来，你的网站需要修缮。</p><p>如果你已经用<code>width</code>或者<code>height</code>限制住了一个盒子，CSS 假定，你知道你在做什么，而且你已经控制住了溢出的隐患。总之，在盒子里面需要放置文本的时候，限制住块方向的尺寸是会引起问题的，因为可能会有比你在设计网站的时候所预计的文本更多的文本，或者文本变大了——比如用户增加字体大小的时候。</p><p>在下面的几节课里，我们会看一下各种不同的控制尺寸的方式，以减少溢出的影响。但是，如果你需要固定的尺寸，你也可以控制溢出表现的形式。那么让我们接着读下去吧！</p><p><strong>overflow 属性</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a>属性是你控制一个元素溢出的方式，它告诉浏览器你想怎样处理溢出。<code>overflow</code>的默认值为<code>visible</code>，这就是我们的内容溢出的时候，我们在默认情况下看到它们的原因。</p><p>如果你想在内容溢出的时候把它裁剪掉，你可以在你的盒子上设置<code>overflow: hidden</code>。这就会像它表面上所显示的那样作用——隐藏掉溢出。这可能会很自然地让东西消失掉，所以你只应该在判断隐藏内容不会引起问题的时候这样做。</p><p>也许你还会想在有内容溢出的时候加个滚动条？如果你用了<code>overflow: scroll</code>，那么你的浏览器总会显示滚动条，即使没有足够多引起溢出的内容。你可能会需要这样的样式，它避免了滚动条在内容变化的时候出现和消失。</p><p><strong>如果你移除了下面的盒子里的一些内容，你可以看一下，滚动条是否还会在没有能滚动的东西的时候保留。</strong></p><p>在以上的例子里面，我们仅仅需要在<code>y</code>轴方向上滚动，但是我们在两个方向上都有了滚动条。你可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-y"><code>overflow-y</code></a>属性，设置<code>overflow-y: scroll</code>来仅在<code>y</code>轴方向滚动。</p><p>你也可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-x"><code>overflow-x</code></a>，以在 x 轴方向上滚动，尽管这不是处理长英文词的好办法！如果你真的需要在小盒子里面和长英文词打交道，那么你可能要了解一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap"><code>overflow-wrap</code></a>属性。除此以外，一些<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS">在 CSS 里面调整大小</a>这节课里面讨论过的方式可能会帮助你创建可以和有变化容量的内容相协调的盒子。</p><p>和<code>scroll</code>一样，在无论是否有多到需要 用滚动条的内容的时候，页面上都会显示一个滚动条。</p><p><strong>备注：</strong> 你可以用<code>overflow</code>属性指定 x 轴和 y 轴方向的滚动，同时使用两个值进行传递。如果指定了两个关键字，第一个对<code>overflow-x</code>生效而第二个对<code>overflow-y</code>生效。否则，<code>overflow-x</code>和<code>overflow-y</code>将会被设置成同样的值。例如，<code>overflow: scroll hidden</code>会把<code>overflow-x</code>设置成<code>scroll</code>，而<code>overflow-y</code>则为<code>hidden</code>。</p><p>如果你只是想让滚动条在有比盒子所能装下更多的内容的时候才显示，那么使用<code>overflow: auto</code>。此时由浏览器决定是否显示滚动条。桌面浏览器一般仅仅会在有足以引起溢出的内容的时候这么做。</p><p>移除一些内容，直到能够装在盒子里面，你还会看到滚动条消失了。</p><h4 id="溢出建立了块级排版上下文"><a href="#溢出建立了块级排版上下文" class="headerlink" title="溢出建立了块级排版上下文"></a>溢出建立了块级排版上下文</h4><p>CSS 中有所谓<strong>块级排版上下文</strong>（Block Formatting Context，BFC）<strong>的概念</strong>。现在你不用太过在意，但是你应该知道，在你使用诸如<code>scroll</code>或者<code>auto</code>的时候，你就建立了一个块级排版上下文。结果就是，你改变了<code>overflow</code>的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。激活了滚动动作，你的盒子里面所有的内容会被收纳，而且不会遮到页面上其他的物件，于是就产生了一个协调的滚动体验。</p><h4 id="网页设计时不需要的溢出"><a href="#网页设计时不需要的溢出" class="headerlink" title="网页设计时不需要的溢出"></a>网页设计时不需要的溢出</h4><p>现代网页布局的方式（正如<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout">CSS layout</a>模块中所介绍的那些）可以很好地处理溢出。我们不一定能预料到网页上会有多少内容，人们很好地设计它们，使得它们能与这种现状协调。但是在以往，开发者会更多地使用固定高度，尽力让毫无关联的盒子的底部对齐。这是很脆弱的，在旧时的应用里面，你偶尔会遇到一些盒子，它们的内容遮到了页面上的其他内容。如果你看到了，那么你现在应该知道，这就是溢出，理论上你应该能重新排布这些布局，使得它不必依赖于盒子尺寸的调整。</p><p>在开发网站的时候，你应该一直把溢出的问题挂在心头，你应该用或多或少的内容测试设计，增加文本的字号，确保你的 CSS 可以正常地协调。改变溢出属性的值，来隐藏内容或者增加滚动条，会是你仅仅在少数特别情况下需要的，例如在你确实需要一个可滚动盒子的时候。</p><h3 id="2-6-css的值与单位"><a href="#2-6-css的值与单位" class="headerlink" title="2.6 css的值与单位"></a>2.6 css的值与单位</h3><p>CSS 中使用的每个属性都允许拥有一个或一组值，查看 MDN 上的任何属性页将帮助你理解对任何特定属性有效的值。在本节课中，我们将学习一些最常用的值和单位。</p><h4 id="什么是-CSS-的值？"><a href="#什么是-CSS-的值？" class="headerlink" title="什么是 CSS 的值？"></a>什么是 CSS 的值？</h4><p>在 CSS 规范和 MDN 的属性页上，你将能够发现值的存在，因为它们将被尖括号包围，如<code>&lt;color&gt;</code>或<code>&lt;length&gt;</code>。当你看到值<code>&lt;color&gt;</code>对特定属性有效时，这意味着你可以使用任何有效的颜色作为该属性的值，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">&#96;&#96;</a>参考页面所列。</p><p><strong>备注：</strong> 你还将看到被称为数据类型的 CSS 值。这些术语基本上是可以互换的——当你在 CSS 中看到一些被称为数据类型的东西时，它实际上只是一种表示值的奇特方式。</p><p><strong>备注：</strong> 是的，CSS 值倾向于使用尖括号表示，以区别于 CSS 属性 (例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a>属性和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value"></a> 数据类型)。你可能还会混淆 CSS 数据类型和 HTML 元素，因为它们都使用尖括号，但这不太可能——它们在完全不一样的上下文中使用。</p><p>在下面的例子中，我们使用关键字设置标题的颜色，使用<code>rgb()</code>函数设置背景：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">197</span>,<span class="hljs-number">93</span>,<span class="hljs-number">161</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 中的值类型是一种定义了一些可使用的值的集合的方式。这意味着如果你看到的 <code>&lt;color&gt;</code> 是有效的，那么你就不需要考虑可以使用哪种类型——不管是关键字、十六进制值还是 <code>rgb()</code> 函数等都是有效的。如果浏览器支持这些可用的 <code>&lt;color&gt;</code> 值，则可以使用它们当中的任意一个。MDN 上针对每个值类型的页面将提供有关浏览器支持的信息。例如，如果你查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">&#96;&#96;</a> 的页面，你将看到浏览器兼容性部分列出了不同类型的颜色值以及对它们的支持。</p><p>让我们来看看你可能经常遇到的一些值和单位类型，并提供一些示例，以便你尝试使用各种值的可能性。</p><h4 id="数字，长度和百分比"><a href="#数字，长度和百分比" class="headerlink" title="数字，长度和百分比"></a>数字，长度和百分比</h4><p>你可能会发现自己在 CSS 中使用了各种数值数据类型。以下全部归类为数值：</p><table><thead><tr><th align="left">数值类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer"><code>&lt;integer&gt;</code></a></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer"><code>&lt;integer&gt;</code></a>是一个整数，比如 1024 或 -55。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number"><code>&lt;number&gt;</code></a></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number"><code>&lt;number&gt;</code></a>表示一个小数——它可能有小数点后面的部分，也可能没有，例如 0.255、128 或 -1.2。</td></tr><tr><td align="left"><code>&lt;dimension&gt;</code></td><td align="left"><code>&lt;dimension&gt;</code>是一个<code>&lt;number&gt;</code>，它有一个附加的单位，例如 45deg、5s 或 10px。<code>&lt;dimension&gt;</code>是一个伞形类别，包括<code>&lt;length&gt;</code>、<code>&lt;angle&gt;</code>、<code>&lt;time&gt;</code>和<code>&lt;resolution&gt;</code>类型。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage"><code>percentage</code></a></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage"><code>percentage</code></a>表示一些其他值的一部分，例如 50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。</td></tr></tbody></table><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>最常见的数字类型是<code>&lt;length&gt;</code>，例如 10px(像素) 或 30em。CSS 中有两种类型的长度——相对长度和绝对长度。重要的是要知道它们之间的区别，以便理解他们控制的元素将变得有多大。</p><h4 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h4><p>以下都是<strong>绝对</strong>长度单位——它们与其他任何东西都没有关系，通常被认为总是相同的大小。</p><table><thead><tr><th align="left">单位</th><th align="left">名称</th><th align="left">等价换算</th></tr></thead><tbody><tr><td align="left"><code>cm</code></td><td align="left">厘米</td><td align="left">1cm &#x3D; 96px&#x2F;2.54</td></tr><tr><td align="left"><code>mm</code></td><td align="left">毫米</td><td align="left">1mm &#x3D; 1&#x2F;10th of 1cm</td></tr><tr><td align="left"><code>Q</code></td><td align="left">四分之一毫米</td><td align="left">1Q &#x3D; 1&#x2F;40th of 1cm</td></tr><tr><td align="left"><code>in</code></td><td align="left">英寸</td><td align="left">1in &#x3D; 2.54cm &#x3D; 96px</td></tr><tr><td align="left"><code>pc</code></td><td align="left">十二点活字</td><td align="left">1pc &#x3D; 1&#x2F;6th of 1in</td></tr><tr><td align="left"><code>pt</code></td><td align="left">点</td><td align="left">1pt &#x3D; 1&#x2F;72th of 1in</td></tr><tr><td align="left"><code>px</code></td><td align="left">像素</td><td align="left">1px &#x3D; 1&#x2F;96th of 1in</td></tr></tbody></table><p>这些值中的大多数在用于打印时比用于屏幕输出时更有用。例如，我们通常不会在屏幕上使用 cm。惟一一个你经常使用的值，估计就是 px(像素)。</p><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><p>相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，你可以使文本或其他元素的大小与页面上的其他内容相对应。下表列出了 web 开发中一些最有用的单位。</p><table><thead><tr><th align="left">单位</th><th align="left">相对于</th></tr></thead><tbody><tr><td align="left"><code>em</code></td><td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td align="left"><code>ex</code></td><td align="left">字符“x”的高度</td></tr><tr><td align="left"><code>ch</code></td><td align="left">数字“0”的宽度</td></tr><tr><td align="left"><code>rem</code></td><td align="left">根元素的字体大小</td></tr><tr><td align="left"><code>lh</code></td><td align="left">元素的 line-height</td></tr><tr><td align="left"><code>vw</code></td><td align="left">视窗宽度的 1%</td></tr><tr><td align="left"><code>vh</code></td><td align="left">视窗高度的 1%</td></tr><tr><td align="left"><code>vmin</code></td><td align="left">视窗较小尺寸的 1%</td></tr><tr><td align="left"><code>vmax</code></td><td align="left">视图大尺寸的 1%</td></tr></tbody></table><h4 id="ems-and-rems"><a href="#ems-and-rems" class="headerlink" title="ems and rems"></a>ems and rems</h4><p><code>em</code>和<code>rem</code>是你在从框到文本调整大小时最常遇到的两个相对长度。了解这些方法是如何工作的以及它们之间的区别是很有意义的，尤其是当你开始学习更复杂的主题时，比如样式化文本或 CSS 布局。下面的示例提供了一个演示。</p><p>HTML 是一组嵌套的列表—我们总共有三个列表，并且两个示例都有相同的 HTML。唯一的区别是第一个类具有 ems，第二个类具有 rems。</p><p>首先，我们将 16px 设置为<code>&lt;html&gt;</code>元素的字体大小。</p><p>概括地说，在排版属性中 em 单位的意思是“父元素的字体大小”。带有 ems 类的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>&lt;ul&gt;</code></a>内的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li"><code>&lt;li&gt;</code></a>元素从它们的父元素中获取大小。因此，每一个连续的嵌套级别都会逐渐变大，因为每个嵌套的字体大小都被设置为 1.3em—是其父嵌套字体大小的 1.3 倍。</p><p>概括地说，rem 单位的意思是“根元素的字体大小”。(“根 em”的 rem 标准。)<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>&lt;ul&gt;</code></a>内的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li"><code>&lt;li&gt;</code></a>元素和一个 rems 类从根元素 (<code>&lt;html&gt;)</code>中获取它们的大小。这意味着每一个连续的嵌套层都不会不断变大。</p><p>但是，如果你在 CSS 中更改<html>字体大小，你将看到所有其他相关内容都发生了更改，包括 rem 和 em 大小的文本。</p><h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h4><p>在许多情况下，百分比与长度的处理方法是一样的。百分比的问题在于，它们总是相对于其他值设置的。例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p><p>在下面的示例中，两个百分比大小的框和两个像素大小的框具有相同的类名。分别为 200px 和 40% 宽。</p><p>不同之处在于，第二组两个框位于一个 400 像素宽的包装器中。第二个 200px 宽的盒子和第一个一样宽，但是第二个 40% 的盒子现在是 400px 的 40%——比第一个窄多了！</p><p>尝试更改包装器的宽度或百分比值，看看这是如何工作的。</p><p>注意，虽然许多值接受长度或百分比，但也有一些值只接受长度。你可以在 MDN 属性引用页面上看到它能接受哪些值。如果允许的值包括<code>&lt;length-percent&gt;</code>，则可以使用长度或百分比。如果允许的值只包含<length>，则不可能使用百分比。</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>有些值接受数字，不添加任何单位。接受无单位数字的属性的一个例子是不透明度属性（<code>opacity</code> ），它控制元素的不透明度 (它的透明程度)。此属性接受 0(完全透明) 和 1(完全不透明) 之间的数字。</p><p>在下面的示例中，尝试将不透明度值更改为 0 到 1 之间的各种小数值，并查看框及其内容是如何变得透明或者不透明的。</p><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>在 CSS 中指定颜色的方法有很多，其中一些是最近才实现的。在 CSS 中，相同的颜色值可以在任何地方使用，无论你指定的是文本颜色、背景颜色还是其他颜色。</p><p>现代计算机的标准颜色系统是 24 位的，它允许通过不同的红、绿、蓝通道的组合显示大约 1670 万种不同的颜色，每个通道有 256 个不同的值 (256 x 256 x 256 &#x3D; 16,777,216)。让我们来看看在 CSS 中指定颜色的一些方法。</p><p><strong>备注：</strong> 在本教程中，我们将研究具有良好浏览器支持的常用指定颜色的方法；虽然还有其他的，但是他们没有很好的支持，也不太常见。</p><h4 id="颜色关键词"><a href="#颜色关键词" class="headerlink" title="颜色关键词"></a>颜色关键词</h4><p>在这学习示例或 MDN 上的其他示例中，你经常会看到使用的颜色关键字，因为它们是一种指定颜色的简单易懂的方式。有一些关键词，其中一些有相当有趣的名字！你可以在页面上看到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value"><code>&lt;color&gt;</code></a>值的完整列表。</p><p><strong>在下面的示例中尝试使用不同的颜色值，以了解它们是如何工作的。</strong></p><p><strong>十六进制 RGB 值</strong></p><p>你可能遇到的下一种颜色值类型是十六进制代码。每个十六进制值由一个散列&#x2F;磅符号 (#) 和六个十六进制数字组成，每个十六进制数字都可以取 0 到 f(代表 15) 之间的 16 个值中的一个——所以是 0123456789abcdef。每对值表示一个通道—红色、绿色和蓝色—并允许我们为每个通道指定 256 个可用值中的任意一个 (16 x 16 &#x3D; 256)。</p><p>这些值有点复杂，不太容易理解，但是它们比关键字更通用——你可以使用十六进制值来表示你想在配色方案中使用的任何颜色。</p><p><strong>RGB 和 RGBA 的值</strong></p><p>我们将在这里讨论的第三种方案是 RGB。RGB 值是一个函数—RGB()—它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似。RGB 的不同之处在于，每个通道不是由两个十六进制数字表示的，而是由一个介于 0 到 255 之间的十进制数字表示的——这有点容易理解。</p><p>你还可以使用 RGBA 颜色——它们的工作方式与 RGB 颜色完全相同，因此你可以使用任何 RGB 值，但是有第四个值表示颜色的 alpha 通道，它控制不透明度。如果将这个值设置为<code>0</code>，它将使颜色完全透明，而设置为<code>1</code>将使颜色完全不透明。介于两者之间的值提供了不同级别的透明度。</p><p><strong>备注：</strong> 在颜色上设置 alpha 通道与使用我们前面看到的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a>属性有一个关键区别。当你使用不透明度时，你让元素和它里面的所有东西都不透明，而使用 RGBA 颜色只让你指定的颜色不透明。</p><h4 id="HSL-和-HSLA-的值"><a href="#HSL-和-HSLA-的值" class="headerlink" title="HSL 和 HSLA 的值"></a>HSL 和 HSLA 的值</h4><p>与 RGB 相比，HSL 颜色模型的支持稍差一些 (在旧版本的 IE 中不支持)，它是在设计师们感兴趣之后实现的。<code>hsl()</code> 函数接受色调、饱和度和亮度值作为参数，而不是红色、绿色和蓝色值，这些值的不同方式组合，可以区分 1670 万种颜色：</p><ul><li><strong>色调</strong>：颜色的底色。这个值在 0 和 360 之间，表示色轮周围的角度。</li><li><strong>饱和度</strong>：颜色有多饱和？它的值为 0 - 100%，其中 0 为无颜色 (它将显示为灰色阴影)，100% 为全色饱和度</li><li><strong>亮度</strong>：颜色有多亮？它从 0 - 100% 中获取一个值，其中 0 表示没有光 (它将完全显示为黑色)，100% 表示完全亮 (它将完全显示为白色)</li></ul><p>就像 RGB 有 RGBA 一样，HSL 也有 HSLA 等效物，它使你能够指定 alpha 通道值。我已经在下面通过将 RGBA 示例更改为使用 HSLA 颜色来演示了这一点。</p><p>你可以在项目中使用这些颜色值中的任何一个。对于大多数项目，你可能会选择一个调色板，然后在整个项目中使用这些颜色——以及你所选择的定义这些颜色的方法。你可以混合使用不同的颜色模型，但是为了一致性，通常最好是你的整个项目使用相同的一个！</p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/image"><code>&lt;image&gt;</code></a> 数据类型用于图像为有效值的任何地方。它可以是一个通过 <code>url()</code>函数指向的实际图像文件，也可以是一个渐变。</p><p>在下面的例子中，我们演示了一个图像和一个渐变作为 CSS <code>background-image</code>属性的值。</p><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position_value"><code>&lt;position&gt;</code></a> 数据类型表示一组 2D 坐标，用于定位一个元素，如背景图像 (通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>)。它可以使用关键字 (如 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, 以及<code>center</code> ) 将元素与 2D 框的特定边界对齐，以及表示框的顶部和左侧边缘偏移量的长度。</p><p>一个典型的位置值由两个值组成——第一个值水平地设置位置，第二个值垂直地设置位置。如果只指定一个轴的值，另一个轴将默认为 <code>center</code>。</p><p>在下面的示例中，我们使用关键字将背景图像从容器的顶部到右侧放置了 40px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.png</span>);<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-position</span>: right <span class="hljs-number">40px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串和标识符"><a href="#字符串和标识符" class="headerlink" title="字符串和标识符"></a>字符串和标识符</h4><p>在上面的示例中，我们看到关键字被用作值的地方 (例如<code>&lt;color&gt;</code>关键字，如 <code>red</code>, <code>black</code>, <code>rebeccapurple</code>, and <code>goldenrod</code>)。这些关键字被更准确地描述为标识符，一个 CSS 可以理解的特殊值。因此它们没有使用引号括起来——它们不被当作字符串。</p><p>在某些地方可以使用 CSS 中的字符串，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#generating_content_with_before_and_after">在指定生成的内容时</a>。在本例中，引用该值以证明它是一个字符串。在下面的示例中，我们使用非引号括起来的颜色关键字和引号括起来的内容字符串。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>我们将查看的最后一种类型的值是一组称为函数的值。在编程中，函数是一段可重用的代码，可以多次运行，以完成重复的任务，对开发人员和计算机都是如此。函数通常与 JavaScript、Python 或 c++等语言相关联，但它们也以属性值的形式存在于 CSS 中。我们已经在颜色部分看到了函数的作用——<code>rgb()</code>、<code>hsl()</code>等。用于从文件返回图像的值——<code>url()</code>——也是一个函数。</p><p>行为更类似于传统编程语言的值是<code>calc()</code>函数。这个函数使你能够在 CSS 中进行简单的计算。如果你希望计算出在为项目编写 CSS 时无法定义的值，并且需要浏览器在运行时为你计算出这些值，那么它特别有用。</p><p>例如，下面我们使用<code>calc()</code>使框宽为 20% + 100px。20% 是根据父容器.wrapper 的宽度来计算的，因此如果宽度改变，它也会改变。我们不能事先做这个计算，因为我们不知道父类的 20% 是多少，所以我们使用<code>calc()</code>来告诉浏览器为我们做这个计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">20%</span> + <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-在css中调整大小"><a href="#2-7-在css中调整大小" class="headerlink" title="2.7 在css中调整大小"></a>2.7 在css中调整大小</h3><p>在前面的课程中你已经看到了几种使用 CSS 为页面中元素设定尺寸的方法。在我们设计网页的时候，需要理解这些不同方法之间的差异。在本课程中，我们将总结设定元素尺寸的方法，并定义几个术语，这些内容将会在未来对你有所帮助。</p><h4 id="原始尺寸，或固有尺寸"><a href="#原始尺寸，或固有尺寸" class="headerlink" title="原始尺寸，或固有尺寸"></a>原始尺寸，或固有尺寸</h4><p>一个空的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>是没有尺寸的。如果你在你的 HTML 文件中添加一个空<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>并给予其边框（就像刚才我们为图像做的那样），你会在页面上看到一条线。这是边框被压缩后的效果— 它内部没有内容。在我们下面的例子中，边框宽度扩展到整个容器宽度，因为它是块级元素，而块级元素的行为就是这样的。它没有高度，或者说高度为 0，因为内部没有内容。</p><p>在上面的例子中，试着在空元素内部添加些内容。现在边框内包含一些文字了，因为元素的高度由其所含内容高度确定。再强调一次，这就是元素的固有尺寸 — 由其所包含的内容决定。</p><h4 id="设置具体的尺寸"><a href="#设置具体的尺寸" class="headerlink" title="设置具体的尺寸"></a>设置具体的尺寸</h4><p>我们当然可以给设计中的元素指定具体大小。当给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为<strong>外部尺寸</strong>。以上面例子中的 <code>&lt;div&gt;</code> 举例 — 我们可以给它一个具体的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 值，然后不论我们放什么内容进去它都是该尺寸。正如我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Overflowing_content">上一课</a>有关溢出的内容中所发现的，如果内容的数量超出了元素可容纳的空间，则设置的高度会导致内容溢出。</p><p>由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。</p><h4 id="使用百分数"><a href="#使用百分数" class="headerlink" title="使用百分数"></a>使用百分数</h4><p>许多时候，百分数是长度单位，正如我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units#percentages">Value and units 这节课中讨论的那样</a>，它们常常可与长度互换。当使用百分数时，你需要清楚，它是<strong>什么</strong>东西的百分数。对于一个处于另外一个容器当中的盒子，如果你给予了子盒子一个百分数作为宽度，那么它指的是父容器宽度的百分数。</p><p>这是因为百分数是以包含盒子的块为根据解析的。如果我们的<code>&lt;div&gt;</code>没有被指定百分数的值，那么它会占据 100% 的可用空间，因为它是块级别的元素。如果我们给了它一个百分数作为宽度，那么这就是它原来情况下可以占据空间的百分数。</p><h4 id="把百分数作为内外边距"><a href="#把百分数作为内外边距" class="headerlink" title="把百分数作为内外边距"></a>把百分数作为内外边距</h4><p>如果你把<code>margins</code>和<code>padding</code>设置为百分数的话，你会注意到一些奇怪的表现。在下面的例子里，我们有一个盒子，我们给了里面的盒子 10% 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>以及 10% 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>。盒子底部和顶部的内外边距，和左右外边距有同样的大小。</p><p>或许，你期望元素的上下外边距是其高度的百分比，元素的左右外边距是其宽度的百分比。但情况并非如此！</p><p>使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的<strong>内联尺寸</strong>进行计算的，也就是元素的水平宽度。在我们的示例中，所有的外边距或填充都是宽度的 10%。请记住一个事实，当你使用百分比作为元素外边距或填充的单位时，你将得到一个相同尺寸的外边距或填充。</p><h4 id="min-和max-尺寸"><a href="#min-和max-尺寸" class="headerlink" title="min-和max-尺寸"></a>min-和max-尺寸</h4><p>除了让万物都有一个确定的大小以外，我们可以让 CSS 给定一个元素的最大或最小尺寸。如果你有一个包含了变化容量的内容的盒子，而且你总是想让它<strong>至少</strong>有个确定的高度，你应该给它设置一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height"><code>min-height</code></a>属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。</p><p>在以下的示例中，你可以看到两个盒子，两个都有 150 像素的确定高度，左边的盒子有 150 像素高，右边的盒子有需要更多空间才能装下的内容，所以它变得比 150 像素高。</p><p>这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p><p>作为示例，如果你设定一个图像的属性为<code>width: 100%</code>，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。</p><p>如果你使用了<code>max-width: 100%</code>，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的 100%。</p><p>在下面的示例里，我们使用了两次相同的图片。第一次使用，属性值已设为<code>width: 100%</code>，位于比图片大的容器里，因此图片拉伸到了与容器相同的宽度；第二次的属性值则设为<code>max-width: 100%</code>，因此它并没有拉伸到充满容器；第三个盒子再一次包含了相同的图片，同时设定了<code>max-width: 100%</code>属性，这时你能看到它是怎样缩小来和盒子大小相适应的。</p><p>这个技术是用来让图片<strong>可响应</strong>的，所以在更小的设备上浏览的时候，它们会合适地缩放。你无论怎样都不应该用这个技术先载入大原始尺寸的图片，再对它们在浏览器中进行缩放。图像应该合适地调整尺寸，以使它们不会比预计中展示时所需要的最大尺寸大。下载过大的图像会造成你的网站变慢，如果用户使用按量收费的网络连接，会让用户花更多钱。</p><p><strong>备注：</strong>了解更多关于<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图片技术</a>的事情。</p><h4 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h4><p>视口，即你在浏览器中看到的部分页面，也是有尺寸的。在 CSS 中，我们有与视口尺寸相关的度量单位，即意为视口宽度的<code>vw</code>单位，以及意为视口高度的 <code>vh</code>单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。</p><p><code>1vh</code>等于视口高度的 1%，<code>1vw</code>则为视口宽度的 1%.你可以用这些单位约束盒子的大小，还有文字的大小。在下面的示例里，我们有一个大小被设为 20vh 和 20vw 的盒子。这个盒子里面有一个字母<code>A</code>，其<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>属性被设成了 10vh。</p><p><strong>如果你改变了<code>vh</code>和<code>vw</code>的对应值，盒子和字体的大小也会改变；视口大小的变化也会让它们的大小变化，因为它们是依照视口来定大小的。想看到随着你改变视口大小的时候示例的变化的话，你需要在一个新浏览器视窗里面载入此示例，因为你可以控制该视窗的大小，同时上面示例所在的嵌入的<code>&lt;iframe&gt;</code>的大小即是对上面示例而言的视口。<a href="https://mdn.github.io/css-examples/learn/sizing/vw-vh.html">打开此示例</a>，调整浏览器视窗的大小，观察在盒子和文本的大小上所发生的事情。</strong></p><p>在你的设计中，根据视口改变物件的大小是很有用的。例如，如果你想要在你其他内容之前，有一个充满整个视口的视觉宣传段落，让你的页面的那个部分有 100vh 高的话，会把剩下的内容推到视口的下面，只有向下滚动文档的时候它们才会出现。</p><h3 id="2-8-图像、媒体和表单元素"><a href="#2-8-图像、媒体和表单元素" class="headerlink" title="2.8 图像、媒体和表单元素"></a>2.8 图像、媒体和表单元素</h3><p>在这节课里，我们来看一下，CSS 是如何处理某些特殊元素的。图像、其他媒体和表格元素的表现和普通的盒子有些不同，这取决于你使用 CSS 格式化它们的能力。理解什么可能做到，什么不可能做到能够省些力气，本节课将会聚焦于一些你需要知道的主要的事情上。</p><h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><p>图像和视频被描述为**<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">替换元素</a>**。这意味着 CSS 不能影响它们的内部布局——而仅影响它们在页面上相对于其它元素的位置。但是，正如我们将看到的，CSS 可以对图像执行多种操作。</p><p>某些替换元素（例如图像和视频）也具有<strong>宽高比</strong>。这意味着它在水平（x）和垂直（y）方向上均具有大小，并且默认情况下将使用文件的固有尺寸进行显示。</p><h4 id="调整图像大小"><a href="#调整图像大小" class="headerlink" title="调整图像大小"></a>调整图像大小</h4><p>正如你从之前的几节课中所学到的那样，CSS 中万物皆盒。如果你把一张图片放在一个盒子里，而这张图片的原始长和宽比盒子的小或大，那么这张图要么缩在盒子里，要么就从盒子里面溢出。你需要决定如何处理这样的溢出。</p><p>下面的示例中有两个盒子，长宽均为 200 像素：</p><ul><li>一个包含了一张小于 200 像素的图像，它比盒子小，并且不会自动拉伸来充满盒子。</li><li>另一张图像大于 200 像素，溢出了盒子。</li></ul><p>那么该如何处理溢出问题呢？</p><p>正如我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS">之前的课程</a> 所学的那样，一个常用的方法是将一张图片的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a> 设为 100%。这将会使图片的尺寸小于等于盒子。这个技术也会对其他替换元素（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"><code>&lt;video&gt;</code></a>，或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe"><code>&lt;iframe&gt;</code></a>。</p><p>你可以选择对容器内的图像作其它方式的处理。例如，你可能想把一张图像调整到能够完全盖住一个盒子的大小。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit"><code>object-fit</code></a> 属性可以在这里帮助你。当使用 <code>object-fit</code> 时，替换元素可以以多种方式被调整到合乎盒子的大小。</p><p>如果我们使用值 <code>contain</code>，图像就会被缩放到足以完整地放到盒子里面的大小。如果它和盒子的比例不同，将会出现“开天窗”的结果。</p><p>你可能也想试试 <code>fill</code> 值，它可以让图像充满盒子，但是不会维持比例。</p><h4 id="布局中的替换元素"><a href="#布局中的替换元素" class="headerlink" title="布局中的替换元素"></a>布局中的替换元素</h4><p>在对替换元素使用各种 CSS 布局时，你可能会发现他们的表现方式与其他元素有一些细节上的差异。例如，flex 或者 grid 布局中，默认情况下元素会被拉伸到充满整块区域。但是图像不会被拉伸，而会对齐到网格区域或者弹性容器的起始处。</p><p>你可以在下面的示例中看到这一现象。该示例有一个两列两行的网格容器，里面有四个物件。所有的 <code>&lt;div&gt;</code> 元素有自己的背景色，被拉伸到充满了行和列。但是，图像并没有被拉伸。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;star.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>  <span class="hljs-attribute">border-radius</span>: .<span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/image-20230225195135107-20230305%2010:52:41.png" alt="image-20230225195135107"></p><p>如果你是按序阅读这些课程的，那么你可能还没有看到布局的部分。不过没关系，只要记住替换元素在成为网格或者弹性布局的一部分时，有不同的默认行为就好了。这一默认行为很有必要，因为它避免了替换元素被布局拉伸成奇怪的样子。</p><p>为了强制图像拉伸，以充满其所在的网格单元，你必须做类似于下面的事情：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这将会无条件地拉伸图像，所以很可能不会是你想要的。</p><h4 id="form-元素"><a href="#form-元素" class="headerlink" title="form 元素"></a>form 元素</h4><p>用 CSS 格式化表单元素是一个需要技巧的工作，<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms">HTML 表单指南</a>包含了详细的格式化表单元素的指导，我不会在这里复述。本节需要介绍的是一些值得关注的关键基础内容。</p><p>很多表单控件是通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input"><code>&lt;form&gt;</code></a> 元素添加到网页上的。该元素定义了简单的表单区域，例如文字输入。更进一步还有 HTML5 新加入的更加复杂的区域，例如颜色和日期撷取器。另外还有一些其他元素，例如用于多行文本输入的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea"><code>&lt;textarea&gt;</code></a>，以及那些用来包含和标记表单特定部分的元素，例如<code>&lt;fieldset&gt;</code>和 <code>&lt;legend&gt;</code> 。</p><p>HTML5 还包含了允许 Web 开发者指定必填区域的特性，甚至还能检验填入内容的类型。如果用户输入了一些不符合要求的内容，或者未填写必填区域，浏览器会显示错误提示。不同的浏览器在给此类元素样式化和自定义方面不尽相同。</p><h4 id="样式化文本输入元素"><a href="#样式化文本输入元素" class="headerlink" title="样式化文本输入元素"></a>样式化文本输入元素</h4><p>允许文本输入的元素有很多，例如 <code>&lt;input type=&quot;text&quot;&gt;</code>，及其指定特定类型的元素，如 <code>&lt;input type=&quot;email&quot;&gt;</code> 以及 <code>&lt;textarea&gt;</code> 元素，这些都是相当容易样式化的，它们和页面上其他盒子的表现相同。只不过在不同的操作系统和浏览器上访问时这些元素默认的样式化方式可能不同。</p><p>在下面的示例中，我们已经将一些文本输入元素用 CSS 样式化了。可以看到，边框、内外边距之类的东西都如期生效了。现在，我们使用属性选择器来指向不同的输入类型，尝试通过改变边框、添加输入区域背景色、改变字体和内边距的方式来改变表单的外观。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;buttons&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span>,<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;email&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#999</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">2em</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span><span class="hljs-selector-pseudo">:hover</span>, <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>警告：</strong> 你应该谨慎改变表单样式，确保用户仍然能轻松辨认表单元素。原则上，你可以创建一个没有边框和背景的，几乎无法与周围的内容区分开来的输入表单，但这会使辨认和填写变得非常困难。</p><h4 id="继承和表单元素"><a href="#继承和表单元素" class="headerlink" title="继承和表单元素"></a>继承和表单元素</h4><p>在一些浏览器中，表单元素默认不会继承字体样式，因此如果你想要确保你的表单填入区域使用 body 中或者一个父元素中定义的字体，你需要向你的 CSS 中加入这条规则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">font-family</span> : inherit;<br>  <span class="hljs-attribute">font-size</span> : <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="form-元素与-box-sizing"><a href="#form-元素与-box-sizing" class="headerlink" title="form 元素与 box-sizing"></a>form 元素与 box-sizing</h4><p>跨浏览器的 form 元素对于不同的挂件使用不同的盒子约束规则。你已经在我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型课</a>中学习了 <code>box-sizing</code> 属性，在样式化表单时候，你可以使用这一知识，确保在给 form 元素设定宽度和高度时可以有统一的体验。</p><p>为了保证统一，最好将所有元素的内外边距都设为 <code>0</code>，然后在单独进行样式化控制的时候将这些加回来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="其他有用的设置"><a href="#其他有用的设置" class="headerlink" title="其他有用的设置"></a>其他有用的设置</h4><p>除了上面提到的规则以外，你也应该在 <code>&lt;textarea&gt;</code> 上设置 <code>overflow: auto</code> 以避免 IE 在不需要滚动条的时候显示滚动条：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将一切都放在一起“重置”"><a href="#将一切都放在一起“重置”" class="headerlink" title="将一切都放在一起“重置”"></a>将一切都放在一起“重置”</h4><p>作为最后一步，我们可以将上面讨论过的各式属性包起来，成为以下的“表单重置”，以提供一个统一的在其上继续进行工作的地基，这包含了前三节提到的所有东西：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br>select,<br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: inherit;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 通用样式表被许多开发者用作所有项目的一系列基础样式，典型就是那些做了和以上提到相似的事情的那些，在你开始自己的 CSS 作业前，它确保了跨浏览器的任何事情都被默认设定为统一样式。它们不像以往那么重要了，因为浏览器显著地要比以往更加统一。但是，如果你想要看一个例子，可以看看这个<a href="http://necolas.github.io/normalize.css/">Normalize.css</a>，它被许多项目用作基础，是非常流行的样式表。</p><p>至于样式化表单的更加深入的信息，可以看下这些教程的 HTML 一节的这两篇文章：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Styling_web_forms">Styling HTML Forms</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Advanced_form_styling">Advanced Styling for HTML Forms</a></li></ul><h3 id="2-9-样式化表格"><a href="#2-9-样式化表格" class="headerlink" title="2.9 样式化表格"></a>2.9 样式化表格</h3><p>设计一个 HTML 表格不是世界上最迷人的工作，但有时我们必须这样做。本文提供了一个使 HTML 表格看起来不错的指南，其中一些功能在前面的文章中已作详细介绍。</p><h4 id="一个典型的风格化表格"><a href="#一个典型的风格化表格" class="headerlink" title="一个典型的风格化表格"></a>一个典型的风格化表格</h4><ol><li>首先，复制<a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/punk-bands-unstyled.html">实例标记</a>到本地，下载这两个图像 (<a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/noise.png">noise</a>和 <a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/styling-tables/leopardskin.jpg">leopardskin</a>)，然后将三个结果文件放在本地计算机的某个工作目录中。</li><li>接下来，创建一个名为<code>style.css</code>的新文件并将其保存在与其他文件相同的目录中。</li><li>将 CSS 链接到 HTML 中，将下面的 HTML 代码放到 HTML 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head">&#96;&#96;</a>中：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="间距和布局"><a href="#间距和布局" class="headerlink" title="间距和布局"></a>间距和布局</h4><p>我们需要做的第一件事是整理出空间&#x2F;布局——默认的表格样式是如此的拥挤！要做到这一点，请将以下 CSS 添加到您的 <code>style.css</code> 文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* spacing */</span><br><br><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">table-layout</span>: fixed;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">border-collapse</span>: collapse;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid purple;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">15%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">35%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><p>需要注意的最重要的部分如下：</p><ul><li>在你的表上，给table-layout属性设置一个为fixed的值通常是一个好主意，因为它使表的行为在默认情况下更可预测。通常情况下，表列的尺寸会根据所包含的内容大小而变化，这会产生一些奇怪的结果。通过 table-layout: fixed，您可以根据列标题的宽度来规定列的宽度，然后适当地处理它们的内容。这就是为什么我们使用了thead th:nth-child(n) 选择了四个不同的标题 (:nth-child) 选择器（“选择第 n 个子元素，它是一个顺序排列的<code>&lt;th&gt;</code>元素，且其父元素是<code>&lt;thead&gt;</code>元素”）并给定了它们的百分比宽度。整个列宽度与列标题的宽度是一样的，这是一种很好的设定表列尺寸的方式。Chris Coyier 在Fixed Table Layouts中更详细地讨论了这一技术。 我们将它与一个 100% 的width组合在一起，这意味着该表将填充它放入的任何容器，并且能很好的响应（虽然它仍然需要更多的工作来让它在窄屏宽度上看起来很好）。</li><li>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a>属性的<code>collapse</code>值对于任何表样式的工作来说都是一个标准的最佳实践。默认情况下，当您在表元素上设置边框时，它们之间将会有间隔，如下图所示：<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/no-border-collapse.png" alt="img">这看起来不太好 (虽然可能是你想要的样子，谁知道呢？)。使用 <code>border-collapse: collapse;</code> ，让边框合为一条，现在看起来好多了：<img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/border-collapse.png" alt="img"></li><li>我们在整个表设置了一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>，这是必要的，因为我们将在表页眉和页脚后面设置一些边框——当你在表格外面没有一个边界而且以空隙结尾的时候，它看起来很奇怪，而且是不连贯的。</li><li>我们在<code>&lt;th&gt;</code>和<code>&lt;td&gt;</code>元素上设置了一些padding——这些元素使数据项有了一些空间，使表看起来更加清晰。</li></ul><p>此刻，我们的表看起来好多了：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-spacing.png" alt="img"></p><h4 id="一些简单的排版"><a href="#一些简单的排版" class="headerlink" title="一些简单的排版"></a>一些简单的排版</h4><p>现在我们把类型整理一下。</p><p>首先，我们在Google Fonts上找到了一种适合于朋克乐队的字体的字体。如果你愿意，你可以去那里找一个不同的。现在，您只需替换我们提供的<code>&lt;link&gt;</code>元素和定制的font-family声明，并使用 Google 字体提供给您的内容。</p><p>首先，将下面的<code>&lt;link&gt;</code>元素添加到您的 HTML 头部，就在您现有的<code>&lt;link&gt;</code>元素之上：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&#x27;https://fonts.googleapis.com/css?family=Rock+Salt&#x27;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&#x27;stylesheet&#x27;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&#x27;text/css&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>现在将下面的 CSS 添加到您的<code>style.css</code>文件，在之前内容后面添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* typography */</span><br><br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;helvetica neue&#x27;</span>, helvetica, arial, sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Rock Salt&#x27;</span>, cursive;<br>&#125;<br><br><span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">2px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">1px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有什么特别的东西。我们通常会对字体样式进行调整，使其更易于阅读：</p><ul><li>我们已经设置了一个全局无衬线字体;这纯粹是一种风格上的选择。我们还在和元素的标题上设置了自定义字体，这是一种很不错的、很有朋克风格的外观。</li><li>我们在标题和单元格上设置了一些<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a>，因为我们觉得它有助于提高可读性。再次强调，这主要是一种风格上的选择。</li><li>我们在中的表格单元中对文本进行了居中对齐，使它们与标题对齐。默认情况下，单元格被赋予了一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a>的<code>left</code>值，并且标题被赋予了一个<code>center</code>值，但是通常情况下，让两者对齐看起来更好。标题字体的默认粗体值足以区分它们的外观。</li><li>我们在中对标题进行了右对齐，以便与它的数据点更好地关联。</li></ul><p>结果看起来更整洁一些：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-typography.png" alt="img"></p><h4 id="图形和颜色"><a href="#图形和颜色" class="headerlink" title="图形和颜色"></a>图形和颜色</h4><p>现在轮到图形和颜色了！因为表格上充满“朋克“和“个性”，我们需要给它再搭配一些鲜艳的造型。别担心，你不必让你的表格”燥起来“，你可以选择一些更巧妙、更有品位的东西。</p><p>首先将下面的 CSS 添加到<code>style.css</code>文件中，在底部添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">thead</span>, <span class="hljs-selector-tag">tfoot</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">leopardskin.jpg</span>);<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> black;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>), <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>));<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid purple;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，对于表格这里没有什么特别的，但有几件事值得注意。</p><p>我们已经将一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>添加到和，并将页眉和页脚的所有文本颜色<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a>更改为白色 (并给它一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a>)，这样它的可读性就更好了。你应该确保你的文字与你的背景形成鲜明的对比，使得它是可读的。</p><p>我们还为<code>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/th)和 </code>](<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98%EF%BC%8C%E5%9C%A8%E9%A1%B5%E7%9C%89%E5%92%8C%E9%A1%B5%E8%84%9A%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E7%BA%B9%E7%90%86%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B9%9F%E4%B8%BA%E8%BF%99%E4%BA%9B%E5%85%83%E7%B4%A0%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E6%98%8E%E4%BA%AE%E7%9A%84%E7%B4%AB%E8%89%B2%E8%BE%B9%E6%A1%86%E3%80%82%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%B5%8C%E5%A5%97%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%82%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%A0%B7%E5%BC%8F%E5%B1%82%E5%8F%A0%E5%9C%A8%E4%B8%80%E8%B5%B7%E3%80%82%E6%98%AF%E7%9A%84%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BB%84%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E5%B1%9E%E6%80%A7%E5%80%BC%E6%9D%A5%E5%9C%A8%E5%92%8C">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)添加了一个线性渐变，在页眉和页脚中添加了一个漂亮的纹理，同时也为这些元素提供了一个明亮的紫色边框。有多个嵌套的元素是很有用的，这样您就可以将样式层叠在一起。是的，我们可以通过设置多组背景图像属性值来在和</a> 元素上同时使用背景图像和线性渐变，但是我们决定分开使用，因为考虑到不支持多个背景图像或线性渐变的老浏览器。</p><h4 id="斑马条纹图案"><a href="#斑马条纹图案" class="headerlink" title="斑马条纹图案"></a>斑马条纹图案</h4><p>我们想用一个单独的部分来展示如何实现斑马条纹（<strong>zebra stripes</strong>）——通过改变不同数据行的颜色，使表中交替行不同的数据行可以更容易地进行解析和读取。将下面的 CSS 添加到您的 <code>style.css</code> 文件底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(odd) &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff33cc</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child</span>(even) &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e495e4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> <span class="hljs-selector-tag">tr</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">noise.png</span>);<br>&#125;<br><br><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff33cc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>您在前面看到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a>选择器用于选择特定的子元素。它也可以用一个公式作为参数，来选择一个元素序列。公式<code>2n-1</code>会选择所有奇数的子元素 (1、3、5 等)，而公式<code>2n</code>会选择所有偶数的子元素 (2、4、6 等等)。我们在代码中使用了<code>odd</code>和<code>even</code>的关键字，这与前面提到的公式作用完全相同。在这里，我们给奇数行和偶数行不同的 (醒目的) 颜色。</li><li>我们还为所有的行添加了一个重复的噪点背景色块（一个半透明的<code>.png</code>，有一点视觉上的扭曲）来提供一些纹理。</li><li>最后，我们给整个表格提供了一个纯的背景颜色，这样浏览器不支持<code>:nth-child</code>选择器仍然有它们的正文行的背景。</li></ul><p>这种颜色爆炸的结果如下：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-color.png" alt="img"></p><p>现在，这可能有点过头不符合你的品味，但我们在这里想要指出的一点是，表格并非只能是枯燥无味的，学术性的。</p><h4 id="样式化标题"><a href="#样式化标题" class="headerlink" title="样式化标题"></a>样式化标题</h4><p>对我们的表格还有最后一点处理——样式化标题。要做到这一点，请将以下内容添加到您的<code>style.css</code> 文件底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">caption</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Rock Salt&#x27;</span>, cursive;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>  <span class="hljs-attribute">caption-side</span>: bottom;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;<br>  <span class="hljs-attribute">text-align</span>: right;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">1px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有什么值得注意的地方，除了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/caption-side"><code>caption-side</code></a>属性，它被赋予了一个<code>bottom</code>的值。这就导致标题被放置在表格的底部，与其他声明一起提供了最后的外观（见预览版<a href="https://mdn.github.io/learning-area/css/styling-boxes/styling-tables/punk-bands-complete.html">punk-bands-complete.html</a>）：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables/table-with-caption.png" alt="img"></p><h4 id="表格样式小贴士"><a href="#表格样式小贴士" class="headerlink" title="表格样式小贴士"></a>表格样式小贴士</h4><p>在继续之前，我们认为我们将为您提供一个快速列表，列出了上面提到的最有用的点：</p><ul><li>使您的表格标记尽可能简单，并且保持灵活性，例如使用百分比，这样设计就更有响应性。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout"><code>table-layout</code></a><code>: fixed</code> 创建更可控的表布局，可以通过在标题<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>中设置<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>来轻松设置列的宽度。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a><code>: collapse</code> 使表元素边框合并，生成一个更整洁、更易于控制的外观。</li><li>使用, 和 将表格分割成逻辑块，并提供额外的应用 CSS 的地方，因此如果需要的话，可以更容易地将样式层叠在一起。</li><li>使用斑马线来让其他行更容易阅读。</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a>直线对齐您的<code>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/th)和</code>](<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)%E6%96%87%E6%9C%AC%EF%BC%8C%E4%BD%BF%E5%86%85%E5%AE%B9%E6%9B%B4%E6%95%B4%E6%B4%81%E3%80%81%E6%9B%B4%E6%98%93%E4%BA%8E%E8%B7%9F%E9%9A%8F%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td)文本，使内容更整洁、更易于跟随。</a></li></ul><h3 id="2-10-网页安全字体"><a href="#2-10-网页安全字体" class="headerlink" title="2.10 网页安全字体"></a>2.10 网页安全字体</h3><p>说到字体可用性，只有某几个字体通常可以应用到所有系统，因此可以毫无顾忌地使用。这些都是所谓的 <strong>网页安全字体</strong>。</p><p>大多数时候，作为网页开发者，我们希望对用于显示我们的文本内容的字体有更具体的控制。问题在于，需要一个方法来知道当前正在浏览我们的网站网页的电脑，它有哪些可用字体。我们并不是总能在每种情况下都知道这一点，但是网络安全字体在几乎所有最常用的操作系统（Windows，Mac，最常见的 Linux 发行版，Android 和 iOS 版本）中都可用。</p><p>实际的 Web 安全字体列表将随着操作系统的发展而改变，但是可以认为下面的字体是网页安全的，至少对于现在来说 (它们中的许多都非常流行，这要感谢微软在 90 年代末和 21 世纪初期的倡议*<a href="https://en.wikipedia.org/wiki/Core_fonts_for_the_Web">Core fonts for the Web</a>* )：</p><table><thead><tr><th align="left">字体名称</th><th align="left">泛型</th><th align="left">注意</th></tr></thead><tbody><tr><td align="left">Arial</td><td align="left">sans-serif</td><td align="left">通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但 Helvetica 被认为具有更好的形状，即使 Arial 更广泛地可用。</td></tr><tr><td align="left">Courier New</td><td align="left">monospace</td><td align="left">某些操作系统有一个 Courier New 字体的替代（可能较旧的）版本叫 Courier。使用 Courier New 作为 Courier 的首选替代方案，被认为是最佳做法。</td></tr><tr><td align="left">Georgia</td><td align="left">serif</td><td align="left"></td></tr><tr><td align="left">Times New Roman</td><td align="left">serif</td><td align="left">某些操作系统有一个 Times New Roman 字体的替代（可能较旧的）版本叫 Times。使用 Times 作为 Times New Roman 的首选替代方案，被认为是最佳做法。</td></tr><tr><td align="left">Trebuchet MS</td><td align="left">sans-serif</td><td align="left">您应该小心使用这种字体——它在移动操作系统上并不广泛。</td></tr><tr><td align="left">Verdana</td><td align="left">sans-serif</td><td align="left"></td></tr></tbody></table><p><strong>备注：</strong> 在各种资源中，<a href="http://www.cssfontstack.com/">cssfontstack.com</a> 网站维护了一个可用在 Windows 和 Mac 操作系统上使用的网页安全字体的列表，这可以帮助决策网站的安全性。</p><p><strong>备注：</strong> 有一个可以下载来自一个网页的自定义字体的方法，允许你通过任何你想要的方法来定制你使用的字体：<strong>网页字体</strong>。这个有一点复杂，我们将在这个模块中的另一篇文章中讨论这一点。</p><h4 id="默认字体"><a href="#默认字体" class="headerlink" title="默认字体"></a>默认字体</h4><p>CSS 定义了 5 个常用的字体名称：<code>serif</code>, <code>sans-serif</code>, <code>monospace</code>, <code>cursive</code>, 和 <code>fantasy</code>. 这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。这是一种糟糕的情况，浏览器会尽力提供一个看上去合适的字体。 <code>serif</code>, <code>sans-serif</code> 和 <code>monospace</code> 是比较好预测的，默认的情况应该比较合理，另一方面，<code>cursive</code> 和 <code>fantasy</code> 是不太好预测的，我们建议使用它们的时候应该稍微注意一些，多多测试。</p><p>五个名称定义如下：</p><table><thead><tr><th align="left">名称</th><th align="left">定义</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>serif</code></td><td align="left">衬线字体，即有衬线的字体（衬线是指字体笔画尾端的小装饰，存在于某些印刷体字体中）。</td><td align="left"></td></tr><tr><td align="left"><code>sans-serif</code></td><td align="left">无衬线字体。</td><td align="left"></td></tr><tr><td align="left"><code>monospace</code></td><td align="left">等宽字体，指包含的全部字符的宽度相同的字体，通常在编辑代码时使用。</td><td align="left"></td></tr><tr><td align="left"><code>cursive</code></td><td align="left">手写字体，对于英文字符而言通常具有顺滑的连接笔画以模拟手写效果。</td><td align="left"></td></tr><tr><td align="left"><code>fantasy</code></td><td align="left">装饰字体。</td><td align="left"></td></tr></tbody></table><h4 id="字体栈"><a href="#字体栈" class="headerlink" title="字体栈"></a>字体栈</h4><p>由于你无法保证你想在你的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 你可以提供一个<strong>字体栈</strong> (<strong>font stack</strong>)，这样的话，浏览器就有多种字体可以选择了。只需包含一个 <code>font-family</code> 属性，其值由几个用逗号分离的字体名称组成。比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Trebuchet MS&quot;</span>, Verdana, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><p>在这种情况下，浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。</p><p>在字体栈的最后提供一个合适的通用的字体名称是个不错的办法，这样的话，即使列出的字体都无法使用，浏览器至少可以提供一个还算合适的选择。为了强调这一点，如果没有其他选项可用，那么段落将被赋予浏览器的默认衬线字体 - 通常是 Time New Roman - 这对于 sans-serif 字体是不利的！</p><p><strong>备注：</strong> 有一些字体名称不止一个单词，比如<code>Trebuchet MS</code> ，那么就需要用引号包裹。</p><h4 id="一个使用-font-family-的例子"><a href="#一个使用-font-family-的例子" class="headerlink" title="一个使用 font-family 的例子"></a>一个使用 font-family 的例子</h4><p>让我们把它添加到之前的例子上，给段落一个 sans-serif 的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>这给我们以下结果：</p><iframe class="sample-code-frame" title="一个使用 font-family 的例子 sample" id="frame_一个使用_font-family_的例子" width="100%" height="220" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8_font-family_%E7%9A%84%E4%BE%8B%E5%AD%90.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>在我们之前的模块中的<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units">CSS values and units</a> 文章，我们回顾了<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>. 字体大小 (通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 属性设置) 可以取大多数这些单位的值 (以及其他，比如百分比 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#percentages">percentages</a>)，然而你在调整字体大小时，最常用的单位是：</p><ul><li>px (像素): 将像素的值赋予给你的文本。这是一个绝对单位，它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。</li><li>em: 1em 等于我们设计的当前元素的父元素上设置的字体大小 (更加具体的话，比如包含在父元素中的大写字母 M 的宽度) 如果你有大量设置了不同字体大小的嵌套元素，这可能会变得棘手，但它是可行的，如下图所示。为什么要使用这个麻烦的单位呢？当你习惯这样做时，那么就会变得很自然，你可以使用em调整任何东西的大小，不只是文本。你可以有一个单位全部都使用 em 的网站，这样维护起来会很简单。</li><li>rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小， (i.e. <html>) ，而不是父元素。这可以让你更容易计算字体大小，但是遗憾的是， rem 不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用em 或 px, 或者是 polyfill 就像 REM-unit-polyfill. （这个单位在“CSS 的值和单位”一节也有讲解）</li></ul><p>元素的 font-size 属性是从该元素的父元素继承的。所以这一切都是从整个文档的根元素——<html>开始，浏览器的 font-size 标准设置的值为 16px。在根元素中的任何段落 (或者那些浏览器没有设置默认大小的元素)，会有一个最终的大小值：16px。其他元素也许有默认的大小，比如 <h1> (en-US) 元素有一个 2em 的默认值，所以它的最终大小值为 32px。当你开始更改嵌套元素的字体大小时，事情会变得棘手。比如，如果你有一个 <article> 元素在你的页面上，然后设置它的 font-size 为 1.5em (通过计算，可以得到大小为 24px)，然后想让 <article> 元素中的段落获得一个计算值为 20px 的大小，那么你应该使用多少 em。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- document base font-size is 16px --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span> <span class="hljs-comment">&lt;!-- If my font-size is 1.5em --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>My paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- How do I compute to 20px font-size? --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你需要将 em 的值设置为 20&#x2F;24, 或者 <code>0.83333333em</code>. 这个计算可能比较复杂，所以当你设置的时候，你需要仔细一些。如果可以使用 rem 的话，那实现起来就变得简单不少，避免在可能的情况下设置容器元素的字体大小。</p><h4 id="一个简单的-size-示例"><a href="#一个简单的-size-示例" class="headerlink" title="一个简单的 size 示例"></a>一个简单的 size 示例</h4><p>当调整你的文本大小时，将文档 (document) 的基础 <code>font-size</code> 设置为 10px 往往是个不错的主意，这样之后的计算会变得简单，所需要的 (r)em 值就是想得到的像素的值除以 10，而不是 16。做完这个之后，你可以简单地调整在你的 HTML 中你想调整的不同类型文本的字体大小。在样式表的指定区域列出所有<code>font-size</code>的规则集是一个好主意，这样它们就可以很容易被找到。</p><p>我们的新结果是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.6rem</span>;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="一个简单的 size 示例 sample" id="frame_一个简单的_size_示例" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84_size_%E7%A4%BA%E4%BE%8B.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="字体样式、字体粗细、文本转换和文本装饰"><a href="#字体样式、字体粗细、文本转换和文本装饰" class="headerlink" title="字体样式、字体粗细、文本转换和文本装饰"></a>字体样式、字体粗细、文本转换和文本装饰</h4><p>CSS 提供了 4 种常用的属性来改变文本的样子：</p><ul><li><code>font-style</code>: 用来打开和关闭文本 italic (斜体)。可能的值如下 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态)：<ul><li><code>normal</code>: 将文本设置为普通字体 (将存在的斜体关闭)</li><li><code>italic</code>: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。</li><li><code>oblique</code>: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。</li></ul></li><li><code>font-weight</code>: 设置文字的粗体大小。这里有很多值可选 (比如-light, -normal,  -bold, -extrabold, -black, 等等), 不过事实上你很少会用到normal和bold以外的值：<ul><li><code>normal</code>, <code>bold</code>: 普通或者<strong>加粗</strong>的字体粗细</li><li><code>lighter</code>, <code>bolder</code>: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。<code>100</code>–<code>900</code>: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。</li></ul></li><li><code>text-transform</code>: 允许你设置要转换的字体。值包括：<ul><li><code>none</code>: 防止任何转型。</li><li><code>uppercase</code>: 将所有文本转为大写。</li><li><code>lowercase</code>: 将所有文本转为小写。</li><li><code>capitalize</code>: 转换所有单词让其首字母大写。</li><li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。</li></ul></li><li><code>text-decoration</code>: 设置&#x2F;取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为：<ul><li><code>none</code>: 取消已经存在的任何文本装饰。</li><li><code>underline</code>: 文本下划线。</li><li><code>overline</code>: 文本上划线</li><li><code>line-through</code>: 穿过文本的线。</li></ul></li></ul><p>你应该注意到<code>text-decoration</code>可以一次接受多个值，如果你想要同时添加多个装饰值，比如text-decoration: underline overline。同时注意<code>text-decoration</code>是一个缩写形式，它由<code>text-decoration-line</code>,<code>text-decoration-style</code>和<code>text-decoration-color</code>构成。你可以使用这些属性值的组合来创建有趣的效果，比如text-decoration: line-through red wavy.我们来看一下这几个属性添加到我们的例子中：</p><p>我们的新结果是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.6rem</span>;<br>  <span class="hljs-attribute">text-transform</span>: capitalize;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.4rem</span>;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="字体样式、字体粗细、文本转换和文本装饰 sample" id="frame_字体样式、字体粗细、文本转换和文本装饰" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%E3%80%81%E5%AD%97%E4%BD%93%E7%B2%97%E7%BB%86%E3%80%81%E6%96%87%E6%9C%AC%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%87%E6%9C%AC%E8%A3%85%E9%A5%B0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h4><p>你可以为你的文本应用阴影，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a> 属性。这最多需要 4 个值，如下例所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">text</span>-shadow: <span class="hljs-number">4</span>px <span class="hljs-number">4</span>px <span class="hljs-number">5</span>px red;<br></code></pre></td></tr></table></figure><p>4 个属性如下：</p><ol><li>阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>, 但是 px 是比较合适的。这个值必须指定。</li><li>阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上&#x2F;向下移动阴影，而不是左&#x2F;右。这个值必须指定。</li><li>模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为 0，这意味着没有模糊。可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</li><li>阴影的基础颜色，可以使用大多数的 CSS 颜色单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#colors">CSS color unit</a>. 如果没有指定，默认为 <code>black</code>.</li></ol><p><strong>备注：</strong> 正偏移值可以向右移动阴影，但也可以使用负偏移值来左右移动阴影，例如 <code>-1px -1px</code>.</p><h4 id="多种阴影"><a href="#多种阴影" class="headerlink" title="多种阴影"></a>多种阴影</h4><p>您可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">text</span>-shadow: -<span class="hljs-number">1</span>px -<span class="hljs-number">1</span>px <span class="hljs-number">1</span>px #aaa,<br>             <span class="hljs-attribute">0px</span> <span class="hljs-number">4</span>px <span class="hljs-number">1</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">5</span>),<br>             <span class="hljs-attribute">4px</span> <span class="hljs-number">4</span>px <span class="hljs-number">5</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">7</span>),<br>             <span class="hljs-attribute">0px</span> <span class="hljs-number">0</span>px <span class="hljs-number">7</span>px rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>.<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>如果我们把这个样式应用到我们 “Tommy the cat” 示例中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements"><code>&lt;h1&gt;</code> (en-US)</a> 元素，就像这样：</p><iframe class="sample-code-frame" title="多种阴影 sample" id="frame_多种阴影" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%A4%9A%E7%A7%8D%E9%98%B4%E5%BD%B1.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 你可以看到更多有趣的关于 <code>text-shadow</code> 使用的示例在 <a href="https://www.sitepoint.com/moonlighting-css-text-shadow/">Moonlighting with CSS text-shadow</a>.</p><h4 id="文本布局"><a href="#文本布局" class="headerlink" title="文本布局"></a>文本布局</h4><p>有了基本的字体属性，我们来看看我们可以用来影响文本布局的属性。</p><h4 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a> 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同：</p><ul><li><code>left</code>: 左对齐文本。</li><li><code>right</code>: 右对齐文本。</li><li><code>center</code>: 居中文字</li><li><code>justify</code>: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>，打破一些更长的词语。</li></ul><p>如果我们应用 <code>text-align: center;</code> 到我们例子中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements"><code>&lt;h1&gt;</code> (en-US)</a> 元素中，结果如下：</p><iframe class="sample-code-frame" title="文本对齐 sample" id="frame_文本对齐" width="100%" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性设置文本每行之间的高，可以接受大多数单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 来获得 <code>line-height</code>。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的 1.5 倍，你可以使用这个：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">line</span>-height: <span class="hljs-number">1</span>.<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>把这个样式应用到我们示例中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p"><code>&lt;p&gt;</code></a> 元素，结果如下：</p><iframe class="sample-code-frame" title="行高 sample" id="frame_行高" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E8%A1%8C%E9%AB%98.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="字母和单词间距"><a href="#字母和单词间距" class="headerlink" title="字母和单词间距"></a>字母和单词间距</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-spacing"><code>word-spacing</code></a> 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。你不会经常使用它们，但是可能可以通过它们，来获得一个特定的外观，或者让较为密集的文字更加可读。它们可以接受大多数单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</p><p>所以作为例子，如果我们把这个样式应用到我们的示例中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p"><code>&lt;p&gt;</code></a> 段落的第一行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会得到下面的结果：</p><iframe class="sample-code-frame" title="字母和单词间距 sample" id="frame_字母和单词间距" width="100%" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals/_sample_.%E5%AD%97%E6%AF%8D%E5%92%8C%E5%8D%95%E8%AF%8D%E9%97%B4%E8%B7%9D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="其他一些值得看一下的属性"><a href="#其他一些值得看一下的属性" class="headerlink" title="其他一些值得看一下的属性"></a>其他一些值得看一下的属性</h4><p>以上属性让你了解如何开始在网页上设置文本，但是你可以使用更多的属性。我们只是想介绍最重要的。一旦你习惯使用上面的内容，你还应该探索以下几点：</p><p>Font 样式：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>: 在小型大写字母和普通文本选项之间切换。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-kerning"><code>font-kerning</code></a>: 开启或关闭字体间距选项。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-feature-settings"><code>font-feature-settings</code></a>: 开启或关闭不同的 <a href="https://en.wikipedia.org/wiki/OpenType">OpenType</a> 字体特性。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-alternates"><code>font-variant-alternates</code></a>: 控制给定的自定义字体的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-caps"><code>font-variant-caps</code></a>: 控制大写字母替代字形的使用。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-east-asian"><code>font-variant-east-asian</code> (en-US)</a>: 控制东亚文字替代字形的使用，像日语和汉语。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-ligatures"><code>font-variant-ligatures</code></a>: 控制文本中使用的连写和上下文形式。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-numeric"><code>font-variant-numeric</code></a>: 控制数字，分式和序标的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-position"><code>font-variant-position</code></a>: 控制位于上标或下标处，字号更小的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size-adjust"><code>font-size-adjust</code></a>: 独立于字体的实际大小尺寸，调整其可视大小尺寸。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>: 在给定字体的可选拉伸版本中切换。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-underline-position"><code>text-underline-position</code></a>: 指定下划线的排版位置，通过使用 <code>text-decoration-line</code> 属性的<code>underline</code> 值。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-rendering"><code>text-rendering</code></a>: 尝试执行一些文本渲染优化。</li></ul><p>文本布局样式：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-indent"><code>text-indent</code></a>: 指定文本内容的第一行前面应该留出多少的水平空间。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-overflow"><code>text-overflow</code></a>: 定义如何向用户表示存在被隐藏的溢出内容。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a>: 定义如何处理元素内部的空白和换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>: 指定是否能在单词内部换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>: 定义文本的方向 (这取决于语言，并且通常最好让 HTML 来处理这部分，因为它是和文本内容相关联的。)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>: 为支持的语言开启或关闭连字符。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-break"><code>line-break</code></a>: 对东亚语言采用更强或更弱的换行规则。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align-last"><code>text-align-last</code></a>: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-orientation"><code>text-orientation</code></a>: 定义行内文本的方向。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap"><code>word-wrap</code></a>: 指定浏览器是否可以在单词内换行以避免超出范围。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</li></ul><h4 id="Font-简写"><a href="#Font-简写" class="headerlink" title="Font 简写"></a>Font 简写</h4><p>许多字体的属性也可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a> 的简写方式来设置 . 这些是按照以下顺序来写的： <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style"><code>font-style</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a>.</p><p>如果你想要使用 <code>font</code> 的简写形式，在所有这些属性中，只有 <code>font-size</code> 和 <code>font-family</code> 是一定要指定的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性之间必须放一个正斜杠。</p><p>一个完整的例子如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font</span>: italic normal bold normal <span class="hljs-number">3em</span>/<span class="hljs-number">1.5</span> Helvetica, Arial, sans-serif;<br></code></pre></td></tr></table></figure><h3 id="2-11-样式化列表"><a href="#2-11-样式化列表" class="headerlink" title="2.11 样式化列表"></a>2.11 样式化列表</h3><h4 id="列表特定样式"><a href="#列表特定样式" class="headerlink" title="列表特定样式"></a>列表特定样式</h4><p>现在我们来看一下列表的一般间距，我们来研究一些列表具有的特定属性。我们从三个属性开始了解，这三个属性可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul">&#96;&#96;</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol">&#96;&#96;</a> 元素上设置：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。</li></ul><h4 id="符号样式"><a href="#符号样式" class="headerlink" title="符号样式"></a>符号样式</h4><p>像上面所提及的， <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 属性允许你设置项目符号点的类型，在我们的例子中，我们在有序列表上设置了大写罗马数字：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ol</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">upper-roman</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果显示如下：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_lists/outer-bullets.png" alt="an ordered list with the bullet points set to appear outside the list item text."></p><p>您可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 参考页面查找到更多选项。</p><h4 id="项目符号位置"><a href="#项目符号位置" class="headerlink" title="项目符号位置"></a>项目符号位置</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> 设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。如上所示，默认值为 outside，这使项目符号位于列表项之外。</p><p>如果值设置为 inside，项目条目则位于行内。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ol</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">upper-roman</span>;<br>  <span class="hljs-built_in">list-style-position:</span> <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_lists/inner-bullets.png" alt="an ordered list with the bullet points set to appear inside the list item text."></p><h4 id="使用自定义的项目符号图片"><a href="#使用自定义的项目符号图片" class="headerlink" title="使用自定义的项目符号图片"></a>使用自定义的项目符号图片</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> 属性允许对于项目符号使用自定义图片。其语法相当简单：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">star</span>.<span class="hljs-string">svg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，这个属性在控制项目符号的位置，大小等方面是有限的。您最好使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 系列属性，您将在 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks">Styling boxes</a> 模块中了解更多信息。在这里我们仅做一点尝试！</p><p>结束我们的例子，我们样式化无序列表像这样（放到您之前所见的顶部）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">list-style-type</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">star.svg</span>);<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">1.6rem</span> <span class="hljs-number">1.6rem</span>;<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的所做如下：</p><ul><li>将<code>&lt;ul&gt;</code> 的 padding-left 从默认的 40px设置为 20px，然后在列表项上设置相同的数值。这就是说，整个列表项仍然排列在列表中，但是列表项产生了一些用于背景图像的填充。如果我们没有设置填充，背景图像将与列表项文本重叠，这看起来会很乱。</li><li>将 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> 设置为 none，以便默认情况下不会显示项目符号。我们将使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性来代替项目符号。</li><li>为每个无序列表项插入项目符号，其相应的属性如下：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>: 充当项目符号的图片文件的参考路径</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>: 这定义了所选元素背景中的图像将出现在哪里 - 在我们的示例中设置 <code>0 0</code>，这意味着项目符号将出现在每个列表项的最左上侧。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>: 设置背景图片的大小。理想条件下，我们想要项目符号与列表项的大小相同（比列表项稍大或稍小亦可）。我们使用的尺寸为 1.6rem（16px），它非常吻合我们为项目符号设置的 20px 的填充，16px 加上 4px 的空格间距，可以使项目符号和列表项文本效果更好。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a>：默认条件下，背景图片不断复制直到填满整个背景空间，在我们的例子中，背景图片只需复制一次，所以我们设置值为 <code>no-repeat</code>。</li></ul></li></ul><p>效果显示如下：</p><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/image-bullets.png" alt="an unordered list with the bullet points set as little star images"></p><h4 id="list-style-速记"><a href="#list-style-速记" class="headerlink" title="list-style 速记"></a>list-style 速记</h4><p>上述提到的三种属性可以用一个单独的速记属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style"><code>list-style</code></a> 来设置。例如：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span>;<br>  <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url</span>(<span class="hljs-string">example</span>.<span class="hljs-string">png</span>);<br>  <span class="hljs-built_in">list-style-position:</span> <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以被如下方式代替：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> &#123;<br>  <span class="hljs-built_in">list-style:</span> <span class="hljs-string">square</span> <span class="hljs-string">url</span>(<span class="hljs-string">example</span>.<span class="hljs-string">png</span>) <span class="hljs-string">inside</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性值可以任意顺序排列，你可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside），如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。</p><h4 id="管理列表计数"><a href="#管理列表计数" class="headerlink" title="管理列表计数"></a>管理列表计数</h4><p>有时，您可能想在有序列表上进行不同的计数方式。例如：从 1 以外的数字开始，或向后倒数，或者按步或多于 1 计数。HTML 和 CSS 有一些工具可以帮助您</p><h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-start"><code>start</code></a> 属性允许你从 1 以外的数字开始计数。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出的结果如下：</p><iframe class="sample-code-frame" title="start sample" id="frame_start" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.start.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-reversed"><code>reversed</code></a> 属性将启动列表倒计数。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">reversed</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出的结果如下：</p><iframe class="sample-code-frame" title="reversed sample" id="frame_reversed" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.reversed.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-value"><code>value</code></a> 属性允许设置列表项指定数值，示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出的结果如下：</p><iframe class="sample-code-frame" title="value sample" id="frame_value" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists/_sample_.value.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 纵然你使用非数字的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a>, 你仍需要使用与数值同等意义的值作为 value 的属性。</p><h3 id="2-12-样式化链接"><a href="#2-12-样式化链接" class="headerlink" title="2.12 样式化链接"></a>2.12 样式化链接</h3><p>当为 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks">links</a> 添加样式时，理解利用伪类有效地建立链接状态是很重要的，以及如何为链接添加样式来实现常用的功能，比如说导航栏、选项卡。我们将在本文中关注所有这些主题。</p><h4 id="让我们来看一些链接"><a href="#让我们来看一些链接" class="headerlink" title="让我们来看一些链接"></a>让我们来看一些链接</h4><p>根据最佳实践 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks">创建超链接</a> 中的练习，我们看到了如何在你的 HTML 中实现链接。在本篇文章中，我们会以这个知识为基础，向你展示将样式应用到链接的最佳实践。</p><h4 id="链接状态"><a href="#链接状态" class="headerlink" title="链接状态"></a>链接状态</h4><p>第一件需要理解的事情是链接状态的概念，链接存在时处于不同的状态，每一个状态都可以用对应的 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors#pseudo-classes">伪类</a> 来应用样式：</p><ul><li><strong>Link (没有访问过的)</strong>: 这是链接的默认状态，当它没有处在其他状态的时候，它可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a> 伪类来应用样式。</li><li><strong>Visited</strong>: 这个链接已经被访问过了 (存在于浏览器的历史纪录), 它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a> 伪类来应用样式。</li><li><strong>Hover</strong>: 当用户的鼠标光标刚好停留在这个链接，它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a> 伪类来应用样式。</li><li><strong>Focus</strong>: 一个链接当它被选中的时候 (比如通过键盘的 Tab 移动到这个链接的时候，或者使用编程的方法来选中这个链接 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus"><code>HTMLElement.focus()</code> (en-US)</a>) 它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a> 伪类来应用样式。</li><li><strong>Active</strong>: 一个链接当它被激活的时候 (比如被点击的时候)，它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a> 伪类来应用样式。</li></ul><h4 id="默认的样式"><a href="#默认的样式" class="headerlink" title="默认的样式"></a>默认的样式</h4><p>下面的例子说明了一个链接的默认行为表现 (这里的 CSS 仅仅是为了放大和居中文本，使内容更加突出)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://mozilla.org&quot;</span>&gt;</span>A link to the Mozilla homepage<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="默认的样式 sample" id="frame_默认的样式" width="100%" height="120" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>当你观察默认样式的时候，你也许会注意到一些东西：</p><ul><li>链接具有下划线。</li><li>未访问过的 (Unvisited) 的链接是蓝色的。</li><li>访问过的 (Visited) 的链接是紫色的。</li><li>悬停 (Hover) 在一个链接的时候鼠标的光标会变成一个小手的图标。</li><li>选中 (Focus) 链接的时候，链接周围会有一个轮廓，你应该可以按 tab 来选中这个页面的链接 (在 Mac 上，你可能需要使用<em>Full Keyboard Access: All controls</em> 选项，然后再按下 Ctrl + F7 ，这样就可以起作用)</li><li>激活 (Active) 链接的时候会变成红色 (当你点击链接时，请尝试按住鼠标按钮。)</li></ul><p>有趣的是，这些默认的样式与 20 世纪 90 年代中期浏览器早期的风格几乎相同。这是因为用户知道以及期待链接就是这样变化的，如果链接的样式不同，就会让一些人感到奇怪。不过这不意味着你不应该为链接添加任何样式，只是你的样式不应该与用户预期的相差太大，你应该至少：</p><ul><li>为链接使用下划线，但是不要在其他内容上也用下划线，以作区分。如果你不想要带有下划线的链接，那你至少要用其他方法来高亮突出链接。</li><li>当用户悬停或选择 (hover 或者 focused) 的时候，使链接有相应的变化，并且在链接被激活 (active) 的时候，变化会有一些不同。可以使用以下 CSS 属性关闭&#x2F;更改默认样式：</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a> 文字的颜色</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor"><code>cursor</code></a> 鼠标光标的样式，你不应该把这个关掉，除非你有非常好的理由。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline"><code>outline</code></a> 文字的轮廓 (轮廓有点像边框，唯一的区别是边框占用了盒模型的空间，而轮廓没有；它只是设置在背景图片的顶部)。outline 是一个有用的辅助功能，所以在把它关掉之前考虑清楚；你至少应该将悬停 (hover) 状态的样式同时应用到选中 (focus) 状态上。</li></ul><p><strong>备注：</strong> 你不仅仅只限于上述属性来把样式应用到你的链接上，你可以用任何你喜欢的属性，就是不要搞得太疯狂！</p><h4 id="将样式应用到一些链接"><a href="#将样式应用到一些链接" class="headerlink" title="将样式应用到一些链接"></a>将样式应用到一些链接</h4><p>现在我们已经详细地看了默认的状态，让我们看一下典型的链接样式的设置。</p><p>开始之前，我们先写出我们的空规则集：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span> &#123;<br><br>&#125;<br><br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这几个规则的顺序是有意义的，因为链接的样式是建立在另一个样式之上的，比如，第一个规则的样式也会在后面的规则中生效，一个链接被激活 (activated) 的时候，它也是处于悬停 (hover) 状态的。如果你搞错了顺序，那么就可能不会产生正确的效果。要记住这个顺序，你可以尝试这样帮助记忆：<strong>L</strong>o<strong>V</strong>e <strong>F</strong>ears <strong>HA</strong>te.</p><p>现在让我们再添加一些信息，得到正确的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2rem</span>;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#265301</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#437A16</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#BAE498</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#265301</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还提供了一些示例 HTML，供你应用 CSS：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>There are several browsers available, such as <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.mozilla.org/zh-CN/firefox/&quot;</span>&gt;</span>Mozilla<br>Firefox<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google.com/chrome/index.html&quot;</span>&gt;</span>Google Chrome<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, and<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.microsoft.com/zh-CN/windows/microsoft-edge&quot;</span>&gt;</span>Microsoft Edge<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>把这两个放在一起，我们得到这样的结果：</p><iframe class="sample-code-frame" title="将样式应用到一些链接 sample" id="frame_将样式应用到一些链接" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%B0%86%E6%A0%B7%E5%BC%8F%E5%BA%94%E7%94%A8%E5%88%B0%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>那么我们在这里做了什么？这个看起来肯定和默认的样式不同，但仍然提供了一个熟悉的体验，好让用户知道发生了什么：</p><ul><li>第一和第二条规则和本次讨论关系不大。</li><li>第三个规则使用了 <code>a</code> 选择器，取消了默认的文本下划线和链接被选中（focus）时的轮廓（outline）（不同浏览器的默认行为可能不同），并为每个链接添加了少量的内边距（padding），所有这一切将在之后变得明确。</li><li>接着，我们使用<code>a:link</code>和<code>a:visited</code>选择器来设置未访问（unvisited）链接和访问过（visited）的链接的一点颜色上的变化，然后就能分辨开来了。</li><li>下面两条规则使用<code>a:focus</code>和<code>a:hover</code>来设置选中（focus）和悬停（hover）的链接为不同的背景颜色，再加上一个下划线，使链接更加突出。这里有两点需要注意：<ul><li>下划线是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a> 创造的，而不是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a>，有一些人喜欢这样，因为前者比后者有更好的样式选项，并且绘制的位置会稍微低一点，所以不会穿过字母 (比如 字母 g 和 y 底部).</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>的值被设置为<code>1px solid</code>，没有指定颜色。这样做可以使边框采用和元素文本一样的颜色，这在这样的情况下是很有用的，因为链接的每种状态下，文本是不同的颜色。</li></ul></li><li>最后，<code>a:active</code> 用来给链接一个不同的配色方案，当链接被激活 (activated) 时，让链接被激活的时候更加明显。</li></ul><h4 id="动手练习：为你的链接添加样式"><a href="#动手练习：为你的链接添加样式" class="headerlink" title="动手练习：为你的链接添加样式"></a>动手练习：为你的链接添加样式</h4><p>在这个动手练习部分，我们希望你使用我们的空规则集，然后添加你自定义的规则，从而使链接看上去比较酷。发挥你的想象力，大胆地做吧。我们相信你可以想出一些更酷的东西，就像我们上面的例子一样。</p><p>如果你犯了错误，你都可以使用 <em>Reset 按钮来重置。</em> 如果你遇到了困难，可以按 <em>Show solution</em> 按钮来显示我们上文中的例子。</p><iframe class="sample-code-frame" title="动手练习：为你的链接添加样式 sample" id="frame_动手练习：为你的链接添加样式" width="700" height="800" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%8A%A8%E6%89%8B%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%93%BE%E6%8E%A5%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="在链接中包含图标"><a href="#在链接中包含图标" class="headerlink" title="在链接中包含图标"></a>在链接中包含图标</h4><p>常见的做法是在链接中包含图标，使链接提供更多关于链接指向的内容的信息。让我们来看一个简单的例子，例子中为一个外部链接 (链接指向的不是本站，而是外部站点)。这样的图标通常看起来像一个指向盒子的小箭头，比如，我们会使用<a href="https://icons8.com/web-app/741/external-link">icons8.com 上的这个优秀的范例</a>。</p><p>让我们来看一些能给我们这个效果的 HTML 和 CSS。先是一些简单的等待你样式化的 HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>For more information on the weather, visit our <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;weather.html&quot;</span>&gt;</span>weather page<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>,<br>look at <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://en.wikipedia.org/wiki/Weather&quot;</span>&gt;</span>weather on Wikipedia<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>, or check<br>out <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.extremescience.com/weather.htm&quot;</span>&gt;</span>weather on Extreme Science<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着是 CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: purple;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;http&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;external-link-52.png&#x27;</span>) no-repeat <span class="hljs-number">100%</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">16px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">19px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="在链接中包含图标 sample" id="frame_在链接中包含图标" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E5%9C%A8%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8C%85%E5%90%AB%E5%9B%BE%E6%A0%87.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>那么这里发生了什么？我们将跳过大部分的 CSS，因为那些只是你之前看过的相同的信息。最后一条规则很有趣，这里，我们在外部链接上插入了一个自定义背景图片，这和上篇<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists#using_a_custom_bullet_image">自定义列表项目符号</a>文章的做法很像。这次，我们使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 简写，而不是分别使用多个属性。我们设置了我们想要插入的图片的路径，指定了 <code>no-repeat</code> ，这样我们只插入了一次图片，然后指定位置为 100%，使其出现在内容的右边，距离上方是 0px。</p><p>我们也使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a> 来指定要显示的背景图像的大小，为了满足响应式网站设计的需要，在图标更大，需要再重新调整它的大小的时候，这样做是很有帮助的。但是，这仅适用于 IE 9 及更高版本。所以你如果需要支持那些老的浏览器，只能调整图像的原始大小，然后插入。</p><p>最后，我们在链接上设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a> ，为背景图片留出空间，这样就不会让它和文本重叠了。</p><p>最后的问题，我们是如何只选中了外部链接的？如果你正确编写你的HTML 链接 ，你应该只会在外部链接上使用绝对 URL，如果链接是链接你的站点的其他部分，那么使用相对链接是更加高效的。因此“http”文本应该只出现在外部链接上，为此我们可以使用一个属性选择器——a[href*&#x3D;”http”] ——选中<code>&lt;a&gt;</code>元素，但是这样只会选中那些拥有 href 属性，且属性的值包含 “http” 的<code>&lt;a&gt;</code>的元素。</p><p>就这样啦，尝试重新审视上面的动手练习部分，尝试这种新技术！</p><p><strong>备注：</strong> 不要担心，如果你目前不熟悉 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks">backgrounds</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks">responsive web design (en-US)</a> ; 这些会在其他地方解释。</p><h4 id="样式化链接为按钮"><a href="#样式化链接为按钮" class="headerlink" title="样式化链接为按钮"></a>样式化链接为按钮</h4><p>目前在本文中探索的用法也可以用在其他方面。比如，悬停 (hover) 的状态可以为不同的元素应用样式，不只是链接，你也许会想添加悬停状态的样式到段落、列表项、或者是其他东西。</p><p>此外，在某些情况下，链接通常会应用样式，使它看上去的效果和按钮差不多，一个网站导航菜单通常是标记为一个列表，列表中包含链接，这可以很容易地被设计为看起来像一组控制按钮或是选项卡，主要是用于让用户可以访问站点的其他部分，现在让我们来看一看。</p><p>首先，一些 HTML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Pizza<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Music<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Wombats<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Finland<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，是我们的 CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">19.5%</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0.625%</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">color</span>: black;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: red;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><p>这给我们以下结果：</p><iframe class="sample-code-frame" title="样式化链接为按钮 sample" id="frame_样式化链接为按钮" width="100%" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/Styling_text/Styling_links/_sample_.%E6%A0%B7%E5%BC%8F%E5%8C%96%E9%93%BE%E6%8E%A5%E4%B8%BA%E6%8C%89%E9%92%AE.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>让我们来解释一下这里发生了什么，主要是几个有趣的部分：</p><ul><li>我们的第二条规则删除了 <ul> 元素的默认的 padding，然后设置了它的宽度是外部容器 <body> (在这次条件下) 的 100% 。</li><li><li> 元素通常默认是块元素 (可见 types of CSS boxes 回顾)，意味着它们各自会占用一行。在这个例子中，我们创建了一组水平列表的链接，所以在第三条规则中，我们设置了 display 属性为 inline，这会导致列表中的每项内容都会一起出现在同一行，它们现在表现得就像内联元素。</li><li>第四条规则，主要是 <a> 元素的样式，这里比较复杂; 让我们一步一步来看：<ul><li>和前面的例子一样，我们首先关掉了 text-decoration 和 outline，我们不希望这些破坏我们链接的样子。<br>接着，我们设置 display 为 inline-block ，<a> 元素默认为内联元素，而且我们不希望它们像值为 block 时一样，线条超出自己的内容，我们确实想要控制它们的大小inline-block 允许我们这样做。</li><li>接着是尺寸的设置！我们要填满整个 <ul> 的宽度，为按钮之间留一些间距 (margin) (但不是右边边缘的间距)，我们有 5 个按钮需要容纳，所以它们的大小应该一样。为了做到这一点，我们设置 width 为 19.5%，然后 margin-right 为 0.625%. 你会注意到所有宽度加起来是 100.625%, 这样会让最后一个按钮溢出 <ul> ，然后显示到下一行中。但是，我们使用了下一条规则让它恢复到了 100%，这条规则选中了列表中的最后一个 <a>元素，然后删除了它的间距 (margin)。完成！</li><li>最后三条声明就比较简单了，主要是为链接各个状态添加了颜色。我们居中了每个链接中的文本，设置 line-height 为 3，让按钮有一些高度 (这也具有垂直居中文本的优点)，并设置文本的颜色为黑色。</li></ul></li></ul><p><strong>备注：</strong> 你也许会注意到 HTML 中的列表的每项内容都在同一行上，这是因为 inline-block 元素在页面上创建的空格换行符，就像几个字之间的空格，这样的空隙也许会破坏我们的水平导航菜单布局。所以我们删除了空格。你可以在 <a href="https://css-tricks.com/fighting-the-space-between-inline-block-elements/">Fighting the space between inline block elements</a> 找到有关此问题的更多信息（和解决方案）。</p><h3 id="2-13-css布局"><a href="#2-13-css布局" class="headerlink" title="2.13 css布局"></a>2.13 css布局</h3><p>此刻，我们已经看过 CSS 的基础知识，如何设置文本的样式，以及如何设置和操作内容所在的框。现在是时候看看如何把你的盒子放在与视口相关的正确位置上。我们已经涵盖了必要的先决条件，所以我们现在可以深入到 CSS 布局，查看不同的显示设置，涉及浮动和定位的传统布局方法，以及像 flexbox 这样的现代布局工具。</p><p>CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口&#x2F;窗口的位置。在这个模块中将涉及更多关于页面<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Layout_mode">布局技术</a>的细节：</p><ul><li>正常布局流</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a>属性</li><li>弹性盒子</li><li>网格</li><li>浮动</li><li>定位</li><li>CSS 表格布局</li><li>多列布局</li></ul><p>每种技术都有它们的用途，各有优缺点，相互辅助。通过理解各个布局方法的设计理念，你能够找到构建你想要的网页需要的布局方案。</p><h4 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h4><p>正常布局流（normal flow）是指在不对页面进行任何布局控制时，浏览器默认的 HTML 布局方式。让我们快速地看一个 HTML 的例子：</p><p>注意，HTML 元素完全按照源码中出现的先后次序显示——第一个段落、无序列表、第二个段落。</p><p>出现在另一个元素下面的元素被描述为<strong>块</strong>元素，与出现在另一个元素旁边的<strong>内联元素</strong>不同，内联元素就像段落中的单个单词一样。</p><p>当你使用 css 创建一个布局时，你正在离开<strong>正常布局流</strong>，但是对于页面上的多数元素，<strong>正常布局流</strong>将完全可以创建你所需要的布局。从一个结构良好的 Html 文档开始是非常重要，因为你可以按照默认的方式来搭建页面，而不是自造车轮。</p><p>下列布局技术会覆盖默认的布局行为：</p><ul><li><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a></strong> 属性 — 标准的 value，比如<code>block</code>, <code>inline</code> 或者 <code>inline-block</code> 元素在正常布局流中的表现形式 (见 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model#types_of_css_boxes">Types of CSS boxes</a>). 接着是全新的布局方式，通过设置<code>display</code>的值，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">CSS Grid</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">Flexbox</a>.</li><li><strong>浮动</strong>——应用 <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a></strong> 值，诸如 <code>left</code> 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。</li><li><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a></strong> 属性 — 允许你精准设置盒子中的盒子的位置，正常布局流中，默认为 <code>static</code> ，使用其它值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。</li><li><strong>表格布局</strong>— 表格的布局方式可以用在非表格内容上，可以使用<code>display: table</code>和相关属性在非表元素上使用。</li><li><strong>多列布局</strong>— 这个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Columns">Multi-column layout</a> 属性 可以让块按列布局，比如报纸的内容就是一列一列排布的。</li></ul><h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>在 css 中实现页面布局的主要方法是设定display属性的值。此属性允许我们更改默认的显示方式。正常流中的所有内容都有一个display的值，用作元素的默认行为方式。例如，英文段落显示在一个段落的下面，这是因为它们的样式是display:block。如果在段落中的某个文本周围创建链接，则该链接将与文本的其余部分保持内联，并且不会打断到新行。这是因为<a>元素默认为display:inline。</p><p>您可以更改此默认显示行为。例如，<li>元素默认为display:block，这意味着在我们的英文文档中，列表项显示为一个在另一个之下。如果我们将显示值更改为inline，它们现在将显示在彼此旁边，就像单词在句子中所做的那样。事实上，您可以更改任何元素的display值，这意味着您可以根据它们的语义选择 html 元素，而不必关心它们的外观。他们的样子是你可以改变的。</p><p>除了可以通过将一些内容从<code>block</code>转换为<code>inline</code>（反之亦然）来更改默认表示形式之外，还有一些更大的布局方法以<code>display</code>值开始。但是，在使用这些属性时，通常需要调用其他属性。在讨论布局时，对我们来说最重要的两个值是 <code>display: flex</code> 和 <code>display: grid</code>。</p><h4 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h4><p>Flexbox 是 CSS 弹性盒子布局模块（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexible Box Layout</a> Module）的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。要使用 flexbox，你只需要在想要进行 flex 布局的父元素上应用<code>display: flex</code> ，所有直接子元素都将会按照 flex 进行布局。我们来看一个例子。</p><h4 id="设置-display-flex"><a href="#设置-display-flex" class="headerlink" title="设置 display:flex"></a>设置 display:flex</h4><p>下面这些 HTML 标记描述了一个 class 为<code>wrapper</code>的容器元素，它的内部有三个<code>&lt;div&gt;</code>元素。它们在我们的英文文档当中，会默认地作为块元素从上到下进行显示。</p><p>现在，当我们把<code>display: flex</code>添加到它的父元素时，这三个元素就自动按列进行排列。这是由于它们变成了*flex 项 (flex items)*，按照 flex 容器（也就是它们的父元素）的一些 flex 相关的初值进行 flex 布局：它们整整齐齐排成一行，是因为父元素上<code>flex-direction</code>的初值是<code>row</code>。它们全都被拉伸至和最高的元素高度相同，是因为父元素上<code>align-items</code>属性的初值是<code>stretch</code>。这就意味着所有的子元素都会被拉伸到它们的 flex 容器的高度，在这个案例里就是所有 flex 项中最高的一项。所有项目都从容器的开始位置进行排列，排列成一行后，在尾部留下一片空白。</p><h4 id="设置-flex-属性"><a href="#设置-flex-属性" class="headerlink" title="设置 flex 属性"></a>设置 flex 属性</h4><p>除了上述可以被应用到 flex 容器的属性以外，还有很多属性可以被应用到 flex 项 (flex items) 上面。这些属性可以改变 flex 项在 flex 布局中占用宽&#x2F;高的方式，允许它们通过伸缩来适应可用空间。</p><p>作为一个简单的例子，我们可以在我们的所有子元素上添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 属性，并赋值为<code>1</code>，这会使得所有的子元素都伸展并填充容器，而不是在尾部留下空白，如果有更多空间，那么子元素们就会变得更宽，反之，他们就会变得更窄。除此之外，如果你在 HTML 标记中添加了一个新元素，那么它们也会变得更小，来为新元素创造空间——不管怎样，最终它们会调整自己直到占用相同宽度的空间。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>    display: flex;<br>&#125;<br><br>.<span class="hljs-keyword">wrapper</span> &gt; div &#123;<br>    flex: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><iframe class="sample-code-frame" title="设置 flex 属性 sample" id="frame_设置_flex_属性" width="300" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%AE%BE%E7%BD%AE_flex_%E5%B1%9E%E6%80%A7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 为了找到更多关于 Flexbox 的信息，看看我们的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">Flexbox</a> 的文章。</p><h4 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h4><p>Flexbox 用于设计横向或纵向的布局，而 Grid 布局则被设计用于同时在两个维度上把元素按行和列排列整齐。</p><h4 id="设置-display-grid"><a href="#设置-display-grid" class="headerlink" title="设置 display: grid"></a>设置 display: grid</h4><p>同 flex 一样，你可以通过指定 display 的值来转到 grid 布局：<code>display: grid</code>。下面的例子使用了与 flex 例子类似的 HTML 标记，描述了一个容器和若干子元素。除了使用<code>display:grid</code>，我们还分别使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows"><code>grid-template-rows</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-columns"><code>grid-template-columns</code></a> 两个属性定义了一些行和列的轨道。定义了三个<code>1fr</code>的列，还有两个<code>100px</code>的行之后，无需再在子元素上指定任何规则，它们自动地排列到了我们创建的格子当中。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>    display: grid;<br>    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px;<br>    grid-gap: <span class="hljs-number">10</span>px;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box6</span>&quot;&gt;<span class="hljs-symbol">Six</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="设置 display: grid sample" id="frame_设置_display_grid" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%AE%BE%E7%BD%AE_display_grid.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="在网格内放置元素"><a href="#在网格内放置元素" class="headerlink" title="在网格内放置元素"></a>在网格内放置元素</h4><p>一旦你拥有了一个 grid，你也可以显式地将元素摆放在里面，而不是依赖于浏览器进行自动排列。在下面的第二个例子里，我们定义了一个和上面一样的 grid，但是这一次我们只有三个子元素。我们利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column"><code>grid-column</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row"><code>grid-row</code></a> 两个属性来指定每一个子元素应该从哪一行&#x2F;列开始，并在哪一行&#x2F;列结束。这就能够让子元素在多个行&#x2F;列上展开。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box1</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box2</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box3</span> &#123;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="在网格内放置元素 sample" id="frame_在网格内放置元素" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%9C%A8%E7%BD%91%E6%A0%BC%E5%86%85%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 这两个例子只是展示了 grid 布局的冰山一角，要深入了解 grid 布局，请参阅我们的文章<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">Grid Layout</a>。</p><p>这篇指南的其余部分介绍了其他的布局方式，它们与你的页面的主要布局结构关系不大，但是却能够帮助你实现特殊的操作。同时，只要你理解了每一个布局任务的初衷，你就能够马上意识到哪一种布局更适合你的组件。</p><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>把一个元素“浮动”(float) 起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流 (normal flow) 中移除，这时候其他的周围内容就会在这个被设置浮动 (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>) 的元素周围环绕。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性有四个可能的值：</p><ul><li><code>left</code> — 将元素浮动到左侧。</li><li><code>right</code> — 将元素浮动到右侧。</li><li><code>none</code> — 默认值，不浮动。</li><li><code>inherit</code> — 继承父元素的浮动属性。</li></ul><p>在下面这个例子当中，我们把一个<code>&lt;div&gt;</code>元素浮动到左侧，并且给了他一个右侧的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>，把文字推开。这给了我们文字环绕着这个<code>&lt;div&gt;</code>元素的效果，在现代网页设计当中，这是你唯一需要学会的事情。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;h1&gt;Simple float example&lt;/h1&gt;<br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;Float&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>&lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar <span class="hljs-built_in">id</span> metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, <span class="hljs-keyword">at</span> ultricies tellus laoreet sit amet. Sed auctor cursus massa <span class="hljs-keyword">at</span> porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut <span class="hljs-built_in">id</span> ornare felis, eget fermentum sapien.&lt;/p&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="浮动 sample" id="frame_浮动" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E6%B5%AE%E5%8A%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> CSS 浮动的知识会在我们关于 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">浮动</a>的教程当中被详细地解释。除此之外，如果您想要了解在 Flexbox 和 Grid 布局出现之前我们是如何进行列布局的（仍然有可能碰到这种情形），请阅读我们关于<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">传统布局方式</a>的文章。</p><h4 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h4><p>定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。定位 (positioning) 并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。</p><p>有一些非常有用的技术在特定的布局下依赖于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>属性。同时，理解定位 (positioning) 也能够帮助你理解正常布局流 (normal flow)，理解把一个元素移出正常布局流 (normal flow) 是怎么一回事。</p><p>有五种主要的定位类型需要我们了解：</p><ul><li><strong>静态定位</strong>（Static positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。</li><li><strong>相对定位</strong>（Relative positioning）允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计（design pinpointing）非常有用。</li><li><strong>绝对定位</strong>（Absolute positioning）将元素完全从页面的正常布局流（normal layout flow）中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 <code>&lt;html&gt;</code> 元素边缘固定，或者相对于该元素的<em>最近被定位祖先元素</em>（nearest positioned ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。</li><li><strong>固定定位</strong>（Fixed positioning）与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。</li><li><strong>粘性定位</strong>（Sticky positioning）是一种新的定位方式，它会让元素先保持和 <code>position: static</code> 一样的定位，当它的相对视口位置（offset from the viewport）达到某一个预设值时，它就会像 <code>position: fixed</code> 一样定位。</li></ul><h4 id="简单定位示例"><a href="#简单定位示例" class="headerlink" title="简单定位示例"></a>简单定位示例</h4><p>我们将展示一些示例代码来熟悉这些布局技术。这些示例代码都作用在下面这一个相同的 HTML 上：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-variable">&lt;h1&gt;</span>Positioning&lt;/h1&gt;<br><br><span class="hljs-variable">&lt;p&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br><span class="hljs-variable">&lt;p class=&quot;positioned&quot;&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br><span class="hljs-variable">&lt;p&gt;</span>I am a <span class="hljs-keyword">basic</span> <span class="hljs-built_in">block</span> level element.&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>该 HTML 将使用以下 CSS 默认样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><iframe class="sample-code-frame" title="简单定位示例 sample" id="frame_简单定位示例" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%AE%80%E5%8D%95%E5%AE%9A%E4%BD%8D%E7%A4%BA%E4%BE%8B.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对定位 (relative positioning) 让你能够把一个正常布局流 (normal flow) 中的元素从它的默认位置按坐标进行相对移动。比如将一个图标往下调一点，以便放置文字。我们可以通过下面的规则添加相对定位来实现效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们给中间段落的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 一个 <code>relative</code>值——这属性本身不做任何事情，所以我们还添加了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a>属性。这些可以将受影响的元素向下向右移——这可能看起来和你所期待的相反，但你需要把它看成是左边和顶部的元素被“推开”一定距离，这就导致了它的向下向右移动。</p><p>添加此代码将给出以下结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>,.<span class="hljs-number">3</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>);<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="相对定位 sample" id="frame_相对定位" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位用于将元素移出正常布局流 (normal flow)，以坐标的形式相对于它的容器定位到 web 页面的任何位置，以创建复杂的布局。有趣的是，它经常被用于与相对定位和浮动的协同工作。</p><p>回到我们最初的非定位示例，我们可以添加以下的 CSS 规则来实现绝对定位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们给我们的中间段一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>的 <code>absolute</code>值，并且和前面一样加上 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a> 属性。但是，添加此代码将给出以下结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>,.<span class="hljs-number">3</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">84</span>,<span class="hljs-number">104</span>);<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="绝对定位 sample" id="frame_绝对定位" width="100%" height="300" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这和之前截然不同！定位元素现在已经与页面布局的其余部分完全分离，并位于页面的顶部。其他两段现在靠在一起，好像之前那个中间段落不存在一样。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a>属性对绝对位置元素的影响不同于相对位置元素。在这一案例当中，他们没有指定元素相对于原始位置的移动程度。相反，在这一案例当中，它们指定元素应该从页面边界的顶部和左边的距离 (确切地说，是 <code>&lt;html&gt;</code>元素的距离)。我们也可以修改作为容器的那个元素（在这里是<code>&lt;html&gt;</code>元素），要了解这方面的知识，参见关于<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">定位 (positioning)</a>的课程</p><p>我们现在暂时不讨论固定定位（fixed positioning）——它基本上以相同的方式工作，除了它仍然固定在浏览器窗口的边缘，而不是它定位的父节点的边缘。</p><h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><p>固定定位 (fixed positioning) 同绝对定位 (absolute positioning) 一样，将元素从文档流 (document flow) 当中移出了。但是，定位的坐标不会应用于”容器”边框来计算元素的位置，而是会应用于视口 (viewport) 边框。利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。</p><p>在这个例子里面，我们在 HTML 加了三段很长的文本来使得页面可滚动，又加了一个带有<code>position: fixed</code>的盒子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Fixed positioning<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;positioned&quot;</span>&gt;</span>Fixed<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 3.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="固定定位 sample" id="frame_固定定位" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h4><p>粘性定位 (sticky positioning) 是最后一种我们能够使用的定位方式。它将默认的静态定位 (static positioning) 和固定定位 (fixed positioning) 相混合。当一个元素被指定了<code>position: sticky</code>时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了<code>position: fixed</code>一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="粘性定位 sample" id="frame_粘性定位" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 想要发现更多关于定位的信息，请参阅我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">Positioning</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Practical_positioning_examples">Practical positioning examples</a>文章。</p><h4 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h4><p>HTML 表格对于显示表格数据是很好的，但是很多年前——在浏览器中支持基本的 CSS 之前——web 开发人员过去也常常使用表格来完成整个网页布局——将它们的页眉、页脚、不同的列等等放在不同的表行和列中。这在当时是有效的，但它有很多问题——表布局是不灵活的，繁重的标记，难以调试和语义上的错误（比如，屏幕阅读器用户在导航表布局方面有问题）。</p><p>一个<code>&lt;table&gt;</code>标签之所以能够像表格那样展示，是由于 css 默认给<code>&lt;table&gt;</code>标签设置了一组 table 布局属性。当这些属性被应用于排列非<code>&lt;table&gt;</code>元素时，这种用法被称为“使用 CSS 表格”。</p><p>下面这个例子展示了一个这样的用法。使用 CSS 表格来进行布局，在现在这个时间点应该被认为是一种传统方法，它通常会被用于兼容一些不支持 Flexbox 和 Grid 的浏览器。</p><p>让我们来看一个例子。首先，创建 HTML 表单的一些简单标记。每个输入元素都有一个标签，我们还在一个段落中包含了一个标题。为了进行布局，每个标签&#x2F;输入对都封装在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>&lt;div&gt;</code></a>中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First of all, tell us your name and age.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>First name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span>Last name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>Age:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在，我们例子中的 CSS。除了使用 display 属性外，大多数 CSS 都是相当普通的。 <code>&lt;form&gt;</code>,<code> &lt;div&gt;</code>, <code>&lt;label&gt;</code>和<code>&lt;input&gt;</code>被告知要分别显示表、表行和表单元——基本上，它们会像 HTML 表格标记一样，导致标签和输入在默认情况下排列整齐。我们所要做的就是添加一些大小、边缘等等，让一切看起来都好一点，我们就完成了。</p><p>你会注意到标题段落已经给出了 display: table-caption;——这使得它看起来就像一个表格<code>&lt;caption&gt;</code> ——同时出于设计需要，我们通过caption-side: bottom; 告诉标题应该展示在表格的底部，即使这个<code>&lt;p&gt;</code>标记在源码中是在<code>&lt;input&gt;</code>之前。这就能让你有一点灵活的弹性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-row;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">label</span>, <span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">label</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">5%</span>;<br>  <span class="hljs-attribute">text-align</span>: right;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">form</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-caption;<br>  <span class="hljs-attribute">caption-side</span>: bottom;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#999</span>;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><iframe class="sample-code-frame" title="表格布局 sample" id="frame_表格布局" width="100%" height="170" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>你可以在 <a href="https://mdn.github.io/learning-area/css/styling-boxes/box-model-recap/css-tables-example.html">css-tables-example.html</a> 看到预览版 (也可以见<a href="https://github.com/mdn/learning-area/blob/master/css/styling-boxes/box-model-recap/css-tables-example.html">源码</a>)</p><h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>多列布局模组给了我们 一种把内容按列排序的方式，就像文本在报纸上排列那样。由于在 web 内容里让你的用户在一个列上通过上下滚动来阅读两篇相关的文本是一种非常低效的方式，那么把内容排列成多列可能是一种有用的技术。</p><p>要把一个块转变成多列容器 (multicol container)，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a>属性来告诉浏览器我们需要多少列，也可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a>来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。</p><p>在下面这个例子中，我们从一个 class 为<code>container</code>的<code>&lt;div&gt;</code>容器元素里边的一块 HTML 开始。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Multi-column layout<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们指定了该容器的<code>column-width</code>为 200 像素，这让浏览器创建了尽可能多的 200 像素的列来填充这一容器。接着他们共同使用剩余的空间来伸展自己的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="多列布局 sample" id="frame_多列布局" width="100%" height="200" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Introduction/_sample_.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="2-14-弹性盒子"><a href="#2-14-弹性盒子" class="headerlink" title="2.14 弹性盒子"></a>2.14 弹性盒子</h3><p>我们给的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flex</code> 的元素就像一个块级元素，但是它的子元素布局为 flex 项。下个部分将更详细地描述这些意味着什么。请注意，如果你希望该元素的子元素作为 flex 项，你也可以使用 <code>display</code> 值为 <code>inline-flex</code>，但是该元素的行为类似于行内元素。</p><h4 id="flex-模型说明"><a href="#flex-模型说明" class="headerlink" title="flex 模型说明"></a>flex 模型说明</h4><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png" alt="在从左到右的语言中，三个 flex 项并排放置在 flex 容器中。主轴——弹性容器布置 flex 方向上的轴——是水平的。主轴的两端是开始端和结束端，分别位于左侧和右侧。交叉轴是垂直的；垂直于主轴。交叉轴的开始端和结束端分别位于顶部和底部。flex 项沿着主轴排列，在这种情况下，宽度称为主轴尺寸，flex 项沿交叉轴排列，在这种情况下，高度称为交叉尺寸。"></p><ul><li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li><li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li><li>设置了 <code>display: flex</code> 的父元素，被称之为 <strong>flex 容器（flex container）。</strong></li><li>在 flex 容器中表现为弹性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）</li></ul><p>了解这些术语以便你阅读后续章节。如果你对使用的任何术语感到困惑，你可以随时返回这里。</p><h4 id="列还是行？"><a href="#列还是行？" class="headerlink" title="列还是行？"></a>列还是行？</h4><p>弹性盒子提供了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）——它默认值是 <code>row</code>，这使得它们在按你浏览器的默认语言方向排成一排（在英语&#x2F;中文浏览器中是从左到右）。</p><p>尝试将以下声明添加到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">&#96;&#96;</a> 元素的 css 规则里：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: column;<br></code></pre></td></tr></table></figure><p>你会看到，这会将那些元素设置为列布局，就像我们添加这些 CSS 之前。在继续之前，请从示例中删除此规则。</p><p><strong>备注：</strong> 你还可以使用 <code>row-reverse</code> 和 <code>column-reverse</code> 值反向排列 flex 项。用这些值试试看吧！</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>当你在布局中使用定宽或者定高的时候，可能会出现问题即处于容器中的弹性盒子子元素会溢出，破坏了布局。你可以看一下<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox-wrap0.html">弹性盒子——wrap0.html</a> 示例（你也可以拷贝到本地），如下所示：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example3.png" alt="简单弹性盒子示例，将所有 flex 项都布置在弹性容器的一行中。第八个 flex 项在浏览器窗口溢出，页面具有可见的水平和垂直滚动条，因为它无法容纳在窗口的宽度内，因为前七个 flex 项占用了视口中的可用空间。默认情况下，如果将弹性方向设置为行，浏览器会尝试将所有 flex 项放在一行中；如果弹性方向设置为列，则会尝试将所有 flex 项置于单列中。"></p><p>在这里我们看到，子代确实超出了它们的容器。解决此问题的一种方法是将以下声明添加到 section css 规则中：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">flex-<span class="hljs-keyword">wrap</span>: <span class="hljs-keyword">wrap</span><br></code></pre></td></tr></table></figure><p>同时，把以下规则也添加到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article"><code>&lt;article&gt;</code></a> 规则中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: <span class="hljs-number">200px</span>;<br></code></pre></td></tr></table></figure><p>现在尝试一下吧；你会看到布局比原来好多了：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example4.png" alt="flex 项在弹性容器中分多行排列。flex-wrap 属性在弹性容器中设置为“wrap”，如果上一行中的 flex 项在弹性容器外溢出，则弹性容器中显示新行中的 flex 项。每个 flex 项的宽度为 200 像素。所有物品都被拉伸到相同的高度，与内容最多的 flex 项一样高。"></p><p>我们现在有多个行。每行都安装了尽可能多的 flex 项。任何溢出都会向下移动到下一行。在 article 上设置的 <code>flex：200px</code> 声明意味着每个声明将至少为 200px 宽。我们稍后会更详细地讨论这个属性。你可能还注意到，最后一行上的最后几个项每个都变得更宽，以便把整个行填满。</p><p>但是这里我们可以做得更多。首先，改变 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 属性值为 <code>row-reverse</code>——你会看到仍然有多行布局，但是每一行元素排列的方向和原来是相反的了。</p><h4 id="flex-flow-缩写"><a href="#flex-flow-缩写" class="headerlink" title="flex-flow 缩写"></a>flex-flow 缩写</h4><p>到这里，应当注意到存在着 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap"><code>flex-wrap</code></a>——的缩写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-flow"><code>flex-flow</code></a>。比如，你可以将</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row;<br><span class="hljs-attribute">flex-wrap</span>: wrap;<br></code></pre></td></tr></table></figure><p>替换为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-flow</span>: row wrap;<br></code></pre></td></tr></table></figure><h4 id="flex-项的动态尺寸"><a href="#flex-项的动态尺寸" class="headerlink" title="flex 项的动态尺寸"></a>flex 项的动态尺寸</h4><p>现在让我们回到第一个例子，看看是如何控制 flex 项占用空间的比例的。打开你本地的 <a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox0.html">弹性盒子 0.html</a>，或者拷贝 <a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flexbox1.html">弹性盒子 1.html</a> 作为新的开始（<a href="https://mdn.github.io/learning-area/css/css-layout/flexbox/flexbox1.html">查看线上</a>）。</p><p>第一步，将以下规则添加到 CSS 的底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。本例中，我们设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">&#96;&#96;</a> 元素的 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为它是一个比例，这意味着将每个 flex 项的设置为 400000 的效果和 1 的时候是完全一样的。</p><p>现在在上一个规则下添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在当你刷新，你会看到第三个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article">&#96;&#96;</a> 元素占用了两倍的可用宽度和剩下的一样——现在总共有四个比例单位可用。前两个 flex 项各有一个，因此它们占用每个可用空间的 1&#x2F;4。第三个有两个单位，所以它占用 2&#x2F;4 或者说是 1&#x2F;2 的可用空间。</p><p>你还可以指定 flex 的最小值。尝试修改现有的 article 规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这表示“每个 flex 项将首先给出 200px 的可用空间，然后，剩余的可用空间将根据分配的比例共享”。尝试刷新，你会看到分配空间的差别。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example1.png" alt="简单的 flexbox 示例，flex 容器中有三个 flex 项。所有 flex 项的最低宽度为 200 像素——使用“flex”设置。前两个 flex 项的 flex 值为 1，第三个项的 flex 值为 2。这会将弹性容器中的剩余空间分成 4 个比例单位。前两个 flex 项各分配一个单元，第三个 flex 项分配两个单元，使第三个 flex 项比宽度相同的其他两个更宽。"></p><p>弹性盒子的真正价值可以体现在它的灵活性&#x2F;响应性，如果你调整浏览器窗口的大小，或者增加一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article"><code>&lt;artcle&gt;</code></a> 元素，这时的布局仍旧是好的。</p><h4 id="flex：缩写与全写"><a href="#flex：缩写与全写" class="headerlink" title="flex：缩写与全写"></a>flex：缩写与全写</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 是一个可以指定最多三个不同值的缩写属性：</p><ul><li>第一个就是上面所讨论过的无单位比例。可以单独指定全写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow"><code>flex-grow</code></a> 属性的值。</li><li>第二个无单位比例——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink"><code>flex-shrink</code></a>——一般用于溢出容器的 flex 项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。这是一个相当高级的弹性盒子功能，我们不会在本文中进一步说明。</li><li>第三个是上面讨论的最小值。可以单独指定全写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis"><code>flex-basis</code></a> 属性的值。</li></ul><p>我们建议不要使用全写属性，除非你真的需要（比如要去覆盖之前写的）。使用全写会多写很多的代码，它们也可能有点让人困惑。</p><h4 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h4><p>还可以使用弹性盒子的功能让 flex 项沿主轴或交叉轴对齐。让我们一起看一下新例子——<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/flex-align0.html">flex-align0.html</a>（<a href="https://mdn.github.io/learning-area/css/css-layout/flexbox/flex-align0.html">在线浏览</a>）——我们将会有一个整洁，灵活的按钮&#x2F;工具栏。此时，你看到了一个水平菜单栏，其中一些按钮卡在左上角，就像下面这样：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox-example5.png" alt="带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排列在一个弹性容器中。按钮卡在左上角，看起来不整洁。"></p><p>首先，拷贝一份到本地。</p><p>然后，将下面的 CSS 添加到例子的底部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flexbox_center_space-around.png" alt="带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排在一个弹性容器中。通过将对齐项属性设置为中心，flex 项位于横轴的中心。通过将 justify-content 属性设置为 space-around，flex 项沿着主轴均匀间隔。"></p><p>刷新一下页面，你就会看到这些按钮很好的垂直水平居中了。我们是通过下面所说的两个新的属性做到的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 控制 flex 项在交叉轴上的位置。</p><ul><li>默认的值是 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。我们的第一个例子在默认情况下得到相等的高度的列的原因。</li><li>在上面规则中我们使用的 <code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。</li><li>你也可以设置诸如 <code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 了解更多。</li></ul><p>你可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-self"><code>align-self</code></a> 属性覆盖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 的行为。比如，你可以这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">align-self</span>: flex-end;<br>&#125;<br></code></pre></td></tr></table></figure><p>！<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox/flexbox_first-child_flex-end.png">带有 Smile、Laugh、Wink、Shrug &amp; Blush 标签的五个按钮排在一个弹性容器中。除第一个项外，所有 flex 项都通过将对齐项属性设置为中心，位于十字轴的中心或垂直居中。第一项与交叉轴末端的弹性容器底部齐平，对齐自属性设置 flex 端。flex 项沿着容器的主轴或宽度均匀间隔。</a></p><p>去看看它产生的效果，然后删除它。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content"><code>justify-content</code></a> 控制 flex 项在主轴上的位置。</p><ul><li>默认值是 <code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。</li><li>你也可以用 <code>flex-end</code> 来让 flex 项到结尾处。</li><li><code>center</code> 在 <code>justify-content</code> 里也是可用的，可以让 flex 项在主轴居中。</li><li>而我们上面用到的值 <code>space-around</code> 是很有用的——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li><li>还有一个值是 <code>space-between</code>，它和 <code>space-around</code> 非常相似，只是它不会在两端留下任何空间。</li></ul><p>在继续下面之前，多多使用提到过的属性吧，看看它们的效果。</p><h4 id="flex-项排序"><a href="#flex-项排序" class="headerlink" title="flex 项排序"></a>flex 项排序</h4><p>弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。</p><p>代码也很简单，将下面的 CSS 添加到示例代码下面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>刷新下，然后你会看到“Smile”按钮移动到了主轴的末尾。下面我们谈下它实现的一些细节：</p><ul><li>所有 flex 项默认的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/order"><code>order</code></a> 值是 0。</li><li>order 值大的 flex 项比 order 值小的在显示顺序中更靠后。</li><li>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。</li><li>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。</li></ul><p>你也可以给 order 设置负值使它们比值为 0 的元素排得更前面。比如，你可以设置“Blush”按钮排在主轴的最前面：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="flex-嵌套"><a href="#flex-嵌套" class="headerlink" title="flex 嵌套"></a>flex 嵌套</h4><p>弹性盒子也能创建一些颇为复杂的布局。设置一个元素为 flex 项，那么他同样成为一个 flex 容器，它的孩子（直接子节点）也表现为弹性盒子。看一下 <a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/flexbox/complex-flexbox.html">复杂弹性盒子.html</a>（<a href="https://mdn.github.io/learning-area/css/css-layout/flexbox/complex-flexbox.html">在线浏览</a>）。</p><p>这个例子的 HTML 是相当简单的。我们用一个<code>&lt;section&gt;</code>元素包含了三个<code> &lt;article&gt;</code>元素。第三个<code>&lt;article&gt;</code>元素包含了三个<code> &lt;div&gt;</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">section</span> - <span class="hljs-selector-tag">article</span><br>          <span class="hljs-selector-tag">article</span><br>          <span class="hljs-selector-tag">article</span> - <span class="hljs-selector-tag">div</span> - <span class="hljs-selector-tag">button</span><br>                    <span class="hljs-selector-tag">div</span>   <span class="hljs-selector-tag">button</span><br>                    <span class="hljs-selector-tag">div</span>   <span class="hljs-selector-tag">button</span><br>                          <span class="hljs-selector-tag">button</span><br>                          <span class="hljs-selector-tag">button</span><br></code></pre></td></tr></table></figure><p>现在让我们看一下布局用到的代码。</p><p>首先，我们设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section"><code>section</code></a> 的子节点布局为弹性盒子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">section</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们给<code>&lt;article&gt;</code>元素设置 flex 值。特别注意这里的第二条 CSS 规则——我们设置第三个<code> &lt;article&gt;</code>元素的子节点的布局同样为 flex，但是属性值为列布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">3</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-flow</span>: column;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们选择了第一个<code> &lt;div&gt;</code>。首先使用 flex: 1 100px; 简单的给它一个最小的高度 100px，然后设置它的子节点（<code>&lt;button&gt; </code>元素）为 flex 项。在这里我们将它们放在一个包装行（wrap row）中，使它们居中对齐，就像我们在前面看到的单个按钮示例中做的那样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-flow</span>: row wrap;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们给按钮设置大小，有意思的是我们给它一个值为 1 的 flex 属性。如果你调整浏览器窗口宽度，你会看到这是一个非常有趣的效果。按钮将尽可能占用最多的空间，尽可能多的堆在同一条线上，但是当它们不再适合在同一条线上，他们中的一些会到下一行去。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="跨浏览器兼容性"><a href="#跨浏览器兼容性" class="headerlink" title="跨浏览器兼容性"></a>跨浏览器兼容性</h4><p>大多数浏览器都支持弹性盒子，诸如 Firefox、Chrome、Opera、Microsoft Edge 和 IE 11，较新版本的 Android&#x2F;iOS 等等。但是你应该要意识到仍旧有被人使用的老浏览器不支持弹性盒子（或者支持，但是只是支持非常非常老版本的弹性盒子）。</p><p>虽然你只是在学习和实验，这不太要紧; 然而，如果你正在考虑在真实网站中使用弹性盒子，则需要进行测试，并确保在尽可能多的浏览器中你的用户体验仍然可以接受。</p><p>弹性盒子相较其他一些 CSS 特性可能更为棘手。例如，如果浏览器缺少 CSS 阴影，则该网站可能仍然可用。但是假如不支持弹性盒子功能就会完全打破布局，使其不可用。</p><p>我们在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Cross_browser_testing">跨浏览器测试</a>模块中讨论了克服跨浏览器支持问题的策略。</p><h3 id="2-15-网格"><a href="#2-15-网格" class="headerlink" title="2.15 网格"></a>2.15 网格</h3><p>CSS 网格是一个用于 web 的二维布局系统。利用网格，你可以把内容按照行与列的格式进行排版。另外，网格还能非常轻松地实现一些复杂的布局。关于使用网格进行页面排版，这篇文章包含了你需要的一切知识。</p><h4 id="什么是网格布局？"><a href="#什么是网格布局？" class="headerlink" title="什么是网格布局？"></a>什么是网格布局？</h4><p>网格是由一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。</p><p>一个网格通常具有许多的<strong>列（column）</strong>与<strong>行（row）</strong>，以及行与行、列与列之间的间隙，这个间隙一般被称为<strong>沟槽（gutter）</strong>。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids/grid.png" alt="img"></p><p><strong>备注：</strong> 任何有设计背景的人似乎都感到惊讶，CSS 没有内置的网格系统，而我们似乎使用各种次优方法来创建网格状的设计。正如你将在本文的最后一部分中发现的那样，这将被改变，但是你可能需要知道在未来一段时间内创建网格的现有方法。</p><h4 id="在-CSS-中创建自己的网格"><a href="#在-CSS-中创建自己的网格" class="headerlink" title="在 CSS 中创建自己的网格"></a>在 CSS 中创建自己的网格</h4><p>决定好你的设计所需要的网格后，你可以创建一个 CSS 网格版面并放入各类元素。我们先来看看网格的基础功能，然后尝试做一个简单的网格系统。</p><h4 id="定义一个网格"><a href="#定义一个网格" class="headerlink" title="定义一个网格"></a>定义一个网格</h4><p>和往常一样，你可以下载，然后在文本编辑器中打开并浏览教程的<a href="https://github.com/mdn/learning-area/blob/main/css/css-layout/grids/0-starting-point.html">起始文件</a>（你可以<a href="https://mdn.github.io/learning-area/css/css-layout/grids/0-starting-point.html">在这里查看实时的效果</a>）。你会看到一个带有容器的示例，容器中有一些子项。默认情况下，子项按照正常布局流自顶而下排布。在这篇教程的第一部分，我们会从这开始，通过对这个文件做一些改变，来了解网格是如何工作的。</p><p>首先，我们通过把容器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性设置为 <code>grid</code> ,来定义一个网格。与弹性盒子一样，将父容器改为网格布局后，他的直接子项会变为网格项。把下面的 css 规则加到你的文件中。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  <span class="hljs-keyword">display</span>: grid;<br>&#125;<br></code></pre></td></tr></table></figure><p>与弹性盒子不同的是，在定义网格后，网页并不会马上发生变化。因为 <code>display: grid</code> 的声明只创建了一个只有一列的网格，所以子项还是会像正常布局流那样，自上而下、一个接一个的排布。</p><p>为了让我们的容器看起来更像一个网格，我们要给刚定义的网格加一些列。那就让我们加三个宽度为<code>200px</code>的列。当然，这里可以用任何长度单位，包括百分比。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在你的 CSS 中加入第二个规则。刷新页面后，你会看到子项们排进了新定义的网格中。</p><iframe class="sample-code-frame" title="定义一个网格 sample" id="frame_定义一个网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="使用-fr-单位的灵活网格"><a href="#使用-fr-单位的灵活网格" class="headerlink" title="使用 fr 单位的灵活网格"></a>使用 fr 单位的灵活网格</h4><p>除了长度和百分比，我们也可以用 <code>fr</code> 这个单位来灵活地定义网格的行与列的大小。这个单位代表网格容器中可用空间的一份，可能有点抽像，看看下面的例子吧。</p><p>使用下面的规则来修改你的网格轨道，创建 3 个宽度为 <code>1fr</code> 的列：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p>将窗口调窄（由于示例中设定了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>，可能需要很窄），你应该能看到每一列的宽度可以会随着可用空间变小而变小。<code>fr</code> 单位按比例划分了可用空间，如果没有理解，可以试着改一下数值，看看会发生什么，比如下面的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个定义里，第一列被分配了 <code>2fr</code> 可用空间，余下的两列各被分配了 <code>1fr</code> 的可用空间，这会使得第一列的宽度更大。另外，<code>fr</code>可以与一般的长度单位混合使用。比如设置 <code>grid-template-columns: 300px 2fr 1fr</code>，那么第一列宽度是<code>300px</code>，剩下的两列会根据剩余的可用空间按比例分配。</p><iframe class="sample-code-frame" title="使用 fr 单位的灵活网格 sample" id="frame_使用_fr_单位的灵活网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E4%BD%BF%E7%94%A8_fr_%E5%8D%95%E4%BD%8D%E7%9A%84%E7%81%B5%E6%B4%BB%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> <code>fr</code>单位分配的是<em>可用</em>空间而非<em>所有</em>空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。</p><h4 id="网格间隙"><a href="#网格间隙" class="headerlink" title="网格间隙"></a>网格间隙</h4><p>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap"><code>grid-column-gap</code> (en-US)</a> 属性来定义列间隙；使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap"><code>grid-row-gap</code> (en-US)</a> 来定义行间隙；使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gap"><code>grid-gap</code> (en-US)</a> 可以同时设定两者。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>间隙距离可以用任何长度单位包括百分比来表示，但不能使用<code>fr</code>单位。</p><iframe class="sample-code-frame" title="网格间隙 sample" id="frame_网格间隙" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E7%BD%91%E6%A0%BC%E9%97%B4%E9%9A%99.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> <code>gap</code>属性曾经有一个<code>grid-</code>前缀，不过后来的标准进行了修改，目的是让他们能够在不同的布局方法中都能起作用。尽管现在这个前缀不会影响语义，但为了代码的健壮性，你可以把两个属性都写上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重复构建轨道组"><a href="#重复构建轨道组" class="headerlink" title="重复构建轨道组"></a>重复构建轨道组</h4><p>你可以使用<code>repeat</code>来重复构建具有某些宽度配置的某些列。举个例子，如果要创建多个等宽轨道，可以用下面的方法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前一样，你仍然得到了 3 个 <code>1fr</code> 的列。第一个传入 repeat 函数的值（<code>3</code>）表明了后续列宽的配置要重复多少次，而第二个值（<code>1fr</code>）表示需要重复的构建配置，这个配置可以具有多个长度设定。例如<code>repeat(2, 2fr 1fr)</code>，如果你仍然不明白，可以实际测试一下效果，这相当于填入了 <code>2fr 1fr 2fr 1fr</code>。</p><h4 id="显式网格与隐式网格"><a href="#显式网格与隐式网格" class="headerlink" title="显式网格与隐式网格"></a>显式网格与隐式网格</h4><p>到目前为止，我们定义过了列，但还没有管过行。但在这之前，我们要来理解一下显式网格和隐式网格。显式网格是我们用 <code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。</p><p>隐式网格中生成的行&#x2F;列大小是参数默认是 <code>auto</code> ，大小会根据放入的内容自动调整。当然，你也可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows"><code>grid-auto-rows</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns"><code>grid-auto-columns</code></a>属性手动设定隐式网格轨道的大小。下面的例子将<code>grid-auto-rows</code>设为了<code>100px</code>，然后你可以看到那些隐式网格中的行（因为这个例子里没有设定<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows"><code>grid-template-rows</code></a>，因此，所有行都位于隐式网格内）现在都是 100 像素高了。</p><p>译者注：简单来说，隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显式网格自动生成的网格部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><iframe class="sample-code-frame" title="显式网格与隐式网格 sample" id="frame_显式网格与隐式网格" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E6%98%BE%E5%BC%8F%E7%BD%91%E6%A0%BC%E4%B8%8E%E9%9A%90%E5%BC%8F%E7%BD%91%E6%A0%BC.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><h4 id="minmax-函数"><a href="#minmax-函数" class="headerlink" title="minmax() 函数"></a>minmax() 函数</h4><p>100 像素高的轨道有时可能会不够用，因为时常会有比 100 像素高的内容加进去。所以，我们可以将其设定为至少 100 像素，并且能够跟随内容来自动拓展尺寸，从而保证能容纳所有内容。显而易见，你很难知道网页上某个元素的尺寸在不同情况下会变成多少，一些额外的内容或者更大的字号就会导致许多能做到像素级精准的设计出现问题。所以，我们有了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 函数为一个行&#x2F;列的尺寸设置了取值范围。比如设定为 <code>minmax(100px, auto)</code>，那么尺寸就至少为 100 像素，并且如果内容尺寸大于 100 像素则会根据内容自动调整。在这里试一下把 <code>grid-auto-rows</code> 属性设置为<code>minmax</code>函数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果所有网格内的内容均小于 100 像素，看起来不会有变化。但如果在某一项中放入很长的内容或者图片，你可以看到这个格子所在的哪一行的高度变成能刚好容纳内容的高度了。注意我们修改的是 <code>grid-auto-rows</code>，因此只会作用于隐式网格。当然，这一项属性也可以应用于显式网格，更多内容可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 页面。</p><h4 id="自动使用多列填充"><a href="#自动使用多列填充" class="headerlink" title="自动使用多列填充"></a>自动使用多列填充</h4><p>现在来试试把学到的关于网格的一切，包括 repeat 与 minmax 函数，组合起来，来实现一个非常有用的功能。某些情况下，我们需要让网格自动创建很多列来填满整个容器。通过设置<code>grid-template-columns</code>属性，我们可以实现这个效果，不过这一次我们会用到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat"><code>repeat</code></a> 函数中的一个关键字<code>auto-fill</code>来替代确定的重复次数。而函数的第二个参数，我们使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数来设定一个行&#x2F;列的最小值，以及最大值 <code>1fr</code>。</p><p>在你的文件中试试看，你也许可以用到以下的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="自动使用多列填充 sample" id="frame_自动使用多列填充" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%88%97%E5%A1%AB%E5%85%85.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>你应该能看到形成了一个包含了许多至少 200 像素宽的列的网格，将容器填满。随着容器宽度的改变，网格会自动根据容器宽度进行调整，每一列的宽度总是大于 200 像素，并且容器总会被列填满。（This works because grid is creating as many 200 pixel columns as will fit into the container, then sharing whatever space is leftover between all of the columns — the maximum is 1fr which, as we already know, distributes space evenly between tracks.）</p><p>基于线的元素放置</p><p>在定义完了网格之后，我们要把元素放入网格中。我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。而对于阿拉伯语，第一条列分隔线在网格的最右边，因为阿拉伯文是从右往左书写的。</p><p>我们根据这些分隔线来放置元素，通过以下属性来指定从那条线开始到哪条线结束。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start"><code>grid-column-start</code> (en-US)</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-end"><code>grid-column-end</code> (en-US)</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-start"><code>grid-row-start</code> (en-US)</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-end"><code>grid-row-end</code> (en-US)</a></li></ul><p>这些属性的值均为分隔线序号，你也可以用以下缩写形式来同时指定开始与结束的线。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column"><code>grid-column</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row"><code>grid-row</code></a></li></ul><p>注意开始与结束的线的序号要使用<code>/</code>符号分开。</p><p>下载<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/grids/8-placement-starting-point.html">这个文件</a>（或者查看<a href="https://mdn.github.io/learning-area/css/css-layout/grids/8-placement-starting-point.html">在线预览</a>）。文件中已经定义了一个网格以及一篇简单的文章位于网格之外。你可以看到元素已经被自动放置到了我们创建的网格中。</p><p>接下来，尝试用定义网格线的方法将所有元素放置到网格中。将以下规则加入到你的 css 的末尾：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="基于线的元素放置 sample" id="frame_基于线的元素放置" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%9A%84%E5%85%83%E7%B4%A0%E6%94%BE%E7%BD%AE.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 你也可以用 <code>-1</code> 来定位到最后一条列分隔线或是行分隔线，并且可以用负数来指定倒数的某一条分隔线。但是这只能用于显式网格，对于<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid">隐式网格</a><code>-1</code>不一定能定位到最后一条分隔线。</p><h4 id="使用-grid-template-areas-属性放置元素"><a href="#使用-grid-template-areas-属性放置元素" class="headerlink" title="使用 grid-template-areas 属性放置元素"></a>使用 grid-template-areas 属性放置元素</h4><p>另一种往网格放元素的方式是用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas"><code>grid-template-areas</code></a>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p><p>将之前基于线的元素放置代码删除（或者重新下载一份新的文件），然后加入以下 CSS 规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar content&quot;</span><br>    <span class="hljs-string">&quot;footer footer&quot;</span>;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">3</span>fr;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: header;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: content;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: sidebar;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: footer;<br>&#125;<br></code></pre></td></tr></table></figure><p>刷新页面，然后你应该能看到的元素会被放到与之前相同的地方，整个过程不需要我们指定任何分隔线序号。</p><iframe class="sample-code-frame" title="使用 grid-template-areas 属性放置元素 sample" id="frame_使用_grid-template-areas_属性放置元素" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Grids/_sample_.%E4%BD%BF%E7%94%A8_grid-template-areas_%E5%B1%9E%E6%80%A7%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><code>grid-template-areas</code>属性的使用规则如下：</p><ul><li>你需要填满网格的每个格子</li><li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li><li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li><li>一个连续的区域必须是一个矩形</li><li>使用<code>.</code>符号，让一个格子留空</li></ul><p>你可以在文件中尽情发挥你的想象来测试各种网格排版，比如把页脚放在内容之下，或者把侧边栏一直延伸到最底。这种直观的元素放置方式很棒，你在 CSS 中看到的就是实际会出现的排版效果。</p><h3 id="2-16-浮动"><a href="#2-16-浮动" class="headerlink" title="2.16 浮动"></a>2.16 浮动</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性最初只用于在成块的文本内浮动图像，但是现在它已成为在网页上创建多列布局的最常用工具之一。本文将阐述它的有关知识。</p><h4 id="浮动的背景知识"><a href="#浮动的背景知识" class="headerlink" title="浮动的背景知识"></a>浮动的背景知识</h4><p>最初，引入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性是为了能让 Web 开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面上看到过。</p><p>但 Web 开发人员很快意识到，任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了。之前的 <a href="https://css-tricks.com/snippets/css/drop-caps/">fancy paragraph example</a> 的课程展示了如何使用浮动创建一个有趣的 drop-cap（首字下沉）效果。</p><p>浮动曾被用来实现整个网站页面的布局，它使信息列得以横向排列（默认的设定则是按照这些列在源代码中出现的顺序纵向排列）。目前出现了更新更好的页面布局技术，所以使用浮动来进行页面布局应被看作<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">传统的布局方法</a>。</p><p>在这一章中，我们仅就浮动这一命令本身的性能展开讲解。</p><h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><p>让我们来探讨如何使用浮动。我们将从一个非常简单的例子开始，包括在图像周围浮动一个文本块。你可以在电脑上创建新的 <code>index.html</code> 文件，并以 <a href="https://github.com/mdn/learning-area/blob/master/html/introduction-to-html/getting-started/index.html">简单的 HTML 模板</a> 填充，在适当的地方插入以下代码。稍后你可以看到示例代码应该能呈现出的效果。</p><p>首先，我们写一些简单的 HTML——添加以下内容到 HTML 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a>内，删除之前<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a>里面的东西：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Simple float example<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>Float<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在将以下 CSS 应用到您的 HTML 中（使用 <code>&lt;style&gt;</code> 元素或 <code>&lt;link&gt;</code> 到单独的 .css 文件——由你选择）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">900px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">font</span>: .<span class="hljs-number">9em</span>/<span class="hljs-number">1.2</span> Arial, Helvetica, sans-serif;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你现在保存并刷新，你会看到和你预期的效果差不多——图片坐落在文本的上方，且保持正常布局流。</p><h4 id="使盒子浮动起来"><a href="#使盒子浮动起来" class="headerlink" title="使盒子浮动起来"></a>使盒子浮动起来</h4><p>为了使盒子浮动起来，向规则 <code>.box</code> 下添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a> 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，如果您保存和刷新，你会看到类似下面的东西：</p><iframe class="sample-code-frame" title="使盒子浮动起来 sample" id="frame_使盒子浮动起来" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E4%BD%BF%E7%9B%92%E5%AD%90%E6%B5%AE%E5%8A%A8%E8%B5%B7%E6%9D%A5.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>让我们考虑一下浮动是如何工作的——浮动元素 (这个例子中的<code>&lt;div&gt;</code>元素) 会脱离正常的文档布局流，并吸附到其父容器的左边（这个例子中的<code>&lt;body&gt;</code>元素）。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</p><p>向右浮动的内容是一样的效果，只是反过来了——浮动元素会吸附到右边，而其他内容将从左侧环绕它。尝试将上一个例子中的浮动值改为 <code>right</code> ，再把 <code>margin-right</code> 换成 <code>margin-left</code> ，看看结果是什么。</p><h4 id="让浮动效果可视化"><a href="#让浮动效果可视化" class="headerlink" title="让浮动效果可视化"></a>让浮动效果可视化</h4><p>我们可以在浮动元素上应用 margin，将文字推开，但不能在文字上应用 margin 将浮动元素推走。这是因为浮动的元素脱离了正常文档流，紧随其后的元素排布在它的“后方”。你可以将示例代码进行更改，来观察到这个现象。</p><p>在紧随浮动盒子的第一段文字上添加 <code>special</code> 类，然后在你的 CSS 文件中添加如下规则，它会赋予跟随其后的段落一个背景色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更清晰的看到效果，将浮动的 <code>margin-left</code> 改为 <code>margin</code> 以将周围全部空出来。如此代码效果所示，你可以看到段落的背景色处于浮动盒子之下。</p><iframe class="sample-code-frame" title="让浮动效果可视化 sample" id="frame_让浮动效果可视化" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E8%AE%A9%E6%B5%AE%E5%8A%A8%E6%95%88%E6%9E%9C%E5%8F%AF%E8%A7%86%E5%8C%96.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>目标元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Visual_formatting_model#line_boxes">行内盒子</a>已被缩短，故文字会排布在浮动元素周围，但是浮动元素从正常文档流移出，故段落的盒子仍然保持全部宽度。</p><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>我们看到，一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也受到浮动元素的影响，我们需要 <em>停止</em> 它；这是通过添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 属性实现的。</p><p>在前例的 HTML 代码中，向浮动元素下方的第二个段落添加 <code>cleared</code> 类，然后向 CSS 文件中添加以下样式：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">.cleared &#123;<br>  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="清除浮动 sample" id="frame_清除浮动" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>应该看到，第二个段落已经停止了浮动，不会再跟随浮动元素排布了。<code>clear</code> 属性接受下列值：</p><ul><li><code>left</code>：停止任何活动的左浮动</li><li><code>right</code>：停止任何活动的右浮动</li><li><code>both</code>：停止任何活动的左右浮动</li></ul><h4 id="清除浮动元素周围的盒子"><a href="#清除浮动元素周围的盒子" class="headerlink" title="清除浮动元素周围的盒子"></a>清除浮动元素周围的盒子</h4><p>现在你知道了如何停止浮动元素其后元素的浮动行为。我们来看个例子，如果存在一个盒子 <em>同时</em> 包含了很高的浮动元素和一个很短的段落，会发生什么。</p><h4 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h4><p>改变你的文档结构，使得第一个段落与浮动的盒子共同处于类名为 <code>wrapper</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>div</code></a> 元素之下。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<span class="hljs-keyword">Float</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>  &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate.&lt;/p&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>在你的 CSS 代码中，为 <code>.wrapper</code> 类添加如下规则并重载页面：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>  background-color: rgb(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  padding: <span class="hljs-number">10</span>px;<br>  color: #fff;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，将原先的 <code>.cleared</code> 类移除：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">.cleared &#123;<br>  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会看到，就像示例代码一样，如果将背景色属性置于段落上，那么这个背景色将处于浮动元素之下。</p><iframe class="sample-code-frame" title="问题所在 sample" id="frame_问题所在" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E9%97%AE%E9%A2%98%E6%89%80%E5%9C%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>再一次强调，这是因为浮动元素处于正常文档流之外，停止紧随其后元素的浮动并不像之前那样奏效。如果你想让盒子联合包住浮动的项目以及第一段文字，同时让紧随其后的内容从盒子中清除浮动，这就是一个问题。</p><p>有三种方法可以处理这个问题，其中的两种在所有浏览器中均可以奏效（虽然看上去有点“小技巧”），剩下的一种是可以处理问题的较新的解决方案。</p><h4 id="clearfix-小技巧"><a href="#clearfix-小技巧" class="headerlink" title="clearfix 小技巧"></a>clearfix 小技巧</h4><p>传统上，这个问题通常由所谓的 “clearfix 小技巧” 解决，其过程为：先向包含浮动内容及其本身的盒子后方插入一些生成的内容，并将生成的内容清除浮动。</p><p>向示例中添加以下 CSS 代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span>::<span class="hljs-keyword">after</span> &#123;<br>  content: &quot;&quot;;<br>  clear: <span class="hljs-keyword">both</span>;<br>  display: block;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在重载页面，盒子的浮动就应该清除了。这与在浮动盒子后手动添加诸如 <code>div</code> 的 HTML 元素，并设置其样式为 <code>clear:both</code> 是等效的。</p><iframe class="sample-code-frame" title="clearfix 小技巧 sample" id="frame_clearfix_小技巧" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.clearfix_%E5%B0%8F%E6%8A%80%E5%B7%A7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="使用-overflow"><a href="#使用-overflow" class="headerlink" title="使用 overflow"></a>使用 overflow</h4><p>一个替代的方案是将包裹元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 属性设置为除 <code>visible</code> 外的其他值。</p><p>移除上一节添加的 clearfix CSS 代码；在包裹元素上添加 <code>overflow: auto</code> 规则。现在，盒子应该再一次停止浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="使用 overflow sample" id="frame_使用_overflow" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.%E4%BD%BF%E7%94%A8_overflow.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这个例子之所以能够生效，是因为创建了所谓的 <strong>块格式化上下文（BFC）</strong>。可以把它看作页面内部包含所需元素的一小块布局区域。如此设置可以让浮动元素包含在 BFC 及其背景之内。大部分情况下这种小技巧都可以奏效，但是可能会出现莫名其妙的滚动条或裁剪阴影，这是使用 overflow 带来的一些副作用。</p><h4 id="display-flow-root"><a href="#display-flow-root" class="headerlink" title="display: flow-root"></a>display: flow-root</h4><p>一个较为现代的方案是使用 <code>display</code> 属性的 <code>flow-root</code> 值。它可以无需小技巧来创建块格式化上下文（BFC），在使用上没有副作用。</p><p>从 <code>.wrapper</code> 中移除 <code>overflow: auto</code> 规则并添加 <code>display: flow-root</code>。如果你的浏览器支持该属性（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">支持的浏览器列表</a>），盒子就会停止浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">display</span>: flow-root;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="display flow-root sample" id="frame_display_flow-root" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Floats/_sample_.display_flow-root.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="2-17-定位"><a href="#2-17-定位" class="headerlink" title="2.17 定位"></a>2.17 定位</h3><p>定位允许你从正常的文档流布局中取出元素，并使它们具有不同的行为，例如放在另一个元素的上面，或者始终保持在浏览器视窗内的同一位置。本文解释的是定位 (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a>) 的各种不同值，以及如何使用它们。</p><h4 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h4><p>定位是一个相当复杂的话题，所以我们深入了解代码之前，让我们审视一下布局理论，并让我们了解它的工作原理。</p><p>首先，围绕元素内容添加任何内边距、边界和外边距来布置单个元素盒子——这就是<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型</a> ，我们前面看过。默认情况下，块级元素的内容宽度是其父元素的宽度的 100％，并且与其内容一样高。内联元素高宽与他们的内容高宽一样。你不能对内联元素设置宽度或高度——它们只是位于块级元素的内容中。如果要以这种方式控制内联元素的大小，则需要将其设置为类似块级元素 <code>display: block;</code>。</p><p>这只是解释了单个元素，但是元素相互之间如何交互呢？<strong>正常的布局流</strong>（在布局介绍文章中提到）是将元素放置在浏览器视口内的系统。默认情况下，块级元素在视口中垂直布局——每个都将显示在上一个元素下面的新行上，并且它们的外边距将分隔开它们。</p><p>内联元素表现不一样——它们不会出现在新行上；相反，它们互相之间以及任何相邻（或被包裹）的文本内容位于同一行上，只要在父块级元素的宽度内有空间可以这样做。如果没有空间，那么溢流的文本或元素将向下移动到新行。</p><p>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">外边距折叠</a>, 我们之前也遇到过。</p><h4 id="介绍-z-index"><a href="#介绍-z-index" class="headerlink" title="介绍 z-index"></a>介绍 z-index</h4><p>所有这些绝对定位很有趣，但还有另一件事我们还没有考虑到 ——当元素开始重叠，什么决定哪些元素出现在其他元素的顶部？在我们已经看到的示例中，我们在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。当我们有不止一个的时候呢？</p><p>尝试添加以下到你的 CSS，使第一段也是绝对定位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">background</span>: lime;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，你将看到第一段的颜色为绿色，移出文档流程，并位于原始位置上方一点。它也堆叠在原始的 <code>.positioned</code> 段落下，其中两个重叠。这是因为 <code>.positioned</code> 段落是源顺序 (HTML 标记) 中的第二个段落，并且源顺序中后定位的元素将赢得先定位的元素。</p><p>你可以更改堆叠顺序吗？是的，你可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a>属性。 “z-index”是对 z 轴的参考。你可以从源代码中的上一点回想一下，我们使用水平（x 轴）和垂直（y 轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。 （0,0）位于页面（或元素）的左上角，x 和 y 轴跨页面向右和向下（适合从左到右的语言，无论如何）。</p><p>网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。</p><p>要更改堆叠顺序，请尝试将以下声明添加到 <code>p:nth-of-type(1)</code> 规则中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>你现在应该可以看到完成的例子：</p><iframe class="sample-code-frame" title="介绍 z-index sample" id="frame_介绍_z-index" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Positioning/_sample_.%E4%BB%8B%E7%BB%8D_z-index.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>请注意，z-index 只接受无单位索引值；你不能指定你想要一个元素是 Z 轴上 23 像素—— 它不这样工作。较高的值将高于较低的值，这取决于你使用的值。使用 2 和 3 将产生与 300 和 40000 相同的效果。</p><p><strong>备注：</strong> 你可以在这里看到这个例子 <a href="https://mdn.github.io/learning-area/css/css-layout/positioning/5_z-index.html"><code>5_z-index.html</code></a> (<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/positioning/5_z-index.html">see source code</a>).</p><h3 id="2-18-多栏布局"><a href="#2-18-多栏布局" class="headerlink" title="2.18 多栏布局"></a>2.18 多栏布局</h3><p>多列布局声明提供了一种多列组织内容的方式，正如你在一些报纸中看到的那样。这篇文章介绍怎么使用这一特性。</p><h4 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h4><p>我们从一些很简单的 HTML 开始；用带有类 <code>container</code> 的简单包装，里面是标题和一些段落。</p><p>带有 .container 的 <div> 将成为我们 multicol 的容器。通过这两个属性开启 multicol column-count 或者 column-width (en-US)。 column-count 将创建指定数量的列，所以如果你把下面的 CSS 加到样式表里让后重载入页面，你将得到 3 列：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  column-<span class="hljs-keyword">count</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建的这些列具有弹性的宽度 — 由浏览器计算出每一列分配多少空间。</p><iframe class="sample-code-frame" title="三列布局 sample" id="frame_三列布局" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="设置列宽"><a href="#设置列宽" class="headerlink" title="设置列宽"></a>设置列宽</h4><p>像下面这样使用 <code>column-width</code> 更改 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p><iframe class="sample-code-frame" title="设置列宽 sample" id="frame_设置列宽" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E8%AE%BE%E7%BD%AE%E5%88%97%E5%AE%BD.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="给多列增加样式"><a href="#给多列增加样式" class="headerlink" title="给多列增加样式"></a>给多列增加样式</h4><p>Multicol 创建的列无法单独的设定样式。不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。你有两个机会改变列的样式：</p><ul><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 改变列间间隙。</li><li>用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule"><code>column-rule</code></a> 在列间加入一条分割线。</li></ul><p>以上面的代码为例，增加 <code>column-gap</code> 属性可以更改列间间隙。</p><p>你可以尝试不同的值 — 该属性接受任何长度单位。现在再加入 <code>column-rule</code>。和你之前遇到的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 属性类似， <code>column-rule</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-color"><code>column-rule-color</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-style"><code>column-rule-style</code></a>的缩写，接受同 <code>border</code> 一样的单位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">column-rule</span>: <span class="hljs-number">4px</span> dotted <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试设置不同的样式和颜色。</p><iframe class="sample-code-frame" title="给多列增加样式 sample" id="frame_给多列增加样式" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E7%BB%99%E5%A4%9A%E5%88%97%E5%A2%9E%E5%8A%A0%E6%A0%B7%E5%BC%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>值得一提的是这条分割线本身并不占用宽度。它置于用 <code>column-gap</code> 创建的间隙内。如果需要更多空间，你需要增加 <code>column-gap</code> 的值。</p><h4 id="列与内容折断"><a href="#列与内容折断" class="headerlink" title="列与内容折断"></a>列与内容折断</h4><p>多列布局的内容被拆成碎块。和多页媒体上的内容表现大致一样 — 比如打印网页的时候。当你把内容放入多列布局容器内，内容被拆成碎块放进列中，内容折断（译者注：比如断词断句）使得这一效果可以实现。</p><p>有时，这种折断内容会降低阅读体验。在下面的举例中，我用 multicol 对一系列盒子布局，每一小块里有小标题和和一些文字。标题和文字可能被折断点拆开，从而降低阅读体验。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat<br>                vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies<br>                tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci<br>                vel, viverra egestas ligula.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">250px</span>;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="列与内容折断 sample" id="frame_列与内容折断" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E5%88%97%E4%B8%8E%E5%86%85%E5%AE%B9%E6%8A%98%E6%96%AD.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="设置-break-inside"><a href="#设置-break-inside" class="headerlink" title="设置 break-inside"></a>设置 break-inside</h4><p>我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Fragmentation">CSS Fragmentation</a> 中声明的属性控制这一特性。这份规范提供了一些属性来控制 multicol 和多页媒体中的内容拆分、折断。比如，在规则 <code>.card</code> 上添加属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/break-inside"><code>break-inside</code></a>，并设值 <code>avoid</code> 。<code>.card</code> 是标题和文本的容器，我们不想拆开这个盒子。</p><p>现阶段，增加旧属性 <code>page-break-inside: avoid</code> 能够获得更好的浏览器支持。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">break-inside</span>: avoid;<br>  <span class="hljs-attribute">page-break-inside</span>: avoid;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>刷新页面，你的盒子就会呆在一起了。</p><iframe class="sample-code-frame" title="设置 break-inside sample" id="frame_设置_break-inside" width="100%" height="600" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout/_sample_.%E8%AE%BE%E7%BD%AE_break-inside.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="2-19-响应式设计"><a href="#2-19-响应式设计" class="headerlink" title="2.19 响应式设计"></a>2.19 响应式设计</h3><p>早年设计 Web 时，页面是以适配特定的屏幕大小为考量创建的。如果用户正在使用比设计者考虑到的更小或者更大的屏幕，那么结果从多余的滚动条，到过长的行和没有被合理利用的空间，不一而足。随着人们使用的屏幕尺寸的种类越来越多，出现了响应式网页设计的概念（<em>responsive web design，RWD</em>），RWD 指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。这是改变我们设计多设备网页的方式的思想，在这篇文章里，我们将会帮你理解掌握它时所需知道的主要技能。</p><p>随着移动 Web 在早期的功能手机上开始成为现实，希望拥抱移动端的公司普遍希望为他们的网站创建一个有着不同的网址的移动版本（大多是像<em>m.example.com</em>或者<em>example.mobi</em>这类）。这意味着一个网站需要开发两个分开的版本，而且要保持时效性。</p><p>除此以外，这些移动网站的体验经常缩水。由于移动设备变得更加强大，足以显示完整的网站，对于那些被困在移动版网站的移动端用户来说，这是很折磨人的，他们因此也没法获取他们知道在支持所有功能的桌面版网站上能找到的信息。</p><h4 id="响应式设计之前的灵活布局"><a href="#响应式设计之前的灵活布局" class="headerlink" title="响应式设计之前的灵活布局"></a>响应式设计之前的灵活布局</h4><p>人们开发了许多方式，尽力解决建设网站时使用液态和固定宽度的方式所带来的弊端。2004 年，Cameron Adams 写了一篇题为《<a href="https://www.themaninblue.com/writing/perspective/2004/09/21/">Resolution dependent layout</a>》的帖子，描述了一种可以创造适应多种屏幕分辨率的设计的方式。这种方式需要 JavaScript 来探测屏幕的分辨率，载入恰当的 CSS。</p><p>Zoe Mickley Gillenwater 深刻影响了<a href="http://zomigi.com/blog/voices-that-matter-slides-available/">她的著作</a>，在里面描述并标准化了可变站点建立的不同方式，试图在充满屏幕和完全保持固定尺寸之间找到最佳平衡。</p><h4 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h4><p>“响应式设计”这个词是<a href="https://alistapart.com/article/responsive-web-design/">Ethan Marcotte 在 2010 年首度提出的</a>，他将其描述为三种技术的混合使用。</p><ol><li>第一个是液态网格，这早先已由 Gillenwater 进行探讨，可以在 Marcotte 的文章《<a href="https://alistapart.com/article/fluidgrids/">Fluid Grids</a>》（出版于 2009 年的《A List Apart》上）中读到。</li><li>第二个是<a href="https://unstoppablerobotninja.com/entry/fluid-images">液态图像</a>的理念。通过使用相当简单的将设置<code>max-width</code>属性设置为<code>100%</code>的技术，图像可以在包含它们的列变得比图像原始尺寸窄的时候，缩放得更小，但总不会变得更大。这使得图像可以被缩放，以被放到一个灵活尺寸的列，而不是溢出出去，同时也不会在列宽于图像的时候，使图像变得太大以至于画质变得粗糙。</li><li>第三个关键的组件是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries">媒体查询</a>。媒体查询使以往 Cameron Adams 探讨过的、由 JavaScript 实现的布局类型切换，可以只使用 CSS 实现。和所有尺寸的屏幕都使用一种布局不同的是，布局是可以改变的：侧栏可以在小屏幕上重新布局，而替代用的导航栏也可以显示出来。</li></ol><p>需要你理解的很重要的一点是<strong>响应式 Web 设计不是单独的技术</strong>，它是描述 Web 设计的一种方式、或者是一组最佳实践的一个词，它是用来建立可以<strong>响应</strong>查看内容的设备的样式的一个词。在 Marcotte’s 原来的探索中，这意味着灵活网格（使用 float）和媒体查询，但是在这篇文章写就的几乎十年以后，Web 的响应式工作已经成为了默认做法。现代的 CSS 布局方式基本上就是响应式的，而且我们在 Web 平台上内置了新的东西，使得设计响应式站点变得容易。</p><p>这篇文章的余下部分会为你指出，在建立响应式站点的时候，你可能会用到的各式 Web 平台的特色功能。</p><h4 id="媒介查询"><a href="#媒介查询" class="headerlink" title="媒介查询"></a>媒介查询</h4><p>响应式设计仅仅是因为媒介查询才新兴起来的。媒介查询第三级规范已经在 2009 年成为了候选推荐，这意味着它可视为准备好在浏览器中开始支持了。媒介查询允许我们运行一系列测试，例如用户的屏幕是否大于某个宽度或者某个分辨率，并将 CSS 选择性地适应用户的需要应用在样式化页面上。</p><p>例如，下面的媒体查询进行测试，以知晓当前的 Web 页面是否被展示为屏幕媒体（也就是说不是印刷文档），且视口至少有 800 像素宽。用于<code>.container</code>选择器的 CSS 将只会在这两件前提存在的情况下应用。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">800px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">1em</span> <span class="hljs-number">2em</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以在一张样式表上加入多条媒体查询，调整整个页面或者部分页面以达到适应各式屏幕尺寸的最佳效果。媒体查询，以及样式改变时的点，被叫做<em>断点</em>（breakpoints）。</p><p>使用媒体查询时的一种通用方式是，为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局。这经常被描述为<strong>移动优先</strong>设计。</p><p>在 MDN 文档中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries">媒体查询</a>中了解更多</p><h4 id="灵活网格"><a href="#灵活网格" class="headerlink" title="灵活网格"></a>灵活网格</h4><p>响应式站点不只是在断点之间改变它们的布局，它们是建立在灵活网格上的。一个灵活网格意味着你不需要适配每个可能使用的设备尺寸，然后为其建立一个精确到像素级的适配布局。那种方式在现存有如此多种不同大小设备的前提下是不可能实现的，比如至少在台式机上，人们并不总是让他们的浏览器窗口最大化的。</p><p>使用灵活网格，你只需要加进去一个断点，在内容看起来不齐整的时候改变设计。例如如果一行随着屏幕大小增加而增长得不可读的长，或者是一个盒子在变窄时把每行的两个单词挤到一起。</p><p>早年间进行响应式设计的时候，我们唯一的实现布局的选项是使用<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">float</a>。灵活浮动布局是这样实现的，让每个元素都有一个作为宽度的百分数，而且确保整个布局的和不会超过 100%。在他对于液态网格文章的原文中，Marcotte 详细描述了一种布局的法则，通过使用像素并把布局转化为百分数的方式设计。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">target / context <span class="hljs-operator">=</span> result<br></code></pre></td></tr></table></figure><p>例如如果我们的预期栏尺寸为 60 像素，而且它所在的上下文（或者容器）为 960 像素，我们在将零点二的空间移动到右边以后，用 960 去除 60，得到我们能够使用在我们的 CSS 上的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.col</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6.25%</span>; <span class="hljs-comment">/* 60 / 960 = 0.0625 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式将会在今天整个 Web 上的许多地方上看到，而且它被我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods">Legacy layout methods</a>一文中的布局一节中记载。可能你将会在工作中遇到使用这种方式的站点，所以有必要理解它，即使是在你不用建立一个使用浮动基础的灵活网格的情况下。</p><h4 id="现代布局技术"><a href="#现代布局技术" class="headerlink" title="现代布局技术"></a>现代布局技术</h4><p>现代布局方式，例如<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout">多栏布局</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">伸缩盒</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">网格</a>默认是响应式的。它们都假设你在尽力创建一个可伸缩网格，而且给了你更容易这样做的方式。</p><h4 id="多个列"><a href="#多个列" class="headerlink" title="多个列"></a>多个列</h4><p>这些布局方式中最老的一个是多个列，即当你指定一个<code>column-count</code>的时候，这意指你希望把你的内容分成多少列。浏览器之后会算出这些列的大小，这是一个随着屏幕尺寸变化的尺寸。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  column-<span class="hljs-keyword">count</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你却去指定<code>column-width</code>的话，你是在指定一个<em>最小</em>宽度。浏览器会尽可能多数量地创建这一宽度的列，只要它们可以恰当地放进容器里面，然后将所有列之间的剩余空间共享出去。因而列的数量会随着空间的多少而改变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">10em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="伸缩盒"><a href="#伸缩盒" class="headerlink" title="伸缩盒"></a>伸缩盒</h4><p>在伸缩盒中，初始的行为是，弹性的物件将参照容器里面的空间的大小，缩小和分布物件之间的空间。通过更改<code>flex-grow</code>和 <code>flex-shrink</code>的值，你可以指示在物件遇到周围有更多或者更少的空间的情况下，你所期望的物件表现。</p><p>在下面的示例中，和布局专题的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox#flexible_sizing_of_flex_items">Flexbox: Flexible sizing of flex items</a>中所描述的那样，使用了<code>flex: 1</code>的简写，可伸缩物件每个将会占据一份可伸缩容器中相等大小的空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 作为一个示例，我们已经重构了上面的简单响应式布局，这次我们用了伸缩盒。你可以看看我们是怎么样才不再需要使用奇怪的百分数值来计算列的尺寸的：<a href="https://mdn.github.io/css-examples/learn/rwd/flex-based-rwd.html">示例</a>、<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/flex-based-rwd.html">源代码</a>。</p><h4 id="CSS-网格"><a href="#CSS-网格" class="headerlink" title="CSS 网格"></a>CSS 网格</h4><p>在 CSS 网格布局中，<code>fr</code>单位许可了跨网格轨道可用空间的分布。下面的示例创建了一个有着 3 个大小为<code>1fr</code>的轨道的网格容器。这会创建三个列轨道，每个占据了容器中可用空间的一部分。你可以在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids#flexible_grids_with_the_fr_unit">Flexible grids with the fr unit</a>下的学习布局网格专题了解更多和这一方式相关的信息。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 网格布局版本的代码要更简单，因为我们可以在.wrapper 上定义列<a href="https://mdn.github.io/css-examples/learn/rwd/grid-based-rwd.html">：示例</a>，<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/grid-based-rwd.html">源代码</a>。</p><h4 id="响应式图像"><a href="#响应式图像" class="headerlink" title="响应式图像"></a>响应式图像</h4><p>最简单的处理响应式图像的方式是在 Marcotte 的早年的关于响应式设计的文章上所描述的那样。基本来说，你可以用一张有着所需最大尺寸的图像。然后缩放它。这仍然是今日所使用的一种方式，而且在大多数样式表里面，你在某些地方可以找到下面的 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式有显然的弊端。图像有可能会显示得比它的原始尺寸小很多，以至于浪费带宽——一个移动端用户会下载几倍于他们在浏览器窗口中实际看到的大小的图像。此外，你可能不想在移动端和桌面端有相同的图像宽高比例。例如，在移动端，方形图像的表现会很好，但是在桌面端显示同样的内容则应用宽图像。或者，认识到移动端更小尺寸的图像的你也许会希望同时展示一张不同的图像，一张在小一点的屏幕上更容易理解的图像。这些东西不能简单通过缩放图像解决。</p><p>响应式图像，使用了<code>&lt;picture&gt;</code>元素和<code>&lt;img&gt; </code>srcset和sizes 特性，解决了这两个问题。你可以提供附带着“提示”（描述图像最适合的屏幕尺寸和分辨率的元数据）的多种尺寸，浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。</p><p>你也可以给用于不同尺寸的图像做“艺术指导”，为不同的屏幕尺寸提供不同的图像裁切或者完全不同的图像。</p><p>你可以在 MDN 这里的学习 HTML 一节中找到详细的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图像指南</a>。</p><h4 id="响应式排版"><a href="#响应式排版" class="headerlink" title="响应式排版"></a>响应式排版</h4><p>在早期的工作没有考虑的一个响应式设计的元素是响应式排版的理念。本质上讲，这描述了根据屏幕真实使用范围的多少，在媒体查询的同时改变字体大小。</p><p>在本例子中，我们想讲我们的一级标题设置为<code>4rem</code>，也就是说它将会有我们的基础字体的四倍大。这真的是个很大的标题！我们只想在大些的屏幕上有这么个超大的标题，那我们先弄个小点的标题，再使用媒体查询，在我们知道用户使用至少<code>1200px</code>的屏幕的时候，拿大些的尺寸覆写它。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>  <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经编辑了我们在上面的响应式网格示例，让它同时包含了使用了圈出方式的响应式类型。你也可以看下随着布局变为两栏，标题是怎样转换大小的。</p><p>移动端，标题变小了：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design/mdn-rwd-font-mobile.png" alt="A stacked layout with a small heading size."></p><p>但在桌面端，我们看到了大点的标题：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design/mdn-rwd-font-desktop.png" alt="A two column layout with a large heading."></p><p><strong>备注：</strong> 查看这个编排好的示例：<a href="https://mdn.github.io/css-examples/learn/rwd/type-rwd.html">示例</a>，<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/type-rwd.html">源代码</a>。</p><p>正如这种排版方式展示的这样，你不需要让媒介查询只能改变页面的布局。它们也能用来调节每个元素，让它们在别的大小的屏幕上更加可用或者更具吸引力。</p><h4 id="使用视口单位实现响应式排版"><a href="#使用视口单位实现响应式排版" class="headerlink" title="使用视口单位实现响应式排版"></a>使用视口单位实现响应式排版</h4><p>一个有趣的方式是使用视口单位<code>vw</code>来实现响应式排版。<code>1vw</code>等同于视口宽度的百分之一，即如果你用<code>vw</code>来设定字体大小的话，字体的大小将总是随视口的大小进行改变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6vw</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题在于，当做上面的事情的时候，因为文本总是随着视口的大小改变大小，用户失去了放缩任何使用<code>vw</code>单位的文本的能力。<strong>所以你永远都不要只用 viewport 单位设定文本。</strong></p><p>这里有一个解决方法，它使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc"><code>calc()</code></a>，如果你将<code>vw</code>单位加到了使用固定大小（例如<code>em</code>或者<code>rem</code>）的值组，那么文本仍然是可放缩的。基本来说，是<code>vw</code>加在了放缩后的值上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">1.5rem</span> + <span class="hljs-number">3vw</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是说，我们只需要指定标题的字体大小一次，而不是为移动端设定它，然后再在媒介查询中重新定义它。字体会在你增加视口大小的时候逐渐增大。</p><p><strong>备注：</strong> 查看这种情况的一个编排好的示例： <a href="https://mdn.github.io/css-examples/learn/rwd/type-vw.html">示例</a>，<a href="https://github.com/mdn/css-examples/blob/master/learn/rwd/type-vw.html">源代码</a>。</p><h4 id="视口元标签"><a href="#视口元标签" class="headerlink" title="视口元标签"></a>视口元标签</h4><p>如果你看看一张响应式页面的 HTML 源代码，你通常将会在文档的<code>&lt;head&gt;</code>看到下面的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">&#96;&#96;</a>标签。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的 100%，在移动端以你所希望的为移动优化的大小展示文档。</p><p>为何需要这个？因为移动端浏览器倾向于在它们的视口宽度上说谎。</p><p>这个元标签的存在，是由于原来 iPhone 发布以后，人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为 960 像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本。其他的移动端浏览器（例如谷歌安卓上的）也是这么做的。用户可以在站点中放大、移动，查看他们感兴趣的那部分，但是这看起来很不舒服。如果你不幸遇到了一个没有响应式设计的网站，今天你还会看到这种情况。</p><p>麻烦的是，你的带断点和媒介查询的响应式设计不会在移动端浏览器上像预期那样工作。如果你有个窄屏布局，在 480 像素及以下的视口宽度下生效，但是视口是按 960 像素设定的，你将不会在移动端看到你的窄屏布局。通过设定<code>width=device-width</code>，你用设备的实际宽度覆写了苹果默认的<code>width=960px</code>，然后你的媒介查询就会像预期那样生效。</p><p><strong>所以你应该在你的文档头部*总是*包含上面那行 HTML。</strong></p><p>和视口元标签一起，你可以使用另外几个设定，但大体说来，上面那行就是你想要使用的。</p><ul><li><code>initial-scale</code>：设定了页面的初始缩放，我们设定为 1。</li><li><code>height</code>：特别为视口设定一个高度。</li><li><code>minimum-scale</code>：设定最小缩放级别。</li><li><code>maximum-scale</code>：设定最大缩放级别。</li><li><code>user-scalable</code>：如果设为<code>no</code>的话阻止缩放。</li></ul><p>你应该避免使用<code>minimum-scale</code>、<code>maximum-scale</code>，尤其是将<code>user-scalable</code>设为<code>no</code>。用户应该有权力尽可能大或小地进行缩放，阻止这种做法会引起访问性问题。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>响应式设计指的是一个响应浏览环境的网页或者应用设计。它涵盖了很多 CSS 和 HTML 的功能和技术，现在基本上就是我们默认建设网站的方式。想一下你在手机上访问的网站，遇到一个缩放的桌面版网站，或者你需要向侧边滚动来寻找东西的网站可能是相当不寻常的。这是因为 Web 已经迁移到了这种响应式设计的方式上。</p><p>在这些课里学到的布局方式的帮助下，实现响应式设计也变得愈加简单。如果你今天新近了解 Web 开发，那么你与响应式设计早期相比，手边有多得多的工具。因而，你有必要检查下你所引用的任何材料的年纪。尽管历史上的文章仍然有用，现代的 CSS 和 HTML 的使用让创建一个优雅且实用的设计变得远远更加容易，且无论你的访客使用什么设备浏览网站。</p><h3 id="2-20-媒体查询入门指南"><a href="#2-20-媒体查询入门指南" class="headerlink" title="2.20 媒体查询入门指南"></a>2.20 媒体查询入门指南</h3><p>最简单的媒体查询语法看起来是像这样的：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">@media media-<span class="hljs-keyword">type</span> and (media-feature-rule) &#123;<br>  /* <span class="hljs-type">CSS</span> rules go here */<br>&#125;<br></code></pre></td></tr></table></figure><p>Copy to Clipboard</p><p>它由以下部分组成：</p><ul><li>一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；</li><li>一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试；</li><li>一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。</li></ul><h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><p>你可以指定的媒体类型为：</p><ul><li><code>all</code></li><li><code>print</code></li><li><code>screen</code></li><li><code>speech</code></li></ul><p>下面的媒体查询将会在页面被打印的时候把 body 设定为只有 12pt 大小。当页面在浏览器中载入的时候，它将不会生效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> print &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12pt</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>备注：</strong>这里的媒体类型是和所谓的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type">MIME type</a>不同的东西。</p></blockquote><p><strong>备注：</strong> 在第三级媒体查询规范中，定义了其他一些媒体类型，它们已经不被建议使用，而且应该被避免使用。</p><blockquote><p><strong>备注：</strong>媒体类型是可选的，如果你没有在媒体查询中指示一个媒体类型的话，那么媒体查询默认会设为用于全部媒体类型。</p></blockquote><h4 id="媒体特征规则"><a href="#媒体特征规则" class="headerlink" title="媒体特征规则"></a>媒体特征规则</h4><p>在指定了类型以后，你可以用一条规则指向一种媒体特征。</p><h4 id="宽和高"><a href="#宽和高" class="headerlink" title="宽和高"></a>宽和高</h4><p>为了建立响应式设计（已经广受浏览器支持），我们一般最常探测的特征是视口宽度，而且我们可以使用<code>min-width</code>、<code>max-width</code>和<code>width</code>媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用 CSS。</p><p>这些特征是用来创建响应不同屏幕大小的布局的。例如，要想在视口正好是 600 像素的时候，让 body 的文本变为红色，你可能会使用下面的媒体查询。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/width.html">打开这个示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/width.html">查看源代码</a>。</p><p><code>width</code>（和<code>height</code>）媒体特征可以以数值范围使用，于是就有了<code>min-</code>或者<code>max-</code>的前缀，指示所给的值是最小值还是最大值。例如，要让颜色在视口窄于 400 像素的时候变成蓝色的话，可以用<code>max-width</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">400px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/max-width.html">打开示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/max-width.html">查看源代码</a>。</p><p>实践中，使用最小值和最大值对响应式设计有很多的用处，所以你会很少见到<code>width</code>或<code>height</code> 单独使用的情况。</p><p>还有许多其他媒体特征可以供你测试，尽管于 4 级和 5 级媒体查询规范中引入了一些新特征，它们受浏览器支持仍然有限。在 MDN 上，每个特征都已经同浏览器支持信息一同记载下来，你可以在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries#media_features">使用媒体查询：媒体特征</a>中找到一张完整的列表。</p><h4 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h4><p>一个受到良好支持的媒体特征是<code>orientation</code>，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变 body 文本颜色的话，可使用下面的媒体查询。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/orientation.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/orientation.html">查看源代码</a>。</p><p>标准的桌面视图是横放朝向的，在这种朝向上能够表现良好的设计，在处于竖放模式的手机或平板电脑上可能不会表现得这么好。对朝向的测试可以帮你建立一个为竖放设备优化的布局。</p><h4 id="使用指点设备"><a href="#使用指点设备" class="headerlink" title="使用指点设备"></a>使用指点设备</h4><p>作为四级规范的一部分，<code>hover</code>媒体特征被引入了进来。这种特征意味着你可以测试用户是否能在一个元素上悬浮，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">hover</span>: <span class="hljs-attribute">hover</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/hover.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/hover.html">查看源代码</a>。</p><p>如果我们知道用户不能悬浮的话，我们可以默认显示一些交互功能。对于能够悬浮的用户，我们可以选择在悬浮在链接上的时候，让这些功能可用。</p><p>还是在四级规范中，出现了<code>pointer</code>媒体特征。它可取三个值：<code>none</code>、<code>fine</code>和<code>coarse</code>。<code>fine</code>指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。<code>coarse</code>指针是你在触摸屏上的手指。<code>none</code>值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。</p><p>使用<code>pointer</code>可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。</p><h4 id="更复杂的媒体查询"><a href="#更复杂的媒体查询" class="headerlink" title="更复杂的媒体查询"></a>更复杂的媒体查询</h4><p>有了所有不同的可用的媒体查询，你可能想要把它们混合起来，或者建立查询列表——其中的任何一个都可以匹配生效。</p><h4 id="媒体查询中的“与”逻辑"><a href="#媒体查询中的“与”逻辑" class="headerlink" title="媒体查询中的“与”逻辑"></a>媒体查询中的“与”逻辑</h4><p>为了混合媒体特征，你可以以与在上面使用<code>and</code>很相同的方式，用<code>and</code>来混合媒体类型和特征。例如，我们可能会想要测得<code>min-width</code>和<code>orientation</code>，而 body 的文字只会在视口至少为 400 像素宽，且设备横放时变为蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/and.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/and.html">查看源代码</a>。</p><h4 id="媒体查询中的“或”逻辑"><a href="#媒体查询中的“或”逻辑" class="headerlink" title="媒体查询中的“或”逻辑"></a>媒体查询中的“或”逻辑</h4><p>如果你有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。在下面的示例中，文本会在视口至少为 400 像素宽的时候<strong>或者</strong>设备处于横放状态的时候变为蓝色。如果其中的任何一项成立，那么查询就匹配上了。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@media <span class="hljs-keyword">screen </span><span class="hljs-keyword">and </span>(min-width: <span class="hljs-number">400</span>px), <span class="hljs-keyword">screen </span><span class="hljs-keyword">and </span>(<span class="hljs-keyword">orientation: </span>landscape) &#123;<br>    <span class="hljs-keyword">body </span>&#123;<br><span class="hljs-symbol">        color:</span> <span class="hljs-keyword">blue;</span><br><span class="hljs-keyword"></span>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/or.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/or.html">查看源代码</a>。</p><h4 id="媒体查询中的“非”逻辑"><a href="#媒体查询中的“非”逻辑" class="headerlink" title="媒体查询中的“非”逻辑"></a>媒体查询中的“非”逻辑</h4><p>你可以用<code>not</code>操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/not.html">打开此示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/not.html">查看源代码</a>。</p><h4 id="怎么选择断点"><a href="#怎么选择断点" class="headerlink" title="怎么选择断点"></a>怎么选择断点</h4><p>响应式设计的早期，许多设计者会尝试指向非常特定的屏幕尺寸。人们公布了流行的手机和平板的屏幕尺寸列表，以让设计者创建可以整齐地放在那些视口里面的设计。</p><p>现在有多得多的设备，以及多种多样的尺寸，让这种事变得不再可行。这也就是说，将所有的设计用在特定的尺寸上以外，一个更好的方法是在内容某种程度上开始变得混乱的时候，改变尺寸的设计。也许线太长了，或者盒子状的外侧栏开始挤在一起而难以阅读。那就是你想要使用媒体查询，将设计变得对剩余可用空间更加友好的时候。这种方式意味着，它无关使用的设备的确切大小，每个范围都被照顾到了。引入媒体查询的点就叫做<strong>断点</strong>。</p><p>火狐开发者工具中的<a href="https://firefox-source-docs.mozilla.org/devtools-user/responsive_design_mode/index.html">响应式设计模式</a>能很好地帮助弄清楚断点应该设置在哪里。你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Media_queries/rwd-mode.png" alt="A screenshot of a layout in a mobile view in Firefox DevTools."></p><h4 id="主动学习：移动优先的响应式设计"><a href="#主动学习：移动优先的响应式设计" class="headerlink" title="主动学习：移动优先的响应式设计"></a>主动学习：移动优先的响应式设计</h4><p>泛泛地说，你可以采用两种方式实现响应式设计。你可以从桌面或者最宽的视图开始，然后随着视口变得越来越小，加上断点，把物件挪开；你也可以从最小的视图开始，随着视口变得越来越大，增添布局内容。第二种方式被叫做<strong>移动优先</strong>的响应式设计，很多时候是最值得仿效的做法。</p><p>用在最小的那个设备上的视图很多时候都是一个简单的单列内容，很像正常文本流显示的那样。这意味着，你很可能不需要为小设备做多少布局设计，合适地安排下你的源代码，默认情况下你就可以得到可读的布局。</p><p>下面的教程会领你用一个非常简单的布局熟悉这种方式。在生产站点上，你的媒体查询中可能会有更多的东西需要调整，但是它们的方法是完全一样的。</p><h4 id="教程：一个简单的移动优先布局"><a href="#教程：一个简单的移动优先布局" class="headerlink" title="教程：一个简单的移动优先布局"></a>教程：一个简单的移动优先布局</h4><p>我们的起始点是一个 HTML 文档，上面应用了一些 CSS，为布局的各部分加入了背景颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2em</span> auto;<br>    <span class="hljs-attribute">font</span>: <span class="hljs-number">1em</span>/<span class="hljs-number">1.3</span> Arial, Helvetica, sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span>,<br><span class="hljs-selector-tag">aside</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.2</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.7</span>);<br>&#125;<br><br><span class="hljs-selector-class">.related</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>, <span class="hljs-number">0.3</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">207</span>, <span class="hljs-number">232</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们没有改变过任何布局，但是文件的源代码是以让内容可读的方式排列的。这个开头是重要的，也是能够确保内容在由屏幕阅读器读出来的时候，让其可以理解的一步。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Meet the team<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Blog<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Veggies!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;related&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sidebar&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>External vegetable-based links<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>              ...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span>2019<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个简单的布局在移动端上也能表现得很好。如果我们在开发者工具中的响应式设计模式里面查看这个布局的话，我们可以看到，它作为一个直截了当的站点移动版布局来说，表现得相当优秀。</p><p>在浏览器里<a href="https://mdn.github.io/css-examples/learn/media-queries/step1.html">打开步骤一</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step1.html">查看源代码</a>。</p><p><strong>如果你想要在我们继续的时候，按步骤来并尝试这个示例，在你的电脑上建立一个<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step1.html">step1.html</a>的本地副本。</strong></p><p>从这里开始，脱拽响应式设计的窗口，让它变得变得更宽，直到你看到一行变得非常长，有足够空间把导航栏放在一个水平行里面。这是我们加入第一个媒体查询的地方。我们将会使用 em，因为这意味着，如果用户已经增加了文本的大小，断点会在行差不多也是这样长，但是视口更宽的时候产生；而文本更小的时候，视口也会更窄。</p><p><strong>将下面的代码加到你的 step1.html 的 CSS 底部。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">40em</span>) &#123;<br>    <span class="hljs-selector-tag">article</span> &#123;<br>        <span class="hljs-attribute">display</span>: grid;<br>        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">3</span>fr <span class="hljs-number">1</span>fr;<br>        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> &#123;<br>        <span class="hljs-attribute">display</span>: flex;<br>    &#125;<br><br>    <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">li</span> &#123;<br>        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 CSS 让我们的文章里面有了个两列布局，两栏分别是文章的内容和在 aside 元素中相关的信息。我们也已经用弹性盒把导航栏放在了一行里面。</p><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/step2.html">打开步骤二</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step2.html">查看源代码</a>。</p><p>让我们继续增加宽度，直到我们觉得这里有了足够多的空间来放置侧栏，再形成一列。在媒体查询中，我们会让 main 元素变成两栏网格。我们之后需要移除文章上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a>，让两个侧栏和彼此对齐，然后我们将会往页脚的顶部加上一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 。一般来说，为了让设计看起来好看，这些小调整是你将会在每一个断点都需要做的。</p><p><strong>再往你的 step1.html 的 CSS 的底部加入下面的代码：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">70em</span>) &#123;<br>    <span class="hljs-selector-tag">main</span> &#123;<br>        <span class="hljs-attribute">display</span>: grid;<br>        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">3</span>fr <span class="hljs-number">1</span>fr;<br>        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">article</span> &#123;<br>        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-selector-tag">footer</span> &#123;<br>        <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">2em</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/step3.html">打开步骤三</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/step3.html">查看源代码</a>。</p><p>如果你在不同的宽度下，看下最后的示例，你会看到设计是如何响应的，在可用的宽度下是如何表现为单栏、双栏或者三栏的。这是一个移动优先的响应式设计的非常简单的示例。</p><h4 id="你真的需要媒体查询吗？"><a href="#你真的需要媒体查询吗？" class="headerlink" title="你真的需要媒体查询吗？"></a>你真的需要媒体查询吗？</h4><p>弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。这些布局方式能否在不加入媒体查询的时候实现你想要的设计，总是值得考虑的一件事。例如，你可能想要一组卡片，至少为二百像素宽，并在主文章里尽可能多地放下这些二百像素的卡片。这可以用网格布局实现，而完全不使用媒体查询。</p><p>这可以由以下代码实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 3<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 4<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Card 5<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>&#125;<br><br><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器中<a href="https://mdn.github.io/css-examples/learn/media-queries/grid.html">打开网格布局示例</a>，或者<a href="https://github.com/mdn/css-examples/blob/master/learn/media-queries/grid.html">查看源代码</a>。</p><p>在你的浏览器里打开这个示例，让屏幕变宽变窄，看一看列轨数目的变化。这个方法里面的好事是，网格不是靠视口宽度判断的，而是可以容纳组件的宽度。对媒体查询这章节的建议就是，你可能根本不需要它！但是，实践中你会发现，由媒体查询改进的现代布局方式的恰当使用，将会产生最佳效果。</p><h2 id="3-javascript"><a href="#3-javascript" class="headerlink" title="3 javascript"></a>3 javascript</h2><blockquote><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li></ol></blockquote><h3 id="3-1-javascript第一步"><a href="#3-1-javascript第一步" class="headerlink" title="3.1 javascript第一步"></a>3.1 javascript第一步</h3><p>JavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是实时的内容更新，交互式的地图，2D&#x2F;3D 动画，滚动播放的视频等等。JavaScript 怎能缺席。它是标准 Web 技术蛋糕的第三层，其中 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML">HTML</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS">CSS</a> 我们已经在学习中心的其他部分进行了详细的讲解。</p><p>示例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>para.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, updateName);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入一个新的名字：&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;玩家 1：&#x27;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript 语言核心之上所构建的功能更令人兴奋。<strong>应用程序接口（Application Programming Interfaces</strong>（<strong>API</strong>））将为你的代码提供额外的超能力。</p><p>API 通常分为两类。</p><p><strong>浏览器 API</strong> 内建于 web 浏览器中，它们可以将数据从周边计算机环境中筛选出来，还可以做实用的复杂工作。例如：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model"><code>文档对象模型 API（DOM（Document Object Model）API）</code></a> 能通过创建、移除和修改 HTML，为页面动态应用新样式等手段来操作 HTML 和 CSS。比如当某个页面出现了一个弹窗，或者显示了一些新内容（像上文小 demo 中看到那样），这就是 DOM 在运行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation"><code>地理位置 API（Geolocation API）</code></a> 获取地理信息。这就是为什么 <a href="https://www.google.cn/maps">谷歌地图</a> 可以找到你的位置，而且标示在地图上。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API"><code>画布（Canvas）</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API"><code>WebGL</code></a> API 可以创建生动的 2D 和 3D 图像。人们正运用这些 web 技术制作令人惊叹的作品。参见 <a href="https://www.chromeexperiments.com/webgl">Chrome Experiments</a> 以及 <a href="https://webglsamples.org/">webglsamples</a>。</li><li>诸如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API"><code>WebRTC</code></a> 等 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery">影音类 API</a> 让你可以利用多媒体做一些非常有趣的事，比如在网页中直接播放音乐和影片，或用自己的网络摄像头获取录像，然后在其他人的电脑上展示（试用简易版 <a href="http://chrisdavidmills.github.io/snapshot/">截图 demo</a> 以理解这个概念）。</li></ul><p><strong>第三方 API</strong> 并没有默认嵌入浏览器中，一般要从网上取得它们的代码和信息。比如：</p><ul><li><a href="https://dev.twitter.com/overview/documentation">Twitter API</a>、<a href="https://open.weibo.com/">新浪微博 API</a> 可以在网站上展示最新推文之类。</li><li><a href="https://developers.google.com/maps/">谷歌地图 API</a>、<a href="https://lbs.amap.com/">高德地图 API</a> 可以在网站嵌入定制的地图等等。</li></ul><h4 id="JavaScript-在页面上做了什么？"><a href="#JavaScript-在页面上做了什么？" class="headerlink" title="JavaScript 在页面上做了什么？"></a>JavaScript 在页面上做了什么？</h4><p>让我们简单回顾一下，浏览器在读取一个网页时都发生什么（<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works#how_does_css_actually_work">CSS 如何工作</a> 一文中首次谈及）。浏览器在读取一个网页时，代码（HTML, CSS 和 JavaScript）将在一个运行环境（浏览器标签页）中得到执行。就像一间工厂，将原材料（代码）加工为一件产品（网页）。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript/execution.png" alt="img"></p><p>在 HTML 和 CSS 集合组装成一个网页后，浏览器的 JavaScript 引擎将执行 JavaScript 代码。这保证了当 JavaScript 开始运行之前，网页的结构和样式已经就位。</p><p>这样很好，因为 JavaScript 最普遍的用处是通过 DOM API（见上文）动态修改 HTML 和 CSS 来更新用户界面（user interface）。如果 JavaScript 在 HTML 和 CSS 就位之前加载运行，就会引发错误。</p><h4 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h4><p>每个浏览器标签页就是其自身用来运行代码的独立容器（这些容器用专业术语称为“运行环境”）。大多数情况下，每个标签页中的代码完全独立运行，而且一个标签页中的代码不能直接影响另一个标签页（或者另一个网站）中的代码。这是一个好的安全措施，如果不这样，黑客就可以从其他网站盗取信息，等等。</p><h4 id="JavaScript-运行次序"><a href="#JavaScript-运行次序" class="headerlink" title="JavaScript 运行次序"></a>JavaScript 运行次序</h4><p>当浏览器执行到一段 JavaScript 代码时，通常会按从上往下的顺序执行这段代码。这意味着你需要注意代码书写的顺序。比如，我们回到第一个例子中的 JavaScript 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>para.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, updateName);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;输入一个新的名字：&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;玩家 1：&#x27;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们选定一个文本段落（第 1 行)，然后给它附上一个事件监听器（第 3 行），使得在它被点击时，<code>updateName()</code> 代码块（code block） （5 – 8 行）便会运行。<code>updateName()</code> （这类可以重复使用的代码块称为“函数”）向用户请求一个新名字，然后把这个名字插入到段落中以更新显示。</p><p>如果你互换了代码里最初两行的顺序，会导致问题。浏览器<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/zh-CN/docs/Learn/Discover_browser_developer_tools">开发者控制台</a>将返回一个错误： <code>TypeError: para is undefined</code>。这意味着 <code>para</code> 对象还不存在，所以我们不能为它增添一个事件监听器。</p><h4 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a>解释代码 vs 编译代码</h4><p>作为程序员，你或许听说过这两个术语：<strong>解释</strong>（interpret）和 <strong>编译</strong>（compile）。在解释型语言中，代码自上而下运行，且实时返回运行结果。代码在由浏览器执行前，不需要将其转化为其他形式。代码将直接以文本格式（text form）被接收和处理。</p><p>相对的，编译型语言需要先将代码转化（编译）成另一种形式才能运行。比如 C&#x2F;C++ 先被编译成汇编语言，然后才能由计算机运行。程序将以二进制的格式运行，这些二进制内容是由程序源代码产生的。</p><p>JavaScript 是轻量级解释型语言。浏览器接受到 JavaScript 代码，并以代码自身的文本格式运行它。技术上，几乎所有 JavaScript 转换器都运用了一种叫做即时编译（just-in-time compiling）的技术；当 JavaScript 源代码被执行时，它会被编译成二进制的格式，使代码运行速度更快。尽管如此，JavaScript 仍然是一门解释型语言，因为编译过程发生在代码运行中，而非之前。</p><p>两种类型的语言各有优势，这个问题我们暂且不谈。</p><h4 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a>服务器端代码 vs 客户端代码</h4><p>你或许还听说过<strong>服务器端（server-side）</strong>和 **客户端（client-side）**代码这两个术语，尤其是在 web 开发时。客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。这就是**客户端 JavaScript**。</p><p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！JavaScript 也可用作服务器端语言，比如现在流行的 Node.js 环境，你可以在我们的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">动态网页 - 服务器端编程</a> 主题中找到更多关于服务器端 JavaScript 的知识。</p><h4 id="动态代码-vs-静态代码"><a href="#动态代码-vs-静态代码" class="headerlink" title="动态代码 vs 静态代码"></a>动态代码 vs 静态代码</h4><p>“<strong>动态</strong>”一词既适用于客户端 JavaScript，又适用于描述服务器端语言。是指通过按需生成新内容来更新 web 页面 &#x2F; 应用，使得不同环境下显示不同内容。服务器端代码会在服务器上动态生成新内容，例如从数据库中提取信息。而客户端 JavaScript 则在用户端浏览器中动态生成新内容，比如说创建一个新的 HTML 表格，用从服务器请求到的数据填充，然后在网页中向用户展示这个表格。两种情况的意义略有不同，但又有所关联，且两者（服务器端和客户端）经常协同作战。</p><p>没有动态更新内容的网页叫做“<strong>静态</strong>”页面<strong>，</strong>所显示的内容不会改变。</p><h4 id="内联-JavaScript-处理器"><a href="#内联-JavaScript-处理器" class="headerlink" title="内联 JavaScript 处理器"></a>内联 JavaScript 处理器</h4><p>注意，有时候你会遇到在 HTML 中存在着一丝真实的 JavaScript 代码。它或许看上去像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createParagraph</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;你点击了这个按钮！&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(para);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;createParagraph()&quot;</span>&gt;点我呀&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>你可以在下面尝试这个版本的 demo。</p><iframe class="sample-code-frame" title="内联 JavaScript 处理器 sample" id="frame_内联_javascript_处理器" width="100%" height="150" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript/_sample_.%E5%86%85%E8%81%94_javascript_%E5%A4%84%E7%90%86%E5%99%A8.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这个 demo 与之前的两个功能完全一致，只是在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button"><code>&lt;button&gt;</code></a> 元素中包含了一个内联的 <code>onclick</code> 处理器，使得函数在按钮被按下时运行。</p><p><strong>然而请不要这样做。</strong> 这将使 JavaScript 污染到 HTML，而且效率低下。对于每个需要应用 JavaScript 的按钮，你都得手动添加 <code>onclick=&quot;createParagraph()&quot;</code> 属性。</p><p>可以使用纯 JavaScript 结构来通过一个指令选取所有按钮。下文的这段代码即实现了这一目的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const buttons = document.query<span class="hljs-constructor">SelectorAll(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buttons.length ; i++) &#123;<br>  buttons<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">createParagraph</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写乍看去比 <code>onclick</code> 属性要长一些，但是这样写会对页面上所有按钮生效，无论多少个，或添加或删除，完全无需修改 JavaScript 代码。</p><h4 id="脚本调用策略"><a href="#脚本调用策略" class="headerlink" title="脚本调用策略"></a>脚本调用策略</h4><p>要让脚本调用的时机符合预期，需要解决一系列的问题。这里看似简单，实际大有文章。最常见的问题就是：HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">文档对象模型</a> DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。</p><p>在上文的“内部”、“外部”示例中，JavaScript 调用于文档头处，解析 HTML 文档体之前。这样做是有隐患的，需要使用一些结构来避免错误发生。</p><p>“内部”示例使用了以下结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  . . .<br>&#125;);<br></code></pre></td></tr></table></figure><p>这是一个事件监听器，它监听浏览器的 “<code>DOMContentLoaded</code>“ 事件，即 HTML 文档体加载、解释完毕事件。事件触发时将调用 “ <code>. . .</code>“ 处的代码，从而避免了错误发生（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件</a> 的概念稍后学习）。</p><p>“外部”示例中使用了 JavaScript 的一项现代技术（<code>async</code> “异步”属性）来解决这一问题，它告知浏览器在遇到 <code>&lt;script&gt;</code> 元素时不要中断后续 HTML 内容的加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述情况下，脚本和 HTML 将一并加载，代码将顺利运行。</p><p><strong>备注：</strong> “外部”示例中 <code>async</code> 属性可以解决调用顺序问题，因此无需使用 <code>DOMContentLoaded</code> 事件。而 <code>async</code> 只能用于外部脚本，因此不适用于“内部”示例。</p><p>解决此问题的旧方法是：把脚本元素放在文档体的底端（<code>&lt;/body&gt;</code> 标签之前，与之相邻），这样脚本就可以在 HTML 解析完毕后加载了。此方案（以及上述的 <code>DOMContentLoaded</code> 方案）的问题是：只有在所有 HTML DOM 加载完成后才开始脚本的加载&#x2F;解析过程。对于有大量 JavaScript 代码的大型网站，可能会带来显著的性能损耗。这也是 <code>async</code> 属性诞生的初衷。</p><h4 id="async-和-defer"><a href="#async-和-defer" class="headerlink" title="async 和 defer"></a><code>async</code> 和 <code>defer</code></h4><p>上述的脚本阻塞问题实际有两种解决方案 —— <code>async</code> 和 <code>defer</code>。我们来依次讲解。</p><p>浏览器遇到 <code>async</code> 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，<code>async</code> 是最理想的选择。</p><p>比如，如果你的页面要加载以下三个脚本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>三者的调用顺序是不确定的。<code>jquery.js</code> 可能在 <code>script2</code> 和 <code>script3</code> 之前或之后调用，如果这样，后两个脚本中依赖 <code>jquery</code> 的函数将产生错误，因为脚本运行时 <code>jquery</code> 尚未加载。</p><p>解决这一问题可使用 <code>defer</code> 属性，脚本将按照在页面中出现的顺序加载和运行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code> 必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code> 之前。</p><p>脚本调用策略小结：</p><ul><li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li><li>如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li></ul><h3 id="3-2-有趣的字符串方法"><a href="#3-2-有趣的字符串方法" class="headerlink" title="3.2 有趣的字符串方法"></a>3.2 有趣的字符串方法</h3><p>现在我们学习基本的字符串语法，让我们开始思考一下我们可以对内置方法的字符串做什么有用的操作，例如查找文本字符串的长度，加入和分割字符串，将字符串中的一个字符替换为另一个字符。</p><h4 id="获得字符串的长度"><a href="#获得字符串的长度" class="headerlink" title="获得字符串的长度"></a>获得字符串的长度</h4><p>这很简单 — 你可以很轻松的使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/length"><code>length</code></a> 属性。尝试输入以下的两行代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let browserType = <span class="hljs-string">&#x27;mozilla&#x27;</span>;<br>browserType.<span class="hljs-built_in">length</span>;<br></code></pre></td></tr></table></figure><p>这个结果应该返回一个数字：7，因为”mozilla”的长度为 7 个字符。说字符串的长度有用是有很多原因的，例如，你可能想算出一连串名字的长度，并用名字长度来作为名字排序的依据，亦或让一个用户知道他输入的用户名太长，已经超出了输入的字符串长度限制。</p><h4 id="检索特定字符串字符"><a href="#检索特定字符串字符" class="headerlink" title="检索特定字符串字符"></a>检索特定字符串字符</h4><p>在相关的注释中，您可以使用方括号表示法返回字符串中的任何字符 - 这意味着您可以在变量名的末尾包含方括号（[ ]）。在方括号内，您可以包含要返回的字符的编号，例如，您要检索第一个字母，可以这样做：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>电脑从 0 开始，不是 1！要检索任何字符串的最后一个字符，我们可以使用下面这行，将这种技术与我们上面看到的 length 属性相结合起来：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType[browserType.length-<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>“mozilla”的长度为 7，但由于计数从 0 开始，所以字符位置为 6，因此需要长度为<strong>length-1</strong>。例如，您可以使用它来查找一系列字符串的第一个字母，并按字母顺序排列。</p><h4 id="在字符串中查找子字符串并提取它"><a href="#在字符串中查找子字符串并提取它" class="headerlink" title="在字符串中查找子字符串并提取它"></a>在字符串中查找子字符串并提取它</h4><ol><li><p>有时候你会想要找出一个较小的字符串是否存在于一个较大的字符串中（我们通常会说一个字符串中存在一个子字符串）。这可以使用<code>indexOf()</code>方法来完成，该方法需要一个parameter (en-US)— 你想要搜索的子字符串。尝试以下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;zilla&#x27;</span>);<br></code></pre></td></tr></table></figure><p>结果是 2，因为子字符串“zilla”从“mozilla”内的位置 2（0，1，2 —— 所以从第 3 个字符）开始。这样的代码可以用来过滤字符串。例如，假设我们有一个 Web 地址列表，但我们只想打印出包含“mozilla”的那些地址。</p></li><li><p>这可以用另一种可能更有效的方式来实现。尝试以下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;vanilla&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这应该会得到-1的结果 —— 当在主字符串中找不到子字符串（在本例中为“vanilla”）时将返回-1。 您可以使用它来查找不包含子串“mozilla”的所有字符串实例，或者如果使用否定运算符，请执行以下操作。你可以这样做：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(browserType.indexOf(<span class="hljs-string">&#x27;mozilla&#x27;</span>)</span></span> !== -<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-comment">// do stuff with the string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当你知道字符串中的子字符串开始的位置，以及想要结束的字符时，<code>slice()</code>可以用来提取它。尝试以下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">browserType</span>.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>这时返回”moz”——第一个参数是开始提取的字符位置，第二个参数是提取的最后一个字符的后一个位置。所以提取从第一个位置开始，直到但不包括最后一个位置。（此例中）你也可以说第二个参数等于被返回的字符串的长度。</p></li><li><p>此外，如果您知道要在某个字符之后提取字符串中的所有剩余字符，则不必包含第二个参数，而只需要包含要从中提取的字符位置 字符串中的其余字符。尝试以下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType.slice(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这返回“zilla” —— 这是因为 2 的字符位置是字母 z，并且因为没有包含第二个参数，所以返回的子字符串是字符串中的所有剩余字符。</p></li></ol><p><strong>备注：</strong> <code>slice()</code>的第二个参数是可选的：如果没有传入这个参数，分片结束位置会在原始字符串的末尾。这个方法也有其他的选项；学习<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice"><code>slice()</code></a>这页，来看看你还能发现什么其他作用。</p><h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><p>字符串方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase"><code>toLowerCase()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"><code>toUpperCase()</code></a>字符串并将所有字符分别转换为小写或大写。例如，如果要在将数据存储在数据库中之前对所有用户输入的数据进行规范化，这可能非常有用。</p><p>让我们尝试输入以下几行来看看会发生什么：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> radData = &#x27;My NaMe Is MuD&#x27;;<br>radData.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>radData.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>;<br></code></pre></td></tr></table></figure><h4 id="替换字符串的某部分"><a href="#替换字符串的某部分" class="headerlink" title="替换字符串的某部分"></a>替换字符串的某部分</h4><p>您可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace()</code></a>方法将字符串中的一个子字符串替换为另一个子字符串。在基础的层面上，这个工作非常简单。你当然可以用它做一些更高级的事情，但目前我们不会涉及到。</p><p>它需要两个参数 - 要被替换下的字符串和要被替换上的字符串。尝试这个例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;moz&#x27;</span>,<span class="hljs-string">&#x27;van&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意，在实际程序中，想要真正更新 <code>browserType</code> 变量的值，您需要设置变量的值等于刚才的操作结果；它不会自动更新子串的值。所以事实上你需要这样写：<code>browserType = browserType.replace(&#39;moz&#39;,&#39;van&#39;);</code>。</p><h3 id="3-3-数组"><a href="#3-3-数组" class="headerlink" title="3.3 数组"></a>3.3 数组</h3><p>数组通常被描述为“像列表一样的对象”; 简单来说，数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。</p><h4 id="数组是什么？"><a href="#数组是什么？" class="headerlink" title="数组是什么？"></a>数组是什么？</h4><p>数组通常被描述为“像列表一样的对象”; 简单来说，数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。也许我们有一系列产品和价格存储在一个数组中，我们想循环遍历所有这些产品，并将它们打印在发票上，同时将所有产品的价格统计在一起，然后将总价格打印在底部。</p><p>如果我们没有数组，我们必须将每个产品存储在一个单独的变量中，然后调用打印的代码，并为每个产品单独添加。花费的时间要长得多，效率很低，而且也容易出错。如果我们有 10 个产品需要添加发票，那就只是有点麻烦而已，但是 100 个，或者 1000 个呢？我们稍后将在文章中使用这个例子。</p><p>像以前的文章一样，我们通过在 JavaScript 控制台中输入一些示例来了解数组的基础知识。我们在下面提供了一个（您也可以在单独的选项卡或窗口中打开此控制台，或者如果您愿意，请使用<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Tools_and_setup/What_are_browser_developer_tools">浏览器的开发者工具控制台</a>）。</p><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>数组由方括号构成，其中包含用逗号分隔的元素列表。</p><ol><li><p>假设我们想在一个数组中存储一个购物清单 - 我们会做一些像下面这样的事情。在您的控制台中输入以下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> shopping = [<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;milk&#x27;</span>, <span class="hljs-string">&#x27;cheese&#x27;</span>, <span class="hljs-string">&#x27;hummus&#x27;</span>, <span class="hljs-string">&#x27;noodles&#x27;</span>];<br>shopping;<br></code></pre></td></tr></table></figure></li><li><p>在这种情况下，数组中的每个项目都是一个字符串，但请记住，您可以将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。您也可以混合和匹配项目类型 - 它们并不都是数字，字符串等。尝试下面这些：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let sequence</span> = [1, 1, 2, 3, 5, 8, 13];<br><span class="hljs-attribute">let random</span> = [<span class="hljs-string">&#x27;tree&#x27;</span>, 795, [0, 1, 2]];<br></code></pre></td></tr></table></figure></li><li><p>尝试创建您自己的几个数组，然后再继续往下看。</p></li></ol><h4 id="访问和修改数组元素"><a href="#访问和修改数组元素" class="headerlink" title="访问和修改数组元素"></a>访问和修改数组元素</h4><p>然后，您可以使用括号表示法访问数组中的元素，与 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Useful_string_methods#%E6%A3%80%E7%B4%A2%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6">检索特定字符串字符</a> 的方法相同。</p><ol><li><p>在您的控制台中输入以下内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">shopping[<span class="hljs-number">0</span>];<br><span class="hljs-regexp">//</span> returns <span class="hljs-string">&quot;bread&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>您还可以简单地为单个数组元素提供新值来修改数组中的元素。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">shopping[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;tahini&#x27;</span>;<br>shopping;<br><span class="hljs-regexp">//</span> shopping will now return [ <span class="hljs-string">&quot;tahini&quot;</span>, <span class="hljs-string">&quot;milk&quot;</span>, <span class="hljs-string">&quot;cheese&quot;</span>, <span class="hljs-string">&quot;hummus&quot;</span>, <span class="hljs-string">&quot;noodles&quot;</span> ]<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 我们以前说过，但还是提醒一下 —— 电脑从 0 开始计数！</p></li><li><p>请注意，数组中包含数组的话称之为多维数组。您可以通过将两组方括号链接在一起来访问数组内的另一个数组。例如，要访问数组内部的一个项目，即random数组中的第三个项目（参见上一节），我们可以这样做：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">random</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure></li><li><p>在继续之前，尝试对您的数组示例进行一些修改。玩一玩，看看哪些有效，哪些无效。</p></li></ol><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>你可以通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性获取数组的长度（数组中有多少项元素），这与查找字符串的长度（以字符为单位）完全相同。尝试以下代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">sequence.<span class="hljs-built_in">length</span>;<br><span class="hljs-comment">// should return 7</span><br></code></pre></td></tr></table></figure><p>虽然 length 属性也有其他用途，但最常用于循环（循环遍历数组中的所有项）。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">let</span> <span class="hljs-keyword">sequence</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sequence</span><span class="hljs-variable">.length</span>; i++) &#123;<br>  console<span class="hljs-variable">.log</span>(<span class="hljs-keyword">sequence</span>[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>您将在以后的文章中正确地了解循环，但简而言之，这段代码的意思是：</p><ol><li>在数组中的元素编号 0 开始循环。</li><li>在元素编号等于数组长度的时候停止循环。这适用于任何长度的数组，但在这种情况下，它将在编号 7 的时候终止循环（这很好，因为我们希望最后一位元素的编号是 6）。</li><li>对于每个元素，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/console/log">console.log()</a> 将其打印到浏览器控制台。</li></ol><h4 id="一些有用的数组方法"><a href="#一些有用的数组方法" class="headerlink" title="一些有用的数组方法"></a>一些有用的数组方法</h4><p>在本节中，我们将介绍一些相当有用的数组方法，这些方法允许我们将字符串拆分为字符串数组，反之亦然，以及添加或删除元素。</p><h4 id="字符串和数组之间的转换"><a href="#字符串和数组之间的转换" class="headerlink" title="字符串和数组之间的转换"></a>字符串和数组之间的转换</h4><p>通常，您会看到一个包含在一个长长的字符串中的原始数据，您可能希望将有用的项目分成更有用的表单，然后对它们进行处理，例如将它们显示在数据表中。为此，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split()</code></a> 方法。在其最简单的形式中，这需要一个参数，您要将字符串分隔的字符，并返回分隔符之间的子串，作为数组中的项。</p><p><strong>备注：</strong> 好吧，从技术上讲，这是一个字符串方法，而不是一个数组方法，但是我们把它放在数组中，因为它在这里很合适。</p><ol><li><p>我们来玩一下这个方法，看看它是如何工作的。首先，在控制台中创建一个字符串：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let myData</span> = <span class="hljs-string">&#x27;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>现在我们用每个逗号分隔它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> myArray = myData.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>myArray;<br></code></pre></td></tr></table></figure></li><li><p>最后，尝试找到新数组的长度，并从中检索一些项目：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">myArray.length;<br>myArray[0]; // the first item in the<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>myArray[1]; // the second item in the<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>myArray[myArray.length-1]; // the last item in the array<br></code></pre></td></tr></table></figure></li><li><p>您也可以使用<code>join()</code>方法进行相反的操作。尝试以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> myNewString = myArray.<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>myNewString;<br></code></pre></td></tr></table></figure></li><li><p>将数组转换为字符串的另一种方法是使用<code>toString()</code>方法。toString()可以比join()更简单，因为它不需要一个参数，但更有限制。使用join()可以指定不同的分隔符（尝试使用与逗号不同的字符运行步骤 4）。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">dogNames</span> = [<span class="hljs-string">&quot;Rocket&quot;</span>,<span class="hljs-string">&quot;Flash&quot;</span>,<span class="hljs-string">&quot;Bella&quot;</span>,<span class="hljs-string">&quot;Slugger&quot;</span>];<br>dogNames.<span class="hljs-built_in">toString</span>(); //Rocket,Flash,Bella,Slugger<br></code></pre></td></tr></table></figure></li></ol><h4 id="添加和删除数组项"><a href="#添加和删除数组项" class="headerlink" title="添加和删除数组项"></a>添加和删除数组项</h4><p>我们还没有涵盖添加和删除数组元素，现在让我们来看看。我们将使用在上一节中最后提到的 <code>myArray</code> 数组。如果您尚未遵循该部分，请先在控制台中创建数组：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let myArray</span> = [<span class="hljs-string">&#x27;Manchester&#x27;</span>, <span class="hljs-string">&#x27;London&#x27;</span>, <span class="hljs-string">&#x27;Liverpool&#x27;</span>, <span class="hljs-string">&#x27;Birmingham&#x27;</span>, <span class="hljs-string">&#x27;Leeds&#x27;</span>, <span class="hljs-string">&#x27;Carlisle&#x27;</span>];<br></code></pre></td></tr></table></figure><p>首先，要在数组末尾添加或删除一个项目，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a>。</p><ol><li><p>让我们先使用push()—— 注意，你需要添加一个或多个要添加到数组末尾的元素。尝试下面的代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">myArray.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;Cardiff&#x27;</span>);<br>myArray;<br>myArray.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;Bradford&#x27;</span>, <span class="hljs-string">&#x27;Brighton&#x27;</span>);<br>myArray;<br></code></pre></td></tr></table></figure></li><li><p>当方法调用完成时，将返回数组的新长度。如果要将新数组长度存储在变量中。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Length</span> = myArray.push(<span class="hljs-string">&#x27;Bristol&#x27;</span>);<br>myArray;<br><span class="hljs-keyword">new</span><span class="hljs-type">Length</span>;<br></code></pre></td></tr></table></figure></li><li><p>从数组中删除最后一个元素的话直接使用pop()就可以。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">myArray.pop()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>当方法调用完成时，将返回已删除的项目。你也可以这样做：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let removedItem <span class="hljs-operator">=</span> myArray.pop()<span class="hljs-comment">;</span><br>myArray<span class="hljs-comment">;</span><br>removedItem<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift"><code>unshift()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift"><code>shift()</code></a> 从功能上与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a> 完全相同，只是它们分别作用于数组的开始，而不是结尾。</p><ol><li><p>首先unshift()——尝试一下这个命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">myArray.unshift(&#x27;Edinburgh&#x27;);<br>myArray;<br></code></pre></td></tr></table></figure></li><li><p>现在shift()—— 尝试一下！</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let removedItem <span class="hljs-operator">=</span> myArray.shift()<span class="hljs-comment">;</span><br>myArray<span class="hljs-comment">;</span><br>removedItem<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-事件介绍"><a href="#3-4-事件介绍" class="headerlink" title="3.4 事件介绍"></a>3.4 事件介绍</h3><p>事件是您在编程时系统内发生的动作或者发生的事情，系统响应事件后，如果需要，您可以某种方式对事件做出回应。例如：如果用户在网页上单击一个按钮，您可能想通过显示一个信息框来响应这个动作。在这篇文章中，我们将讨论一些关于事件的重要概念，并且观察它们在浏览器上如何运行。这篇文章不会面面俱到，仅聚焦于您现阶段需要掌握的知识。</p><h4 id="一系列事件"><a href="#一系列事件" class="headerlink" title="一系列事件"></a>一系列事件</h4><p>就像上面提到的，<strong>事件</strong>是您在编程时系统内发生的动作或者发生的事情——系统会在事件出现时产生或触发某种信号，并且会提供一个自动加载某种动作（列如：运行一些代码）的机制，比如在一个机场，当跑道清理完成，飞机可以起飞时，飞行员会收到一个信号，因此他们开始起飞。</p><p>在 Web 中，事件在浏览器窗口中被触发并且通常被绑定到窗口内部的特定部分 — 可能是一个元素、一系列元素、被加载到这个窗口的 HTML 代码或者是整个浏览器窗口。举几个可能发生的不同事件：</p><ul><li>用户在某个元素上点击鼠标或悬停光标。</li><li>用户在键盘中按下某个按键。</li><li>用户调整浏览器的大小或者关闭浏览器窗口。</li><li>一个网页停止加载。</li><li>提交表单。</li><li>播放、暂停、关闭视频。</li><li>发生错误。</li></ul><p>如果您想看看更多其他的事件，请移步至 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">Event reference</a>。</p><p>每个可用的事件都会有一个<strong>事件处理器</strong>，也就是事件触发时会运行的代码块。当我们定义了一个用来回应事件被激发的代码块的时候，我们说我们<strong>注册了一个事件处理器</strong>。注意事件处理器有时候被叫做<strong>事件监听器</strong>——从我们的用意来看这两个名字是相同的，尽管严格地来说这块代码既监听也处理事件。监听器留意事件是否发生，然后处理器就是对事件发生做出的回应。</p><p><strong>备注：</strong> 网络事件不是 JavaScript 语言的核心——它们被定义成内置于浏览器的 JavaScript APIs。</p><p>值得注意的是并不是只有 JavaScript 使用事件——大多的编程语言都有这种机制，并且它们的工作方式不同于 JavaScript。实际上，JavaScript 网页上的事件机制不同于在其他环境中的事件机制。</p><p>比如，<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs">Node.js</a> 是一种非常流行的允许开发者使用 JavaScript 来建造网络和服务器端应用的运行环境。<a href="https://nodejs.org/docs/latest-v5.x/api/events.html">Node.js event model</a> 依赖定期监听事件的监听器和定期处理事件的处理器——虽然听起来好像差不多，但是实现两者的代码是非常不同的，Node.js 使用像 on ( ) 这样的函数来注册一个事件监听器，使用 once ( ) 这样函数来注册一个在运行一次之后注销的监听器。 <a href="https://nodejs.org/docs/latest-v5.x/api/http.html#http_event_connect">HTTP connect event docs</a> 提供了很多例子。</p><p>另外一个例子：您可以使用 JavaScript 来开发跨浏览器的插件（使用 <a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions">WebExtensions</a> 开发技术。事件模型和网站的事件模型是相似的，仅有一点点不同——事件监听属性使用驼峰命名法（如<code>onMessage</code>而不是<code>onmessage</code>），还需要与 <code>addListener</code> 函数结合，参见 <a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage#examples">runtime.onMessage page</a> 上的一个例子。</p><h4 id="使用网页事件的方式"><a href="#使用网页事件的方式" class="headerlink" title="使用网页事件的方式"></a>使用网页事件的方式</h4><p>您可以通过多种不同的方法将事件侦听器代码添加到网页，以便在关联的事件被触发时运行它。在本节中，我们将回顾不同的机制，并讨论应该使用哪些机制。</p><h4 id="事件处理器属性"><a href="#事件处理器属性" class="headerlink" title="事件处理器属性"></a>事件处理器属性</h4><p><em>这些是我们的课程中最常见到的代码 - 存在于事件处理程序过程的属性中</em>。回到上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/click_event"><code>onclick</code></a> 是被用在这个情景下的事件处理器的属性，它就像 button 其他的属性（如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent"><code>btn.textContent</code></a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style"><code>btn.style</code> (en-US)</a>), 但是有一个特别的地方——当您将一些代码赋值给它的时候，只要事件触发代码就会运行。</p><p>您也可以将一个有名字的函数赋值给事件处理参数（正如我们在 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Build_your_own_function">Build your own function</a> 中看到的），下面的代码也是这样工作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br><br>btn.<span class="hljs-property">onclick</span> = bgChange;<br></code></pre></td></tr></table></figure><p>有很多事件处理参数可供选择，我们来做一个实验。</p><p>首先将 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventhandlerproperty.html">random-color-eventhandlerproperty.html</a> 复制到本地，然后用浏览器打开。别慌，这只是我们之前已经进行过的一个简单随机颜色的示例的代码复制。将 <code>btn.onclick</code> 依次换成其他值，在浏览器中观察效果。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/focus_event"><code>btn.onfocus</code></a>及<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/blur_event"><code>btn.onblur</code></a> — 颜色将于按钮被置于焦点或解除焦点时改变（尝试使用 Tab 移动至按钮上，然后再移开）。这些通常用于显示有关如何在置于焦点时填写表单字段的信息，或者如果表单字段刚刚填入不正确的值，则显示错误消息。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/dblclick_event"><code>btn.ondblclick</code></a> — 颜色将仅于按钮被双击时改变。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keypress_event"><code>window.onkeypress</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keydown_event"><code>window.onkeydown</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keyup_event"><code>window.onkeyup</code></a> — 当按钮被按下时颜色会发生改变。<code>keypress</code> 指的是通俗意义上的按下按钮 (按下并松开), 而 <code>keydown</code> 和 <code>keyup</code> 指的是按键动作的一部分，分别指按下和松开。注意如果你将事件处理器添加到按钮本身，它将不会工作 — 我们只能将它添加到代表整个浏览器窗口的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">window</a>对象中。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseover_event"><code>btn.onmouseover</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseout_event"><code>btn.onmouseout</code></a> — 颜色将会在鼠标移入按钮上方时发生改变，或者当它从按钮移出时。</li></ul><p>一些事件非常通用，几乎在任何地方都可以用（比如 onclick 几乎可以用在几乎每一个元素上），然而另一些元素就只能在特定场景下使用，比如我们只能在 video 元素上使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event">onplay (en-US)</a> 。</p><h4 id="内联事件处理器——请勿使用"><a href="#内联事件处理器——请勿使用" class="headerlink" title="内联事件处理器——请勿使用"></a>内联事件处理器——请勿使用</h4><p>你也许在你的代码中看到过这么一种写法：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;bgChange()&quot;</span>&gt;Press me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  const rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  document.body.style.backgroundColor = rndCol;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 您可以在<a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventhandlerattributes.html">GitHub</a>上找到这个示例的完整源代码 (也可以<a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-eventhandlerattributes.html">在线运行</a>).</p><p>在 Web 上注册事件处理程序的最早方法是类似于上面所示的<strong>事件处理程序 HTML 属性</strong>(也称为内联事件处理程序)—属性值实际上是当事件发生时要运行的 JavaScript 代码。上面的例子中调用一个在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script"><code>div</code></a>元素在同一个页面上，但也可以直接在属性内插入 JavaScript，例如：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello, this is my old-fashioned event handler!&#x27;);&quot;</span>&gt;Press me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>你会发现 HTML 属性等价于对许多事件处理程序的属性；但是，你不应该使用这些 —— 他们被认为是不好的做法。使用一个事件处理属性似乎看起来很简单，如果你只是在做一些非常快的事情，但很快就变得难以管理和效率低下。</p><p>一开始，您不应该混用 HTML 和 JavaScript，因为这样文档很难解析——最好的办法是只在一块地方写 JavaScript 代码。</p><p>即使在单一文件中，内置事件处理器也不是一个好主意。一个按钮看起来还好，但是如果有一百个按钮呢？您得在文件中加上 100 个属性。这很快就会成为维护人员的噩梦。使用 Java Script，您可以给网页中的 button 都加上事件处理器。就像下面这样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> buttons = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; buttons.length; i++) &#123;<br>  buttons[i].onclick = bgChange;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 将您的编程逻辑与内容分离也会让您的站点对搜索引擎更加友好。</p><h4 id="addEventListener-和-removeEventListener"><a href="#addEventListener-和-removeEventListener" class="headerlink" title="addEventListener() 和 removeEventListener()"></a>addEventListener() 和 removeEventListener()</h4><p>新的事件触发机制被定义在 <a href="https://www.w3.org/TR/DOM-Level-2-Events/">Document Object Model (DOM) Level 2 Events</a> Specification, 这个细则给浏览器提供了一个函数 — <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>。这个函数和事件处理属性是类似的，但是语法略有不同。我们可以重写上面的随机颜色背景代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, bgChange);<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 您可以在<a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-addeventlistener.html">Github</a>上找到这个示例的完整源代码 (也可以 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-addeventlistener.html">在线运行</a>)。</p><p>在 <code>addEventListener()</code> 函数中，我们具体化了两个参数——我们想要将处理器应用上去的事件名称，和包含我们用来回应事件的函数的代码。注意将这些代码全部放到一个匿名函数中是可行的：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  document.body.style.backgroundColor = rndCol;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这个机制带来了一些相较于旧方式的优点。有一个相对应的方法，<code>removeEventListener()，</code>这个方法移除事件监听器。例如，下面的代码将会移除上个代码块中的事件监听器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">btn.remove<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">bgChange</span>)</span>;<br></code></pre></td></tr></table></figure><p>在这个简单的、小型的项目中可能不是很有用，但是在大型的、复杂的项目中就非常有用了，可以非常高效地清除不用的事件处理器，另外在其他的一些场景中也非常有效——比如您需要在不同环境下运行不同的事件处理器，您只需要恰当地删除或者添加事件处理器即可。</p><p>您也可以给同一个监听器注册多个处理器，下面这种方式不能实现这一点：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">myElement.onclick</span> = functionA<span class="hljs-comment">;</span><br><span class="hljs-attr">myElement.onclick</span> = functionB<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>第二行会覆盖第一行，但是下面这种方式就会正常工作了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">myElement.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">functionA</span>)</span>;<br>myElement.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">functionB</span>)</span>;<br></code></pre></td></tr></table></figure><p>当元素被点击时两个函数都会工作：</p><p>此外，该事件机制还提供了许多其他强大的特性和选项。这对于本文来说有点超出范围，但是如果您想要阅读它们，请查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/removeEventListener"><code>removeEventListener()</code></a>参考页面。</p><h4 id="我该使用哪种机制？"><a href="#我该使用哪种机制？" class="headerlink" title="我该使用哪种机制？"></a>我该使用哪种机制？</h4><p>在三种机制中，您绝对不应该使用 HTML 事件处理程序属性 - 这些属性已经过时了，而且也是不好的做法，如上所述。</p><p>另外两种是相对可互换的，至少对于简单的用途：</p><ul><li>事件处理程序属性功能和选项会更少，但是具有更好的跨浏览器兼容性 (在 Internet Explorer 8 的支持下)，您应该从这些开始学起。</li><li>DOM Level 2 Events (<code>addEventListener()</code>, etc.) 更强大，但也可以变得更加复杂，并且支持不足（只支持到 Internet Explorer 9）。但是您也应该尝试这个方法，并尽可能地使用它们。</li></ul><p>第三种机制（DOM Level 2 Events (<code>addEventListener()</code>, etc.)）的主要优点是，如果需要的话，可以使用<code>removeEventListener()</code>删除事件处理程序代码，而且如果有需要，您可以向同一类型的元素添加多个监听器。例如，您可以在一个元素上多次调用<code>addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>，并可在第二个参数中指定不同的函数。对于事件处理程序属性来说，这是不可能的，因为后面任何设置的属性都会尝试覆盖较早的属性，例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">element.onclick <span class="hljs-operator">=</span> function1<span class="hljs-comment">;</span><br>element.onclick <span class="hljs-operator">=</span> function2<span class="hljs-comment">;</span><br>etc.<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 如果您在工作中被要求支持比 Internet Explorer 8 更老的浏览器，那么您可能会遇到困难，因为这些古老的浏览器会使用与现代浏览器不同的事件处理模型。但是不要害怕，大多数 JavaScript 库 (例如 jQuery ) 都内置了能够跨浏览器差异的函数。在你学习 JavaScript 旅程里的这个阶段，不要太担心这个问题。</p><h4 id="其他事件概念"><a href="#其他事件概念" class="headerlink" title="其他事件概念"></a>其他事件概念</h4><p>本节我们将简要介绍一些与事件相关的高级概念。在这一点并不需要完全理解透彻，但它可能有助于你解释一些经常会遇到的代码模式。</p><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>有时候在事件处理函数内部，您可能会看到一个固定指定名称的参数，例如<code>event</code>，<code>evt</code>或简单的<code>e</code>。这被称为<strong>事件对象</strong>，它被自动传递给事件处理函数，以提供额外的功能和信息。例如，让我们稍稍重写一遍我们的随机颜色示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params">e</span>) &#123;<br>  const rndCol = <span class="hljs-string">&#x27;rgb(&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-built_in">random</span>(<span class="hljs-number">255</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  e.target.style.backgroundColor = rndCol;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(e);<br>&#125;<br><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, bgChange);<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> 您可以在 Github 上查看这个示例的 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventobject.html">完整代码</a> ，或者在这里查看 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/random-color-eventobject.html">实时演示</a>。</p><p>在这里，您可以看到我们在函数中包括一个事件对象<code>e</code>，并在函数中设置背景颜色样式在 <code>e.target</code> 上——它指的是按钮本身。事件对象 <code>e</code> 的 <code>target</code> 属性始终是事件刚刚发生的元素的引用。所以在这个例子中，我们在按钮上设置一个随机的背景颜色，而不是页面。</p><p><strong>备注：</strong> 您可以使用任何您喜欢的名称作为事件对象 - 您只需要选择一个名称，然后可以在事件处理函数中引用它。开发人员最常使用 e &#x2F; evt &#x2F; event，因为它们很简单易记。坚持标准总是很好。</p><p>当您要在多个元素上设置相同的事件处理程序时，<code>e.target</code>非常有用，并且在发生事件时对所有元素执行某些操作。例如，你可能有一组 16 块方格，当它们被点击时就会消失。用 e.target 总是能准确选择当前操作的东西（方格）并执行操作让它消失，而不是必须以更困难的方式选择它。在下面的示例中 (请参见<a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/useful-eventtarget.html">useful-eventtarget.html</a>完整代码;也可以在线运行<a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/useful-eventtarget.html">running live</a>）我们使用 JavaScript 创建了 16 个<code>&lt;div&gt;</code>元素。接着我们使用 <code>document.querySelectorAll()</code>选择全部的元素，然后遍历每一个，为每一个元素都添加一个<code>onclick</code>单击事件，每当它们点击时就会为背景添加一个随机颜色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; divs.<span class="hljs-property">length</span>; i++) &#123;<br>  divs[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-title function_">bgChange</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下 (试着点击它 - 玩的开心):</p><iframe class="sample-code-frame" title="事件对象 sample" id="frame_事件对象" width="100%" height="400" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>你遇到的大多数事件处理器的事件对象都有可用的标准属性和函数（方法）（请参阅完整列表 <code>Event</code> 对象引用）。然而，一些更高级的处理程序会添加一些专业属性，这些属性包含它们需要运行的额外数据。例如，媒体记录器 API 有一个<code>dataavailable</code>事件，它会在录制一些音频或视频时触发，并且可以用来做一些事情 (例如保存它，或者回放)。对应的<code>ondataavailable</code>处理程序的事件对象有一个可用的数据属性。</p><h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>有时，你会遇到一些情况，你希望事件不执行它的默认行为。最常见的例子是 Web 表单，例如自定义注册表单。当你填写详细信息并按提交按钮时，自然行为是将数据提交到服务器上的指定页面进行处理，并将浏览器重定向到某种“成功消息”页面（或 相同的页面，如果另一个没有指定。）</p><p>当用户没有正确提交数据时，麻烦就来了 - 作为开发人员，你希望停止提交信息给服务器，并给他们一个错误提示，告诉他们什么做错了，以及需要做些什么来修正错误。一些浏览器支持自动的表单数据验证功能，但由于许多浏览器不支持，因此建议你不要依赖这些功能，并实现自己的验证检查。我们来看一个简单的例子。</p><p>首先，一个简单的 HTML 表单，需要你填入名（first name）和姓（last name）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>First name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span>Last name: <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lname&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们用一个<code>onsubmit</code>事件处理程序（在提交的时候，在一个表单上发起<code>submit</code>事件）来实现一个非常简单的检查，用于测试文本字段是否为空。如果是，我们在事件对象上调用<code>preventDefault()</code>函数，这样就停止了表单提交，然后在我们表单下面的段落中显示一条错误消息，告诉用户什么是错误的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br><span class="hljs-keyword">const</span> fname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fname&#x27;</span>);<br><span class="hljs-keyword">const</span> lname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;lname&#x27;</span>);<br><span class="hljs-keyword">const</span> submit = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;submit&#x27;</span>);<br><span class="hljs-keyword">const</span> para = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><br>form.onsubmit = function(e) &#123;<br>  <span class="hljs-keyword">if</span> (fname.value === <span class="hljs-string">&#x27;&#x27;</span> || lname.value === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    e.preventDefault();<br>    para.textContent = <span class="hljs-string">&#x27;You need to fill in both names!&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这是一种非常弱的表单验证——例如，用户输入空格或数字提交表单，表单验证并不会阻止用户提交——这不是我们例子想要达到的目的。输出如下：</p><iframe class="sample-code-frame" title="阻止默认行为 sample" id="frame_阻止默认行为" width="100%" height="140" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p><strong>备注：</strong> 查看完整的源代码 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/preventdefault-validation.html">preventdefault-validation.html</a> (也可以 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/preventdefault-validation.html">running live</a> )</p><h4 id="事件冒泡及捕获"><a href="#事件冒泡及捕获" class="headerlink" title="事件冒泡及捕获"></a>事件冒泡及捕获</h4><p>最后即将介绍的这个主题你常常不会深究，但如果你不理解这个主题，就会十分痛苦。事件冒泡和捕捉是两种机制，主要描述当在一个元素上有两个相同类型的事件处理器被激活会发生什么。为了容易理解，我们来看一个例子——在新标签页打开这个<a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box.html">show-video-box.html</a> 例子（在这里可以查看源码 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html">source code</a>）。也可以在下面查看：</p><iframe class="sample-code-frame" title="事件冒泡及捕获 sample" id="frame_事件冒泡及捕获" width="100%" height="500" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Building_blocks/Events/_sample_.%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E6%8D%95%E8%8E%B7.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>这是一个非常简单的例子，它显示和隐藏一个包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video"><code>video</code></a> 元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div"><code>div</code></a> 元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Display video<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hidden&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Your browser doesn&#x27;t support HTML video. Here is a <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span>&gt;</span>link to the video<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> instead.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当“button”元素按钮被单击时，将显示视频，它是通过将改变 <code>&lt;div&gt;</code> 的 class 属性值从 <code>hidden</code> 变为 <code>showing</code>(这个例子的 CSS 包含两个 <code>class</code>，它们分别控制这个 <code>&lt;div&gt;</code> 盒子在屏幕上显示还是隐藏。)：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const btn = document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br>const videoBox = document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">div</span>&#x27;)</span>;<br><br><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Video()</span> &#123;<br>  <span class="hljs-keyword">if</span> (videoBox.get<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;)</span><span class="hljs-operator"> === </span>&#x27;hidden&#x27;) &#123;<br>    videoBox.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;,&#x27;<span class="hljs-params">showing</span>&#x27;)</span>;<br>  &#125;<br>&#125;<br><br>btn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">displayVideo</span>)</span>;<br></code></pre></td></tr></table></figure><p>然后我们再添加几个<code>click</code>事件处理器，第一个添加在<code>&lt;div&gt;</code>元素上，第二个添加在<code>&lt;video&gt;</code>元素上。这个想法是当视频 (<code>&lt;video&gt;</code>）外 <code>&lt;div&gt;</code>元素内这块区域被单击时，这个视频盒子应该再次隐藏；当单击视频 (<code>&lt;video&gt;</code>）本身，这个视频将开始播放。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">videoBox.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> videoBox.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;hidden&#x27;</span>));<br><br>const video = document.querySelector(<span class="hljs-string">&#x27;video&#x27;</span>);<br><br>video.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> video.play());<br></code></pre></td></tr></table></figure><p>但是有一个问题 - 当您点击<code>video</code>开始播放的视频时，它会在同一时间导致<code>&lt;div&gt;</code>也被隐藏。这是因为<code>video</code>在<code>&lt;div&gt;</code>之内 - <code>video</code>是<code>&lt;div&gt;</code>的一个子元素 - 所以点击<code>video</code>实际上是同时也运行<code>&lt;div&gt;</code>上的事件处理程序。</p><h4 id="对事件冒泡和捕捉的解释"><a href="#对事件冒泡和捕捉的解释" class="headerlink" title="对事件冒泡和捕捉的解释"></a>对事件冒泡和捕捉的解释</h4><p>当一个事件发生在具有父元素的元素上 (例如，在我们的例子中是<code>&lt;video&gt;</code>元素) 时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。在捕获阶段：</p><ul><li>浏览器检查元素的最外层祖先<code>&lt;html&gt;</code>，是否在捕获阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它。</li><li>然后，它移动到<code>&lt;html&gt;</code>中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。</li></ul><p>在冒泡阶段，恰恰相反：</p><ul><li>浏览器检查实际点击的元素是否在冒泡阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它</li><li>然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达<code>&lt;html&gt;</code>元素。</li></ul><p>在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册。因此，在我们当前的示例中，当您单击视频时，这个单击事件从 <code>&lt;video&gt;</code>元素向外冒泡直到<code>&lt;html&gt;</code>元素。沿着这个事件冒泡线路：</p><ul><li>它发现了<code>video.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>第一次开始播放。</li><li>接着它发现了（往外冒泡找到的） <code>videoBox.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>也隐藏起来了。</li></ul><h4 id="用-stopPropagation-修复问题"><a href="#用-stopPropagation-修复问题" class="headerlink" title="用 stopPropagation() 修复问题"></a>用 stopPropagation() 修复问题</h4><p>这是令人讨厌的行为，但有一种方法来解决它！标准事件对象具有可用的名为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>stopPropagation()</code></a>的函数，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在<strong>冒泡</strong>链上进一步扩大，因此将不会有更多事件处理器被运行 (不会向上冒泡)。所以，我们可以通过改变前面代码块中的第二个处理函数来解决当前的问题：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">video.onclick <span class="hljs-operator">=</span> function(e) &#123;<br>  e.stopPropagation()<span class="hljs-comment">;</span><br>  video.play()<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>你可以尝试把 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box.html">show-video-box.html source code</a> 拷贝到本地，然后自己动手修复它，或者在 <a href="https://mdn.github.io/learning-area/javascript/building-blocks/events/show-video-box-fixed.html">show-video-box-fixed.html</a> 页面查看修复结果（也可以在这里 <a href="https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/show-video-box-fixed.html">source code</a> 查看源码）。</p><p><strong>备注：</strong> 为什么我们要弄清楚捕捉和冒泡呢？那是因为，在过去糟糕的日子里，浏览器的兼容性比现在要小得多，Netscape（网景）只使用事件捕获，而 Internet Explorer 只使用事件冒泡。当 W3C 决定尝试规范这些行为并达成共识时，他们最终得到了包括这两种情况（捕捉和冒泡）的系统，最终被应用在现在浏览器里。</p><p><strong>备注：</strong> 如上所述，默认情况下，所有事件处理程序都是在冒泡阶段注册的，这在大多数情况下更有意义。如果您真的想在捕获阶段注册一个事件，那么您可以通过使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>注册您的处理程序，并将可选的第三个属性设置为 true。</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>冒泡还允许我们利用事件委托——这个概念依赖于这样一个事实，如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。</p><p>一个很好的例子是一系列列表项，如果你想让每个列表项被点击时弹出一条信息，您可以将<code>click</code>单击事件监听器设置在父元素<code>&lt;ul&gt;</code>上，这样事件就会从列表项冒泡到其父元素<code>&lt;ul&gt;</code>上。</p><p>这个的概念在 David Walsh 的博客上有更多的解释，并有多个例子——看看<a href="https://davidwalsh.name/event-delegate">How JavaScript Event Delegation Works</a>.</p><h3 id="3-5-对象入门"><a href="#3-5-对象入门" class="headerlink" title="3.5 对象入门"></a>3.5 对象入门</h3><p>点表示法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">name</span>.<span class="hljs-keyword">first</span><br><span class="hljs-built_in">name</span>.<span class="hljs-keyword">last</span><br></code></pre></td></tr></table></figure><p>括号表示法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">person<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;age&#x27;</span>]</span><br>person<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;name&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;first&#x27;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="“this”的含义"><a href="#“this”的含义" class="headerlink" title="“this”的含义"></a>“this”的含义</h4><p>你也许在我们的方法里注意到了一些奇怪的地方，看这个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">greeting: <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>  alert(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">&#x27;.&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你也许想知道”this”是什么，关键字”this”指向了当前代码运行时的对象 ( 原文：the current object the code is being written inside )——这里即指 person 对象，为什么不直接写 person 呢？当你学到下一篇<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Classes_in_JavaScript">Object-oriented JavaScript for beginners</a>文章时，我们开始使用构造器 (constructor) 时，”this”是非常有用的——它保证了当代码的上下文 (context) 改变时变量的值的正确性（比如：不同的 person 对象拥有不同的 name 这个属性，很明显 greeting 这个方法需要使用的是它们自己的 name）。</p><h4 id="基于原型的语言？"><a href="#基于原型的语言？" class="headerlink" title="基于原型的语言？"></a>基于原型的语言？</h4><p>JavaScript 常被描述为一种<strong>基于原型的语言 (prototype-based language)<strong>——每个对象拥有一个</strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><p>准确地说，这些属性和方法定义在 Object 的构造器函数 (constructor functions) 之上的<code>prototype</code>属性上，而非对象实例本身。</p><p>在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p><p><strong>备注：</strong> 理解对象的原型（可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf(obj)</code></a>或者已被弃用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a>属性获得）与构造函数的 <code>prototype</code> 属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，<code>Object.getPrototypeOf(new Foobar())</code> 和 <code>Foobar.prototype</code> 指向着同一个对象。</p><h4 id="使用-Javascript-中的原型"><a href="#使用-Javascript-中的原型" class="headerlink" title="使用 Javascript 中的原型"></a>使用 Javascript 中的原型</h4><p>在 javascript 中，函数可以有属性。每个函数都有一个特殊的属性叫作<strong>原型（prototype）</strong>，正如下面所展示的。请注意，下面的代码是独立的一段 (在网页中没有其他代码的情况下，这段代码是安全的)。为了最好的学习体验，你最好打开一个控制台 (在 Chrome 和 Firefox 中，可以按 Ctrl+Shift+I 来打开) 切换到”控制台” 选项卡，复制粘贴下面的 JavaScript 代码，然后按回车来运行。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomething.prototype );<br><span class="hljs-comment">// It does not matter how you declare the function, a</span><br><span class="hljs-comment">//  function in javascript will always have a default</span><br><span class="hljs-comment">//  prototype property.</span><br><span class="hljs-keyword">var</span> doSomething = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomething.prototype );<br></code></pre></td></tr></table></figure><p>正如上面所看到的，<code>doSomething</code> 函数有一个默认的原型属性，它在控制台上面呈现了出来。运行这段代码之后，控制台上面应该出现了像这样的一个对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    constructor: ƒ <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>,<br>    __proto__: &#123;<br>        constructor: ƒ <span class="hljs-constructor">Object()</span>,<br>        hasOwnProperty: ƒ has<span class="hljs-constructor">OwnProperty()</span>,<br>        isPrototypeOf: ƒ is<span class="hljs-constructor">PrototypeOf()</span>,<br>        propertyIsEnumerable: ƒ property<span class="hljs-constructor">IsEnumerable()</span>,<br>        toLocaleString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>,<br>        toString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>,<br>        valueOf: ƒ value<span class="hljs-constructor">Of()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以添加一些属性到 doSomething 的原型上面，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    foo: <span class="hljs-string">&quot;bar&quot;</span>,<br>    constructor: ƒ <span class="hljs-keyword">do</span><span class="hljs-constructor">Something()</span>,<br>    __proto__: &#123;<br>        constructor: ƒ <span class="hljs-constructor">Object()</span>,<br>        hasOwnProperty: ƒ has<span class="hljs-constructor">OwnProperty()</span>,<br>        isPrototypeOf: ƒ is<span class="hljs-constructor">PrototypeOf()</span>,<br>        propertyIsEnumerable: ƒ property<span class="hljs-constructor">IsEnumerable()</span>,<br>        toLocaleString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>,<br>        toString: ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>,<br>        valueOf: ƒ value<span class="hljs-constructor">Of()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 <code>doSomething</code> 的实例。正确使用 new 运算符的方法就是在正常调用函数时，在函数名的前面加上一个 <code>new</code> 前缀。通过这种方法，在调用函数前加一个 <code>new</code> ，它就会返回一个这个函数的实例化对象。然后，就可以在这个对象上面添加一些属性。看。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>; <span class="hljs-comment">// add a property onto the prototype</span><br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>; <span class="hljs-comment">// add a property onto the object</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( doSomeInstancing );<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    prop:</span> <span class="hljs-string">&quot;some value&quot;</span>,<br><span class="hljs-symbol">    __proto__:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        foo:</span> <span class="hljs-string">&quot;bar&quot;</span>,<br><span class="hljs-symbol">        constructor:</span> ƒ doSomething(),<br><span class="hljs-symbol">        __proto__:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            constructor:</span> ƒ Object(),<br><span class="hljs-symbol">            hasOwnProperty:</span> ƒ hasOwnProperty(),<br><span class="hljs-symbol">            isPrototypeOf:</span> ƒ isPrototypeOf(),<br><span class="hljs-symbol">            propertyIsEnumerable:</span> ƒ propertyIsEnumerable(),<br><span class="hljs-symbol">            toLocaleString:</span> ƒ toLocaleString(),<br><span class="hljs-symbol">            toString:</span> ƒ toString(),<br><span class="hljs-symbol">            valueOf:</span> ƒ valueOf()<br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>就像上面看到的，<code>doSomeInstancing</code> 的 <code>__proto__</code> 属性就是<code>doSomething.prototype</code>. 但是这又有什么用呢？好吧，当你访问 <code>doSomeInstancing</code> 的一个属性，浏览器首先查找 <code>doSomeInstancing</code> 是否有这个属性。如果 <code>doSomeInstancing</code> 没有这个属性，然后浏览器就会在 <code>doSomeInstancing</code> 的 <code>__proto__</code> 中查找这个属性 (也就是 doSomething.prototype). 如果 doSomeInstancing 的 <code>__proto__</code> 有这个属性，那么 doSomeInstancing 的 <code>__proto__</code> 上的这个属性就会被使用。否则，如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性，浏览器就会去查找 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性。默认情况下，所有函数的原型属性的 <code>__proto__</code> 就是 <code>window.Object.prototype</code>. 所以 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> (也就是 doSomething.prototype 的 <code>__proto__</code> (也就是 <code>Object.prototype</code>)) 会被查找是否有这个属性。如果没有在它里面找到这个属性，然后就会在 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 里面查找。然而这有一个问题：doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 不存在。最后，原型链上面的所有的 <code>__proto__</code> 都被找完了，浏览器所有已经声明了的 <code>__proto__</code> 上都不存在这个属性，然后就得出结论，这个属性是 <code>undefined</code>.</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomeInstancing.prop:      &quot;</span> + doSomeInstancing.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomeInstancing.foo:       &quot;</span> + doSomeInstancing.foo);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prop:           &quot;</span> + doSomething.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.foo:            &quot;</span> + doSomething.foo);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prototype.prop: &quot;</span> + doSomething.prototype.prop);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;doSomething.prototype.foo:  &quot;</span> + doSomething.prototype.foo);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">doSomeInstancing<span class="hljs-selector-class">.prop</span>:      some value<br>doSomeInstancing<span class="hljs-selector-class">.foo</span>:       bar<br>doSomething<span class="hljs-selector-class">.prop</span>:           undefined<br>doSomething<span class="hljs-selector-class">.foo</span>:            undefined<br>doSomething<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.prop</span>: undefined<br>doSomething<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.foo</span>:  bar<br></code></pre></td></tr></table></figure><p><strong>create()</strong></p><p>我们曾经讲过如何用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create()</code></a> 方法创建新的对象实例。</p><ol><li><p>例如，在上个例子的 JavaScript 控制台中输入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var person2 <span class="hljs-operator">=</span> Object.create(person1)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>create()实际做的是从指定原型对象创建一个新的对象。这里以person1为原型对象创建了person2对象。在控制台输入：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">person2.<span class="hljs-emphasis">__proto__</span><br></code></pre></td></tr></table></figure></li></ol><p>结果返回对象<code>person1</code>。</p><h4 id="面向对象编程基本概念"><a href="#面向对象编程基本概念" class="headerlink" title="面向对象编程基本概念"></a>面向对象编程基本概念</h4><p>面向对象编程（OOP）是如今多种编程语言所实现的一种编程范式，包括 Java、C++。在本文中，我们会简要介绍面向对象编程（OOP）的基本概念，其中包括三个主要概念：<strong>类与实例</strong>、<strong>继承</strong>、<strong>封装</strong>。</p><p><strong>封装</strong></p><p>当其他部分的代码想要执行对象的某些操作时，可以借助对象向外部提供的接口完成操作，借此，对象保持了自身的内部状态不会被外部代码随意修改。也就是说，对象的内部状态保持了私有性，而外部代码只能通过对象所提供的接口访问和修改对象的内部状态，不能直接访问和修改对象的内部状态。保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为<strong>封装</strong>（encapsulation）。</p><p>封装的好处在于，当程序员需要修改一个对象的某个操作时，程序员只需要修改对象对应方法的内部实现即可，而不需要在所有代码中找出该方法的所有实现，并逐一修改。某种意义上来说，封装在对象内部和对象外部设立了一种特别的“防火墙”。</p><h3 id="3-6-异步javascript"><a href="#3-6-异步javascript" class="headerlink" title="3.6 异步javascript"></a>3.6 异步javascript</h3><p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p><p>浏览器提供的许多功能（尤其是最有趣的那一部分）可能需要很长的时间来完成，因此需要异步完成，例如：</p><ul><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 发起 HTTP 请求</li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia"><code>getUserMedia()</code></a> 访问用户的摄像头和麦克风</li><li>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker"><code>showOpenFilePicker()</code> (en-US)</a> 请求用户选择文件以供访问</li></ul><p>因此，即使你可能不需要经常<em>实现</em>自己的异步函数，你也很可能需要<em>正确使用</em>它们。</p><p>在这篇文章中，我们将从同步函数长时间运行时存在的问题开始，并以此进一步认识异步编程的必要性。</p><p>事件处理程序实际上就是异步编程的一种形式：你提供的函数（事件处理程序）将在事件发生时被调用（而不是立即被调用）。如果“事件”是“异步操作已经完成”，那么你就可以看到事件如何被用来通知调用者异步函数调用的结果的。</p><p>一些早期的异步 API 正是以这种方式来使用事件的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API 可以让你用 JavaScript 向远程服务器发起 HTTP 请求。由于这样的操作可能需要很长的时间，所以它被设计成异步 API，你可以通过给 <code>XMLHttpRequest</code> 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。</p><p>下面的例子展示了这样的操作。点击“点击发起请求”按钮来发送一个请求。我们将创建一个新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 并监听它的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadend_event"><code>loadend</code></a> 事件。而我们的事件处理程序则会在控制台中输出一个“完成！”的消息和请求的状态代码。</p><p>我们在添加了事件监听器后发送请求。注意，在这之后，我们仍然可以在控制台中输出“请求已发起”，也就是说，我们的程序可以在请求进行的同时继续运行，而我们的事件处理程序将在请求完成时被调用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xhr&quot;</span>&gt;</span>点击发起请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reload&quot;</span>&gt;</span>重载<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;event-log&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> log = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.event-log&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#xhr&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>  xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;loadend&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    log.<span class="hljs-property">textContent</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;log.textContent&#125;</span>完成！状态码：<span class="hljs-subst">$&#123;xhr.status&#125;</span>`</span>;<br>  &#125;);<br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json&#x27;</span>);<br>  xhr.<span class="hljs-title function_">send</span>();<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;log.textContent&#125;</span>请求已发起\n`</span>;&#125;);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  log.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="事件处理程序 sample" id="frame_事件处理程序" width="600" height="120" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing/_sample_.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>这就像我们在以前的模块中遇到的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件处理程序</a>，只是这次的事件不是像点击按钮那样的用户行为，而是某个对象的状态变化。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。正如我们刚刚所看到的：回调函数曾经是 JavaScript 中实现异步函数的主要方式。</p><p>然而，当回调函数本身需要调用其他同样接受回调函数的函数时，基于回调的代码会变得难以理解。当你需要执行一些分解成一系列异步函数的操作时，这将变得十分常见。例如下面这种情况：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">doStep1</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doStep2</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doStep3</span>(init) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">init</span> + <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">doOperation</span>() &#123;<br>  let result = 0;<br>  result = doStep1(result);<br>  result = doStep2(result);<br>  result = doStep3(result);<br>  console.log(`结果：$&#123;result&#125;`);<br>&#125;<br>doOperation();<br></code></pre></td></tr></table></figure><p>现在我们有一个被分成三步的操作，每一步都依赖于上一步。在这个例子中，第一步给输入的数据加 1，第二步加 2，第三步加 3。从输入 0 开始，最终结果是 6（0+1+2+3）。作为同步代码，这很容易理解。但是如果我们用回调来实现这些步骤呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep1</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">1</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep2</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">2</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doStep3</span>(<span class="hljs-params">init, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = init + <span class="hljs-number">3</span>;<br>  <span class="hljs-title function_">callback</span>(result);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doOperation</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">doStep1</span>(<span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-params">result1</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">doStep2</span>(result1, <span class="hljs-function"><span class="hljs-params">result2</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">doStep3</span>(result2, <span class="hljs-function"><span class="hljs-params">result3</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`结果：<span class="hljs-subst">$&#123;result3&#125;</span>`</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br><span class="hljs-title function_">doOperation</span>();<br></code></pre></td></tr></table></figure><p>因为必须在回调函数中调用回调函数，我们就得到了这个深度嵌套的 <code>doOperation()</code> 函数，这就更难阅读和调试了。在一些地方这被称为“回调地狱”或“厄运金字塔”（因为缩进看起来像一个金字塔的侧面）。</p><p>面对这样的嵌套回调，处理错误也会变得非常困难：你必须在“金字塔”的每一级处理错误，而不是在最高一级一次完成错误处理。</p><p>由于以上这些原因，大多数现代异步 API 都不使用回调。事实上，JavaScript 中异步编程的基础是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>，这也是我们下一篇文章要讲述的主题。</p><h4 id="如何使用promise"><a href="#如何使用promise" class="headerlink" title="如何使用promise"></a>如何使用promise</h4><p><strong>Promise</strong> 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。</p><h4 id="使用-fetch-API"><a href="#使用-fetch-API" class="headerlink" title="使用 fetch() API"></a>使用 fetch() API</h4><p>要做到这一点，我们将向服务器发出一个 <strong>HTTP 请求</strong>。在 HTTP 请求中，我们向远程服务器发送一个请求信息，然后它向我们发送一个响应。这次，我们将发送一个请求，从服务器上获得一个 JSON 文件。还记得在上一篇文章中，我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API 进行 HTTP 请求吗？那么，在这篇文章中，我们将使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> API，一个现代的、基于 Promise 的、用于替代 <code>XMLHttpRequest</code> 的方法。</p><p>把下列代码复制到你的浏览器 JavaScript 控制台中：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(fetchPromise);<br><br>fetchPromise.then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`已收到响应：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;已发送请求……&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们在这里：</p><ol><li>调用 <code>fetch()</code> API，并将返回值赋给 <code>fetchPromise</code> 变量。</li><li>紧接着，输出 <code>fetchPromise</code> 变量，输出结果应该像这样：<code>Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;</code>。这告诉我们有一个 <code>Promise</code> 对象，它有一个 <code>state</code>属性，值是 <code>&quot;pending&quot;</code>。<code>&quot;pending&quot;</code> 状态意味着操作仍在进行中。</li><li>将一个处理函数传递给 Promise 的 <strong><code>then()</code></strong> 方法。当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象。</li><li>输出一条信息，说明我们已经发送了这个请求。</li></ol><p>完整的输出结果应该是这样的：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span> &#123; &lt;state&gt;: <span class="hljs-string">&quot;pending&quot;</span> &#125;<br>已发送请求……<br>已收到响应：<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>请注意，<code>已发送请求……</code> 的消息在我们收到响应之前就被输出了。与同步函数不同，<code>fetch()</code> 在请求仍在进行时返回，这使我们的程序能够保持响应性。响应显示了 <code>200</code>（OK）的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">状态码</a>，意味着我们的请求成功了。</p><p>可能这看起来很像上一篇文章中的例子中我们把事件处理程序添加到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象中。但不同的是，我们这一次将处理程序传递到返回的 Promise 对象的 <code>then()</code> 方法中。</p><h4 id="链式使用-Promise"><a href="#链式使用-Promise" class="headerlink" title="链式使用 Promise"></a>链式使用 Promise</h4><p>在你通过 <code>fetch()</code> API 得到一个 <code>Response</code> 对象的时候，你需要调用另一个函数来获取响应数据。这次，我们想获得 JSON 格式的响应数据，所以我们会调用 <code>Response</code> 对象的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json"><code>json()</code></a> 方法。事实上，<code>json()</code> 也是异步的，因此我们必须连续调用两个异步函数。</p><p>试试这个：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise.then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  const jsonPromise = response.json();<br>  jsonPromise.then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，就像我们之前做的那样，我们给 <code>fetch()</code> 返回的 Promise 对象添加了一个 <code>then()</code> 处理程序。但这次我们的处理程序调用 <code>response.json()</code> 方法，然后将一个新的 <code>then()</code> 处理程序传递到 <code>response.json()</code> 返回的 Promise 中。</p><p>执行代码后应该会输出“baked beans”（“products.json”中第一个产品的名称）。</p><p>等等！还记得上一篇文章吗？我们好像说过，在回调中调用另一个回调会出现多层嵌套的情况？我们是不是还说过，这种“回调地狱”使我们的代码难以理解？这不是也一样吗，只不过变成了用 <code>then()</code> 调用而已？</p><p>当然如此。但 Promise 的优雅之处在于 <em><code>then()</code> 本身也会返回一个 Promise，这个 Promise 将指示 <code>then()</code> 中调用的异步函数的完成状态</em>。这意味着我们可以（当然也应该）把上面的代码改写成这样：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>不必在第一个 <code>then()</code> 的处理程序中调用第二个 <code>then()</code>，我们可以直接<em>返回</em> <code>json()</code> 返回的 Promise，并在该返回值上调用第二个 “then()”。这被称为 <strong>Promise 链</strong>，意味着当我们需要连续进行异步函数调用时，我们就可以避免不断嵌套带来的缩进增加。</p><p>在进入下一步之前，还有一件事要补充：我们需要在尝试读取请求之前检查服务器是否接受并处理了该请求。我们将通过检查响应中的状态码来做到这一点，如果状态码不是“OK”，就抛出一个错误：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.ok) &#123;<br>      throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">`HTTP error: <span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;);<br></code></pre></td></tr></table></figure><h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><p>这给我们带来了最后一个问题：我们如何处理错误？<code>fetch()</code> API 可能因为很多原因抛出错误（例如，没有网络连接或 URL 本身存在问题），我们也会在服务器返回错误消息时抛出一个错误。</p><p>在上一篇文章中，我们看到在嵌套回调中进行错误处理非常困难，我们需要在每一个嵌套层中单独捕获错误。</p><p><code>Promise</code> 对象提供了一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>catch()</code></a> 方法来支持错误处理。这很像 <code>then()</code>：你调用它并传入一个处理函数。然后，当异步操作<em>成功</em>时，传递给 <code>then()</code> 的处理函数被调用，而当异步操作<em>失败</em>时，传递给 <code>catch()</code> 的处理函数被调用。</p><p>如果将 <code>catch()</code> 添加到 Promise 链的末尾，它就可以在任何异步函数失败时被调用。于是，我们就可以将一个操作实现为几个连续的异步函数调用，并在一个地方处理所有错误。</p><p>试试这个版本的 <code>fetch()</code> 代码。我们使用 <code>catch()</code> 添加了一个错误处理函数，并修改了 URL（这样请求就会失败）。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise = fetch(<span class="hljs-string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><br>fetchPromise<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.ok) &#123;<br>      throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then( <span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(json[<span class="hljs-number">0</span>].name);<br>  &#125;)<br>  .catch( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>尝试运行这个版本：你应该会看到 <code>catch()</code> 处理函数输出的错误。</p><h4 id="Promise-术语"><a href="#Promise-术语" class="headerlink" title="Promise 术语"></a>Promise 术语</h4><p>Promise 中有一些具体的术语值得我们弄清楚。</p><p>首先，Promise 有三种状态：</p><ul><li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。这是调用 <code>fetch()</code> 返回 Promise 时的状态，此时请求还在进行中。</li><li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。当 Promise 完成时，它的 <code>then()</code> 处理函数被调用。</li><li><strong>已拒绝（rejected）</strong>：意味着操作失败。当一个 Promise 失败时，它的 <code>catch()</code> 处理函数被调用。</li></ul><p>注意，这里的“成功”或“失败”的含义取决于所使用的 API：例如，<code>fetch()</code> 认为服务器返回一个错误（如<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404">404 Not Found</a>）时请求成功，但如果网络错误阻止请求被发送，则认为请求失败。</p><p>有时我们用 <strong>已敲定（settled）</strong> 这个词来同时表示 <strong>已兑现（fulfilled）</strong> 和 <strong>已拒绝（rejected）</strong> 两种情况。</p><p>如果一个 Promise 处于已决议（resolved）状态，或者它被“锁定”以跟随另一个 Promise 的状态，那么它就是 <strong>已兑现（fulfilled）</strong>。</p><p>文章 <a href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/">Let’s talk about how to talk about promises</a> 对这些术语的细节做了很好的解释。</p><h4 id="合并使用多个-Promise"><a href="#合并使用多个-Promise" class="headerlink" title="合并使用多个 Promise"></a>合并使用多个 Promise</h4><p>当你的操作由几个异步函数组成，而且你需要在开始下一个函数之前完成之前每一个函数时，你需要的就是 Promise 链。但是在其他的一些情况下，你可能需要合并多个异步函数的调用，<code>Promise</code> API 为解决这一问题提供了帮助。</p><p>有时你需要所有的 Promise 都得到实现，但它们并不相互依赖。在这种情况下，将它们一起启动然后在它们全部被兑现后得到通知会更有效率。这里需要 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> 方法。它接收一个 Promise 数组，并返回一个单一的 Promise。</p><p>由<code>Promise.all()</code>返回的 Promise：</p><ul><li>当且仅当数组中<em>所有</em>的 Promise 都被兑现时，才会通知 <code>then()</code> 处理函数并提供一个包含所有响应的数组，数组中响应的顺序与被传入 <code>all()</code> 的 Promise 的顺序相同。</li><li>会被拒绝——如果数组中有<em>任何一个</em> Promise 被拒绝。此时，<code>catch()</code> 处理函数被调用，并提供被拒绝的 Promise 所抛出的错误。</li></ul><p>譬如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise3 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> response <span class="hljs-keyword">of</span> responses) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure><p>这里我们向三个不同的 URL 发出三个 <code>fetch()</code> 请求。如果它们都被兑现了，我们将输出每个请求的响应状态。如果其中任何一个被拒绝了，我们将输出失败的情况。</p><p>根据我们提供的 URL，应该所有的请求都会被兑现，尽管因为第二个请求中请求的文件不存在，服务器将返回 <code>404</code>（Not Found）而不是 <code>200</code>（OK）。所以输出应该是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/apis/</span>fetching-data<span class="hljs-regexp">/can-store/</span>products.json：<span class="hljs-number">200</span><br>https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/apis/</span>fetching-data<span class="hljs-regexp">/can-store/</span>not-found：<span class="hljs-number">404</span><br>https:<span class="hljs-regexp">//m</span>dn.github.io<span class="hljs-regexp">/learning-area/</span>javascript<span class="hljs-regexp">/oojs/</span>json/superheroes.json：<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>如果我们用一个错误编码的 URL 尝试同样的代码，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchPromise3 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> response <span class="hljs-keyword">of</span> responses) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure><p>……然后 <code>catch()</code> 处理程序将被运行，我们应该看到像这样的输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">获取失败：TypeError: Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">fetch</span><br></code></pre></td></tr></table></figure><p>有时，你可能需要等待一组 Promise 中的某一个 Promise 的执行，而不关心是哪一个。在这种情况下，你需要 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any()</code></a>。这就像 <code>Promise.all()</code>，不过在 Promise 数组中的任何一个被兑现时它就会被兑现，如果所有的 Promise 都被拒绝，它也会被拒绝。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchPromise1 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>const fetchPromise2 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);<br>const fetchPromise3 = fetch(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);<br><br>Promise.<span class="hljs-built_in">any</span>([fetchPromise1, fetchPromise2, fetchPromise3])<br>  .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>  &#125;)<br>  .catch( <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`获取失败：<span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>  &#125;);<br></code></pre></td></tr></table></figure><p>值得注意的是，在这种情况下，我们无法预测哪个获取请求会先被兑现。</p><p>这两个用于组合多个承诺的函数只是额外的 <code>Promise</code> 函数中的两个。要了解其余的内容，参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 参考文档。</p><h4 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code></a> 关键字为你提供了一种更简单的方法来处理基于异步 Promise 的代码。在一个函数的开头添加 <code>async</code>，就可以使其成为一个异步函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> function <span class="hljs-title">myFunction</span>()</span> &#123;<br>  <span class="hljs-comment">// 这是一个异步函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在异步函数中，你可以在调用一个返回 Promise 的函数之前使用 <code>await</code> 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p><p>这使你能够编写像同步代码一样的异步函数。例如，我们可以用它来重写我们的 fetch 示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span><br>    <span class="hljs-comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span><br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span><br>    <span class="hljs-comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span><br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchProducts</span>();<br></code></pre></td></tr></table></figure><p>这里我们调用 <code>await fetch()</code>，我们的调用者得到的并不是 <code>Promise</code>，而是一个完整的 <code>Response</code> 对象，就好像 <code>fetch()</code> 是一个同步函数一样。</p><p>我们甚至可以使用 <code>try...catch</code> 块来处理错误，就像我们在写同步代码时一样。</p><p>但请注意，这个写法只在异步函数中起作用。异步函数总是返回一个 Pomise，所以你不能做这样的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> json = <span class="hljs-title function_">fetchProducts</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);   <span class="hljs-comment">// json 是一个 Promise 对象，因此这句代码无法正常工作</span><br></code></pre></td></tr></table></figure><p>相反，你需要做一些事情，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchProducts</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 请求错误：<span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无法获取产品列表：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> jsonPromise = <span class="hljs-title function_">fetchProducts</span>();<br>jsonPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>));<br></code></pre></td></tr></table></figure><p>你可能会在需要使用 Promise 链地方使用 <code>async</code> 函数，这也使得 Promise 的工作更加直观。</p><p>请记住，就像一个 Promise 链一样，<code>await</code> 强制异步操作以串联的方式完成。如果下一个操作的结果取决于上一个操作的结果，这是必要的，但如果不是这样，像 <code>Promise.all()</code> 这样的操作会有更好的性能。</p><h3 id="3-7-实现基于Promise的API"><a href="#3-7-实现基于Promise的API" class="headerlink" title="3.7 实现基于Promise的API"></a>3.7 实现基于Promise的API</h3><p>通常情况下，当你实现一个基于 promise 的 API 时，你会使用事件、普通回调，或者消息传递模型来包裹一个异步操作。你将会使用一个 <code>Promise</code> 对象来合理的处理操作的成功或者失败。</p><h4 id="实现-alarm-API"><a href="#实现-alarm-API" class="headerlink" title="实现 alarm() API"></a>实现 alarm() API</h4><p>在这个示例中我们将会实现一个基于 promise 的 alarm API，叫做 <code>alarm()</code> 。它将以被唤醒人的名字和一个在人被唤醒前以毫秒为单位的延迟作为参数。在延迟之后，本函数将会发送一个包含需要被唤醒人名字的 “Wake up!” 消息。</p><h4 id="用-setTimeout-包裹"><a href="#用-setTimeout-包裹" class="headerlink" title="用 setTimeout() 包裹"></a>用 setTimeout() 包裹</h4><p>我们将会使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout"><code>setTimeout()</code></a> 来实现 <code>alarm()</code> 函数。<code>setTimeout()</code> 以一个回调函数和一个以毫秒为单位的延迟作为参数。当调用 <code>setTimeout()</code> 时，它将启动一个设置为给定延迟的计时器，当时间过期时，它就会调用给定的回调函数。</p><p>在下面的例子中，我们使用一个回调函数和一个 1000 毫秒的延迟调用 <code>setTimeout()</code>：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;button <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;set-alarm&quot;</span>&gt;Set alarm&lt;/button&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setAlarm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    output.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Wake up!&#x27;</span>;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, setAlarm);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="用 setTimeout() 包裹 sample" id="frame_用_settimeout_包裹" width="600" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E7%94%A8_settimeout_%E5%8C%85%E8%A3%B9.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h4 id="Promise-构造器"><a href="#Promise-构造器" class="headerlink" title="Promise() 构造器"></a>Promise() 构造器</h4><p>我们的 <code>alarm()</code> 函数返回一个在定时器过期时才会被兑现的 <code>Promise</code>。它将会传递一个 “Wake up!” 消息到 <code>then()</code> 处理器中，也会在当调用者提供一个负延迟值时拒绝这个 promise。</p><p>这里的关键组件是 <code>Promise()</code> 构造器。<code>Promise()</code> 构造器使用单个函数作为参数。我们把这个函数称作<code>执行器</code>（executor）。当你创建一个新的 promise 的时候你需要实现这个执行器。</p><p>这个执行器本身采用两个参数，这两个参数都是函数，通常被称作 <code>resolve</code> 和 <code>reject</code>。在你的执行器实现里，你调用原始的异步函数。如果异步函数成功了，就调用 <code>resolve</code>，如果失败了，就调用 <code>reject</code>。如果执行器函数抛出了一个错误，<code>reject</code> 会被自动调用。你可以将任何类型的单个参数传递到 <code>resolve</code> 和 <code>reject</code> 中。</p><p>所以我们可以像下面这样实现 <code>alarm()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数创建并且返回一个新的 <code>Promise</code>。对于执行器中的 promise，我们：</p><ul><li>检查 <code>delay</code>（延迟）是否为负数，如果是的话就抛出一个错误。</li><li>调用 <code>window.setTimeout()</code>，传递一个回调函数和 <code>delay</code>（延迟）。当计时器过期时回调会被调用，在回调函数内，我们调用了 <code>resolve</code>，并且传递了 <code>&quot;Wake up!&quot;</code> 消息。</li></ul><h4 id="使用-alarm-API"><a href="#使用-alarm-API" class="headerlink" title="使用 alarm() API"></a>使用 alarm() API</h4><p>这一部分同上一篇文章是相当相似的。我们可以调用 <code>alarm()</code>，在返回的 promise 中调用 <code>then()</code> 和 <code>catch()</code> 来设置 promise 兑现和拒绝状态的处理器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#name&#x27;</span>);<br><span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#delay&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">alarm</span>(name.<span class="hljs-property">value</span>, delay.<span class="hljs-property">value</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> output.<span class="hljs-property">textContent</span> = message)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> output.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Couldn&#x27;t set alarm: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="使用 alarm() API sample" id="frame_使用_alarm_api" width="600" height="160" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E4%BD%BF%E7%94%A8_alarm_api.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>尝试对 “Name” 和 “Delay” 设置不同的值。尝试为 “Delay” 设置一个负值。</p><h4 id="在-alarm-API-上使用-async-和-await"><a href="#在-alarm-API-上使用-async-和-await" class="headerlink" title="在 alarm() API 上使用 async 和 await"></a>在 alarm() API 上使用 async 和 await</h4><p>自从 <code>alarm()</code> 返回了一个 <code>Promise</code>，我们可以对它做任何我们可以对其他任何 promise 做的事情：<code>Promise.all()</code>，和 <code>async</code> &#x2F; <code>await</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#name&#x27;</span>);<br><span class="hljs-keyword">const</span> delay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#delay&#x27;</span>);<br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#set-alarm&#x27;</span>);<br><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">alarm</span>(<span class="hljs-params">person, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Alarm delay must not be negative&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Wake up, <span class="hljs-subst">$&#123;person&#125;</span>!`</span>);<br>    &#125;, delay);<br>  &#125;);<br>&#125;<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> message = <span class="hljs-keyword">await</span> <span class="hljs-title function_">alarm</span>(name.<span class="hljs-property">value</span>, delay.<span class="hljs-property">value</span>);<br>    output.<span class="hljs-property">textContent</span> = message;<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (error) &#123;<br>    output.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Couldn&#x27;t set alarm: <span class="hljs-subst">$&#123;error&#125;</span>`</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><iframe class="sample-code-frame" title="在 alarm() API 上使用 async 和 await sample" id="frame_在_alarm_api_上使用_async_和_await" width="600" height="160" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API/_sample_.%E5%9C%A8_alarm_api_%E4%B8%8A%E4%BD%BF%E7%94%A8_async_%E5%92%8C_await.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="3-8-workers简介"><a href="#3-8-workers简介" class="headerlink" title="3.8 workers简介"></a>3.8 workers简介</h3><p>在”异步 JavaScript” 模块的最后一篇文章中，我们将介绍 workers，它使您能够在单独执行 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Thread">线程</a> 中运行一些任务。</p><p>在本模块的第一篇文章中，我们看到了当在你的程序中具有一个长期运行的的同步任务时发生了什么 ── 整个窗口变得完全没有响应。从根本上讲，出现这种情况的原因是程序是单线程的。一个线程是程序遵循的一系列指令。因为程序由一个线程组成，它在同一时间只能做一件事情：所以如果它正在等待我们的长期运行的同步调用返回，它就不能做其他任何事情。</p><p>Workers 给了你在不同线程中运行某些任务的能力，因此你可以启动任务，然后继续其他的处理（例如处理用户操作）。</p><p>但是这是要付出代价的。对于多线程代码，你永远不知道你的线程什么时候将会被挂起，其他线程将会得到运行的机会。因此，如果两个线程都可以访问相同的变量，那么变量就有可能在任何时候发生意外的变化，这将导致很难发现的 Bug。</p><p>为了避免 Web 中的这些问题，你的主代码和你的 worker 代码永远不能直接访问彼此的变量。Workers 和主代码运行在完全分离的环境中，只有通过相互发送消息来进行交互。特别是，这意味着 workers 不能访问 DOM（窗口、文档、页面元素等等）。</p><p>有三种不同类型的 workers：</p><ul><li>dedicated workers</li><li>shared workers</li><li>service workers</li></ul><p>在本文中，我们将介绍第一类 workers 的一个例子，然后简要的讨论另外两类。</p><h4 id="使用-web-workers"><a href="#使用-web-workers" class="headerlink" title="使用 web workers"></a>使用 web workers</h4><p>还记得在第一篇文章中，我们有一个计算质数的页面吗？我们将使用一个 worker 来运行质数运算，因此我们的页面对用户操作保持响应。</p><h4 id="同步的质数生成器"><a href="#同步的质数生成器" class="headerlink" title="同步的质数生成器"></a>同步的质数生成器</h4><p>让我们先看一下我们上一个例子中的 JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePrimes</span>(<span class="hljs-params">quota</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">2</span>; c &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n); ++c) &#123;<br>      <span class="hljs-keyword">if</span> (n % c === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> primes = [];<br>  <span class="hljs-keyword">const</span> maximum = <span class="hljs-number">1000000</span>;<br><br>  <span class="hljs-keyword">while</span> (primes.<span class="hljs-property">length</span> &lt; quota) &#123;<br>    <span class="hljs-keyword">const</span> candidate = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (maximum + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(candidate)) &#123;<br>      primes.<span class="hljs-title function_">push</span>(candidate);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> primes;<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#generate&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> quota = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#quota&#x27;</span>).<span class="hljs-property">value</span>;<br>  <span class="hljs-keyword">const</span> primes = <span class="hljs-title function_">generatePrimes</span>(quota);<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">`Finished generating <span class="hljs-subst">$&#123;quota&#125;</span> primes!`</span>;<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#user-input&#x27;</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Try typing in here immediately after pressing &quot;Generate primes&quot;&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个程序中，在我们调用 <code>generatePrimes()</code> 之后，程序变得完全没有响应。</p><h4 id="用-worker-进行质数生成"><a href="#用-worker-进行质数生成" class="headerlink" title="用 worker 进行质数生成"></a>用 worker 进行质数生成</h4><p>在这个例子中，首先在 <a href="https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/start">https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/start</a> 将文件拷贝到本地。在这个目录下有四个文件：</p><ul><li>index.html</li><li>style.css</li><li>main.js</li><li>generate.js</li></ul><p>“index.html” 文件和 “style.css” 文件已完成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span><span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;quota&quot;</span>&gt;</span>Number of primes:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;quota&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;quota&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1000000&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;generate&quot;</span>&gt;</span>Generate primes<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reload&quot;</span>&gt;</span>Reload<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user-input&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;62&quot;</span>&gt;</span>Try typing in here immediately after pressing &quot;Generate primes&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>“main.js” 和 “generate.js” 文件是空的。我们将向 “main.js” 中添加主代码，向 “generate.js” 中添加 worker 代码。</p><p>首先，我们可以看到 worker 代码被保存在一个与主代码隔离的脚本中。我们还可以看到，在上面的 “index.html” 中，只有主代码被包含在 <code>&lt;script&gt;</code> 标签中。</p><p>现在将下面的代码拷贝到 “main.js”中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 在 &quot;generate.js&quot; 中创建一个新的 worker</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;./generate.js&#x27;</span>);<br><br><span class="hljs-comment">// 当用户点击 &quot;Generate primes&quot; 时，给 worker 发送一条消息。</span><br><span class="hljs-comment">// 消息中的 command 属性是 &quot;generate&quot;, 还包含另外一个属性 &quot;quota&quot;，即要生成的质数。</span><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#generate&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> quota = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#quota&#x27;</span>).value;<br>  worker.postMessage(&#123;<br>    command: <span class="hljs-string">&#x27;generate&#x27;</span>,<br>    quota: quota<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 当 worker 给主线程回发一条消息时，为用户更新 output 框，包含生成的质数（从 message 中获取）。</span><br>worker.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, message =&gt; &#123;<br>  <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#output&#x27;</span>).textContent = `Finished generating $&#123;message.data&#125; primes!`;<br>&#125;);<br><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#reload&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#user-input&#x27;</span>).value = <span class="hljs-string">&#x27;Try typing in here immediately after pressing &quot;Generate primes&quot;&#x27;</span>;<br>  <span class="hljs-built_in">document</span>.location.reload();<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>首先，我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker"><code>Worker()</code></a> 构造函数创建 worker。我们传递一个指向 worker 脚本的 URL。只要 worker 被创建了，woker 脚本就会执行。</li><li>其次，与同步版本一样，我们向 “Generate primes” 按钮添加一个click事件处理器。但是现在，我们不再调用generatePrimes()函数，而是使用<code>worker.postMessage()</code>向 worker 发送一条消息。这条消息可以携带一个参数，在本示例中我们传递一个包含两个属性的 JSON 对象：<ul><li><code>command</code>：一个用于标识我们希望 worker 所做事情的字符串（以防我们的 worker 可以做多个事情）。</li><li><code>quota</code>：要生成的质数的数量。</li></ul></li><li>然后，我们向 worker 添加一个 <code>message</code> 消息处理器。这样 worker 就能告诉我们它是什么时候完成的，并且传递给我们任何结果数据。我们的处理器从消息的 <code>data</code> 属性获取数据，然后将其写入 output 元素（数据与 <code>quota</code> 是完全相同的，这虽然没有意义，但是这展示了其中原理）。</li><li>最后，我们为 “Reload” 按钮实现了 <code>click</code> 事件处理器。这与同步版本完全相同。</li></ul><p>现在到 worker 代码了。拷贝下面的代码到 “generate.js” 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听主线程中的消息。</span><br><span class="hljs-comment">// 如果消息中的 command 是 &quot;generate&quot;，则调用 `generatePrimse()`</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (message.<span class="hljs-property">data</span>.<span class="hljs-property">command</span> === <span class="hljs-string">&#x27;generate&#x27;</span>) &#123;<br>    <span class="hljs-title function_">generatePrimes</span>(message.<span class="hljs-property">data</span>.<span class="hljs-property">quota</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 生成质数 (非常低效)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePrimes</span>(<span class="hljs-params">quota</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">2</span>; c &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(n); ++c) &#123;<br>      <span class="hljs-keyword">if</span> (n % c === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> primes = [];<br>  <span class="hljs-keyword">const</span> maximum = <span class="hljs-number">1000000</span>;<br><br>  <span class="hljs-keyword">while</span> (primes.<span class="hljs-property">length</span> &lt; quota) &#123;<br>    <span class="hljs-keyword">const</span> candidate = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (maximum + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(candidate)) &#123;<br>      primes.<span class="hljs-title function_">push</span>(candidate);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 完成后给主线程发送一条包含我们生成的质数数量的消息消息。</span><br>  <span class="hljs-title function_">postMessage</span>(primes.<span class="hljs-property">length</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>请记住，只要主脚本创建 worker，这些代码就会运行。</p><p>worker 要做的第一件事情就是开始监听来自主脚本的消息。这通过使用 <code>addEventListener()</code> 实现，它在 worker 中是一个全局函数。在 <code>message</code> 事件处理器内部，事件的 <code>data</code> 属性包含一个来自主脚本的参数的副本。如果主脚本传递 <code>generate</code> 命令，我们就调用 <code>generatePrimes()</code>，传入来自消息事件的 <code>quota</code> 值。</p><p><code>generatePrimes()</code> 函数与同步版本类似，只不过我们在完成后向主脚本发送一条消息，而不是返回一个值。我们对此使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/postMessage"><code>postMessage()</code> (en-US)</a> 函数，就像在 worker 中 <code>addEventListener</code>是全局函数一样。如我们所见，主脚本正在监听这条消息并且将会在收到消息后更新 DOM。</p><p><strong>备注：</strong> 要运行此站点，你必须运行一个本地 web 服务器，因为 file:&#x2F;&#x2F; URLs 不允许加载 workers。参考我们的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Tools_and_setup/set_up_a_local_testing_server">设置一个本地测试服务器</a>的指导。完成后，你应该可以点击 “Generate primes” 并且使你的主页面保持响应。 如果你在创建和运行这个样例的过程中有疑问，你可以在 <a href="https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished">https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/finished</a> 查看完成后的版本，并且在 <a href="https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished">https://mdn.github.io/learning-area/javascript/asynchronous/workers/finished</a> 进行在线尝试。</p><h4 id="其他类型的-worker"><a href="#其他类型的-worker" class="headerlink" title="其他类型的 worker"></a>其他类型的 worker</h4><p>我们刚刚创建的 worker 被称为 <em>dedicated worker</em>。这意味着它由一个脚本实例使用。</p><p>不过，还有其他类型的 worker：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker"><code>SharedWorker</code></a> 可以由运行在不同窗口中的多个不同脚本共享。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API"><em>Service worker</em></a> 的行为就像代理服务器，缓存资源以便于 web 应用程序可以在用户离线时工作。他们是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps">渐进式 Web 应用</a>的关键组件。</li></ul><h3 id="3-9-客户端web-api简介"><a href="#3-9-客户端web-api简介" class="headerlink" title="3.9 客户端web api简介"></a>3.9 客户端web api简介</h3><h4 id="API-可以做什么？"><a href="#API-可以做什么？" class="headerlink" title="API 可以做什么？"></a>API 可以做什么？</h4><p>在主流浏览器中有大量的可用 API，您可以在代码中做许多的事情，对此可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN API index page</a>。</p><h4 id="常见浏览器-API"><a href="#常见浏览器-API" class="headerlink" title="常见浏览器 API"></a>常见浏览器 API</h4><p>特别地，您将使用的最常见的浏览器 API 类别（以及我们将更详细地介绍的）是：</p><ul><li><strong>操作文档的 API</strong>内置于浏览器中。最明显的例子是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">DOM（文档对象模型）</a>API，它允许您操作 HTML 和 CSS — 创建、移除以及修改 HTML，动态地将新样式应用到您的页面，等等。每当您看到一个弹出窗口出现在一个页面上，或者显示一些新的内容时，这都是 DOM 的行为。您可以在在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents">Manipulating documents</a>中找到关于这些类型的 API 的更多信息。</li><li><strong>从服务器获取数据的 API</strong> 用于更新网页的一小部分是相当好用的。这个看似很小的细节能对网站的性能和行为产生巨大的影响 — 如果您只是更新一个股票列表或者一些可用的新故事而不需要从服务器重新加载整个页面将使网站或应用程序感觉更加敏感和“活泼”。使这成为可能的 API 包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a>。您也可能会遇到描述这种技术的术语<strong>Ajax</strong>。您可以在<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data">Fetching data from the server</a>找到关于类似的 API 的更多信息。</li><li><strong>用于绘制和操作图形的 API</strong>目前已被浏览器广泛支持 — 最流行的是允许您以编程方式更新包含在 HTML <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas"><code>canvas</code></a> 元素中的像素数据以创建 2D 和 3D 场景的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">Canvas</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API">WebGL</a>。例如，您可以绘制矩形或圆形等形状，将图像导入到画布上，然后使用 Canvas API 对其应用滤镜（如棕褐色滤镜或灰度滤镜），或使用 WebGL 创建具有光照和纹理的复杂 3D 场景。这些 API 经常与用于创建动画循环的 API（例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame"><code>window.requestAnimationFrame()</code></a>）和其他 API 一起不断更新诸如动画和游戏之类的场景。</li><li><strong>音频和视频 API</strong> 例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">Web Audio API</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API">WebRTC</a> 允许你使用多媒体来做一些非常有趣的事情，比如创建用于播放音频和视频的自定义 UI 控件，显示字幕字幕和你的视频，从网络摄像机抓取视频，通过画布操纵（见上），或在网络会议中显示在别人的电脑上，或者添加效果到音轨（如增益、失真、平移等） 。</li><li><strong>设备 API</strong>基本上是以对网络应用程序有用的方式操作和检索现代设备硬件中的数据的 API。我们已经讨论过访问设备位置数据的地理定位 API，因此您可以在地图上标注您的位置。其他示例还包括通过系统通知（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Notifications_API">Notifications API</a>）或振动硬件（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Vibration_API">Vibration API</a>）告诉用户 Web 应用程序有用的更新可用。</li><li><strong>客户端存储 API</strong>在 Web 浏览器中的使用变得越来越普遍 - 如果您想创建一个应用程序来保存页面加载之间的状态，甚至让设备在处于脱机状态时可用，那么在客户端存储数据将会是非常有用的。例如使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a>的简单的键 - 值存储以及使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>的更复杂的表格数据存储。</li></ul><h4 id="x3D-x3D-常见第三方-API-x3D-x3D"><a href="#x3D-x3D-常见第三方-API-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;常见第三方 API&#x3D;&#x3D;"></a>&#x3D;&#x3D;常见第三方 API&#x3D;&#x3D;</h4><p>第三方 API 种类繁多; 下列是一些比较流行的你可能迟早会用到的第三方 API:</p><ul><li>The <a href="https://dev.twitter.com/overview/documentation">Twitter API</a>, 允许您在您的网站上展示您最近的推文等。</li><li>The <a href="https://developers.google.com/maps/">Google Maps API</a> 允许你在网页上对地图进行很多操作（这很有趣，它也是 Google 地图的驱动器）。现在它是一整套完整的，能够胜任广泛任务的 API。其能力已经被<a href="https://developers.google.com/maps/documentation/api-picker">Google Maps API Picker</a>见证。</li><li>The <a href="https://developers.facebook.com/docs/">Facebook suite of API</a> 允许你将很多 Facebook 生态系统中的功能应用到你的 app，使之受益，比如说它提供了通过 Facebook 账户登录、接受应用内支付、推送有针对性的广告活动等功能。</li><li>The <a href="https://developers.google.com/youtube/">YouTube API</a>, 允许你将 Youtube 上的视频嵌入到网站中去，同时提供搜索 Youtube，创建播放列表等众多功能。</li><li>The <a href="https://www.twilio.com/">Twilio API</a>, 其为您的 app 提供了针对语音通话和视频聊天的框架，以及从您的 app 发送短信息或多媒体信息等诸多功能。</li></ul><p><strong>备注：</strong> 你可以在 <a href="http://www.programmableweb.com/category/all/apis">Programmable Web API directory</a>.上发现更多关于第三方 API 的信息。</p><h3 id="3-10-客户端存储"><a href="#3-10-客户端存储" class="headerlink" title="3.10 客户端存储"></a>3.10 客户端存储</h3><p>在其他的 MDN 学习中我们已经讨论过 静态网站（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/First_steps/Client-Server_overview#static_sites">static sites</a>）和动态网站（ <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/First_steps/Client-Server_overview#dynamic_sites">dynamic sites</a>）的区别。大多数现代的 web 站点是动态的— 它们在服务端使用各种类型的数据库来存储数据 (服务端存储), 之后通过运行服务端（ <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">server-side</a>）代码来重新获取需要的数据，把其数据插入到静态页面的模板中，并且生成出 HTML 渲染到用户浏览上。</p><p>客户端存储以相同的原理工作，但是在使用上有一些不同。它是由 JavaScript APIs 组成的因此允许你在客户端存储数据 (比如在用户的机器上)，而且可以在需要的时候重新取得需要的数据。这有很多明显的用处，比如：</p><ul><li>个性化网站偏好（比如显示一个用户选择的窗口小部件，颜色主题，或者字体）。</li><li>保存之前的站点行为 (比如从先前的 session 中获取购物车中的内容，记住用户是否之前已经登陆过)。</li><li>本地化保存数据和静态资源可以使一个站点更快（至少让资源变少）的下载，甚至可以在网络失去链接的时候变得暂时可用。</li><li>保存 web 已经生产的文档可以在离线状态下访问。</li></ul><p>通常客户端和服务端存储是结合在一起使用的。例如，你可以从数据库中下载一个由网络游戏或音乐播放器应用程序使用的音乐文件，将它们存储在客户端数据库中，并按需要播放它们。用户只需下载音乐文件一次——在随后的访问中，它们将从数据库中检索。</p><p><strong>备注：</strong> 使用客户端存储 API 可以存储的数据量是有限的（可能是每个 API 单独的和累积的总量）;具体的数量限制取决于浏览器，也可能基于用户设置。有关更多信息，获取更多信息，请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria">浏览器存储限制和清理标准</a>。</p><p>传统方法：cookies</p><p>客户端存储的概念已经存在很长一段时间了。从早期的网络时代开始，网站就使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">cookies</a> 来存储信息，以在网站上提供个性化的用户体验。它们是网络上最早最常用的客户端存储形式。 因为在那个年代，有许多问题——无论是从技术上的还是用户体验的角度——都是困扰着 cookies 的问题。这些问题非常重要，以至于当第一次访问一个网站时，欧洲居民会收到消息，告诉他们是否会使用 cookies 来存储关于他们的数据，而这是由一项被称为<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E6%AC%A7%E7%9B%9Fcookie%E6%8C%87%E4%BB%A4">欧盟 Cookie 条例</a>的欧盟法律导致的。</p><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/cookies-notice.png" alt="img"></p><p>由于这些原因，我们不会在本文中教你如何使用 cookie。毕竟它过时、存在各种<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%AE%89%E5%85%A8">安全问题</a>，而且无法存储复杂数据，而且有更好的、更现代的方法可以在用户的计算机上存储种类更广泛的数据。 cookie 的唯一优势是它们得到了非常旧的浏览器的支持，所以如果您的项目需要支持已经过时的浏览器（比如 Internet Explorer 8 或更早的浏览器），cookie 可能仍然有用，但是对于大多数项目（很明显不包括本站）来说，您不需要再使用它们了。其实 cookie 也没什么好说的，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie"><code>document.cookie</code></a>一把梭就完事了。</p><p><strong>备注：</strong> 为什么仍然有新创建的站点使用 cookies？这主要是因为开发人员的习惯，使用了仍然使用 cookies 的旧库，以及存在许多 web 站点，提供了过时的参考和培训材料来学习如何存储数据。</p><p>新流派：Web Storage 和 IndexedDB</p><p>现代浏览器有比使用 cookies 更简单、更有效的存储客户端数据的 API。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a> 提供了一种非常简单的语法，用于存储和检索较小的、由名称和相应值组成的数据项。当您只需要存储一些简单的数据时，比如用户的名字，用户是否登录，屏幕背景使用了什么颜色等等，这是非常有用的。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a> 为浏览器提供了一个完整的数据库系统来存储复杂的数据。这可以用于存储从完整的用户记录到甚至是复杂的数据类型，如音频或视频文件。</li></ul><p>您将在下面了解更多关于这些 API 的信息。</p><h4 id="未来：Cache-API"><a href="#未来：Cache-API" class="headerlink" title="未来：Cache API"></a>未来：Cache API</h4><p>一些现代浏览器支持新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a> API。这个 API 是为存储特定 HTTP 请求的响应文件而设计的，它对于像存储离线网站文件这样的事情非常有用，这样网站就可以在没有网络连接的情况下使用。缓存通常与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker API</a> 组合使用，尽管不一定非要这么做。 Cache 和 Service Workers 的使用是一个高级主题，我们不会在本文中详细讨论它，尽管我们将在下面的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage#%E7%A6%BB%E7%BA%BF%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8">离线文件存储</a> 一节中展示一个简单的例子。</p><h4 id="存储简单数据"><a href="#存储简单数据" class="headerlink" title="存储简单数据"></a>存储简单数据</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a> 非常容易使用 — 你只需存储简单的 键名&#x2F;键值 对数据 (限制为字符串、数字等类型) 并在需要的时候检索其值。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>让我们来告诉你怎么做：</p><ol><li><p>第一步，访问 GitHub 上的 <a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/index.html">web storage blank template</a> (在新标签页打开此<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/index.html">模板</a>)。</p></li><li><p>打开你浏览器开发者工具的 JavaScript 控制台。</p></li><li><p>你所有的 web storage 数据都包含在浏览器内两个类似于对象的结构中： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage"><code>localStorage</code></a>。第一种方法，只要浏览器开着，数据就会一直保存 (关闭浏览器时数据会丢失) ，而第二种会一直保存数据，甚至到浏览器关闭又开启后也是这样。我们将在本文中使用第二种方法，因为它通常更有用。</p></li><li><p><code>Storage.setItem()</code>方法允许您在存储中保存一个数据项——它接受两个参数：数据项的名字及其值。试着把它输入到你的 JavaScript 控制台（如果你愿意的话，可以把它的值改为你自己的名字！）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;Chris&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>Storage.getItem()</code>方法接受一个参数——你想要检索的数据项的名称——并返回数据项的值。现在将这些代码输入到你的 JavaScript 控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>在输入第二行时，您应该会看到myName变量现在包含name数据项的值。</p></li><li><p><code>Storage.removeItem()</code>方法接受一个参数——你想要删除的数据项的名称——并从 web storage 中删除该数据项。在您的 JavaScript 控制台中输入以下几行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>第三行现在应该返回null—name项已经不存在于 web storage 中。</p></li></ol><h4 id="数据会一直存在！"><a href="#数据会一直存在！" class="headerlink" title="数据会一直存在！"></a>数据会一直存在！</h4><p>web storage 的一个关键特性是，数据在不同页面加载时都存在（甚至是当浏览器关闭后，对 localStorage 的而言）。让我们来看看这个：</p><ol><li><p>再次打开我们的 Web Storage 空白模板，但是这次你要在不同的浏览器中打开这个教程！这样可以更容易处理。</p></li><li><p>在浏览器的 JavaScript 控制台中输入这几行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;Chris&#x27;</span>);<br><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>你应该看到 name 数据项返回。</p></li><li><p>现在关掉浏览器再把它打开。</p></li><li><p>再次输入下面几行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br>myName<br></code></pre></td></tr></table></figure><p>你应该看到，尽管浏览器已经关闭，然后再次打开，但仍然可以使用该值。</p></li></ol><h4 id="为每个域名分离储存"><a href="#为每个域名分离储存" class="headerlink" title="为每个域名分离储存"></a>为每个域名分离储存</h4><p>每个域都有一个单独的数据存储区 (每个单独的网址都在浏览器中加载). 你 会看到，如果你加载两个网站（例如 google.com 和 amazon.com）并尝试将某个项目存储在一个网站上，该数据项将无法从另一个网站获取。</p><p>这是有道理的 - 你可以想象如果网站能够查看彼此的数据，就会出现安全问题！</p><h4 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h4><p>让我们通过编写一个简单的工作示例来应用这些新发现的知识，让你了解如何使用网络存储。我们的示例将允许你输入一个名称，然后该页面将刷新，以提供个性化问候。这种状态也会页面&#x2F;浏览器重新加载期间保持，因为这个名称存储在 Web Storage 中。</p><p>你可以在 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/web-storage/personal-greeting.html">personal-greeting.html</a> 中找到示例文件 —— 这包含一个具有标题，内容和页脚，以及用于输入您的姓名的表单的简单网站。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/web-storage-demo.png" alt="img"></p><p>让我们来构建示例，以便了解它的工作原理。</p><ol><li><p>首先，在您的计算机上的新目录中创建一个 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/web-storage/personal-greeting.html">personal-greeting.html</a> 文件的副本。</p></li><li><p>接下来，请注意我们的 HTML 如何引用一个名为<code>index.js</code>的 JavaScript 文件（请参见第 40 行）。我们需要创建它并将 JavaScript 代码写入其中。在与 HTML 文件相同的目录中创建一个<code>index.js</code>文件。</p></li><li><p>我们首先创建对所有需要在此示例中操作的 HTML 功能的引用 - 我们将它们全部创建为常量，因为这些引用在应用程序的生命周期中不需要更改。将以下几行添加到你的 JavaScript 文件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 创建所需的常量</span><br><span class="hljs-keyword">const</span> rememberDiv = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.remember&#x27;</span>);<br><span class="hljs-keyword">const</span> forgetDiv = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.forget&#x27;</span>);<br><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br><span class="hljs-keyword">const</span> nameInput = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#entername&#x27;</span>);<br><span class="hljs-keyword">const</span> submitBtn = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#submitname&#x27;</span>);<br><span class="hljs-keyword">const</span> forgetBtn = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#forgetname&#x27;</span>);<br><br><span class="hljs-keyword">const</span> h1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);<br><span class="hljs-keyword">const</span> personalGreeting = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.personal-greeting&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>接下来，我们需要包含一个小小的事件监听器，以在按下提交按钮时阻止实际的提交表单动作自身，因为这不是我们想要的行为。在您之前的代码下添加此代码段：在你之前的代码后添加这段代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 当按钮按下时阻止表单提交</span><br>form.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">submit</span>&#x27;, <span class="hljs-params">function</span>(<span class="hljs-params">e</span>)</span> &#123;<br>  e.prevent<span class="hljs-constructor">Default()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>现在我们需要添加一个事件监听器，当单击“Say hello”按钮时，它的处理函数将会运行。这些注释详细解释了每一处都做了什么，但实际上我们在这里获取用户输入到文本输入框中的名字并使用setItem()将它保存在网络存储中，然后运行一个名为nameDisplayCheck()的函数来处理实际的网站文本的更新。将此添加到代码的底部：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// run function when the &#x27;Say hello&#x27; button is clicked</span><br>submitBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">function</span>()</span> &#123;<br>  <span class="hljs-comment">// store the entered name in web storage</span><br>  localStorage.set<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">name</span>&#x27;, <span class="hljs-params">nameInput</span>.<span class="hljs-params">value</span>)</span>;<br>  <span class="hljs-comment">// run nameDisplayCheck() to sort out displaying the</span><br>  <span class="hljs-comment">// personalized greetings and updating the form display</span><br>  name<span class="hljs-constructor">DisplayCheck()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>此时，我们还需要一个事件处理程序，以便在单击“Forget”按钮时运行一个函数——且仅在单击“Say hello”按钮（两种表单状态来回切换）后才显示。在这个功能中，我们使用</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">removeItem()</span><br></code></pre></td></tr></table></figure><p>从网络存储中删除项目</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">name</span><br></code></pre></td></tr></table></figure><p>，然后再次运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">nameDisplayCheck</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>以更新显示。将其添加到底部：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// run function when the &#x27;Forget&#x27; button is clicked</span><br>forgetBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">function</span>()</span> &#123;<br>  <span class="hljs-comment">// Remove the stored name from web storage</span><br>  localStorage.remove<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">name</span>&#x27;)</span>;<br>  <span class="hljs-comment">// run nameDisplayCheck() to sort out displaying the</span><br>  <span class="hljs-comment">// generic greeting again and updating the form display</span><br>  name<span class="hljs-constructor">DisplayCheck()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>现在是时候定义</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">nameDisplayCheck</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>函数本身了。在这里，我们通过使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure><p>作为测试条件来检查 name 数据项是否已经存储在 Web Storage 中。如果它已被存储，则该调用的返回值为true; 如果没有，它会是false。如果是true，我们会显示个性化问候语，显示表格的“forget”部分，并隐藏表格的“Say hello”部分。如果是false，我们会显示一个通用问候语，并做相反的事。再次将下面的代码添到底部：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> define the nameDisplayCheck() <span class="hljs-keyword">function</span><br><span class="hljs-keyword">function</span> nameDisplayCheck() &#123;<br>  <span class="hljs-regexp">//</span> check whether the <span class="hljs-string">&#x27;name&#x27;</span> data item is stored <span class="hljs-keyword">in</span> web Storage<br>  <span class="hljs-keyword">if</span>(localStorage.getItem(<span class="hljs-string">&#x27;name&#x27;</span>)) &#123;<br>    <span class="hljs-regexp">//</span> If it is, display personalized greeting<br>    let name = localStorage.getItem(<span class="hljs-string">&#x27;name&#x27;</span>);<br>    h1.textContent = <span class="hljs-string">&#x27;Welcome, &#x27;</span> + name;<br>    personalGreeting.textContent = <span class="hljs-string">&#x27;Welcome to our website, &#x27;</span> + name + <span class="hljs-string">&#x27;! We hope you have fun while you are here.&#x27;</span>;<br>    <span class="hljs-regexp">//</span> hide the <span class="hljs-string">&#x27;remember&#x27;</span> part of the form and show the <span class="hljs-string">&#x27;forget&#x27;</span> part<br>    forgetDiv.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>    rememberDiv.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> not, display generic greeting<br>    h1.textContent = <span class="hljs-string">&#x27;Welcome to our website &#x27;</span>;<br>    personalGreeting.textContent = <span class="hljs-string">&#x27;Welcome to our website. We hope you have fun while you are here.&#x27;</span>;<br>    <span class="hljs-regexp">//</span> hide the <span class="hljs-string">&#x27;forget&#x27;</span> part of the form and show the <span class="hljs-string">&#x27;remember&#x27;</span> part<br>    forgetDiv.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>    rememberDiv.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后但同样重要的是，我们需要在每次加载页面时运行nameDisplayCheck()函数。如果我们不这样做，那么个性化问候不会在页面重新加载后保持。将以下代码添加到代码的底部：document.body.onload &#x3D; nameDisplayCheck;</p></li></ol><p>你的例子完成了 - 做得好！现在剩下的就是保存你的代码并在浏览器中测试你的 HTML 页面。你可以在这里看到我们的<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/web-storage/personal-greeting.html">完成版本并在线运行</a>。</p><p><strong>备注：</strong> 在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">Using the Web Storage API</a> 中还有一个稍微复杂点儿的示例。</p><p><strong>备注：</strong> 在完成版本的源代码中， <code>&lt;script src=&quot;index.js&quot; defer&gt;&lt;/script&gt;</code> 一行里， <code>defer</code> 属性指明在页面加载完成之前，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script">&#96;&#96;</a>元素的内容不会执行。</p><h4 id="存储复杂数据"><a href="#存储复杂数据" class="headerlink" title="存储复杂数据"></a>存储复杂数据</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>（有时简称 IDB）是可以在浏览器中访问的一个完整的数据库系统，在这里，你可以存储复杂的关系数据。其种类不限于像字符串和数字这样的简单值。你可以在一个 IndexedDB 中存储视频，图像和许多其他的内容。</p><p>但是，这确实是有代价的：使用 IndexedDB 要比 Web Storage API 复杂得多。在本节中，我们仅仅只能浅尝辄止地一提它的能力，不过我们会给你足够基础知识以帮助你开始。</p><h4 id="通过一个笔记存储示例演示"><a href="#通过一个笔记存储示例演示" class="headerlink" title="通过一个笔记存储示例演示"></a>通过一个笔记存储示例演示</h4><p>在这里，我们将向您介绍一个示例，该示例允许您在浏览器中存储笔记并随时查看和删除它们，在我们进行时，我们将解释 IDB 的最基本部分并让您自己构建注释。</p><p>这个应用看起来像这样：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/idb-demo.png" alt="img"></p><p>每个笔记都有一个标题和一些正文，每个都可以单独编辑。我们将在下面通过的 JavaScript 代码提供详细的注释，以帮助您了解正在发生的事情。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>1、首先，将 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index.html"><code>index.html</code></a>, <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/style.css"><code>style.css</code></a>, 和 <a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index-start.js"><code>index-start.js</code></a> 文件的本地副本放入本地计算机上的新目录中。</p><p>2、浏览这些文件。您将看到 HTML 非常简单：具有页眉和页脚的网站，以及包含显示注释的位置的主内容区域，以及用于在数据库中输入新注释的表单。CSS 提供了一些简单的样式，使其更清晰。JavaScript 文件包含五个声明的常量，其中包含对将显示注释的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul">&#96;&#96;</a> 元素的引用，标题和正文 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input">&#96;&#96;</a> 元素，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">&#96;&#96;</a>本身，以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">&#96;&#96;</a>。</p><p>3、将您的 JavaScript 文件重命名为 <code>index.js</code> 。您现在可以开始向其添加代码了。</p><h4 id="数据库初始设置"><a href="#数据库初始设置" class="headerlink" title="数据库初始设置"></a>数据库初始设置</h4><p>现在让我们来看看为了建立数据库必须首先要做什么。</p><ol><li><p>在常量声明下，加入这几行：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">// Create an<span class="hljs-built_in"> instance </span>of a db object for us to store the open database in<br>let db;<br></code></pre></td></tr></table></figure><p>这里我们声明了一个叫db的变量 — 这将在之后被用来存储一个代表数据库的对象。我们将在几个地方使用它，所以我们为了方便使用而在这里把它声明为全局的。</p></li><li><p>接着，在你的代码最后添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们将把所有的后续代码写在这个window.onload事件处理函数内，这个函数将在 window 的<code>load</code>事件被触发时调用，为了确保我们没有在应用完整加载前试图使用 IndexedDB 功能（如果我们不这么做，它会失败）。</p></li><li><p>在window.onload处理程序内，添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Open our database; it is created if it doesn&#x27;t already exist</span><br><span class="hljs-comment">// (see onupgradeneeded below)</span><br><span class="hljs-keyword">let</span> request = <span class="hljs-variable language_">window</span>.<span class="hljs-property">indexedDB</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>此行创建一个request变量，目的是打开note数据库的1</p><p>版本。如果notes数据库不存在，则后续代码将为您创建。您将在 IndexedDB 中经常看到此请求模式。数据库操作需要时间。您不希望在等待结果时挂起浏览器，因此数据库操作是异步的，这意味着它们不会立即发生，而是在将来的某个时刻发生，并且在完成后会收到通知。 要在 IndexedDB 中处理此问题，您需要创建一个请求对象（可以随意命名 - 命名为request，可以表明它的用途）。然后，在请求完成或者失败时，使用事件处理程序来运行代码，您将在下面看到这些代码。</p><p><strong>备注：</strong> 版本号很重要。如果要升级数据库（例如：更改表结构），则必须使用增加的版本号或者<code>onupgradeneeded</code>处理程序内指定的不同模式（请参阅下文）等再次运行代码。在这个简单教程中，我们不讨论数据库升级。</p><ol><li><p>在之前添加的事件处理程序下方添加以下代码 - 在window.onload处理程序内：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// onerror handler signifies that the database didn&#x27;t open successfully</span><br>request.onerror = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Database failed to open&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// onsuccess handler signifies that the database opened successfully</span><br>request.onsuccess = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Database opened successfully&#x27;</span>);<br><br>  <span class="hljs-comment">// Store the opened database object in the db variable. This is used a lot below</span><br>  db = request.result;<br><br>  <span class="hljs-comment">// Run the displayData() function to display the notes already in the IDB</span><br>  displayData();<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果系统返回：请求失败，<code>request.onerror</code> (en-US)将会运行。这将允许你对这个问题做出响应。在我们的简单示例中，只是将消息打印到 JavaScript 控制台。 如果系统返回：请求成功，表明成功打开数据库，<code>request.onsuccess</code> (en-US)将会运行。如果是这种情况，则表示已打开数据库的对象在<code>request.result</code> (en-US)属性中变为可用，从而允许我们操作数据库。我们将它存储在db吗，我们之前创建的变量中供以后使用。我们还运行一个名为displayData()的自定义函数，它把数据库中的数据显示在元素 ( 或 HTML 无序列表元素）代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的。通常情况下，无序列表项的头部可以是几种形式，如一个点，一个圆形或方形。头部的风格并不是在页面的 HTML 描述定义，但在其相关的 CSS 可以用 list-style-type 属性。”&gt;<code>&lt;ul&gt;</code>。我们现在运行它，以便在页面加载时显示数据库中已有的注释。您将在稍后看到此定义。</p></li></ol></li><li><p>最后，对于本节，我们可能会添加最重要的事件处理程序来设置数据库：<code>request.onupgradeneeded</code> (en-US)。如果尚未设置数据库，或者使用比现有存储数据库更大的版本号打开数据库（执行升级时），则运行此处理程序。在上一个处理程序下面添加以下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Setup the database tables if this has not already been done</span><br>request.onupgradeneeded = <span class="hljs-keyword">function</span>(e) &#123;<br>  <span class="hljs-comment">// Grab a reference to the opened database</span><br>  <span class="hljs-keyword">let</span> db = e.target.result;<br><br>  <span class="hljs-comment">// Create an objectStore to store our notes in (basically like a single table)</span><br>  <span class="hljs-comment">// including a auto-incrementing key</span><br>  <span class="hljs-keyword">let</span> objectStore = db.create<span class="hljs-constructor">ObjectStore(&#x27;<span class="hljs-params">notes</span>&#x27;, &#123; <span class="hljs-params">keyPath</span>: &#x27;<span class="hljs-params">id</span>&#x27;, <span class="hljs-params">autoIncrement</span>:<span class="hljs-params">true</span> &#125;)</span>;<br><br>  <span class="hljs-comment">// Define what data items the objectStore will contain</span><br>  objectStore.create<span class="hljs-constructor">Index(&#x27;<span class="hljs-params">title</span>&#x27;, &#x27;<span class="hljs-params">title</span>&#x27;, &#123; <span class="hljs-params">unique</span>: <span class="hljs-params">false</span> &#125;)</span>;<br>  objectStore.create<span class="hljs-constructor">Index(&#x27;<span class="hljs-params">body</span>&#x27;, &#x27;<span class="hljs-params">body</span>&#x27;, &#123; <span class="hljs-params">unique</span>: <span class="hljs-params">false</span> &#125;)</span>;<br><br>  console.log(&#x27;Database setup complete&#x27;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是我们定义数据库的模式（结构）的地方; 也就是说，它包含的列（或字段）集。这里我们首先从e.target.result（事件目标的result属性）中获取对现有数据库的引用，该引用是request对象。这相当于处理程序db &#x3D; request.result;内部的行onsuccess，但我们需要在此单独执行此操作，因为onupgradeneeded处理程序（如果需要）将在onsuccess处理程序之前运行，这意味着db如果我们不这样做，该值将不可用。 然后<code>IDBDatabase.createObjectStore()</code>，我们使用在打开的数据库中创建一个新的对象库。这相当于传统数据库系统中的单个表。我们给它起了名称注释，并且还指定了一个autoIncrement名为的关键字段id在每个新记录中，这将自动赋予增量值 - 开发人员不需要明确地设置它。作为密钥，该id字段将用于唯一标识记录，例如删除或显示记录时。 我们还使用以下<code>IDBObjectStore.createIndex()</code> (en-US)方法创建另外两个索引（字段）:(title每个音符将包含一个标题），以及body（包含音符的正文）。</p></li></ol><p>因此，通过设置这个简单的数据库模式，当我们开始向数据库添加记录时，每个记录都会沿着这些行表示为一个对象：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  title:</span> <span class="hljs-string">&quot;Buy milk&quot;</span>,<br><span class="hljs-symbol">  body:</span> <span class="hljs-string">&quot;Need both cows milk and soya.&quot;</span>,<br><span class="hljs-symbol">  id:</span> <span class="hljs-number">8</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="添加数据到数据库"><a href="#添加数据到数据库" class="headerlink" title="添加数据到数据库"></a>添加数据到数据库</h4><p>现在让我们看一下如何将记录添加到数据库中。这将使用我们页面上的表单完成。</p><p>在您之前的事件处理程序下面（但仍在<code>window.onload</code>处理程序中），添加以下行，该行设置一个<code>onsubmit</code>处理程序，该处理程序运行<code>addData()</code>在提交表单时调用的函数（当 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方。”&gt;&#96;&#96;</a>按下提交时导致成功提交表单）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">Create</span> an onsubmit <span class="hljs-keyword">handler</span> so that <span class="hljs-keyword">when</span> the form <span class="hljs-keyword">is</span> submitted the addData() <span class="hljs-keyword">function</span> <span class="hljs-keyword">is</span> run<br>form.onsubmit = addData;<br></code></pre></td></tr></table></figure><p>现在让我们定义一下这个<code>addData()</code>功能。在上一行下面添加：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// Define the addData() function</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addData</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// prevent default - we don&#x27;t want the form to submit in the conventional way</span><br>  e.preventDefault();<br><br>  <span class="hljs-comment">// grab the values entered into the form fields and store them in an object ready for being inserted into the DB</span><br>  let newItem = &#123; <span class="hljs-attr">title</span>: titleInput.value, <span class="hljs-attr">body</span>: bodyInput.value &#125;;<br><br>  <span class="hljs-comment">// open a read/write db transaction, ready for adding the data</span><br>  let transaction = db.transaction([<span class="hljs-string">&#x27;notes&#x27;</span>], <span class="hljs-string">&#x27;readwrite&#x27;</span>);<br><br>  <span class="hljs-comment">// call an object store that&#x27;s already been added to the database</span><br>  let objectStore = transaction.objectStore(<span class="hljs-string">&#x27;notes&#x27;</span>);<br><br>  <span class="hljs-comment">// Make a request to add our newItem object to the object store</span><br>  <span class="hljs-keyword">var</span> request = objectStore.add(newItem);<br>  request.onsuccess = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// Clear the form, ready for adding the next entry</span><br>    titleInput.value = <span class="hljs-string">&#x27;&#x27;</span>;<br>    bodyInput.value = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// Report on the success of the transaction completing, when everything is done</span><br>  transaction.oncomplete = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Transaction completed: database modification finished.&#x27;</span>);<br><br>    <span class="hljs-comment">// update the display of data to show the newly added item, by running displayData() again.</span><br>    displayData();<br>  &#125;;<br><br>  transaction.onerror = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Transaction not opened due to error&#x27;</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这很复杂; 打破它，我们：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault"><code>Event.preventDefault()</code></a>在事件对象上运行以停止以传统方式实际提交的表单（这将导致页面刷新并破坏体验）。</li><li>创建一个表示要输入数据库的记录的对象，并使用表单输入中的值填充它。请注意，我们不必明确包含一个<code>id</code>值 - 正如我们提前详细说明的那样，这是自动填充的。</li><li>使用该方法打开对象存储的<code>readwrite</code>事务。此事务对象允许我们访问对象存储，以便我们可以对其执行某些操作，例如添加新记录。<code>notes</code><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction"><code>IDBDatabase.transaction()</code> (en-US)</a></li><li>使用该<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/objectStore"><code>IDBTransaction.objectStore()</code> (en-US)</a>方法访问对象库，将结果保存在 <code>objectStore</code> 变量中。</li><li>使用添加新记录到数据库<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBObjectStore/add"><code>IDBObjectStore.add()</code></a>。这创建了一个请求对象，与我们之前看到的方式相同。</li><li>在生命周期的关键点添加一堆事件处理程序<code>request</code>以及<code>transaction</code>运行代码。请求成功后，我们会清除表单输入，以便输入下一个注释。交易完成后，我们<code>displayData()</code>再次运行该功能以更新页面上的注释显示。</li></ul><h4 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h4><p>我们已经<code>displayData()</code>在代码中引用了两次，所以我们可能更好地定义它。将其添加到您的代码中，位于上一个函数定义之下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Define the displayData() function</span><br><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Data()</span> &#123;<br>  <span class="hljs-comment">// Here we empty the contents of the list element each time the display is updated</span><br>  <span class="hljs-comment">// If you ddn&#x27;t do this, you&#x27;d get duplicates listed each time a new note is added</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list</span>.firstChild) &#123;<br>    <span class="hljs-built_in">list</span>.remove<span class="hljs-constructor">Child(<span class="hljs-params">list</span>.<span class="hljs-params">firstChild</span>)</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Open our object store and then get a cursor - which iterates through all the</span><br>  <span class="hljs-comment">// different data items in the store</span><br>  <span class="hljs-keyword">let</span> objectStore = db.transaction(&#x27;notes&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">notes</span>&#x27;)</span>;<br>  objectStore.<span class="hljs-keyword">open</span><span class="hljs-constructor">Cursor()</span>.onsuccess = <span class="hljs-keyword">function</span>(e) &#123;<br>    <span class="hljs-comment">// Get a reference to the cursor</span><br>    <span class="hljs-keyword">let</span> cursor = e.target.result;<br><br>    <span class="hljs-comment">// If there is still another data item to iterate through, keep running this code</span><br>    <span class="hljs-keyword">if</span>(cursor) &#123;<br>      <span class="hljs-comment">// Create a list item, h3, and p to put each data item inside when displaying it</span><br>      <span class="hljs-comment">// structure the HTML fragment, and append it inside the list</span><br>      <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>      <span class="hljs-keyword">let</span> h3 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">h3</span>&#x27;)</span>;<br>      <span class="hljs-keyword">let</span> para = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">p</span>&#x27;)</span>;<br><br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">h3</span>)</span>;<br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">para</span>)</span>;<br>      <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br><br>      <span class="hljs-comment">// Put the data from the cursor inside the h3 and para</span><br>      h3.textContent = cursor.value.title;<br>      para.textContent = cursor.value.body;<br><br>      <span class="hljs-comment">// Store the ID of the data item inside an attribute on the listItem, so we know</span><br>      <span class="hljs-comment">// which item it corresponds to. This will be useful later when we want to delete items</span><br>      listItem.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">data</span>-<span class="hljs-params">note</span>-<span class="hljs-params">id</span>&#x27;, <span class="hljs-params">cursor</span>.<span class="hljs-params">value</span>.<span class="hljs-params">id</span>)</span>;<br><br>      <span class="hljs-comment">// Create a button and place it inside each listItem</span><br>      <span class="hljs-keyword">let</span> deleteBtn = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">button</span>&#x27;)</span>;<br>      listItem.append<span class="hljs-constructor">Child(<span class="hljs-params">deleteBtn</span>)</span>;<br>      deleteBtn.textContent = &#x27;Delete&#x27;;<br><br>      <span class="hljs-comment">// Set an event handler so that when the button is clicked, the deleteItem()</span><br>      <span class="hljs-comment">// function is run</span><br>      deleteBtn.onclick = deleteItem;<br><br>      <span class="hljs-comment">// Iterate to the next item in the cursor</span><br>      cursor.continue<span class="hljs-literal">()</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Again, if list item is empty, display a &#x27;No notes stored&#x27; message</span><br>      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>.firstChild) &#123;<br>        <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>        listItem.textContent = &#x27;No notes stored.&#x27;<br>        <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br>      &#125;<br>      <span class="hljs-comment">// if there are no more cursor items to iterate through, say so</span><br>      console.log(&#x27;Notes all displayed&#x27;);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次，让我们打破这个：</p><ul><li>首先，我们清空 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>ul</code></a> 元素的内容，然后填充更新的内容。如果您不这样做，那么每次更新时都会添加大量重复内容。</li><li>接下来，我们<code>notes</code>使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction"><code>IDBDatabase.transaction()</code> (en-US)</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/objectStore"><code>IDBTransaction.objectStore()</code> (en-US)</a>我们一样得到对象存储的引用<code>addData()</code>，除了这里我们将它们链接在一行中。</li><li>下一步是使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBObjectStore/openCursor"><code>IDBObjectStore.openCursor()</code></a>方法打开对游标的请求 - 这是一个可用于迭代对象存储中的记录的构造。我们将一个<code>onsuccess</code>处理程序链接到该行的末尾以使代码更简洁 - 当成功返回游标时，运行处理程序。</li><li>我们<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IDBCursor"><code>IDBCursor</code></a>使用 let 获取对游标本身（对象）的引用<code>cursor = e.target.result</code>。</li><li>接下来，我们检查光标是否包含来自数据存储区（<code>if(cursor)&#123; ... &#125;</code>）的记录 - 如果是这样，我们创建一个 DOM 片段，用记录中的数据填充它，然后将其插入页面（<code>&lt;ul&gt;</code>元素内部）。我们还包括一个删除按钮，当单击该按钮时，将通过运行该<code>deleteItem()</code>功能删除该注释，我们将在下一节中查看。</li><li>在<code>if</code>块结束时，我们使用该<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/continue"><code>IDBCursor.continue()</code> (en-US)</a>方法将光标前进到数据存储区中的下一条记录，然后<code>if</code>再次运行块的内容。如果有另一个要迭代的记录，这会导致它被插入到页面中，然后<code>continue()</code>再次运行，依此类推。</li><li>当没有更多记录要迭代时，<code>cursor</code>将返回<code>undefined</code>，因此<code>else</code>块将运行而不是<code>if</code>块。此块检查是否有任何注释被插入<code>&lt;ul&gt;</code>- 如果没有，它会插入一条消息，说没有存储注释。</li></ul><h4 id="删除一条笔记"><a href="#删除一条笔记" class="headerlink" title="删除一条笔记"></a>删除一条笔记</h4><p>如上所述，当按下笔记的删除按钮时，笔记将被删除。这是通过<code>deleteItem()</code>函数实现的，如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Define the deleteItem() function</span><br><span class="hljs-keyword">function</span> delete<span class="hljs-constructor">Item(<span class="hljs-params">e</span>)</span> &#123;<br>  <span class="hljs-comment">// retrieve the name of the task we want to delete. We need</span><br>  <span class="hljs-comment">// to convert it to a number before trying it use it with IDB; IDB key</span><br>  <span class="hljs-comment">// values are type-sensitive.</span><br>  <span class="hljs-keyword">let</span> noteId = <span class="hljs-constructor">Number(<span class="hljs-params">e</span>.<span class="hljs-params">target</span>.<span class="hljs-params">parentNode</span>.<span class="hljs-params">getAttribute</span>(&#x27;<span class="hljs-params">data</span>-<span class="hljs-params">note</span>-<span class="hljs-params">id</span>&#x27;)</span>);<br><br>  <span class="hljs-comment">// open a database transaction and delete the task, finding it using the id we retrieved above</span><br>  <span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-literal">[&#x27;<span class="hljs-identifier">notes</span>&#x27;]</span>, &#x27;readwrite&#x27;);<br>  <span class="hljs-keyword">let</span> objectStore = transaction.<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">notes</span>&#x27;)</span>;<br>  <span class="hljs-keyword">let</span> request = objectStore.delete(noteId);<br><br>  <span class="hljs-comment">// report that the data item has been deleted</span><br>  transaction.oncomplete = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-comment">// delete the parent of the button</span><br>    <span class="hljs-comment">// which is the list item, so it is no longer displayed</span><br>    e.target.parentNode.parentNode.remove<span class="hljs-constructor">Child(<span class="hljs-params">e</span>.<span class="hljs-params">target</span>.<span class="hljs-params">parentNode</span>)</span>;<br>    console.log(&#x27;Note &#x27; + noteId + &#x27; deleted.&#x27;);<br><br>    <span class="hljs-comment">// Again, if list item is empty, display a &#x27;No notes stored&#x27; message</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list</span>.firstChild) &#123;<br>      <span class="hljs-keyword">let</span> listItem = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">li</span>&#x27;)</span>;<br>      listItem.textContent = &#x27;No notes stored.&#x27;;<br>      <span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">listItem</span>)</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一部分可以使用一些解释 - 我们检索要删除<code>Number(e.target.parentNode.getAttribute(&#39;data-note-id&#39;))</code>的记录的 ID - 回想一下记录的 ID 是在第一次显示时保存在<code>data-note-id</code>属性中的<code>&lt;li&gt;</code>。但是，我们需要通过全局内置的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number">Number（）</a>对象传递属性，因为它当前是一个字符串，否则将无法被数据库识别。</li><li>然后，我们使用我们之前看到的相同模式获取对对象存储的引用，并使用该<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete"><code>IDBObjectStore.delete()</code> (en-US)</a>方法从数据库中删除记录，并将 ID 传递给它。</li><li>当数据库事务完成后，我们<code>&lt;li&gt;</code>从 DOM 中删除注释，然后再次检查以查看它是否<code>&lt;ul&gt;</code>为空，并根据需要插入注释。</li></ul><p>就是这样了！你的例子现在应该有效。</p><p>如果您遇到问题，请随时<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/indexeddb/notes/">查看我们的实例</a>（请参阅<a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/indexeddb/notes/index.js">源代码</a>）。</p><h4 id="通过-IndexedDB-存储复杂数据"><a href="#通过-IndexedDB-存储复杂数据" class="headerlink" title="通过 IndexedDB 存储复杂数据"></a>通过 IndexedDB 存储复杂数据</h4><p>如上所述，IndexedDB 可用于存储不仅仅是简单的文本字符串。您可以存储任何您想要的东西，包括复杂的对象，如视频或图像 blob。并且它比任何其他类型的数据更难实现。</p><p>为了演示如何操作，我们编写了另一个名为<a href="https://github.com/mdn/learning-area/tree/master/javascript/apis/client-side-storage/indexeddb/video-store">IndexedDB 视频存储的</a>示例（请参阅<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/indexeddb/video-store/">此处也可以在此处运行</a>）。首次运行示例时，它会从网络下载所有视频，将它们存储在 IndexedDB 数据库中，然后在 UI 内部 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">&#96;&#96;</a> 元素中显示视频。第二次运行它时，它会在数据库中找到视频并从那里获取它们而不是显示它们 - 这使得后续加载更快，占用空间更少。</p><p>让我们来看看这个例子中最有趣的部分。我们不会全部看 - 它的很多内容与上一个示例类似，代码注释得很好。</p><ol><li><p>对于这个简单的例子，我们已经存储了视频的名称以获取数组 opf 对象：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const videos</span> = [<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;crystal&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;elf&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;frog&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;monster&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;pig&#x27;</span> &#125;,<br>  &#123; <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;rabbit&#x27;</span> &#125;<br>];<br></code></pre></td></tr></table></figure></li><li><p>首先，一旦数据库成功打开，我们就运行一个init()函数。这会遍历不同的视频名称，尝试加载由videos数据库中的每个名称标识的记录。 如果在数据库中找到每个视频（通过查看request.result评估是否容易检查true- 如果记录不存在，那么undefined），视频文件（存储为 blob）和视频名称将直接传递给displayVideo()函数以放置它们在用户界面中。如果没有，视频名称将传递给fetchVideoFromNetwork()函数…你猜对了 - 从网络中获取视频。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> init<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-comment">// Loop through the video names one by one</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; videos.length; i++) &#123;<br>    <span class="hljs-comment">// Open transaction, get object store, and get() each video by name</span><br>    <span class="hljs-keyword">let</span> objectStore = db.transaction(&#x27;videos&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">videos</span>&#x27;)</span>;<br>    <span class="hljs-keyword">let</span> request = objectStore.get(videos<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.name);<br>    request.onsuccess = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>      <span class="hljs-comment">// If the result exists in the database (is not undefined)</span><br>      <span class="hljs-keyword">if</span>(request.result) &#123;<br>        <span class="hljs-comment">// Grab the videos from IDB and display them using displayVideo()</span><br>        console.log(&#x27;taking videos from IDB&#x27;);<br>        display<span class="hljs-constructor">Video(<span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">mp4</span>, <span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">webm</span>, <span class="hljs-params">request</span>.<span class="hljs-params">result</span>.<span class="hljs-params">name</span>)</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Fetch the videos from the network</span><br>        fetch<span class="hljs-constructor">VideoFromNetwork(<span class="hljs-params">videos</span>[<span class="hljs-params">i</span>])</span>;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>以下片段是从内部fetchVideoFromNetwork()获取的 - 这里我们使用两个单独<code>fetch()</code>请求获取视频的 MP4 和 WebM 版本。然后，我们使用该<code>Body.blob()</code>方法将每个响应的主体提取为 blob，为我们提供可以在以后存储和显示的视频的对象表示。 我们在这里遇到了一个问题 - 这两个请求都是异步的，但我们只想在两个 promises 都满足时尝试显示或存储视频。幸运的是，有一种处理这种问题的内置方法 -<code>Promise.all()</code>。这需要一个参数 - 引用您要检查放置在数组中的履行的所有单个承诺 - 并且本身是基于承诺的。 当所有这些承诺都履行完毕时，all()承诺将通过包含所有个人履行价值的数组来实现。在all()块中，您可以看到我们displayVideo()之前调用函数，就像在 UI 中显示视频一样，然后我们也调用storeVideo()函数将这些视频存储在数据库中。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let mp4Blob = <span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;videos/&#x27;</span> + video.name + <span class="hljs-string">&#x27;.mp4&#x27;</span>).<span class="hljs-keyword">then</span>(response =&gt;<br>  response.blob()<br>);<br>let webmBlob = <span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;videos/&#x27;</span> + video.name + <span class="hljs-string">&#x27;.webm&#x27;</span>).<span class="hljs-keyword">then</span>(response =&gt;<br>  response.blob()<br>);;<br><br>// <span class="hljs-keyword">Only</span> run the next code <span class="hljs-keyword">when</span> <span class="hljs-keyword">both</span> promises have fulfilled<br>Promise.<span class="hljs-keyword">all</span>([mp4Blob, webmBlob]).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-keyword">values</span>) &#123;<br>  // display the video fetched <span class="hljs-keyword">from</span> the network <span class="hljs-keyword">with</span> displayVideo()<br>  displayVideo(<span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">values</span>[<span class="hljs-number">1</span>], video.name);<br>  // store it <span class="hljs-keyword">in</span> the IDB <span class="hljs-keyword">using</span> storeVideo()<br>  storeVideo(<span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">values</span>[<span class="hljs-number">1</span>], video.name);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>我们storeVideo()先来看看吧。这与您在上一个示例中看到的用于向数据库添加数据的模式非常相似 - 我们打开一个readwrite事务并获取对象存储引用videos，创建一个表示要添加到数据库的记录的对象，然后使用它添加它<code>IDBObjectStore.add()</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> store<span class="hljs-constructor">Video(<span class="hljs-params">mp4Blob</span>, <span class="hljs-params">webmBlob</span>, <span class="hljs-params">name</span>)</span> &#123;<br>  <span class="hljs-comment">// Open transaction, get object store; make it a readwrite so we can write to the IDB</span><br>  <span class="hljs-keyword">let</span> objectStore = db.transaction(<span class="hljs-literal">[&#x27;<span class="hljs-identifier">videos</span>&#x27;]</span>, &#x27;readwrite&#x27;).<span class="hljs-keyword">object</span><span class="hljs-constructor">Store(&#x27;<span class="hljs-params">videos</span>&#x27;)</span>;<br>  <span class="hljs-comment">// Create a record to add to the IDB</span><br>  <span class="hljs-keyword">let</span> record = &#123;<br>    mp4 : mp4Blob,<br>    webm : webmBlob,<br>    name : name<br>  &#125;<br><br>  <span class="hljs-comment">// Add the record to the IDB using add()</span><br>  <span class="hljs-keyword">let</span> request = objectStore.add(record);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>最后但并非最不重要的是，我们displayVideo()创建了在 UI 中插入视频然后将它们附加到页面所需的 DOM 元素。最有趣的部分如下所示 - 要在<video>元素中实际显示我们的视频 blob，我们需要使用该<code>URL.createObjectURL()</code>方法创建对象 URL（指向存储在内存中的视频 blob 的内部 URL）。完成后，我们可以将对象 URL 设置为<code>&lt;source&gt;</code>元素src属性的值，并且它可以正常工作。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> display<span class="hljs-constructor">Video(<span class="hljs-params">mp4Blob</span>, <span class="hljs-params">webmBlob</span>, <span class="hljs-params">title</span>)</span> &#123;<br>  <span class="hljs-comment">// Create object URLs out of the blobs</span><br>  <span class="hljs-keyword">let</span> mp4URL = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>create<span class="hljs-constructor">ObjectURL(<span class="hljs-params">mp4Blob</span>)</span>;<br>  <span class="hljs-keyword">let</span> webmURL = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>create<span class="hljs-constructor">ObjectURL(<span class="hljs-params">webmBlob</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  </span><span class="hljs-keyword">let</span> video = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">video</span>&#x27;)</span>;<br>  video.controls = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">let</span> source1 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">source</span>&#x27;)</span>;<br>  source1.src = mp4URL;<br>  source1.<span class="hljs-keyword">type</span> = &#x27;video/mp4&#x27;;<br>  <span class="hljs-keyword">let</span> source2 = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">source</span>&#x27;)</span>;<br>  source2.src = webmURL;<br>  source2.<span class="hljs-keyword">type</span> = &#x27;video/webm&#x27;;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="离线文件存储"><a href="#离线文件存储" class="headerlink" title="离线文件存储"></a>离线文件存储</h4><p>上面的示例已经说明了如何创建一个将大型资产存储在 IndexedDB 数据库中的应用程序，从而无需多次下载它们。这已经是对用户体验的一个很大的改进，但仍然有一件事 - 每次访问网站时仍然需要下载主要的 HTML，CSS 和 JavaScript 文件，这意味着当没有网络连接时，它将无法工作。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage/ff-offline.png" alt="img"></p><p>这就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">服务工作者</a>和密切相关的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache">Cache API 的</a>用武之地。</p><p>服务工作者是一个 JavaScript 文件，简单地说，它是在浏览器访问时针对特定来源（网站或某个域的网站的一部分）进行注册的。注册后，它可以控制该来源的可用页面。它通过坐在加载的页面和网络之间以及拦截针对该来源的网络请求来实现这一点。</p><p>当它拦截一个请求时，它可以做任何你想做的事情（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API#other_use_case_ideas">用例思路</a>），但经典的例子是离线保存网络响应，然后提供响应请求而不是来自网络的响应。实际上，它允许您使网站完全脱机工作。</p><p>Cache API 是另一种客户端存储机制，略有不同 - 它旨在保存 HTTP 响应，因此与服务工作者一起工作得非常好。</p><p><strong>备注：</strong> 现在大多数现代浏览器都支持服务工作者和缓存。在撰写本文时，Safari 仍在忙着实施它，但它应该很快就会存在。</p><h4 id="一个-service-worker-例子"><a href="#一个-service-worker-例子" class="headerlink" title="一个 service worker 例子"></a>一个 service worker 例子</h4><p>让我们看一个例子，让你对这可能是什么样子有所了解。我们已经创建了另一个版本的视频存储示例，我们在上一节中看到了 - 这个功能完全相同，只是它还通过服务工作者将 Cache，CSS 和 JavaScript 保存在 Cache API 中，允许示例脱机运行！</p><p>请参阅<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/">IndexedDB 视频存储，其中服务工作者正在运行</a>，并且还可以<a href="https://github.com/mdn/learning-area/tree/master/javascript/apis/client-side-storage/cache-sw/video-store-offline">查看源代码</a>。</p><h4 id="注册服务工作者"><a href="#注册服务工作者" class="headerlink" title="注册服务工作者"></a>注册服务工作者</h4><p>首先要注意的是，在主 JavaScript 文件中放置了一些额外的代码（请参阅<a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.js">index.js</a>）。首先，我们进行特征检测测试，以查看<code>serviceWorker</code>该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator"><code>Navigator</code></a>对象中是否有该成员。如果返回 true，那么我们知道至少支持服务工作者的基础知识。在这里，我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register"><code>ServiceWorkerContainer.register()</code></a>方法将<code>sw.js</code>文件中包含的服务工作者注册到它所驻留的源，因此它可以控制与它或子目录相同的目录中的页面。当其承诺履行时，服务人员被视为已注册。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// Register service worker to control making site work offline</span><br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;serviceWorker&#x27;</span> in navigator) &#123;<br>  navigator.serviceWorker<br>           .register(<span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js&#x27;</span>)<br>           .then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Service Worker Registered&#x27;</span>); &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备注：</strong> <code>sw.js</code>文件的给定路径是相对于站点源的，而不是包含代码的 JavaScript 文件。服务人员在<code>https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js</code>。原点是<code>https://mdn.github.io</code>，因此给定的路径必须是<code>/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js</code>。如果您想在自己的服务器上托管此示例，则必须相应地更改此示例。这是相当令人困惑的，但出于安全原因，它必须以这种方式工作。</p><h4 id="安装-service-worker"><a href="#安装-service-worker" class="headerlink" title="安装 service worker"></a>安装 service worker</h4><p>下次访问服务工作者控制下的任何页面时（例如，重新加载示例时），将针对该页面安装服务工作者，这意味着它将开始控制它。发生这种情况时，<code>install</code>会向服务工作人员发起一个事件; 您可以在服务工作者本身内编写代码来响应安装。</p><p>让我们看一下<a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js">sw.js</a>文件（服务工作者）中的一个例子。您将看到安装侦听器已注册<code>self</code>。此<code>self</code>关键字是一种从服务工作文件内部引用服务工作者的全局范围的方法。</p><p>在<code>install</code> 处理程序内部，我们使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent/waitUntil"><code>ExtendableEvent.waitUntil()</code></a>事件对象上可用的方法来表示浏览器不应该完成服务工作者的安装，直到其中的 promise 成功完成。</p><p>这是我们在运行中看到 Cache API 的地方。我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/open"><code>CacheStorage.open()</code></a>方法打开一个可以存储响应的新缓存对象（类似于 IndexedDB 对象存储）。此承诺通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a>表示<code>video-store</code>缓存的对象来实现。然后，我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/addAll"><code>Cache.addAll()</code></a>方法获取一系列资产并将其响应添加到缓存中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.addEventListener(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span> &#123;<br> e.waitUntil(<br>   caches.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;video-store&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cache)</span></span> &#123;<br>     <span class="hljs-keyword">return</span> cache.addAll([<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.html&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/index.js&#x27;</span>,<br>       <span class="hljs-string">&#x27;/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/style.css&#x27;</span><br>     ]);<br>   &#125;)<br> );<br>&#125;);<br></code></pre></td></tr></table></figure><p>这就是现在，安装完成。</p><h4 id="响应未来的请求"><a href="#响应未来的请求" class="headerlink" title="响应未来的请求"></a>响应未来的请求</h4><p>在我们的 HTML 页面上注册并安装了服务工作者，并且所有相关资产都添加到我们的缓存中，我们几乎准备好了。还有一件事要做，写一些代码来响应进一步的网络请求。</p><p>这就是第二位代码的<code>sw.js</code>作用。我们向服务工作者全局范围添加另一个侦听器，该范围在<code>fetch</code>引发事件时运行处理函数。只要浏览器在服务工作者注册的目录中请求资产，就会发生这种情况。</p><p>在处理程序内部，我们首先记录所请求资产的 URL。然后，我们使用该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith"><code>FetchEvent.respondWith()</code></a>方法为请求提供自定义响应。</p><p>在这个块中，我们<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/match"><code>CacheStorage.match()</code></a>用来检查是否可以在任何缓存中找到匹配的请求（即匹配 URL）。如果未找到匹配，或者<code>undefined</code>如果未找到匹配，则此承诺将满足匹配的响应。</p><p>如果找到匹配项，我们只需将其作为自定义响应返回。如果没有，我们从网络中<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">获取（）</a>响应并返回该响应。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.addEventListener(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(e.request.url);<br>  e.respondWith(<br>    caches.<span class="hljs-built_in">match</span>(e.request).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response)</span></span> &#123;<br>      <span class="hljs-keyword">return</span> response || fetch(e.request);<br>    &#125;)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>这就是我们简单的服务工作者。您可以使用它们进行更多的负载 - 有关详细信息，请参阅<a href="https://github.com/mdn/serviceworker-cookbook/">服务工作者手册</a>。感谢 Paul Kinlan 在他的文章中<a href="https://developers.google.com/web/fundamentals/codelabs/offline/">添加服务工作者和离线到您的 Web 应用程序</a>，这启发了这个简单的例子。</p><h4 id="测试离线示例"><a href="#测试离线示例" class="headerlink" title="测试离线示例"></a>测试离线示例</h4><p>要测试我们的<a href="https://mdn.github.io/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/">服务工作者示例</a>，您需要加载它几次以确保它已安装。完成后，您可以：</p><ul><li>尝试拔掉网络连接&#x2F;关闭 Wifi。</li><li>如果您使用的是 Firefox，请选择<em>文件&gt;脱机工作</em>。</li><li>转到 devtools，然后选择<em>Application&gt; Service Workers</em>，如果您使用的是 Chrome，请选中<em>Offline</em>选中。</li></ul><p>如果再次刷新示例页面，您仍应该看到它加载得很好。所有内容都是脱机存储的 - 缓存中的页面资源以及 IndexedDB 数据库中的视频。</p><h1 id="that’s-it"><a href="#that’s-it" class="headerlink" title="that’s it"></a>that’s it</h1>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>党课</title>
    <link href="/blog/2022/11/20/%E5%85%9A%E8%AF%BE/"/>
    <url>/blog/2022/11/20/%E5%85%9A%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="党章"><a href="#党章" class="headerlink" title="党章"></a>党章</h1><p>2022.11.28</p><h2 id="x3D-x3D-总-纲-x3D-x3D"><a href="#x3D-x3D-总-纲-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;总　纲&#x3D;&#x3D;"></a>&#x3D;&#x3D;总　纲&#x3D;&#x3D;</h2><p>　　中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队，是中国特色社会主义事业的领导核心，代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益。党的最高理想和最终目标是实现共产主义。</p><p>　　中国共产党以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想作为自己的行动指南。</p><p>　　马克思列宁主义揭示了人类社会历史发展的规律，它的基本原理是正确的，具有强大的生命力。中国共产党人追求的共产主义最高理想，只有在社会主义社会充分发展和高度发达的基础上才能实现。社会主义制度的发展和完善是一个长期的历史过程。坚持马克思列宁主义的基本原理，走中国人民自愿选择的适合中国国情的道路，中国的社会主义事业必将取得最终的胜利。</p><p>　　以毛泽东同志为主要代表的中国共产党人，把马克思列宁主义的基本原理同中国革命的具体实践结合起来，创立了毛泽东思想。毛泽东思想是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶。在毛泽东思想指引下，中国共产党领导全国各族人民，经过长期的反对帝国主义、封建主义、官僚资本主义的革命斗争，取得了新民主主义革命的胜利，建立了人民民主专政的中华人民共和国；新中国成立以后，顺利地进行了社会主义改造，完成了从新民主主义到社会主义的过渡，确立了社会主义基本制度，发展了社会主义的经济、政治和文化。</p><p>　　十一届三中全会以来，以邓小平同志为主要代表的中国共产党人，总结新中国成立以来正反两方面的经验，解放思想，实事求是，实现全党工作中心向经济建设的转移，实行改革开放，开辟了社会主义事业发展的新时期，逐步形成了建设中国特色社会主义的路线、方针、政策，阐明了在中国建设社会主义、巩固和发展社会主义的基本问题，创立了邓小平理论。邓小平理论是马克思列宁主义的基本原理同当代中国实践和时代特征相结合的产物，是毛泽东思想在新的历史条件下的继承和发展，是马克思主义在中国发展的新阶段，是当代中国的马克思主义，是中国共产党集体智慧的结晶，引导着我国社会主义现代化事业不断前进。</p><p>　　十三届四中全会以来，以江泽民同志为主要代表的中国共产党人，在建设中国特色社会主义的实践中，加深了对什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党的认识，积累了治党治国新的宝贵经验，形成了“三个代表”重要思想。“三个代表”重要思想是对马克思列宁主义、毛泽东思想、邓小平理论的继承和发展，反映了当代世界和中国的发展变化对党和国家工作的新要求，是加强和改进党的建设、推进我国社会主义自我完善和发展的强大理论武器，是中国共产党集体智慧的结晶，是党必须长期坚持的指导思想。始终做到“三个代表”，是我们党的立党之本、执政之基、力量之源。</p><p>　　十六大以来，以胡锦涛同志为主要代表的中国共产党人，坚持以邓小平理论和“三个代表”重要思想为指导，根据新的发展要求，深刻认识和回答了新形势下实现什么样的发展、怎样发展等重大问题，形成了以人为本、全面协调可持续发展的科学发展观。科学发展观是同马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想既一脉相承又与时俱进的科学理论，是马克思主义关于发展的世界观和方法论的集中体现，是马克思主义中国化重大成果，是中国共产党集体智慧的结晶，是发展中国特色社会主义必须长期坚持的指导思想。</p><p>　　十八大以来，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，科学回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义等重大时代课题，创立了习近平新时代中国特色社会主义思想。习近平新时代中国特色社会主义思想是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华，是党和人民实践经验和集体智慧的结晶，是中国特色社会主义理论体系的重要组成部分，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南，必须长期坚持并不断发展。在习近平新时代中国特色社会主义思想指导下，中国共产党领导全国各族人民，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，推动中国特色社会主义进入了新时代，实现第一个百年奋斗目标，开启了实现第二个百年奋斗目标新征程。</p><p>　　改革开放以来我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系，确立了中国特色社会主义制度，发展了中国特色社会主义文化。全党同志要倍加珍惜、长期坚持和不断发展党历经艰辛开创的这条道路、这个理论体系、这个制度、这个文化，高举中国特色社会主义伟大旗帜，坚定道路自信、理论自信、制度自信、文化自信，发扬斗争精神，增强斗争本领，贯彻党的基本理论、基本路线、基本方略，为实现推进现代化建设、完成祖国统一、维护世界和平与促进共同发展这三大历史任务，实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦而奋斗。</p><p>　　中国共产党自成立以来，始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心使命，历经百年奋斗，从根本上改变了中国人民的前途命运，开辟了实现中华民族伟大复兴的正确道路，展示了马克思主义的强大生命力，深刻影响了世界历史进程，锻造了走在时代前列的中国共产党。经过长期实践，积累了坚持党的领导、坚持人民至上、坚持理论创新、坚持独立自主、坚持中国道路、坚持胸怀天下、坚持开拓创新、坚持敢于斗争、坚持统一战线、坚持自我革命的宝贵历史经验，这是党和人民共同创造的精神财富，必须倍加珍惜、长期坚持，并在实践中不断丰富和发展。</p><p>　　我国正处于并将长期处于社会主义初级阶段。这是在原本经济文化落后的中国建设社会主义现代化不可逾越的历史阶段，需要上百年的时间。我国的社会主义建设，必须从我国的国情出发，走中国特色社会主义道路，以中国式现代化全面推进中华民族伟大复兴。在现阶段，我国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。由于国内的因素和国际的影响，阶级斗争还在一定范围内长期存在，在某种条件下还有可能激化，但已经不是主要矛盾。我国社会主义建设的根本任务，是进一步解放生产力，发展生产力，逐步实现社会主义现代化，并且为此而改革生产关系和上层建筑中不适应生产力发展的方面和环节。必须坚持和完善公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等基本经济制度，鼓励一部分地区和一部分人先富起来，逐步实现全体人民共同富裕，在生产发展和社会财富增长的基础上不断满足人民日益增长的美好生活需要，促进人的全面发展。发展是我们党执政兴国的第一要务。必须坚持以人民为中心的发展思想，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展。各项工作都要把有利于发展社会主义社会的生产力，有利于增强社会主义国家的综合国力，有利于提高人民的生活水平，作为总的出发点和检验标准，尊重劳动、尊重知识、尊重人才、尊重创造，做到发展为了人民、发展依靠人民、发展成果由人民共享。必须按照中国特色社会主义事业“五位一体”总体布局和“四个全面”战略布局，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设，协调推进全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党。新时代新征程，经济和社会发展的战略目标是，到二〇三五年基本实现社会主义现代化，到本世纪中叶把我国建成社会主义现代化强国。</p><p>　　中国共产党在社会主义初级阶段的基本路线是：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p><p>　　中国共产党在领导社会主义事业中，必须坚持以经济建设为中心，其他各项工作都服从和服务于这个中心。要实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战略、区域协调发展战略、可持续发展战略、军民融合发展战略，充分发挥科学技术作为第一生产力的作用，充分发挥人才作为第一资源的作用，充分发挥创新作为引领发展第一动力的作用，依靠科技进步，提高劳动者素质，促进国民经济更高质量、更有效率、更加公平、更可持续、更为安全发展。</p><p>　　坚持社会主义道路、坚持人民民主专政、坚持中国共产党的领导、坚持马克思列宁主义毛泽东思想这四项基本原则，是我们的立国之本。在社会主义现代化建设的整个过程中，必须坚持四项基本原则，反对资产阶级自由化。</p><p>　　坚持改革开放，是我们的强国之路。只有改革开放，才能发展中国、发展社会主义、发展马克思主义。要全面深化改革，完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化。要从根本上改革束缚生产力发展的经济体制，坚持和完善社会主义市场经济体制；与此相适应，要进行政治体制改革和其他领域的改革。要坚持对外开放的基本国策，吸收和借鉴人类社会创造的一切文明成果。改革开放应当大胆探索，勇于开拓，提高改革决策的科学性，更加注重改革的系统性、整体性、协同性，在实践中开创新路。</p><p>　　中国共产党领导人民发展社会主义市场经济。毫不动摇地巩固和发展公有制经济，毫不动摇地鼓励、支持、引导非公有制经济发展。发挥市场在资源配置中的决定性作用，更好发挥政府作用，建立完善的宏观调控体系。统筹城乡发展、区域发展、经济社会发展、人与自然和谐发展、国内发展和对外开放，调整经济结构，转变经济发展方式，推进供给侧结构性改革。促进新型工业化、信息化、城镇化、农业现代化同步发展，建设社会主义新农村，走中国特色新型工业化道路，建设创新型国家和世界科技强国。</p><p>　　中国共产党领导人民发展社会主义民主政治。坚持党的领导、人民当家作主、依法治国有机统一，走中国特色社会主义政治发展道路、中国特色社会主义法治道路，扩大社会主义民主，建设中国特色社会主义法治体系，建设社会主义法治国家，巩固人民民主专政，建设社会主义政治文明。坚持和完善人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度。发展更加广泛、更加充分、更加健全的全过程人民民主，推进协商民主广泛多层制度化发展，切实保障人民管理国家事务和社会事务、管理经济和文化事业的权利。尊重和保障人权。广开言路，建立健全民主选举、民主协商、民主决策、民主管理、民主监督的制度和程序。完善中国特色社会主义法律体系，加强法律实施工作，实现国家各项工作法治化。</p><p>　　中国共产党领导人民发展社会主义先进文化。建设社会主义精神文明，实行依法治国和以德治国相结合，提高全民族的思想道德素质和科学文化素质，为改革开放和社会主义现代化建设提供强大的思想保证、精神动力和智力支持，建设社会主义文化强国。加强社会主义核心价值体系建设，坚持马克思主义指导思想，树立中国特色社会主义共同理想，弘扬以爱国主义为核心的民族精神和以改革创新为核心的时代精神，培育和践行社会主义核心价值观，倡导社会主义荣辱观，增强民族自尊、自信和自强精神，抵御资本主义和封建主义腐朽思想的侵蚀，扫除各种社会丑恶现象，努力使我国人民成为有理想、有道德、有文化、有纪律的人民。对党员要进行共产主义远大理想教育。大力发展教育、科学、文化事业，推动中华优秀传统文化创造性转化、创新性发展，继承革命文化，发展社会主义先进文化，提高国家文化软实力。牢牢掌握意识形态工作领导权，不断巩固马克思主义在意识形态领域的指导地位，巩固全党全国人民团结奋斗的共同思想基础。</p><p>　　中国共产党领导人民构建社会主义和谐社会。按照民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处的总要求和共同建设、共同享有的原则，以保障和改善民生为重点，解决好人民最关心、最直接、最现实的利益问题，使发展成果更多更公平惠及全体人民，不断增强人民群众获得感，努力形成全体人民各尽其能、各得其所而又和谐相处的局面。加强和创新社会治理。严格区分和正确处理敌我矛盾和人民内部矛盾这两类不同性质的矛盾。加强社会治安综合治理，依法坚决打击各种危害国家安全和利益、危害社会稳定和经济发展的犯罪活动和犯罪分子，保持社会长期稳定。坚持总体国家安全观，统筹发展和安全，坚决维护国家主权、安全、发展利益。</p><p>　　中国共产党领导人民建设社会主义生态文明。树立尊重自然、顺应自然、保护自然的生态文明理念，增强绿水青山就是金山银山的意识，坚持节约资源和保护环境的基本国策，坚持节约优先、保护优先、自然恢复为主的方针，坚持生产发展、生活富裕、生态良好的文明发展道路。着力建设资源节约型、环境友好型社会，实行最严格的生态环境保护制度，形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式，为人民创造良好生产生活环境，实现中华民族永续发展。</p><p>　　中国共产党坚持对人民解放军和其他人民武装力量的绝对领导，贯彻习近平强军思想，加强人民解放军的建设，坚持政治建军、改革强军、科技强军、人才强军、依法治军，建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队，切实保证人民解放军有效履行新时代军队使命任务，充分发挥人民解放军在巩固国防、保卫祖国和参加社会主义现代化建设中的作用。</p><p>　　中国共产党维护和发展平等团结互助和谐的社会主义民族关系，积极培养、选拔少数民族干部，帮助少数民族和民族地区发展经济、文化和社会事业，铸牢中华民族共同体意识，实现各民族共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，团结信教群众为经济社会发展作贡献。</p><p>　　中国共产党同全国各民族工人、农民、知识分子团结在一起，同各民主党派、无党派人士、各民族的爱国力量团结在一起，进一步发展和壮大由全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者组成的最广泛的爱国统一战线。不断加强全国人民包括香港特别行政区同胞、澳门特别行政区同胞、台湾同胞和海外侨胞的团结。全面准确、坚定不移贯彻“一个国家、两种制度”的方针，促进香港、澳门长期繁荣稳定，坚决反对和遏制“台独”，完成祖国统一大业。</p><p>　　中国共产党坚持独立自主的和平外交政策，坚持和平发展道路，坚持互利共赢的开放战略，统筹国内国际两个大局，积极发展对外关系，努力为我国的改革开放和现代化建设争取有利的国际环境。在国际事务中，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持正确义利观，维护我国的独立和主权，反对霸权主义和强权政治，维护世界和平，促进人类进步，推动构建人类命运共同体，推动建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。在互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处五项原则的基础上，发展我国同世界各国的关系。不断发展我国同周边国家的睦邻友好关系，加强同发展中国家的团结与合作。遵循共商共建共享原则，推进“一带一路”建设。按照独立自主、完全平等、互相尊重、互不干涉内部事务的原则，发展我党同各国共产党和其他政党的关系。</p><p>　　中国共产党要领导全国各族人民实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦，必须紧密围绕党的基本路线，坚持和加强党的全面领导，坚持党要管党、全面从严治党，弘扬坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，加强党的长期执政能力建设、先进性和纯洁性建设，以改革创新精神全面推进党的建设新的伟大工程，以党的政治建设为统领，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，全面提高党的建设科学化水平，以伟大自我革命引领伟大社会革命。坚持立党为公、执政为民，发扬党的优良传统和作风，不断提高党的领导水平和执政水平，提高拒腐防变和抵御风险的能力，不断增强自我净化、自我完善、自我革新、自我提高能力，不断增强党的阶级基础和扩大党的群众基础，不断提高党的创造力、凝聚力、战斗力，建设学习型、服务型、创新型的马克思主义执政党，使我们党始终走在时代前列，成为领导全国人民沿着中国特色社会主义道路不断前进的坚强核心。党的建设必须坚决实现以下六项基本要求：</p><p>　　第一，坚持党的基本路线。全党要用邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想和党的基本路线统一思想，统一行动，并且毫不动摇地长期坚持下去。必须把改革开放同四项基本原则统一起来，全面落实党的基本路线，反对一切“左”的和右的错误倾向，要警惕右，但主要是防止“左”。必须提高政治判断力、政治领悟力、政治执行力，增强贯彻落实党的理论和路线方针政策的自觉性和坚定性。</p><p>　　第二，坚持解放思想，实事求是，与时俱进，求真务实。党的思想路线是一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理。全党必须坚持这条思想路线，积极探索，大胆试验，开拓创新，创造性地开展工作，不断研究新情况，总结新经验，解决新问题，在实践中丰富和发展马克思主义，推进马克思主义中国化时代化。</p><p>　　第三，坚持新时代党的组织路线。全面贯彻习近平新时代中国特色社会主义思想，以组织体系建设为重点，着力培养忠诚干净担当的高素质干部，着力集聚爱国奉献的各方面优秀人才，坚持德才兼备、以德为先、任人唯贤，为坚持和加强党的全面领导、坚持和发展中国特色社会主义提供坚强组织保证。全党必须增强党组织的政治功能和组织功能，培养选拔党和人民需要的好干部，培养和造就大批堪当时代重任的社会主义事业接班人，聚天下英才而用之，从组织上保证党的基本理论、基本路线、基本方略的贯彻落实。</p><p>　　第四，坚持全心全意为人民服务。党除了工人阶级和最广大人民群众的利益，没有自己特殊的利益。党在任何时候都把群众利益放在第一位，同群众同甘共苦，保持最密切的联系，坚持权为民所用、情为民所系、利为民所谋，不允许任何党员脱离群众，凌驾于群众之上。我们党的最大政治优势是密切联系群众，党执政后的最大危险是脱离群众。党风问题、党同人民群众联系问题是关系党生死存亡的问题。党在自己的工作中实行群众路线，一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p><p>　　第五，坚持民主集中制。民主集中制是民主基础上的集中和集中指导下的民主相结合。它既是党的根本组织原则，也是群众路线在党的生活中的运用。必须充分发扬党内民主，尊重党员主体地位，保障党员民主权利，发挥各级党组织和广大党员的积极性创造性。必须实行正确的集中，牢固树立政治意识、大局意识、核心意识、看齐意识，坚定维护以习近平同志为核心的党中央权威和集中统一领导，保证全党的团结统一和行动一致，保证党的决定得到迅速有效的贯彻执行。加强和规范党内政治生活，增强党内政治生活的政治性、时代性、原则性、战斗性，发展积极健康的党内政治文化，营造风清气正的良好政治生态。党在自己的政治生活中正确地开展批评和自我批评，在原则问题上进行思想斗争，坚持真理，修正错误。努力造成又有集中又有民主，又有纪律又有自由，又有统一意志又有个人心情舒畅生动活泼的政治局面。</p><p>　　第六，坚持从严管党治党。全面从严治党永远在路上，党的自我革命永远在路上。新形势下，党面临的执政考验、改革开放考验、市场经济考验、外部环境考验是长期的、复杂的、严峻的，精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险更加尖锐地摆在全党面前。要把严的标准、严的措施贯穿于管党治党全过程和各方面。坚持依规治党、标本兼治，不断健全党内法规体系，坚持把纪律挺在前面，加强组织性纪律性，在党的纪律面前人人平等。强化全面从严治党主体责任和监督责任，加强对党的领导机关和党员领导干部特别是主要领导干部的监督，不断完善党内监督体系。深入推进党风廉政建设和反腐败斗争，以零容忍态度惩治腐败，一体推进不敢腐、不能腐、不想腐。</p><p>　　中国共产党的领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，党是最高政治领导力量。党政军民学，东西南北中，党是领导一切的。党要适应改革开放和社会主义现代化建设的要求，坚持科学执政、民主执政、依法执政，加强和改善党的领导。党必须按照总揽全局、协调各方的原则，在同级各种组织中发挥领导核心作用。党必须集中精力领导经济建设，组织、协调各方面的力量，同心协力，围绕经济建设开展工作，促进经济社会全面发展。党必须实行民主的科学的决策，制定和执行正确的路线、方针、政策，做好党的组织工作和宣传教育工作，发挥全体党员的先锋模范作用。党必须在宪法和法律的范围内活动。党必须保证国家的立法、司法、行政、监察机关，经济、文化组织和人民团体积极主动地、独立负责地、协调一致地工作。党必须加强对工会、共产主义青年团、妇女联合会等群团组织的领导，使它们保持和增强政治性、先进性、群众性，充分发挥作用。党必须适应形势的发展和情况的变化，完善领导体制，改进领导方式，增强执政能力。共产党员必须同党外群众亲密合作，共同为建设中国特色社会主义而奋斗。</p><h2 id="x3D-x3D-第一章-党-员-x3D-x3D"><a href="#x3D-x3D-第一章-党-员-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第一章　党　员&#x3D;&#x3D;"></a>&#x3D;&#x3D;第一章　党　员&#x3D;&#x3D;</h2><p>　　第一条　年满十八岁的中国工人、农民、军人、知识分子和其他社会阶层的先进分子，承认党的纲领和章程，愿意参加党的一个组织并在其中积极工作、执行党的决议和按期交纳党费的，可以申请加入中国共产党。</p><p>　　第二条　中国共产党党员是中国工人阶级的有共产主义觉悟的先锋战士。</p><p>　　中国共产党党员必须全心全意为人民服务，不惜牺牲个人的一切，为实现共产主义奋斗终身。</p><p>　　中国共产党党员永远是劳动人民的普通一员。除了法律和政策规定范围内的个人利益和工作职权以外，所有共产党员都不得谋求任何私利和特权。</p><p>　　第三条　党员必须履行下列义务：</p><p>　　（一）认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，学习党的路线、方针、政策和决议，学习党的基本知识和党的历史，学习科学、文化、法律和业务知识，努力提高为人民服务的本领。</p><p>　　（二）增强“四个意识”、坚定“四个自信”、做到“两个维护”，贯彻执行党的基本路线和各项方针、政策，带头参加改革开放和社会主义现代化建设，带动群众为经济发展和社会进步艰苦奋斗，在生产、工作、学习和社会生活中起先锋模范作用。</p><p>　　（三）坚持党和人民的利益高于一切，个人利益服从党和人民的利益，吃苦在前，享受在后，克己奉公，多做贡献。</p><p>　　（四）自觉遵守党的纪律，首先是党的政治纪律和政治规矩，模范遵守国家的法律法规，严格保守党和国家的秘密，执行党的决定，服从组织分配，积极完成党的任务。</p><p>　　（五）维护党的团结和统一，对党忠诚老实，言行一致，坚决反对一切派别组织和小集团活动，反对阳奉阴违的两面派行为和一切阴谋诡计。</p><p>　　（六）切实开展批评和自我批评，勇于揭露和纠正违反党的原则的言行和工作中的缺点、错误，坚决同消极腐败现象作斗争。</p><p>　　（七）密切联系群众，向群众宣传党的主张，遇事同群众商量，及时向党反映群众的意见和要求，维护群众的正当利益。</p><p>　　（八）发扬社会主义新风尚，带头实践社会主义核心价值观和社会主义荣辱观，提倡共产主义道德，弘扬中华民族传统美德，为了保护国家和人民的利益，在一切困难和危险的时刻挺身而出，英勇斗争，不怕牺牲。</p><p>　　第四条　党员享有下列权利：</p><p>　　（一）参加党的有关会议，阅读党的有关文件，接受党的教育和培训。</p><p>　　（二）在党的会议上和党报党刊上，参加关于党的政策问题的讨论。</p><p>　　（三）对党的工作提出建议和倡议。</p><p>　　（四）在党的会议上有根据地批评党的任何组织和任何党员，向党负责地揭发、检举党的任何组织和任何党员违法乱纪的事实，要求处分违法乱纪的党员，要求罢免或撤换不称职的干部。</p><p>　　（五）行使表决权、选举权，有被选举权。</p><p>　　（六）在党组织讨论决定对党员的党纪处分或作出鉴定时，本人有权参加和进行申辩，其他党员可以为他作证和辩护。</p><p>　　（七）对党的决议和政策如有不同意见，在坚决执行的前提下，可以声明保留，并且可以把自己的意见向党的上级组织直至中央提出。</p><p>　　（八）向党的上级组织直至中央提出请求、申诉和控告，并要求有关组织给以负责的答复。</p><p>　　党的任何一级组织直至中央都无权剥夺党员的上述权利。</p><p>　　第五条　发展党员，必须把政治标准放在首位，经过党的支部，坚持个别吸收的原则。</p><p>　　申请入党的人，要填写入党志愿书，要有两名正式党员作介绍人，要经过支部大会通过和上级党组织批准，并且经过预备期的考察，才能成为正式党员。</p><p>　　介绍人要认真了解申请人的思想、品质、经历和工作表现，向他解释党的纲领和党的章程，说明党员的条件、义务和权利，并向党组织作出负责的报告。</p><p>　　党的支部委员会对申请入党的人，要注意征求党内外有关群众的意见，进行严格的审查，认为合格后再提交支部大会讨论。</p><p>　　上级党组织在批准申请人入党以前，要派人同他谈话，作进一步的了解，并帮助他提高对党的认识。</p><p>　　在特殊情况下，党的中央和省、自治区、直辖市委员会可以直接接收党员。</p><p>　　第六条　预备党员必须面向党旗进行入党宣誓。誓词如下：我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作，为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。</p><p>　　第七条　预备党员的预备期为一年。党组织对预备党员应当认真教育和考察。</p><p>　　预备党员的义务同正式党员一样。预备党员的权利，除了没有表决权、选举权和被选举权以外，也同正式党员一样。</p><p>　　预备党员预备期满，党的支部应当及时讨论他能否转为正式党员。认真履行党员义务，具备党员条件的，应当按期转为正式党员；需要继续考察和教育的，可以延长预备期，但不能超过一年；不履行党员义务，不具备党员条件的，应当取消预备党员资格。预备党员转为正式党员，或延长预备期，或取消预备党员资格，都应当经支部大会讨论通过和上级党组织批准。</p><p>　　预备党员的预备期，从支部大会通过他为预备党员之日算起。党员的党龄，从预备期满转为正式党员之日算起。</p><p>　　第八条　每个党员，不论职务高低，都必须编入党的一个支部、小组或其他特定组织，参加党的组织生活，接受党内外群众的监督。党员领导干部还必须参加党委、党组的民主生活会。不允许有任何不参加党的组织生活、不接受党内外群众监督的特殊党员。</p><p>　　第九条　党员有退党的自由。党员要求退党，应当经支部大会讨论后宣布除名，并报上级党组织备案。</p><p>　　党员缺乏革命意志，不履行党员义务，不符合党员条件，党的支部应当对他进行教育，要求他限期改正；经教育仍无转变的，应当劝他退党。劝党员退党，应当经支部大会讨论决定，并报上级党组织批准。如被劝告退党的党员坚持不退，应当提交支部大会讨论，决定把他除名，并报上级党组织批准。</p><p>　　党员如果没有正当理由，连续六个月不参加党的组织生活，或不交纳党费，或不做党所分配的工作，就被认为是自行脱党。支部大会应当决定把这样的党员除名，并报上级党组织批准。</p><h2 id="x3D-x3D-第二章-党的组织制度-x3D-x3D"><a href="#x3D-x3D-第二章-党的组织制度-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第二章　党的组织制度&#x3D;&#x3D;"></a>&#x3D;&#x3D;第二章　党的组织制度&#x3D;&#x3D;</h2><p>　　第十条　党是根据自己的纲领和章程，按照民主集中制组织起来的统一整体。党的民主集中制的基本原则是：</p><p>　　（一）党员个人服从党的组织，少数服从多数，下级组织服从上级组织，全党各个组织和全体党员服从党的全国代表大会和中央委员会。</p><p>　　（二）党的各级领导机关，除它们派出的代表机关和在非党组织中的党组外，都由选举产生。</p><p>　　（三）党的最高领导机关，是党的全国代表大会和它所产生的中央委员会。党的地方各级领导机关，是党的地方各级代表大会和它们所产生的委员会。党的各级委员会向同级的代表大会负责并报告工作。</p><p>　　（四）党的上级组织要经常听取下级组织和党员群众的意见，及时解决他们提出的问题。党的下级组织既要向上级组织请示和报告工作，又要独立负责地解决自己职责范围内的问题。上下级组织之间要互通情报、互相支持和互相监督。党的各级组织要按规定实行党务公开，使党员对党内事务有更多的了解和参与。</p><p>　　（五）党的各级委员会实行集体领导和个人分工负责相结合的制度。凡属重大问题都要按照集体领导、民主集中、个别酝酿、会议决定的原则，由党的委员会集体讨论，作出决定；委员会成员要根据集体的决定和分工，切实履行自己的职责。</p><p>　　（六）党禁止任何形式的个人崇拜。要保证党的领导人的活动处于党和人民的监督之下，同时维护一切代表党和人民利益的领导人的威信。</p><p>　　第十一条　党的各级代表大会的代表和委员会的产生，要体现选举人的意志。选举采用无记名投票的方式。候选人名单要由党组织和选举人充分酝酿讨论。可以直接采用候选人数多于应选人数的差额选举办法进行正式选举。也可以先采用差额选举办法进行预选，产生候选人名单，然后进行正式选举。选举人有了解候选人情况、要求改变候选人、不选任何一个候选人和另选他人的权利。任何组织和个人不得以任何方式强迫选举人选举或不选举某个人。</p><p>　　党的地方各级代表大会和基层代表大会的选举，如果发生违反党章的情况，上一级党的委员会在调查核实后，应作出选举无效和采取相应措施的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p><p>　　党的各级代表大会代表实行任期制。</p><p>　　第十二条　党的中央和地方各级委员会在必要时召集代表会议，讨论和决定需要及时解决的重大问题。代表会议代表的名额和产生办法，由召集代表会议的委员会决定。</p><p>　　第十三条　凡是成立党的新组织，或是撤销党的原有组织，必须由上级党组织决定。</p><p>　　在党的地方各级代表大会和基层代表大会闭会期间，上级党的组织认为有必要时，可以调动或者指派下级党组织的负责人。</p><p>　　党的中央和地方各级委员会可以派出代表机关。</p><p>　　第十四条　党的中央和省、自治区、直辖市委员会实行巡视制度，在一届任期内，对所管理的地方、部门、企事业单位党组织实现巡视全覆盖。</p><p>　　中央有关部委和国家机关部门党组（党委）根据工作需要，开展巡视工作。</p><p>　　党的市（地、州、盟）和县（市、区、旗）委员会建立巡察制度。</p><p>　　第十五条　党的各级领导机关，对同下级组织有关的重要问题作出决定时，在通常情况下，要征求下级组织的意见。要保证下级组织能够正常行使他们的职权。凡属应由下级组织处理的问题，如无特殊情况，上级领导机关不要干预。</p><p>　　第十六条　有关全国性的重大政策问题，只有党中央有权作出决定，各部门、各地方的党组织可以向中央提出建议，但不得擅自作出决定和对外发表主张。</p><p>　　党的下级组织必须坚决执行上级组织的决定。下级组织如果认为上级组织的决定不符合本地区、本部门的实际情况，可以请求改变；如果上级组织坚持原决定，下级组织必须执行，并不得公开发表不同意见，但有权向再上一级组织报告。</p><p>　　党的各级组织的报刊和其他宣传工具，必须宣传党的路线、方针、政策和决议。</p><p>　　第十七条　党组织讨论决定问题，必须执行少数服从多数的原则。决定重要问题，要进行表决。对于少数人的不同意见，应当认真考虑。如对重要问题发生争论，双方人数接近，除了在紧急情况下必须按多数意见执行外，应当暂缓作出决定，进一步调查研究，交换意见，下次再表决；在特殊情况下，也可将争论情况向上级组织报告，请求裁决。</p><p>　　党员个人代表党组织发表重要主张，如果超出党组织已有决定的范围，必须提交所在的党组织讨论决定，或向上级党组织请示。任何党员不论职务高低，都不能个人决定重大问题；如遇紧急情况，必须由个人作出决定时，事后要迅速向党组织报告。不允许任何领导人实行个人专断和把个人凌驾于组织之上。</p><p>　　第十八条　党的中央、地方和基层组织，都必须重视党的建设，经常讨论和检查党的宣传工作、教育工作、组织工作、纪律检查工作、群众工作、统一战线工作等，注意研究党内外的思想政治状况。</p><h2 id="第三章-党的中央组织"><a href="#第三章-党的中央组织" class="headerlink" title="第三章　党的中央组织"></a>第三章　党的中央组织</h2><p>　　第十九条　党的全国代表大会每五年举行一次，由中央委员会召集。中央委员会认为有必要，或者有三分之一以上的省一级组织提出要求，全国代表大会可以提前举行；如无非常情况，不得延期举行。</p><p>　　全国代表大会代表的名额和选举办法，由中央委员会决定。</p><p>　　第二十条　党的全国代表大会的职权是：</p><p>　　（一）听取和审查中央委员会的报告；</p><p>　　（二）审查中央纪律检查委员会的报告；</p><p>　　（三）讨论并决定党的重大问题；</p><p>　　（四）修改党的章程；</p><p>　　（五）选举中央委员会；</p><p>　　（六）选举中央纪律检查委员会。</p><p>　　第二十一条　党的全国代表会议的职权是：讨论和决定重大问题；调整和增选中央委员会、中央纪律检查委员会的部分成员。调整和增选中央委员及候补中央委员的数额，不得超过党的全国代表大会选出的中央委员及候补中央委员各自总数的五分之一。</p><p>　　第二十二条　党的中央委员会每届任期五年。全国代表大会如提前或延期举行，它的任期相应地改变。中央委员会委员和候补委员必须有五年以上的党龄。中央委员会委员和候补委员的名额，由全国代表大会决定。中央委员会委员出缺，由中央委员会候补委员按照得票多少依次递补。</p><p>　　中央委员会全体会议由中央政治局召集，每年至少举行一次。中央政治局向中央委员会全体会议报告工作，接受监督。</p><p>　　在全国代表大会闭会期间，中央委员会执行全国代表大会的决议，领导党的全部工作，对外代表中国共产党。</p><p>　　第二十三条　党的中央政治局、中央政治局常务委员会和中央委员会总书记，由中央委员会全体会议选举。中央委员会总书记必须从中央政治局常务委员会委员中产生。</p><p>　　中央政治局和它的常务委员会在中央委员会全体会议闭会期间，行使中央委员会的职权。</p><p>　　中央书记处是中央政治局和它的常务委员会的办事机构；成员由中央政治局常务委员会提名，中央委员会全体会议通过。</p><p>　　中央委员会总书记负责召集中央政治局会议和中央政治局常务委员会会议，并主持中央书记处的工作。</p><p>　　党的中央军事委员会组成人员由中央委员会决定，中央军事委员会实行主席负责制。</p><p>　　每届中央委员会产生的中央领导机构和中央领导人，在下届全国代表大会开会期间，继续主持党的经常工作，直到下届中央委员会产生新的中央领导机构和中央领导人为止。</p><p>　　第二十四条　中国人民解放军的党组织，根据中央委员会的指示进行工作。中央军事委员会负责军队中党的工作和政治工作，对军队中党的组织体制和机构作出规定。</p><h2 id="第四章-党的地方组织"><a href="#第四章-党的地方组织" class="headerlink" title="第四章　党的地方组织"></a>第四章　党的地方组织</h2><p>　　第二十五条　党的省、自治区、直辖市的代表大会，设区的市和自治州的代表大会，县（旗）、自治县、不设区的市和市辖区的代表大会，每五年举行一次。</p><p>　　党的地方各级代表大会由同级党的委员会召集。在特殊情况下，经上一级委员会批准，可以提前或延期举行。</p><p>　　党的地方各级代表大会代表的名额和选举办法，由同级党的委员会决定，并报上一级党的委员会批准。</p><p>　　第二十六条　党的地方各级代表大会的职权是：</p><p>　　（一）听取和审查同级委员会的报告；</p><p>　　（二）审查同级纪律检查委员会的报告；</p><p>　　（三）讨论本地区范围内的重大问题并作出决议；</p><p>　　（四）选举同级党的委员会，选举同级党的纪律检查委员会。</p><p>　　第二十七条　党的省、自治区、直辖市、设区的市和自治州的委员会，每届任期五年。这些委员会的委员和候补委员必须有五年以上的党龄。</p><p>　　党的县（旗）、自治县、不设区的市和市辖区的委员会，每届任期五年。这些委员会的委员和候补委员必须有三年以上的党龄。</p><p>　　党的地方各级代表大会如提前或延期举行，由它选举的委员会的任期相应地改变。</p><p>　　党的地方各级委员会的委员和候补委员的名额，分别由上一级委员会决定。党的地方各级委员会委员出缺，由候补委员按照得票多少依次递补。</p><p>　　党的地方各级委员会全体会议，每年至少召开两次。</p><p>　　党的地方各级委员会在代表大会闭会期间，执行上级党组织的指示和同级党代表大会的决议，领导本地方的工作，定期向上级党的委员会报告工作。</p><p>　　第二十八条　党的地方各级委员会全体会议，选举常务委员会和书记、副书记，并报上级党的委员会批准。党的地方各级委员会的常务委员会，在委员会全体会议闭会期间，行使委员会职权；在下届代表大会开会期间，继续主持经常工作，直到新的常务委员会产生为止。</p><p>　　党的地方各级委员会的常务委员会定期向委员会全体会议报告工作，接受监督。</p><p>　　第二十九条　党的地区委员会和相当于地区委员会的组织，是党的省、自治区委员会在几个县、自治县、市范围内派出的代表机关。它根据省、自治区委员会的授权，领导本地区的工作。</p><h2 id="第五章-党的基层组织"><a href="#第五章-党的基层组织" class="headerlink" title="第五章　党的基层组织"></a>第五章　党的基层组织</h2><p>　　第三十条　企业、农村、机关、学校、医院、科研院所、街道社区、社会组织、人民解放军连队和其他基层单位，凡是有正式党员三人以上的，都应当成立党的基层组织。</p><p>　　党的基层组织，根据工作需要和党员人数，经上级党组织批准，分别设立党的基层委员会、总支部委员会、支部委员会。基层委员会由党员大会或代表大会选举产生，总支部委员会和支部委员会由党员大会选举产生，提出委员候选人要广泛征求党员和群众的意见。</p><p>　　第三十一条　党的基层委员会、总支部委员会、支部委员会每届任期三年至五年。基层委员会、总支部委员会、支部委员会的书记、副书记选举产生后，应报上级党组织批准。</p><p>　　第三十二条　党的基层组织是党在社会基层组织中的战斗堡垒，是党的全部工作和战斗力的基础。它的基本任务是：</p><p>　　（一）宣传和执行党的路线、方针、政策，宣传和执行党中央、上级组织和本组织的决议，充分发挥党员的先锋模范作用，积极创先争优，团结、组织党内外的干部和群众，努力完成本单位所担负的任务。</p><p>　　（二）组织党员认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，推进“两学一做”学习教育、党史学习教育常态化制度化，学习党的路线、方针、政策和决议，学习党的基本知识，学习科学、文化、法律和业务知识。</p><p>　　（三）对党员进行教育、管理、监督和服务，提高党员素质，坚定理想信念，增强党性，严格党的组织生活，开展批评和自我批评，维护和执行党的纪律，监督党员切实履行义务，保障党员的权利不受侵犯。加强和改进流动党员管理。</p><p>　　（四）密切联系群众，经常了解群众对党员、党的工作的批评和意见，维护群众的正当权利和利益，做好群众的思想政治工作。</p><p>　　（五）充分发挥党员和群众的积极性创造性，发现、培养和推荐他们中间的优秀人才，鼓励和支持他们在改革开放和社会主义现代化建设中贡献自己的聪明才智。</p><p>　　（六）对要求入党的积极分子进行教育和培养，做好经常性的发展党员工作，重视在生产、工作第一线和青年中发展党员。</p><p>　　（七）监督党员干部和其他任何工作人员严格遵守国家法律法规，严格遵守国家的财政经济法规和人事制度，不得侵占国家、集体和群众的利益。</p><p>　　（八）教育党员和群众自觉抵制不良倾向，坚决同各种违纪违法行为作斗争。</p><p>　　第三十三条　街道、乡、镇党的基层委员会和村、社区党组织，统一领导本地区基层各类组织和各项工作，加强基层社会治理，支持和保证行政组织、经济组织和群众性自治组织充分行使职权。</p><p>　　国有企业党委（党组）发挥领导作用，把方向、管大局、保落实，依照规定讨论和决定企业重大事项。国有企业和集体企业中党的基层组织，围绕企业生产经营开展工作。保证监督党和国家的方针、政策在本企业的贯彻执行；支持股东会、董事会、监事会和经理（厂长）依法行使职权；全心全意依靠职工群众，支持职工代表大会开展工作；参与企业重大问题的决策；加强党组织的自身建设，领导思想政治工作、精神文明建设、统一战线工作和工会、共青团、妇女组织等群团组织。</p><p>　　非公有制经济组织中党的基层组织，贯彻党的方针政策，引导和监督企业遵守国家的法律法规，领导工会、共青团等群团组织，团结凝聚职工群众，维护各方的合法权益，促进企业健康发展。</p><p>　　社会组织中党的基层组织，宣传和执行党的路线、方针、政策，领导工会、共青团等群团组织，教育管理党员，引领服务群众，推动事业发展。</p><p>　　实行行政领导人负责制的事业单位中党的基层组织，发挥战斗堡垒作用。实行党委领导下的行政领导人负责制的事业单位中党的基层组织，对重大问题进行讨论和作出决定，同时保证行政领导人充分行使自己的职权。</p><p>　　各级党和国家机关中党的基层组织，协助行政负责人完成任务，改进工作，对包括行政负责人在内的每个党员进行教育、管理、监督，不领导本单位的业务工作。</p><p>　　第三十四条　党支部是党的基础组织，担负直接教育党员、管理党员、监督党员和组织群众、宣传群众、凝聚群众、服务群众的职责。</p><h2 id="第六章-党的干部"><a href="#第六章-党的干部" class="headerlink" title="第六章　党的干部"></a>第六章　党的干部</h2><p>　　第三十五条　党的干部是党的事业的骨干，是人民的公仆，要做到忠诚干净担当。党按照德才兼备、以德为先的原则选拔干部，坚持五湖四海、任人唯贤，坚持事业为上、公道正派，反对任人唯亲，努力实现干部队伍的革命化、年轻化、知识化、专业化。</p><p>　　党重视教育、培训、选拔、考核和监督干部，特别是培养、选拔优秀年轻干部。积极推进干部制度改革。</p><p>　　党重视培养、选拔女干部和少数民族干部。</p><p>　　第三十六条　党的各级领导干部必须信念坚定、为民服务、勤政务实、敢于担当、清正廉洁，模范地履行本章程第三条所规定的党员的各项义务，并且必须具备以下的基本条件：</p><p>　　（一）具有履行职责所需要的马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的水平，带头贯彻落实习近平新时代中国特色社会主义思想，努力用马克思主义的立场、观点、方法分析和解决实际问题，坚持讲学习、讲政治、讲正气，经得起各种风浪的考验。</p><p>　　（二）具有共产主义远大理想和中国特色社会主义坚定信念，坚决执行党的基本路线和各项方针、政策，立志改革开放，献身现代化事业，在社会主义建设中艰苦创业，树立正确政绩观，做出经得起实践、人民、历史检验的实绩。</p><p>　　（三）坚持解放思想，实事求是，与时俱进，开拓创新，认真调查研究，能够把党的方针、政策同本地区、本部门的实际相结合，卓有成效地开展工作，讲实话，办实事，求实效。</p><p>　　（四）有强烈的革命事业心和政治责任感，有实践经验，有胜任领导工作的组织能力、文化水平和专业知识。</p><p>　　（五）正确行使人民赋予的权力，坚持原则，依法办事，清正廉洁，勤政为民，以身作则，艰苦朴素，密切联系群众，坚持党的群众路线，自觉地接受党和群众的批评和监督，加强道德修养，讲党性、重品行、作表率，做到自重、自省、自警、自励，反对形式主义、官僚主义、享乐主义和奢靡之风，反对特权思想和特权现象，反对任何滥用职权、谋求私利的行为。</p><p>　　（六）坚持和维护党的民主集中制，有民主作风，有全局观念，善于团结同志，包括团结同自己有不同意见的同志一道工作。</p><p>　　第三十七条　党员干部要善于同党外干部合作共事，尊重他们，虚心学习他们的长处。</p><p>　　党的各级组织要善于发现和推荐有真才实学的党外干部担任领导工作，保证他们有职有权，充分发挥他们的作用。</p><p>　　第三十八条　党的各级领导干部，无论是由民主选举产生的，或是由领导机关任命的，他们的职务都不是终身的，都可以变动或解除。</p><p>　　年龄和健康状况不适宜于继续担任工作的干部，应当按照国家的规定退、离休。</p><h2 id="x3D-x3D-第七章-党的纪律-x3D-x3D"><a href="#x3D-x3D-第七章-党的纪律-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第七章　党的纪律&#x3D;&#x3D;"></a>&#x3D;&#x3D;第七章　党的纪律&#x3D;&#x3D;</h2><p>　　第三十九条　党的纪律是党的各级组织和全体党员必须遵守的行为规则，是维护党的团结统一、完成党的任务的保证。党组织必须严格执行和维护党的纪律，共产党员必须自觉接受党的纪律的约束。</p><p>　　第四十条　党的纪律主要包括政治纪律、组织纪律、廉洁纪律、群众纪律、工作纪律、生活纪律。</p><p>　　坚持惩前毖后、治病救人，执纪必严、违纪必究，抓早抓小、防微杜渐，按照错误性质和情节轻重，给以批评教育、责令检查、诫勉直至纪律处分。运用监督执纪“四种形态”，让“红红脸、出出汗”成为常态，党纪处分、组织调整成为管党治党的重要手段，严重违纪、严重触犯刑律的党员必须开除党籍。</p><p>　　党内严格禁止用违反党章和国家法律的手段对待党员，严格禁止打击报复和诬告陷害。违反这些规定的组织或个人必须受到党的纪律和国家法律的追究。</p><p>　　第四十一条　对党员的纪律处分有五种：警告、严重警告、撤销党内职务、留党察看、开除党籍。</p><p>　　留党察看最长不超过两年。党员在留党察看期间没有表决权、选举权和被选举权。党员经过留党察看，确已改正错误的，应当恢复其党员的权利；坚持错误不改的，应当开除党籍。</p><p>　　开除党籍是党内的最高处分。各级党组织在决定或批准开除党员党籍的时候，应当全面研究有关的材料和意见，采取十分慎重的态度。</p><p>　　第四十二条　对党员的纪律处分，必须经过支部大会讨论决定，报党的基层委员会批准；如果涉及的问题比较重要或复杂，或给党员以开除党籍的处分，应分别不同情况，报县级或县级以上党的纪律检查委员会审查批准。在特殊情况下，县级和县级以上各级党的委员会和纪律检查委员会有权直接决定给党员以纪律处分。</p><p>　　对党的中央委员会委员、候补委员，给以警告、严重警告处分，由中央纪律检查委员会常务委员会审议后，报党中央批准。对地方各级党的委员会委员、候补委员，给以警告、严重警告处分，应由上一级纪律检查委员会批准，并报它的同级党的委员会备案。</p><p>　　对党的中央委员会和地方各级委员会的委员、候补委员，给以撤销党内职务、留党察看或开除党籍的处分，必须由本人所在的委员会全体会议三分之二以上的多数决定。在全体会议闭会期间，可以先由中央政治局和地方各级委员会常务委员会作出处理决定，待召开委员会全体会议时予以追认。对地方各级委员会委员和候补委员的上述处分，必须经过上级纪律检查委员会常务委员会审议，由这一级纪律检查委员会报同级党的委员会批准。</p><p>　　严重触犯刑律的中央委员会委员、候补委员，由中央政治局决定开除其党籍；严重触犯刑律的地方各级委员会委员、候补委员，由同级委员会常务委员会决定开除其党籍。</p><p>　　第四十三条　党组织对党员作出处分决定，应当实事求是地查清事实。处分决定所依据的事实材料和处分决定必须同本人见面，听取本人说明情况和申辩。如果本人对处分决定不服，可以提出申诉，有关党组织必须负责处理或者迅速转递，不得扣压。对于确属坚持错误意见和无理要求的人，要给以批评教育。</p><p>　　第四十四条　党组织如果在维护党的纪律方面失职，必须问责。</p><p>　　对于严重违犯党的纪律、本身又不能纠正的党组织，上一级党的委员会在查明核实后，应根据情节严重的程度，作出进行改组或予以解散的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p><h2 id="第八章-党的纪律检查机关"><a href="#第八章-党的纪律检查机关" class="headerlink" title="第八章　党的纪律检查机关"></a>第八章　党的纪律检查机关</h2><p>　　第四十五条　党的中央纪律检查委员会在党的中央委员会领导下进行工作。党的地方各级纪律检查委员会和基层纪律检查委员会在同级党的委员会和上级纪律检查委员会双重领导下进行工作。上级党的纪律检查委员会加强对下级纪律检查委员会的领导。</p><p>　　党的各级纪律检查委员会每届任期和同级党的委员会相同。</p><p>　　党的中央纪律检查委员会全体会议，选举常务委员会和书记、副书记，并报党的中央委员会批准。党的地方各级纪律检查委员会全体会议，选举常务委员会和书记、副书记，并由同级党的委员会通过，报上级党的委员会批准。党的基层委员会是设立纪律检查委员会，还是设立纪律检查委员，由它的上一级党组织根据具体情况决定。党的总支部委员会和支部委员会设纪律检查委员。</p><p>　　党的中央和地方纪律检查委员会向同级党和国家机关全面派驻党的纪律检查组，按照规定向有关国有企业、事业单位派驻党的纪律检查组。纪律检查组组长参加驻在单位党的领导组织的有关会议。他们的工作必须受到该单位党的领导组织的支持。</p><p>　　第四十六条　党的各级纪律检查委员会是党内监督专责机关，主要任务是：维护党的章程和其他党内法规，检查党的路线、方针、政策和决议的执行情况，协助党的委员会推进全面从严治党、加强党风建设和组织协调反腐败工作，推动完善党和国家监督体系。</p><p>　　党的各级纪律检查委员会的职责是监督、执纪、问责，要经常对党员进行遵守纪律的教育，作出关于维护党纪的决定；对党的组织和党员领导干部履行职责、行使权力进行监督，受理处置党员群众检举举报，开展谈话提醒、约谈函询；检查和处理党的组织和党员违反党的章程和其他党内法规的比较重要或复杂的案件，决定或取消对这些案件中的党员的处分；进行问责或提出责任追究的建议；受理党员的控告和申诉；保障党员的权利。</p><p>　　各级纪律检查委员会要把处理特别重要或复杂的案件中的问题和处理的结果，向同级党的委员会报告。党的地方各级纪律检查委员会和基层纪律检查委员会要同时向上级纪律检查委员会报告。</p><p>　　各级纪律检查委员会发现同级党的委员会委员有违犯党的纪律的行为，可以先进行初步核实，如果需要立案检查的，应当在向同级党的委员会报告的同时向上一级纪律检查委员会报告；涉及常务委员的，报告上一级纪律检查委员会，由上一级纪律检查委员会进行初步核实，需要审查的，由上一级纪律检查委员会报它的同级党的委员会批准。</p><p>　　第四十七条　上级纪律检查委员会有权检查下级纪律检查委员会的工作，并且有权批准和改变下级纪律检查委员会对于案件所作的决定。如果所要改变的该下级纪律检查委员会的决定，已经得到它的同级党的委员会的批准，这种改变必须经过它的上一级党的委员会批准。</p><p>　　党的地方各级纪律检查委员会和基层纪律检查委员会如果对同级党的委员会处理案件的决定有不同意见，可以请求上一级纪律检查委员会予以复查；如果发现同级党的委员会或它的成员有违犯党的纪律的情况，在同级党的委员会不给予解决或不给予正确解决的时候，有权向上级纪律检查委员会提出申诉，请求协助处理。</p><h2 id="第九章-党-组"><a href="#第九章-党-组" class="headerlink" title="第九章　党　组"></a>第九章　党　组</h2><p>　　第四十八条　在中央和地方国家机关、人民团体、经济组织、文化组织和其他非党组织的领导机关中，可以成立党组。党组发挥领导作用。党组的任务，主要是负责贯彻执行党的路线、方针、政策；加强对本单位党的建设的领导，履行全面从严治党责任；讨论和决定本单位的重大问题；做好干部管理工作；讨论和决定基层党组织设置调整和发展党员、处分党员等重要事项；团结党外干部和群众，完成党和国家交给的任务；领导机关和直属单位党组织的工作。</p><p>　　第四十九条　党组的成员，由批准成立党组的党组织决定。党组设书记，必要时还可以设副书记。</p><p>　　党组必须服从批准它成立的党组织领导。</p><p>　　第五十条　在对下属单位实行集中统一领导的国家工作部门和有关单位的领导机关中，可以建立党委，党委的产生办法、职权和工作任务，由中央另行规定。</p><h2 id="x3D-x3D-第十章-党和共产主义青年团的关系-x3D-x3D"><a href="#x3D-x3D-第十章-党和共产主义青年团的关系-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第十章　党和共产主义青年团的关系&#x3D;&#x3D;"></a>&#x3D;&#x3D;第十章　党和共产主义青年团的关系&#x3D;&#x3D;</h2><p>　　第五十一条　中国共产主义青年团是中国共产党领导的先进青年的群团组织，是广大青年在实践中学习中国特色社会主义和共产主义的学校，是党的助手和后备军。共青团中央委员会受党中央委员会领导。共青团的地方各级组织受同级党的委员会领导，同时受共青团上级组织领导。</p><p>　　第五十二条　党的各级委员会要加强对共青团的领导，注意团的干部的选拔和培训。党要坚决支持共青团根据广大青年的特点和需要，生动活泼地、富于创造性地进行工作，充分发挥团的突击队作用和联系广大青年的桥梁作用。</p><p>　　团的县级和县级以下各级委员会书记，企业事业单位的团委员会书记，是党员的，可以列席同级党的委员会和常务委员会的会议。</p><h2 id="x3D-x3D-第十一章-党徽党旗-x3D-x3D"><a href="#x3D-x3D-第十一章-党徽党旗-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第十一章　党徽党旗&#x3D;&#x3D;"></a>&#x3D;&#x3D;第十一章　党徽党旗&#x3D;&#x3D;</h2><p>　　第五十三条　中国共产党党徽为镰刀和锤头组成的图案。</p><p>　　第五十四条　中国共产党党旗为旗面缀有金黄色党徽图案的红旗。</p><p>　　第五十五条　中国共产党的党徽党旗是中国共产党的象征和标志。党的各级组织和每一个党员都要维护党徽党旗的尊严。要按照规定制作和使用党徽党旗。</p>]]></content>
    
    
    <categories>
      
      <category>党</category>
      
    </categories>
    
    
    <tags>
      
      <tag>党</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/blog/2022/11/20/webpack/"/>
    <url>/blog/2022/11/20/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><blockquote><ol><li><a href="https://zhuanlan.zhihu.com/p/65574428">https://zhuanlan.zhihu.com/p/65574428</a></li><li><a href="https://juejin.cn/post/6844904030649614349">https://juejin.cn/post/6844904030649614349</a></li><li>新建webpack项目：<a href="https://juejin.cn/post/6844904005286494215">https://juejin.cn/post/6844904005286494215</a></li><li>无法识别webpack：<a href="https://blog.csdn.net/happyqyt/article/details/89739065">https://blog.csdn.net/happyqyt/article/details/89739065</a></li><li>webpack官方：<a href="https://webpack.docschina.org/configuration/devtool/">https://webpack.docschina.org/configuration/devtool/</a></li></ol></blockquote><h4 id="1-1-没有webpack的情况："><a href="#1-1-没有webpack的情况：" class="headerlink" title="1.1 没有webpack的情况："></a>1.1 没有webpack的情况：</h4><p>header.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> header = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    header.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页标题&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(header);<br>&#125;<br></code></pre></td></tr></table></figure><p>content.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    content.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页主体&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(content);<br>&#125;<br></code></pre></td></tr></table></figure><p>footer.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> footer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    footer.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页页脚&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(footer);<br>&#125;<br></code></pre></td></tr></table></figure><p>index.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Header</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Footer</span>();<br></code></pre></td></tr></table></figure><p>dist.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;webContent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./header.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./content.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./footer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样将代码模块化后，使得代码的逻辑变得清晰，更能呈现出业务场景。</p><p>但是，这种方式的模块化也存在缺点：</p><p>①页面加载速度变慢：</p><p>由于增加了js文件的数量，所以网页需要发起更多次的http请求，导致了页面加载速度变慢。</p><p>②无法直接在js代码中看出js文件之间相互的存储位置的关系，必须要通过dist.html文件才能查看。</p><p>③js文件必须按规定顺序加载：</p><p>在dist.html文件中，header.js、content.js以及footer.js文件都必须在index.js文件之前加载完毕：</p><p><img src="https://pic1.zhimg.com/80/v2-0df3230ef4b30ab06ca7436b683a7090_720w.webp" alt="img"></p><p>假如我们把header.js文件，放在index.js文件后面进行加载：</p><p><img src="https://pic3.zhimg.com/80/v2-57193acea19b5a9b4a8e8a3aff35ce5a_720w.webp" alt="img"></p><p>网页的控制台就会报错。</p><h4 id="1-2-使用webpack打包的情况"><a href="#1-2-使用webpack打包的情况" class="headerlink" title="1.2 使用webpack打包的情况"></a>1.2 使用webpack打包的情况</h4><p>为了解决上面那种模块化方式存在的缺点，我们依据ES module的规则改写一点代码，然后结合webpack来解决。</p><p>首先，我们来看改写后的代码：</p><p>header.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br>    <span class="hljs-keyword">var</span> header = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    header.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页标题&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(header);<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Header</span>;<br></code></pre></td></tr></table></figure><p>content.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br>    <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    content.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页主体&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(content);<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Content</span>;<br></code></pre></td></tr></table></figure><p>footer.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> webContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webContent&#x27;</span>);<br>    <span class="hljs-keyword">var</span> footer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    footer.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;网页页脚&#x27;</span>;<br>    webContent.<span class="hljs-title function_">appendChild</span>(footer);<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Footer</span>;<br></code></pre></td></tr></table></figure><p>index.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./header.js&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./content.js&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Footer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./footer.js&#x27;</span>;<br> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Header</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Footer</span>();<br></code></pre></td></tr></table></figure><p>dist.html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;webContent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来，进入到上面这些文件的根目录，我这里是进入到e:\webpack-demo，然后初始化npm环境（注意：做这些操作之前必须要先安装node环境，可以参考这篇文章：</p><p><a href="https://link.zhihu.com/?target=https://www.npmjs.com.cn/getting-started/installing-node/%EF%BC%89%EF%BC%9A">https://www.npmjs.com.cn/getting-started/installing-node/）：www.npmjs.com.cn/getting-started/installing-node/%EF%BC%89%EF%BC%9A</a></p><p><img src="https://pic3.zhimg.com/80/v2-a00645e76758c8afa04f4f16bde731e6_720w.webp" alt="img"></p><p>接下来，一直回车就好。</p><p>然后，安装webpack:</p><p><img src="https://pic2.zhimg.com/80/v2-023b4ee85a09368e9094de33ac87d255_720w.webp" alt="img"></p><p>最后，运行npx webpack命令（Node 8.2+ 版本提供的 npx 命令，可以运行在初始安装的 webpack 包(package)的 <strong>webpack</strong> 二进制文件，就是可以调用webpack中的webpack二进制文件程序）：</p><p><img src="https://pic4.zhimg.com/80/v2-994a8b8ca95e19b1d6148488b271a907_720w.webp" alt="img"></p><p>此时，会发现根目录中出现了一个新的文件夹：</p><p><img src="https://pic3.zhimg.com/80/v2-823b4204e121b4270006c43d179a99aa_720w.webp" alt="img"></p><p>查看dist文件夹中的内容，可以发现有一个main.js文件，其实这个main.js文件是webpack将index.js、header.js、content.js、footer.js打包在一起的一个文件。</p><p>用浏览器直接打开dist.html文件，可以发现和原先的模块化方法得到相同的结果：</p><p><img src="https://pic3.zhimg.com/80/v2-d0811a49a974c32c1c400711a297dcda_720w.webp" alt="img"></p><h4 id="1-3-webpack是什么"><a href="#1-3-webpack是什么" class="headerlink" title="1.3 webpack是什么"></a>1.3 webpack是什么</h4><p>webpack是一个打包工具，他的宗旨是一切静态资源皆可打包。有人就会问为什么要webpack？webpack是现代前端技术的基石，常规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p><h4 id="1-4-webpack核心概念"><a href="#1-4-webpack核心概念" class="headerlink" title="1.4 webpack核心概念"></a>1.4 webpack核心概念</h4><p><strong>1、Entry（入口）：</strong>指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p><strong>2、Output（出口）：</strong>告诉 webpack 在哪里输出它所创建的结果文件，以及如何命名这些文件，默认值为.&#x2F;dist。</p><p><strong>3、Loader（模块转换器）：</strong>将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p><strong>4、Plugins（插件）：</strong>在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</p><p><strong>5、Module(模块)：</strong>开发者将程序分解成离散功能块，并称之为模块，</p><p>在webpack里一个模块对应着一个文件，webpack会从配置的 Entry 开始递归找出所有依赖的模块。</p><h4 id="1-5-webpack执行流程"><a href="#1-5-webpack执行流程" class="headerlink" title="1.5 webpack执行流程"></a>1.5 webpack执行流程</h4><p>webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，每找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑</p><h4 id="1-6-webpack简单打包案例"><a href="#1-6-webpack简单打包案例" class="headerlink" title="1.6 webpack简单打包案例"></a>1.6 webpack简单打包案例</h4><ol><li>准备工作</li></ol><p>建一个空文件夹用于创建项目， 如下我在D盘创建了一个名为webpack_demo的文件夹，使用终端进入文件夹， 使用npm init 命令初始化一个package.json文件。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2ea3e67e4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过如果你不打算发布这个模块，直接一路回车就好。（也可以使用<code>npm init -y</code>这个命令来一次生成package.json文件，这样终端不会询问你问题）。</p><ol start="2"><li>安装webpack</li></ol><p>接下来在命令行中输入以下命令安装webpack，如果你想一步到位的话，就把全局webpack和本地项目webpack全都先装了，因为后面一些模块会用到。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install webpack --global                <span class="hljs-regexp">//</span> 安装全局webpack命令<br>npm install webpack webpack-cli --save-dev  <span class="hljs-regexp">//</span> 安装本地项目模块<br><br><span class="hljs-regexp">//</span> install    可简写为i,<br><span class="hljs-regexp">//</span> --global   可简写为-g<br><span class="hljs-regexp">//</span> --save     可简写为-S<br><span class="hljs-regexp">//</span> --save-dev 可简写为-D复制代码<br></code></pre></td></tr></table></figure><ol start="3"><li>新建文件</li></ol><p>在webpack_demo文件夹下新建两个文件夹，分别为src文件夹和dist文件夹，接着在src文件夹下新增index.js文件和hello.js文件，在dist文件夹下新增index.html文件。此时项目结构如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2eb7d555a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在hello.js中导出一个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// hello.js </span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">let</span> hello = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>   hello.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;hello xxx!&quot;</span>;<br>   <span class="hljs-keyword">return</span> hello;<br> &#125;;<br></code></pre></td></tr></table></figure><p>在index.js中引入这个hello.js模块</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">const</span> hello = require(<span class="hljs-string">&#x27;./hello.js&#x27;</span>);<br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>).appendChild(hello());<br></code></pre></td></tr></table></figure><p>在index.html下引入打包后的js文件bundle.js</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <span class="hljs-comment">&lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>进行打包</li></ol><p>在终端输入如下命令进行打包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack全局安装的情况下，output后面的是打包后的文件路径，bundle.js为打包后的js文件名<br><br>webpack src<span class="hljs-regexp">/index.js --output dist/</span>bundle.js  <br><br><span class="hljs-regexp">//</span> --output可简写为-o<br><span class="hljs-regexp">//</span> 上述命令相当于把src文件夹下的index.js文件打包到dist文件夹下的bundle.js，这样就生成了打包后的文件供index.html引入<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2eca103e8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看出webpack同时编译了index.js和hello.js，因为index.js文件引入了hello.js模块，现在打开index.html看看结果</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2ee62bb72~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们已经成功使用webpack进行打包，这时小伙伴要说了，每次都在终端中输入这么长的命令，感觉好烦啊，接下来学习通过配置文件来使用webpack。</p><ol start="5"><li>通过配置文件来使用webpack</li></ol><p>在当前项目的根目录下新建一个配置文件webpack.config.js，我们写下如下简单配置代码，目前只涉及入口配置（相当于我们的index.js，从它开始打包）和出口配置（相当于我们打包生成的bundle.js）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>    entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>    output: &#123;<br>        path: path.join( __dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>        filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>    &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span> path.join的功能是拼接路径片段<br><span class="hljs-regexp">//</span> __dirname是node.js中的一个全局变量，它指向当前执行脚本所在的目录，即D:\webpack_demo<br></code></pre></td></tr></table></figure><p>有了这个配置文件，我们只需在终端中运行webpack命令就可进行打包，这条命令会自动引用webpack.config.js文件中的配置选项</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2edcc40d3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="6"><li>package.json文件中自定义脚本命令</li></ol><p>Node项目一般都有一个package.json文件，该文件用于描述当前项目，其中有一个scripts属性，该属性可以自定义脚本命令，例如我们运行的打包命令，那么可以在scripts里添加自定义脚本为：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c2f40cd7cf~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>之后就可以使用npm run build来运行该脚本命令，这样有什么好处呢？如果命令行很短，好处当然不明显了，但是如何命令行很长呢？那么我们可以在这里添加每次都需要执行的命令，配置了scripts后， npm run key值相当于在终端运行了value值</p><h4 id="1-7-构建本地服务"><a href="#1-7-构建本地服务" class="headerlink" title="1.7 构建本地服务"></a>1.7 构建本地服务</h4><p>上面案例我们是通过打开本地HTML文件来查看页面的，vue，react框架时都是运行在本地服务器上的，那我们能不能也改成那样呢？接下来学习如何构建本地服务</p><ol><li>webpack-dev-server配置本地服务器</li></ol><p>Webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js构建，它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm install webpack-dev-<span class="hljs-keyword">server</span> -D<br></code></pre></td></tr></table></figure><ol start="2"><li>devServer配置项</li></ol><ul><li><strong>port：</strong>指定了开启服务器的端口号，默认为8080</li><li><strong>host：</strong>配置 DevServer的服务器监听地址，默认为 127.0.0.1</li><li><strong>headers：</strong>该配置项可以在HTTP响应中注入一些HTTP响应头。例如：</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">headers: &#123;<br>  &#x27;X-foo&#x27;: &#x27;<span class="hljs-number">112233</span>&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>historyApiFallback：</strong>该配置项属性是用来应对返回404页面时定向跳转到特定页面的。一般是应用在单页应用，比如在访问路由时候，访问不到该路由的时候，通过该配置项，设置属性值为true的时候，会自动跳转到 index.html下。当然我们也可以手动通过 正则来匹配路由</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 跳到index.html页面 </span><br>historyApiFallback: <span class="hljs-keyword">true</span><br><br><span class="hljs-comment">// 使用正则来匹配路由</span><br>historyApiFallback: &#123;<br>  rewrites: [<br>    &#123; <span class="hljs-keyword">from</span>: <span class="hljs-regexp">/^\/user/</span>, to: <span class="hljs-string">&#x27;/user.html&#x27;</span> &#125;,<br>    &#123; <span class="hljs-keyword">from</span>: <span class="hljs-regexp">/^\/home/</span>, to: <span class="hljs-string">&#x27;/home.html&#x27;</span> &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>hot：</strong>该配置项是指模块替换功能，DevServer 默认行为是在发现源代码被更新后通过自动刷新整个页面来做到实时预览的，但是开启模块热替换功能后，它是通过在不刷新整个页面的情况下通过使用新模块替换旧模块来做到实时预览的。</li><li><strong>proxy :</strong> 有时候我们使用webpack在本地启动服务器的时候，由于我们使用的访问的域名是 <a href="http://localhost:8081/">http://localhost:8081</a> 这样的，但是我们服务端的接口是其他的，可以通过该配置来解决跨域的问题</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设服务端接口域名为：http:<span class="hljs-regexp">//</span>news.baidu.com<br>proxy: &#123;<br>  <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>    target: <span class="hljs-string">&#x27;http://news.baidu.com&#x27;</span>, <span class="hljs-regexp">//</span> 目标接口的域名<br>    <span class="hljs-regexp">//</span> secure: true,  <span class="hljs-regexp">//</span> https 的时候 使用该参数<br>    changeOrigin: true,  <span class="hljs-regexp">//</span> 是否跨域<br>    pathRewrite: &#123;<br>      <span class="hljs-string">&#x27;^/api&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-regexp">//</span> 重写路径<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>open：</strong>该属性用于DevServer启动且第一次构建完成时，自动使用我们的系统默认浏览器去打开网页。</li><li><strong>compress：</strong>配置是否启用 gzip 压缩，boolean 类型，默认为 false</li></ul><ol start="3"><li>添加配置项到webpack.config.js</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua">devServer: &#123;<br>    server: <span class="hljs-string">&quot;http&quot;</span>,<br>    static: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>), // 原contentBase<br>    headers: [<br>    &#123;<br>        key: <span class="hljs-string">&#x27;X-Custom&#x27;</span>,<br>        value: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    &#125;,<br>    &#123;<br>        key: <span class="hljs-string">&#x27;Y-Custom&#x27;</span>,<br>        value: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    &#125;,<br>    ],<br>    // hot: <span class="hljs-literal">true</span>, // 模块替换功能，实时预览<br>    hot: <span class="hljs-string">&quot;only&quot;</span>, // 在构建失败的情况下启用无需页面刷新的热模块替换作为后备<br>    host: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    port: <span class="hljs-number">8080</span>, // 开启服务器的端口号<br>    <span class="hljs-built_in">open</span>: <span class="hljs-literal">true</span>, // devserver启动且第一次完成构建时，自动使用系统默认浏览器打开网页<br>    client: &#123; // 编译出错时在浏览器上显示错误<br>        overlay: &#123;<br>            warnings: <span class="hljs-literal">false</span>,<br>            errors: <span class="hljs-literal">true</span>,<br>        &#125;<br>    &#125;,<br>    proxy: &#123; // 跨域问题<br>        <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>            target: <span class="hljs-string">&#x27;http://localhost:8888&#x27;</span>, // 目标接口的域名（服务器接口）<br>            changeOrigin: <span class="hljs-literal">true</span>, // 是否跨域<br>            secure: <span class="hljs-literal">false</span>, // 代理地址没证书也可以代理成功 <br>            pathRewrite: &#123;<br>                <span class="hljs-string">&#x27;^api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> // 重写路径<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><ol start="4"><li>在package.json文件中添加启动命令</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --open&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>我们用dev来启动本地服务器， webpack-dev-server就是启动服务器的命令，- -open是用于启动完服务器后自动打开浏览器，这时候我们自定义命令方式的便捷性就体现出来了，可以多个命令集成在一起运行，即我们定义了一个dev命令名称就可以同时运行了webpack-dev-server和- -open两个命令</p><p>现在在终端输入npm run dev 运行服务器</p><p>这样我们就可以在<a href="http://localhost:8088/%E4%B8%AD%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2">http://localhost:8088/中查看页面</a> (退出服务器，可使用ctrl+c后，再按y确认即可退出服务器运行)</p><ol start="5"><li>source maps调试配置</li></ol><p>作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，<code>Source Map</code>就是用来解决这个问题的。通过如下配置，我们会在打包时生成对应于打包文件的<code>.map</code>文件，使得编译后的代码可读性更高，更易于调试。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// webpack.config.js</span><br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>  entry: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  output: &#123;<br>    path: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: <span class="hljs-literal">true</span>,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: <span class="hljs-literal">true</span>,<br>    open: <span class="hljs-literal">true</span>,<br>    overlay: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span> <span class="hljs-comment">// 会生成对于调试的完整的.map文件，同时也会减慢打包速度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置好后，我们再次运行npm run build进行打包，这时我们会发现在dist文件夹中多出了一个bundle.js.map。如果我们的代码有bug，在浏览器的调试工具中会提示错误出现的位置，这就是devtool：’source-map’ 配置项的作用。</p><h4 id="1-8-Loaders"><a href="#1-8-Loaders" class="headerlink" title="1.8 Loaders"></a>1.8 Loaders</h4><p>loaders是webpack最强大的功能之一，通过不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把scss转为css，将ES66、ES7等语法转化为当前浏览器能识别的语法，将JSX转化为js等多项功能。Loaders需要单独安装并且需要在webpack.comfig.js中的modules配置项下进行配置，Loaders的配置包括以下几方面：</p><ul><li>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader的名称（必须）</li><li>include&#x2F;exclude： 手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）</li><li>options： 为loaders提供额外的设置选项（可选）</li></ul><ol><li>配置css-loader</li></ol><p>如果我们要加载一个css文件，需要安装style-loader和css-loader</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> style-loader css-loader -D<br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// webpack.config.js</span><br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>  entry: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  output: &#123;<br>    path: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: <span class="hljs-literal">true</span>,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: <span class="hljs-literal">true</span>,<br>    open: <span class="hljs-literal">true</span>,<br>    overlay: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: /\.css$/,   <span class="hljs-comment">// 正则匹配以.css结尾的文件</span><br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在src文件夹下新建index.css文件，设置body的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* index.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: gray;<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>在src文件夹下的index.js引入它</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span> <span class="hljs-comment">// 导入css</span><br><br><span class="hljs-keyword">const</span> hello = require(<span class="hljs-string">&#x27;./hello.js&#x27;</span>);<br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>).appendChild(hello());复制代码<br></code></pre></td></tr></table></figure><p>运行npm run dev启动服务器，会发现页面背景颜色变成了灰色</p><ol start="2"><li>配置sass</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install sass-loader <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> -D // 因为sass-loader依赖于<span class="hljs-keyword">node</span><span class="hljs-title">-sass</span>，所以还要安装<span class="hljs-keyword">node</span><span class="hljs-title">-sass</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: true,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: true,<br>    open: true,<br>    overlay: true,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-regexp">//</span> 会生成对于调试的完整的.map文件，但同时也会减慢打包速度<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-9-插件"><a href="#1-9-插件" class="headerlink" title="1.9 插件"></a>1.9 插件</h4><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。<br>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p><ol><li>使用插件</li></ol><p>如需使用某个插件，需要通过npm进行安装，然后在webpack.config.js配置文件的plugins配置项中添加该插件的实例，下面我们先来使用一个简单的版权声明插件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: true,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: true,<br>    open: true,<br>    overlay: true,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-regexp">//</span> 会生成对于调试的完整的.map文件，但同时也会减慢打包速度<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;,<br>  plugins: [<br>    new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>)  <span class="hljs-regexp">//</span> new一个插件的实例 <br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行npm run build 打包后，我们查看dist下面的bundle.js文件显示如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31dadb6c4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="2"><li>自动生成html文件（HtmlWebpackPlugin）</li></ol><p>到目前为止我们都是使用一开始建好的index.html文件，而且也是手动引入bundle.js，要是以后我们引入不止一个js文件，而且更改js文件名的话，也得手动更改index.html中的js文件名，所以能不能自动生成index.html且自动引用打包后的js呢？HtmlWebpackPlugin插件就是用来解决这个问题的</p><p>我们对项目结构进行一些更改：把整个dist文件夹删除；在src文件夹下新建一个index.html(名称自定义)文件模板（当然这个是可选的，因为就算不设置模板，HtmlWebpackPlugin插件也会生成默认html文件，这里我们设置模块会让我们的开发更加灵活），如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;root&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>复制代码<br></code></pre></td></tr></table></figure><p>安装HtmlWebpackPlugin插件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> html-webpack-plugin -D<br></code></pre></td></tr></table></figure><p>引入HtmlWebpackPlugin插件，并配置了引用了我们设置的模板，如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.join(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    hot: true,<br>    port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    inline: true,<br>    open: true,<br>    overlay: true,<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-regexp">//</span> 会生成对于调试的完整的.map文件，但同时也会减慢打包速度<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;,<br>  plugins: [<br>    new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>    new HtmlWebpackPlugin(&#123;<br>      template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行npm run build进行打包，dist文件夹自动生成，包含index.html、bundle.js、bundle.js.map三个文件</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c312cdd4f9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img">!</p><p>为什么会自动生成dist文件夹呢？因为我们在output出口配置项中定义了出口文件所在的位置为dist文件夹，且出口文件名为bundle.js，所以HtmlWebpackPlugin会自动帮你在 dist&#x2F;index.html 中引用名为bundle.js文件，如果你在webpack.config.js文件中更改了出口文件名，dist&#x2F;index.html 中也会自动更改该文件名，这样以后修改起来是不是方便多了？</p><ol start="3"><li>清理dist文件夹（CleanWebpackPlugin）</li></ol><p>webpack会生成文件，然后将这些文件放置在dist文件夹中，但是webpack无法追踪到哪些文件是实际在项目中用到的。通常，在每次构建前清理dist文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到CleanWebpackPlugin插件了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> clean-webpack-plugin -D<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-comment">// 这个插件不需要安装，是基于webpack的，需要引入webpack模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入HtmlWebpackPlugin插件</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">overlay</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-comment">// 正则匹配以.css结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-comment">// 正则匹配以.scss和.sass结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">BannerPlugin</span>(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-comment">// new一个插件的实例 </span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-comment">// new一个这个插件的实例，并传入相关的参数</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),  <span class="hljs-comment">// 默认删除output中path对应文件</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们每运行一次npm run build后就会发现，webpack会先将dist文件夹删除，然后再生产新的dist文件夹。</p><ol start="4"><li>热更新（HotModuleReplacementPlugin）</li></ol><p><strong>HotModuleReplacementPlugin</strong>是一个很实用的插件，可以在我们修改代码后自动刷新预览效果。</p><p>设置方法：</p><ol><li>devServer配置项中添加 hot：true 参数。</li><li>因为HotModuleReplacementPlugin是webpack模块自带的，所以引入webpack后，在plugins配置项中直接使用即可。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-comment">// 这个插件不需要安装，是基于webpack的，需要引入webpack模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入HtmlWebpackPlugin插件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CleanWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>    <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">overlay</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>, <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-comment">// 正则匹配以.css结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-comment">// 正则匹配以.scss和.sass结尾的文件</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-comment">// 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的</span><br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">BannerPlugin</span>(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-comment">// new一个插件的实例 </span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-comment">// new一个这个插件的实例，并传入相关的参数</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>([<span class="hljs-string">&#x27;dist&#x27;</span>]),  <span class="hljs-comment">// 所要清理的文件夹名称</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>() <span class="hljs-comment">// 热更新插件 </span><br>  ]<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>npm run dev 启动项目后，我们尝试着修改hello.js的内容，会发现浏览器预览效果会自动刷新</p><h4 id="1-10-项目优化及拓展"><a href="#1-10-项目优化及拓展" class="headerlink" title="1.10 项目优化及拓展"></a>1.10 项目优化及拓展</h4><ol><li>代码分离</li></ol><p>我们的webpack.config.js配置文件，其实也没配置多少东西就这么多了，要是以后增加了更多配置，岂不是看得眼花缭乱，所以最好的方法就是把它拆分，方便管理：</p><p>1、 我们在根目录下新建三个文件，分别为webpack.common.js、webpack.dev.js、webpack.prod.js分别代表公共配置文件、开发环境配置文件、生产环境（指项目上线时的环境）配置文件。</p><p>2、安装一个合并模块插件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> webpack-merge -D<br></code></pre></td></tr></table></figure><p>3、将webpack.config.js的代码拆分到上述新建的三个文件中，然后把将webpack.config.js文件删除，具体如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.common.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>module.exports = &#123;<br>  entry: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>), <span class="hljs-regexp">//</span> 入口文件<br>  output: &#123;<br>    path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>    filename: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>  &#125;,<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;<br>    ]<br>  &#125;,<br>  plugins: [<br>    new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>    new HtmlWebpackPlugin(&#123;<br>      template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>    &#125;),<br>    new webpack.HotModuleReplacementPlugin() <span class="hljs-regexp">//</span> 热更新插件 <br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// webpack.dev.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">merge</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);  <span class="hljs-comment">// 引入webpack-merge功能模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">common</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>); <span class="hljs-comment">// 引入webpack.common.js</span><br><br>module.exports = <span class="hljs-title function_ invoke__">merge</span>(common, &#123;   // 将webpack.common.js合并到当前文件<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_ invoke__">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>        <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>        <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">overlay</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.prod.js</span><br><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123; <span class="hljs-comment">// 将webpack.common.js合并到当前文件</span><br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),  <br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>4、设置package.json的scripts命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.prod.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --open --config webpack.dev.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>我们把build命令改为了webpack –config webpack.prod.js，意思是把打包配置指向webpack.prod.js配置文件，而之前我们只需要使用一个webpack 命令为什么就可以运行了？因为webpack 命令是默认指向webpack.config.js这个文件名称了，现在我们把文件名称改了，所以就需要自定义指向新的文件，dev命令中的指令也同理。</p><p>然后我们运行npm run build 和npm run dev，效果应该和我们分离代码前是一样的。</p><ol start="2"><li>多入口 多出口</li></ol><p>到目前为止我们都是一个入口文件和一个出口文件，要是我不止一个入口文件呢？下面我们来试试：</p><p>在webpack.common.js中的entry入口有三种写法，分别为字符串、数组和对象，平时我们用得比较多的是对象，所以我们把它改为对象的写法，首先我们在src文件夹下新建index2.js文件，名称任意。因为有多个入口，所以肯定得多个出口来进行一一对应了，所以entry和output配置如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">entry:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    index:</span> path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>),<br><span class="hljs-symbol">    index2:</span> path.join(__dirname, <span class="hljs-string">&quot;/src/index2.js&quot;</span>)<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">output:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    path:</span> path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-comment">// 打包后的文件存放的地方 </span><br><span class="hljs-symbol">    filename:</span> <span class="hljs-string">&quot;[name].js&quot;</span> <span class="hljs-comment">// 打包后输出文件的文件名</span><br><span class="hljs-punctuation">&#125;</span>,<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index2.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">page2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;我是第二个入口文件&#x27;</span>;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>).<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">page2</span>());<br></code></pre></td></tr></table></figure><p>然后我们运行npm run build打包后发现dist文件夹下会多出index2.js文件，同时index.html也会自动将index2.js引入，然后我们运行npm run dev显示如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31dcc0a82~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="3"><li>分离css</li></ol><p>webpack的理念是把css、js全都打包到一个文件里，但要是我们想把css分离出来该怎么做呢？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install extract-text-webpack-plugin@<span class="hljs-keyword">next</span> -D  <span class="hljs-regexp">//</span> 加上@<span class="hljs-keyword">next</span>是为了安装最新的，否则会出错<br></code></pre></td></tr></table></figure><p>安装完以上插件后在webpack.common.js文件中引入并使用该插件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.common.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>const ExtractTextPlugin = require(<span class="hljs-string">&#x27;extract-text-webpack-plugin&#x27;</span>) <span class="hljs-regexp">//</span>引入分离插件<br>module.exports = &#123;<br>    entry: &#123;<br>        index: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>),<br>        index2: path.join(__dirname, <span class="hljs-string">&quot;/src/index2.js&quot;</span>)<br>    &#125;,<br>    output: &#123;<br>        path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>        filename: <span class="hljs-string">&quot;[name].js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>    &#125;,<br>    module: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>                use: ExtractTextPlugin.extract(&#123;  <span class="hljs-regexp">//</span> 这里我们需要调用分离插件内的extract方法<br>                    fallback: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 相当于回滚，经css-loader处理过的css最终再经过style-loader处理<br>                    use: [<span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>                &#125;)<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>            &#125;<br>        ]<br>    &#125;,<br>    plugins: [<br>        new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>        new HtmlWebpackPlugin(&#123;<br>            template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>        &#125;),<br>        new webpack.HotModuleReplacementPlugin(), <span class="hljs-regexp">//</span> 热更新插件<br>        new ExtractTextPlugin(<span class="hljs-string">&#x27;css/index.css&#x27;</span>) <span class="hljs-regexp">//</span> 将css分离到/dist文件夹下的css文件夹中的index.css <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行npm run build后会发现dist文件夹下多一个css文件</p><ol start="4"><li>消除冗余的css</li></ol><p>有时候我们css写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，上线前又忘了检查，对于这方面，我们应该尽量去优化它，webpack就有这个功能。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> purifycss-webpack purify-css glob -D复制代码<br></code></pre></td></tr></table></figure><p>安装完后在webpack.prod.js文件中进行配置，引入purifycss-webpack和glob插件并使用它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.prod.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 引入CleanWebpackPlugin插件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">PurifyCssWebpack</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;purifycss-webpack&#x27;</span>); <span class="hljs-comment">// 引入PurifyCssWebpack插件</span><br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>);  <span class="hljs-comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common, &#123; <span class="hljs-comment">// 将webpack.common.js合并到当前文件</span><br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurifyCssWebpack</span>(&#123;<br>            <span class="hljs-attr">paths</span>: glob.<span class="hljs-title function_">sync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;src/*.html&#x27;</span>)) <span class="hljs-comment">// 同步扫描所有html文件中所引用的css</span><br>        &#125;)<br>    ]<br>&#125;)复制代码<br></code></pre></td></tr></table></figure><p>我们在index.css文件中增加一些多余的代码试试：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* index.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: gray;<br>&#125;<br><br><span class="hljs-comment">/* 冗余css */</span><br><span class="hljs-selector-class">.a</span> &#123;<br>    <span class="hljs-attribute">color</span>: black;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 冗余css */</span><br><span class="hljs-selector-class">.b</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">border</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们运行npm run build后发现打包后的index.css中是没有多余的<code>.a</code>和<code>.b</code>代码的：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31db42cc2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ol start="5"><li>处理图片</li></ol><p>如果要使用图片，我们得安装两个loader</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">// 虽然我们只需使用url-loader，但url-loader是依赖于<span class="hljs-keyword">file</span>-loader的，所以也要安装<br>npm <span class="hljs-keyword">install</span> url-loader <span class="hljs-keyword">file</span>-loader -D 复制代码<br></code></pre></td></tr></table></figure><p>然后在webpack.common.js中配置url-loader</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.common.js<br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>);  <span class="hljs-regexp">//</span> 这个插件不需要安装，是基于webpack的，需要引入webpack模块<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-regexp">//</span> 引入HtmlWebpackPlugin插件<br>const ExtractTextPlugin = require(<span class="hljs-string">&#x27;extract-text-webpack-plugin&#x27;</span>) <span class="hljs-regexp">//</span>引入分离插件<br>module.exports = &#123;<br>    entry: &#123;<br>        index: path.join(__dirname, <span class="hljs-string">&quot;/src/index.js&quot;</span>),<br>        index2: path.join(__dirname, <span class="hljs-string">&quot;/src/index2.js&quot;</span>)<br>    &#125;,<br>    output: &#123;<br>        path: path.join(__dirname, <span class="hljs-string">&quot;/dist&quot;</span>), <span class="hljs-regexp">//</span> 打包后的文件存放的地方 <br>        filename: <span class="hljs-string">&quot;[name].js&quot;</span> <span class="hljs-regexp">//</span> 打包后输出文件的文件名<br>    &#125;,<br>    module: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>                use: ExtractTextPlugin.extract(&#123;  <span class="hljs-regexp">//</span> 这里我们需要调用分离插件内的extract方法<br>                    fallback: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 相当于回滚，经css-loader处理过的css最终再经过style-loader处理<br>                    use: [<span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>                &#125;)<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(png|jpg|svg|gif)$/</span>,  <span class="hljs-regexp">//</span> 正则匹配图片格式名<br>                use: [<br>                    &#123; loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>  <span class="hljs-regexp">//</span> 使用url-loader &#125;<br>                ]<br>            &#125;,<br>        ]<br>    &#125;,<br>    plugins: [<br>        new webpack.BannerPlugin(<span class="hljs-string">&#x27;版权所有，翻版必究&#x27;</span>),  <span class="hljs-regexp">//</span> new一个插件的实例 <br>        new HtmlWebpackPlugin(&#123;<br>            template: path.join(__dirname, <span class="hljs-string">&quot;/src/index.html&quot;</span>)<span class="hljs-regexp">//</span> new一个这个插件的实例，并传入相关的参数<br>        &#125;),<br>        new webpack.HotModuleReplacementPlugin(), <span class="hljs-regexp">//</span> 热更新插件<br>        new ExtractTextPlugin(<span class="hljs-string">&#x27;css/index.css&#x27;</span>) <span class="hljs-regexp">//</span> 将css分离到/dist文件夹下的css文件夹中的index.css <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把index.css的背景改为图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* index.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./images/bg.jpg&#x27;</span>) no-repeat;<br>    <span class="hljs-attribute">background-size</span>: <span class="hljs-number">200px</span> <span class="hljs-number">250px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;复制代码<br></code></pre></td></tr></table></figure><p>运行npm run dev 后显示如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c31f9e3bce~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们会发现背景图片变成了base64，因为webpack会自动优化图片，减少发送请求，但是如果我想把它变成路径的该怎么做？</p><p>我们可以把webpack.common.js的loader配置更改一下，增加options选项：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk">module: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.css结尾的文件<br>        use: ExtractTextPlugin.extract(&#123;  <span class="hljs-regexp">//</span> 这里我们需要调用分离插件内的extract方法<br>          fallback: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 相当于回滚，经css-loader处理过的css最终再经过style-loader处理<br>          use: [<span class="hljs-string">&#x27;css-loader&#x27;</span>],<br>          publicPath: <span class="hljs-string">&#x27;../&#x27;</span>  <span class="hljs-regexp">//</span> 给背景图片设置一个公共路径<br>        &#125;)<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(scss|sass)$/</span>,   <span class="hljs-regexp">//</span> 正则匹配以.scss和.sass结尾的文件<br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>],  <span class="hljs-regexp">//</span> 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(png|jpg|svg|gif)$/</span>,  <span class="hljs-regexp">//</span> 正则匹配图片格式名<br>        use: [<br>          &#123;<br>            loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,  <span class="hljs-regexp">//</span> 使用url-loader<br>            options: &#123;<br>              limit: <span class="hljs-number">1000</span>,  <span class="hljs-regexp">//</span> 限制只有小于<span class="hljs-number">1</span>kb的图片才转为base64，例子图片为<span class="hljs-number">1.47</span>kb,所以不会被转化<br>              outputPath: <span class="hljs-string">&#x27;images&#x27;</span>,  <span class="hljs-regexp">//</span> 设置打包后图片存放的文件夹名称<br>            &#125;,<br>          &#125;<br>        ]<br>      &#125;,<br>    ]<br>  &#125;,<br></code></pre></td></tr></table></figure><ol start="6"><li>压缩代码</li></ol><p>在webpack4.x版本中当你打包时会自动把js压缩了，而且npm run dev运行服务器时，当你修改代码时，热更新很慢，这是因为你修改后webpack又自动为你打包，这就导致了在开发环境中效率很慢，所以我们需要把开发环境和生产环境区分开来，这时就体现出我们代码分离的便捷性了，webpack.dev.js代表开发环境的配置，webpack.prod.js代表生产环境的配置，这时我们只要在package.json文件中配置对应环境的命令即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.prod.js --mode production&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --open --config webpack.dev.js --mode development&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>复制代码<br></code></pre></td></tr></table></figure><p>–mode production表示打包时是生产环境，会自己将js进行压缩，而–mode development表示当前是开发环境，不需要进行压缩。这同时也解决了之前一直遗留的警告问题</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/24/16f374c336f83e41~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>因为webpack版本变更，上文部分内容无法在webpack 5+版本复现，但功能一脉相承，经实验，将可运行的webpack版本传至<a href="github.com/azureabaaba/webpack">此处</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用操作</title>
    <link href="/blog/2022/11/09/git/"/>
    <url>/blog/2022/11/09/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git常用操作"><a href="#git常用操作" class="headerlink" title="git常用操作"></a>git常用操作</h1><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1391668002121_.pic-20221109%2022:00:14.jpg" alt="1391668002121_.pic"></p><h3 id="1-git配置"><a href="#1-git配置" class="headerlink" title="1 git配置"></a>1 git配置</h3><ol><li>安装Git：<a href="https://link.zhihu.com/?target=https://git-scm.com/">https://git-scm.com/</a></li><li>本地命令行生成密钥绑定GitHub账号</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输入命令生成密钥对，替换成自己邮箱，然后一路回车</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br><br><span class="hljs-comment"># 将生成的公钥打印出来复制，将这串文本复制粘贴到GitHub的Setting-&gt;SSH and GPG keys中</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br><br><span class="hljs-comment"># 输入命令检查是否绑定成功,输入yes后，如果出现Hi,xxx!则绑定成功</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>\3. 配置用户名和邮箱信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看配置信息，一开始为空</span><br>git config --list<br><br><span class="hljs-comment"># 全局配置，对所有代码库生效</span><br>git config --global user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br><br><br><span class="hljs-comment"># 局部配置，只对当前的代码库有效</span><br>git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config --<span class="hljs-built_in">local</span> user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br><br><span class="hljs-comment"># 配置后，远程仓库提交的commit里对应的用户即为 user.name</span><br></code></pre></td></tr></table></figure><h3 id="2-git基本概念"><a href="#2-git基本概念" class="headerlink" title="2 git基本概念"></a>2 git基本概念</h3><ol><li>本地仓库：本地仓库上存放所有相关的文件，具体可分为工作区、暂存区和仓库区，工作区即项目文件夹下不包含<code>.git</code>文件夹的所有文件，暂存区和仓库区则在<code>.git</code>文件夹下</li><li>工作区：即我们工作的文件夹，在里面进行文件的增删改操作</li><li>暂存区：临时保存工作区上的改动，通过<code>git add</code>操作将工作区的修改同步到暂存区</li><li>仓库区：当执行<code>git commit</code>操作时，将暂存区上的所有变动同步到本地仓库</li><li>远程仓库：GitHub&#x2F;GitLab上保存的仓库，通过<code>git push</code>将本地仓库同步到远程仓库，也可以通过<code>git fetch/pull</code>将远程仓库同步到本地仓库</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1411668002121_.pic-20221109%2022:00:35.jpg" alt="1411668002121_.pic"></p><h3 id="3-git基本操作"><a href="#3-git基本操作" class="headerlink" title="3 git基本操作"></a>3 git基本操作</h3><p><strong>创建版本库</strong></p><p>创建版本库有两种方式，一种是将本地的文件夹直接变成一个git仓库，另一种是直接将远程的仓库克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init <span class="hljs-comment"># 将本地文件夹变为一个git仓库</span><br>git <span class="hljs-built_in">clone</span> &lt;url&gt; <span class="hljs-comment">#将远程仓库克隆到本地</span><br></code></pre></td></tr></table></figure><p><strong>修改与提交操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;file&gt; <span class="hljs-comment"># 将单个文件从工作区添加到暂存区</span><br>git add . <span class="hljs-comment"># 将所有文件添加到暂存区</span><br>git commit -m <span class="hljs-string">&quot;messenge&quot;</span> <span class="hljs-comment"># 将暂存区文件提交到本地仓库</span><br>git status <span class="hljs-comment"># 查看工作区状态，显示有变更的文件。</span><br>git diff <span class="hljs-comment"># 比较文件的不同，即暂存区和工作区的差异。</span><br></code></pre></td></tr></table></figure><p><strong>远程操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master <span class="hljs-comment"># 将本地的master分支推送到远程对应的分支</span><br>git pull  <span class="hljs-comment"># 下载远程代码并合并，相当于git fetch + git pull</span><br>git fetch   <span class="hljs-comment"># 从远程获取代码库，但不进行合并操作</span><br><br>git remote add origin &lt;url&gt; <span class="hljs-comment"># 将远程仓库与本地仓库关联起来</span><br>git remote -v <span class="hljs-comment"># 查看远程库信息</span><br></code></pre></td></tr></table></figure><p><strong>撤销与回退操作</strong></p><p>撤销操作：当修改了工作区&#x2F;暂存区的文件，但是还没有commit时，想要撤销之前的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 场景1：当你改乱了工作区某个文件的内容，但还没有add到暂存区</span><br>git checkout &lt;file&gt; <span class="hljs-comment"># 撤销工作区的某个文件到和暂存区一样的状态</span><br><br><span class="hljs-comment"># 场景2：当乱改了工作区某个文件的内容，并且git add到了暂存区</span><br>git reset HEAD &lt;file&gt; <span class="hljs-comment"># 第1步，将暂存区的文件修改撤销掉</span><br>git checkout &lt;file&gt; <span class="hljs-comment"># 第2步，将工作区的文件修改撤销掉</span><br><br><span class="hljs-comment"># 场景3：乱改了很多文件，想回到最新一次提交时的状态</span><br>git reset --hard HEAD <span class="hljs-comment"># 撤销工作区中所有未提交文件的修改内容</span><br></code></pre></td></tr></table></figure><p>回退操作：当已经进行了commit操作，需要回退到之前的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^ <span class="hljs-comment"># 回退到上次提交的状态</span><br>git reset --hard HEAD~n <span class="hljs-comment"># 回退到n个版本前的状态</span><br>git reset --hard HEAD commitid <span class="hljs-comment"># 回退到某一个commitid的状态</span><br>git reset --soft HEAD commitid <span class="hljs-comment"># 回退到某一个commitid的状态，并且保留暂存区的内容</span><br>git reset --mixed(默认) HEAD commitid <span class="hljs-comment"># 回退到某一个commitid的状态，并且保留工作区的内容</span><br></code></pre></td></tr></table></figure><p>关于reset三种模式的说明：</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1421668002121_.pic-20221109%2022:00:46.jpg" alt="1421668002121_.pic"></p><h3 id="4-git分支管理"><a href="#4-git分支管理" class="headerlink" title="4 git分支管理"></a>4 git分支管理</h3><p>git的最强大之处就在于分支管理了，具体有两种应用场景：</p><ol><li>多人协作：每个人都基于主分支创建一个自己的分支，在分支上进行开发，然后再不断将写好的代码合并到主分支</li><li>自己修复bug&#x2F;增加feature：创建一个bug分支或者feature分支，写好代码后合并到自己的分支然后删除bug&#x2F;feature分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch &lt;name&gt; <span class="hljs-comment"># 创建分支</span><br>git checkout &lt;name&gt; <span class="hljs-comment"># 切换到某个分支</span><br>git checkout -b &lt;name&gt; <span class="hljs-comment"># 创建并切换到新分支，相当于同时执行了以上两个命令</span><br>git merge &lt;name&gt; <span class="hljs-comment"># 合并某个分支到当前分支中，默认fast forward</span><br>git branch -a <span class="hljs-comment"># 查看所有分支</span><br>git branch -d &lt;name&gt; <span class="hljs-comment"># 删除分支</span><br></code></pre></td></tr></table></figure><h3 id="5-git多人协作"><a href="#5-git多人协作" class="headerlink" title="5 git多人协作"></a>5 git多人协作</h3><p>多人协作在同一个分支上进行开发的工作模式：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li><li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li></ol><h3 id="6-git服务器搭建"><a href="#6-git服务器搭建" class="headerlink" title="6 git服务器搭建"></a>6 git服务器搭建</h3><p>自己搭建一台 Git 服务器作为私有仓库使用，以 Centos 为例搭建 Git 服务器</p><p>安装git</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>yum <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><p>创建一个git用户组和用户，用来运行git服务：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">groupadd git</span><br><span class="hljs-attribute">useradd git -g git</span><br></code></pre></td></tr></table></figure><p>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件里，一行一个。</p><p>如果没有该文件创建它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/git/<br><span class="hljs-built_in">mkdir</span> .ssh<br><span class="hljs-built_in">chmod</span> 755 .ssh<br><span class="hljs-built_in">touch</span> .ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 644 .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>首先我们选定一个目录作为Git仓库，假定是&#x2F;home&#x2F;gitrepo&#x2F;runoob.git，在&#x2F;home&#x2F;gitrepo目录下输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /home</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> gitrepo</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> git:git gitrepo/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> gitrepo</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init --bare runoob.git</span><br>Initialized empty Git repository in /home/gitrepo/runoob.git/<br></code></pre></td></tr></table></figure><p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> -R git:git runoob.git</span><br></code></pre></td></tr></table></figure><p>克隆仓库</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git clone git<span class="hljs-variable">@192</span>.<span class="hljs-number">168.45</span>.<span class="hljs-number">4</span><span class="hljs-symbol">:/home/gitrepo/runoob</span>.git<br><span class="hljs-title class_">Cloning</span> into <span class="hljs-string">&#x27;runoob&#x27;</span>...<br><span class="hljs-symbol">warning:</span> <span class="hljs-title class_">You</span> appear to have cloned an empty repository.<br><span class="hljs-title class_">Checking</span> connectivity... done.<br></code></pre></td></tr></table></figure><p>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p><p>这样我们的 Git 服务器安装就完成。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript</title>
    <link href="/blog/2022/11/04/Typescript/"/>
    <url>/blog/2022/11/04/Typescript/</url>
    
    <content type="html"><![CDATA[<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><p>辅助React（？）</p><h3 id="1-尝试ts"><a href="#1-尝试ts" class="headerlink" title="1 尝试ts"></a>1 尝试ts</h3><p><code>npm i -g typescript</code>：全局安装typescript</p><p><code>tsc --init</code>：初始化，生成tsconfig.json</p><p><code>tsc</code>：将ts文件转换为js文件</p><p><code>tsc -w</code>：自动编译：每当文件保存就会自动编译成js文件</p><h3 id="2-变量声明"><a href="#2-变量声明" class="headerlink" title="2 变量声明"></a>2 变量声明</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> url : <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;https://api.thecatapi.com/v1/images/search&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">button</span>: <span class="hljs-title class_">HTMLButtonElement</span> | <span class="hljs-literal">null</span>  = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-接口和实现"><a href="#3-接口和实现" class="headerlink" title="3 接口和实现"></a>3 接口和实现</h3><p>定义任何东西的时候要注明类型，调用任何东西的时候要检查类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CatType</span> &#123;<br>    id : <span class="hljs-built_in">string</span>;<br>    url : <span class="hljs-built_in">string</span>;<br>    height : <span class="hljs-built_in">number</span>;<br>    width : <span class="hljs-built_in">number</span>;<br>    test? : <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CatType</span> &#123;<br>    id : <span class="hljs-built_in">string</span>;<br>    url : <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, url: <span class="hljs-built_in">string</span>, height: <span class="hljs-built_in">number</span>, width: <span class="hljs-built_in">number</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-修饰符、函数类型"><a href="#4-修饰符、函数类型" class="headerlink" title="4 修饰符、函数类型"></a>4 修饰符、函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebDisplay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">addData</span>(<span class="hljs-attr">data</span>:<span class="hljs-title class_">CatType</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">cat</span>: <span class="hljs-title class_">Cat</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(data.<span class="hljs-property">id</span>, data.<span class="hljs-property">url</span>, data.<span class="hljs-property">height</span>, data.<span class="hljs-property">width</span>);<br>        <span class="hljs-keyword">const</span> tableRow : <span class="hljs-title class_">HTMLTableRowElement</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;tr&#x27;</span>);<br>        tableRow.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.id&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;&lt;img src=&quot;<span class="hljs-subst">$&#123;cat.url&#125;</span>&quot; alt=&quot;cat&quot;&gt;&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.height.toString()&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.width.toString()&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;<span class="hljs-subst">$&#123;cat.url&#125;</span>&lt;/td&gt;</span><br><span class="hljs-string">            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;X&lt;/a&gt;&lt;/td&gt;</span><br><span class="hljs-string">        `</span>;<br>        tableBody?.<span class="hljs-title function_">appendChild</span>(tableRow);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">deleteData</span>(<span class="hljs-attr">deleteButton</span>: <span class="hljs-title class_">HTMLAnchorElement</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> td = deleteButton.<span class="hljs-property">parentElement</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLTableCellElement</span>;<br>        <span class="hljs-keyword">const</span> tr = td.<span class="hljs-property">parentElement</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLTableRowElement</span>;<br>        tr.<span class="hljs-title function_">remove</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-fetch入门：接收api的数据"><a href="#5-fetch入门：接收api的数据" class="headerlink" title="5 fetch入门：接收api的数据"></a>5 fetch入门：接收api的数据</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> getJSON&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">Response</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">json</span>: <span class="hljs-title class_">Promise</span>&lt;T&gt; = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> json;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>):<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> json : <span class="hljs-title class_">CatType</span>[] = <span class="hljs-keyword">await</span> getJSON&lt;<span class="hljs-title class_">CatType</span>[]&gt;(url);<br>        <span class="hljs-keyword">const</span> data : <span class="hljs-title class_">CatType</span> = json[<span class="hljs-number">0</span>];<br>        <span class="hljs-title class_">WebDisplay</span>.<span class="hljs-title function_">addData</span>(data);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (<span class="hljs-attr">error</span>: <span class="hljs-title class_">Error</span> | <span class="hljs-built_in">unknown</span>) &#123;<br>        <span class="hljs-keyword">let</span> message : <span class="hljs-built_in">string</span>;<br>        <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) &#123;<br>            message = error.<span class="hljs-property">message</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-title class_">String</span>(error);<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-利用事件冒泡添加事件监听"><a href="#6-利用事件冒泡添加事件监听" class="headerlink" title="6 利用事件冒泡添加事件监听"></a>6 利用事件冒泡添加事件监听</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript">button?.<span class="hljs-property">addEventListener</span>&lt;<span class="hljs-string">&#x27;click&#x27;</span>&gt;(<span class="hljs-string">&#x27;click&#x27;</span>, getData);<br><br>tableBody?.<span class="hljs-property">addEventListener</span>&lt;<span class="hljs-string">&#x27;click&#x27;</span>&gt;(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ev: MouseEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">WebDisplay</span>.<span class="hljs-title function_">deleteData</span>(&lt;<span class="hljs-title class_">HTMLAnchorElement</span>&gt;ev.<span class="hljs-property">target</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="7-限定回调函数的参数和返回值"><a href="#7-限定回调函数的参数和返回值" class="headerlink" title="7 限定回调函数的参数和返回值"></a>7 限定回调函数的参数和返回值</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserName</span>(<span class="hljs-params">callback: (data: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">void</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-title function_">getUserName</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(data);<br>&#125;);<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-title function_">getUserName</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(data*<span class="hljs-number">2</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="8-类型别名"><a href="#8-类型别名" class="headerlink" title="8 类型别名"></a>8 类型别名</h3><p>针对复杂的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UserID</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params">userId: UserID</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-小技巧"><a href="#9-小技巧" class="headerlink" title="9 小技巧"></a>9 小技巧</h3><ol><li>在tsconfig中配置一个额外的选项：<code>&quot;noImplicitAny&quot;: true</code>，让编译器对类型做更加严格的验证</li><li>在tsconfig中配置一个额外的选项：<code>&quot;strictNullChecks&quot;: true</code>，除非明确指定值可以为空，否则赋予空值是非法的</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 指定</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 不指定</span><br><span class="hljs-keyword">let</span> s : <span class="hljs-built_in">string</span>;<br>s = <span class="hljs-string">&#x27;azure&#x27;</span>;<br>s = <span class="hljs-literal">null</span>;<br>s = undefine;<br></code></pre></td></tr></table></figure><ol start="3"><li>在使用第三方库时，可能库本身不是用ts编写的，但又想使用ts提供更完善的类型支持，可以安装由社区维护的类型定义包（DefinitelyTyped&#x2F;DefinitelyTyped），例如使用<code>npm install --save-dev @types/three</code>&#x2F;<code>npm install three --save</code></li></ol><h3 id="10-常用数据类型"><a href="#10-常用数据类型" class="headerlink" title="10 常用数据类型"></a>10 常用数据类型</h3><p>基础类型</p><ul><li>常用：boolean、number、string、array、enum、any、void</li><li>不常用：tuple、null、undefined、never</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">20210701</span>;<br></code></pre></td></tr></table></figure><p>对象类型</p><p>简单理解interface 和 type 的区别：type 更强大，interface 可以进行<code>声明合并</code>，type 不行；一般声明都用interface，需要用到其他变量类型，type多一些。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hero</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>;<br>  skinNum?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">say</span>(): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// say函数返回值为string</span><br>  [<span class="hljs-attr">propname</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// 当前Hero可定义任意字符串类型的key</span><br>&#125;<br><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">interface</span> littleSoldier <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span> &#123;<br>  <span class="hljs-title function_">rush</span>(): <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-comment">// 任意类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAnyObject</span> &#123;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Hero</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>,<br>  skinNum?: <span class="hljs-built_in">number</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>数组类型</p><p>项目中常见的写法，需要声明<code>列表数据</code>类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IItem</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">isGod</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">objectArr</span>: <span class="hljs-title class_">IItem</span>[] = [&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;az&#x27;</span>, <span class="hljs-attr">isGod</span>: <span class="hljs-literal">true</span> &#125;];<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">objectArr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">IItem</span>&gt; = [&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;az&#x27;</span>, <span class="hljs-attr">isGod</span>: <span class="hljs-literal">true</span> &#125;];<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">numberArr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>元组tuple</p><p>元组和数组类似，但是类型注解时会不一样，赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 数组 某个位置的值可以是注解中的任何一个</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">LOL</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-string">&quot;zed&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;darts&quot;</span>];<br><br><span class="hljs-comment">// 元祖 每一项数据类型必须一致</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">LOL</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&quot;zed&quot;</span>, <span class="hljs-string">&quot;darts&quot;</span>, <span class="hljs-number">25</span>];<br></code></pre></td></tr></table></figure><p>联合 | or 交叉&amp;类型</p><ul><li>联合类型：某个变量可能是多个 interface 中的其中一个，用 <code>|</code> 分割</li><li>交叉类型：由多个类型组成，用 <code>&amp;</code> 连接</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Waiter</span> &#123;<br>  <span class="hljs-attr">anjiao</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">say</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Teacher</span> &#123;<br>  <span class="hljs-attr">anjiao</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">skill</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWho</span>(<span class="hljs-params">animal: Waiter | Teacher</span>) &#123;&#125;<br><span class="hljs-comment">// 交叉类型 </span><br><span class="hljs-comment">// 同名类型会进行合并，同名基础类型属性的合并返回：never</span><br><span class="hljs-comment">// 同名非基础类型属性可以正常合并</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWho</span>(<span class="hljs-params">jishi: Waiter &amp; Teacher</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>enum枚举</p><p>提高代码可维护性，统一维护某些枚举值，避免 <code>JiShi === 1</code>这种魔法数字。<code>JiShi === JiShiEnum.BLUEJ</code>这样写，老板一眼就知道我想找谁。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 初始值默认为 0</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JiShiEnum</span> &#123;<br>     <span class="hljs-variable constant_">REDJ</span>,<br>     <span class="hljs-variable constant_">BLUEJ</span>,<br>     <span class="hljs-variable constant_">GREENJ</span>,<br>&#125;<br><span class="hljs-comment">// 设置初始值</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JiShiEnum</span> &#123;<br>     <span class="hljs-variable constant_">REDJ</span> = <span class="hljs-number">8</span>,<br>     <span class="hljs-variable constant_">BLUEJ</span>,<br>     <span class="hljs-variable constant_">GREENJ</span>,<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">jishi</span>: <span class="hljs-title class_">JiShiEnum</span> = <span class="hljs-title class_">JiShiENUM</span>.<span class="hljs-property">BLUE</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jishi) <span class="hljs-comment">// 9</span><br><span class="hljs-comment">// 字符串枚举，每个都需要声明</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">JiShiEnum</span> &#123;<br>     <span class="hljs-variable constant_">REDJ</span> = <span class="hljs-string">&quot;8号&quot;</span>,<br>     <span class="hljs-variable constant_">BLUEJ</span> = <span class="hljs-string">&quot;9号&quot;</span>,<br>     <span class="hljs-variable constant_">GREENJ</span> = <span class="hljs-string">&quot;10号&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型T(Type)</p><p>简单说就是：泛指的类型，不确定的类型，可以理解为一个<code>占位符</code>（使用T只是习惯，使用任何字母都行）</p><ul><li>K（Key）：表示对象中的键类型；</li><li>V（Value）：表示对象中的值类型；</li><li>E（Element）：表示元素类型。</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// T 自定义名称</span><br><span class="hljs-keyword">function</span> myFun&lt;T&gt;(<span class="hljs-attr">params</span>: T[]) &#123;<br>  <span class="hljs-keyword">return</span> params;<br>&#125;<br>myFun &lt;<span class="hljs-built_in">string</span>&gt; ([<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>]);<br><br><span class="hljs-comment">// 定义多个泛型</span><br><span class="hljs-keyword">function</span> join&lt;T, P&gt;(<span class="hljs-attr">first</span>: T, <span class="hljs-attr">second</span>: P) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;first&#125;</span><span class="hljs-subst">$&#123;second&#125;</span>`</span>;<br>&#125;<br>join &lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt; (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>);<br></code></pre></td></tr></table></figure><p>断言</p><p>断言用来手动指定一个值的类型。<code>值 as 类型</code> or <code>&lt;类型&gt;值</code></p><p>注意在 tsx 语法中必须使用前者，即 值 as 类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWho</span>(<span class="hljs-params">animal: Waiter | Teacher</span>) &#123;<br>  <span class="hljs-keyword">if</span> (animal.<span class="hljs-property">anjiao</span>) &#123;<br>    (animal <span class="hljs-keyword">as</span> <span class="hljs-title class_">Teacher</span>).<span class="hljs-title function_">skill</span>();<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    (animal <span class="hljs-keyword">as</span> <span class="hljs-title class_">Waiter</span>).<span class="hljs-title function_">say</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>in</p><p>在做类型保护事件，类似于数组和字符串的 <code>includes</code> 方法</p><p>也有遍历的作用，拿到ts类型定义的Key，获取Key还有个方法：keyof是取类型的key的联合类型 , in是遍历类型的key</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeWhoTwo</span>(<span class="hljs-params">animal: Waiter | Teacher</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;skill&quot;</span> <span class="hljs-keyword">in</span> animal) &#123;<br>    animal.<span class="hljs-title function_">skill</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    animal.<span class="hljs-title function_">say</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>void和never</p><p>返回值类型，也算是基础类型。没有返回值的函数: void</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个函数是永远也执行不完的，就可以定义返回值为 never</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">errorFuntion</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个函数有入参，也有出参，项目中的常规写法：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 定义一个小姐姐</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGirl</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">isAnMo</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">number</span>: <span class="hljs-title class_">JiShiEnum</span>;<br>&#125;;<br><span class="hljs-comment">// 定义搜索小姐姐的入参</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISearchParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IGirl</span>&#123;<br>  <span class="hljs-attr">serviceTime</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGetGirls</span> &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-title class_">IGirl</span>[];<br>&#125;<br><span class="hljs-comment">// 函数主体</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getGirls</span>(<span class="hljs-params">data: ISearchParams</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">IGetGirls</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`/dabaojian/getGirls`</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    data,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-类型检测"><a href="#11-类型检测" class="headerlink" title="11 类型检测"></a>11 类型检测</h3><p>typeof</p><p>typeof 操作符可以用来获取一个变量或对象的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hero</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">skill</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">zed</span>: <span class="hljs-title class_">Hero</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;影流之主&quot;</span>, <span class="hljs-attr">skill</span>: <span class="hljs-string">&quot;影子&quot;</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">LOL</span> = <span class="hljs-keyword">typeof</span> zed; <span class="hljs-comment">// type LOL = Hero</span><br></code></pre></td></tr></table></figure><p>在上面代码中，我们通过 typeof 操作符获取 zed 变量的类型并赋值给 LOL 类型变量，之后我们就可以使用 LOL 类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-attr">ahri</span>: <span class="hljs-variable constant_">LOL</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;阿狸&quot;</span>, <span class="hljs-attr">skill</span>: <span class="hljs-string">&quot;魅惑&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>instanceof</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberObj</span> &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addObj</span>(<span class="hljs-params">first: <span class="hljs-built_in">object</span> | NumberObj, second: <span class="hljs-built_in">object</span> | NumberObj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">NumberObj</span> &amp;&amp; second <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">NumberObj</span>) &#123;<br>    <span class="hljs-keyword">return</span> first.<span class="hljs-property">count</span> + second.<span class="hljs-property">count</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>keyof</p><p>keyof 与 Object.keys 略有相似，只不过 keyof 取 interface 的键</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">// type keys = &quot;x&quot; | &quot;y&quot;</span><br><span class="hljs-keyword">type</span> keys = keyof <span class="hljs-title class_">Point</span>;<br></code></pre></td></tr></table></figure><p>用keyof可以更好的定义数据类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> get&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">o</span>: T, <span class="hljs-attr">name</span>: K): T[K] &#123;<br>  <span class="hljs-keyword">return</span> o[name]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-ts类里的关键字"><a href="#12-ts类里的关键字" class="headerlink" title="12 ts类里的关键字"></a>12 ts类里的关键字</h3><p>public</p><p>private 类的外部不可用，继承也不行</p><p>protected 类的外部不可用，继承可以</p><p>public readOnly xxx 只读属性</p><p>static funcXXX 静态方法，不需要 new 就可以调用</p><p>abstract funcXXX 抽象类，所有子类都必须要实现 funcXXX</p><h3 id="13-Utility-Type"><a href="#13-Utility-Type" class="headerlink" title="13 Utility Type"></a>13 Utility Type</h3><p><code>Partial&lt;T&gt;</code>：将T中所有属性转换为可选属性。返回的类型可以是T的任意子集</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserModel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">sex</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">UserModel</span>&gt;<br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel</span> = &#123;<br>    name?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>    age?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>    sex?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 源码解析</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="hljs-keyword">in</span> keyof T]?: T[P]; &#125;;<br></code></pre></td></tr></table></figure><p><code>Required&lt;T&gt;</code>：通过将T的所有属性设置为必选属性来构造一个新的类型。与Partial相反</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel2</span> = <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">UserModel</span>&gt;<br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel2</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">sex</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Readonly&lt;T&gt;</code>：将T中所有属性设置为只读</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel3</span> = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">UserModel</span>&gt;<br><br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JUserModel3</span> = &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">readonly</span> age?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">sex</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Record&lt;K,T&gt;</code>：构造一个类型，该类型具有一组属性K，每个属性的类型为T。可用于将一个类型的属性映射为另一个类型。Record 后面的泛型就是对象键和值的类型。</p><p>简单理解：K对应对应的key，T对应对象的value，返回的就是一个声明好的对象</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoProperty</span> = <span class="hljs-string">&#x27;title&#x27;</span> | <span class="hljs-string">&#x27;description&#x27;</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Todo</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">TodoProperty</span>, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Todo</span> = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGirl</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> allGirls = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">IGirl</span>&gt;<br></code></pre></td></tr></table></figure><p><code>Pick&lt;T,K&gt;</code>：在一个声明好的对象中，挑选一部分出来组成一个新的声明对象</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoBase</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;title&quot;</span> | <span class="hljs-string">&quot;done&quot;</span>&gt;;<br><br><span class="hljs-comment">// =</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoBase</span> = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Omit&lt;T,K&gt;</code>：从T中取出除去K的其他所有属性。与Pick相对。</p><p><code>Exclude&lt;T,U&gt;</code>：从T中排除可分配给U的属性，剩余的属性构成新的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;; <br><br><span class="hljs-comment">// = </span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><p><code>Extract&lt;T,U&gt;</code>：从T中抽出可分配给U的属性构成新的类型。与Exclude相反</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;; <br><br><span class="hljs-comment">// = </span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p><code>NonNullable&lt;T&gt;</code>：去除T中的 null 和 undefined 类型</p><p><code>Parameters&lt;T&gt;</code>：返回类型为T的函数的参数类型所组成的数组</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;  <span class="hljs-comment">// []</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;  <span class="hljs-comment">// [string]</span><br></code></pre></td></tr></table></figure><p><code>ReturnType&lt;T&gt;</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;  <span class="hljs-comment">// string</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;  <span class="hljs-comment">// void</span><br></code></pre></td></tr></table></figure><p><code>InstanceType&lt;T&gt;</code>：返回构造函数类型T的实例类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>  x = <span class="hljs-number">0</span>;<br>  y = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> C&gt;;  <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React + Typescript(2)</title>
    <link href="/blog/2022/11/04/react+typescript/"/>
    <url>/blog/2022/11/04/react+typescript/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Typescript"><a href="#React-Typescript" class="headerlink" title="React + Typescript"></a>React + Typescript</h1><p>结合项目的一些疑惑与解答</p><h3 id="1-三点运算符与其他常见"><a href="#1-三点运算符与其他常见" class="headerlink" title="1 三点运算符与其他常见"></a>1 三点运算符与其他常见</h3><p>三点运算符：…</p><p>用来声明任意数量的方法参数，在下例中，可以传任意参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"> ...args </span>)&#123;<br>args.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>非空断言操作符：!</p><p>在上下⽂中当类型检查器⽆法断定类型时，⼀个新的后缀表达式操作符 ! 可以⽤于断⾔操作对象是⾮ <strong>null</strong> 和⾮ <strong>undefined</strong> 类型。</p><p>可选链操作符：?.</p><p>允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。<code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为空(<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish">nullish</a> ) (<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a> 或者 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>) 的情况下不会引起错误，该表达式短路返回值是 <code>undefined</code>。与函数调用一起使用时，如果给定的函数不存在，则返回 <code>undefined</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> baz = obj?.<span class="hljs-property">foo</span>?.<span class="hljs-property">bar</span>?.<span class="hljs-property">baz</span>; <span class="hljs-comment">// 42</span><br><span class="hljs-keyword">const</span> safe = obj?.<span class="hljs-property">qux</span>?.<span class="hljs-property">baz</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>空值合并运算符：??</p><p>当左侧操作数为 <strong>null</strong> 或 <strong>undefined</strong> 时，其返回右侧的操作数，否则返回左侧的操作数。</p><p>与逻辑或 || 运算符不同，逻辑或会在左操作数为 falsy 值时返回右侧操作数。也就是说，如果你使⽤|| 来为某些变量设置默认的值时，你可能会遇到意料之外的⾏为。⽐如为 falsy 值（’’、NaN 或 0）时</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;nordon&#x27;</span>; <span class="hljs-comment">// 返回nodedon</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">0</span> ?? <span class="hljs-number">18</span>; <span class="hljs-comment">// 返回 0</span><br><span class="hljs-keyword">const</span> age2 = <span class="hljs-number">0</span> || <span class="hljs-number">18</span>; <span class="hljs-comment">// 返回 18</span><br></code></pre></td></tr></table></figure><p>可选属性： ?:</p><p>在⾯向对象语⾔中，接⼝是⼀个很重要的概念，它是对⾏为的抽象，⽽具体如何⾏动需要由类去实现。<strong>TypeScript</strong> 中的接⼝是⼀个⾮常灵活的概念，除了可⽤于对类的⼀部分⾏为进⾏抽象以外，也常⽤于对「对象的形状（<strong>Shape</strong>）」进⾏描述。</p><p>在 TypeScript 中使⽤ interface 关键字就可以声明⼀个接⼝：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>运算符：&amp;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PartialPointX</span> &amp; &#123; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>运算符：|</p><p>在 TypeScript 中联合类型（Union Types）表示取值可以为多种类型中的⼀种，联合类型使⽤ | 分隔每个类型。联合类型通常与 null 或 undefined ⼀起使⽤</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">info: strong | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></span>) =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>数字分割符：_</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1_234_567</span>;<br><span class="hljs-comment">// 等价</span><br><span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1234567</span>;<br></code></pre></td></tr></table></figure><h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2 Promise"></a>2 Promise</h3><p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 then 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1551668316202_.pic-20221113%2020:35:29.jpg" alt="1551668316202_.pic"></p><p>特性：链式调用、内部三种状态（Pending（进行中），Resolved(完成)，Rejected (失败)。Promise从Pending状态开始，如果成功就转到成功态，并执行resolve回调函数；如果失败就转到失败状态并执行reject回调函数。 Promise一旦状态改变，就不会再变，任何时候都可以得到这个结果。）</p><p>例如一个<code>createAudioFileAsync</code>方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">createAudioFileAsync</span>(audioSettings).<span class="hljs-title function_">then</span>(successCallback, failureCallback);<br></code></pre></td></tr></table></figure><p>出现的背景：解决ajax回调地狱（当嵌套层数很多时，会变得难以维护）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">doSomething</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">doSomethingElse</span>(result, <span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) &#123;<br>    <span class="hljs-title function_">doThirdThing</span>(newResult, <span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Got the final result: &#x27;</span> + finalResult);<br>    &#125;, failureCallback);<br>  &#125;, failureCallback);<br>&#125;, failureCallback);<br></code></pre></td></tr></table></figure><p>连续执行两个或者多个异步操作是一个常见的需求，在上一个操作执行成功之后，开始下一个的操作，并带着上一步操作所返回的结果。我们可以通过创造一个 <strong>Promise 链</strong>来实现这种需求：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">doSomething</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doSomethingElse</span>(result);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doThirdThing</span>(newResult);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Got the final result: &#x27;</span> + finalResult);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(failureCallback);<br></code></pre></td></tr></table></figure><h3 id="3-React-hook"><a href="#3-React-hook" class="headerlink" title="3 React hook"></a>3 React hook</h3><h5 id="1-useState"><a href="#1-useState" class="headerlink" title="1 useState"></a>1 useState</h5><blockquote><p>用来更新值以及重新渲染</p></blockquote><p>使用方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState)<br></code></pre></td></tr></table></figure><p>这行代码返回一个 state，以及更新 state 的函数。</p><p>setState 函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。</p><p>在初始渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同。</p><p>调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(count + 1)</span><br><span class="language-xml">      &#125;&#125;&gt;Count &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><blockquote><p>使用规则：</p><p>只能在顶层域调用hooks，不能在内部的循环、条件判断、嵌套的方法中使用</p><p>只能在React function中使用hooks，不能在其他普通function中使用hooks</p></blockquote><hr><p>当你的 state 值依赖上一个状态值时，就会用到 previous state。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> initialCount = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialCount)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment5</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>      <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> prevCount + <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      Count: &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(initialCount)</span><br><span class="language-xml">      &#125;&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount + 1)</span><br><span class="language-xml">      &#125;&#125;&gt; + 1 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount - 1)</span><br><span class="language-xml">      &#125;&#125;&gt; - 1 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment5&#125;</span>&gt;</span> + 5 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><p>使用 previousState 时，要使用 setter function 的方式，传参给 setState 方法。来确保拿到的是准确的 previous state。</p><p>在重新渲染中，useState 返回的第一个值将始终是更新后最新的 state。</p><hr><p>当useState中的state为对象时，调用相应的setState有一些要注意的地方，useState不会自动合并更新对象，可以用函数式的setState结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;name.firstName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(&#123;</span><br><span class="language-xml">            ...name,</span><br><span class="language-xml">            firstName: e.target.value</span><br><span class="language-xml">          &#125;)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;name.lastName&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(&#123;</span><br><span class="language-xml">            ...name,</span><br><span class="language-xml">            lastName: e.target.value</span><br><span class="language-xml">          &#125;)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Your first name is &#123;name.firstName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Your last name is &#123;name.lastName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;JSON.stringify(name)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><hr><p>useState with Array</p><p>点击按钮，列表增加一个1-10的随机数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemType</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UseStateWithArray</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [items, setItems] = useState&lt;<span class="hljs-title class_">ItemType</span>[]&gt;([])<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addItem</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setItems</span>([<br>      ...items,<br>      &#123;<br>        <span class="hljs-attr">id</span>: items.<span class="hljs-property">length</span>,<br>        <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>)<br>      &#125;<br>    ])<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addItem&#125;</span>&gt;</span>add a number<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          items.length &gt; 0 &amp;&amp; items.map((item: ItemType) =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.id&#125; : &#123;item.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          ))</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UseStateWithArray</span><br></code></pre></td></tr></table></figure><p>注意 state 中不会自动补全旧的变量，需要使用展开运算符自己手动补充</p><h5 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2 useEffect"></a>2 useEffect</h5><blockquote><p>页面刷新时和销毁时调用</p></blockquote><p>useEffect api 的用法，第一个参数为匿名函数，作为 effect 要执行的内容。第二个参数为数组，用于观察改变的 props 或 state 进行有条件的触发 effect，或者传入空数组，让 effect 只执行一次。useEffect 返回一个匿名函数，在组件销毁是执行，可以有效避免内存泄露的风险。</p><p>可以认为是 componentDidMount, componentDidUpdate, componentWillUnmount 的替代品。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;count&#125;</span> times`</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount + 1)</span><br><span class="language-xml">      &#125;&#125; &gt;Clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><p>可以看到 useEffect 的第一个入参是一个匿名函数，它会在每次 render 后调用。在第一次 render 和后续的更新 render 都会被调用。</p><p>另外，useEffect 写在函数式组件内，这样就可以直接拿到 props 和 state 的值，不用写 this 之类的代码。</p><hr><p>有条件的执行useEffect</p><p>上一节了解到 useEffect 会在每次 render 后执行里面的函数，这可能会有一些性能问题，接下来就讲一讲如何有条件地执行 useEffect 中的匿名函数。</p><p>在上一节的示例上进行扩展一个输入 name 的功能，通过判断只执行 count 变化带来的逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useEffect - update title&#x27;</span>)<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span><br>  &#125;, [count])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(e.target.value)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount(prevCount =&gt; prevCount + 1)</span><br><span class="language-xml">      &#125;&#125; &gt;Clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookCounter</span><br></code></pre></td></tr></table></figure><p>注意到 useEffect 的第二个参数 <code>[count]</code>，这个参数是一个数组，元素是要被观察的 state 或 props，只有指定的这个变量发生变化时，才会触发 useEffect 中的第一个参数匿名函数的执行。这有利于性能的保证。</p><hr><p>只执行一次useEffect</p><p>通过一个记录鼠标坐标的示例研究一下如何只执行一次 useEffect</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">RunEffectsOnlyOnce</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [x, setX] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> [y, setY] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">logMousePos</span> = (<span class="hljs-params">e: MouseEvent</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setX</span>(e.<span class="hljs-property">clientX</span>)<br>    <span class="hljs-title function_">setY</span>(e.<span class="hljs-property">clientY</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;addEventListener&#x27;</span>)<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, logMousePos)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      Y - &#123;y&#125;, X - &#123;x&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RunEffectsOnlyOnce</span><br></code></pre></td></tr></table></figure><p>注意到 useEffect 方法的第二个参数传入一个空数组，有效的避免了多次调用的问题。</p><p>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。</p><p>如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入 [] 作为第二个参数更接近大家更熟悉的 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 思维模式，但我们有更好的方式来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code>，因此会使得额外操作很方便。</p><hr><p>需要清除的Effect<br>在 useEffect 的第一个参数中添加一个 return 匿名函数，这个匿名函数将在组件卸载的时候执行。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;addEventListener&#x27;</span>)<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, logMousePos)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, logMousePos)<br>  &#125;<br>&#125;, [])<br></code></pre></td></tr></table></figure><hr><p>useEffect中依赖错误导致的bug</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">IntervalCouterHooks</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearInterval</span>(interval)<br>    &#125;<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">IntervalCouterHooks</span><br></code></pre></td></tr></table></figure><p>传入空的依赖数组 <code>[]</code>，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 <code>setInterval</code> <code>的回调中，count</code> 的值不会发生变化。因为当 effect 执行时，我们会创建一个闭包，并将 <code>count</code> 的值被保存在该闭包当中，且初值为 0。每隔一秒，回调就会执行 <code>setCount(0 + 1)</code>，因此，<code>count</code> 永远不会超过 1。</p><p>解法一：这里我们不能将 useEffect 的第二个参数设置为空数组，而是 <code>[count]</code>。</p><p>指定 <code>[count]</code> 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。事实上，每个 <code>setInterval</code> 在被清除前（类似于 setTimeout）都会调用一次。但这并不是我们想要的。要解决这个问题，我们可以使用 setState 的函数式更新形式。它允许我们指定 state 该如何改变而不用引用当前 state，即下面的解法二</p><p>解法二：将<code>setCount(count + 1)</code>改为<code>setCount((prevCount) =&gt; preCount + 1)</code></p><p>useEffect 的依赖数组里依然使用空数组。这里设置了 count 的值是和上一个值有关，也解决了问题。此时，<code>setInterval</code> 的回调依旧每秒调用一次，但每次 setCount 内部的回调取到的 <code>count</code> 是最新值（在回调中变量命名为 c）。</p><hr><p>多个useEffect</p><p>如果代码中有多个业务逻辑，可以将他们写在不同的 useEffect 中，并且可以写多个 useState 和他们匹配分组使用，会让业务逻辑更加清晰。</p><hr><p>Fetch Data with Effect Hook：使用 useEffect 来获取数据，使用 axios 库示例，<a href="https://link.juejin.cn/?target=https://jsonplaceholder.typicode.com/">jsonplaceholder.typicode.com&#x2F;</a> 网站提供了示例的请求，返回了一些 json 数据。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FetchData</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">const</span> [posts, setPosts] = useState&lt;postType[]&gt;([])<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: postType[] = res.<span class="hljs-property">data</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>      <span class="hljs-title function_">setPosts</span>(data)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">rej</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rej)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          posts.map((item) =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &gt;</span></span><br><span class="language-xml">              &#123;item.title&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">          ))</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FetchData</span><br></code></pre></td></tr></table></figure><p>注意 useEffect 第二个依赖参数传入空数组，保证了 useEffect 只执行一次。</p><p>输入id获取不同数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [post, setPost] = useState&lt;postType&gt;()<br>  <span class="hljs-keyword">const</span> [id, setId] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (id) &#123;<br>      axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/posts/<span class="hljs-subst">$&#123;id&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: postType = res.<span class="hljs-property">data</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>        <span class="hljs-title function_">setPost</span>(data)<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;)<br>    &#125;<br>  &#125;, [id])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setId(e.target.value)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          post &amp;&amp; post.title</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FetchData</span><br></code></pre></td></tr></table></figure><p>点击Button触发effect：监听按钮点击触发变化，执行 effect 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [post, setPost] = useState&lt;postType&gt;()<br>  <span class="hljs-keyword">const</span> [id, setId] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  <span class="hljs-keyword">const</span> [idFromBtnClick, setIdFromBtnClick] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (idFromBtnClick) &#123;<br>      axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/posts/<span class="hljs-subst">$&#123;idFromBtnClick&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: postType = res.<span class="hljs-property">data</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>        <span class="hljs-title function_">setPost</span>(data)<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;)<br>    &#125;<br>  &#125;, [idFromBtnClick])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setId(e.target.value)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setIdFromBtnClick(id)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;Fetch Post<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          post &amp;&amp; post.title</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FetchData</span><br></code></pre></td></tr></table></figure><h5 id="3-useContext"><a href="#3-useContext" class="headerlink" title="3 useContext"></a>3 useContext</h5><blockquote><p>组件间传值</p></blockquote><p>Context api 是在组件树中传递数据但不用每层都经过的一种 api。</p><p>使用Context</p><ol><li>在根节点 App.tsx 中使用 <code>createContext()</code> 来创建一个 context</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。</p><p>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。</p><ol start="2"><li>提供Provider</li></ol><p>在根节点中使用 Provider 包裹子节点，将 context 提供给子节点</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span> value=&#123;<span class="hljs-string">&#x27;chuanshi&#x27;</span>&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentC</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span>&gt;<br></code></pre></td></tr></table></figure><p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p><p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p><p>通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。</p><p>别忘了将之前定义好的 Context export 出去，以便在子孙节点中引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整写在app.tsx的代码为：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentC</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/16ComponentC&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">chuanshi</span>&#x27;&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ComponentC</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在使用的节点处消费Context</li></ol><p>import context 对象</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br></code></pre></td></tr></table></figure><p>使用 Consumer 进行消费</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Consumer</span>&gt;<br>  &#123;<br>    <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        User context value &#123;user&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&lt;/<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Consumer</span>&gt;<br></code></pre></td></tr></table></figure><p>这里，React 组件也可以订阅到 context 变更。这能让你在函数式组件中完成订阅 context。</p><p>这需要函数作为子元素（function as a child）这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</p><hr><p>多个Context情况</p><p>在app.tsx中增加一个Context：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentC</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/16ComponentC&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ChannelContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">chuanshi</span>&#x27;&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ChannelContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">code</span> <span class="hljs-attr">volution</span>&#x27;&#125;&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ComponentC</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ChannelContext.Provider</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>接下来在 component F 中消费它们</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserContext</span>, <span class="hljs-title class_">ChannelContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentF</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">        &#123;</span><br><span class="language-xml">          (user) =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ChannelContext.Consumer</span>&gt;</span></span><br><span class="language-xml">              &#123;</span><br><span class="language-xml">                (channel) =&gt; (</span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                    User context value &#123;user&#125;, channel value &#123;channel&#125;</span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                )</span><br><span class="language-xml">              &#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ChannelContext.Consumer</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">          )</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ComponentF</span><br></code></pre></td></tr></table></figure><p>更好的方式：使用useContext hook api</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentF</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./16ComponentF&#x27;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">UserContext</span>, <span class="hljs-title class_">ChannelContext</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentE</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>)<br>  <span class="hljs-keyword">const</span> channel = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ChannelContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;user&#125; - &#123;channel&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ComponentE</span><br></code></pre></td></tr></table></figure><p>关键的代码：<code>const value = useContext(MyContext)</code></p><p>useContext 方法接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <code>React.memo</code> 或 <code>shouldComponentUpdate</code>，也会在组件本身使用 <code>useContext</code> 时重新渲染。</p><p>可以理解为，<code>useContext(MyContext)</code> 相当于 class 组件中的 <code>static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code>。</p><p><code>useContext(MyContext)</code> 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件提供 context。</p><h5 id="4-useReducer"><a href="#4-useReducer" class="headerlink" title="4 useReducer"></a>4 useReducer</h5><blockquote><p>对值或对象的复杂变化统一管理</p></blockquote><p><code>useReducer</code> 是一个用于状态管理的 hook api。是 <code>useState</code> 的替代方案。</p><p>那么 <code>useReducer</code> 和 <code>useState</code> 的区别是什么呢？答案是<code>useState</code> 是使用 <code>useReducer</code> 构建的。</p><p>使用：<code>[newState, dispatch] = useReducer(reducer, initialState)</code></p><hr><p>一个简单例子：CounterOne.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: <span class="hljs-built_in">number</span>, action: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterOne</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterOne</span><br></code></pre></td></tr></table></figure><p>reducer function 的2个参数，分别为当前 state 和 action， 并根据不同的 action 返回不同的新的 state。</p><p>useReducer 返回了一个数组，2个元素分别为 state 和 dispatch 方法。其中 state 在我们的例子中就是当前的 count 值，dispatch 方法接受一个参数，执行对应的 action。dispatch 执行后，对应的 state 会改变，组件会 rerender，来展示最新的状态。</p><p>App.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CounterOne</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/19CounterOne&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">CounterOne</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><hr><p>complex state &amp; action</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">firstCounter</span>: <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  state: &#123;</span><br><span class="hljs-params">    firstCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;,</span><br><span class="hljs-params">  action: &#123;</span><br><span class="hljs-params">    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> + <span class="hljs-number">1</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> - <span class="hljs-number">1</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count.firstCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27; &#125;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterTwo</span><br></code></pre></td></tr></table></figure><p>与上一节的示例效果相同。现在，我们已经将 state 和 action 都改写为对象了，那么这样写有什么好处呢？</p><p>其一的好处是 action 现在是一个对象了，可以有多个属性决定 action 的效果。例如我们再添加一个 +5 的逻辑。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">firstCounter</span>: <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  state: &#123;</span><br><span class="hljs-params">    firstCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;,</span><br><span class="hljs-params">  action: &#123;</span><br><span class="hljs-params">    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">    value: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> + action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> - action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count.firstCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27;, value: 0&#125;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterTwo</span><br></code></pre></td></tr></table></figure><p>可以注意到给 action 增加了一个 value 属性，实现了加减 5 的逻辑。</p><p>第二个好处是 state 作为一个对象，就可以添加更多的 state 属性，例如我们在增加一个计数器2，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">firstCounter</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">secondCounter</span>: <span class="hljs-number">10</span>,<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params"></span><br><span class="hljs-params">  state: &#123;</span><br><span class="hljs-params">    firstCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">    secondCounter: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;,</span><br><span class="hljs-params">  action: &#123;</span><br><span class="hljs-params">    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">    value: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">  &#125;</span><br><span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> + action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">firstCounter</span>: state.<span class="hljs-property">firstCounter</span> - action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment2&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">secondCounter</span>: state.<span class="hljs-property">secondCounter</span> + action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement2&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">secondCounter</span>: state.<span class="hljs-property">secondCounter</span> - action.<span class="hljs-property">value</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>First Count - &#123;count.firstCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Second Count - &#123;count.secondCounter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 1</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;increment&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Increment 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">          type: &#x27;decrement&#x27;,</span><br><span class="language-xml">          value: 5</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      &gt;Decrement 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">            type: &#x27;increment2&#x27;,</span><br><span class="language-xml">            value: 1</span><br><span class="language-xml">          &#125;)&#125;</span><br><span class="language-xml">        &gt;Increment second<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;</span><br><span class="language-xml">            type: &#x27;decrement2&#x27;,</span><br><span class="language-xml">            value: 1</span><br><span class="language-xml">          &#125;)&#125;</span><br><span class="language-xml">        &gt;Decrement second<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27;, value: 0 &#125;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterTwo</span><br></code></pre></td></tr></table></figure><p>这样我们就能同时维护 2 个计时器。</p><hr><p>multiple useReducers：如果有多个 state，但 state 变化的方式又是相同的时候，可以多次使用 useReducer。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: <span class="hljs-built_in">number</span>, action: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterThree</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">const</span> [countTwo, dispatchTwo] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count - &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>CountTwo - &#123;countTwo&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchTwo(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchTwo(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchTwo(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterThree</span><br></code></pre></td></tr></table></figure><p>这个例子中使用了多个 useReducer，但共用了一个 reducer function。这有效的避免了合并对象的麻烦（可以对比上一节使用展开运算法合并 state）。也提高了代码的复用性。</p><hr><p>useReducer with useContext</p><p>如果在某些场景想再组件之间分享 state，进行全局的 state 管理时，我们可以使用 useReducer 加 useContext。</p><p>要完成这个需求分为 2 步</p><ol><li>使用 useReducer 在根节点创建一个 counter 方法</li><li>通过 useContext 为子组件提供和消费 context</li></ol><p>在app.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><span class="hljs-keyword">import</span> A <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/22A&#x27;</span><br><span class="hljs-keyword">import</span> B <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/22B&#x27;</span><br><span class="hljs-keyword">import</span> C <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/22C&#x27;</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CountContextType</span> &#123;<br>  <span class="hljs-attr">countState</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">countDispatch</span>: <span class="hljs-function">(<span class="hljs-params">action: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">CountContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(&#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">CountContextType</span>)<br><br><span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: <span class="hljs-built_in">number</span>, action: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> initialState<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CountContext.Provider</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">countState:</span> <span class="hljs-attr">count</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">countDispatch:</span> <span class="hljs-attr">dispatch</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">      &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">        Count - &#123;count&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">A</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">B</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">C</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">CountContext.Provider</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>A.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CountContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      A - &#123;countContext.countState&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> A<br></code></pre></td></tr></table></figure><p>B.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> D <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./22D&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">D</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> B<br></code></pre></td></tr></table></figure><p>C.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> E <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./22E&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">E</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> C<br></code></pre></td></tr></table></figure><p>D.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CountContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">D</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      D - &#123;countContext.countState&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> D<br></code></pre></td></tr></table></figure><p>E.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">import</span> F <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./22F&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">E</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">F</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> E<br></code></pre></td></tr></table></figure><p>F.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CountContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      F - &#123;countContext.countState&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;increment&#x27;)&#125;</span><br><span class="language-xml">      &gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;decrement&#x27;)&#125;</span><br><span class="language-xml">      &gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> countContext.countDispatch(&#x27;reset&#x27;)&#125;</span><br><span class="language-xml">      &gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> F<br></code></pre></td></tr></table></figure><p>我们再一起回顾一下</p><ol><li>在 App.tsx 中，我们使用 useReducer 创建了一个 counter，声明了初始值，创建了 reducer 函数，useReducer 返回了状态 count 和 dispatch 方法。</li><li>为了能让其他组件访问到 count 和 dispatch，我们通过 React.createContext 创建了 CountContext，并用 <code>&lt;CountContext.Provider&gt;</code> 包裹根节点。将 count 和 dispatch 作为 value 传给 Provider。</li><li>在子节点中，我们使用 useContext 获取到 count 和 dispatch 方法，通过调用 dispatch 实现对 count 的改变。</li></ol><hr><p>Fetching Data with useReducer</p><p>如何使用 useReducer 去请求远程数据。</p><p>接下来我们做这样一个小需求：</p><ol><li>页面载入时请求数据</li><li>请求数据中展示 loading 状态</li><li>请求返回后移除 loading 样式，展示请求的数据；若请求失败，也移除 loading 展示错误提示</li></ol><p>useState实现请求</p><p>app.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">DataFetchingOne</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/23DataFetchingOne&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataFetchingOne</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>DataFetchingOne.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataFetchingOne</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">const</span> [post, setPost] = <span class="hljs-title function_">useState</span>(&#123;&#125; <span class="hljs-keyword">as</span> postType)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)<br>      <span class="hljs-title function_">setPost</span>(res.<span class="hljs-property">data</span>)<br>      <span class="hljs-title function_">setError</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)<br>      <span class="hljs-title function_">setPost</span>(&#123;&#125; <span class="hljs-keyword">as</span> postType)<br>      <span class="hljs-title function_">setError</span>(<span class="hljs-string">&#x27;something went wrong&#x27;</span>)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        loading</span><br><span class="language-xml">          ? &#x27;Loading...&#x27;</span><br><span class="language-xml">          : post.title</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        error</span><br><span class="language-xml">          ? error</span><br><span class="language-xml">          : null</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DataFetchingOne</span><br></code></pre></td></tr></table></figure><p>在这个实现中，我们使用了3个useState去控制 loading, post 和 error，接下来看看如何使用 useReducer 实现。</p><p>useReducer实现请求</p><p>app.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">DataFetchingOne</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/23DataFetchingOne&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataFetchingOne</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>DataFetchingTwo.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> postType &#123;<br>  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> stateType = &#123;<br>  <span class="hljs-attr">loading</span>: <span class="hljs-built_in">boolean</span><br>  <span class="hljs-attr">error</span>: <span class="hljs-built_in">string</span><br>  post?: postType | &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> actionType = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span> | <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span><br>  payload?: postType | &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">post</span>: &#123;&#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state: stateType, action: actionType</span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">post</span>: action.<span class="hljs-property">payload</span>,<br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;something went wrong&#x27;</span>,<br>        <span class="hljs-attr">post</span>: &#123;&#125;,<br>      &#125;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataFetchingTwo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>,<br>        <span class="hljs-attr">payload</span>: res.<span class="hljs-property">data</span>,<br>      &#125;)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span><br>      &#125;)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        state.loading</span><br><span class="language-xml">          ? &#x27;Loading...&#x27;</span><br><span class="language-xml">          // @ts-ignore</span><br><span class="language-xml">          : state.post.title</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">      &#123;</span><br><span class="language-xml">        state.error</span><br><span class="language-xml">          ? state.error</span><br><span class="language-xml">          : null</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DataFetchingTwo</span><br></code></pre></td></tr></table></figure><p>可以看到，我们将 state 集合在了一起，在同一个对象，修改 state 的逻辑也聚合在了一起，即 reducer 函数中的 switch 部分。</p><hr><p>useState vs useReducer</p><ul><li><p>如果 state 的类型为 Number, String, Boolean 建议使用 useState，如果 state 的类型 为 Object 或 Array，建议使用 useReducer</p></li><li><p>如果 state 变化非常多，也是建议使用 useReducer，集中管理 state 变化，便于维护</p></li><li><p>如果 state 关联变化，建议使用 useReducer</p></li><li><p>业务逻辑如果很复杂，也建议使用 useReducer</p></li><li><p>如果 state 只想用在 组件内部，建议使用 useState，如果想维护全局 state 建议使用 useReducer</p></li></ul><h5 id="5-useCallback和useMemo"><a href="#5-useCallback和useMemo" class="headerlink" title="5 useCallback和useMemo"></a>5 useCallback和useMemo</h5><blockquote><p>自定义那几个变量变化才更新，阻止了子组件不必要的render</p><p>useCallback 是缓存了函数自身，而 useMemo 是缓存了函数的返回值。</p></blockquote><p>组件多次被复用的场景</p><p>有一个组件树结构。ParentWrap 包含 Title 组件、2次使用 Count 组件、2次使用 Button 组件。</p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1571668332118_.pic-20221113%2020:36:13.jpg" alt="1571668332118_.pic"></p><p>App.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ParentComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/26ParentComponenet&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ParentComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>ParentComponent.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Title</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./26Title&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Count</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./26Count&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./26Button&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponenet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [age, setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">29</span>)<br>  <span class="hljs-keyword">const</span> [salary, setSalary] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">50000</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">incrementAge</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>)<br>  &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">incrementSalary</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setSalary</span>(salary + <span class="hljs-number">1000</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Title</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Count</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Age&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;age&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;incrementAge&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span>Increment age<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Count</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Salary&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;salary&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">handleClick</span>=<span class="hljs-string">&#123;incrementSalary&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span>Increment salary<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ParentComponenet</span><br></code></pre></td></tr></table></figure><p>Title.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Title</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering Title&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>useCallback<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Title</span><br></code></pre></td></tr></table></figure><p>Count.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Count</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  text: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  count: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Rendering <span class="hljs-subst">$&#123;props.text&#125;</span>`</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;props.text&#125; - &#123;props.count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Count</span><br></code></pre></td></tr></table></figure><p>Button.tsx</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  handleClick: () =&gt; <span class="hljs-built_in">void</span></span><br><span class="hljs-params">  children: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering button&#x27;</span>, props.<span class="hljs-property">children</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Button</span><br></code></pre></td></tr></table></figure><p>每次点击，可以看到以下日志：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Rendering Title<br>Rendering Age<br>Rendering <span class="hljs-selector-tag">button</span> Increment age<br>Rendering Salary<br>Rendering <span class="hljs-selector-tag">button</span> Increment salary<br></code></pre></td></tr></table></figure><p>每次状态改变都触发了所有组件的 rerender，这个示例比较简单，但是假如未来遇到20、30、甚至50个组件 rerender 的时候，就一定要考虑到性能问题了。下面讲讲在这个示例中怎么进行优化。</p><hr><p>useMemo</p><p>使用：<code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code></p><p>返回一个 memoized 值。 把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p><strong>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。</strong> 将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。</p><p>例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> isEven = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">1000000000</span>) i += <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> counterOne % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br>&#125;, [counterOne])<br></code></pre></td></tr></table></figure><p>在本例中，我们当然希望点击增加年龄的按钮时，只有关于年龄的 Count 和 Button 进行 rerender，而其他组件不发生 rerender，点击增加 salary 时也一样。如何才能做到呢？答案是 <code>React.memo</code>。</p><p>我们给 Title.tsx, Count.tsx, Button.tsx 添加 <code>React.memo()</code>，代码如下：</p><p>Title.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Title</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering Title&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>useCallback<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Title</span>)<br></code></pre></td></tr></table></figure><p>Count.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Count</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  text: string</span><br><span class="hljs-params">  count: number</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Rendering <span class="hljs-subst">$&#123;props.text&#125;</span>`</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;props.text&#125; - &#123;props.count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Count</span>)<br></code></pre></td></tr></table></figure><p>Button.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props: &#123;</span><br><span class="hljs-params">  handleClick: () =&gt; <span class="hljs-keyword">void</span></span><br><span class="hljs-params">  children: string</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rendering button&#x27;</span>, props.<span class="hljs-property">children</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Button</span>)<br></code></pre></td></tr></table></figure><p>React.memo 为高阶组件。它与 React.PureComponent 非常相似，但只适用于函数组件，而不适用 class 组件。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">/* 使用 props 渲染 */</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p>React.memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。</p><p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">/* 使用 props 渲染 */</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">areEqual</span>(<span class="hljs-params">prevProps, nextProps</span>) &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  如果把 nextProps 传入 render 方法的返回结果与</span><br><span class="hljs-comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span><br><span class="hljs-comment">  否则返回 false</span><br><span class="hljs-comment">  */</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">MyComponent</span>, areEqual);<br></code></pre></td></tr></table></figure><p>此方法仅作为性能优化的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。</p><p>但是，使用了 React.memo 后，依然有不相关的 rerender：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Rendering Age<br>Rendering <span class="hljs-selector-tag">button</span> Increment age<br>Rendering <span class="hljs-selector-tag">button</span> Increment salary<br></code></pre></td></tr></table></figure><p>在 ParentComponenet.tsx 中，我们看到点击 Increment age 按钮时，导致了 state 变化，ParentComponenet 进行了 rerender。<code>&lt;Title /&gt;</code> 没有传入属性，React.memo 判断出不需要 rerender，但是 Increment salary 按钮上的属性 incrementSalary 方法，实际上被重新创建了，导致了这个 Button 传入的 props 发生了变化，因此 React.memo 没有阻止 rerender。点击按钮 Increment salary 导致的相同的现象也是同理。那么如何解决呢？答案是使用 useCallback hook。</p><hr><p>useCallback</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">doSomething</span>(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure><p>返回一个 memoized 回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。</p><p>类比到我们的例子中，useCallback 会缓存我们的 <code>incrementSalary()</code> 如果 salary 没有变化，直接返回缓存的值，如果 salary 发生变化，也就是 useCallback 的依赖发生变化，那么一个新的方法将被返回。这就可以帮助我们解决只依赖某个变量的子组件避免不必要的 render 问题。</p><p>如何使用：</p><ol><li>import useCallback</li><li>调用useCallback</li></ol><p>我们将 ParentComponenet.tsx 中的 incrementAge 和 incrementSalary 使用 useCallback 改写如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> incrementAge = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>)<br>  &#125;,<br>  [age],<br>)<br><br><span class="hljs-keyword">const</span> incrementSalary = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setSalary</span>(salary + <span class="hljs-number">1000</span>)<br>  &#125;,<br>  [salary],<br>)<br></code></pre></td></tr></table></figure><h5 id="6-useRef"><a href="#6-useRef" class="headerlink" title="6 useRef"></a>6 useRef</h5><p>页面载入获取焦点示例</p><p>FocusInput.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FocusInput</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>)<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    inputRef.<span class="hljs-property">current</span> &amp;&amp; inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>  &#125;, [])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FocusInput</span><br></code></pre></td></tr></table></figure><p>App.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">FocusInput</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/28FocusInput&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FocusInput</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>注意与 TypeScript 结合使用时的方式，需要先声明好泛型</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>)<br>复制代码<br></code></pre></td></tr></table></figure><p>同时使用时需要判空</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">inputRef.<span class="hljs-property">current</span> &amp;&amp; inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>复制代码<br></code></pre></td></tr></table></figure><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p><p>在典型的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p><p>下面是几个适合使用 refs 的情况</p><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库。</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。举个例子，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性。</p><p>勿过度使用 Refs</p><p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 状态提升 以获取更多有关示例。</p><hr><p>可以停止的计时器示例：</p><p>需求是页面上有一个每隔1秒自动加一的计时器，并且有个按钮，点击后计时器停止，先使用 Class 组件完成这样的需求</p><p>ClassTimer.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassTimer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>&lt;&#123;&#125;, &#123; <span class="hljs-attr">timer</span>: number &#125;&gt; &#123;<br>  interval!: number<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props: Readonly&lt;&#123;&#125;&gt;</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">timer</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> (&#123;<br>        <span class="hljs-attr">timer</span>: prevState.<span class="hljs-property">timer</span> + <span class="hljs-number">1</span><br>      &#125;))<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">interval</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        Timer - &#123;this.state.timer&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">            clearInterval(this.interval)</span><br><span class="language-xml">          &#125;&#125;</span><br><span class="language-xml">        &gt;Clear Timer<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>App.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ClassTimer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/29ClassTimer&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ClassTimer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>Function 组件示例</p><p>HookTimer.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HookTimer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [timer, setTimer] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-comment">//  @ts-ignore</span><br>  <span class="hljs-keyword">const</span> intervalRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>) <span class="hljs-keyword">as</span> &#123; <span class="hljs-attr">current</span>: number &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    intervalRef.<span class="hljs-property">current</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setTimer</span>(<span class="hljs-function"><span class="hljs-params">pre</span> =&gt;</span> pre + <span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearInterval</span>(intervalRef.<span class="hljs-property">current</span>)<br>    &#125;<br>  &#125;, [])<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      HookTimer - &#123;timer&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          clearInterval(intervalRef.current)</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;Clear Hook Timer<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HookTimer</span><br></code></pre></td></tr></table></figure><p>App.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ClassTimer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/29ClassTimer&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">HookTimer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/29HookTimer&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ClassTimer</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HookTimer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>这就是 useRef 的第二种用法，可以用它创建一个通用的容器，用来保存变量。</p><h3 id="4-React-router"><a href="#4-React-router" class="headerlink" title="4 React router"></a>4 React router</h3><p>举例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App14&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Home&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/List&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Detail&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Error</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Error&#x27;</span><br><br><span class="hljs-comment">// BrowserRouter（history模式）不带#需要配置，HashRouter（Hash模式）带#打包后即可</span><br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span>, <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-comment">// 定义一个路由</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BaseRouter</span> = (<span class="hljs-params"></span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">App</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/list/:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">List</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Detail</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Error</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">BaseRouter</span>;<br></code></pre></td></tr></table></figure><h3 id="5-axios"><a href="#5-axios" class="headerlink" title="5 axios"></a>5 axios</h3><p>在React项目中，我们经常使用Axios库进行数据请求，Axios 是基于 Promise 的 HTTP 库，可以在浏览器和 node.js 中使用。Axios 具备以下特性：</p><ul><li>从浏览器中创建 XMLHttpRequests；</li><li>从 node.js 创建 HTTP 请求；</li><li>支持 Promise API；</li><li>拦截请求和响应；</li><li>转换请求数据和响应数据；</li><li>取消请求；</li><li>自动转换 JSON 数据；</li><li>客户端支持防御 XSRF。</li></ul><p>Axios的基本使用就不再多介绍了。为了更好地调用，做一些全局的拦截，通常会对Axios进行封装，下面就使用TypeScript对Axios进行简单封装，使其同时能够有很好的类型支持。Axios是自带声明文件的，所以我们无需额外的操作。 </p><p>下面来看基本的封装：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">AxiosInstance</span>, <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosPromise</span>,<span class="hljs-title class_">AxiosResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>; <span class="hljs-comment">// 引入axios和定义在node_modules/axios/index.ts文件里的类型声明</span><br><br> <span class="hljs-comment">// 定义接口请求类，用于创建axios请求实例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpRequest</span> &#123;<br>  <span class="hljs-comment">// 接收接口请求的基本路径</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> baseUrl: <span class="hljs-built_in">string</span></span>) &#123; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> = baseUrl;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 调用接口时调用实例的这个方法，返回AxiosPromise</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">request</span>(<span class="hljs-attr">options</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">AxiosPromise</span> &#123; <br>    <span class="hljs-comment">// 创建axios实例，它是函数，同时这个函数包含多个属性</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span> = axios.<span class="hljs-title function_">create</span>() <br>    <span class="hljs-comment">// 合并基础路径和每个接口单独传入的配置，比如url、参数等</span><br>    options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeConfig</span>(options) <br>    <span class="hljs-comment">// 调用interceptors方法使拦截器生效</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">interceptors</span>(instance, options.<span class="hljs-property">url</span>) <br>    <span class="hljs-comment">// 返回AxiosPromise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(options) <br>  &#125;<br>  <br>  <span class="hljs-comment">// 用于添加全局请求和响应拦截</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">interceptors</span>(<span class="hljs-params">instance: AxiosInstance, url?: <span class="hljs-built_in">string</span></span>) &#123; <br>    <span class="hljs-comment">// 请求和响应拦截</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 用于合并基础路径配置和接口单独配置</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">mergeConfig</span>(<span class="hljs-attr">options</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">AxiosRequestConfig</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123; <span class="hljs-attr">baseURL</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> &#125;, options);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HttpRequest</span>;<br></code></pre></td></tr></table></figure><p>通常baseUrl在开发环境的和生产环境的路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里要写在一个配置文件里：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">api</span>: &#123;<br>        <span class="hljs-attr">devApiBaseUrl</span>: <span class="hljs-string">&#x27;/test/api/xxx&#x27;</span>,<br>        <span class="hljs-attr">proApiBaseUrl</span>: <span class="hljs-string">&#x27;/api/xxx&#x27;</span>,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的文件中引入这个配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-attr">api</span>: &#123; devApiBaseUrl, proApiBaseUrl &#125; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/config&#x27;</span>;<br><span class="hljs-keyword">const</span> apiBaseUrl = env.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span> ? proApiBaseUrl : devApiBaseUrl;<br></code></pre></td></tr></table></figure><p>之后就可以将apiBaseUrl作为默认值传入HttpRequest的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpRequest</span> &#123; <br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> baseUrl: <span class="hljs-built_in">string</span> = apiBaseUrl</span>) &#123; <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseUrl</span> = baseUrl;<br>  &#125;<br></code></pre></td></tr></table></figure><p>接下来可以完善一下拦截器类，在类中interceptors方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">interceptors</span>(<span class="hljs-params">instance: AxiosInstance, url?: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 请求拦截</span><br>    instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 接口请求的所有配置，可以在axios.defaults修改配置</span><br>      <span class="hljs-keyword">return</span> config<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;)<br> <br>  <span class="hljs-comment">// 响应拦截</span><br>    instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">res: AxiosResponse</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> &#123; data &#125; = res <br>      <span class="hljs-keyword">const</span> &#123; code, msg &#125; = data<br>      <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(msg) <br>      &#125;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123; <br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><p>到这里封装的就差不多了，一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以所有请求返回的数据格式都是一样的，所以就可以定义一个接口来指定返回的数据结构，可以定义一个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResponseData</span> &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span><br>  data?: <span class="hljs-built_in">any</span><br>  <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看看使用TypeScript封装的Axios该如何使用。可以先定义一个请求实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HttpRequest</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/axios&#x27;</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/axios&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequest</span>()<br></code></pre></td></tr></table></figure><p>这里把请求类导入进来，默认导出这个类的实例。之后创建一个登陆接口请求方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">ResponseData</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AxiosPromise</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILogin</span> &#123;<br>  <span class="hljs-attr">user</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> loginReq = (<span class="hljs-attr">data</span>: <span class="hljs-title class_">ILogin</span>): <span class="hljs-title class_">AxiosPromise</span>&lt;<span class="hljs-title class_">ResponseData</span>&gt; =&gt; &#123;<br>  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/api/user/login&#x27;</span>,<br>    data,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里封装登录请求方法loginReq，他的参数必须是我们定义的ILogin接口的类型。这个方法返回一个类型为<code>AxiosPromise</code>的Promise，AxiosPromise是axios声明文件内置的类型，可以传入一个泛型变量参数，用于指定返回的结果中data字段的类型。 </p><p>接下来可以调用一下这个登录的接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; loginReq &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/user&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span>: <span class="hljs-variable constant_">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">login</span> = (<span class="hljs-params">params</span>) =&gt; &#123;<br>  <span class="hljs-title function_">loginReq</span>(params).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span>)<br>  &#125;)<br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，当我们调用loginReq接口时，就会提示我们，参数的类型是ILogin，需要传入几个参数。这样编写代码的体验就会好很多。</p><h3 id="6-Types-or-Interfaces？"><a href="#6-Types-or-Interfaces？" class="headerlink" title="6 Types or Interfaces？"></a>6 Types or Interfaces？</h3><p>我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：</p><ul><li>在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；</li><li>在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。</li></ul><p>interface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-comment">// 可以继续在原属性基础上，添加新属性：color</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Animal</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-comment">// type类型不支持属性扩展</span><br><span class="hljs-comment">// Error: Duplicate identifier &#x27;Animal&#x27;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Animal</span> = &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>type对于联合类型是很有用的，比如：type Type &#x3D; TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。</p><h3 id="7-懒加载类型"><a href="#7-懒加载类型" class="headerlink" title="7 懒加载类型"></a>7 懒加载类型</h3><p>如果我们想在React router中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RouteType</span> &#123;<br>    <span class="hljs-attr">pathname</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">LazyExoticComponent</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>    <span class="hljs-attr">exact</span>: <span class="hljs-built_in">boolean</span>;<br>    title?: <span class="hljs-built_in">string</span>;<br>    icon?: <span class="hljs-built_in">string</span>;<br>    children?: <span class="hljs-title class_">RouteType</span>[];<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">AppRoutes</span>: <span class="hljs-title class_">RouteType</span>[] = [<br>    &#123;<br>        <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/Login/Login&#x27;</span>)),<br>        <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/404&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/404/404&#x27;</span>)),<br>        <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">pathname</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-attr">exact</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/Admin/Admin&#x27;</span>))<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>下面是懒加载类型和lazy方法在声明文件中的定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">LazyExoticComponent</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ComponentType</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt; = <span class="hljs-title class_">ExoticComponent</span>&lt;<span class="hljs-title class_">ComponentPropsWithRef</span>&lt;T&gt;&gt; &amp; &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_result</span>: T;<br>&#125;;<br><br><span class="hljs-keyword">function</span> lazy&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ComponentType</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt;(<br><span class="hljs-attr">factory</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;&#123; <span class="hljs-attr">default</span>: T &#125;&gt;<br>): <span class="hljs-title class_">LazyExoticComponent</span>&lt;T&gt;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>typescript</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法导论笔记</title>
    <link href="/blog/2022/11/03/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    <url>/blog/2022/11/03/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h2><h3 id="一：基础知识"><a href="#一：基础知识" class="headerlink" title="一：基础知识"></a>一：基础知识</h3><h4 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1 算法基础"></a>1 算法基础</h4><h5 id="1-1-插入排序（增量）"><a href="#1-1-插入排序（增量）" class="headerlink" title="1.1 插入排序（增量）"></a>1.1 插入排序（增量）</h5><p>循环不变性</p><h5 id="1-2-分析算法"><a href="#1-2-分析算法" class="headerlink" title="1.2 分析算法"></a>1.2 分析算法</h5><p>输入规模</p><p>最坏情况与平均情况分析</p><p>增长量级</p><h5 id="1-3-设计算法"><a href="#1-3-设计算法" class="headerlink" title="1.3 设计算法"></a>1.3 设计算法</h5><p><strong>分治法</strong></p><p>许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。这些算法都典型地遵循分治法的思想：将原问题分解成规模较小但类似于原问题的子问题，递归地解决这些子问题，然后再合并这些子问题的解来建立原问题的解。</p><p>分治算法在每层递归时都有三个步骤：分解、解决、合并</p><p>&#x3D;&#x3D;举例：归并排序算法&#x3D;&#x3D;</p><h4 id="2-函数的增长"><a href="#2-函数的增长" class="headerlink" title="2 函数的增长"></a>2 函数的增长</h4><h5 id="2-1-渐进记号"><a href="#2-1-渐进记号" class="headerlink" title="2.1 渐进记号"></a>2.1 渐进记号</h5><h5 id="2-2-标准记号和常用函数"><a href="#2-2-标准记号和常用函数" class="headerlink" title="2.2 标准记号和常用函数"></a>2.2 标准记号和常用函数</h5><h4 id="3-分治策略"><a href="#3-分治策略" class="headerlink" title="3 分治策略"></a>3 分治策略</h4><h5 id="3-1-递归式"><a href="#3-1-递归式" class="headerlink" title="3.1 递归式"></a>3.1 递归式</h5><p>求解递归式的方法：代入法、递归树法、主方法</p><h5 id="x3D-x3D-3-2-最大子数组问题-x3D-x3D"><a href="#x3D-x3D-3-2-最大子数组问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.2 最大子数组问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.2 最大子数组问题&#x3D;&#x3D;</h5><p>股票买卖</p><p>使用分治策略的求解方法</p><p>分治算法的分析</p><h5 id="x3D-x3D-3-3-矩阵乘法的Strassen算法-x3D-x3D"><a href="#x3D-x3D-3-3-矩阵乘法的Strassen算法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.3 矩阵乘法的Strassen算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.3 矩阵乘法的Strassen算法&#x3D;&#x3D;</h5><h5 id="3-4-用代入法求解递归式"><a href="#3-4-用代入法求解递归式" class="headerlink" title="3.4 用代入法求解递归式"></a>3.4 用代入法求解递归式</h5><ol><li>猜测解的形式</li><li>用数学归纳法求出解中的常数，并证明解是正确的</li></ol><h5 id="3-5-用递归树方法求解递归式"><a href="#3-5-用递归树方法求解递归式" class="headerlink" title="3.5 用递归树方法求解递归式"></a>3.5 用递归树方法求解递归式</h5><h5 id="3-6-用主方法求解递归式"><a href="#3-6-用主方法求解递归式" class="headerlink" title="3.6 用主方法求解递归式"></a>3.6 用主方法求解递归式</h5><p>证明主定理</p><h4 id="4-概率分析和随机算法"><a href="#4-概率分析和随机算法" class="headerlink" title="4 概率分析和随机算法"></a>4 概率分析和随机算法</h4><p>&#x3D;&#x3D;4.1 雇用问题&#x3D;&#x3D;</p><p>在任何时候雇佣更好的办公助理并为此支付费用</p><p>最坏情况分析</p><p>概率分析</p><p>随机算法</p><p>指示器随机变量</p><p>随机算法</p><p>随机排列数组</p><p>4.2 概率分析和指示器随机变量的进一步使用</p><p>生日悖论</p><p>球与箱子&#x2F;礼券收集者问题</p><p>特征序列</p><p>在线雇佣问题</p><h3 id="二：排序和顺序统计量"><a href="#二：排序和顺序统计量" class="headerlink" title="二：排序和顺序统计量"></a>二：排序和顺序统计量</h3><h4 id="x3D-x3D-1-堆排序-x3D-x3D"><a href="#x3D-x3D-1-堆排序-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1 堆排序&#x3D;&#x3D;"></a>&#x3D;&#x3D;1 堆排序&#x3D;&#x3D;</h4><p>堆</p><p>维护堆的性质</p><p>建堆</p><p>堆排序算法</p><p>优先队列</p><h4 id="x3D-x3D-2-快速排序-x3D-x3D"><a href="#x3D-x3D-2-快速排序-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2 快速排序&#x3D;&#x3D;"></a>&#x3D;&#x3D;2 快速排序&#x3D;&#x3D;</h4><p>分治思想</p><p>快速排序性能</p><p>快速排序的随机化版本</p><p>快速排序分析</p><h4 id="3-线性时间排序"><a href="#3-线性时间排序" class="headerlink" title="3 线性时间排序"></a>3 线性时间排序</h4><p>排序算法的下界：&#x3D;&#x3D;决策树模型&#x3D;&#x3D;</p><p>最坏情况的下界</p><p>&#x3D;&#x3D;计数排序&#x3D;&#x3D;</p><p>&#x3D;&#x3D;基数排序&#x3D;&#x3D;</p><p>&#x3D;&#x3D;桶排序&#x3D;&#x3D;</p><h4 id="4-中位数和顺序统计量"><a href="#4-中位数和顺序统计量" class="headerlink" title="4 中位数和顺序统计量"></a>4 中位数和顺序统计量</h4><p>最大值和最小值</p><p>&#x3D;&#x3D;期望为线性时间的选择算法&#x3D;&#x3D;</p><p>&#x3D;&#x3D;最坏情况为线性时间的选择算法&#x3D;&#x3D;</p><h3 id="三：数据结构"><a href="#三：数据结构" class="headerlink" title="三：数据结构"></a>三：数据结构</h3><h4 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1 基本数据结构"></a>1 基本数据结构</h4><p>栈和队列</p><p>链表</p><p>指针和对象的实现</p><p>有根树的表示：二叉树、分支无限制的有根树</p><h4 id="2-散列表"><a href="#2-散列表" class="headerlink" title="2 散列表"></a>2 散列表</h4><p>直接寻址表</p><p>散列表：链接法、开放寻址法</p><h4 id="3-散列函数"><a href="#3-散列函数" class="headerlink" title="3 散列函数"></a>3 散列函数</h4><p>除法散列法</p><p>乘法散列法</p><p>全域散列法</p><p>开放寻址法：线性探查、二次探查、双重散列、开放寻址法的分析</p><p>完全散列</p><h4 id="4-二叉搜索树"><a href="#4-二叉搜索树" class="headerlink" title="4 二叉搜索树"></a>4 二叉搜索树</h4><p>什么是二叉搜索树</p><p>查询二叉搜索树：最大关键字元素和最小关键字元素、后继和前驱</p><p>插入和删除</p><p>随机构建二叉搜索树</p><h4 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5 红黑树"></a>5 红黑树</h4><p>红黑树的性质</p><p>旋转</p><p>插入</p><h4 id="6-数据结构的扩张"><a href="#6-数据结构的扩张" class="headerlink" title="6 数据结构的扩张"></a>6 数据结构的扩张</h4><p>动态顺序统计</p><p>如何扩张数据结构</p><p>区间树</p><h3 id="四：高级设计和分析技术"><a href="#四：高级设计和分析技术" class="headerlink" title="四：高级设计和分析技术"></a>四：高级设计和分析技术</h3><h4 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h4><p>用于求解最优化问题</p><p>&#x3D;&#x3D;钢条切割&#x3D;&#x3D;</p><p>&#x3D;&#x3D;矩阵链乘法&#x3D;&#x3D;</p><p>动态规划原理：最优子结构、子问题重叠</p><p>重构最优解、备忘</p><p>&#x3D;&#x3D;最长公共子序列&#x3D;&#x3D;</p><p>&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;</p><h4 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2 贪心算法"></a>2 贪心算法</h4><p>&#x3D;&#x3D;活动选择问题&#x3D;&#x3D;：调度竞争共享资源的多个活动</p><p>贪心算法原理：贪心选择性质、最有子结构、贪心对动态规划（0-1背包、分数背包）</p><p>&#x3D;&#x3D;赫夫曼编码&#x3D;&#x3D;：变长编码、前缀码、构造赫夫曼编码、赫夫曼算法的正确性</p><p>拟阵和贪心算法：矩阵拟阵、图拟阵、加权拟阵上的贪心算法</p><p>用拟阵求解任务调度问题</p><h4 id="3-摊还分析"><a href="#3-摊还分析" class="headerlink" title="3 摊还分析"></a>3 摊还分析</h4><p>聚合分析：栈操作、二进制计数器递增</p><p>核算法：栈操作、二进制计数器递增</p><p>势能法：栈操作、二进制计数器递增</p><p>动态表：表扩张、表扩张和收缩</p><h3 id="五：高级数据结构"><a href="#五：高级数据结构" class="headerlink" title="五：高级数据结构"></a>五：高级数据结构</h3><h4 id="1-B树"><a href="#1-B树" class="headerlink" title="1 B树"></a>1 B树</h4><p>辅存上的数据结构</p><p>B树的定义</p><p>B树上的基本操作：创建一个空的B树、向B树中插入一个关键字、分裂B树中的结点、以沿树单程下行方式向B树插入关键字</p><p>从B树中删除关键字</p><h4 id="2-斐波那契堆"><a href="#2-斐波那契堆" class="headerlink" title="2 斐波那契堆"></a>2 斐波那契堆</h4><p>可合并堆</p><p>理论上的斐波那契堆与实际中的斐波那契堆</p><p>斐波那契堆结构：势函数、最大度数</p><h5 id="2-2-可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点"><a href="#2-2-可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点" class="headerlink" title="2.2 可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点"></a>2.2 可合并堆操作：创建一个新的斐波那契堆、插入一个结点、寻找最小结点、两个斐波那契堆的合并、抽取最小结点</h5><h5 id="2-3-关键字减值和删除一个结点"><a href="#2-3-关键字减值和删除一个结点" class="headerlink" title="2.3 关键字减值和删除一个结点"></a>2.3 关键字减值和删除一个结点</h5><h5 id="2-4-最大度数的界"><a href="#2-4-最大度数的界" class="headerlink" title="2.4 最大度数的界"></a>2.4 最大度数的界</h5><h4 id="3-van-Emde-Boas树"><a href="#3-van-Emde-Boas树" class="headerlink" title="3 van Emde Boas树"></a>3 van Emde Boas树</h4><h5 id="3-1-基本方法"><a href="#3-1-基本方法" class="headerlink" title="3.1 基本方法"></a>3.1 基本方法</h5><p>直接寻址</p><p>叠加的二叉树结构</p><p>叠加的一颗高度恒定的树</p><h5 id="3-2-递归结构"><a href="#3-2-递归结构" class="headerlink" title="3.2 递归结构"></a>3.2 递归结构</h5><p>原型van Emde Boas结构</p><p>原型van Emde Boas结构上的操作：判断一个值是否在集合中、查找最小元素、查找后继、插入元素、删除元素</p><p>van Emde Boas树及其操作：查找最小元素和最大元素、判断一个值是否在集合中、查找前驱和后继、插入一个元素、删除一个元素</p><h4 id="4-用于不相交集合的数据结构"><a href="#4-用于不相交集合的数据结构" class="headerlink" title="4 用于不相交集合的数据结构"></a>4 用于不相交集合的数据结构</h4><p>不相交集合的操作</p><p>不相交集合的链表表示：合并的一个简单实现、一种加权合并的启发式策略</p><p>不相交集合森林：改进运行时间的启发式策略、实现不相交集合森林的伪代码、启发式策略对运行时间的影响</p><p>带路径压缩的按秩合并的分析：一个增长非常慢的函数与其增长非常慢的逆函数、秩的性质、时间界的证明、势函数、势的变化与操作的摊还分析</p><h3 id="六：图算法"><a href="#六：图算法" class="headerlink" title="六：图算法"></a>六：图算法</h3><h4 id="1-基本的图算法"><a href="#1-基本的图算法" class="headerlink" title="1 基本的图算法"></a>1 基本的图算法</h4><p>图的表示</p><p>广度优先搜索</p><p>&#x3D;&#x3D;最短路径&#x3D;&#x3D;</p><p>广度优先树</p><p>深度优先搜索</p><p>拓扑排序</p><p>强连通分量</p><h4 id="2-x3D-x3D-最小生成树-x3D-x3D"><a href="#2-x3D-x3D-最小生成树-x3D-x3D" class="headerlink" title="2 &#x3D;&#x3D;最小生成树&#x3D;&#x3D;"></a>2 &#x3D;&#x3D;最小生成树&#x3D;&#x3D;</h4><p>最小生成树的形成</p><p>&#x3D;&#x3D;Kruskal算法和Prim算法&#x3D;&#x3D;</p><h4 id="3-x3D-x3D-单源最短路径-x3D-x3D"><a href="#3-x3D-x3D-单源最短路径-x3D-x3D" class="headerlink" title="3 &#x3D;&#x3D;单源最短路径&#x3D;&#x3D;"></a>3 &#x3D;&#x3D;单源最短路径&#x3D;&#x3D;</h4><p>最短路径的几个变体</p><p>负权重的边</p><p>环路</p><p>最短路径的表示</p><p>松弛操作</p><p>最短路径和松弛操作的性质</p><p>&#x3D;&#x3D;Bellman-Ford算法&#x3D;&#x3D;</p><p>有向无环图中的单源最短路径问题</p><p>&#x3D;&#x3D;Dijkstra算法&#x3D;&#x3D;</p><p>差分约束系统</p><p>最短路径性质的证明</p><p>松弛操作与最短路径树</p><h4 id="4-所有结点对的最短路径问题"><a href="#4-所有结点对的最短路径问题" class="headerlink" title="4 所有结点对的最短路径问题"></a>4 所有结点对的最短路径问题</h4><p>最短路径和矩阵乘法：最短路径的结构、所有结点对最短路径的递归解、自底向上计算最短路径权重、改进算法的运行时间</p><p>&#x3D;&#x3D;Floyd-Warshall算法&#x3D;&#x3D;</p><p>自底向上计算最短路径权重、构建一条最短路径、有向图的传递闭包</p><p>&#x3D;&#x3D;用于稀疏图的Johnson算法&#x3D;&#x3D;</p><p>通过重新复制来生成非负权重、计算所有结点对之间的最短路径</p><h4 id="5-最大流"><a href="#5-最大流" class="headerlink" title="5 最大流"></a>5 最大流</h4><p>流网络：容量限制、流量守恒、用反平行边来模拟问题、具有多个源结点和多个汇点的网络</p><p>&#x3D;&#x3D;Frod-Fulkerson方法&#x3D;&#x3D;</p><p>残存网络、增广路径、流网络的切割</p><p>Edmonds-Karp算法</p><p>&#x3D;&#x3D;推送-重贴标签算法&#x3D;&#x3D;</p><p>&#x3D;&#x3D;前置重贴标签算法&#x3D;&#x3D;</p><h3 id="七：算法问题选编"><a href="#七：算法问题选编" class="headerlink" title="七：算法问题选编"></a>七：算法问题选编</h3><h4 id="1-多线程算法"><a href="#1-多线程算法" class="headerlink" title="1 多线程算法"></a>1 多线程算法</h4><h5 id="1-1-动态多线程基础"><a href="#1-1-动态多线程基础" class="headerlink" title="1.1 动态多线程基础"></a>1.1 动态多线程基础</h5><p>多线程执行的模型</p><p>性能度量</p><p>调度</p><p>多线程算法的分析</p><p>并行循环</p><p>竞争条件</p><p>&#x3D;&#x3D;国际象棋&#x3D;&#x3D;</p><h5 id="1-2-多线程矩阵算法"><a href="#1-2-多线程矩阵算法" class="headerlink" title="1.2 多线程矩阵算法"></a>1.2 多线程矩阵算法</h5><p>矩阵算法的多线程算法</p><p>矩阵算法的分治多线程算法</p><p>多线程Strassen算法</p><h5 id="1-3-多线程归并排序"><a href="#1-3-多线程归并排序" class="headerlink" title="1.3 多线程归并排序"></a>1.3 多线程归并排序</h5><p>多线程归并排序分析</p><h4 id="2-矩阵运算"><a href="#2-矩阵运算" class="headerlink" title="2 矩阵运算"></a>2 矩阵运算</h4><h5 id="2-1-求解线性方程组"><a href="#2-1-求解线性方程组" class="headerlink" title="2.1 求解线性方程组"></a>2.1 求解线性方程组</h5><p>LUP分解</p><p>正向替换和反向替换</p><p>计算一个LU分解</p><p>计算一个LUP分解</p><h5 id="2-2-矩阵求逆"><a href="#2-2-矩阵求逆" class="headerlink" title="2.2 矩阵求逆"></a>2.2 矩阵求逆</h5><p>通过LUP分解计算逆矩阵</p><p>矩阵算法和矩阵求逆</p><h5 id="2-3-对称正定矩阵和最小二乘逼近"><a href="#2-3-对称正定矩阵和最小二乘逼近" class="headerlink" title="2.3 对称正定矩阵和最小二乘逼近"></a>2.3 对称正定矩阵和最小二乘逼近</h5><h4 id="3-线性规划"><a href="#3-线性规划" class="headerlink" title="3 线性规划"></a>3 线性规划</h4><p>一个政治问题</p><p>一般线性规划</p><p>线性规划综述</p><p>单纯形法</p><p>线性规划算法</p><h5 id="3-1-松弛型和标准型"><a href="#3-1-松弛型和标准型" class="headerlink" title="3.1 松弛型和标准型"></a>3.1 松弛型和标准型</h5><p>转换线性规划为标准型</p><p>转换线性规划为松弛型</p><h5 id="3-2-将问题表达为线性规划"><a href="#3-2-将问题表达为线性规划" class="headerlink" title="3.2 将问题表达为线性规划"></a>3.2 将问题表达为线性规划</h5><p>最短路径</p><p>最大流</p><p>最小费用流</p><p>多商品流</p><h5 id="3-3-单纯形算法"><a href="#3-3-单纯形算法" class="headerlink" title="3.3 单纯形算法"></a>3.3 单纯形算法</h5><h5 id="3-4-对偶性"><a href="#3-4-对偶性" class="headerlink" title="3.4 对偶性"></a>3.4 对偶性</h5><h5 id="3-5-初始基本可行解"><a href="#3-5-初始基本可行解" class="headerlink" title="3.5 初始基本可行解"></a>3.5 初始基本可行解</h5><h4 id="4-多项式与快速傅立叶变化"><a href="#4-多项式与快速傅立叶变化" class="headerlink" title="4 多项式与快速傅立叶变化"></a>4 多项式与快速傅立叶变化</h4><h5 id="4-1-多项式的表示"><a href="#4-1-多项式的表示" class="headerlink" title="4.1 多项式的表示"></a>4.1 多项式的表示</h5><p>系数表示</p><p>点值表示</p><p>系数形式表示的多项式的快速乘法</p><h5 id="4-2-DFT与FFT"><a href="#4-2-DFT与FFT" class="headerlink" title="4.2 DFT与FFT"></a>4.2 DFT与FFT</h5><p>单位复数根</p><p>在单位复数根处插值</p><h5 id="4-3-高效FFT实现"><a href="#4-3-高效FFT实现" class="headerlink" title="4.3 高效FFT实现"></a>4.3 高效FFT实现</h5><p>FFT的一种迭代实现</p><p>并行FFT电路</p><h4 id="5-数论算法"><a href="#5-数论算法" class="headerlink" title="5 数论算法"></a>5 数论算法</h4><p>输入规模与算数计算的代价</p><h5 id="5-1-基础数论概念"><a href="#5-1-基础数论概念" class="headerlink" title="5.1 基础数论概念"></a>5.1 基础数论概念</h5><h5 id="5-2-最大公约数"><a href="#5-2-最大公约数" class="headerlink" title="5.2 最大公约数"></a>5.2 最大公约数</h5><p>欧几里得算法</p><p>运行时间</p><h5 id="5-3-模运算"><a href="#5-3-模运算" class="headerlink" title="5.3 模运算"></a>5.3 模运算</h5><h5 id="5-4-求解模线性方程"><a href="#5-4-求解模线性方程" class="headerlink" title="5.4 求解模线性方程"></a>5.4 求解模线性方程</h5><h5 id="5-5-中国余数定理"><a href="#5-5-中国余数定理" class="headerlink" title="5.5 中国余数定理"></a>5.5 中国余数定理</h5><h5 id="5-6-元素的幂"><a href="#5-6-元素的幂" class="headerlink" title="5.6 元素的幂"></a>5.6 元素的幂</h5><h5 id="5-7-RSA公钥加密系统"><a href="#5-7-RSA公钥加密系统" class="headerlink" title="5.7 RSA公钥加密系统"></a>5.7 RSA公钥加密系统</h5><h5 id="5-8-素数的测试"><a href="#5-8-素数的测试" class="headerlink" title="5.8 素数的测试"></a>5.8 素数的测试</h5><p>素数的密度</p><p>伪素树测试过程</p><p>Miller-Rabin随机性素树测试方法</p><h5 id="5-9-整数的因子分解"><a href="#5-9-整数的因子分解" class="headerlink" title="5.9 整数的因子分解"></a>5.9 整数的因子分解</h5><h4 id="6-字符串匹配"><a href="#6-字符串匹配" class="headerlink" title="6 字符串匹配"></a>6 字符串匹配</h4><h5 id="6-1-朴素字符串匹配算法"><a href="#6-1-朴素字符串匹配算法" class="headerlink" title="6.1 朴素字符串匹配算法"></a>6.1 朴素字符串匹配算法</h5><h5 id="6-2-Rabin-Karp算法"><a href="#6-2-Rabin-Karp算法" class="headerlink" title="6.2 Rabin-Karp算法"></a>6.2 Rabin-Karp算法</h5><h5 id="6-3-利用有限自动机进行字符串匹配"><a href="#6-3-利用有限自动机进行字符串匹配" class="headerlink" title="6.3 利用有限自动机进行字符串匹配"></a>6.3 利用有限自动机进行字符串匹配</h5><h5 id="6-4-Knuth-Morris-Pratt算法"><a href="#6-4-Knuth-Morris-Pratt算法" class="headerlink" title="6.4 Knuth-Morris-Pratt算法"></a>6.4 Knuth-Morris-Pratt算法</h5><p>关于模式的前缀函数</p><p>运行时间分析</p><p>前缀函数计算的正确性</p><p>KMP算法的正确性</p><h4 id="7-计算几何学"><a href="#7-计算几何学" class="headerlink" title="7 计算几何学"></a>7 计算几何学</h4><h5 id="7-1-线段的性质"><a href="#7-1-线段的性质" class="headerlink" title="7.1 线段的性质"></a>7.1 线段的性质</h5><p>叉积、确定连续线段是向左转还是向右转、判定两条线段是否相交</p><h5 id="7-2-确定任意一对线段是否相交"><a href="#7-2-确定任意一对线段是否相交" class="headerlink" title="7.2 确定任意一对线段是否相交"></a>7.2 确定任意一对线段是否相交</h5><p>线段排序</p><p>移动扫除线</p><h5 id="7-3-寻找凸包"><a href="#7-3-寻找凸包" class="headerlink" title="7.3 寻找凸包"></a>7.3 寻找凸包</h5><p>增量法、分治法、剪纸-搜索法</p><p>Graham扫描法</p><h4 id="8-NP完全性"><a href="#8-NP完全性" class="headerlink" title="8 NP完全性"></a>8 NP完全性</h4><p>最短与最长路径</p><p>欧拉回路与哈密顿圈</p><p>2CNF可满足性问题与3-CNF可满足性问题</p><p>NP完全性与P类问题和NP类问题</p><p>证明NP完全问题概述</p><p>判定问题与最优化问题</p><p>归约</p><h5 id="8-1-多项式时间"><a href="#8-1-多项式时间" class="headerlink" title="8.1 多项式时间"></a>8.1 多项式时间</h5><p>抽象问题</p><p>编码</p><p>形式语言体系</p><h5 id="8-2-多项式时间的验证"><a href="#8-2-多项式时间的验证" class="headerlink" title="8.2 多项式时间的验证"></a>8.2 多项式时间的验证</h5><p>哈密顿回路</p><p>验证算法</p><p>复杂类NP</p><h5 id="8-3-NP完全性和可归约性"><a href="#8-3-NP完全性和可归约性" class="headerlink" title="8.3 NP完全性和可归约性"></a>8.3 NP完全性和可归约性</h5><h5 id="8-4-NP完全性的证明"><a href="#8-4-NP完全性的证明" class="headerlink" title="8.4 NP完全性的证明"></a>8.4 NP完全性的证明</h5><h5 id="8-5-NP完全问题"><a href="#8-5-NP完全问题" class="headerlink" title="8.5 NP完全问题"></a>8.5 NP完全问题</h5><p>&#x3D;&#x3D;团问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;哈密顿回路问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;旅行商问题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;子集和问题&#x3D;&#x3D;</p><h4 id="9-近似算法"><a href="#9-近似算法" class="headerlink" title="9 近似算法"></a>9 近似算法</h4><p>顶点覆盖问题</p><p>旅行商问题</p><p>随机化和线性规划</p><p>子集和问题</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链</title>
    <link href="/blog/2022/09/01/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/blog/2022/09/01/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>讨论：速度最慢的数据库、下一代价值互联网</p><h3 id="1、比特币中的密码学原理"><a href="#1、比特币中的密码学原理" class="headerlink" title="1、比特币中的密码学原理"></a>1、比特币中的密码学原理</h3><p>比特币又称加密货币，用到了密码学上的哈希和签名</p><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>密码学上的哈希函数cryptographic hash function两个重要性质：</p><ul><li>collision resistance，两个不同的输入算出来的哈希值相等，称为哈希碰撞，哈希碰撞无法避免，这里是指没有高效的方法人为制造哈希碰撞。<ul><li>MD5曾经是很流行的哈希函数，但现在已经知道如何人为制造哈希碰撞了。</li></ul></li><li>hiding：哈希函数的计算过程是单向的，不可逆的。无法通过哈希值反推输入的内容，哈希值没有泄露输入的信息。</li><li>二者结合在一起，可以实现：digital commitment&#x2F;digital equivalent of a sealed envelope，但要注意，需要输入空间足够大、输入分布要尽量均匀。输入空间不够大时，可以给输入值后面拼接随机数再一起取hash，以保证输入随机且分布均匀。</li><li>比特币中用到的哈希函数还要求第三个性质：puzzle friendly。<ul><li>挖矿：寻找随机数nonce，拼接到block header，使得$H(\text {block header}) \le target$，需要大量的计算，挖矿很难、验证很容易（difficult to solve, but easy to verify）。</li></ul></li></ul><p>比特币中的哈希函数叫做<code>SHA-256</code>。</p><h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>开账户：在本地创立一个公钥和私钥的对（public key, private key)，这就代表了一个比特币的账户，公私钥的概念来自非对称的加密体系（asymmetric encryption algorithm）</p><ul><li>对称加密体系需要安全的网络环境，不能以明文形式在网络上传输，密钥的分发不是很方便。</li><li>非对称加密体系：加密用公钥、解密用私钥，公钥可以公开。</li></ul><p>比特币系统是不加密的，信息都是公开的，公私钥的作用主要就是签名， 发起交易时用自己的私钥签名，其他人用公钥验证，证明交易来自本人。</p><p>生成公私钥的过程要是随机的，比特币中每一次签名时也要有好的随机源，一次随机源不好就有可能泄露私钥。</p><h3 id="2、比特币的数据结构"><a href="#2、比特币的数据结构" class="headerlink" title="2、比特币的数据结构"></a>2、比特币的数据结构</h3><p>哈希指针（hash pointers）：存地址+hash值。（找到位置，检测是否有被篡改）</p><p><strong>区块链：</strong></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt="区块链的数据结构"></p><p>取hash时，是将前一个区块的内容（包括保存的hash值）一起取hash，通过这个数据结构可以实现tamper-evident log：只要记住系统里保存的最后一个hash值，就可以检测出对区块链任何部位的修改。</p><p><strong>Merkle tree：</strong></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).jpg" alt="merkle tree"></p><p>用hash指针代替了普通的指针。记住根hash值，就能检测出对数中任何节点的修改，效率更高。每个区块分为两部分：块头和块身。</p><ul><li>block header：仅存储这个区块所包含的所有交易组成的merkle tree组成的根hash值。</li><li>block body：有交易列表。</li></ul><p>Merkle tree的用途：</p><ul><li><p>提供merkle proof：从需验证的交易往上找到根节点，这个路径上的节点就是merkle proof，从下往上验证，沿途的这些hash值都是正确的就行了。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/e65b588da577865af9a1ad6b7339f89.png" alt="merkle proof"></p></li><li><p>proof of membership&#x2F;proof of inclusion：$O(log(n))$</p></li><li><p>proof of non-membership：$O(n)$</p></li><li><p>Sorted merkle tree：对hash值排序</p></li></ul><blockquote><p>hash指针不适用于有环的情况，会出现数据相互依赖从而没有一个区块的数据能定下来。</p></blockquote><h3 id="3、比特币协议"><a href="#3、比特币协议" class="headerlink" title="3、比特币协议"></a>3、比特币协议</h3><p>使用公私钥发行货币：double spending attack</p><p>使用编号，每次使用货币向央行验证归属：央行超负荷（中心化方案）</p><p>将央行的职能改为由用户共同承担（去中心化方案）</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(3).jpg" alt="未命名文件 (3)"></p><p>比特币系统中每个交易都包含了输入和输出两个部分，输入部分要给出币的来源，输出部分要给出收款人公钥的hash。</p><p>付款人的公钥是付款人交易时给出，但可能为伪造，为了验证交易真实，使用付款人给出的公钥和币的来源时的公钥核对。（有借必有贷、借贷必相等）</p><ul><li><p>block header：保存宏观信息</p><ul><li>version 使用比特币哪个版本的协议</li><li>hash of previous block header 区块链中指向前一个区块的指针</li><li>Merkle root hash merkle tree的根hash值</li><li>target 挖矿的难度目标阈值</li><li>nonce 随机数</li></ul></li><li><p>block body：保存交易数据</p><ul><li>transaction list 交易列表</li></ul></li></ul><p>系统中的节点分为全节点(full node)和轻节点(light node)，全节点保存区块链的所有信息，验证每一个交易，也叫fully validating node，轻节点只保存block header，一般来说，轻节点无法独立验证交易的合法性。系统中大部分节点是轻节点，不参与区块链的构造和维护，只是利用区块链的信息做查询等。</p><p>账本的内容要取得分布式的共识 distributed consensus：系统里有很多台机器，共同维护一个全局的hash表（distributed hash table）。</p><p>分布式系统有很多不可能结论，例FLP impossibility result：在一个异步(asynchronous)的系统里(网络传输时延没有上限)，那么即使只有一个成员是有问题的(faulty)，那么也不可能取得共识。</p><p>CAP Theorem：一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)，这三个性质中最多只能满足两个，不可能三个都满足。</p><p>分布式共识的一个重要协议：Paxos(确保一致性)</p><p>比特币中的共识协议：有些节点可能是有恶意的，假设系统中大多数节点是好的。</p><ul><li><p>使用投票：需要先确定谁有投票权(membership)，例如联盟链(hyperledger fabric)，只有某些符合条件的大公司才可以加入，此时基于投票的方案是可行的。但比特币产生账户是很容易的，不需要批准，只有跟外部发生交易时才知道有这个账户存在，可能受到女巫攻击(sybil attack)。</p></li><li><p>比特币中的解决方案：用计算力来投票。</p><ul><li><p>每个节点都可以在本地组装出一个候选区块，把他认为合法的交易放在区块里，然后尝试各种nonce值(4 bytes)，看哪一个能满足不等式要求，求出hash落在指定范围内，如果某个节点找到了符合要求的nonce，就获得了记账权，也即往比特币这个去中心化的系统里写入下一个区块的权力，只有找到nonce，获得记账权的节点才有资格发布下一个区块。</p></li><li><p>其他节点收到这个区块后，要验证这个区块的合法性(验证block header的内容是否正确；目标阈值的编码——nBits域，检查nBits域是否符合比特币协议中规定的难度要求；检查nonce是否使$H(\text {block header}) \le target$成立)，假设都符合要求，然后看block body里的交易列表，验证每个交易都是合法的(要有合法的签名；以前没有被花过)，如果有任何一个不符合要求，那么这个区块是不能被接收的，要被放弃掉。</p></li><li><p>最长合法链 longest vaild chain：假设有一个区块经过检查，都是符合要求的，但如果不在最长链上，也有可能不被接收。比特币协议中规定：接受的区块应该是在扩展最长合法链。（分叉攻击的例子forking attack：通过往中间插入区块，来回滚已经发生了的交易）</p><ul><li>如果两个节点在差不多同一个时间找到了符合要求的nonce，都可以发布区块，这时候会出现两个等长的分叉，按最长合法链原则，这两个都是合法的。</li><li>比特币中，缺省情况下，每个节点是接收它最早收到的那个。</li><li>等长的临时性的分叉可能会维持一段时间，直到最后有某个区块是胜出的，也即沿着这个区块往下扩展，其他分支又被称为orphan block。</li></ul></li><li><p>获得记账权的节点本身有一定权利，可以决定哪些交易被写到下个区块里，但是设计协议时不应该让这个成为争夺记账权的主要动力，因为凡是合法的交易，都应该能被写到区块链里。</p><ul><li><p>出块奖励 block reward 比特币协议中规定，获得记账权的节点在发布的区块里，可以有一个特殊的交易，即铸币交易，在这个交易里可以发布一定数量的比特币。</p></li><li><p>coinbase transaction 是比特币系统中发行新比特币的唯一方法，其他所有的交易都只是把已有的比特币把一个账户转移到另一个账户，包括用法币购买比特币，也没有产生新的比特币。</p></li><li><p>比特币刚上线时，每一个发布的区块可以产生50BTC，21万个区块之后，这个出块奖励就要减半，即25BTC，再过21万个区块，再次减半，即12.5BTC。</p><blockquote><p>21万个区块平均是4年，每隔4年出块奖励减半。</p></blockquote></li></ul></li></ul></li></ul><p>以上即是比特币里的共识机制。</p><h3 id="4、比特币系统的实现"><a href="#4、比特币系统的实现" class="headerlink" title="4、比特币系统的实现"></a>4、比特币系统的实现</h3><p>比特币采取基于交易的账本模式 transaction-based ledger，每个区块里记录的是交易信息，有转账交易、有铸币交易，但是系统中没有显式的记录每个账户有多少钱，需要经过交易记录来推算。</p><p>比特币中的全节点要维护一个UTXO的数据结构(Unspent Transaction Output)——还没有被花出去的交易的输出组成的集合。一个交易可能有多个输出，Utxo中的每个元素要给出产生这个输出的交易的hash值，以及它在这个交易里是第几个输出。新发起的交易是否合法，要查询Utxo，只有在这个集合里才是合法的，维护Utxo以便快速检测double spending。</p><p>每个交易可以有多个输入，也可以有多个输出，所有输入的金额加起来要等于输出的金额。</p><blockquote><p> 有时可能不等，涉及到比特币系统的第二个激励机制：transaction fee</p></blockquote><p>以太坊采取基于账户的模式 account_based ledger，这个模式之中，系统要显式的记录每个账户上有多少个币。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/e905bb6edc2ab35cd4c40a7b8616245.png" alt="e905bb6edc2ab35cd4c40a7b8616245"></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/62f9439c6b117abb1d982f4a890709a.png" alt="62f9439c6b117abb1d982f4a890709a"></p><blockquote><p>求hash时只用到了block header的内容，block header里有merkle tree的根hash值，这已经能保证整个区块里的交易是不能被篡改的。</p></blockquote><h4 id="挖矿过程的概率分析"><a href="#挖矿过程的概率分析" class="headerlink" title="挖矿过程的概率分析"></a>挖矿过程的概率分析</h4><p>挖矿即不断尝试nonce，求解puzzle，每次尝试nonce可以看做是一个伯努利实验Bernoulli trial（a random experiment with binary outcome），大量尝试这个过程，构成了一个Bernoulli process（a sequence of independent Bernoulli trials），具有无记忆性（memoryless）。</p><p>每次尝试nonce，成功的可能性很小，需要尝试大量的nonce，才有可能找到符合要求的，这个情况下，Bernoulli process可以用Poisson process来近似（实验的次数很多，每次实验成功的概率很小）。</p><p>出块时间服从指数分布（exponential distribution），整个系统的平均出块时间是10min，这个平均时间是比特币协议设计出来的，通过定期调整挖矿难度，使得平均出块时间维持在10min左右，具体到每一个矿工，能挖到下一个区块的时间，取决于这个矿工的算力占系统总算力的百分比。出块时间的分布也是无记忆的，将来还要挖多少时间跟过去已经挖了多少时间是没有关系的，仍然服从指数分布，平均还是要10min，这个性质也成progress free（过去的progress是没有用的）。</p><blockquote><p>如果没有这个特点，算力强的矿工会有不成比例的优势，这恰恰是挖矿公平性的保证。</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/1.png" alt="1"></p><h4 id="比特币的总量"><a href="#比特币的总量" class="headerlink" title="比特币的总量"></a>比特币的总量</h4><p>出块奖励是系统中产生新的比特币的唯一途径。而出块奖励每隔四年减半，这样产生的比特币数量就构成了一个几何序列（geometric series）：$21万<em>50+21万</em>25+21万<em>12.5+\dots &#x3D; 21万</em>50*(1+\frac 1 2+\frac 1 4+\dots ) &#x3D; 21万<em>50</em>2 &#x3D;210万$</p><p>比特币的puzzle除了比拼算力之外，没有其他的实际意义，比特币越来越难挖到是因为出块奖励被人为的减少了，比特币的稀缺性是人为造成的。</p><p>但是，挖矿的过程对于维护比特币系统的安全性是至关重要的：Bitcoin is secured by mining。对于一个去中心化的，没有membership控制的系统来说，挖矿提供了一种凭借算力投票的有效手段，只要大部分算力掌握在诚实的节点手里，比特币的安全性就能得到保证，挖矿这个过程虽然表面上看没有实际意义，但是这个机制的设立对于维护整个系统的安全性是非常有效的。</p><h4 id="比特币安全性分析"><a href="#比特币安全性分析" class="headerlink" title="比特币安全性分析"></a>比特币安全性分析</h4><p>假设大部分算力掌握在诚实的矿工手里，是否能保证写入区块链的交易都是合法的？</p><ul><li><p>恶意节点伪造交易：没有对方的私钥无法签名。</p></li><li><p>定义有恶意的攻击是否成功的标准，是看他能不能让诚实的节点接受这个交易，如果仅是恶意节点之间互相认账，诚实节点都不认账，那是没有用的，因为比特币是扩展最长合法链，恶意的区块相当于作废，这对于攻击者来说会损失出块奖励。（&#x3D;&#x3D;这里老师讲的是恶意节点多长都没有用，可如果这个节点本来是诚实的，他后面延伸了很多节点，后来它变成恶意的了，这条链不再扩展，那么它后面的诚实链会受到影响吗？&#x3D;&#x3D;）</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(0).jpg" alt="未命名文件 (0)"></p></li><li><p>能否把已经花出去的币再花一遍？</p></li><li><p>区块插在哪个位置，是要在刚开始挖矿时就要决定的，因为设置的block header里要填前一个区块的hash，如果想插在某个节点之后，一开始就要把该节点设置为前一个区块，而不是等获得了记账权之后再说。防范双花攻击的办法是多等几个区块&#x2F;确认，比特币协议中缺省要等六个confirmation，此时才认为前面一个交易是不可篡改的，平均出块时间10min，这个过程要等一个小时。</p></li></ul><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/4.jpg" alt="4"></p><ul><li><p>零确认 zero confirmation：这个转账交易发布出去，但还没有被写入区块链。比特币中缺省的设置是节点接收最先听到的交易；实际交易天然有时间间隔。</p></li><li><p>恶意节点是否能故意不把合法的交易写在区块链？</p></li><li><p>可以，但合法的交易可以写在下一个区块里，总有诚实的节点愿意发布这些交易，比特币协议规定，区块的大小有限制，最多不能超过1M字节，所以如果交易太多，有些交易就只能等到下一个区块再发布。</p></li><li><p>是否可以隐藏算好的区块，等到交易目标达成再同时发布，以超越已形成的区块&#x2F;confirmation，成为最长链？（selfish mining）</p></li><li><p>正常的情况是挖到区块马上发布，以免被其他人挖到损失奖励，这个攻击成功的前提是需要占到很大的算力。（不可能越级挖，因为每个块需要前一个块的hash，前面一个区块没挖出来，没办法提前准备好）</p><blockquote><p>selfish mining 的另一个目的：减少竞争。</p><p>藏一个块，用两个块竞争，但也有风险，还是拼算力。</p></blockquote></li></ul><h3 id="5、比特币网络"><a href="#5、比特币网络" class="headerlink" title="5、比特币网络"></a>5、比特币网络</h3><p>用户把交易发布到比特币网络上，节点收到这些交易把他们打包到区块里，然后把区块发布到比特币网络上，这些新发布的交易和区块在比特币网络上如何传播？</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/5.jpg" alt="5"></p><p>比特币网络的设计原则：简单、鲁棒而非高效。</p><p>消息以flooding的方式传播：节点第一次收到消息时，将它传播给其他邻居节点，同时记录已收到这个消息，下次再收到这个消息，就不再转发给邻居节点，邻居节点的选取是随机的，不考虑底层的拓扑结构，鲁棒性很强，但牺牲了效率。</p><p>比特币系统中每个节点要维护一个等待上链交易的集合，第一次听到某个交易时，把这个交易写入集合，并且转发这个交易，再收到这个交易就不转发，转发的前提是交易合法（有合法的签名，以前没有被花过）。</p><p>集合中的交易一旦写入区块链，就要从集合中删掉，如果因为某个区块链里的交易导致集合里出现了非法交易，也要删除非法交易。</p><blockquote><p>risk condition：有两个有冲突的交易，差不多同时被广播到网络上，那么每个节点因为在网络上的位置不同，先收到的交易不同。</p></blockquote><p>新发布的区块在网络上的传播方式跟新发布的交易是类似的，每个节点除了检查区块的内容的合法性，还要检查它是否在最长合法链上，越是大的区块在网络上的传播速度就越慢。</p><p>best effort：一个交易发布到比特币网络上，不一定所有的节点都能收到，而且不同的节点收到交易的顺序也可能是不一样的，网络传播存在延迟，且有的节点不一定按照比特币协议的要求进行转发，也有的节点可能转发不合法的交易，这是一个去中心化的系统中面临的实际问题。</p><h3 id="6、比特币的挖矿难度调整"><a href="#6、比特币的挖矿难度调整" class="headerlink" title="6、比特币的挖矿难度调整"></a>6、比特币的挖矿难度调整</h3><p>挖矿：不断尝试block header里的nonce值，使整个block header的哈希值小于等于给定的目标阈值。即$H(\text{block header}) \le target$。$target$越小，挖矿难度越大，调整挖矿难度就是调整目标空间在整个输出空间中所占的比例。</p><p>比特币用的哈希算法是SHA-256，产生的哈希值是256位，所以整个输出空间是$2^{256}$个可能的取值，调整这个比例就是哈希值前面有多少个0（不准确）。</p><p>出块时间太短会出现的问题：</p><ul><li>分叉会成为常态，分叉过多，对于不利于系统达成共识，也危害系统安全（比特币协议假设大部分算力掌握在诚实的矿工手里，系统的总算力越强，安全性越好）。恶意节点可以集中算力扩展成最长合法链。</li></ul><p>比特币协议中规定：每隔2016个区块，要重新调整目标阈值，大概是每两个星期调整一下（$\frac {2016<em>10} {60</em>24} &#x3D; 14天$）。具体调整方式为$target &#x3D; target * \frac {\text{actual time}} {\text{experted time}}$，目标阈值增大最多增大4倍，不会超过4倍；目标阈值缩小最多缩小$\frac 1 4$，不会超过$\frac 1 4$。</p><p>计算$target$的方法是写在比特币系统的代码里，每挖到2016个区块会自动进行调整，代码开源，如果$target$被恶意修改，诚实的矿工不会承认。</p><ul><li>nBits域：$target$编码的版本，在block header里没有直接存储$target$，因为需要256位&#x2F;32个字节，而nBits只有4个字节，可以认为是一个压缩编码，如果没有按规则调整$target$，检查区块合法性就无法通过，因为每个节点要独立验证发布的区块的合法性。</li></ul><h3 id="7、比特币挖矿"><a href="#7、比特币挖矿" class="headerlink" title="7、比特币挖矿"></a>7、比特币挖矿</h3><p>全节点</p><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿<ul><li>决定验证哪条链挖下去</li><li>当出现等长的分叉的时候，选择哪一个分叉</li></ul></li></ul><p>轻节点</p><ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头（1000倍）</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法校验大多数交易的合法性，只能校验与自己相关的那些交易的合法性</li><li>无法检测网上发布的区块的正确性</li><li>可以验证挖矿的难度</li><li>只能检测哪个是最长链，不知道哪个是最长合法链</li></ul><p>比特币怎么保证安全性</p><ul><li>密码学上的保证：没有私钥，就无法伪造签名，不能将他人账上的前转走，前提是，系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受那些没有合法签名的交易，如果没有这一点，密码学上的保证就没有用武之地。</li><li>共识机制</li></ul><p>挖矿设备</p><ul><li><p>趋于专业化：CPU挖矿（通用计算机、笔记本电脑）→ GPU挖矿（主要用于大规模的并行计算，例如深度学习，大量的矩阵乘法） → ASIC芯片（application specific integrated circulation）</p></li><li><p>大型矿池的出现：单个矿工即使用了ASIC芯片，挖矿从平均收益上看是有利可图的，但是收益是非常不稳定的，除了挖矿外，单个矿工还要承担全节点的其他责任。矿池就是把矿工组织起来成为一个整体，矿石的架构是一个全节点会驱动很多矿机。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/6.jpg" alt="6"></p><p>矿工只负责计算哈希值，全节点的其他职责都由pool manager来承担（监听网上的交易、把交易组织打包成候选区块、是否有其他节点抢先发布区块，有的话要进行调整）。</p><p>矿池的出现解决了收入不稳定的问题，收入分配时，矿主以矿工提交的较简单的almost valid block作为share的数量为依据进行分配。</p><p>是否会出现矿工挖到矿后不提交给矿池，自己独占奖励？</p><ul><li>不可行，每个矿工的任务是有矿主分配的，矿主负责组装好区块，然后交给矿工尝试nonce，光是调整nonce是不够的，还要调整coinbase，矿主可能把不同的coinbase对应的nonce值的范围交给不同的矿工尝试，coinbase transaction的地址填的是矿主的地址，所以矿工挖到区块后不提交给矿主，自己提交是无用的。</li></ul><p>大型矿池的一个弊病：51%的攻击更容易了（分叉攻击、双花攻击、Boycott封锁某个账户）。类似云计算里的on demand computing，此处为on demand mining，矿石带来的潜在危害。</p></li></ul><h3 id="8、比特币脚本"><a href="#8、比特币脚本" class="headerlink" title="8、比特币脚本"></a>8、比特币脚本</h3><p>唯一能访问的内存空间就是堆栈，所以是基于栈的语言。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/fb118d0f3f3f69f20c421b3b978ce13.jpg" alt="fb118d0f3f3f69f20c421b3b978ce13"></p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/a44e90b2b47b4759d5d81b91b166c8f.jpg" alt="a44e90b2b47b4759d5d81b91b166c8f"></p><blockquote><p>每个输入都要说明这个输入的币来自之前哪个交易的输出，前两行给出输入的币的来源，第三项是输入脚本，给出signature证明有权力花这个钱。</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/2175087397b6f48030dd2daf87dc210.jpg" alt="2175087397b6f48030dd2daf87dc210"></p><blockquote><p>scriptPublicKey是输出脚本，asm是输出脚本内容，包含一系列操作，reqSigs表示这个输出需要多少个签名才能兑现，type是输出的类型，这里表示公钥的哈希，addresses是输出的地址。</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/df1c2ac503eaaa4ca31f23169e91964.jpg" alt="df1c2ac503eaaa4ca31f23169e91964"></p><blockquote><p>输出脚本要与输入脚本匹配</p></blockquote><p>输入输出脚本的形式</p><ul><li><p>P2PK(Pay to Public Key)</p><ul><li><p>input script</p><ul><li>PUSHDATA(Sig)</li></ul></li><li><p>output script</p><ul><li>PUSHDATA(PubKey)&#x2F;&#x2F;输出脚本里直接给出收款人的公钥。</li><li>CHECKSIG&#x2F;&#x2F;检查签名，在输入脚本里直接检查签名，签名是用私钥对输入脚本所在的整个交易的签名，是最简单的。</li></ul></li><li><p>实例：</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/9f2bc3262d66508b9926191b78f1d49.jpg" alt="9f2bc3262d66508b9926191b78f1d49"></p></li></ul></li><li><p>P2PKH(Pay to Public Key Hash)</p><ul><li><p>input script</p><ul><li>PUSHDATA(Sig)&#x2F;&#x2F;把签名压入栈</li><li>PUSHDATA(Public)&#x2F;&#x2F;把公钥压入栈</li></ul></li><li><p>output script</p><ul><li>DUP&#x2F;&#x2F;把栈顶元素复制一遍(栈顶为两个公钥)</li><li>HASH160&#x2F;&#x2F;把栈顶元素弹出来，取哈希，然后把得到的哈希值压入栈(栈顶为公钥的哈希值)(输入脚本里给出的公钥)</li><li>PUSHDATA(PubKeyHash)&#x2F;&#x2F;把输出脚本里提供的公钥的哈希值压入栈(收款人的公钥的哈希)</li><li>EQUALVERIFY&#x2F;&#x2F;弹出栈顶两个元素是否相等，防止冒名顶替</li><li>CHECKSIG&#x2F;&#x2F;弹出栈顶的两个元素，用公钥检查签名</li></ul></li><li><p>实例</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/0223bb1d47a9820801fef7d25ca796d.jpg" alt="0223bb1d47a9820801fef7d25ca796d"></p></li></ul></li><li><p>P2SH(Pay to Script Hash)</p><ul><li><p>采用BIP16的方案</p></li><li><p>input script</p><ul><li><p>……</p></li><li><p>PUSHDATA(Sig)</p></li><li><p>……</p></li><li><p>PUSHDATA(serialized redeemScript)</p></li></ul></li><li><p>output script</p><ul><li>HASH160</li><li>PUSHDATA(redeemScriptHash)(赎回脚本)</li><li>EQUAL</li></ul></li><li><p>input script要给出一些签名（数目不定）及一段序列化的redeemScript，验证分为如下两步：</p><ul><li>验证序列化的redeemScript是否与output script中的哈希值匹配</li><li>反序列化并执行redeemScript，验证input script中给出的签名是否正确</li></ul></li><li><p>redeemScript的形式</p><ul><li>P2PK形式</li><li>P2PKH形式</li><li>多重签名形式</li></ul></li><li><p>例：用P2SH实现P2PK</p><ul><li>redeemScript<ul><li>PUSHDATA(PubKey)</li><li>CHECKSIG</li></ul></li><li>input script<ul><li>PUSHDATA(Sig)</li><li>PUSHDATA(serialized redeemScript)</li></ul></li><li>output script<ul><li>HASH160</li><li>PUSHDATA(redeemScriptHash)</li><li>EQUAL</li></ul></li></ul></li><li><p>P2SH的一个常见场景是对多重签名的支持</p><ul><li><p>比特币系统中一个输出可能性需要多个签名才能把钱取出来</p></li><li><p>最早的多重签名，目前已不推荐使用</p><ul><li>input script<ul><li>X&#x2F;&#x2F;需要多压一个没用的元素，已对应CHECKMULITISIG的bug</li><li>PUSHDATA(Sig_1)</li><li>PUSHDATA(Sig_2)</li><li>……</li><li>PUSHDATA(Sig_M)</li></ul></li><li>outputScript<ul><li>M</li><li>PUSHDATA(pubkey_1)</li><li>PUSHDATA(pubkey_2)</li><li>……</li><li>PUSHDATA(pubkey_N)</li><li>N</li><li>CHECKMULTISIG</li></ul></li></ul></li><li><p>用P2SH实现多重签名</p><ul><li>把输出脚本的复杂度转移到输入脚本</li><li>redeemScript<ul><li>M</li><li>PUSHDATA(pubkey_1)</li><li>PUSHDATA(pubkey_2)</li><li>……</li><li>PUSHDATA(pubkey_N)</li><li>N</li><li>CHECKMULTISIG</li></ul></li><li>input script<ul><li>X</li><li>PUSHDATA(Sig_1)</li><li>PUSHDATA(Sig_2)</li><li>……</li><li>PUSHDATA(Sig_M)</li><li>PUSHDATA(serialized RedeemScript)</li></ul></li><li>output script<ul><li>HASH160</li><li>PUSHDATA(RedeemScriptHash)</li><li>EQUAL</li></ul></li></ul></li><li><p>实例</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/3694329da6ab2de67074e3d6382151d.jpg" alt="3694329da6ab2de67074e3d6382151d"></p></li></ul></li></ul></li><li><p>Proof of Burn</p><ul><li><p>output script</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs script">RETURN //无条件返回错误，包含这个操作的脚本永远不可能通过验证<br>[zero or more ops or test]<br></code></pre></td></tr></table></figure><p>这种形式的output被称为：Provably Unspendable&#x2F;Prunable Outputs</p></li><li><p>脚本说明</p><p>假如有一个交易的input指向这个output，无论input里的input script如何设计，执行到RETURN命令之后都会直接但会false，不会执行RETURN后面的其他指令，所以这个output无法再被花出去，其对应的UTXO也就可以被剪枝了，无需保存。</p><p>应用场景：</p><ul><li><p>这个脚本是证明销毁比特币的一种方法，有些小币种要求销毁一定数量的比特币才能得到这个币种（AltCoin）。</p></li><li><p>在区块链里添加需要永久保存的内容，如digital commitment，把某项知识产权的内容取hash后，把hash值放在RETURN语句的后面，不会占很大的内容，也不会泄露知识产权的内容，应对知识产权的纠纷。</p><blockquote><p>coinbase域里也可以随意写内容，且不用销毁比特币，但只有获得记账权的节点才能用。</p></blockquote></li></ul></li></ul></li></ul><blockquote><p>注：简单起见，所有的操作都省略了OP_前缀，例：OP_CHECKSIG、OP_DUP</p><p>比特币的脚本语言不支持循环，就不会有死循环</p></blockquote><h3 id="9、比特币分叉"><a href="#9、比特币分叉" class="headerlink" title="9、比特币分叉"></a>9、比特币分叉</h3><p>分叉的原因：两个节点差不多同时挖到矿，会出现临时性的分叉（state fork）；分叉攻击（forKing attack&#x2F;deliberate fork）；比特币的协议发生了改变，去中心化的系统中升级软件没办法保证所有节点都升级（protocal fork），根据对协议修改的内容的不同，又可分为硬分叉（hard fork）和软分叉（soft fork）。</p><p>硬分叉：对比特币协议增加一些新的特性，这时候没有升级软件的旧的节点不认可这些特性，认为这些特性非法。一个例子是比特币协议中的区块大小限制（block size limit），某些新节点改为了4M，旧节点依然是1M，只要旧节点不更新软件，这个分叉就不会消失。出现hard fork后变成了两条平行的链，彼此之间有各自的加密货币（社区分裂），分叉前的链理论上分叉后的链都会认，但会出现问题，后来分裂的链会带一条chain Id。</p><blockquote><p>目前区块大小限制</p><p>$\frac {1000000} {250} &#x3D; 4000$   $\frac {4000} {60*10} &#x3D; 7 tx&#x2F;s$</p></blockquote><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/7.jpg" alt="7"></p><p>软分叉：对比特币协议加一些限制，原来合法的交易&#x2F;区块，在新的协议中可能变得不合法。例某些新节点将区块大小限制改为了0.5M，旧节点依然是1M，因为新旧节点都认可的是0.5M的分叉，所以之后所有节点都会在0.5M的链上扩展，迫使其更新协议，系统不会有永久性的分叉。</p><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(4).jpg" alt="未命名文件 (4)"></p><p>实际可能出现软分叉的情况：给某些目前协议中没有规定的域增加一些新的含义，赋予新的规则，例coinbase域，有时会把coinbase域的前八个字节也作为extra nonce，使搜索空间从$2^{32}$变成$2^{96}$，作为挖矿难度，剩下的字节如何用？有人提出作为UTXO的根哈希值。</p><p>比特币历史上一个比较著名的软分叉的例子是P2SH(Pay to Script Hash)，这个功能在最初的比特币版本上是没有的，是通过软分叉的方法加进去的。</p><h3 id="10、问答"><a href="#10、问答" class="headerlink" title="10、问答"></a>10、问答</h3><h5 id="Q1：转账交易时，接收者不在线怎么办"><a href="#Q1：转账交易时，接收者不在线怎么办" class="headerlink" title="Q1：转账交易时，接收者不在线怎么办"></a>Q1：转账交易时，接收者不在线怎么办</h5><p>不需要接收者在线，转账交易只是在区块链上记录把自己账户上的比特币转过去，是不是当时连在比特币网络是没关系的。</p><h5 id="Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的"><a href="#Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的" class="headerlink" title="Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的"></a>Q2：假设某个全节点收到了某个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的</h5><p>可能的，比特币账户在创建的时候是不需要通知其他人的，在本地产生公私钥对就可以了，只有在以后产生收款地址，第一次收到钱，其他节点才知道这个账户的存在。</p><h5 id="Q3：账户的私钥丢失了怎么办"><a href="#Q3：账户的私钥丢失了怎么办" class="headerlink" title="Q3：账户的私钥丢失了怎么办"></a>Q3：账户的私钥丢失了怎么办</h5><p>账户上的钱变成了死钱，永远取不出来，但是有些加密货币的交易所是中心化的机构，在交易所开办账户一般来说是需要提供身份证明的，这种情况下，把比特币放在交易所，私钥是交易所保管的，登录交易所类似登录银行，这种情况下丢失了密码可以跟交易所练习，通过身份验证重置密码（不是密钥），有些在线钱包也有保管私钥的功能（Mt.Gox）。</p><h5 id="Q4：私钥泄露了怎么办"><a href="#Q4：私钥泄露了怎么办" class="headerlink" title="Q4：私钥泄露了怎么办"></a>Q4：私钥泄露了怎么办</h5><p>尽快把账户上的钱转移到另一个安全账户上。</p><h5 id="Q5：转账时写错了地址怎么办"><a href="#Q5：转账时写错了地址怎么办" class="headerlink" title="Q5：转账时写错了地址怎么办"></a>Q5：转账时写错了地址怎么办</h5><p>没有办法取消已经发布的交易，转到别人的地址或者不存在的地址都无法拿回比特币，如果转到不存在的地址，全节点会永久的把这个地址保存在UTXO里，这对全节点是不友好的。</p><h5 id="Q6：OP-RETURN是无条件返回错误，为什么能写在区块链里"><a href="#Q6：OP-RETURN是无条件返回错误，为什么能写在区块链里" class="headerlink" title="Q6：OP_RETURN是无条件返回错误，为什么能写在区块链里"></a>Q6：OP_RETURN是无条件返回错误，为什么能写在区块链里</h5><p>进行验证时，是当前交易的输入脚本和币的来源的输出脚本拼在一起看能不能顺利执行，这个执行过程是不可以发生错误的，如果抛出错误就不是合法交易，但OP_RETURN是写在当前交易的输出脚本，所以验证当前交易合法性时，不会执行这个语句。有人想花这笔钱时才会执行到这个交易的输出脚本。</p><p>&#x3D;&#x3D;那么这个输出脚本与下一个输入脚本拼和时会验证不通过吗&#x3D;&#x3D;</p><h5 id="Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）"><a href="#Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）" class="headerlink" title="Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）"></a>Q7：会不会有的矿工偷答案，把其他矿工找到的nonce当成自己的nonce发布出去（怎么知道是哪个矿工最先找到nonce）</h5><p>发布的区块里有coinbase transaction，里面有收款人地址，是挖到矿的矿工的地址，偷答案要把这个地址换成自己的地址，一旦换掉，coinbase transaction的内容就发生了改变，这样会导致这个merkle tree的根hash会变化，会导致block header的内容发生变化，原来找到的nonce就作废了，所以不可能偷答案。</p><h5 id="Q8：事先怎么知道交易费要给哪个矿工"><a href="#Q8：事先怎么知道交易费要给哪个矿工" class="headerlink" title="Q8：事先怎么知道交易费要给哪个矿工"></a>Q8：事先怎么知道交易费要给哪个矿工</h5><p>事先不需要知道哪个矿工会得到交易费，交易费的计算是<code>total inputs - total outputs</code>，矿工挖到矿后，可以把区块里包含的交易的差额都收集起来，作为自己的交易费。</p><h3 id="11、比特币的匿名性"><a href="#11、比特币的匿名性" class="headerlink" title="11、比特币的匿名性"></a>11、比特币的匿名性</h3><p>有可能破坏比特币匿名性：</p><ul><li>地址账户可能被关联</li><li>比特币跟实体世界发生联系时，可能泄露真实身份</li><li>用比特币做支付</li></ul><p>网络层的匿名性：TOR（多路径转发&#x2F;洋葱路由）</p><p>应用层的匿名性：coin mixing（交易所、在线钱包）</p><p>不可篡改性对隐私保护是灾难性的</p><h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h4><p>概念：一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是争取的外的任何信息。</p><p>数学基础：同态隐藏</p><ul><li>如果x,y不同，那么它们的加密函数值E(x)和E(y)也不相同（应不会出现碰撞）</li><li>给定E(x)的值，很难反推出x的值</li><li>给定E(x)和E(y)的值，我们可以很容易地计算出某些关于x,y的加密函数值<ul><li>同态加法：通过E(x)和E(y)计算出E(x+y)的值</li><li>同态乘法：通过E(x)和E(y)计算出E(xy)的值</li><li>扩展到多项式</li></ul></li></ul><p>例子：Alice想要向Bob证明他知道一组数使得x+y&#x3D;7，同时不让Bob知道x和y的具体数值</p><ul><li><p>简单的版本</p><ul><li><p>Alice把E(x)和E(y)的数值发给Bob</p></li><li><p>Bob通过收到的E(x)和E(y)计算出E(x+y)的值</p></li><li><p>Bob同时计算E(7)的值，如果E(x+y) &#x3D; E(7)，那么验证通过，否则验证失败</p><blockquote><p>虽然Bob无法从E(x)知道x的值，但是可以遍历x的各种取值，所以在复杂场景下，Alice将值给Bob之前，要做一些随机化处理，但要保证x+y依然不变。</p></blockquote></li></ul></li></ul><p>盲签</p><ul><li>用户A提供SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款</li><li>用户A把SerialNum和Token交给B完成交易</li><li>用户B拿SerialNum和Token给银行验证，银行验证通过，增加B的存款</li><li>银行无法把A和B联系起来</li><li>中心化</li></ul><p>零币和零钞</p><ul><li>零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码保证</li><li>零币(zerocoin)系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务</li><li>零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行</li></ul><h3 id="12、比特币引发的思考"><a href="#12、比特币引发的思考" class="headerlink" title="12、比特币引发的思考"></a>12、比特币引发的思考</h3><p><strong>Q1：指针保存的是本地内存的地址，只是在本地计算机上才有意义，在其他计算机上就没有意义了，那么在发送区块的时候，哈希指针是怎么通过网络传输</strong></p><p>哈希指针只是一种形象的说法，实际用的时候只有哈希没有指针，全节点一般是把这些区块存储在(key,value)数据库里，key是区块的哈希，value是区块的内容，一个常用的(key,value)数据库是level DB，区块链这种链表结构实际上是在level DB里面用哈希指针串起来的，只要掌握了最后一个区块的哈希指针，就可以通过level DB来查找key对应的value就可以把最后一个区块的内容取出来，这个区块的块头又有指向前一个区块的哈希指针，一步步往前找，最终能把整个区块链找出来。</p><p>有些节点没有保存完整的区块链的信息，只保存了最近的几千个区块，如果需要用到前面区块的信息，可以问其他的全节点要，哈希指针的性质保证了整个区块的内容是不可篡改的。</p><p><strong>Q2：区块恋：n个人保存私钥的n个部分</strong></p><p>任何一人丢失，都可能导致无法取出钱。</p><p>截断私钥的做法会降低账户的安全性，比特币系统中每个账户的安全性与所用的私钥的长度是相关的。</p><p>多个人的共享账户不建议用共享私钥的办法，建议用多重签名。</p><p><strong>Q3：理论上，分布式系统中取得共识是不可能的，比特币系统如何绕过分布式共识中的那些不可能结论。</strong></p><p>严格来说，比特币没有取得真正的共识，因为取得的共识随时可能被推翻，例如分叉攻击，但是理论上的不可能结论，实际中不一定适用，理论可能只针对某种特定的模型。</p><p><strong>Q4：比特币的稀缺性</strong></p><p>总量固定&#x2F;稀缺的东西其实是不适合货币的，一个好的货币要有通货膨胀的功能。</p><p><strong>Q5：量子计算</strong></p><p>量子计算离实用还差得很远；比特币中并没有把账户的公钥直接暴露出来，而是用公钥取hash后得到一个地址（取hash不同于加密，可能造成信息的损失，hash函数一般是不可逆的）；</p><blockquote><p>未完待续。。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>比特币</tag>
      
      <tag>以太坊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实训总结</title>
    <link href="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="实训总结"><a href="#实训总结" class="headerlink" title="实训总结"></a>实训总结</h1><h2 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h2><p>我们使用的是mysql+Navicat Premium15，开发的时候用本地的连接（因为开发时为了测试功能会需要一些数据，也产生很多数据，如果要同时保证数据库完整性会降低效率），最终演示是用的是白嫖来的云服务器，方便团队中的其他成员进行管理维护，同时配合项目功能看实际效果。</p><p>我们总共建了13张表，schedule_info这张表因为时间不够了，整个日程功能被放弃，所以并没有用到，实际用到的是13张表，已转储为xbb_db.sql，在项目过程中走过的一些关于数据库的小坑如下：</p><p><strong>1、表名尽量简单。</strong></p><p>最开始建表的时候每张表都带个“_”，doctor_info、nurse_info等等，事实证明多余的“__info”只是在折磨自己，还有一个表名字是medicineinfo_base，后期写相关内容的时候非常折磨。</p><p><strong>2、&#x3D;&#x3D;数据库的字段名和实体类的属性名不对应&#x3D;&#x3D;</strong></p><p><strong>例：</strong></p><p><code>数据库字段：idnamepwd </code></p><p><code>实体类属性：idnamepassword</code></p><p>查询结果：password查询为null</p><p><strong>原因：</strong></p><p>sql语句：<code>select * from mybatis.user where id = #&#123;id&#125; </code></p><p>其实为：<code>select id,name,pwd from mybatis.user where id = #&#123;id&#125; </code></p><p>而输出的user的password属性没有赋值，所以为null</p><p><strong>解决方法：</strong></p><p>法一：起别名</p><p><code>select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;</code></p><p>法二：使用resultMap结果集映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--property实体类中的属性,column数据库中的字段--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    select * from mybatis.user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>id 标签：用于指定主键字段<br>result 标签：用于指定非主键字段<br>column 属性：用于指定数据库列名<br>property 属性：用于指定实体类属性名称</p></blockquote><p>法三：Mybatis-Plus在实体类属性和数据库表字段映射时，会自动将数据库表字段名中的下划线去掉，并且不受字母大小写的影响。</p><p>在application.yml配置文件中添加Mybatis的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">type-aliases-package</span>: <span class="hljs-string">com.mybatisplus.pojo  # 实体类包别名作用:可以用实体类名称代替实体类的相对路径</span><br>  <span class="hljs-attr">configuration</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">map-underscore-to-camel-case</span>: <span class="hljs-string">true # 驼峰命名</span><br></code></pre></td></tr></table></figure><p>通过驼峰命名,将数据库表字段名下划线去掉，然后去映射实体类属性名，同样不考虑字母大小写问题,这样就达到了和Mybatis-Plus一样的效果。</p><p>（但依然可能有值无法被映射到）</p><p>法四：在核心配置文件中启用下划线与驼峰式命名规则的映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>  <br>          <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上是从网上搜到的解决办法，我们试过改配置，但还是有问题，所以用了resultMap，但其实很麻烦，每个字段都要写，所以后来直接把数据库的字段名改成了跟实体类属性对应的驼峰。</p><p><strong>3、使用简写</strong></p><p>在application.properties中添加<code>mybatis.type-aliases-package=com.xbb.entity</code>后，我们在mapper.xml映射文件中不需要写出实体类的完整路径，只需要写出类名即可。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;selectByDepartment&quot; resultType<span class="hljs-operator">=</span>&quot;doctor&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> doctor_info <span class="hljs-keyword">where</span> department <span class="hljs-operator">=</span> #&#123;department&#125;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>4、给每张表都设置自增主键id，可能不会展现给用户，但可以作为唯一标志来查询。</p><p>5、本来觉得在建表的时候要考虑到展示，前端的一个table最好来自一张表的数据，所以可能需要一定的冗余，后来发现，需要多张表数据时直接通过sql操作也可行（left joint），如果之后有机会可以尝试。</p><p>6、算是一点总结吧，个人感觉数据库的设计是很需要逻辑的，一旦定下来改动的成本会很高，而且作为整个项目的底层，设计的好坏会影响到后面所有的开发过程是否复杂可行，所以要用多点心，考虑整体。</p><h2 id="搭建后端"><a href="#搭建后端" class="headerlink" title="搭建后端"></a>搭建后端</h2><h3 id="Spring-Boot入门"><a href="#Spring-Boot入门" class="headerlink" title="Spring Boot入门"></a>Spring Boot入门</h3><p><strong>介绍：</strong></p><p>一般把Spring Boot称为搭建程序的脚手架或者说是便捷搭建基于Spring的工程 脚手架。其最主要作用就是帮助开发人员快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让开发人员关注业务而非配置。 </p><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：</p><p>1、复杂的配置 </p><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以 写配置挤占了写应用程序逻辑的时间。</p><p>2、混乱的依赖管理</p><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p><p>而Spring Boot让这一切成为过去！ </p><p>Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。 </p><p>Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器starter），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。</p><p>我们可以使用Spring Boot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 </p><p><strong>Spring Boot 主要特点是：</strong> </p><ul><li>创建独立的Spring应用，为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 </li><li>直接嵌入应用服务器，如tomcat、jetty、undertow等；不需要去部署war包 </li><li>提供固定的启动器依赖去简化组件配置；实现开箱即用（启动器starter其实就是Spring Boot提供的一个jar 包），通过自己设置参数（.properties或.yml的配置文件），即可快速使用。 </li><li>自动地配置Spring和其它有需要的第三方依赖     </li><li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等     </li><li>绝对没有代码生成，也无需 XML 配置。</li></ul><h3 id="新建一个Spring-Boot项目"><a href="#新建一个Spring-Boot项目" class="headerlink" title="新建一个Spring Boot项目"></a>新建一个Spring Boot项目</h3><p><strong>1、新建一个maven工程</strong></p><p>File–New–Project–Maven–next–选定Name和Location–Finish</p><p>生成如图：</p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_133833.png" alt="2022-04-04_133833"></p><p><strong>2、添加依赖</strong></p><p>现在创建好的项目还与Spring Boot没什么关联，Spring Boot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们 就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ </p><p><strong>2.1 添加父工程坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.2 添加web启动器</strong></p><p>为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的自动配置依赖，我们称为 启动器 。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，我们并没有在这里指定版本信息。因为Spring Boot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖。</p><p>那些依赖都是Spring Boot根据 spring-boot-starter-web 这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 </p><p><strong>2.3 管理jdk版本</strong></p><p>如果我们想要修改Spring Boot项目的jdk版本，只需要简单的添加以下属性即可，如果没有需求，则不添加。同样的在 pom.xml 文件中添加如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.4 完整pom文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 </span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ccnu.springboot.demo1<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springbootdemo1<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>2.5 启动类</strong></p><p>Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： </p><p>编写&#x2F;backend&#x2F;src&#x2F;main&#x2F;java&#x2F;azure&#x2F;Application.java如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> azure;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@MapperScan(&quot;azure.dao&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.6 编写controller</strong></p><p>编写&#x2F;backend&#x2F;src&#x2F;mian&#x2F;java&#x2F;azure&#x2F;controller&#x2F;NotFoundcontroller.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> azure.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotFoundController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;404&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">NotFound</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;对不起，您的页面走丢了！&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.7 启动项目，查看启动端口：</p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_143417.png" alt="2022-04-04_143417"></p><p>打开<a href="http://localhost:8080/404">http://localhost:8080/404</a></p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_143125.png" alt="2022-04-04_143125"></p><p>测试成功</p><p>2.8 项目最终完整的xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--maven版本和头文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    自己配置的GVA--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ccnu.springboot.demo4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springbootdemo5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    项目的打包方式--&gt;</span><br><span class="hljs-comment">&lt;!--    jar:java应用--&gt;</span><br><span class="hljs-comment">&lt;!--    war:javaweb应用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    父工程坐标--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">fastjson.version</span>&gt;</span>1.2.25<span class="hljs-tag">&lt;/<span class="hljs-name">fastjson.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    项目依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 分页功能 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- Spring Boot的web启动器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- Thymeleaf --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- MyBatis --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 连接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- lombok --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 工具包 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fastjson.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>3、新建配置文件</strong></p><p>在&#x2F;backend&#x2F;src&#x2F;main&#x2F;resources下新建application.properties或application.yml（二者都是配置文件，写法不同）</p><p>application.properties中为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">project.name</span>=<span class="hljs-string">kanbingbing</span><br><span class="hljs-attr">project.version</span>=<span class="hljs-string">1.0.0</span><br><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8081</span><br><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://114.115.218.247:3307/xbb_db?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-comment">#spring.datasource.url=jdbc:mysql://localhost:3306/xbb_db?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br><span class="hljs-attr">spring.jackson.time-zone</span>=<span class="hljs-string">GMT+8</span><br><br><span class="hljs-attr">spring.jackson.date-format</span>=<span class="hljs-string">yyyy-MM-dd HH:mm:ss</span><br><br><span class="hljs-attr">spring.thymeleaf.cache</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/static/</span><br><br><span class="hljs-attr">mybatis.type-aliases-package</span>=<span class="hljs-string">com.xbb.entity</span><br><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mybatis/mappers/*.xml</span><br><br><span class="hljs-attr">logback.level</span>=<span class="hljs-string">INFO</span><br><span class="hljs-attr">logging.level.com.ccnu</span>=<span class="hljs-string">debug</span><br><br><span class="hljs-attr">file.upload.path</span>=<span class="hljs-string">C:\\Shirley-learning\\apache-tomcat-9.0.24-windows-x64\\apache-tomcat-9.0.24\\webapps\\tanghulu</span><br><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">2MB</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">2MB</span><br></code></pre></td></tr></table></figure><p>application.yml中为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">pagehelper:</span><br>  <span class="hljs-attr">helperDialect:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">reasonable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">supportMethodsArguments:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">params:</span> <span class="hljs-string">count=countSql</span><br><br></code></pre></td></tr></table></figure><h3 id="用mybatis管理数据库"><a href="#用mybatis管理数据库" class="headerlink" title="用mybatis管理数据库"></a>用mybatis管理数据库</h3><p>在&#x2F;backend&#x2F;src&#x2F;main&#x2F;resources下新建mybatis.mappers文件夹，存放xml文件，目录如图所示：</p><p><img src="/blog/2022/09/01/%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/2022-04-04_153709.png" alt="2022-04-04_153709"></p><h3 id="以Spring-MVC架构编写程序"><a href="#以Spring-MVC架构编写程序" class="headerlink" title="以Spring MVC架构编写程序"></a>以Spring MVC架构编写程序</h3><p>在&#x2F;backend&#x2F;src&#x2F;main&#x2F;java&#x2F;azure下</p><p>新建entity文件夹存放实体类，实体类类名及属性最好与数据库的表名和字段对应；</p><p>新建dao文件夹作为数据访问层，与编写sql语言直接操作数据库的xml文件相对应，命名如：ArticleMapper接口类；</p><p>新建service文件夹作为业务层，再在service文件夹下新建impl文件夹，二者分别存放service接口类和serviceImpl接口实现类，命名如：ArticleService接口类和ArticleServiceImpl接口实现类；</p><p>新建controller文件夹作为控制层，调用service层的方法以及向前端提供接口，命名如ArticleController类；</p><p>新建utils文件夹存放工具类，如CodeGenerator类、Result类。</p><p>![未命名文件 (1)](.&#x2F;未命名文件 (1).png)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，一个项目的后端框架已经搭建完毕，之后的开发按照上述规则进行。</p><h2 id="搭建前端"><a href="#搭建前端" class="headerlink" title="搭建前端"></a>搭建前端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要的环境</p><p>Node.js : <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p>安装就无脑下一步就好,安装在自己的环境目录下</p><p>Git : <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><p>镜像:<a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p><p>确认nodejs安装成功:</p><p>cmd 下输入 node -v,查看是否能够正确打印出版本号即可!</p><p>cmd 下输入 npm-v,查看是否能够正确打印出版本号即可!</p><p>这个npm,就是一个软件包管理工具,就和linux下的apt软件安装差不多!</p><p>安装 Node.js 淘宝镜像加速器（cnpm）</p><p>这样子的话,下载会快很多~</p><p>在命令台输入-g 就是全局安装</p><p>npm install cnpm -g</p><p>或使用如下语句解决 npm 速度慢的问题</p><p>npm install –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p><p>在命令台输入</p><p>cnpm install vue-cli -g</p><p>查看是否安装成功</p><p>vue list</p><h3 id="新建vue脚手架"><a href="#新建vue脚手架" class="headerlink" title="新建vue脚手架"></a>新建vue脚手架</h3><p>进入想新建项目的文件夹，打开控制台</p><p>创建脚手架：vue init webpack frontend</p><blockquote><p>克隆项目：git clone (地址)</p></blockquote><p>然后有一系列选项需要自定义，一般来说可以一路default，选择结束后会显示在安装中</p><p>运行vue：</p><p>cd frontend</p><p>npm install</p><p>npm run dev</p><p>打开<a href="http://localhost:8080/#/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0vue%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%86%99%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E5%B0%86%E5%BE%88%E5%A4%9A%E4%B8%9C%E8%A5%BF%E5%88%A0%E9%99%A4%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/#/，可以看到vue脚手架的一个默认页面，自己在写项目之前需要将很多东西删除，这些初始化操作如下：</a></p><ul><li><p>将src&#x2F;assets中的logo.png替换成自己的logo.png</p></li><li><p>将components中的HelloWorld.vue删除</p></li><li><p>将router&#x2F;index.js中的内容替换如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>      <span class="hljs-comment">//此处开始写自己的路由</span><br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>将App.vue中的内容替换如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>将main.js中的内容替换如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// The Vue build version to load with the `import` command</span><br><span class="hljs-comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><span class="hljs-comment">// 扫描路由配置</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-comment">// 导入Axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Axios</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-axios&#x27;</span><br><span class="hljs-comment">// 导入vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-comment">// 导入element-ui</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-comment">// 导入element css</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="hljs-comment">// 导入echarts</span><br><span class="hljs-comment">// import echarts from &#x27;echarts&#x27;</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;echarts&#x27;</span>;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(router)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Axios</span>, axios)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$echarts</span> = echarts<br><br><span class="hljs-comment">/* eslint-disable no-new */</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  <span class="hljs-comment">// components: &#123;App&#125;,</span><br>  <span class="hljs-comment">// template: &#x27;&lt;App/&gt;&#x27;</span><br>  <span class="hljs-comment">// elementUI</span><br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>注：引入前需要配套安装，安装方式基本都为：npm install xxx</p></blockquote></li></ul><p>还有一些要根据项目情况改变的小细节如下：</p><p>1、在写路径时可用@来代替src，相关配置在build&#x2F;webpack.base.conf.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">context</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../&#x27;</span>),<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./src/main.js&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>],<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;vue$&#x27;</span>: <span class="hljs-string">&#x27;vue/dist/vue.esm.js&#x27;</span>,<br>      <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src&#x27;</span>),<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、设置前后端交互的端口，相关配置在config&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">dev</span>: &#123;<br>    <span class="hljs-comment">// Paths</span><br>    <span class="hljs-attr">assetsSubDirectory</span>: <span class="hljs-string">&#x27;static&#x27;</span>,<br>    <span class="hljs-attr">assetsPublicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">proxyTable</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-comment">// 此处写后端启动的端口号</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8081&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-comment">// can be overwritten by process.env.HOST</span><br>    <span class="hljs-comment">// 此处写前端启动的端口号</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>, <span class="hljs-comment">// can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span><br>    <span class="hljs-attr">autoOpenBrowser</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">errorOverlay</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">notifyOnErrors</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">poll</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-</span><br><br>    <span class="hljs-attr">useEslint</span>: <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-attr">showEslintErrorsInOverlay</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;cheap-module-eval-source-map&#x27;</span>,<br>    <span class="hljs-attr">cacheBusting</span>: <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-attr">cssSourceMap</span>: <span class="hljs-literal">true</span><br>  &#125;,<br></code></pre></td></tr></table></figure><p>3、设置打开时的网页名称，在index.html中进行修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 此处写网页名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>xbb-frontend<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="项目主要功能实现"><a href="#项目主要功能实现" class="headerlink" title="项目主要功能实现"></a>项目主要功能实现</h2><h3 id="1、基础增删改查及分类"><a href="#1、基础增删改查及分类" class="headerlink" title="1、基础增删改查及分类"></a>1、基础增删改查及分类</h3><p>以doctor为例</p><p>&#x3D;&#x3D;后端内容&#x3D;&#x3D;</p><p>在src&#x2F;main&#x2F;resources&#x2F;mybatis.mappers中新建DoctorMapper.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xbb.dao.DoctorMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 增加 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addDoctor&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.Doctor&quot;</span>&gt;</span><br>        insert into doctor_info(id,name,sex,idCard,age,birth,image,introduction,department,sort,fee,telephone)<br>        values(#&#123;id&#125;,#&#123;name&#125;,#&#123;sex&#125;,#&#123;idCard&#125;,#&#123;age&#125;,#&#123;birth&#125;,#&#123;image&#125;,#&#123;introduction&#125;,#&#123;department&#125;,#&#123;sort&#125;,#&#123;fee&#125;,#&#123;telephone&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 删除 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteDoctor&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.Doctor&quot;</span>&gt;</span><br>        delete from doctor_info where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 修改 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateDoctor&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.Doctor&quot;</span>&gt;</span><br>        update doctor_info set name=#&#123;name&#125;,sex=#&#123;sex&#125;,idCard=#&#123;idCard&#125;,age=#&#123;age&#125;,birth=#&#123;birth&#125;,image=#&#123;image&#125;,introduction=#&#123;introduction&#125;,department=#&#123;department&#125;,sort=#&#123;sort&#125;,fee=#&#123;fee&#125;,telephone=#&#123;telephone&#125;<br>        where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 查询 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;doctor&quot;</span>&gt;</span><br>        select * from doctor_info<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 根据科室查询医生 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByDepartment&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;doctor&quot;</span>&gt;</span><br>        select * from doctor_info where department = #&#123;department&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 模糊查询 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;doctor&quot;</span>&gt;</span><br>    select * from doctor_info where name like concat(&#x27;%&#x27;,#&#123;val&#125;,&#x27;%&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>utils中新建Result工具类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.utils;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> total;<span class="hljs-comment">//内容长度</span><br>    <span class="hljs-keyword">private</span> Object data;<span class="hljs-comment">// 内容</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>entity中新建Doctor实体类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.entity;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Doctor</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<span class="hljs-comment">//工号</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">private</span> String sex;<span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> String idCard;<span class="hljs-comment">//身份证号</span><br>    <span class="hljs-keyword">private</span> String telephone;<span class="hljs-comment">//电话号码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">private</span> String birth;<span class="hljs-comment">//出生日期</span><br>    <span class="hljs-keyword">private</span> String image;<span class="hljs-comment">//个人照片</span><br>    <span class="hljs-keyword">private</span> String introduction;<span class="hljs-comment">//个人简介</span><br>    <span class="hljs-keyword">private</span> String department;<span class="hljs-comment">//科室</span><br>    <span class="hljs-keyword">private</span> String sort;<span class="hljs-comment">//职称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> fee;<span class="hljs-comment">//挂号费</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>dao中新建DcotorMapper.interface，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.dao;<br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DoctorMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//添加医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(Long id)</span>;<span class="hljs-comment">//删除一条医生信息记录（管理员）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//修改医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<span class="hljs-comment">//查询所有医生信息（管理员）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//根据科室查询医生信息（病人）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(String val)</span>;<span class="hljs-comment">//根据医生名模糊查询（管理员）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>service中新建DoctorService.interface，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service;<br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> com.xbb.utils.Result;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DoctorService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//添加医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(Long id)</span>;<span class="hljs-comment">//删除一条医生信息记录（管理员）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(Doctor doctor)</span>;<span class="hljs-comment">//修改医生信息（医生）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAllOnce</span><span class="hljs-params">()</span>;<span class="hljs-comment">//一次获取所有医生信息（管理员）</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectAll</span><span class="hljs-params">(<span class="hljs-type">int</span> current,<span class="hljs-type">int</span> size)</span>;<span class="hljs-comment">//分页查询所有医生信息（管理员）</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//根据科室查询医生信息（病人）</span><br>    Result <span class="hljs-title function_">search</span><span class="hljs-params">(Integer current, Integer size, String val)</span>;<span class="hljs-comment">//根据医生名模糊查询并分类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Impl中新建DoctorServiceImpl接口实现类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service.impl;<br><br><span class="hljs-keyword">import</span> com.github.pagehelper.Page;<br><span class="hljs-keyword">import</span> com.github.pagehelper.PageHelper;<br><span class="hljs-keyword">import</span> com.xbb.dao.DoctorMapper;<br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> com.xbb.service.DoctorService;<br><span class="hljs-keyword">import</span> com.xbb.utils.Result;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoctorServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DoctorService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DoctorMapper doctorMapper;<span class="hljs-comment">//这里总会报错，不知为何，但不影响运行</span><br><br>    <span class="hljs-comment">// 插入：添加医生</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(Doctor doctor)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.addDoctor(doctor);<br>    &#125;<br><br>    <span class="hljs-comment">// 删除：删除医生</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.deleteDoctor(id);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 修改：修改医生信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(Doctor doctor)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.updateDoctor(doctor);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询：一次获取所有医生列表</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAllOnce</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.selectAll();<br>    &#125;<br><br>    <span class="hljs-comment">// 查询：一次获取所有医生列表并分页</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectAll</span><span class="hljs-params">(<span class="hljs-type">int</span> current ,<span class="hljs-type">int</span> size)</span> &#123;<br>        Page&lt;Doctor&gt; doctors = PageHelper.startPage(current, size);<br>        doctorMapper.selectAll();<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>        result.setData(doctors.getResult());<br>        result.setTotal(doctors.getTotal());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询：根据科室名查询医生</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(String department)</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorMapper.selectByDepartment(department);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 模糊查询：根据医生名进行模糊查询并分类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">search</span><span class="hljs-params">(Integer current, Integer size, String val)</span> &#123;<br>        Page&lt;Doctor&gt; doctors = PageHelper.startPage(current, size);<br>        doctorMapper.search(val);<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>        result.setData(doctors.getResult());<br>        result.setTotal(doctors.getTotal());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在controller中新建DoctorController类，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.controller;<br><br><span class="hljs-keyword">import</span> com.xbb.entity.Doctor;<br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.DoctorServiceImpl;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.UserServiceImpl;<br><span class="hljs-keyword">import</span> com.xbb.utils.Result;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/doctor&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoctorController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DoctorServiceImpl doctorService;<br><br>    <span class="hljs-comment">// 添加医生</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/addDoctor&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDoctor</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Doctor doctor)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.addDoctor(doctor);<br>    &#125;<br><br>    <span class="hljs-comment">// 删除医生</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/deleteDoctor&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteDoctor</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Long id)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.deleteDoctor(id);<br>    &#125;<br><br>    <span class="hljs-comment">// 修改医生信息</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/updateDoctor&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateDoctor</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Doctor doctor)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.updateDoctor(doctor);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 一次获取所有医生列表</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;selectAllOnce&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectAllOnce</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> doctorService.selectAllOnce();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取所有医生并分页</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/selectAll&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectAll</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer current,<span class="hljs-meta">@RequestParam</span> Integer size)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.selectAll(current,size);<br>    &#125;<br><br>    <span class="hljs-comment">// 根据科室名查询医生列表</span><br>    <span class="hljs-meta">@RequestMapping(value=&quot;/selectByDepartment&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Doctor&gt; <span class="hljs-title function_">selectByDepartment</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String department)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.selectByDepartment(department);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 模糊查询并分页</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/search&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer current,<span class="hljs-meta">@RequestParam</span> Integer size,<span class="hljs-meta">@RequestParam</span> String val)</span>&#123;<br>        <span class="hljs-keyword">return</span> doctorService.search(current,size,val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;前端内容&#x3D;&#x3D;</p><p>在src下新建utils文件夹，在utils下新建request.js，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Message</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><br><span class="hljs-comment">// create an axios instance</span><br><span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-comment">// url = base url + request url</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span> <span class="hljs-comment">// request timeout</span><br>&#125;)<br><br>service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> !== <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-keyword">return</span> res<br>      <span class="hljs-comment">// return Promise.reject(new Error(res.message || &#x27;Error&#x27;))</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-title class_">Message</span>(&#123;<br>      <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>,<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>      <span class="hljs-attr">duration</span>: <span class="hljs-number">5</span> * <span class="hljs-number">1000</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service<br></code></pre></td></tr></table></figure><p>在src下新建api文件夹，在api中新建doctor.js，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/request&#x27;</span><br><br><span class="hljs-comment">// 添加医生信息</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/addDoctor&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    data<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 删除医生信息</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/deleteDoctor&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">id</span>: data<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 修改医生信息</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">editDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/updateDoctor&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    data<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 一次性获取所有医生</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDoctorOnce</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/selectAllOnce&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 获取所有医生并分页</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDoctor</span> (data) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/selectAll&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: data<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 根据科室名获取医生</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDoctorByDepartment</span> (department) &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/selectByDepartment&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">department</span>: department<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 根据医生名模糊搜索</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">searchByDoctorName</span>(<span class="hljs-params">val,current,size</span>)&#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/doctor/search&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>        val : val,<br>        current : current,<br>        <span class="hljs-attr">size</span>: size<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在src下新建admin，admin下新建index.vue和subadmin文件夹，subadmin文件夹继续新建Doctor.vue</p><p>Doctor.vue内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;!-- template里的所有东西必须用一个div包裹，规定 --&gt;<br>  &lt;div&gt;<br>    &lt;div class=&quot;tab-container&quot;&gt;<br>      &lt;!-- 添加按钮：样式、图标、点击事件 --&gt;  <br>      &lt;el-button<br>        type=&quot;primary&quot;<br>        icon=&quot;el-icon-edit&quot;<br>        @click=&quot;handleCreate&quot;<br>      &gt;添加<br>      &lt;/el-button&gt;<br>      &lt;br&gt;<br>      &lt;!-- element-ui的弹框，dialogFormVisible默认为false --&gt;<br>      &lt;el-dialog :visible.sync=&quot;dialogFormVisible&quot;&gt;<br>        &lt;!-- 表单：向后端提交数据，属性：model：v-bind:model的缩写，将表单数据绑定到doctorForm；元素绑定ref之后，直接通过this.$refs即可调用；：rules：写表单项提交规则；label-position=&quot;left&quot;：标签放在左边--&gt;<br>        &lt;el-form<br>          :model=&quot;doctorForm&quot;<br>          ref=&quot;doctorForm&quot;<br>          :rules=&quot;rules&quot;<br>          label-position=&quot;left&quot;<br>        &gt;<br>            <br>          &lt;!-- el-form-item即为表单项 --&gt;<br>          &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.name&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;性别&quot; prop=&quot;sex&quot;&gt;<br>            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>            &lt;el-radio v-model=&quot;doctorForm.sex&quot; label=&quot;男&quot;&gt;男&lt;/el-radio&gt;<br>            &lt;el-radio v-model=&quot;doctorForm.sex&quot; label=&quot;女&quot;&gt;女&lt;/el-radio&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;身份证号&quot; prop=&quot;idCard&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.idCard&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;电话号码&quot; prop=&quot;telephone&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.telephone&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;<br>            &lt;el-input-number v-model=&quot;doctorForm.age&quot; :min=&quot;1&quot;<br>                             :max=&quot;160&quot;&gt;&lt;/el-input-number&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;生日&quot; prop=&quot;birth&quot;&gt;<br>            &lt;el-input v-model=&quot;doctorForm.birth&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br><br>          &lt;el-form-item label=&quot;科室&quot; prop=&quot;department&quot;&gt;<br>            &lt;el-select<br>              v-model=&quot;doctorForm.department&quot;<br>              class=&quot;filter-item&quot;<br>              placeholder=&quot;选择科室&quot;<br>            &gt;<br>              &lt;el-option<br>                v-for=&quot;item in tabMapDepartments&quot;<br>                :key=&quot;item.key&quot;<br>                :label=&quot;item.label&quot;<br>                :value=&quot;item.key&quot;<br>              /&gt;<br>            &lt;/el-select&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;职称&quot; prop=&quot;sort&quot;&gt;<br>            &lt;el-select<br>              v-model=&quot;doctorForm.sort&quot;<br>              class=&quot;filter-item&quot;<br>              placeholder=&quot;选择职称&quot;<br>            &gt;<br>              &lt;el-option<br>                v-for=&quot;item in tabMapSorts&quot;<br>                :key=&quot;item.key&quot;<br>                :label=&quot;item.label&quot;<br>                :value=&quot;item.key&quot;<br>              /&gt;<br>            &lt;/el-select&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;挂号费&quot; prop=&quot;fee&quot;&gt;<br>            &lt;el-input-number v-model=&quot;doctorForm.fee&quot; :min=&quot;0&quot;<br>                             :max=&quot;10000&quot;&gt;&lt;/el-input-number&gt;<br>          &lt;/el-form-item&gt;<br>            <br>          &lt;el-form-item label=&quot;个人介绍&quot; prop=&quot;introduction&quot;&gt;<br>            &lt;el-input type=&quot;textarea&quot; autosize v-model=&quot;doctorForm.introduction&quot;<br>                      style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br><br>        &lt;/el-form&gt;<br>          <br>        &lt;!-- 弹出框底部按钮 --&gt;<br>        &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>          &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt;取消&lt;/el-button&gt;<br>          &lt;el-button type=&quot;primary&quot; @click=&quot; createData(&#x27;doctorForm&#x27;) &quot;&gt;确定&lt;/el-button&gt;<br>        &lt;/div&gt;<br>          <br>      &lt;/el-dialog&gt;<br>    &lt;/div&gt;<br><br>    &lt;div&gt;<br>      &lt;!-- 表格 --&gt;<br>      &lt;el-table<br>        ref=&quot;filterTable&quot;<br>        :data=&quot;tableData&quot;<br>        stript<br>        style=&quot;width: 100%&quot;<br>        :default-sort=&quot;&#123;prop: &#x27;data&#x27;, order: &#x27;descending&#x27;&#125;&quot;<br>      &gt;<br>          <br>        &lt;!--        详情框--&gt;<br>        &lt;el-table-column type=&quot;expand&quot;&gt;<br>          &lt;template slot-scope=&quot;props&quot;&gt;<br>            &lt;el-form label-position=&quot;left&quot;<br>                     class=&quot;demo-table-expand&quot;<br>                     style=&quot;margin-left: 100px; width: 800px;&quot;&gt;<br>              &lt;el-form-item label=&quot;姓名:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.name &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;性别:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.sex &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;身份证号:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.idCard &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;电话号码:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.telephone &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;年龄:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.age &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;生日:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.birth &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>&lt;!--              &lt;el-form-item label=&quot;头像:&quot;&gt;--&gt;<br>&lt;!--                &lt;span&gt;&#123;&#123; props.row.image &#125;&#125;&lt;/span&gt;--&gt;<br>&lt;!--              &lt;/el-form-item&gt;--&gt;<br>              &lt;el-form-item label=&quot;职称:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.sort &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;费用:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.fee &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;科室:&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.department &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>              &lt;el-form-item label=&quot;个人介绍:&quot; style=&quot;width: 700px;&quot;&gt;<br>                &lt;span&gt;&#123;&#123; props.row.introduction &#125;&#125;&lt;/span&gt;<br>              &lt;/el-form-item&gt;<br>            &lt;/el-form&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br><br>        &lt;!--        主要表单--&gt;<br>        &lt;el-table-column<br>          prop=&quot;name&quot;<br>          label=&quot;姓名&quot;<br>          width=&quot;100&quot;<br>        &gt;<br>          &lt;template slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-popover trigger=&quot;hover&quot; placement=&quot;top&quot;&gt;<br>              &lt;p&gt;姓名：&#123;&#123; scope.row.name &#125;&#125;&lt;/p&gt;<br>              &lt;p&gt;医生介绍：&#123;&#123; scope.row.introduction &#125;&#125;&lt;/p&gt;<br>              &lt;div slot=&quot;reference&quot; class=&quot;name-wrapper&quot;&gt;<br>                &lt;el-tag size=&quot;medium&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/el-tag&gt;<br>              &lt;/div&gt;<br>            &lt;/el-popover&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;sex&quot;<br>          label=&quot;性别&quot;<br>          width=&quot;70&quot;<br>          :sex=&quot;sex&quot;<br>        &gt;&lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;sort&quot;<br>          label=&quot;职称&quot;<br>          width=&quot;150&quot;<br>          :sort=&quot;sort&quot;<br>        &gt;&lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;age&quot;<br>          label=&quot;年龄&quot;<br>          width=&quot;100&quot;<br>          :age=&quot;age&quot;<br>        &gt;&lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          prop=&quot;department&quot;<br>          label=&quot;科室&quot;<br>          width=&quot;150&quot;<br>          :filters=&quot;[<br>            &#123; text : &#x27;神经内科&#x27;, value : &#x27;神经内科&#x27;&#125;,<br>            &#123; text : &#x27;内科&#x27;, value : &#x27;内科&#x27;&#125;,<br>            &#123; text : &#x27;外科&#x27;, value : &#x27;外科&#x27;&#125;,<br>            &#123; text : &#x27;妇产科&#x27;, value : &#x27;妇产科&#x27;&#125;,<br>            &#123; text : &#x27;儿科&#x27;, value : &#x27;儿科&#x27;&#125;,<br>            &#123; text : &#x27;眼科&#x27;, value : &#x27;眼科&#x27;&#125;,<br>            &#123; text : &#x27;耳鼻喉科&#x27;, value : &#x27;耳鼻喉科&#x27;&#125;,<br>            &#123; text : &#x27;口腔科&#x27;, value : &#x27;口腔科&#x27;&#125;,<br>            &#123; text : &#x27;皮肤科&#x27;, value : &#x27;皮肤科&#x27;&#125;,<br>            &#123; text : &#x27;肿瘤科&#x27;, value : &#x27;肿瘤科&#x27;&#125;,<br>            &#123; text : &#x27;中医科&#x27;, value : &#x27;中医科&#x27;&#125;,<br>            &#123; text : &#x27;体检中心&#x27;, value : &#x27;体检中心&#x27;&#125;<br>          ]&quot;<br>          :filter-method=&quot;filterTag&quot;<br>          filter-placement=&quot;bottom-end&quot;<br>        &gt;<br>          &lt;template slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-tag&gt;&#123;&#123; scope.row.department &#125;&#125;<br>            &lt;/el-tag&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br><br>        &lt;el-table-column<br>          fixed=&quot;right&quot;<br>          label=&quot;操作&quot;<br>          width=&quot;200&quot;<br>        &gt;<br>          &lt;template slot=&quot;header&quot; slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-input<br>              v-model=&quot;val&quot;<br>              size=&quot;medium&quot;<br>              placeholder=&quot;输入关键字搜索&quot;<br>              @keyup.enter.native=&quot;search&quot;/&gt;<br>            &lt;el-button style=&quot;margin-right: 10px&quot; @click=&quot;search()&quot;&gt;搜索&lt;/el-button&gt;<br>          &lt;/template&gt;<br><br>          &lt;template slot-scope=&quot;scope&quot;&gt;<br>            &lt;el-button<br>              size=&quot;mini&quot;<br>              @click=&quot;handleEdit(scope.$index, scope.row)&quot;<br>            &gt;编辑<br>            &lt;/el-button&gt;<br>            &lt;el-button<br>              size=&quot;mini&quot;<br>              type=&quot;danger&quot;<br>              @click=&quot;handleDelete(scope.$index, scope.row)&quot;<br>            &gt;删除<br>            &lt;/el-button&gt;<br>          &lt;/template&gt;<br>        &lt;/el-table-column&gt;<br>      &lt;/el-table&gt;<br>      &lt;pagination<br>        v-show=&quot;total &gt; 0&quot;<br>        :total=&quot;total&quot;<br>        :page.sync=&quot;page.current&quot;<br>        :limit.sync=&quot;page.size&quot;<br>        @pagination=&quot;getDoctor&quot;/&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br><br>import &#123;<br>  deleteDoctor,<br>  addDoctor,<br>  getDoctor,<br>  editDoctor,<br>  searchByDoctorName, addDoctorUser<br>&#125; from &#x27;@/api/admin&#x27;<br>import &#123; register &#125; from &#x27;@/api/register&#x27;<br>import Pagination from &#x27;@/components/Pagination&#x27;<br><br>export default &#123;<br>  name: &#x27;Doctor&#x27;,<br>  edit: false,<br>  components: &#123;Pagination&#125;,<br>  created () &#123;<br>    this.getDoctor()<br>  &#125;,<br>  data () &#123;<br>    return &#123;<br>      fileList: [],<br>      val: &#x27;&#x27;,<br>      tableData: [],<br>      total: 10,<br>      page: &#123;<br>        current: 1,<br>        size: 10<br>      &#125;,<br>      dialogFormVisible: false,<br>      doctorForm: &#123;<br>        name: &#x27;&#x27;,<br>        sex: &#x27;&#x27;,<br>        idCard: &#x27;&#x27;,<br>        age: &#x27;&#x27;,<br>        birth: &#x27;&#x27;,<br>        image: &#x27;&#x27;,<br>        introduction: &#x27;&#x27;,<br>        department: &#x27;&#x27;,<br>        sort: &#x27;&#x27;,<br>        fee: &#x27;&#x27;,<br>        telephone: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        name: [<br>          &#123;required: true, message: &#x27;姓名不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        sex: [<br>          &#123;required: true, message: &#x27;性别不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        idCard: [<br>          &#123;required: true, message: &#x27;身份证号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        age: [<br>          &#123;required: true, message: &#x27;年龄不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        birth: [<br>          &#123;required: true, message: &#x27;生日不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        // image: [<br>        //   &#123;required: true, message: &#x27;照片不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        // ],<br>        introduction: [<br>          &#123;required: true, message: &#x27;个人介绍不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        sort: [<br>          &#123;required: true, message: &#x27;职称不可为空&#x27;,  trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        department: [<br>          &#123;required: true, message: &#x27;科室不可为空&#x27;,  trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        fee: [<br>          &#123;required: true, message: &#x27;费用不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        telephone: [<br>          &#123;required: true, message: &#x27;电话不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false,<br>      tabMapDepartments: [<br>        &#123;label: &#x27;神经内科&#x27;, key: &#x27;神经内科&#x27;&#125;,<br>        &#123;label: &#x27;内科&#x27;, key: &#x27;内科&#x27;&#125;,<br>        &#123;label: &#x27;外科&#x27;, key: &#x27;外科&#x27;&#125;,<br>        &#123;label: &#x27;妇产科&#x27;, key: &#x27;妇产科&#x27;&#125;,<br>        &#123;label: &#x27;儿科&#x27;, key: &#x27;儿科&#x27;&#125;,<br>        &#123;label: &#x27;眼科&#x27;, key: &#x27;眼科&#x27;&#125;,<br>        &#123;label: &#x27;耳鼻喉科&#x27;, key: &#x27;耳鼻喉科&#x27;&#125;,<br>        &#123;label: &#x27;口腔科&#x27;, key: &#x27;口腔科&#x27;&#125;,<br>        &#123;label: &#x27;皮肤科&#x27;, key: &#x27;皮肤科&#x27;&#125;,<br>        &#123;label: &#x27;肿瘤科&#x27;, key: &#x27;肿瘤科&#x27;&#125;,<br>        &#123;label: &#x27;中医科&#x27;, key: &#x27;中医科&#x27;&#125;,<br>        &#123;label: &#x27;体检中心&#x27;, key: &#x27;体检中心&#x27;&#125;,<br>      ],<br>      tabMapSorts: [<br>        &#123;label: &#x27;科室主任&#x27;, key: &#x27;科室主任&#x27;&#125;,<br>        &#123;label: &#x27;科室副主任&#x27;, key: &#x27;科室副主任&#x27;&#125;,<br>        &#123;label: &#x27;科室专家&#x27;, key: &#x27;科室专家&#x27;&#125;,<br>        &#123;label: &#x27;主治医师&#x27;, key: &#x27;主治医师&#x27;&#125;,<br>        &#123;label: &#x27;副主治医师&#x27;, key: &#x27;副主治医师&#x27;&#125;,<br>      ],<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    getDoctor () &#123;<br>      getDoctor(this.page).then((res) =&gt; &#123;<br>        this.tableData = res.data<br>        this.total = res.total<br>      &#125;)<br>    &#125;,<br>    search () &#123;<br>      searchByDoctorName(this.val, this.page.current, this.page.size).then((res) =&gt; &#123;<br>        this.tableData = res.data<br>        this.total = res.total<br>      &#125;)<br>    &#125;,<br>    handleCreate () &#123;<br>      this.dialogFormVisible = true<br>      this.doctorForm = &#123;<br>        name: &#x27;&#x27;,<br>        sex: &#x27;&#x27;,<br>        idCard: &#x27;&#x27;,<br>        telephone: &#x27;&#x27;,<br>        age: &#x27;&#x27;,<br>        birth: &#x27;&#x27;,<br>        image: &#x27;&#x27;,<br>        sort: &#x27;&#x27;,<br>        department: &#x27;&#x27;,<br>        fee: &#x27;&#x27;,<br>        introduction: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;<br>    &#125;,<br>    createData (formName) &#123;<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        if (vaild) &#123;<br>          if (this.editDoctor) &#123;<br>            // 为表单绑定验证功能<br>            editDoctor(this.doctorForm)<br>            this.editDoctor = false<br>            this.$notify(&#123;<br>              title: &#x27;提示信息&#x27;,<br>              message: &#x27;修改成功&#x27;,<br>              type: &#x27;success&#x27;<br>            &#125;)<br>            this.getDoctor()<br>            this.getDoctor()<br>            this.dialogFormVisible = false<br>          &#125; else &#123;<br>            console.log(&#x27;start&#x27;)<br>            addDoctor(this.doctorForm)<br>            addDoctorUser(this.doctorForm.telephone, this.doctorForm.password, this.doctorForm.name, this.doctorForm.flag)<br>            this.editDoctor = false<br>            this.$notify(&#123;<br>              title: &#x27;提示信息&#x27;,<br>              message: &#x27;添加成功&#x27;,<br>              type: &#x27;success&#x27;<br>            &#125;)<br>            this.getDoctor()<br>            this.getDoctor()<br>            this.dialogFormVisible = false<br>          &#125;<br>        &#125; else &#123;<br>          this.dialogVisible = true<br>          this.getDoctor()<br>          this.getDoctor()<br>          return false<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    sex (row, column) &#123;<br>      return row.sex<br>    &#125;,<br>    department (row, column) &#123;<br>      return row.department<br>    &#125;,<br>    sort (row, column) &#123;<br>      return row.sort<br>    &#125;,<br>    telephone (row, column) &#123;<br>      return row.telephone<br>    &#125;,<br>    age (row, column) &#123;<br>      return row.age<br>    &#125;,<br>    image (row, column) &#123;<br>      return row.image<br>    &#125;,<br>    handleEdit (index, row) &#123;<br>      this.dialogFormVisible = true<br>      this.editDoctor = true<br>      this.doctorForm = row<br>    &#125;,<br>    handleDelete (index, row) &#123;<br>      this.$confirm(&#x27;确认删除？&#x27;, &#x27;确认信息&#x27;, &#123;<br>        distinguishCancelAndClose: true,<br>        confirmButtonText: &#x27;删除&#x27;,<br>        cancelButtonText: &#x27;放弃删除&#x27;<br>      &#125;).then(() =&gt; &#123;<br>        deleteDoctor(row.id)<br>        this.getDoctor()<br>        this.$message(&#123;<br>          type: &#x27;info&#x27;,<br>          message: &#x27;删除成功&#x27;<br>        &#125;);<br>      &#125;).catch(action =&gt; &#123;<br>      &#125;);<br>    &#125;,<br>    //根据标签刷新<br>    filterHandler(value, row, column) &#123;<br>      const property = column[&#x27;property&#x27;];<br>      return row[property] === value;<br>    &#125;,<br>    filterTag(value, row) &#123;<br>      console.log(this.tableData)<br>      return row.department=== value<br>    &#125;,<br>    //清除标签<br>    clearFilter() &#123;<br>      this.$refs.filterTable.clearFilter()<br>    &#125;,<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.demo-table-expand &#123;<br>  font-size: 0;<br>&#125;<br><br>.demo-table-expand label &#123;<br>  width: 90px;<br>  color: #99a9bf;<br>&#125;<br><br>.demo-table-expand .el-form-item &#123;<br>  margin-right: 0;<br>  margin-bottom: 0;<br>  width: 50%;<br>&#125;<br><br>.block &#123;<br>  position: absolute;<br>  left: 30%;<br>  margin: 30px auto;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>index.vue内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>      &lt;el-header style=&quot;text-align: right; fontsize: 20px&quot;&gt;<br>        &lt;el-dropdown&gt;<br>          &lt;span&gt;你好，管理员&lt;/span&gt;<br>        &lt;/el-dropdown&gt;<br>      &lt;/el-header&gt;<br>    <br>      &lt;el-container&gt;<br>      &lt;el-aside width=&quot;200px&quot;&gt;<br>        &lt;div class=&quot;title&quot;&gt;&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;管 理 员 后 台&lt;/div&gt;<br>        &lt;br&gt;&lt;br&gt;<br>        &lt;el-menu&gt;<br>          &lt;el-menu-item index=&quot;5&quot; @click=&quot;toDoctor()&quot;&gt;<br>              &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;<br>              &lt;template slot=&quot;title&quot;&gt;医生信息管理&lt;/template&gt;<br>          &lt;/el-menu-item&gt;<br>        &lt;/el-menu&gt;<br>      &lt;/el-aside&gt;<br><br>      &lt;el-container&gt;<br>        &lt;el-main class=&quot;main&quot;&gt;<br>          &lt;!--          此处展示视图--&gt;<br>          &lt;transition name=&quot;scale&quot; mode=&quot;out-in&quot;&gt;<br>            &lt;router-view/&gt;<br>          &lt;/transition&gt;<br>        &lt;/el-main&gt;<br>      &lt;/el-container&gt;<br><br>    &lt;/el-container&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;getCurrent, logout&#125; from &#x27;@/api/login&#x27;<br><br>export default &#123;<br>  name: &#x27;Admin&#x27;,<br>  data () &#123;<br>    return &#123;<br>      circleUrl: &#x27;https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png&#x27;<br>    &#125;<br>  &#125;,<br>  mounted() &#123;<br>    this.getCurrent()<br>  &#125;,<br>  methods: &#123;<br>    toDoctor () &#123;<br>      this.$router.push(&#x27;/admin/doctor&#x27;)<br>    &#125;,<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br><br>.title &#123;<br>  height: 100px;<br>  width: 200px;<br>  background-color: #3d504c;<br>  color: white;<br>&#125;<br><br>.main &#123;<br>  height: 100%;<br>  /*border-radius: 30px;*/<br>  background-image: url(&quot;../../assets/background.png&quot;);<br>  background-size: 270px;<br>  background-color: #ebf3f2;<br>  /*text-align: center;*/<br>&#125;<br><br>.scale-enter, .scale-leave-to &#123;<br>  transform: scale(0)<br>&#125;<br>.scale-leave, .scale-enter-to &#123;<br>  transform: scale(1)<br>&#125;<br>.scale-enter-active, .scale-leave-active &#123;<br>  transition: all .5s<br>&#125;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>vue中所有的页面都需要配置路由，以上述两个页面为例：</p><p>在router中国新建modules文件夹，在modules文件夹中新建admin.js，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Admin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/admin/index&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Doctor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/admin/subadmin/Doctor&#x27;</span><br><br><span class="hljs-keyword">const</span> adminRouter = &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Admin&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-title class_">Admin</span>,<br>  <span class="hljs-attr">meta</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;管理员界面&#x27;</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-help&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;doctor&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Doctor&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">Doctor</span>,<br>      <span class="hljs-attr">meta</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;医生信息管理&#x27;</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> adminRouter<br></code></pre></td></tr></table></figure><p>router&#x2F;index.js中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 导入vue-router</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">// 导入组件</span><br><span class="hljs-keyword">import</span> adminRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/modules/admin&#x27;</span><br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<br><br><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  <span class="hljs-attr">routes</span>: [<br>    adminRouter,<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>基本完成，可通过<a href="http://localhost:8080/admin/doctor%E6%9D%A5%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C">http://localhost:8080/admin/doctor来查看效果</a></p><h3 id="2、登录注册修改密码及获取当前用户"><a href="#2、登录注册修改密码及获取当前用户" class="headerlink" title="2、登录注册修改密码及获取当前用户"></a>2、登录注册修改密码及获取当前用户</h3><p>&#x3D;&#x3D;后端&#x3D;&#x3D;</p><p>resources&#x2F;mybatis&#x2F;mappers&#x2F;UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xbb.dao.UserMapper&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 注册 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkRegister&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from user_login where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.xbb.entity.User&quot;</span>&gt;</span><br>        insert into user_login(id,password,flag,username) values(#&#123;id&#125;,#&#123;password&#125;,#&#123;flag&#125;,#&#123;username&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 登录 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from user_login where id=#&#123;id&#125; and password=#&#123;password&#125; and flag=#&#123;flag&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 修改密码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        update user_login set password=#&#123;password&#125; where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>entity&#x2F;User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.entity;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<span class="hljs-comment">//手机号</span><br>    <span class="hljs-keyword">private</span> String password;<span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<span class="hljs-comment">//用户身份，0代表管理员，1代表患者，2代表医生，3代表护士</span><br>    <span class="hljs-keyword">private</span> String username;<span class="hljs-comment">//用户名</span><br>&#125;<br></code></pre></td></tr></table></figure><p>dao&#x2F;UserMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.dao;<br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(String id)</span>;<span class="hljs-comment">//判断id是否已经存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//添加用户（注册）</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//判断手机号、密码和flag是否正确</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(String id,String password)</span>;<span class="hljs-comment">//修改密码（用户）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span>;<span class="hljs-comment">//登出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>service&#x2F;UserService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(String id)</span>;<span class="hljs-comment">//判断id是否已经存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//添加用户（注册）</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(User user)</span>;<span class="hljs-comment">//判断手机号、密码和flag是否正确</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(String id,String password)</span>;<span class="hljs-comment">//修改密码（用户）</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span>;<span class="hljs-comment">//获取当前的登录信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span>;<span class="hljs-comment">//登出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>UserServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service.impl;<br><br><span class="hljs-keyword">import</span> com.xbb.dao.UserMapper;<br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> com.xbb.service.UserService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    HttpServletRequest httpServletRequest;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.checkRegister(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.addUser(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> userMapper.checkLogin(user);<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) httpServletRequest.getSession().setAttribute(<span class="hljs-string">&quot;id&quot;</span>, res.getId());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(String id,String password)</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.updateUser(id,password);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (String) httpServletRequest.getSession().getAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-keyword">return</span> userMapper.getById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span> &#123;<br>        httpServletRequest.getSession().removeAttribute(<span class="hljs-string">&quot;id&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>controller&#x2F;UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.controller;<br><br><span class="hljs-keyword">import</span> com.xbb.entity.User;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.UserServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserServiceImpl userService;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/checkRegister&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkRegister</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String id)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.checkRegister(id);<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value= &quot;/addUser&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.addUser(user);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/checkLogin&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.checkLogin(user);<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/updateUser&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String id,<span class="hljs-meta">@RequestParam</span> String password)</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.updateUser(id,password);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/current&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.current();<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/logout&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span>&#123;<br>        userService.logout();<br>    &#125;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/current&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">current</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> userService.current();<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/addDNUser&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDNUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String id,<span class="hljs-meta">@RequestParam</span> String password,</span><br><span class="hljs-params">                         <span class="hljs-meta">@RequestParam</span> String username,<span class="hljs-meta">@RequestParam</span> <span class="hljs-type">int</span> flag)</span>&#123;<br>        User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setId(id);<br>        user.setPassword(password);<br>        user.setUsername(username);<br>        user.setFlag(flag);<br>        <span class="hljs-keyword">return</span> userService.addUser(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;前端&#x3D;&#x3D;</p><p>views下新建login文件夹，login文件夹下新建Login.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-form ref=&quot;loginForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;<br>             label-width=&quot;80px&quot; class=&quot;login-box&quot;&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;小宝贝看病病&lt;/h3&gt;<br>      &lt;h3 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h3&gt;<br><br>      &lt;el-form-item label=&quot;账号&quot; prop=&quot;id&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.id&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;<br>         <br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.password&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-radio-group v-model=&quot;form.flag&quot;&gt;<br>        &lt;el-radio :label=&quot;0&quot;&gt;用户&lt;/el-radio&gt;<br>        &lt;el-radio :label=&quot;1&quot;&gt;医生&lt;/el-radio&gt;<br>        &lt;el-radio :label=&quot;2&quot;&gt;护士&lt;/el-radio&gt;<br>        &lt;el-radio :label=&quot;3&quot;&gt;管理员&lt;/el-radio&gt;<br>      &lt;/el-radio-group&gt;<br><br>      &lt;el-form-item class=&quot;buttons&quot; style=&quot;margin-left: -60px&quot;&gt;<br>        &lt;el-button @click=&quot;toRegister()&quot;&gt;跳转注册页&lt;/el-button&gt;<br>        &lt;el-button @click=&quot;toUpdatePassword()&quot;&gt;修改密码&lt;/el-button&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(&#x27;loginForm&#x27;)&quot;&gt;登录&lt;/el-button&gt;<br>      &lt;/el-form-item&gt;<br><br>    &lt;/el-form&gt;<br><br>    &lt;el-dialog<br>      title=&quot;温馨提示&quot;<br>      :visible.sync=&quot;dialogVisible&quot;<br>      width=&quot;30%&quot;&gt;<br>&lt;!--      :before-close=&quot;handleClose&quot;--&gt;<br>      &lt;span&gt;请输入正确的格式&lt;/span&gt;<br>      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确定&lt;/el-button&gt;<br>      &lt;/span&gt;<br>    &lt;/el-dialog&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;login&#125; from &#x27;@/api/login&#x27;<br>export default &#123;<br>  name: &#x27;Login.vue&#x27;,<br>  data () &#123;<br>    return &#123;<br>      form: &#123;<br>        id: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        id: [<br>          &#123;required: true, message: &#x27;账号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        flag: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ]<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    toUpdatePassword() &#123;<br>      this.$router.push(&#x27;/updatepassword&#x27;)<br>    &#125;,<br>    showPwd () &#123;<br>      if (this.passwordType === &#x27;password&#x27;) &#123;<br>        this.passwordType = &#x27;&#x27;<br>      &#125; else &#123;<br>        this.passwordType = &#x27;password&#x27;<br>      &#125;<br>      this.$nextTick(() =&gt; &#123;<br>        this.$refs.password.focus()<br>      &#125;)<br>    &#125;,<br>    onSubmit (formName) &#123;<br>      // 为表单绑定验证功能<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        if (vaild) &#123;<br>          login(this.form).then((res) =&gt; &#123;<br>            console.log(res)<br>            if (res.id !== undefined) &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;登录成功&#x27;,<br>                type: &#x27;success&#x27;<br>              &#125;)<br>              // 使用vue-router路由到指定页面，该方式成为编程式导航<br>              if (res.flag === 0)&#123;<br>                this.$router.push(&#x27;/patient&#x27;)<br>              &#125;else if(res.flag === 1)&#123;<br>                this.$router.push(&#x27;/doctor&#x27;)<br>              &#125;else if(res.flag === 2)&#123;<br>                this.$router.push(&#x27;/nurse&#x27;)<br>              &#125;else &#123;<br>                this.$router.push(&#x27;admin&#x27;)<br>              &#125;<br>            &#125; else &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;账号或密码错误&#x27;,<br>                type: &#x27;error&#x27;<br>              &#125;)<br>            &#125;<br>          &#125;)<br>          // // 使用vue-router路由到指定页面，该方式成为编程式导航<br>          // this.$router.push(&#x27;/main&#x27;)<br>        &#125; else &#123;<br>          this.dialogVisible = true<br>          return false<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    toRegister () &#123;<br>      this.$router.push(&#x27;/register&#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.title &#123;<br>  margin: 0 auto 30px auto;<br>  text-align: center;<br>  color: #707070;<br>&#125;<br><br>.login-box &#123;<br>  border: 1px green solid;<br>  width: 350px;<br>  margin: 80px auto;<br>  padding: 35px 35px 15px 35px;<br>  border-radius: 5px;<br>  -webkit-border-radius: 5px;<br>  -moz-border-radius: 5px;<br>  box-shadow: 0 0 25px #2c3e90;<br>&#125;<br><br>.login-title &#123;<br>  text-align: center;<br>  margin: 0 auto 40px auto;<br>  color: #af4f7e;<br>&#125;<br><br>.buttons &#123;<br>  //margin: 30px auto;<br>  margin-top: 40px;<br>  margin-left: 25px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>login下新建Register.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-form ref=&quot;registerForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;<br>             label-width=&quot;80px&quot; class=&quot;register-box&quot;&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;小宝贝看病病&lt;/h3&gt;<br>      &lt;h3 class=&quot;register-title&quot;&gt;欢迎注册&lt;/h3&gt;<br><br>      &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; v-model=&quot;form.username&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;手机号&quot; prop=&quot;id&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入手机号&quot; v-model=&quot;form.id&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.password&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;confirmPassword&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.confirmPassword&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item class=&quot;register-button&quot; style=&quot;margin-left: 0px&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(&#x27;registerForm&#x27;)&quot;&gt;注册&lt;/el-button&gt;<br>        &lt;el-button @click=&quot;toLogin()&quot;&gt;跳转登录页&lt;/el-button&gt;<br>      &lt;/el-form-item&gt;<br><br>    &lt;/el-form&gt;<br><br>    &lt;el-dialog<br>      title=&quot;温馨提示&quot;<br>      :visible.sync=&quot;dialogVisible&quot;<br>      width=&quot;30%&quot;<br>      &gt;<br>      &lt;span&gt;请重新验证格式&lt;/span&gt;<br>      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;重新输入&lt;/el-button&gt;<br>&lt;!--        &lt;el-button type=&quot;primary&quot; @click=&quot;toLogin()&quot;&gt;回到登录&lt;/el-button&gt;--&gt;<br>      &lt;/span&gt;<br>    &lt;/el-dialog&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;register, checkRegister&#125; from &#x27;@/api/register&#x27;<br>import &#123;<br>  validateContacts,<br>  validatePhone,<br>  validatePsdReg<br>&#125; from &#x27;@/views/login/validation&#x27;<br>import &#123;addPatient&#125; from &#x27;@/api/admin&#x27;<br>export default &#123;<br>  name: &#x27;Register&#x27;,<br>  data () &#123;<br>    return &#123;<br>      form: &#123;<br>        username: &#x27;&#x27;,<br>        id: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        confirmPassword: &#x27;&#x27;,<br>        // flag: &#x27;&#x27;<br>      &#125;,<br>      patientForm: &#123;<br>        telephone: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        username: [<br>          &#123;required: true, message: &#x27;用户名不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123; validator: validateContacts, message: validateContacts.callback, trigger: &#x27;blur&#x27; &#125;<br>        ],<br>        id: [<br>          &#123;required: true, message: &#x27;手机号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123; min: 11, max: 11, message: &#x27;手机号格式错误&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123; validator: validatePhone, message: &#x27;手机号格式错误&#x27;, trigger: &#x27;blur&#x27; &#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;validator:validatePsdReg, message: validatePsdReg.callback, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        confirmPassword: [<br>          &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator:(rule,value,callback)=&gt;&#123;<br>              if(value===&#x27;&#x27;)&#123;<br>                callback(new Error(&#x27;请再次输入密码&#x27;))<br>              &#125;else if(value!==this.form.password)&#123;<br>                callback(new Error(&#x27;两次输入密码不一致&#x27;))<br>              &#125;else&#123;<br>                callback( )<br>              &#125;<br>            &#125;,<br>            trigger:&#x27;blur&#x27;<br>          &#125;<br>        ]<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    toLogin() &#123;<br>      this.dialogVisible = false<br>      this.$router.push(&#x27;/login&#x27;)<br>    &#125;,<br>    onSubmit (formName) &#123;<br>      // 为表单绑定验证功能<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        console.log(this.form.id)<br>        checkRegister(this.form.id).then((res) =&gt; &#123;<br>          console.log(res.id)<br>          if (vaild) &#123;<br>            if (res.id === undefined) &#123;<br>              // 使用vue-router路由到指定页面，该方式成为编程式导航<br>              register(this.form).then((res) =&gt; &#123;<br>                console.log(res)<br>              &#125;)<br>              this.patientForm.telephone = this.form.id<br>              addPatient(this.patientForm)<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;注册成功&#x27;,<br>                type: &#x27;success&#x27;<br>              &#125;)<br>              this.$router.push(&#x27;/login&#x27;)<br>              return true<br>            &#125; else &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;该手机号已注册&#x27;,<br>                type: &#x27;error&#x27;<br>              &#125;)<br>            &#125;<br>          &#125; else &#123;<br>            this.dialogVisible = true<br>            return false<br>          &#125;<br>        &#125;)<br><br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.title &#123;<br>  margin: 0 auto 30px auto;<br>  text-align: center;<br>  color: #707070;<br>&#125;<br>.register-box &#123;<br>  border: 1px green solid;<br>  width: 350px;<br>  margin: 80px auto;<br>  padding: 35px 35px 15px 35px;<br>  border-radius: 5px;<br>  -webkit-border-radius: 5px;<br>  -moz-border-radius: 5px;<br>  box-shadow: 0 0 25px #2c3e90;<br>&#125;<br>.register-title &#123;<br>  text-align: center;<br>  margin: 0 auto 40px auto;<br>  color: #af4f7e;<br>&#125;<br>.register-button &#123;<br>  margin-left: 60px;<br>  margin-top: 30px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>login下新建UpdatePassword.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-form ref=&quot;updatePasswordForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;<br>             label-width=&quot;120px&quot; class=&quot;login-box&quot;&gt;<br>      &lt;br&gt;<br>      &lt;h3 class=&quot;title&quot;&gt;小宝贝看病病&lt;/h3&gt;<br>      &lt;h3 class=&quot;login-title&quot;&gt;修改密码&lt;/h3&gt;<br>      &lt;br&gt;<br>      &lt;el-form-item label=&quot;账号&quot; prop=&quot;id&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.id&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item label=&quot;请输入原密码&quot; prop=&quot;password&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入原密码&quot; v-model=&quot;form.password&quot;/&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;br&gt;<br>      &lt;el-form-item label=&quot;请输入新密码&quot; prop=&quot;newPassword&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入新密码&quot; v-model=&quot;form.newPassword&quot;/&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;br&gt;<br>      &lt;el-form-item label=&quot;请确认新密码&quot; prop=&quot;confirmPassword&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; placeholder=&quot;请确认新密码&quot; v-model=&quot;form.confirmPassword&quot;/&gt;<br>      &lt;/el-form-item&gt;<br><br>      &lt;el-form-item class=&quot;buttons&quot; style=&quot;margin-left: -100px&quot;&gt;<br>        &lt;el-button @click=&quot;toRegister()&quot;&gt;跳转注册页&lt;/el-button&gt;<br>        &lt;el-button @click=&quot;toLogin()&quot;&gt;跳转登录页&lt;/el-button&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;updatePassword(&#x27;updatePasswordForm&#x27;)&quot;&gt;确认修改密码&lt;/el-button&gt;<br>      &lt;/el-form-item&gt;<br><br>    &lt;/el-form&gt;<br><br>    &lt;el-dialog<br>      title=&quot;温馨提示&quot;<br>      :visible.sync=&quot;dialogVisible&quot;<br>      width=&quot;30%&quot;&gt;<br>      &lt;!--      :before-close=&quot;handleClose&quot;--&gt;<br>      &lt;span&gt;请输入账号和密码&lt;/span&gt;<br>      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确定&lt;/el-button&gt;<br>      &lt;/span&gt;<br>    &lt;/el-dialog&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;checkPassword, login, updatePassword&#125; from &#x27;@/api/login&#x27;<br>import &#123;validatePsdReg&#125; from &#x27;@/views/login/validation&#x27;<br>export default &#123;<br>  name: &#x27;Login.vue&#x27;,<br>  data () &#123;<br>    return &#123;<br>      form: &#123;<br>        id: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        newPassword: &#x27;&#x27;,<br>        confirmPassword: &#x27;&#x27;,<br>        flag: &#x27;&#x27;<br>      &#125;,<br>      // 表单验证，需要在el-form-item元素中增加prop属性<br>      rules: &#123;<br>        id: [<br>          &#123;required: true, message: &#x27;账号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;<br>        ],<br>        password: [<br>          &#123;required: true, message: &#x27;原密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator: validatePsdReg,<br>            message: validatePsdReg.callback,<br>            trigger: &#x27;blur&#x27;<br>          &#125;<br>        ],<br>        newPassword: [<br>          &#123;required: true, message: &#x27;新密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator: validatePsdReg,<br>            message: validatePsdReg.callback,<br>            trigger: &#x27;blur&#x27;<br>          &#125;<br>        ],<br>        confirmPassword: [<br>          &#123;required: true, message: &#x27;请再次输入新密码&#x27;, trigger: &#x27;blur&#x27;&#125;,<br>          &#123;<br>            validator:(rule,value,callback)=&gt;&#123;<br>              if(value===&#x27;&#x27;)&#123;<br>                callback(new Error(&#x27;请再次输入密码&#x27;))<br>              &#125;else if(value!==this.form.password)&#123;<br>                callback(new Error(&#x27;两次输入密码不一致&#x27;))<br>              &#125;else&#123;<br>                callback( )<br>              &#125;<br>            &#125;,<br>            trigger:&#x27;blur&#x27;<br>          &#125;<br>        ]<br>      &#125;,<br>      // 对话框和显示<br>      dialogVisible: false<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    updatePassword(formName) &#123;<br>      console.log(&#x27;start&#x27;)<br>      this.$refs[formName].validate((vaild) =&gt; &#123;<br>        if (vaild) &#123;<br>          checkPassword(this.form.id,this.form.password).then((res) =&gt; &#123;<br>            if(res.id !== undefined)&#123;<br>              updatePassword(this.form.id, this.form.newPassword)<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;更改密码成功&#x27;,<br>                type: &#x27;success&#x27;<br>              &#125;)<br>            &#125;else &#123;<br>              this.$notify(&#123;<br>                title: &#x27;提示信息&#x27;,<br>                message: &#x27;密码与账号不匹配&#x27;,<br>                type: &#x27;error&#x27;<br>              &#125;)<br>            &#125;<br>          &#125;)<br>        &#125; else &#123;<br>          this.dialogVisible = true<br>          return false<br>        &#125;<br>      &#125;)<br>    &#125;,<br>    toLogin()&#123;<br>      this.$router.push(&#x27;/login&#x27;)<br>    &#125;,<br>    showPwd () &#123;<br>      if (this.passwordType === &#x27;password&#x27;) &#123;<br>        this.passwordType = &#x27;&#x27;<br>      &#125; else &#123;<br>        this.passwordType = &#x27;password&#x27;<br>      &#125;<br>      this.$nextTick(() =&gt; &#123;<br>        this.$refs.password.focus()<br>      &#125;)<br>    &#125;,<br>    toRegister () &#123;<br>      this.$router.push(&#x27;/register&#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.title &#123;<br>  margin: 0 auto 30px auto;<br>  text-align: center;<br>  color: #707070;<br>&#125;<br><br>.login-box &#123;<br>  border: 1px green solid;<br>  width: 420px;<br>  margin: 80px auto;<br>  padding: 35px 35px 15px 35px;<br>  border-radius: 5px;<br>  -webkit-border-radius: 5px;<br>  -moz-border-radius: 5px;<br>  box-shadow: 0 0 25px #2c3e90;<br>&#125;<br><br>.login-title &#123;<br>  text-align: center;<br>  margin: 0 auto 40px auto;<br>  color: #af4f7e;<br>&#125;<br><br>.buttons &#123;<br>  //margin: 30px auto;<br>  margin-top: 40px;<br>  margin-left: 25px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>login文件夹下新建validation.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 是否电话号码</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validatePhone</span>(<span class="hljs-params">rule, value,callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> reg =<span class="hljs-regexp">/^[1][3-9][0-9]&#123;9&#125;$/</span>;<br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-string">&#x27;&#x27;</span>||value==<span class="hljs-literal">undefined</span>||value==<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> ((!reg.<span class="hljs-title function_">test</span>(value)) &amp;&amp; value != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入正确的电话号码&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//是否邮箱号</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateEMail</span>(<span class="hljs-params">rule, value,callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> reg =<span class="hljs-regexp">/^([a-zA-Z0-9]+[-_\.]?)+@[a-zA-Z0-9]+\.[a-z]+$/</span>;<br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-string">&#x27;&#x27;</span>||value==<span class="hljs-literal">undefined</span>||value==<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span> (!reg.<span class="hljs-title function_">test</span>(value))&#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入正确的邮箱&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//是否身份证号</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateIdNo</span>(<span class="hljs-params">rule, value,callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>;<br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-string">&#x27;&#x27;</span>||value==<span class="hljs-literal">undefined</span>||value==<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> ((!reg.<span class="hljs-title function_">test</span>(value)) &amp;&amp; value != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入正确的身份证号码&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 检查密码格式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">validatePsdReg</span> = (<span class="hljs-params">rule, value, callback</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入密码&#x27;</span>))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(?![\d]+$)(?![a-zA-Z]+$)(?![^\da-zA-Z]+$)([^\u4e00-\u9fa5\s])&#123;6,20&#125;$/</span>.<span class="hljs-title function_">test</span>(value)) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入6-20位英文字母、数字或者符号（除空格），且字母、数字和标点符号至少包含两种&#x27;</span>))<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">callback</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否为中文</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">validateContacts</span> = (<span class="hljs-params">rule, value, callback</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入中文&#x27;</span>))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[\u0391-\uFFE5A-Za-z]+$/</span>.<span class="hljs-title function_">test</span>(value)) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;不可输入特殊字符&#x27;</span>))<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">callback</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置路由类似上个部分，不再复述。</p><h3 id="3、Echarts图"><a href="#3、Echarts图" class="headerlink" title="3、Echarts图"></a>3、Echarts图</h3><p>&#x3D;&#x3D;后端&#x3D;&#x3D;</p><p>主要是算数据给数据</p><p>OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countAge&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where patient_age<span class="hljs-symbol">&amp;gt;</span>=#&#123;age1&#125; and patient_age<span class="hljs-symbol">&amp;lt;</span>#&#123;age2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countDepartment&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where department=#&#123;department&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countOrderByDoctorName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where doctor_name=#&#123;doctorName&#125; and order_day &gt;= date(now()) - interval 7 day group by order_day ORDER BY order_day<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countOrder&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>    select count(*) from order_info where order_day &gt;= date(now()) - interval 7 day group by order_day ORDER BY order_day;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>dao&#x2F;OrderMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.dao;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age1,<span class="hljs-type">int</span> age2)</span>;<span class="hljs-comment">//查询就诊年龄段对应的记录条数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//查询所挂科室的记录数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder();<span class="hljs-comment">//查询未来一周预约人数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(String name);<span class="hljs-comment">//根据医生名查询未来一周预约人数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>OrderService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age1,<span class="hljs-type">int</span> age2)</span>;<span class="hljs-comment">//查询就诊年龄段对应的记录条数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDepartment</span><span class="hljs-params">(String department)</span>;<span class="hljs-comment">//查询所挂科室的记录数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder();<span class="hljs-comment">//查询未来一周预约人数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(String name);<span class="hljs-comment">//根据医生名查询未来一周预约人数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>OrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.service.impl;<br><span class="hljs-keyword">import</span> com.xbb.dao.OrderMapper;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> com.xbb.service.OrderService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age1, <span class="hljs-type">int</span> age2)</span> &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countAge(age1,age2);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDepartment</span><span class="hljs-params">(String department)</span> &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countDepartment(department);<br>    &#125;<br>    <br>        <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder() &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countOrder();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(String name) &#123;<br>        <span class="hljs-keyword">return</span> orderMapper.countOrderByDoctorName(name);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>OrderController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.controller;<br><br><span class="hljs-keyword">import</span> com.xbb.entity.MedicalRecord;<br><span class="hljs-keyword">import</span> com.xbb.entity.Order;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.MedicalRecordServiceImpl;<br><span class="hljs-keyword">import</span> com.xbb.service.impl.OrderServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.propertyeditors.CustomDateEditor;<br><span class="hljs-keyword">import</span> org.springframework.beans.propertyeditors.CustomNumberEditor;<br><span class="hljs-keyword">import</span> org.springframework.beans.propertyeditors.StringTrimmerEditor;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.WebDataBinder;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderServiceImpl orderService;<br>    <span class="hljs-keyword">private</span> MedicalRecordServiceImpl medicalRecordService;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countAge&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countAge()&#123;<br>        <span class="hljs-type">int</span>[] countAge=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)&#123;<br>            countAge[i]=orderService.countAge(i*<span class="hljs-number">10</span>,(i+<span class="hljs-number">1</span>)*<span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> countAge;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countDepartment&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countDepartment()&#123;<br>        <span class="hljs-type">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">12</span>];<br>        count[<span class="hljs-number">0</span>]=orderService.countDepartment(<span class="hljs-string">&quot;神经内科&quot;</span>);<br>        count[<span class="hljs-number">1</span>]=orderService.countDepartment(<span class="hljs-string">&quot;内科&quot;</span>);<br>        count[<span class="hljs-number">2</span>]=orderService.countDepartment(<span class="hljs-string">&quot;外科&quot;</span>);<br>        count[<span class="hljs-number">3</span>]=orderService.countDepartment(<span class="hljs-string">&quot;妇产科&quot;</span>);<br>        count[<span class="hljs-number">4</span>]=orderService.countDepartment(<span class="hljs-string">&quot;儿科&quot;</span>);<br>        count[<span class="hljs-number">5</span>]=orderService.countDepartment(<span class="hljs-string">&quot;眼科&quot;</span>);<br>        count[<span class="hljs-number">6</span>]=orderService.countDepartment(<span class="hljs-string">&quot;耳鼻咽喉科&quot;</span>);<br>        count[<span class="hljs-number">7</span>]=orderService.countDepartment(<span class="hljs-string">&quot;口腔科&quot;</span>);<br>        count[<span class="hljs-number">8</span>]=orderService.countDepartment(<span class="hljs-string">&quot;皮肤科&quot;</span>);<br>        count[<span class="hljs-number">9</span>]=orderService.countDepartment(<span class="hljs-string">&quot;肿瘤科&quot;</span>);<br>        count[<span class="hljs-number">10</span>]=orderService.countDepartment(<span class="hljs-string">&quot;中医科&quot;</span>);<br>        count[<span class="hljs-number">11</span>]=orderService.countDepartment(<span class="hljs-string">&quot;体检中心&quot;</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countOrderByDoctorName&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrderByDoctorName(<span class="hljs-meta">@RequestParam</span> String name)&#123;<br>        <span class="hljs-keyword">return</span> orderService.countOrderByDoctorName(name);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/countOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countOrder()&#123;<br>        <span class="hljs-keyword">return</span> orderService.countOrder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;前端&#x3D;&#x3D;</p><p>前端是根据从后端拿到的数据绘图，写法参考<a href="https://echarts.apache.org/handbook/zh/get-started/">https://echarts.apache.org/handbook/zh/get-started/</a></p><p>我们的写法如下：</p><p>admin.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/request&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getOrderCount</span> () &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/count&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAgeCount</span> () &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/countAge&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">countOrder</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> request (&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/countOrder&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">countOrderByDoctorName</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/order/countOrderByDoctorName&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">name</span>: name<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>给参数的写法很容易错，报错一般是xxx is not present</p><p>稍微总结：</p><p>1、传多个参数拿到的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;get&#x27;</span>,<br><span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">val</span>:val,<br>    <span class="hljs-attr">current</span>: current<br>&#125;<br></code></pre></td></tr></table></figure><p>2、传一个表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>data <span class="hljs-comment">//或写为 params: data</span><br><span class="hljs-comment">// 后端需要多个参数时，前端可以作为表单提交</span><br><span class="hljs-comment">// 定义方式例：</span><br><span class="hljs-attr">page</span>: &#123;<br>    <span class="hljs-attr">current</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">size</span>: <span class="hljs-number">10</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>3、不传参：直接不写</p></blockquote><p>接下来选择比较复杂的OrderEchartsByDoctor为例，效果是拿到从当天起及后六天共七天的单个医生的被预约数，然后展示，因为后端只拿到了数据数组，所以前端还写了获取近七天日期的方法与后端数据对应，另外这里本来想的是从父组件拿医生名，结果貌似子组件先加载所以拿不到，最后放弃了组件间传值，直接在这个子组件获取。</p><p>在components里新建OrderEchartsByDoctor.vue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;div id=&quot;orderEchartsByDoctor&quot; :style=&quot;&#123;width: &#x27;400px&#x27;, height: &#x27;400px&#x27;&#125;&quot; class=&quot;chart&quot;&gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;countOrder, getOrderCount&#125; from &#x27;@/api/admin&#x27;<br>import &#123;countOrderByDoctorName&#125; from &#x27;@/api/doctor&#x27;<br>import &#123;getCurrent&#125; from &#x27;@/api/login&#x27;<br><br>export default &#123;<br>  name: &#x27;OrderEchartsByDoctor&#x27;,<br>  props: [&#x27;name&#x27;],<br>  created()&#123;<br>    console.log(&quot;页面初次进来时，是否存在：&quot;, this.nameNow)<br>    this.getDate();<br>    this.countOrder();<br>  &#125;,<br>  data () &#123;<br>    return &#123;<br>      count: [],<br>      same_week: [],<br>      same_day: &#x27;&#x27;,<br>      singleDate: [],<br>      nameNow:&#x27;&#x27;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    countOrder()&#123;<br>      getCurrent().then((res) =&gt; &#123;<br>        this.nameNow = res.username<br>        console.log(res)<br>        countOrderByDoctorName(this.nameNow).then((res) =&gt; &#123;<br>          this.count = res;<br>          this.drawLine()<br>        &#125;)<br>      &#125;)<br><br>    &#125;,<br><br>    getDate()&#123;<br>      // 默认显示当天前一周的数据<br>      let data = [];<br>      for (let i = 6; i &gt;= 0; i--) &#123;<br>        data.push(this.getDay(+i)) // 后<br>      &#125;<br>      console.log(data)<br>      // let date = data.reverse(); //得出一周的日期进行排序<br>      let date = data;<br>      let pkc = []; /* 用于存储展示的日期数据 */<br>      let weekday = [<br>        &#x27;星期日&#x27;,<br>        &#x27;星期一&#x27;,<br>        &#x27;星期二&#x27;,<br>        &#x27;星期三&#x27;,<br>        &#x27;星期四&#x27;,<br>        &#x27;星期五&#x27;,<br>        &#x27;星期六&#x27;,<br>      ];<br>      date.forEach((item, index) =&gt; &#123;<br>        //循坏日期<br>        let f = new Date(item);<br>        let week = f.getDay(); //计算出星期几<br>        let str1 = item.split(&#x27;-&#x27;);<br>        let strs = str1[0] + &#x27;-&#x27; + str1[1] + &#x27;-&#x27; + str1[2];<br><br>        let weeks = weekday[week]; /* 将计算出来的时间带入数字得出中文 */<br>        let time = Math.round(new Date(item) / 1000); //时间戳转换<br>        let s = &#123;&#125;; //用于存储每个日期对象<br>        s.date = item;<br>        s.name = strs;<br>        s.week = weeks;<br>        s.times = time;<br>        pkc.push(s);<br>      &#125;);<br>      this.same_week = pkc;<br>      //pkc存储着今天的年月日星期几，时间戳等<br>      this.same_day = pkc[0].date; //今天的数据<br>      for (let i = 0; i &lt; this.same_week.length; i++) &#123;<br>        this.singleDate = this.singleDate.concat(this.same_week[i].date)<br>      &#125;<br>    &#125;,<br>    getDay(day) &#123;<br>      let today = new Date();<br>      let targetday_milliseconds = today.getTime() + 1000 * 60 * 60 * 24 * day;<br>      today.setTime(targetday_milliseconds); //注意，这行是关键代码<br>      let tYear = today.getFullYear();<br>      let tMonth = today.getMonth();<br>      let tDate = today.getDate();<br>      tMonth = this.doHandleMonth(tMonth + 1);<br>      tDate = this.doHandleMonth(tDate);<br>      // return tYear + &#x27;-&#x27; + tMonth + &#x27;-&#x27; + tDate;<br>      return tMonth + &#x27;-&#x27; + tDate;<br>    &#125;,<br>    doHandleMonth(month) &#123;<br>      let m = month;<br>      if (month.toString().length == 1) &#123;<br>        m = month;<br>      &#125;<br>      return m;<br>    &#125;,<br><br>    drawLine()&#123;<br>      // 基于准备好的dom，初始化echarts实例<br>      let orderChart = this.$echarts.init(document.getElementById(&#x27;orderEchartsByDoctor&#x27;))<br>      // 绘制图表<br>      orderChart.setOption(&#123;<br>        title: &#123;<br>          text: &#x27;最近七天-我的预约&#x27;,<br>          subtext: &#x27;单位（个）&#x27;<br>        &#125;,<br>        tooltip: &#123;&#125;,<br>        yAxis: &#123;<br>          type: &#x27;category&#x27;,<br>          // data: [&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;]<br>          data: this.singleDate<br>        &#125;,<br>        xAxis: &#123;<br><br>        &#125;,<br>        series: [&#123;<br>          name: &#x27;挂号&#x27;,<br>          type: &#x27;bar&#x27;,<br>          color: &#x27;#86a185&#x27;,<br>          // data: [&quot;0&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;2&quot;,&quot;4&quot;,&quot;4&quot;]<br>          data: this.count.reverse()<br>        &#125;]<br>      &#125;);<br>    &#125;,<br>  &#125;<br>&#125;<br><br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.chart&#123;<br>  margin-left: 100px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>然后在view&#x2F;doctor&#x2F;subdoctor&#x2F;AddPatient里使用组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;el-card&gt;<br>  &lt;order-echarts-by-doctor<br>    id=&quot;orderEchartsByDoctor&quot;<br>    :style=&quot;&#123;width: &#x27;400px&#x27;, height: &#x27;400px&#x27;&#125;&quot;<br>    :name=&quot;name&quot;<br>  &gt;&lt;/order-echarts-by-doctor&gt;<br>&lt;/el-card&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import OrderEchartsByDoctor from &#x27;@/components/OrderEchartsByDoctor&#x27;<br>export default &#123;<br>  name: &#x27;addPatient&#x27;,<br>  components: &#123; OrderEchartsByDoctor &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.demo-draw__content &#123;<br>  text-align: left;<br>&#125;<br>.button &#123;<br>  text-align: center;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这里再把前端获取当前时间单拉出来：</p><p>法一：</p><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; nowDate &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">nowDate</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 当前日期</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">currentTime</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">formatDate</span>, <span class="hljs-number">500</span>);<br>    &#125;,<br>    <span class="hljs-title function_">formatDate</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>      <span class="hljs-keyword">let</span> year = date.<span class="hljs-title function_">getFullYear</span>(); <span class="hljs-comment">// 年</span><br>      <span class="hljs-keyword">let</span> month = date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>; <span class="hljs-comment">// 月</span><br>      <span class="hljs-keyword">let</span> day = date.<span class="hljs-title function_">getDate</span>(); <span class="hljs-comment">// 日</span><br>      <span class="hljs-keyword">let</span> week = date.<span class="hljs-title function_">getDay</span>(); <span class="hljs-comment">// 星期</span><br>      <span class="hljs-keyword">let</span> weekArr = [ <span class="hljs-string">&quot;星期日&quot;</span>, <span class="hljs-string">&quot;星期一&quot;</span>, <span class="hljs-string">&quot;星期二&quot;</span>, <span class="hljs-string">&quot;星期三&quot;</span>, <span class="hljs-string">&quot;星期四&quot;</span>, <span class="hljs-string">&quot;星期五&quot;</span>, <span class="hljs-string">&quot;星期六&quot;</span> ];<br>      <span class="hljs-keyword">let</span> hour = date.<span class="hljs-title function_">getHours</span>(); <span class="hljs-comment">// 时</span><br>      hour = hour &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + hour : hour; <span class="hljs-comment">// 如果只有一位，则前面补零</span><br>      <span class="hljs-keyword">let</span> minute = date.<span class="hljs-title function_">getMinutes</span>(); <span class="hljs-comment">// 分</span><br>      minute = minute &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + minute : minute; <span class="hljs-comment">// 如果只有一位，则前面补零</span><br>      <span class="hljs-keyword">let</span> second = date.<span class="hljs-title function_">getSeconds</span>(); <span class="hljs-comment">// 秒</span><br>      second = second &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + second : second; <span class="hljs-comment">// 如果只有一位，则前面补零</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">nowDate</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;year&#125;</span>/<span class="hljs-subst">$&#123;month&#125;</span>/<span class="hljs-subst">$&#123;day&#125;</span> <span class="hljs-subst">$&#123;hour&#125;</span>:<span class="hljs-subst">$&#123;minute&#125;</span>:<span class="hljs-subst">$&#123;second&#125;</span> <span class="hljs-subst">$&#123;weekArr[week]&#125;</span>`</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">currentTime</span>();<br>  &#125;,<br>  <span class="hljs-comment">// 销毁定时器</span><br>  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">formatDate</span>) &#123;<br>      <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">formatDate</span>); <span class="hljs-comment">// 在Vue实例销毁前，清除时间定时器</span><br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">date</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>      <span class="hljs-title function_">dateFormat</span>(<span class="hljs-params">time</span>) &#123;<br>          <span class="hljs-keyword">var</span> date=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time);<br>          <span class="hljs-keyword">var</span> year=date.<span class="hljs-title function_">getFullYear</span>();<br>          <span class="hljs-comment">/* 在日期格式中，月份是从0开始的，因此要加0</span><br><span class="hljs-comment">          * 使用三元表达式在小于10的前面加0，以达到格式统一  如 09:11:05</span><br><span class="hljs-comment">          * */</span><br>          <span class="hljs-keyword">var</span> month= date.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+(date.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>) : date.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">var</span> day=date.<span class="hljs-title function_">getDate</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getDate</span>() : date.<span class="hljs-title function_">getDate</span>();<br>          <span class="hljs-keyword">var</span> hours=date.<span class="hljs-title function_">getHours</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getHours</span>() : date.<span class="hljs-title function_">getHours</span>();<br>          <span class="hljs-keyword">var</span> minutes=date.<span class="hljs-title function_">getMinutes</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getMinutes</span>() : date.<span class="hljs-title function_">getMinutes</span>();<br>          <span class="hljs-keyword">var</span> seconds=date.<span class="hljs-title function_">getSeconds</span>()&lt;<span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span>+date.<span class="hljs-title function_">getSeconds</span>() : date.<span class="hljs-title function_">getSeconds</span>();<br>          <span class="hljs-comment">// 拼接</span><br>          <span class="hljs-keyword">return</span> year+<span class="hljs-string">&quot;-&quot;</span>+month+<span class="hljs-string">&quot;-&quot;</span>+day+<span class="hljs-string">&quot; &quot;</span>+hours+<span class="hljs-string">&quot;:&quot;</span>+minutes+<span class="hljs-string">&quot;:&quot;</span>+seconds;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-comment">//显示当前日期时间</span><br>          <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span><span class="hljs-comment">// 声明一个变量指向Vue实例this，保证作用域一致</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           _this.<span class="hljs-property">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 修改数据date</span><br>           &#125;, <span class="hljs-number">1000</span>)<br>       &#125;,<br>      <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>) &#123;<br>        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>); <span class="hljs-comment">// 在Vue实例销毁前，清除我们的定时器</span><br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;&#123;&#123;<span class="hljs-title function_">dateFormat</span>(date)&#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>天气</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWeather</span>();<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWeather</span>();<br>  &#125;, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">getWeather</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 第三方天气api接口</span><br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://www.tianqiapi.com/api/&#x27;</span>, &#123;<br>      <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">appid</span>: <span class="hljs-string">&#x27;26148275&#x27;</span>,<br>        <span class="hljs-attr">appsecret</span>: <span class="hljs-string">&#x27;2id6H48Y&#x27;</span>,<br>        <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;v6&#x27;</span><br>      &#125;<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>) &#123;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;xue&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/xue.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;yin&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/yin.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;yu&#x27;</span> || res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;bingbao&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/yu.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;yun&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/yun.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;wu&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/wu.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;shachen&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/shachen.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">wea_img</span> == <span class="hljs-string">&#x27;lei&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/lei.png&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgSrc</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../assets/img/brand/qing.png&#x27;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">weatcherData</span> = res.<span class="hljs-property">data</span>;<br>      &#125;<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、下拉框的选项触发事件"><a href="#4、下拉框的选项触发事件" class="headerlink" title="4、下拉框的选项触发事件"></a>4、下拉框的选项触发事件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form-item&gt;<br>    &lt;span&gt;病&amp;nbsp;&amp;nbsp;房&amp;nbsp;&amp;nbsp;号&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>    &lt;el-select v-model=&quot;patientForm.wardId&quot; placeholder=&quot;请选择&quot;&gt;<br>        &lt;el-option<br>                   v-for=&quot;item in bedInfo&quot;<br>                   :key=&quot;item&quot;<br>                   :label=&quot;item&quot;<br>                   :value=&quot;item&quot;<br>                   @click.native=&quot;getBedList()&quot;<br>                   &gt;<br>        &lt;/el-option&gt;<br>    &lt;/el-select&gt;<br>&lt;/el-form-item&gt;<br></code></pre></td></tr></table></figure><blockquote><p> 给vue组件绑定事件时候，必须加上native ，否则会认为监听的是来自Item组件自定义的事件。</p><p> 例子：如果使用router-link标签，加上@click事件，绑定的事件会无效因为：router-link的作用是单纯的路由跳转，会阻止click事件，你可以试试只用click不用native,事件是不会触发的。此时加上.native，才会触发事件。</p><p> &#x3D;&#x3D;这里也用到了用v-for动态生成&#x3D;&#x3D;</p></blockquote><h3 id="5、显示已有值，但可以修改"><a href="#5、显示已有值，但可以修改" class="headerlink" title="5、显示已有值，但可以修改"></a>5、显示已有值，但可以修改</h3><blockquote><p>之前在别的组件里试过很多次，为了让用户每次提交时不用修改所有值，但发现el-input这个东西会让v-model失效所以不行，但后来在写个人信息修改的时候又成了，记录在这里：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-card class=&quot;box-card&quot;&gt;<br>      &lt;el-form ref=&quot;personalForm&quot; :model=&quot;personalForm&quot;&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;姓&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;名&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input v-model=&quot;personalForm.name&quot; style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-radio-group v-model=&quot;personalForm.sex&quot;&gt;<br>            &lt;el-radio label=&quot;男&quot;&gt;&lt;/el-radio&gt;<br>            &lt;el-radio label=&quot;女&quot;&gt;&lt;/el-radio&gt;<br>          &lt;/el-radio-group&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;身份证号&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input v-model=&quot;personalForm.idCard&quot; style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;年&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;龄&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input-number v-model=&quot;personalForm.age&quot; @change=&quot;handleChange&quot; :min=&quot;1&quot; :max=&quot;110&quot; label=&quot;描述文字&quot;&gt;&lt;/el-input-number&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;生&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;日&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-date-picker v-model=&quot;personalForm.birth&quot; type=&quot;date&quot; placeholder=&quot;选择日期&quot;&gt;&lt;/el-date-picker&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;婚&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;姻&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-radio-group v-model=&quot;personalForm.marriage&quot;&gt;<br>            &lt;el-radio label=&quot;未婚&quot;&gt;&lt;/el-radio&gt;<br>            &lt;el-radio label=&quot;已婚&quot;&gt;&lt;/el-radio&gt;<br>          &lt;/el-radio-group&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;span&gt;家庭住址&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br>          &lt;el-input v-model=&quot;personalForm.address&quot; style=&quot;width: 50%;&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-button type=&quot;primary&quot; @click=&quot;updatePatient()&quot; class=&quot;button&quot;&gt;提交&lt;/el-button&gt;<br>      &lt;/el-form&gt;<br>    &lt;/el-card&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;getPatientInfo, updatePatient&#125; from &#x27;@/api/patient&#x27;<br>import &#123;getCurrent&#125; from &#x27;@/api/login&#x27;<br><br>export default &#123;<br>  name: &#x27;PersonalInfo&#x27;,<br>  data()&#123;<br>    return&#123;<br>      updateInfo:[],<br>      personalForm: &#123;<br>        name: &#x27;&#x27;,<br>        sex: &#x27;&#x27;,<br>        idCard: &#x27;&#x27;,<br>        age: &#x27;&#x27;,<br>        birth: &#x27;&#x27;,<br>        telephone: &#x27;&#x27;,<br>        marriage: &#x27;&#x27;,<br>        address: &#x27;&#x27;<br>      &#125;,<br>      username: &#x27;&#x27;,<br>      id: &#x27;&#x27;,<br>    &#125;<br>  &#125;,<br>  mounted() &#123;<br>    this.getCurrent()<br>  &#125;,<br>  methods: &#123;<br>    handleChange(value) &#123;<br>      console.log(value);<br>    &#125;,<br>    getCurrent() &#123;<br>      getCurrent().then((res) =&gt; &#123;<br>        this.username = res.username<br>        getPatientInfo(res.id).then((res) =&gt; &#123;<br>          this.personalForm = res<br>        &#125;)<br>      &#125;)<br>    &#125;,<br>    updatePatient() &#123;<br>      console.log(&#x27;start&#x27;)<br>      getCurrent().then((res) =&gt; &#123;<br>        this.personalForm.telephone = res.id<br>        updatePatient(this.personalForm)<br>        this.$notify(&#123;<br>          title: &#x27;提示信息&#x27;,<br>          message: &#x27;更新成功&#x27;,<br>          type: &#x27;success&#x27;<br>        &#125;)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.box-card&#123;<br>  width: 60%;<br>  margin-left: 10%;<br>  margin-top: 5%;<br>&#125;<br>.button&#123;<br>  margin-left: 22%;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="6、过滤重复值"><a href="#6、过滤重复值" class="headerlink" title="6、过滤重复值"></a>6、过滤重复值</h3><p>这个如果在sql语句里写只需要一句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;selectAllInIdle&quot; resultType<span class="hljs-operator">=</span>&quot;java.lang.Integer&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">DISTINCT</span> bed_info.wardId <span class="hljs-keyword">from</span> bed_info <span class="hljs-keyword">where</span> flag<span class="hljs-operator">=</span>&quot;空闲&quot;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>前端也能做：</p><p>1、数组的当前项和下一项比较，如果两者相同，删除其一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">sort</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(arr[i] == arr[i+<span class="hljs-number">1</span>])&#123;<br>        arr.<span class="hljs-title function_">splice</span>(i,<span class="hljs-number">1</span>)<br>        i--<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><p>2、利用对象的key是唯一的进行操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json = &#123;&#125;;<br><span class="hljs-keyword">var</span> newArr = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(!json[arr[i]])&#123;<br>        json[arr[i]] = <span class="hljs-literal">true</span>;<br>        newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr);<br></code></pre></td></tr></table></figure><p>3、利用indexOf操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> newArr = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(newArr.<span class="hljs-title function_">indexOf</span>(arr[i]) == -<span class="hljs-number">1</span>)&#123;<br>        newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr);<br></code></pre></td></tr></table></figure><p>另附：&#x3D;&#x3D;vue处理数组的几种方法&#x3D;&#x3D;</p><p><strong>数组追加</strong></p><p>项目里的写法是：<code>arr = arr.cancat(res[i])</code></p><p>写法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">push</span>(element1[, ...[, elementN]])<br><span class="hljs-keyword">const</span> array = []<br><br>array.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1]</span><br><br>array.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-property">length</span>) <span class="hljs-comment">//=&gt; 3</span><br></code></pre></td></tr></table></figure><p><strong>首端添加</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">unshift</span>(element1[, ...[, elementN]])<br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><br>array.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [3, 4, 5]</span><br><br>array.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p><strong>插入到中间某位置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">splice</span>(start, deleteCount, element1[, ...[, elementN]])<br><span class="hljs-string">`第二个参数是删除若干个元素，设置0为不删除任何元素`</span><br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> ]<br><br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 6, 7]</span><br><br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 4, 5, 6, 7]</span><br></code></pre></td></tr></table></figure><p><strong>删除某位置元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">splice</span>(start, deleteCount, element1[, ...[, elementN]])<br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p><strong>替换数组某元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span><br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><br>array[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [10, 2, 3, 4, 5]</span><br><br><span class="hljs-number">2.</span><br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br>array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array) <span class="hljs-comment">//=&gt; [ 1, 6, 3, 4, 5 ]</span><br><br><span class="hljs-comment">//splice(inde,howmany,item)参数 描述</span><br><span class="hljs-comment">//index   必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</span><br><span class="hljs-comment">//howmany 必需。规定应该删除多少元素。必须是数字，但可以是 &quot;0&quot;。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</span><br><span class="hljs-comment">//item，要添加到数组的新元素</span><br></code></pre></td></tr></table></figure><p><strong>过滤器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">filter</span>(fn)<br><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> ]<br><span class="hljs-keyword">const</span> evenNumbers = array.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNumbers) <span class="hljs-comment">//=&gt; [2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><p><strong>数据转换</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><br><span class="hljs-keyword">const</span> addedArray = array.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + <span class="hljs-number">2</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(addedArray) <span class="hljs-comment">//=&gt; [3,4,5,6,7]</span><br></code></pre></td></tr></table></figure><p><strong>聚合函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><br><span class="hljs-number">1.</span><br>array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">left,right</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> left + right<br>&#125;)<br><br><span class="hljs-string">`针对每次所需要用到的聚合情况做些封装`</span><br><span class="hljs-keyword">const</span> arrayUtils = &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">return</span>  array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">left,right</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> letf + right<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">multi</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">left,right</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> left * right<br>    &#125;)<br>  &#125;<br>&#125; <br><br><span class="hljs-string">`或者更为抽象的方式，涉及一些函数式编程的概念`</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reduceFn</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(fn)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判断两个数组中一个是否完全包含另一个</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">isInclude (aa, bb) &#123;<br>            <span class="hljs-keyword">return</span> aa.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> bb.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">sub</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">return</span> sub === item;<br>                &#125;);<br>            &#125;);<br>        &#125;,<br></code></pre></td></tr></table></figure><p><strong>数组去重，返回新数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">isInclude (aa, bb) &#123;<br>            <span class="hljs-keyword">return</span> aa.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> bb.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">sub</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">return</span> sub === item;<br>                &#125;);<br>            &#125;);<br>        &#125;,<br></code></pre></td></tr></table></figure><h3 id="7、根据身份证号计算年龄sql"><a href="#7、根据身份证号计算年龄sql" class="headerlink" title="7、根据身份证号计算年龄sql"></a>7、根据身份证号计算年龄sql</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,<br>idCard,<br>(<span class="hljs-built_in">substring</span>(now(),<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)<span class="hljs-operator">-</span><span class="hljs-built_in">substring</span>(idCard,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>))<span class="hljs-operator">-</span>(<span class="hljs-built_in">substring</span>(idCard,<span class="hljs-number">11</span>,<span class="hljs-number">4</span>)<span class="hljs-operator">-</span>date_format(now(),<span class="hljs-string">&#x27;%m%d&#x27;</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> age<br><span class="hljs-keyword">from</span> patient_info<br></code></pre></td></tr></table></figure><h3 id="8、给提示信息"><a href="#8、给提示信息" class="headerlink" title="8、给提示信息"></a>8、给提示信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$notify(&#123;<br>                <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;提示信息&#x27;</span>,<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;账号或密码错误&#x27;</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span><br>              &#125;)<br><br><span class="hljs-variable language_">this</span>.$notify(&#123;<br>                <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;提示信息&#x27;</span>,<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;success&#x27;</span><br>              &#125;)<br></code></pre></td></tr></table></figure><h3 id="9、input框的一些属性"><a href="#9、input框的一些属性" class="headerlink" title="9、input框的一些属性"></a>9、input框的一些属性</h3><p>9.1 使用value可设置默认值</p><p>9.2 使用<code>@keyup.enter.native=&quot;search&quot;</code>可以敲回车调用方法</p><p>9.3 你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。<code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p><p>9.4 <code>placeholder=&quot;输入关键字搜索&quot;</code>默认值</p><h3 id="10、前端日期传给后端出现json格式错误"><a href="#10、前端日期传给后端出现json格式错误" class="headerlink" title="10、前端日期传给后端出现json格式错误"></a>10、前端日期传给后端出现json格式错误</h3><p>在实体类里加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xbb.entity;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.format.annotation.DateTimeFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<span class="hljs-comment">//自增主键</span><br>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<span class="hljs-comment">//订单创建时间</span><br>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</span><br>    <span class="hljs-keyword">private</span> Date orderDay;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>大致就想到这些，可能再有就是一些小细节，想说完全不太可能，总的来说还是收获颇丰的。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>springboot</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计</title>
    <link href="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><p><strong>教学内容</strong></p><ul><li><p>NP难问题的近似算法：NP难问题没有多项式时间精确算法，除非P&#x3D;NP，如何在多项式时间内寻找近似最优解。</p></li><li><p>在线算法：输入缺乏先验，随着时间的推移分别在线到达。如何设计算法，使性能和事先拥有全部信息的算法相近。</p></li><li><p>流式算法：解决在严重存储限制下的大型数据集上的问题，例如在高速网络环境中，</p></li><li><p>博弈论算法：输入由许多不同利益不同的参与者控制，</p></li></ul><p><strong>课程目标</strong></p><ul><li><p>巩固利用计算思维求解复杂问题的能力，掌握定量的问题分析、设计和程序实现的方法。</p></li><li><p>掌握基本的算法实现技能，进一步学习掌握算法开发方法。</p></li><li><p>掌握从具体问题出发独立查阅各种途径的资料来分析解决问题的能力。</p></li><li><p>掌握分析和建立计算机领域的问题模型的能力， 提高按照规范编写程序，培养良好的程序设计习惯。</p></li></ul><p><strong>科学范式</strong></p><ul><li>实验归纳：人类早期的科学实践，以记录描述自然现象为主要特征，称为“实验科学”（第一范式） </li><li>模型推演：科学家尝试简化模型，去掉干扰，留下关键因素，通过演算进行归纳总结（第二范式） </li><li>仿真模拟：随着计算机仿真越来越多成熟，可以逐渐取代实验，成为科研的常规方法（第三范式） </li><li>数据密集型科学发现：随着数据的爆炸性增长，计算机将不仅仅能做模拟仿真，还能进行分析总结，得到理论（第四范式）</li></ul><h3 id="1、三柱-x2F-四柱汉诺塔-x2F-动态规划"><a href="#1、三柱-x2F-四柱汉诺塔-x2F-动态规划" class="headerlink" title="1、三柱&#x2F;四柱汉诺塔&#x2F;动态规划"></a>1、三柱&#x2F;四柱汉诺塔&#x2F;动态规划</h3><h4 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h4><p>用递归树可视化递归过程</p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-14_204251.png" alt="2022-04-14_204251"></p><p>分治算法的主定理：$T(n) &#x3D; aT(\frac n b +cn^k)$</p><ul><li>若$a &gt; b^k$，则$T(n)&#x3D;O(n^{log_ba})$</li><li>若$a &#x3D; b^k$，则$T(n) &#x3D; O(n^klog_bn)$</li><li>若$a &lt; b^k$，则$T(n) &#x3D; O(n^k)$</li></ul><h4 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h4><p>1883年由爱德华·卢卡斯提出</p><p>问题描述：由三个木桩和一组n个直径不同的圆盘组成，这些圆盘可以堆叠在木桩上。初始情况是圆盘按大小顺序堆放在一个木桩上，最大的在底部。规则为允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的顶部。目标是以最少的移动次数将所有圆盘转移到另一个目标木桩上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输出移动方式，用num存储移动次数，暴力解</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi3</span>(<span class="hljs-params">n,A,B,C</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    三柱汉诺塔</span><br><span class="hljs-string">    A:初始柱 B:过渡柱 C:目标柱</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;disk[<span class="hljs-subst">&#123;n&#125;</span>]: from <span class="hljs-subst">&#123;A&#125;</span> to <span class="hljs-subst">&#123;C&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        hanoi3(n-<span class="hljs-number">1</span>, A, C, B)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;disk[<span class="hljs-subst">&#123;n&#125;</span>]: from <span class="hljs-subst">&#123;A&#125;</span> to <span class="hljs-subst">&#123;B&#125;</span>&#x27;</span>)<br>        hanoi3(n-<span class="hljs-number">1</span>, B, A, C)<br><br><span class="hljs-comment">#测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-string">&#x27;主程序&#x27;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># num = 0</span><br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        hanoi3(n, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)<br>        <span class="hljs-built_in">print</span>(num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; ---END--- &#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="四柱汉诺塔"><a href="#四柱汉诺塔" class="headerlink" title="四柱汉诺塔"></a>四柱汉诺塔</h4><p>当我们有大于3根柱子的时候，如何移动才能最优？</p><p>Frame-Stewart算法</p><ul><li>使用4根柱子将最上面的k个盘片移到一个临时柱子</li><li>使用剩余的3根柱子将剩余的盘片移到目标柱子</li><li>使用4根柱子将k个盘片从临时柱子移到目标柱子</li></ul><p>优化问题：如何选择最优的k？</p><ul><li>动态规划：存在重叠子问题</li><li>是否存在解析解？</li></ul><h3 id="2、四柱汉诺塔的最优解法-x2F-高楼扔鸡蛋"><a href="#2、四柱汉诺塔的最优解法-x2F-高楼扔鸡蛋" class="headerlink" title="2、四柱汉诺塔的最优解法&#x2F;高楼扔鸡蛋"></a>2、四柱汉诺塔的最优解法&#x2F;高楼扔鸡蛋</h3><h4 id="解四柱汉诺塔"><a href="#解四柱汉诺塔" class="headerlink" title="解四柱汉诺塔"></a>解四柱汉诺塔</h4><p>公式：$M_4(n)&#x3D;2M_4(n-k)+M_3(k)$</p><p>初始条件：$M_4(1)&#x3D;1$ and $M_3(k)&#x3D;2^k-1$</p><blockquote><p>解释：先用四柱的方式将上<code>n-k</code>个盘子放在某过渡柱上，再用三柱的方式将下<code>k</code>个盘子放在目标柱上，再用四柱的方式将过渡柱上的<code>n-k</code>个盘子放在目标柱上</p><p>$M_4(n)$：以四柱的方式放n个盘子最少需要多少次</p><p><code>n</code>：需要放的盘子总数</p><p><code>k</code>：以三柱的方式放多少个盘子</p></blockquote><p>引出问题：<code>k</code>如何取值？</p><p>暴力：对于输入k，遍历k&#x3D;1…n的结果，取遍历出的最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4</span>(<span class="hljs-params">n</span>):<br>    m = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>        tmp = <span class="hljs-number">2</span>*hanoi4(n-i) + math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &lt; m:<br>            m = tmp<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(m)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-string">&#x27;主程序&#x27;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        <span class="hljs-built_in">print</span>(hanoi4(n))<br></code></pre></td></tr></table></figure><p>优化方式：用一个数组来存储计算过的$M_4(n-k)$的值，遍历时优先查表</p><table><thead><tr><th>$n$</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>$M_3$</td><td>1</td><td>3</td><td>7</td><td>15</td><td>31</td><td>63</td><td>127</td><td>255</td><td>511</td><td>1023</td></tr><tr><td>$M_4$</td><td>1</td><td>3</td><td>5</td><td>9</td><td>13</td><td>17</td><td>25</td><td>33</td><td>41</td><td>49</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 带备忘录的解法</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4_memo</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">global</span> memo<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> memo[n] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>): <span class="hljs-keyword">return</span> memo[n]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>        tmp = <span class="hljs-number">2</span>*hanoi4_memo(n-i) + math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &lt; memo[n]:<br>            memo[n] = <span class="hljs-built_in">int</span>(tmp)<br>    <span class="hljs-keyword">return</span> memo[n]<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入盘数：&#x27;</span>))  <span class="hljs-comment"># 盘数</span><br>        memo = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)]*(n+<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(hanoi4_memo(n))<br></code></pre></td></tr></table></figure><p>最优解：</p><p>三角形数：$t_k &#x3D; \frac{k(k+1)}{2}$ 也即<code>1,3,6,10,15,21</code></p><table><thead><tr><th>$k$</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>$t_k$</td><td>1</td><td>3</td><td>6</td><td>10</td><td>15</td><td>21</td><td>28</td></tr></tbody></table><p>令$M(t_k) &#x3D; 2M(t_{k-1}) + 2^k-1$ ，初始条件$M(1)&#x3D;1$</p><blockquote><p>Frame和Stewart证明：</p><p>若$n&#x3D;t_k$，最优选择就是k；</p><p>当$t_{k-1} &lt; n &lt; t_k$时，<code>k-1</code>和<code>k</code>都是最优解。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dp数组的迭代解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi4_dp</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 得到三柱汉诺塔的最少次数列表</span><br>    hanoi3 = [<span class="hljs-number">0</span>]*n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hanoi3[i] = <span class="hljs-built_in">int</span>(math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i)-<span class="hljs-number">1</span>)<br>    dp = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 计算四柱汉诺塔</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 得到使用三柱方法的柱数k</span><br>        k=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i):<br>            <span class="hljs-keyword">if</span> i &lt;= j*(j+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>: <br>                k = j<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 算四柱的dp数组</span><br>        dp[i]=<span class="hljs-number">2</span>*dp[i-k]+hanoi3[k]<br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h4 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h4><p>问题描述：n层楼，k个鸡蛋，算最少的尝试次数，找到鸡蛋恰好摔碎的那层楼（以下都不碎，以上都会碎）</p><p>注：n,k至少为1，最坏情况：鸡蛋破碎一定发生在搜索空间穷尽时</p><p>条件：n层楼、k个鸡蛋</p><p>选择：去哪层楼扔</p><p>条件发生变化：在第i层扔下鸡蛋后</p><p>鸡蛋碎了：<code>k=k-1</code>，搜索区间<code>[1,i-1]</code>共<code>i-1</code>层</p><p>鸡蛋没碎：<code>k</code>不变，搜索区间<code>[i+1,n]</code>共<code>n-i</code>层</p><p>分别遍历两种可能，然后选择次数更多的一个（较差的情况下），加上初始扔的一次，就是初始在i层楼扔下鸡蛋需要的尝试次数。</p><p>用i遍历n，找出初始在每层楼需要的尝试次数，取最小值，即为所求次数。</p><blockquote><p>解题思路：</p><p>1、定义F(n,k)：n层楼，k个鸡蛋时，至少要扔几次鸡蛋</p><p>2、状态转移方程： $F(n,k)&#x3D;min_{1\le i\le n}(max(F(n-i,k),F(i-1,k-1))+1)$</p><p>3、base case： $F(0,x)&#x3D;0,F(x,1)&#x3D;x$</p></blockquote><p>暴力解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># n:楼层数，k:鸡蛋数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eggDrop</span>(<span class="hljs-params">n,k</span>):<br>    res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        tmp = <span class="hljs-built_in">max</span>(eggDrop(n-i,k),eggDrop(i-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>))+<span class="hljs-number">1</span><br>        res = <span class="hljs-built_in">min</span>(res,tmp)<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        n,k=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入楼层数和鸡蛋数，用逗号隔开：&quot;</span>))<br>        <span class="hljs-built_in">print</span>(eggDrop(n,k))<br></code></pre></td></tr></table></figure><p>优化：添加备忘录消除重叠子问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># n:楼层数，k:鸡蛋数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop</span>(<span class="hljs-params">n,k</span>):<br>    memo = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">n,k</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 避免重复计算</span><br>        <span class="hljs-keyword">if</span> (n,k) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(n,k)]<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 穷举所有的可能</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">max</span>(dp(n-i,k),dp(i-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>)<br>        memo[(n,k)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> dp(n,k)<br></code></pre></td></tr></table></figure><p>优化：二分搜索代替线性搜索优化for循环</p><p>思路：<code>dp(n,k)</code>这个函数，当<code>k</code>固定时，是关于<code>n</code>单调递增的（鸡蛋数量固定时，楼层越多，需要的尝试次数越多），于是将<code>dp(n-i,k)</code>和<code>dp(i-1,k-1)</code>看做关于<code>i</code>的函数，所以<code>dp(n-i,k)</code>是关于<code>i</code>单调递减，<code>dp(i-1,k-1)</code>是关于<code>i</code>单调递增。</p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/d2253affeade7b0d8c4128c5e193ab0.jpg" alt="d2253affeade7b0d8c4128c5e193ab0"></p><p>于是，问题便成了求二者的交点，可以用二分查找来寻找这个点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop2</span>(<span class="hljs-params">n,k</span>):<br>    memo = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">n,k</span>):<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">if</span> (n,k) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(n,k)]<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-comment"># 用二分代替线性搜索</span><br>        low, high = <span class="hljs-number">1</span>, n<br>        <span class="hljs-keyword">while</span> low &lt;= high:<br>            mid = (low + high) // <span class="hljs-number">2</span><br>            broken = dp(mid-<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>) <span class="hljs-comment"># 碎</span><br>            non_broken = dp(n-mid,k) <span class="hljs-comment"># 没碎</span><br>            <span class="hljs-comment"># res = min(max(碎，没碎) +1)</span><br>            <span class="hljs-keyword">if</span> broken &gt; non_broken:<br>                high = mid-<span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">min</span>(res,broken+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                low = mid+<span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">min</span>(res, non_broken+<span class="hljs-number">1</span>)<br>        memo[(n,k)] = res<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> dp(n,k)<br></code></pre></td></tr></table></figure><p>优化：重新定义状态转移</p><p>定义：k：鸡蛋数，m：最少扔鸡蛋次数，dp(k,m)：最高楼层数</p><p>鸡蛋碎了：测楼下</p><p>鸡蛋没碎：测楼上</p><p>总的楼层数 &#x3D; 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</p><p>状态转移方程：<code>dp[k][m] = dp[k][m-1] + dp[k-1][m-1] + 1</code></p><p><code>dp[k][m-1]</code>：楼上的楼层数</p><p><code>dp[k-1][m-1]</code>：楼下的楼层数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 重新定义状态转移方程</span><br><span class="hljs-comment"># k:鸡蛋数 m:最少扔鸡蛋次数</span><br><span class="hljs-comment"># 函数返回结果: 最高楼层数</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">superEggDrop3</span>(<span class="hljs-params">k,m</span>):<br>    dp = np.zeros((k+<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> dp[k][m] &lt; m:<br>        n+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>):<br>            dp[i][n] = dp[i][n-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> dp[k][m]<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        k,m=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入鸡蛋数和最少扔鸡蛋次数，用逗号隔开：&quot;</span>))<br>        <span class="hljs-built_in">print</span>(superEggDrop3(k,m))<br>        <br><span class="hljs-comment"># 该方程一个10*9的dp数组如下</span><br>[[   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>    <span class="hljs-number">8</span>    <span class="hljs-number">9</span>   <span class="hljs-number">10</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">6</span>   <span class="hljs-number">10</span>   <span class="hljs-number">15</span>   <span class="hljs-number">21</span>   <span class="hljs-number">28</span>   <span class="hljs-number">36</span>   <span class="hljs-number">45</span>   <span class="hljs-number">55</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">14</span>   <span class="hljs-number">25</span>   <span class="hljs-number">41</span>   <span class="hljs-number">63</span>   <span class="hljs-number">92</span>  <span class="hljs-number">129</span>  <span class="hljs-number">175</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">30</span>   <span class="hljs-number">56</span>   <span class="hljs-number">98</span>  <span class="hljs-number">162</span>  <span class="hljs-number">255</span>  <span class="hljs-number">385</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">62</span>  <span class="hljs-number">119</span>  <span class="hljs-number">218</span>  <span class="hljs-number">381</span>  <span class="hljs-number">637</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">126</span>  <span class="hljs-number">246</span>  <span class="hljs-number">465</span>  <span class="hljs-number">847</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">254</span>  <span class="hljs-number">501</span>  <span class="hljs-number">967</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">255</span>  <span class="hljs-number">510</span> <span class="hljs-number">1012</span>]<br> [   <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">7</span>   <span class="hljs-number">15</span>   <span class="hljs-number">31</span>   <span class="hljs-number">63</span>  <span class="hljs-number">127</span>  <span class="hljs-number">255</span>  <span class="hljs-number">511</span> <span class="hljs-number">1022</span>]]<br></code></pre></td></tr></table></figure><h4 id="思考题：最长上升子序列"><a href="#思考题：最长上升子序列" class="headerlink" title="思考题：最长上升子序列"></a>思考题：最长上升子序列</h4><p>问题描述：给定一个无序的整数数组，找到其中最长的上升子序列（不一定连续）的长度。</p><p>定义dp数组：<code>dp[i]</code>表示以<code>nums[i]</code>这个数结尾的最长递增子序列的长度。</p><p>根据这个定义，最终结果应为dp数组中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">nums</span>):<br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>)<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp)):<br>        res = <span class="hljs-built_in">max</span>(res,dp[i])<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>        nums=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入序列：&quot;</span>)<br>        <span class="hljs-built_in">print</span>(lengthOfLIS(nums))<br></code></pre></td></tr></table></figure><h4 id="思考题：背包问题（组合优化）"><a href="#思考题：背包问题（组合优化）" class="headerlink" title="思考题：背包问题（组合优化）"></a>思考题：背包问题（组合优化）</h4><p>0-1背包</p><h3 id="3、马尔科夫链-x2F-最长上升子序列-x2F-背包问题-x2F-贪婪算法"><a href="#3、马尔科夫链-x2F-最长上升子序列-x2F-背包问题-x2F-贪婪算法" class="headerlink" title="3、马尔科夫链&#x2F;最长上升子序列&#x2F;背包问题&#x2F;贪婪算法"></a>3、马尔科夫链&#x2F;最长上升子序列&#x2F;背包问题&#x2F;贪婪算法</h3><h4 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h4><ul><li>以一维可数集为索引的离散随机变量：$X&#x3D;\left{X_n|n&gt;0\right}$</li><li>随机变量的取值为一个可数集（状态空间）的元素：$X &#x3D; s_i,s_i\in s$</li><li>满足马尔科夫性质：$p(X_{t+1} | X_t,…X_1) &#x3D; p(X_{t+1} | X_t)$</li></ul><h4 id="隐马尔科夫模型（HMM）"><a href="#隐马尔科夫模型（HMM）" class="headerlink" title="隐马尔科夫模型（HMM）"></a>隐马尔科夫模型（HMM）</h4><ul><li>状态不能直接观察，但是可以生成一个可以测量的输出对象</li><li>输出是一个依赖于状态的随机变量</li><li>应用：语音识别、自然语言处理</li><li>关键问题与算法<ul><li>评估问题：前向算法（给观测序列<code>O</code>，）</li><li>解码问题：Viterbi算法</li><li>学习问题：向前向后算法</li></ul></li></ul><p><strong>模型表达：2个状态集合和3个概率矩阵</strong></p><ol><li>隐含状态 $S$</li><li>可观测状态 $O$</li><li>初始状态概率矩阵 $\pi$</li><li>隐含状态转移概率矩阵 $A$</li><li>观测状态转移概率矩阵 $B$</li></ol><p>总结：一般的，可以用 $\lambda &#x3D; (A,B,\pi)$ 三元组来简洁的表示一个隐马尔科夫模型。 隐马尔可夫模型实际上是标准马尔可夫模型的扩展，添加了可观测状态集合和这些状态与隐含状态之间的概率关系。</p><blockquote><p>例：盒子模球实验</p><p>有三个盒子，编号分别为1号、2号和3号，每个盒子里有个数不等的黑球和白球：</p><ul><li>1号：黑球2个，白球8个</li><li>2号：黑球6个，白球4个</li><li>3号：黑球4个，白球6个</li></ul><p>据此可得<strong>观测概率矩阵</strong>：$$B&#x3D;\begin{pmatrix} 0.2 &amp; 0.8 \ 0.6 &amp; 0.4 \ 0.4 &amp; 0.6 \end{pmatrix}$$</p><p>实验过程：</p><p>每次随机出现一个盒子，然后从随机出现的盒子中随机摸一个球，记录下求得颜色，然后把球放回盒子。重复以上。</p><p>试验过程中，我们只能在每次摸出球后看到被摸出的球的颜色（可观测状态），但无法知道每次随机出现的盒子的编号（隐含状态）。</p><p>记录<strong>可观测状态</strong>：$O&#x3D;\left{黑，黑，白，白，白，黑，黑\right}$</p><p>假定第一次个盒子出现的概率分布为：1号0.3，2号0.5，3号0.2</p><p>可得<strong>初始状态概率矩阵：</strong> $\pi &#x3D; (0.3,0.5,0.2)^T$</p><p>提炼<strong>隐含状态转移概率矩阵：</strong> $ A &#x3D; \begin{bmatrix} 0.4 &amp; 0.4 &amp; 0.2 \ 0.3 &amp; 0.2 &amp; 0.5 \ 0.2 &amp; 0.6 &amp; 0.2 \end{bmatrix}$</p><blockquote><p>李姐状态转移矩阵：第一行：随机到1号后，再次随机，1号出现的概率是0.4，2号出现的概率是0.4，3号出现的概率是0.2。以此类推。</p></blockquote><p>参考：<a href="https://www.zhihu.com/question/19633865/answer/1635328825">https://www.zhihu.com/question/19633865/answer/1635328825</a></p></blockquote><p><strong>主要关注：viterbi算法</strong></p><ul><li>最大似然解码：给定观察到的信道输出，找到最有可能的输入。</li><li>广泛应用于通信系统中，用于解码由有限状态过程编码的数据序列</li><li>求解：$maxP(1|0,\theta)$</li></ul><h4 id="动态规划的要素"><a href="#动态规划的要素" class="headerlink" title="动态规划的要素"></a>动态规划的要素</h4><p>状态：需要保留的信息是什么？</p><p>状态转移：信息交换与更新的过程</p><p>权重与损失函数：局部评价指标、最终目标</p><p>优化过程：寻找最优解</p><h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>暴力：共$2^n$个子序列</p><p>老师讲的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS2</span>(<span class="hljs-params">nums</span>):<br>    dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[i] <span class="hljs-keyword">and</span> dp[j] &lt; dp[i]+<span class="hljs-number">1</span>:<br>                dp[j] = dp[i] + <span class="hljs-number">1</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp)):<br>        <span class="hljs-keyword">if</span> dp[i] &gt; res:<br>            res = dp[i]<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="背包问题：组合优化"><a href="#背包问题：组合优化" class="headerlink" title="背包问题：组合优化"></a>背包问题：组合优化</h4><p>问题描述：容量重量有限，求价值最大的方案</p><blockquote><p>Knapsack Problem是NP难问题，没有多项式时间解</p></blockquote><p><strong>0-1背包问题</strong></p><p><strong>问题描述：</strong></p><p>N件物品可放入背包，第i件物品的重量为w[i]，价值为v[i]。要求在总重量不超过上限W的情况下，装入背包的物品价值最大。</p><p>0-1决策：装或者不装</p><p>确定目标函数，指示函数d(i) &#x3D; {0,1}</p><p>$max_d \sum_{i&#x3D;1}^N d(i)V(i)$, subject to $\sum d(i)W(i) \leq W$</p><p>假设W，W(i)离散</p><p>已知条件：装了多少件物品，还可以装多重的东西</p><p>考虑的依据：不超过重量限制时，选择下一件物品使总价值最大</p><p><strong>解题思路：</strong></p><p>构建一个二维表<code>V[i][j]</code>：在重量限制<code>j</code>时，选择了<code>&#123;1,2，...，i&#125;</code>件物品的最大价值</p><p>表的上限<code>V[N][W]</code>：装<code>N</code>件物品，重量<code>W</code></p><p>分析状态转移：第<code>i</code>件物品要么装入背包，要么不装入背包</p><p>装入背包：<code>V[i][j] = V[i-1][j-W[i]] + v[i]</code></p><p>不装入背包：<code>V[i][j] = V[i-1][j]</code></p><p>决策依据：$V[i][j] &#x3D; max(V[i-1][j], V[i-1][j-W[i]] + v[i])$</p><p><strong>背包问题解的优化：</strong></p><p>伪多项式时间<code>O(NW)</code></p><p>进一步分析，不需要显式表示物品序号，可简化为一维表：</p><p><code>i</code>为不同的重量限制，<code>j</code>遍历每个物品</p><p>$V[i] &#x3D; max_j(V[i], V[i-w[j]]+v[j])$，其中，$V[W] &#x3D; 0$</p><blockquote><p><strong>一种解法（二维数组）</strong></p><p>&#x3D;&#x3D;step1：明确【状态】和【选择】&#x3D;&#x3D;</p><p>状态：【背包的容量】、【可选择的物品】</p><p>选择：【装进背包】、【不装进背包】</p><p>套框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">1</span>的所有取值:<br>&gt;<span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">2</span>的所有取值:<br>&gt;<span class="hljs-keyword">for</span> ...<br>dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>,选择<span class="hljs-number">2</span>,...)<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;step2：明确dp数组的定义&#x3D;&#x3D;</p><p>dp数组即描述问题局面的一个数组，上节明确了本题有两个状态，也就是说需要一个二维的dp数组，一维是可选择的物品，一维是背包的容量。</p><p>于是对dp数组定义：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][w]</code>。</p><p>根据这个定义，我们最终想求的答案就是<code>dp[N][W]</code>，base case为<code>dp[0][...] = dp[...][0] = 0</code>，因为没有物品或者背包没有空间时，能装的最大价值就是0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 细化框架</span><br>&gt;dp = np.zeros((N+<span class="hljs-number">1</span>, W+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span><br>&gt;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.N]:<br>&gt;<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.W]:<br>&gt;dp[i][w] = <span class="hljs-built_in">max</span>(<br> 把物品 i 装进背包,<br> 不把物品 i 装进背包<br>&gt;)<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;step3：根据【选择】，思考状态转移的逻辑&#x3D;&#x3D;</p><p>装入背包：<code>dp[i][W] = V[i-1][j-W[i-1]] + v[i-1]</code></p><p>不装入背包：<code>dp[i][W] = V[i-1][w]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 细化代码</span><br>&gt;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.N]:<br>&gt;<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>.W]:<br>&gt;dp[i][w] = <span class="hljs-built_in">max</span>(<br> dp[i-<span class="hljs-number">1</span>][w],<br> dp[i-<span class="hljs-number">1</span>][w - wt[i-<span class="hljs-number">1</span>]] + val[i-<span class="hljs-number">1</span>]<br>&gt;)<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;step4：写成代码，处理边界情况&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack2</span>(<span class="hljs-params">W,N,weight,value</span>):<br>&gt;<span class="hljs-comment"># 初始化全为0</span><br>&gt;dp = np.zeros((N+<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>&gt;<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,N+<span class="hljs-number">1</span>):<br>  <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>      <span class="hljs-keyword">if</span> w &lt; weight[n-<span class="hljs-number">1</span>]:<br>          <span class="hljs-comment"># 装不下</span><br>          dp[n][w] = dp[n-<span class="hljs-number">1</span>][w]<br>      <span class="hljs-keyword">else</span>:<br>          <span class="hljs-comment"># 择优：装/不装</span><br>          dp[n][w] = <span class="hljs-built_in">max</span>(dp[n-<span class="hljs-number">1</span>][w-weight[n-<span class="hljs-number">1</span>]]+value[n-<span class="hljs-number">1</span>],dp[n-<span class="hljs-number">1</span>][w])<br>&gt;<span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure></blockquote><p>优化为一维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># W:背包能承受的重量 N:物品的数量 weight:每个物品的重量 value:每个物品的价值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack3</span>(<span class="hljs-params">W,N,weight,value</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>            <span class="hljs-keyword">if</span> w &gt;= weight[i]:<br>                dp[w] = <span class="hljs-built_in">max</span>(dp[w],dp[w-weight[i]]+value[i])<br>        <span class="hljs-built_in">print</span>(dp)<br>    <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure><blockquote><p>写个小坑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简化为一维数组</span><br><span class="hljs-comment"># W:背包能承受的重量 N:物品的数量 weight:每个物品的重量 value:每个物品的价值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack3</span>(<span class="hljs-params">W,N,weight,value</span>):<br> dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>     <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>         <span class="hljs-keyword">if</span> w &gt;= weight[i]:<br>             dp[w] = <span class="hljs-built_in">max</span>(dp[w],dp[w-weight[i]]+value[i])<br>     <span class="hljs-built_in">print</span>(dp)<br> <span class="hljs-keyword">return</span> dp<br><br> <span class="hljs-comment"># 另一种遍历</span><br> <span class="hljs-comment"># for w in range(1,W+1):</span><br>     <span class="hljs-comment"># for i in range(N):</span><br>     <span class="hljs-comment">#     if w &gt;= weight[i]:</span><br>     <span class="hljs-comment">#         dp[w] = max(dp[w],dp[w-weight[i]]+value[i])</span><br>     <span class="hljs-comment"># print(dp)</span><br><br><span class="hljs-comment"># 输入：10,6,[2,2,3,1,5,2],[2,3,1,5,4,3]</span><br><span class="hljs-comment"># 输出：[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]</span><br></code></pre></td></tr></table></figure><p>这里也是尝试写成一维数组，与上面方法不同的是从正向遍历，导致<code>dp[w-weight[i]]</code>拿到的数据可能包含了第<code>i</code>个物品，导致了重复。尝试了加flag之类的，但似乎正向遍历的方法没法做。</p></blockquote><h5 id="背包问题的变体"><a href="#背包问题的变体" class="headerlink" title="背包问题的变体"></a>背包问题的变体</h5><h6 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h6><p>例：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><p>分割等和子集：给定一个只包含正整数的非空数组，是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>问题转换：</strong></p><p><code>sum</code>为物品总重量，给一个可装载重量为<code>sum/2</code>的背包和<code>N</code>个物品，每个物品重量为<code>weight[i]</code>，是否存在一种装法，能够恰好将背包装满。</p><p>1、明确【状态】和【选择】：</p><p>状态：【背包的容量】、【可选择的物品】</p><p>选择：【装进背包】、【不装进背包】</p><p>2、明确dp数组定义：</p><p><code>dp[i][j]</code>表示对于前<code>i</code>个物品，当前背包的容量为<code>j</code>时，若<code>x</code>为<code>True</code>，则说明可以恰好将背包装满，若<code>x</code>为<code>False</code>，则说明不能恰好将背包装满。</p><p>根据这个定义，我们想求的最终答案即为<code>dp[N][sum/2]</code>。</p><p>base case为<code>dp[...][0] = True</code>和<code>dp[0][...]=False</code></p><blockquote><p>背包没有空间：装满了</p><p>没有物品可选：无法装满</p></blockquote><p>3、根据【选择】，思考状态转移的逻辑</p><p>判断是否可装入：<code>weight[i-1] &lt;= j</code></p><p>装入背包：<code>dp[i][j] = dp[i-1][j-weight[i-1]]</code></p><p>不装入背包：<code>dp[i][j] = dp[i-1][j]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_divide</span>(<span class="hljs-params">weight</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weight: <span class="hljs-built_in">sum</span> += w<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span>%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>)<br>    dp = np.full((<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>),<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>),<span class="hljs-literal">False</span>,dtype=<span class="hljs-built_in">bool</span>)<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 状态转换</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j-weight[i-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 背包容量不足</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 选择装入或不装入</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] | dp[i-<span class="hljs-number">1</span>][j-weight[i-<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(weight)][<span class="hljs-built_in">sum</span>]<br></code></pre></td></tr></table></figure><p>4、优化：状态压缩</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 状态压缩</span><br><span class="hljs-comment"># weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_divide2</span>(<span class="hljs-params">weight</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weight: <span class="hljs-built_in">sum</span> += w<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span>%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>)<br>    dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 状态转换</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">sum</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i]:<br>                dp[j] = dp[j] | dp[j-weight[i]]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">sum</span>]<br></code></pre></td></tr></table></figure><blockquote><p>如上题，<code>j</code>应从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响了其他的结果。</p></blockquote><p>至此，子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。 </p><h6 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h6><p>例：<a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>零钱兑换2：给定不同面额的硬币和一个总金额，写出函数来计算可以凑成总金额的硬币组合数，假设每一种面额的硬币有无限个<strong>。</strong></p><p><strong>问题转换：</strong></p><p>有一个背包，最大容量为<code>W</code>，有一系列物品<code>weight</code>，每个物品的重量为<code>weight[i]</code>，每个物品的数量无限，请问有多少种方法，能够把背包恰好装满。</p><p>1、明确【状态】和【选择】：</p><p>状态：【背包的容量】、【可选择的物品】</p><p>选择：【装进背包】、【不装进背包】</p><p>2、明确<code>dp</code>数组的定义：</p><p>若只使用前<code>i</code>个物品，当背包容量为<code>j</code>时，有<code>dp[i][j]</code>种方法可以装满背包。</p><p>所求的答案即为<code>dp[N][W]</code>，<code>N</code>为<code>weight</code>数组的大小。</p><p>base case：<code>dp[0][...]=0</code>和<code>dp[...][0]=1</code></p><p>3、根据【选择】，思考状态转移的逻辑：</p><p>条件：<code>j &gt;= weight[i-1]</code></p><p>装入背包：<code>dp[i][j-weight[i-1]]</code>&#x3D;&#x3D;(可以重复，所以是<code>i</code>而不是<code>i-1</code>)&#x3D;&#x3D;</p><p>不装入背包：<code>dp[i-1][j]</code></p><p>共有<code>dp[i][j] = dp[i][j-weight[i-1]] + dp[i-1][j]</code>种凑法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完全背包</span><br><span class="hljs-comment"># weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_complete</span>(<span class="hljs-params">W,weight</span>):<br>    dp = np.zeros((<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>),dtype=<span class="hljs-built_in">int</span>)<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j - weight[i-<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(weight)][W]<br></code></pre></td></tr></table></figure><p>4、优化：降低空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 状态压缩</span><br><span class="hljs-comment"># W: 背包承重 weight: 物品重量数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_complete2</span>(<span class="hljs-params">W,weight</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[i]:<br>                dp[j] = dp[j] + dp[j-weight[i]]<br>    <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure><p>时间复杂度<code> O(len(weight)*W)</code>，空间复杂度<code>O(W)</code>。</p><h4 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h4><ul><li>通过做出一系列短视的决策来解决问题</li><li>每个决策本身都能最优地解决某些子问题</li><li>但这些子问题对整个问题来说未必最优</li><li>设计的关键：找到一种合适的方法，把问题分解成几个小的部分，然后把他们组合在一起</li><li>例：作业调度、Dijkstra算法、最小生成树</li></ul><blockquote><p>每一步都做出一个局部最优的选择，最终的结果就是全局最优。</p><p>注：部分问题具有这个性质</p></blockquote><h5 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h5><p>给出多个形如[start,end]的闭区间，算出这些区间中最多有几个互不相交的区间。</p><blockquote><p>例：intvs &#x3D; [[1,3],[2,4],[3,6]]，应返回2，即最多有两个区间互不相交</p></blockquote><p>解题思路：</p><p>1、从区间结合intvs中选择一个区间x，这个x是在当前所有区间中结束最早的（end最小）</p><p>2、把所有与x相交的区间从区间集合intvs中删除</p><p>3、重复步骤1和步骤2，直到intvs为空，之前选出的x就是最大不相交子集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 区间调度</span><br><span class="hljs-comment"># intvs: 区间集合</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">key_function</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">interval_schedule</span>(<span class="hljs-params">intvs</span>):<br>    <span class="hljs-keyword">if</span> intvs == []:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 按end排序</span><br>    intvs.sort(key=key_function)<br>    <span class="hljs-comment"># 至少有一个区间不相交</span><br>    count = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 排序后，第一个区间就是x</span><br>    x_end = intvs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> intv <span class="hljs-keyword">in</span> intvs:<br>        start = intv[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> start &gt;= x_end:<br>            count += <span class="hljs-number">1</span><br>            x_end = intv[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> count<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    intvs = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>    <span class="hljs-built_in">print</span>(interval_schedule(intvs))<br></code></pre></td></tr></table></figure><h5 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h5><p><strong>问题描述：</strong></p><p>给定：n个作业和一台机器，作业<code>i</code>有一个开始时间$s_i$和一个完成时间$f_i \geq s_i$</p><p>目标：以非重叠的方式找到可以在机器上调度的最大作业子集</p><p>对于任意两个计划作业<code>i</code>和<code>j</code>，$f_i \le s_j$ 或 $f_j \le s_i$ （不能同时进行）</p><p>贪婪方法：持续作业调度，确保没有新作业与现有的作业重叠。关键在于调度作业的顺序。</p><p><strong>贪婪策略：</strong></p><p>有几种可能的方法可以做到这一点，每种方法都试图尽量减少每个连续作业可能导致的潜在重叠次数</p><ul><li>最短作业优先</li><li>最早到达优先</li><li>冲突最少优先</li><li>最早完成时间优先</li></ul><p><strong>最早完成时间优先：</strong></p><p>考虑任何不少于<code>k</code>个作业的解决方案<code>S</code>。对<code>k</code>归纳证明，贪婪算法<code>G</code>调度至少<code>k</code>个作业时，前<code>k</code>个作业不晚于所选解中的前<code>k</code>个作业完成。这一结论意味着贪婪算法调度的作业数至少与最优解相同。</p><p>基本情况：<code>k=0</code>，假设归纳假设适用于<code>k-1</code></p><p>令$S_k$为<code>S</code>中的第<code>k</code>个作业，$G_k$是贪婪调度的第<code>k</code>个作业。显然，$s_{S_K} \ge f_{S_K-1} \ge f_{G_{K-1}}$。也就是说，$S_k$在$G_{k-1}$完成之后开始。另外，在贪婪中调度$G_{k-1}$时，$S_k$尚未被考虑。因此贪婪算法可以通过增加作业$S_k$来扩充其调度。因此，它会找到一个候选者来扩充它的解决方案，特别是选择一个不晚于$S_k$的解决方案。</p><p><strong>贪婪算法的特点：</strong>分步骤来构造一个优化问题的解，每一步需满足特定要求。</p><ul><li>可行：不违反约束条件</li><li>局部最优：当前步骤最优的局部解</li><li>不可撤销：一旦做出选择，后续步骤中无法改变（与动态规划的区别，动态规划考虑全局，可以撤销，贪婪考虑局部）</li></ul><h5 id="最佳股票交易时间"><a href="#最佳股票交易时间" class="headerlink" title="最佳股票交易时间"></a>最佳股票交易时间</h5><p>问题描述：整形数组中的元素表示当天股票的价格；根据需要买入卖出，完成尽可能多的交易；不得同时进行多笔交易，必须在再次购买之前卖出股票；设计算法找出最大利润。</p><p><strong>股票买卖问题：</strong></p><p>问题描述：给定一个数组，它的第<code>i</code>个元素时一支给定的股票在第<code>i</code>天的价格，设计一个算法来计算你能获取的最大利益。你最多可以完成<code>k</code>笔交易，且不能同时参与多笔交易。</p><p>示例：</p><blockquote><p>输入：[2,4,1], k&#x3D;2</p><p>输出：2（最大利益）</p><p>输入：[3,2,6,5,0,3], k&#x3D;2</p><p>输出：7（最大利益）</p></blockquote><p>1、明确【状态】和【选择】</p><p>状态：【天数】、【允许交易的最大次数】、【当前的持有状态】(1持有0没有持有)</p><p>选择：【买入】、【卖出】、【无操作】</p><p>尝试穷举：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[i][k][<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>]<br><span class="hljs-number">0</span> &lt;= i &lt;= n-<span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;= k &lt;= K<br><span class="hljs-comment"># n为天数，K为最多交易数</span><br><span class="hljs-comment"># 此问题共n*K*2种状态，可尝试穷举</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,K+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;:<br>            dp[i][k][s] = <span class="hljs-built_in">max</span>(buy,sell,rest)<br><span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>2、状态转移框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># base case:</span><br><span class="hljs-comment"># i=-1(没开始) k=0(不允许交易) 利润为0</span><br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-comment"># i=-1 s=1(没开始时持有股票) k=0 s=1(不允许交易持有股票) 负无穷表不可能</span><br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br><br><span class="hljs-comment"># 状态转移方程：</span><br>dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br></code></pre></td></tr></table></figure><p>3、运用到不同类型的题目</p><ul><li>k&#x3D;1</li></ul><p>此时<code>k</code>均为1，不会改变，<code>k</code>对于状态转移已经没有影响了，可以简化<code>k</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=1的情况</span><br><span class="hljs-comment"># prices: 股票价格列表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit2</span>(<span class="hljs-params">prices</span>):<br>    n = <span class="hljs-built_in">len</span>(prices)<br>    dp = np.zeros((n,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>: <br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br>            dp[i][<span class="hljs-number">1</span>]=-prices[i]<br>            <span class="hljs-keyword">continue</span><br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i])<br>        dp[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],-prices[i])<br>    <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>优化：降低空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 改进：dp数组-&gt;一个变量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit3</span>(<span class="hljs-params">prices</span>):<br>    n = <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-comment"># base case</span><br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+prices[i])<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,-prices[i])<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;正无穷</li></ul><p>此时<code>k=k-1</code>，依然不需要<code>k</code>来记录状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k= 正无穷</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit4</span>(<span class="hljs-params">prices</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        tmp=dp0<br>        dp0=<span class="hljs-built_in">max</span>(dp0,dp1+prices[i])<br>        dp1=<span class="hljs-built_in">max</span>(dp1,tmp-prices[i])<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;正无穷+冷却一天</li></ul><p>每次sell后，要等一天才能交易</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=正无穷+cooldown</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit5</span>(<span class="hljs-params">prices</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1 = <span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    dp_pre0 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> price <span class="hljs-keyword">in</span> prices:<br>        tmp=dp0<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+price)<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,dp_pre0-price)<br>        dp_pre0=tmp<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;正无穷+fee</li></ul><p>把手续费从利润中减去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=正无穷+fee</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit6</span>(<span class="hljs-params">prices,fee</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    dp0,dp1=<span class="hljs-number">0</span>,-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>    <span class="hljs-keyword">for</span> price <span class="hljs-keyword">in</span> prices:<br>        tmp = dp0<br>        dp0 = <span class="hljs-built_in">max</span>(dp0,dp1+price)<br>        dp1 = <span class="hljs-built_in">max</span>(dp1,tmp-price-fee)<br>    <span class="hljs-keyword">return</span> dp0<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;2</li></ul><p>没有消掉<code>k</code>的影响，所以必须对<code>k</code>进行穷举</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit7</span>(<span class="hljs-params">prices</span>):<br>    K=<span class="hljs-number">2</span><br>    n=<span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-comment"># 创建三维表</span><br>    dp = np.zeros((n,K+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>:<br>                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>                dp[i][k][<span class="hljs-number">1</span>] = -prices[i]<br>                <span class="hljs-keyword">continue</span><br>            dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>]+prices[i])<br>            dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><ul><li>k&#x3D;any integer</li></ul><p>K非常大时，可使用k&#x3D;正无穷的解法，减少遍历。</p><p>此外可类似k&#x3D;2的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># k=any integer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit8</span>(<span class="hljs-params">prices,K</span>):<br>    n=<span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> K &gt; n/<span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> profit4(prices)<br>    <span class="hljs-comment"># 创建三维表</span><br>    dp = np.zeros((n,K+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),dtype=<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>==-<span class="hljs-number">1</span>:<br>                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>                dp[i][k][<span class="hljs-number">1</span>] = -prices[i]<br>                <span class="hljs-keyword">continue</span><br>            dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>]+prices[i])<br>            dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(dp[n-<span class="hljs-number">1</span>][K][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>总结：用数组存储所有的状态，从base case开始状态转移，至解。</p><h5 id="圆和弦（卡特兰数）"><a href="#圆和弦（卡特兰数）" class="headerlink" title="圆和弦（卡特兰数）"></a>圆和弦（卡特兰数）</h5><p>问题描述：圆上有<code>2n</code>个点，可以连成<code>n</code>个不相交的弦，不同的连接方式有多少？</p><p>解题思路：</p><p>0、定义函数<code>f(2n)</code>：为所求答案</p><p>1、连接任意两个点，可以用一根弦将整个圆分成两部分，例如对于有<code>2n</code>个点的圆，可以分成<code>2</code>和<code>n-4</code>两部分，于是这个情况有<code>f(2)*f(n-4)</code>种连接方式。</p><p>2、因为划分要做到两边都是偶数，才能保证连接出<code>n</code>个弦不相交，所以从单个点出发，有<code>n/2</code>种划分。</p><p>3、最终答案就是把每种划分的所有连接方式相加。</p><p>实际是算卡特兰数，也即：<code>f(n)=f(0)*f(n-1)+f(1)*f(n-2)+...+f(n-1)*f(0)</code></p><p>例：<code>[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796] </code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 圆和弦</span><br><span class="hljs-comment"># 圆上有2n个点，可以连成n个不相交的弦，不同的连接方式有多少？</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>]=dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            dp[i] += dp[j]*dp[i-j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><blockquote><p>同样是求卡特兰数的问题：</p><ul><li>出栈问题：已知进展顺序<code>abcd</code>，可能的出栈顺序多少种？<code>f(4)=14</code>。</li><li>n个符号分别依次入栈</li><li>归结为已知问题：在n*n的方格中，入栈&#x3D;向上，出栈&#x3D;向右，起点（0,0），终点（n,n）</li><li>满二叉树问题：求个(n+1)个叶子的满二叉树的个数（这里的满二叉树（full binary tree）是指除根节点外的节点要么有2个要么有0个节点）。<code>f(3)=5</code>即4个叶子的满二叉树个数。</li><li>购票问题：电影票每50张元，如果有个人排队买票，其中个n人各持有100元面值的钞票张，另外个m人各持有50元面值的钞票张，而票房没有预备找零．有多少种方法可以将这个人排成一列，顺序购票？<code>m=n时，即为Catalan数</code>。</li><li>凸多边形的剖分：求凸（n+2）边形用其(n-1)条对角线分割为互不重叠的三角形的分法总数。<code>f(4)=14</code>凸6边形用3条对角线的分法总数。</li></ul></blockquote><h6 id="卡特兰计数问题"><a href="#卡特兰计数问题" class="headerlink" title="卡特兰计数问题"></a>卡特兰计数问题</h6><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-21_133416.png" alt="2022-04-21_133416"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 动态规划的解法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan4</span>(<span class="hljs-params">m,n</span>):<br>    dp = np.zeros((m+<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>), dtype=<span class="hljs-built_in">int</span>)<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,j+<span class="hljs-number">1</span>):<br>            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h6 id="二叉树数量"><a href="#二叉树数量" class="headerlink" title="二叉树数量"></a>二叉树数量</h6><ul><li>给定二叉树的中序遍历结果，有多少种二叉树满足这种遍历。</li><li>观察视角：根节点在哪里？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树数量的递归</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan6</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-built_in">sum</span> += Catalan6(i) * Catalan6(n-i-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><h5 id="作业：熟悉掌握Viterbi算法"><a href="#作业：熟悉掌握Viterbi算法" class="headerlink" title="作业：熟悉掌握Viterbi算法"></a>作业：熟悉掌握Viterbi算法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">viterbi_decode</span>(<span class="hljs-params">score, transition</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;解码TensorFlow之外得分最高的标签序列</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">        score: 预测概率矩阵</span><br><span class="hljs-string">        transition: 转移矩阵</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">        viterbi: 最高得分标签的整数列表</span><br><span class="hljs-string">        viterbi_score: viterbi分数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 用于存储累计分数的数组</span><br>    <span class="hljs-comment"># np.zeros_like返回一个新矩阵，其维度与矩阵score一致，并为其初始化为全0；</span><br>    trellis = np.zeros_like(score)<br>    <span class="hljs-comment"># 用于存储最优路径索引的数组</span><br>    backpointers = np.zeros_like(score, dtype=np.int32)<br>    <span class="hljs-comment"># 第一个时刻的累计分数</span><br>    trellis[<span class="hljs-number">0</span>] = score[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># shape: 行，列</span><br>    <span class="hljs-comment"># 循环score的行，从1开始</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, score.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-comment"># 各个状态截止到上个时刻的累计分数 + 转移分数</span><br>        <span class="hljs-comment"># 把trellis的第一行扩展为三行（第一列的数形成第一行），与transision相加</span><br>        v = np.expand_dims(trellis[t - <span class="hljs-number">1</span>], <span class="hljs-number">1</span>) + transition<br>        <span class="hljs-comment"># max（各个状态截止到上个时刻的累计分数 + 转移分数）+ 选择当前状态的分数</span><br>        <span class="hljs-comment"># axis=0 代表行（对每列，选出最大行） , axis=1 代表列</span><br>        trellis[t] = score[t] + np.<span class="hljs-built_in">max</span>(v, <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 记录累计分数最大的索引</span><br>        backpointers[t] = np.argmax(v, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 最优路径的结果</span><br>    <span class="hljs-comment"># trellis数组最后一行最大值的索引以数组的形式返回</span><br>    viterbi = [np.argmax(trellis[-<span class="hljs-number">1</span>])]<br>    <span class="hljs-comment"># 反向遍历每个时刻，得到最优路径</span><br>    <span class="hljs-keyword">for</span> bp <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(backpointers[<span class="hljs-number">1</span>:]):<br>        viterbi.append(bp[viterbi[-<span class="hljs-number">1</span>]])<br>    viterbi.reverse()<br><br>    viterbi_score = np.<span class="hljs-built_in">max</span>(trellis[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> viterbi, viterbi_score<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    score = np.array([[<span class="hljs-number">0.8</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>],[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.4</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.2</span>]])<br>    transition = np.array([[<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>],[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>],[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>]])<br>    <span class="hljs-built_in">print</span>(viterbi_decode(score, transition))<br></code></pre></td></tr></table></figure><h3 id="4、Catalan-x2F-动态时间拉伸-x2F-Dijkstra"><a href="#4、Catalan-x2F-动态时间拉伸-x2F-Dijkstra" class="headerlink" title="4、Catalan&#x2F;动态时间拉伸&#x2F;Dijkstra"></a>4、Catalan&#x2F;动态时间拉伸&#x2F;Dijkstra</h3><h5 id="股票交易时间"><a href="#股票交易时间" class="headerlink" title="股票交易时间"></a>股票交易时间</h5><p>一趟扫描：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># a:股票价格数组</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profit</span>(<span class="hljs-params">a</span>):<br>    tmp = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(a)):<br>        <span class="hljs-keyword">if</span> a[i] &gt; a[i-<span class="hljs-number">1</span>]:<br>            tmp += a[i] - a[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> tmp<br></code></pre></td></tr></table></figure><p>这是老师给的解答，相当于把所有相邻的前小后大全部相加，拿到了全局最优。</p><p>证明不详，但经测试与动态规划解法<code>profit4(prices)</code>能得出一样的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比较测试</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        random_int_list = []<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>            random_int_list.append(random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>))<br>        <span class="hljs-built_in">print</span>(profit(random_int_list))<br>        <span class="hljs-built_in">print</span>(profit4(random_int_list))<br></code></pre></td></tr></table></figure><h5 id="男生（100）女生（50）买票"><a href="#男生（100）女生（50）买票" class="headerlink" title="男生（100）女生（50）买票"></a>男生（100）女生（50）买票</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 半区网路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan3</span>(<span class="hljs-params">i,j</span>):<br>    <span class="hljs-comment"># base case</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == i <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> == j: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> i &lt; j <span class="hljs-keyword">and</span> i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> Catalan3(i-<span class="hljs-number">1</span>, j) + Catalan3(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> i == j: <span class="hljs-keyword">return</span> Catalan3(i-<span class="hljs-number">1</span>, j)<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == i: <span class="hljs-keyword">return</span> Catalan3(i, j-<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;should have not reached here&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="圆和弦"><a href="#圆和弦" class="headerlink" title="圆和弦"></a>圆和弦</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求Catalan递归的写法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Catalan2</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        tmp = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,n,<span class="hljs-number">2</span>):<br>            tmp += Catalan2(i)*Catalan2(n-i-<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> tmp<br></code></pre></td></tr></table></figure><h4 id="动态时间拉伸"><a href="#动态时间拉伸" class="headerlink" title="动态时间拉伸"></a>动态时间拉伸</h4><ul><li><p>多普勒效应：波在波源移向观察者时接收频率变高，而在波源远离观察者时接收频率变低。</p></li><li><p>模板匹配</p></li><li><p>时间序列对准</p></li><li><p>序列相似度度量</p></li></ul><p>两个有限长度的序列$X&#x3D;\left{x_1,\dots,x_m\right}$和$Y&#x3D;\left{y_1,\dots,y_n\right}$</p><p>非负代价函数$d(x_i,y_j)$</p><p>如何发现$X$和$Y$的最佳对应关系？</p><p><strong>动态规划求解：</strong></p><ul><li>转化为从(0,0)到(m,n)的最短路径问题</li><li>已知D(0,0)，求D(m,n)</li><li>递推过程：<code>D(i,j) = d(i,j) + min&#123;D(i,j-1),D(i-1,j-1),D(i-1,j)&#125;</code></li></ul><h5 id="Dijkstra最短路径算法（贪婪算法）"><a href="#Dijkstra最短路径算法（贪婪算法）" class="headerlink" title="Dijkstra最短路径算法（贪婪算法）"></a>Dijkstra最短路径算法（贪婪算法）</h5><ul><li>Dijkstra算法贪婪地探索从<code>s</code>开始的路径，每次移动到下一个最近的节点。这种方式实际构造了从<code>s</code>到图中每个其他节点的最短路径。</li><li>给定：带权图以及特殊节点<code>s</code>和<code>t</code></li><li>目标：找到<code>s</code>和<code>t</code>之间的最短路径</li></ul><p>算法描述：</p><ul><li><p>初始化<code>K=&#123;s&#125;</code>，令<code>Path(s)= ∅ </code>，<code>d(s) = 0</code></p></li><li><p>对不在<code>K</code>中的每一个节点<code>v</code>，计算距离 $d(v) &#x3D; \min_{u \in K}\left{ d(u) + w(u,v) \right}$</p></li><li><p>令$v^*$为$v^* &#x3D; \arg \min_{v \notin K}d(v)$，<code>e=(u,v)</code>为对应边</p></li><li><p>令$K&#x3D;K \cup \left{ v^* \right}$，$Path(v^*) &#x3D; Path(u)\cup\left{e^<em>\right}$，$d(v^</em>) &#x3D; d(u) + w(e^*)$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, start</span>):<br>    vnum = <span class="hljs-built_in">len</span>(graph) <span class="hljs-comment"># 顶点个数</span><br>    paths = &#123;&#125;<br>    cands = [(<span class="hljs-number">0</span>,start,start)]<br>    heapify(cands) <span class="hljs-comment"># 转化为小顶堆，便于找到权重最小的边</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> count &lt; vnum <span class="hljs-keyword">and</span> cands <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plen,u,vmin=heappop(cands) <span class="hljs-comment"># 选出累计路径最短的边</span><br>        <span class="hljs-keyword">if</span> paths.get(vmin) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 如果已经找到到vmin的最短路径就跳过</span><br>            <span class="hljs-keyword">continue</span><br>        paths[vmin] = plen <span class="hljs-comment"># 存入最短路径</span><br>        <span class="hljs-keyword">for</span> next_edge <span class="hljs-keyword">in</span> graph[vmin]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> paths.get(next_edge[<span class="hljs-number">2</span>]):<br>                heappush(cands, (plen+next_edge[<span class="hljs-number">0</span>],u,next_edge[<span class="hljs-number">2</span>]))<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> paths<br>graph = &#123;<span class="hljs-string">&#x27;A&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)], <br>         <span class="hljs-string">&#x27;C&#x27;</span>: [(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)], <br>         <span class="hljs-string">&#x27;B&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)], <br>         <span class="hljs-string">&#x27;E&#x27;</span>: [(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)], <br>         <span class="hljs-string">&#x27;D&#x27;</span>: [(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)], <br>         <span class="hljs-string">&#x27;G&#x27;</span>: [(<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>)], <br>         <span class="hljs-string">&#x27;F&#x27;</span>: [(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>), (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>)]&#125;      <br><span class="hljs-built_in">print</span>(dijkstra(graph, <span class="hljs-string">&#x27;A&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 法二：</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">startwith</span>(<span class="hljs-params">start: <span class="hljs-built_in">int</span>, mgraph: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>    passed = [start]<br>    nopass = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(mgraph)) <span class="hljs-keyword">if</span> x != start]<br>    dis = mgraph[start]<br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(nopass):<br>        idx = nopass[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nopass:<br>            <span class="hljs-keyword">if</span> dis[i] &lt; dis[idx]: idx = i<br><br>        nopass.remove(idx)<br>        passed.append(idx)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nopass:<br>            <span class="hljs-keyword">if</span> dis[idx] + mgraph[idx][i] &lt; dis[i]: <br>                dis[i] = dis[idx] + mgraph[idx][i]<br>    <span class="hljs-keyword">return</span> dis<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    inf = <span class="hljs-number">10086</span><br>    mgraph = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, inf, inf, inf],<br>              [inf, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, inf, inf],<br>              [inf, inf, <span class="hljs-number">0</span>, inf, <span class="hljs-number">5</span>, inf],<br>              [inf, inf, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>],<br>              [inf, inf, inf ,inf, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>],<br>              [inf, inf, inf, inf ,inf, <span class="hljs-number">0</span>]]<br><br>    <span class="hljs-built_in">print</span>(startwith(<span class="hljs-number">0</span>, mgraph))<br></code></pre></td></tr></table></figure><p><strong>Dijkstra算法的最优性：</strong></p><p>通过对$K$的大小的归纳来证明这个结论。</p><p>$|K| &#x3D; 1$的基本情况是平凡的：在这种情况下$K$只包含$s$和路径$Path(s) &#x3D; \varnothing$。</p><p>假设结论一直保持到步骤$k-1$仍然成立，并考虑第$k$步把点$v$添加到集合$K$，且$e&#x3D;(u,v)$为对应边。</p><p>为了造成矛盾，假设路径$Path(v)$并非$s$到$v$的最短路径，而$Path^*(v)$为相应的最短路径。设$x$为$Path^*(v)$上集合$K$中最后一个结点，$x’$是$Path^*(v)$上紧随$x$之后的结点。</p><p>由定义可知$d(x)+w(x,x’)$不超过为$Path^*(v)$的长度。</p><p>但是，通过构造，&#x3D;&#x3D;$d(u) + w(u,v) \leq d(x) + w(x,x’)$（不是很理解）&#x3D;&#x3D;，且$d(v) &#x3D; d(u) + w(u,v)$，意味着$d(v)$不超过$Path^*(v)$的长度。</p><p>于是导出矛盾。</p><h5 id="作业：kruskal算法、prime算法"><a href="#作业：kruskal算法、prime算法" class="headerlink" title="作业：kruskal算法、prime算法"></a>作业：kruskal算法、prime算法</h5><h3 id="5、Catalan计数-x2F-最小生成树问题"><a href="#5、Catalan计数-x2F-最小生成树问题" class="headerlink" title="5、Catalan计数&#x2F;最小生成树问题"></a>5、Catalan计数&#x2F;最小生成树问题</h3><p>Catalan计数见前文</p><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li>$G&#x3D;(V,E)$是一个无向连通图，代价函数<code>w</code>将边映射为正实数</li><li>生成树是一颗连接<code>G</code>的所有顶点的无向树</li><li>生成树的代价等于树中所有边的代价之和</li><li>最小生成树的代价为<code>G</code>的所有可能生成树的最小代价的一颗生成树</li><li>一个图可以有许多具有代价的<code>MST</code></li><li>构建<code>MST</code>的两个主要算法：<code>Kruskal</code>和<code>Prim</code>，都是贪婪算法</li></ul><p><strong>安全边</strong></p><ul><li>图的割：对结点集合<code>V</code>的一个划分</li><li>穿过割的边：一条边的两个端点分别在割的两边</li><li>轻边：穿过割的边中权重最小的一条边</li><li>结论：假设$A\subset E$，且包含在一些<code>MST</code>中，如果$(s,v_s)$ 是一个关于$A$的割，$(u,v)$是一条穿过割$(s,v_s)$的轻边，则$(u,v)$对$A$来说是安全的。</li></ul><p>贪婪算法：独特</p><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><ul><li>集合<code>A</code>初始时只包括孤立的结点</li><li>对<code>E</code>的边按权重大小升序排序</li><li>顺序考虑边：如果这条边连接两个不同部分，则添加该边</li><li>无向图$G&#x3D;(V,E)$的<code>MST</code>可以在时间复杂度$O(|V|log|V| + |E|log|E|)$完成</li></ul><h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5><ul><li>Prim算法与Dijkstra算法的单源最短路径算法非常像，具有相同的复杂度</li><li>在算法的任何阶段，集合<code>A</code>都会形成一棵树，而不是像Kruskal那样由连接的组件组成的森林</li><li>每个阶段中，都会向树添加一条轻边，将<code>A</code>连接到$V_A$中的顶点</li><li>用边的权重组成一个优先队列负责查找轻边</li></ul><h4 id="P和NP"><a href="#P和NP" class="headerlink" title="P和NP"></a>P和NP</h4><ul><li>在分析算法的复杂性时，可以把问题转化为一个决策问题：答案为是&#x2F;否的可计算问题</li><li>例如，把在一种语言中生成字符串的问题转化为验证给定字符串在一种语言中的成员身份的问题</li><li>P指的是一类语言，它的隶属度问题可以用输入字符串大小的时间多项式来确定</li><li>对于某些语言，则没有多项式时间的成员算法。但是，我们可以用另一个“见证”字符串在多项式时间内验证该字符串是否使用这一语言</li><li>NP是一类语言，给定一个多项式长度的见证字符串，其成员资格可以在多项式时间内进行验证</li></ul><p><strong>P-时间可约性</strong></p><ul><li>可约性的概念允许我们在多项式时间内将一个问题转化为另一个问题</li><li>如果我们能解决后者，那么我们也能解决前者的问题；相反，如果前者是NP难问题，后者也是NP难问题</li><li>在讨论决策问题时，如果存在一个多项式时间算法，该算法将问题A的一个实例作为输入，并输出一个保证与问题A的实例具有相同结果的问题B的实例，这种归约成为Cook归约</li><li>就是说，如果问题B存在一个有效算法，那么问题A可以通过将其实例转换为问题B的实例，并对其应用有效算法来解决</li></ul><p><strong>P&#x3D;NP?</strong></p><ul><li>P和NP是否相等是计算机科学中最突出、最重要的开放性问题之一。考虑这个问题的有效工具：一个问题对于一个类来说是完全的概念</li><li>可以说，NP中最难的问题称为NP-Hard，是NP中的每一个问题都可以被多项式时间归约到的问题</li><li>因此，任何一个问题的多项式时间算法都意味着NP中的每一个问题都可以在多项式时间内求解，即$NP \subseteq P$</li><li>我们已经知道$P \subseteq NP$，因为每个P算法都可以被看作是一个NP算法</li><li>P&#x3D;NP if 存在一个决定任何一个NP完全问题的多项式时间算法</li></ul><p><strong>SAT问题</strong></p><ul><li>第一个被证明是NP完全的问题是Boolean-SAT：给定一个布尔表达式，是否有一组变量可以使整个表达式的值为真？显然，存在一些不可满足的布尔表达式</li><li>可满足性：给定共轭范式的布尔表达式，寻找变量的值使该表达式为TRUE</li><li>Cook和Levin独立地证明了SAT的NP完全性，称为Cook-Levin定理。Cook-Levin定理证明了SAT是NP完全的，证明了对于NP中的任何问题SAT都存在一个约简</li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_103017.png" alt="2022-04-30_103017"></p><p><strong>顶点覆盖问题</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_103309.png" alt="2022-04-30_103309"></p><p>问题描述：给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</p><p><strong>SAT问题定义</strong></p><p>布尔可满足性：给定一个CNF（共轭范式）中的布尔公式$\phi$，该公式可以满足吗？换句话说，我们给出了一个带有n个变量的$x_1,x_2,\dots,x_n$的布尔公式$\phi &#x3D; C_1\wedge C_2\wedge \dots \wedge C_k$，其中每个$C_i$是一个形式为$(l_{i1} \vee l_{i2} \vee \dots \vee l_{il})$的子句，每个$l_{ij}$是从集合$\left{ x_1,x_2,\dots,x_n;\overline{x_1},\overline{x_2},\dots,\overline{x_n} \right}$里抽取的文字。我们需要决定是否存在一些变量的设置使得$\phi$得到满足</p><p><strong>2-CNF和3-CNF</strong></p><ul><li>重要性：NP-完全问题是一类任何NP问题可以以多项式时间转化的问题。任一NP完全问题可以多项式时间求解，则所有NP-完全问题都变成了P问题</li><li>2-CNF：子句包含1或2个变量的满足性决策问题</li><li>3-CNF：子句可以包含3个变量</li><li>2-CNF是P问题，而3-CNF属于NPC</li></ul><p><strong>SAT的NP完全性质</strong></p><p>要证明SAT问题是NP完全的，只需证明NP中的任何问题都可以在多项式时间内归约为SAT问题</p><ul><li>首先把问题限制为决策问题：把原始问题转化为一个成员问题，即给定的输入是否属于某种语言。那么，P表示可以在多项式时间内确定成员隶属的语言类，而NP代表存在一个可以在多项式时间内验证其成员隶属的语言类。</li><li>其次，需要将一个问题规约为另一个问题。问题A可以规约到问题B，则如果得到B的一个解，可以多项式时间内调用这个解还原性为A的解。</li></ul><p>Cook-Levin定理表名，对于NP中的任何问题，都存在到SAT的一种规约，从而证明SAT是NP完全的</p><p><strong>Cook-Levin定理</strong></p><blockquote><p>SAT is NP-complete</p></blockquote><p>假设L是一个NP问题，根据定义，则L具有一个多项式时间的验证算法V：</p><ul><li>If $x\in L$，$\exist$见证者y，V(x,y) &#x3D; 1</li><li>If $x \notin L$，$\exist$见证者y，V(x,y) &#x3D; 0</li></ul><p>可以为V构造一个多项式大小的电路，由AND、OR、NOT组成。改电路包含|x|+|y|个输入，其中|x|对应x的每一位的值，|y|代表可变变量</p><p><strong>Cook-Levin定理证明思路</strong></p><p>要求解问题L，只需要找到输入中的|y|个变量中的一种设置使电路的输出为1。这样就把问题L归结为决定电路是否能输出1的问题。接下来证明满足电路的问题可被归为SAT的一个实例。电路中的每一个门可以表示称一个3CNF（三元CNF，每个子句金包含三项）</p><p>例如：</p><ul><li><p>或门OR是一个输入a和b以及输出$Z_i$的函数，表示为$(a \vee b \vee \bar Z_i) \wedge (Z_i \vee \bar a) \wedge (Z_i \vee \bar b) $</p><blockquote><p>a,b&#x3D;true&#x2F;false</p></blockquote></li><li><p>非门NOT是一个输入a且输出$Z_i$的函数，表示为$(a \vee \bar Z_i) \wedge (\bar a \vee Z_i)$</p><blockquote><p>a&#x3D;true&#x2F;false</p></blockquote></li></ul><p>即使有些子句只包含少于3项，可以通过填充独立文字来构造3CNF。独立文字的值不影响从句的布尔量。</p><p><strong>Cook-Levin定理证明</strong></p><p>假设V中共有q个门，记为$Z_i,Z_2,\dots,Z_q$，其中$Z_q$是V的最后输出。</p><p>这些门要么直接使用输入，要么使用中间结果$Z_i$为输入。</p><p>因此，整个电路可以表示为CNF形式的公式：$\phi &#x3D; C_1\wedge C_2\wedge \dots \wedge C_q \wedge Z_q$，其中每个$C_i&#x3D;(t_i \vee t_2 \vee t_3)$，$t_1,t_2,t_3 \in \left{ x,y,Z_1,Z_2,\dots,Z_q,\bar Z_1,\bar Z_2,\dots,\bar Z_q \right}$。</p><p>如前所述，即使最后一个子句只含一项$Z_q$，也可等价转换为3-CNF。因此，该电路被归结为$\phi$，3-CNF形式的公式。</p><p>$\phi$被满足当且仅当原电路输出1。</p><p>所以，$L \le_p SAT$，SAT是NP完全问题</p><h4 id="接雨水（贪婪）"><a href="#接雨水（贪婪）" class="headerlink" title="接雨水（贪婪）"></a>接雨水（贪婪）</h4><p>问题描述：给定一个长度为n的整形数组，元素均大于0，以其中任意两个作为隔板，且位置不变，如何使容纳水的容积最大？</p><p>解题思路：选择短板算容量并淘汰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">water</span>(<span class="hljs-params">a</span>):<br>    n = <span class="hljs-built_in">len</span>(a)<br>    i,j = <span class="hljs-number">0</span>,n-<span class="hljs-number">1</span><br>    m = tmp = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; j:<br>        <span class="hljs-keyword">if</span> a[i] &lt; a[j]:<br>            tmp = a[i]*(j-i+<span class="hljs-number">1</span>)<br>            i+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            tmp = a[j]*(j-i-<span class="hljs-number">1</span>)<br>            j-=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> tmp &gt; m:<br>            m = tmp<br>    <span class="hljs-keyword">return</span> m<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a = [<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>    <span class="hljs-built_in">print</span>(water(a))<br></code></pre></td></tr></table></figure><h3 id="6、P和NP-x2F-接雨水-x2F-网络流算法-x2F-排队"><a href="#6、P和NP-x2F-接雨水-x2F-网络流算法-x2F-排队" class="headerlink" title="6、P和NP&#x2F;接雨水&#x2F;网络流算法&#x2F;排队"></a>6、P和NP&#x2F;接雨水&#x2F;网络流算法&#x2F;排队</h3><h4 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h4><p><strong>求解与验证</strong></p><ul><li>求解问题看起来比验证答案要难（更加耗时）</li><li>例如：数独，给定初始位置，一般情况下求解数独比验证填好的数字是否满足数独的规则要更加困难</li><li>但是，如果需要验证的解的数量非常大，即使单个答案可以很快验证，总体上也要花费很长时间</li><li>NP是nondetermintstic polynomial time的缩写，指在非确定性图灵机上可以以多项式时间精确求解的问题</li><li>有些问题似乎相似，实际分属P和NP：欧拉旅行问题（访问所有边），汉密尔顿环（一次性访问所有节点）</li></ul><p><strong>CNF</strong></p><p><strong>2-CNF和3-CNF</strong></p><p><strong>Cook-Levin定理</strong></p><h4 id="网络流算法"><a href="#网络流算法" class="headerlink" title="网络流算法"></a>网络流算法</h4><ul><li>假设有一个管道网络，每个管道都有一定的横截面，网络有一个入口和一个出口</li><li>目标是将水通过管道从入口以尽可能大的速率输送到出口</li><li>两个主要限制：通过管道的速度不能超过管道的横截面（容量约束）；在管网的任何连接处，流入的水量必须正好等于流出的水量（流量守恒约束）</li><li>最大流问题要求在给定的有容量图中找到一个最大可能的可行流</li></ul><p><strong>假设</strong></p><ul><li>图G不包含自循环（不含形为(u,u)的边）</li><li>图G不包含多重边，如果$e_1$，$e_2$是从u到v的两条边，容量分别是$c_1$，$c_2$，则可以用一条边容量为$c_1+c_2$的边e表示</li><li>图G有方向性。如果图包含一条无向边(u,v)，可以用两条有向边u-&gt;v和v-&gt;u来代替，每条边的容量都等于c(u,v)</li></ul><p><strong>贪婪算法</strong></p><p>重复下列操作直至所有s~t路径都达到饱和</p><ul><li>寻找带有剩余容量的s~t路径</li><li>让该路径达到饱和</li><li>重复直到没有这种路径存在</li></ul><p>贪婪算法无法保证最优解：单一步骤具有不可撤销的特点</p><p><strong>Ford-Fulkerson算法</strong></p><ul><li>算法的总体思想类似贪婪算法：在每一步通过图选择一条s~t路径，并对其进行饱和</li><li>在剩余图中找到路径，该图明确允许沿先前使用的边反向流动</li><li>给定一个可行流$f$，剩余图$G_f&#x3D;(V_f,E_f)$，容量函数$c_f$按下列方式定义：<ul><li>$V_f&#x3D;V$</li><li>$E_f&#x3D;\left{(u,v)|u,v \in V \wedge (c(u,v) &gt; f(u,v))\right} \cup \left{ (u,v) | u,v \in V \wedge (f(v,u) &gt; 0) \right}$ </li><li>$c_f(u,v)&#x3D;c(u,v)-f(u,v)+f(v,u)$</li></ul></li></ul><p><strong>网络流与割集</strong></p><ul><li>s-t割集是一组边C，使得图$G’&#x3D;(V,E \backslash C)$不包含s~t路径。割集的容量为$cap(C)&#x3D;\sum _{e\in C}c(e)$</li><li>记F为所有可行的流的集合，则对于任意s~t割集C，$cap(C) \ge \max _{f\in F}|f|$</li><li>设$C^*$为G的最小s~t割集，$f^*$是G的最大s-t流，则$cap(C^*) \ge |f^*|$</li></ul><p><strong>主要结论</strong></p><ul><li>如果容量是整数值，Ford-Fulkerson算法可以发现最大流</li><li>最大流量的大小等于最小割集的容量</li><li>算法的运行时间：迭代中的每一步最多需要$O(m)$时间，其中m是边的数目，因为在每次迭代中，流的大小至少增加1，迭代次数的一个简单上界是F，最大流的大小。这是一个$O(mF)$的界。运行时间是一个伪多项式时间。</li></ul><h4 id="排队问题"><a href="#排队问题" class="headerlink" title="排队问题"></a>排队问题</h4><p>问题描述：假设有打乱顺序的一群人站成一个队列，数组people表示队列中一些人的属性（不一定按顺序）。每个$people[i] &#x3D; [h_i,k_i]$表示第$i$个人的身高为$h_i$，前面正好有$k_i$个身高大于或等于$h_i$的人。请重新构造并返回数组people所表示的队列。返回的队列应该格式化为数组queue，其中$queue[j] &#x3D; [h_j,k_j]$是队列中第$j$个人的属性（queue[0]是排在队列前面的人）</p><blockquote><p>示例：输入：people&#x3D;[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</p><p>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></blockquote><h4 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h4><p>随机算法</p><p>在线算法</p><p>经典分治算法应用FFT</p><h3 id="7、排队-x2F-np-x2F-顶点覆盖问题-x2F-二部图匹配（线性规划）"><a href="#7、排队-x2F-np-x2F-顶点覆盖问题-x2F-二部图匹配（线性规划）" class="headerlink" title="7、排队&#x2F;np&#x2F;顶点覆盖问题&#x2F;二部图匹配（线性规划）"></a>7、排队&#x2F;np&#x2F;顶点覆盖问题&#x2F;二部图匹配（线性规划）</h3><h4 id="顶点覆盖问题"><a href="#顶点覆盖问题" class="headerlink" title="顶点覆盖问题"></a>顶点覆盖问题</h4><p><strong>顶点覆盖问题的NP完全性</strong></p><ul><li>Vertex Covering Problem属于NP问题</li><li>任何一个NP完全问题可以规约为顶点覆盖问题</li></ul><p><strong>顶点覆盖问题属于NP</strong></p><ul><li>设计一个多项式时间的验证算法，检验：<ul><li>给定的顶点集合是原图顶点的一个子集</li><li>该顶点集合覆盖了所有的边</li></ul></li><li>上述步骤都可以在多项式时间完成。如果每一步回答都是YES，则返回YES，否则返回NO</li></ul><p><strong>SAT规约为顶点覆盖问题</strong></p><ul><li><p>给定一个3-CNF：</p><p>$\phi &#x3D; (x_1 \vee x_1 \vee x_2) \wedge (\bar x_1 \vee \bar x_2 \vee \bar x_2) \wedge (\bar x_1 \vee x_2 \vee x_2)$</p></li><li><p>设计一个顶点覆盖问题与之等价</p></li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_112712.png" alt="2022-04-30_112712"></p><h4 id="二部图匹配"><a href="#二部图匹配" class="headerlink" title="二部图匹配"></a>二部图匹配</h4><p><strong>问题描述</strong></p><ul><li>二部图G&#x3D;(V,E)是顶点集V可分为两个不相交的子集X和Y的图，使得每个边$e \in E$有一个端点在X中，另一个端点在Y中</li><li>一个匹配$M \subseteq E$是边的子集，使得V中的每个节点最多出现在M中的一条边上</li><li>Maximal Matching(极大匹配)是指在不将一个节点的度增加到2的情况下，不能再添加任何边的匹配，是一个局部最大值</li><li>Maximum Matching(最大匹配)是具有尽可能多的匹配，它是全局最优的</li></ul><p><strong>二部图与最大流</strong></p><ul><li>目标：在图中找到最大匹配</li><li>可以容易地找到最大匹配：只需在匹配中添加边，直到无法添加更多的边为止</li><li>可以证明，对于任何极大匹配(maximal matching) $M$，$|M| \ge \frac 1 2|M^*|$，其中$M^*$是最大匹配(maximum matching)</li><li>最大匹配问题可以归结为最大流问题</li></ul><p><strong>二部图匹配与最大流</strong></p><ul><li>在$G&#x3D;(V,E)$基础上构造$G’ &#x3D; (V’,E’)$，其中$V’$除$V$中的节点外还包含源s和汇t，$E’$除E中的边外还包含s到X和Y到t的边</li><li>所有边具有单位容量</li><li>对于大小为k的流，X中的点最多带有一条带流量的出边，Y中3的点最多有一条带流量的入边，X到Y有流量的边的个数是k</li><li>解决最大流问题就解决了最大匹配，时间复杂度$O((m+n)n)$</li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-04-30_115228.png" alt="2022-04-30_115228"></p><p><strong>完全匹配</strong></p><ul><li><p>完全匹配是指每个节点上正好有一条边的匹配</p></li><li><p>确定给定二部图是否具有完全匹配的一种方法可以先找到最大匹配，再检查匹配的大小是否等于每个部分中的节点数</p></li><li><p>另一种方法利用了霍尔定理</p><blockquote><p>二部图G(V,E)具有完全匹配当且仅当对每个子集$S \sube X$或$S \sube Y$，S的邻域的大小至少和S一样大，即$|\gamma (S)| \ge |S|$</p></blockquote></li></ul><p><strong>调度问题</strong></p><ul><li>假设$J&#x3D;\left{J_1,J_2,\dots,J_n\right}$是一组作业，$T&#x3D;\left{ T_1,T_2,\dots,T_k \right}$为可执行这些作业的机器上的可用时隙</li><li>每个作业$J$都有一组有效的时隙$S_j \in T$，可以对其进行调度；限制条件是不能同时调度两个作业</li><li>问题是如何找到可以调度的最大作业集</li><li>这一问题可以归结为二部匹配：对于每个作业，在$X$中创建一个节点，对于每个时隙，在$Y$中创建一个节点；对于$S_j$中的每个时隙，在$X$和$Y$之间创建一条边。二部图的最大匹配就是可以调度的最大作业集</li></ul><p><strong>调度问题举例</strong></p><ul><li>某家医院有n名医生，每个医生都有一组休假日。有k个假期段供选择，每个假期段连续跨越几天。设$D_j$为第$j$个假期中包含的天数</li><li>在限制条件下，需要最大限度地将医生分配到天，每天一名医生</li><li>限制：每个医生都有一个容量$c_i$，是可以安排的最大总天数，每个假期段，任何一个医生最多安排一次</li></ul><p><strong>转化为最大流问题</strong></p><ul><li>为每个医生$i$创建一个节点$u_i$，为每个休假日$j$创建一个节点$v_j$；从起始节点s添加一条边到$u_i$，从$v_j$加入一条边到汇点$t$</li><li>医生的容量表示为从$s$到$u_i$的边的容量</li><li>从节点$v_j$到$t$的边的容量都设置为1，表示每个假期选择一个医生</li><li>为了防止医生在休假期间被安排多次，引入中间节点：对于任何医生$i$和假期$j$，创建一个中间节点$w_{ij}$并创建一个从$u_i$到$w_{ij}$的单位容量的边。对于休假期间医生有空的每一天，创建一条从$w_{ij}$到该天节点的单位容量边</li></ul><p><strong>加入中间节点</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-04_102711.png" alt="2022-05-04_102711"></p><p><strong>线性规划</strong></p><ul><li>把最大流可以归结为线性规划问题</li><li>首先考虑最大流问题的一个例子，$G&#x3D;(V,E)$，边$e \in E$的容量为$c_e$</li><li>设变量$f_e$为边$e$上的流量，下面的线性规划可用于最大流问题</li></ul><p>$ max \sum_{v:(s,v) \in E} $ </p><p>subject to $\sum_{u:(u,v) \in E}f(u,v) &#x3D; \sum_{u:(v,u) \in E}f(v,u) $ $\forall v \in V,v \ne s,$ </p><p>$0 \le f_e &lt; c_e $ ，$\forall e \in E$</p><p><strong>线性规划形式</strong></p><p>$min \sum_i c_ix_i$</p><p>subject to $\sum_i A_{ij}x_i \ge b_j$  $\forall j$</p><p>$ x_i \ge 0$  $\forall i$ </p><p><strong>线性规划举例</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/90cf3102072a47d92eec4727d52285b.jpg" alt="90cf3102072a47d92eec4727d52285b"></p><h3 id="8、线性代数解法-x2F-随机化算法-x2F-knuth-shuffle-x2F-扩展计数范围-x2F-负载均衡问题-x2F-球和桶-x2F-遗传算法"><a href="#8、线性代数解法-x2F-随机化算法-x2F-knuth-shuffle-x2F-扩展计数范围-x2F-负载均衡问题-x2F-球和桶-x2F-遗传算法" class="headerlink" title="8、线性代数解法&#x2F;随机化算法&#x2F;knuth shuffle&#x2F;扩展计数范围&#x2F;负载均衡问题&#x2F;球和桶&#x2F;遗传算法"></a>8、线性代数解法&#x2F;随机化算法&#x2F;knuth shuffle&#x2F;扩展计数范围&#x2F;负载均衡问题&#x2F;球和桶&#x2F;遗传算法</h3><h4 id="线性代数解法练习"><a href="#线性代数解法练习" class="headerlink" title="线性代数解法练习"></a>线性代数解法练习</h4><p><img src="https://raw.githubusercontent.com/Yoonalis/img/master/2022-05-04_135935.png" alt="2022-05-04_135935"></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/09ec96aa4d19bf976ce665f5b08067d.jpg" alt="09ec96aa4d19bf976ce665f5b08067d"></p><h4 id="随机化算法（拉斯维加斯和蒙特卡洛）"><a href="#随机化算法（拉斯维加斯和蒙特卡洛）" class="headerlink" title="随机化算法（拉斯维加斯和蒙特卡洛）"></a>随机化算法（拉斯维加斯和蒙特卡洛）</h4><ul><li><p>随机化算法是一种类似于可以投掷硬币并根据投掷结果采取不同行动的算法，将讨论两种随机算法：</p></li><li><p>Las Vegas：随机化算法总是能给出正确答案，但在某些情况下可能花费更长的时间。它们的“预期”运行时间是输入大小的多项式，意味着所有可能投币的平均运行时间是多项式。</p><ul><li><p>在最坏的情况下，拉斯维加斯算法可能需要指数级的时间。</p></li><li><p>拉斯维加斯算法的一个例子是快速排序：它根据投币量做出一些决策，总是产生正确的结果，其预期运行时间和最坏情况下的运行时间分别是$nlogn$和$n^2$</p></li></ul></li><li><p>Monte Carlo算法：这些是指有时会得出一个错误的答案的随机算法。</p><ul><li>像拉斯维加斯算法一样，它们的预期运行时间是多项式的，但在最坏情况下可能是指数的。</li><li>通常可以通过多次运行Monte Carlo算法，将得到正确答案的概率“提升”到我们喜欢的最小值。</li><li>例如，如果一个特定的蒙特卡洛算法产生一个概率为$\frac 1 4$的错误结果，并且我们有能力洁厕到一个错误的结果，那么在t次独立运行之后，没有得到正确答案的概率是$(\frac 1 4)^t$。</li><li>在某些优化问题中，我们没有能力检测错误的答案，但可以比较不同的答案，并选择最好的一个。</li></ul></li></ul><blockquote><p>拉斯维加斯算法：采样越多，越有机会找到最优解（试钥匙）</p><p>蒙特卡罗算法：采样越多，越近似最优解（挑最大的苹果）</p></blockquote><p><strong>随机化的优势</strong></p><p>随机算法相比确定型算法具有几个有点：</p><ul><li>简单性。对于相同的任务，随机算法往往比确定型算法简单。例如，快速排序枢纽元的选择。</li><li>效率。对于某些问题，随机算法比确定型算法具有更好的渐近运行时间：对某些问题，确定型算法是以指数时间运行的，而随机算法是已知多项式时间的。</li><li>当算法面临信息不足时，随机化是非常有用的。</li></ul><h4 id="Karger随机化算法"><a href="#Karger随机化算法" class="headerlink" title="Karger随机化算法"></a>Karger随机化算法</h4><h4 id="knuth-shuffle"><a href="#knuth-shuffle" class="headerlink" title="knuth shuffle"></a>knuth shuffle</h4><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">a,n</span>):<br>    tmp = a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &gt;= n: <span class="hljs-keyword">return</span> a<br>    i = random.randint(<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>)<br>    a[<span class="hljs-number">0</span>] = a[i]<br>    a[i] = tmp<br>    shuffle(a[<span class="hljs-number">1</span>:],n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>    n = <span class="hljs-built_in">len</span>(a)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(shuffle(a,n))<br></code></pre></td></tr></table></figure><blockquote><p>可能因为依赖的<code>random.randint()</code>这个函数，感觉在短时间内的随机性不是很好</p></blockquote><h4 id="扩展计数范围"><a href="#扩展计数范围" class="headerlink" title="扩展计数范围"></a>扩展计数范围</h4><p>问题描述：给一个能在1-7中取随机的<code>rand7()</code>，设计一个能在1-10中取随机的<code>rand10()</code>，要求取到每个数的概率相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand7</span>():<br>    <span class="hljs-keyword">return</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand10</span>():<br>    x=-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> x == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> x &gt; <span class="hljs-number">40</span>:<br>        x = (rand7() - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span> + rand7()<br>    x = x%<span class="hljs-number">10</span>+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(rand10())<br></code></pre></td></tr></table></figure><h4 id="负载均衡问题"><a href="#负载均衡问题" class="headerlink" title="负载均衡问题"></a>负载均衡问题</h4><ul><li>在多个资源之间分配任务</li><li>例如，Nginx一种支持反向代理的开源Web服务器，可以用于高性能的负载均衡</li><li>在网络服务器之间合理分配请求，使每个服务器的工作量基本相同</li><li>简单的方法就是把任务以均匀分布方式分发给服务器</li></ul><p><strong>Nginx负载均衡方法</strong></p><ul><li>Round-Robin：对应用服务器的请求按照轮转方式分配</li><li>最少连接数：将下一条请求分配给活跃连接数最少的服务器</li><li>IP-hash：基于客户端的IP地址，使用哈希函数来决定为下一条请求分配哪一个服务器</li></ul><h4 id="球和桶"><a href="#球和桶" class="headerlink" title="球和桶"></a>球和桶</h4><ul><li>考虑把m个球扔进n个桶的过程</li><li>每一个球都以$\frac 1 n$的概率进入不同的桶，独立于其他的球</li><li>碰撞：两个球扔进同一个桶</li></ul><p><strong>基本结论</strong></p><ul><li><p>两球碰撞的概率是多少？</p></li><li><p>使用贝叶斯定理，再计算边际概率</p></li><li><p>把球i进入桶j的事件记作$B_i^j$</p><p>$Pr[Col_{12}] &#x3D; \sum^2_{i&#x3D;1}Pr[B^i_2|B^i_1]Pr[B^i_1] &#x3D; \sum^n_{i&#x3D;1} \frac 1 n Pr[B^i_1] &#x3D; \frac 1 n$</p></li><li><p>m个球进入n个桶相撞次数的期望值是：$\sum_{i \ne j}Pr[Col_{ij}]&#x3D;\frac 1 n C^2_m$</p></li><li><p>一个桶为空的概率是多少？一个球不落入桶i的概率是$1-\frac 1 n$，因此桶始终为空的概率是$(1-\frac 1 n)^n \to \frac 1 e$</p></li><li><p>空桶个数的期望值是多少？$\frac n e$</p></li><li><p>一个桶内恰好有k个球的概率是多少？$C_n^k(\frac 1 n)^k(1-\frac 1 n)^{n-k} \le \frac {n^k} {k!} \frac 1 {n^k} &#x3D; \frac 1 {k!}$</p></li><li><p>一个桶内至少有k个球的概率是多少？$\le C^k_n(\frac 1 n)^k \le (\frac e k)^k$</p></li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-06_152213.png" alt="2022-05-06_152213"></p><h4 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h4><p><strong>介绍</strong></p><ul><li>遗传算法是一种优化算法，用来寻找最大化或最小化的一个特定的函数的最优解</li><li>遗传算法是一个演化计算研究领域的一个分支，模拟繁殖和自然选择的生物过程来求解问题</li><li>与进化论一样，遗传算法的许多过程都是随机的，但允许人们设置随机水平和控制水平，比随机搜索和穷举搜索算法更强大和有效</li><li>优势在于不需要关于给定问题的额外信息，找到其他优化方法由于缺乏连续性、导数、线性或其他特性而无法处理的问题的解</li></ul><p><strong>算法的构成</strong></p><p>模拟生物过程设计，相关术语多从生物学中借用，但比其生物对应物要简单。具体包含如下组成部分：</p><ul><li>一个用于优化的适应度函数</li><li>一个染色体群体</li><li>选择哪些染色体将繁殖的方式</li><li>产生下一代染色体的交叉方式</li><li>新一代染色体中的随机变异</li></ul><p><strong>适应度函数</strong></p><ul><li>适应度函数是指算法力图优化的指标函数</li><li>适应度一词源自进化论，用适应度函数测试并量化每个潜在解决方案的适合程度</li><li>设计适应度函数是算法中最关键的部分之一</li><li>从随机选择的染色体初始群体开始，遗传算法用适应度函数对群体中的每一条染色体进行评估，检验它们解决问题的好坏</li></ul><h3 id="9、演化算法-x2F-模拟退火算法"><a href="#9、演化算法-x2F-模拟退火算法" class="headerlink" title="9、演化算法&#x2F;模拟退火算法"></a>9、演化算法&#x2F;模拟退火算法</h3><h4 id="遗传算法-1"><a href="#遗传算法-1" class="headerlink" title="遗传算法"></a>遗传算法</h4><p><strong>适应度函数</strong></p><ul><li>适应度函数是指算法力图优化的指标函数</li><li>适应度一词源自进化论，用适应度函数测试并量化每个潜在解决方案的适合程度</li><li>设计适应度函数是算法中最关键的部分之一</li><li>从随机选择的染色体初始群体开始，遗传算法用适应度函数对群体中的每一条染色体将进行评估，检验它们解决问题的好坏</li></ul><p><strong>染色体</strong></p><ul><li>染色体是指代表遗传算法候选解决方案一个或多个数值</li><li>每个候选解都被编码为一组参数值，如果问题具有维度n，则通常每个染色体编码为n元数组：$chromosome&#x3D;[p_1,p_2,…,p_n]$，其中每个$p_i$是第i个参数的取值</li><li>将候选解的样本空间转化为染色体是遗传算法的关键，例如二进制可将每个参数值转换为一个0&#x2F;1字符串以创建染色体</li></ul><p><strong>选择算子</strong></p><ul><li>选择算子根据用户定义的概率分布选择一些染色体进行复制</li><li>染色体fitness越高，被选中的可能性就越大。例如，如果f是一个非负适应度函数，那么选择$C_{25}$染色体进行繁殖的概率可以设成$Pr(C_{25} &#x3D; \frac {f(C_{25})} {\sum_i^n f(C_i)} )$</li><li>选择算子以带替换的方式选择染色体，因此同一染色体可以多次选择</li></ul><p><strong>Roullete</strong></p><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-06_200508.png" alt="2022-05-06_200508"></p><p><strong>交叉算子与变异算子</strong></p><ul><li>交叉算子类似于细胞减数分裂中染色体的生物交叉和重组</li><li>该操作符交换两条所选染色体的子序列来产生两个后代。例如，如果父代染色体为[11010111001000],[01011101010010]，在第四位之后交换，则子代染色体为[01010111001000],[11011101010010]</li><li>变异算子随机翻转新染色体中的单个位(将0变为1，反之亦然)，通常把变异发生的概率设为很低，如0.001</li></ul><p><strong>遗传算法的步骤</strong></p><ul><li>随机产生初始种群</li><li>选择其中一组进行交配，繁殖下一代，使用交叉算子</li><li>使用变异算子</li><li>得到子代后，重新评估适应度函数，接收则停止，否则返回第二步</li></ul><p><strong>单变量函数的优化</strong></p><p><strong>代际更替</strong></p><p><strong>连续值遗传算法</strong></p><p><strong>遗传算法的问题</strong></p><ul><li>如果算法需要搜索连续值，则需要把染色体转换为实数值数组</li><li>算法的解受到浮点数精度的制约</li><li>连续值遗传算法可以比二进制遗传算法更快，因为在计算适应度值时无需预先解码</li><li>例如，适应度函数为$f(x) &#x3D; 2xsin(x)+ysin(2y)$，$chromosone&#x3D;[x,y]$，$0 \le x \le 10,0 \le y \le 10$</li><li>可以提升变异概率，保留部分上一代的个体进入下一代。需要设计新的选择概率形式和交叉算子</li></ul><p><strong>遗传算法应用</strong></p><ul><li><p>背包问题：选择物品，在满足重量约束下使价值最高</p></li><li><p>染色体编码：二进制编码，位数与物品数量一致，1代表放入，0表示不放</p></li><li><p>适应度函数：不超出重量限制时取价值之和，否则设为-1</p></li><li><p>选择概率：$Pr(x_i) &#x3D; \frac {e^{f(x_i)}} {\sum ^n_j e^{f(x_j)}}$</p></li></ul><p><strong>遗传算法问题</strong></p><ul><li>每一代种群相当于一组可行解</li><li>按照概率分布探索解空间的不同区域</li><li>优点：较少的迭代次数，较低的计算强度，可以设计不同的适应度函数求解复杂的优化问题</li><li>困难：收敛过快，易于陷入局部最优；交叉和变异可能导致进入不可行的区域</li></ul><h5 id="遗传算法实现"><a href="#遗传算法实现" class="headerlink" title="遗传算法实现"></a>遗传算法实现</h5><p>种群初始化：通过随机生成的方式来创造一个种群，采用二进制将一个染色体编码为基因型，随后用进制转化，将二进制的基因型转化为十进制的表现型。</p><p>适应度计算（种群评估）：将目标函数值作为个体的适应度。</p><p>选择（复制）操作：根据种群中个体的适应度大小，通过轮盘赌等方式将适应度高的个体从当前种群中选择出来。其中轮盘赌即是与适应度成正比的概率来确定各个个体遗传到下一代群体中的数量。具体步骤如下：</p><ul><li>首先计算所有个体的适应度总和$\sum f_i$</li><li>其次计算出每个个体的相对适应度大小$\frac {f_i} {\sum_{f_i}}$</li><li>再产生一个0到1之间的随机数，依据随机数出现在上述哪个概率区域来确定各个个体被选中的次数</li></ul><p>交叉（交配）运算：该步骤是遗传算法中产生新的个体的主要操作过程，它用一定的交配概率阈值(pc，一般是0.4到0.99)来控制是否采取单点交叉，多点交叉等方式生成新的交叉个体。具体步骤如下：</p><ul><li>先对群体随机配对</li><li>再随机设定交叉点的位置</li><li>再互换配对染色体间的部分基因</li></ul><p>变异运算：该步骤是产生新的个体的另一种操作。一般先随机产生变异点，再根据变异概率阈值(pm，一般是0.0001到0.1)将变异点原有基因取反</p><p>终止判断：如果满足条件（迭代次数，一般是200~500）则终止算法，否则返回适应度计算</p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> cm<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br><br><span class="hljs-comment"># sample:计算F(x,y)在[-3,3]和[-3,3]里的最大值</span><br><br><span class="hljs-comment"># 初始化</span><br>DNA_SIZE = <span class="hljs-number">24</span><br>POP_SIZE = <span class="hljs-number">200</span><br>CROSSOVER_RATE = <span class="hljs-number">0.8</span><br>MUTATION_RATE = <span class="hljs-number">0.005</span><br>N_GENERATIONS = <span class="hljs-number">50</span><br>X_BOUND = [-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>Y_BOUND = [-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>*(<span class="hljs-number">1</span>-x)**<span class="hljs-number">2</span>*np.exp(-(x**<span class="hljs-number">2</span>)-(y+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span>)-<span class="hljs-number">10</span>*(x/<span class="hljs-number">5</span>- x**<span class="hljs-number">3</span> - y**<span class="hljs-number">5</span>)*np.exp(-x**<span class="hljs-number">2</span>-y**<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>/<span class="hljs-number">3</span>**np.exp(-(x+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> - y**<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 适应度函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_fitness</span>(<span class="hljs-params">pop</span>):<br>    x,y = translateDNA(pop)<br>    pred = F(x,y)<br>    <span class="hljs-keyword">return</span> (pred - np.<span class="hljs-built_in">min</span>(pred)) + <span class="hljs-number">1e-3</span><br><br><span class="hljs-comment"># 解码函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">translateDNA</span>(<span class="hljs-params">pop</span>):<br>    x_pop = pop[:,<span class="hljs-number">1</span>::<span class="hljs-number">2</span>] <span class="hljs-comment"># 奇数列</span><br>    y_pop = pop[:,::<span class="hljs-number">2</span>] <span class="hljs-comment"># 偶数列</span><br>    x = x_pop.dot(<span class="hljs-number">2</span>**np.arange(DNA_SIZE)[::-<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(<span class="hljs-number">2</span>**DNA_SIZE-<span class="hljs-number">1</span>)*(X_BOUND[<span class="hljs-number">1</span>]-X_BOUND[<span class="hljs-number">0</span>])+X_BOUND[<span class="hljs-number">0</span>]<br>    y = y_pop.dot(<span class="hljs-number">2</span>**np.arange(DNA_SIZE)[::-<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(<span class="hljs-number">2</span>**DNA_SIZE-<span class="hljs-number">1</span>)*(Y_BOUND[<span class="hljs-number">1</span>]-Y_BOUND[<span class="hljs-number">0</span>])+Y_BOUND[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> x,y<br><br><span class="hljs-comment"># 交叉变异</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crossover_and_mutation</span>(<span class="hljs-params">pop,CROSSOVER_RATE = <span class="hljs-number">0.8</span></span>):<br>    new_pop = []<br>    <span class="hljs-keyword">for</span> father <span class="hljs-keyword">in</span> pop:<br>        child = father<br>        <span class="hljs-keyword">if</span> np.random.rand() &lt; CROSSOVER_RATE:<br>            mother = pop[np.random.randint(POP_SIZE)]<br>            cross_points = np.random.randint(low=<span class="hljs-number">1</span>,high=DNA_SIZE*<span class="hljs-number">2</span>)<br>            child[cross_points:] = mother[cross_points:]<br>        mutation(child)<br>        new_pop.append(child)<br>    <span class="hljs-keyword">return</span> new_pop<br><br><span class="hljs-comment"># 变异</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mutation</span>(<span class="hljs-params">child,MUTATION_RATE=<span class="hljs-number">0.001</span></span>):<br>    <span class="hljs-keyword">if</span> np.random.rand() &lt; MUTATION_RATE:<br>        mutate_point = np.random.randint(<span class="hljs-number">0</span>,DNA_SIZE*<span class="hljs-number">2</span>)<br>        child[mutate_point] = child[mutate_point]^<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 选择</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">pop, fitness</span>):<br>    idx = np.random.choice(np.arange(POP_SIZE),size=POP_SIZE,replace=<span class="hljs-literal">True</span>,p=(fitness)/(fitness.<span class="hljs-built_in">sum</span>()))<br>    <span class="hljs-keyword">return</span> pop[idx]<br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_info</span>(<span class="hljs-params">pop</span>):<br>    fitness = get_fitness(pop)<br>    max_fitness_index = np.argmax(fitness)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;max_fitness:&quot;</span>,fitness[max_fitness_index])<br>    x,y = translateDNA(pop)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最优的基因型：&quot;</span>,pop[max_fitness_index])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(x,y):&quot;</span>,(x[max_fitness_index],y[max_fitness_index]))<br><br><span class="hljs-comment"># 可视化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_3d</span>(<span class="hljs-params">ax</span>):<br><br>    X = np.linspace(*X_BOUND, <span class="hljs-number">100</span>)<br>    Y = np.linspace(*Y_BOUND, <span class="hljs-number">100</span>)<br>    X,Y = np.meshgrid(X,Y)<br>    Z = F(X,Y)<br>    ax.plot_surface(X,Y,Z,rstride=<span class="hljs-number">1</span>,cstride=<span class="hljs-number">1</span>,cmap=cm.coolwarm)<br>    ax.set_zlim(-<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>    ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    ax.set_zlabel(<span class="hljs-string">&#x27;z&#x27;</span>)<br>    plt.pause(<span class="hljs-number">3</span>)<br>    plt.show()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GAs</span>():<br><br>    fig = plt.figure()<br>    ax = Axes3D(fig)<br>    plt.ion()<br>    plot_3d(ax)<br><br>    <span class="hljs-comment"># 随机产生初始种群</span><br>    pop = np.random.randint(<span class="hljs-number">2</span>,size=(POP_SIZE,DNA_SIZE*<span class="hljs-number">2</span>))<br><br>    <span class="hljs-comment"># 迭代N代</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N_GENERATIONS):<br>        x,y = translateDNA(pop)<br><br>        <span class="hljs-comment"># 可视化</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sca&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">locals</span>():<br>            sca.remove()<br>        sca = ax.scatter(x,y,F(x,y),c=<span class="hljs-string">&#x27;black&#x27;</span>,marker=<span class="hljs-string">&#x27;o&#x27;</span>);plt.show();plt.pause(<span class="hljs-number">0.1</span>)<br><br>        pop = np.array(crossover_and_mutation(pop,CROSSOVER_RATE))<br>        fitness = get_fitness(pop)<br>        pop = select(pop,fitness)<br><br>    print_info(pop)<br>    plt.ioff()<br>    plot_3d(ax)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    GAs()<br></code></pre></td></tr></table></figure><h4 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h4><ul><li>模拟退火算法采用Monte Carlo方法，模仿金属退火时的加热-冷却过程来求解最大规模组合优化问题</li><li>与遗传算法相似，采用随机方式探索解空间，可用于非连续、不可微、非凸问题</li><li>与遗传算法不同，模拟退火在理论上具有可以保证的收敛性</li><li>遗传算法种群中的每一个点具有独立性，可以并行执行；模拟退火算法从单点出发，在存在很多局部最优解的情况下可以跳出局部寻找全局最优</li></ul><p> <strong>退火</strong></p><ul><li><p>固体材料加热到超过熔点，然后冷却回固体状态</p></li><li><p>最终的结构取决于冷却的方式</p><ul><li>缓慢冷却–大晶体（能量低）</li><li>快速冷却–缺陷（能量高）</li></ul></li><li><p>Metropolis算法模拟系统在冷却过程中能量变化，系统会最终收敛到某种能量的“冻结”状态</p></li><li><p>根据热力学：在温度T时，能量增加$\delta E$的概率为：$P(\triangle E) &#x3D; e^{-\frac {\delta E} {kT}}$</p></li></ul><p><strong>模拟退火算法实施</strong></p><ul><li>与一般的爬山法相似，区别在于不是接受最佳移动，而是接受一个随机移动</li><li>如果移动改进了结果，则接受；否则算法以一个小于1的概率采取这种移动（Metropolis判据）</li><li>接受概率与移动使解变坏的程度$\triangle E$有关，与其指数成反比：$Pr(\text{accepting uphill move}) \sim 1-e^{\frac {\triangle E} {kT}}$</li><li>参数T表示退火时的温度，T越大，接受的概率越大；k实质是Boltzmann常数。选择参数T逐步下降，$T(k+1)&#x3D;\alpha T(k), \alpha &lt; 1$</li></ul><p><strong>退火过程</strong></p><ul><li>凝聚态物理中，固体液化时在加热后需要冷却，使粒子在低能量状态下重新组织为晶格形式</li><li>在寻优过程中，允许偶发的上升，逃脱局部最优的陷阱</li></ul><p><img src="/blog/2022/09/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2022-05-07_163131.png" alt="2022-05-07_163131"></p><p><strong>模拟退火过程</strong></p><ul><li>设置初始温度</li><li>重复下列步骤<ol><li>按预定次数执行<ul><li>生成一个扰动</li><li>如果能量下降，接受新的状态；否则以$P(\triangle E)$接受新的概率状态</li><li>降低温度</li></ul></li><li>直到冻结</li></ol></li></ul><p><strong>分析</strong></p><ul><li>在高温下，接受更差步骤的概率更改。如果$T&#x3D;\infin$，所有动作均可接受，对应于随机局部行走</li><li>在低温下，接受更差步骤的概率降低。如果$T&#x3D;0$，不接受更差的移动，搜索等同于局部搜索</li><li>接受解的质量大幅度退化的概率呈指数下降，趋近于0</li><li>温度必须足够高才允许移动到几乎所有邻近状态</li></ul><p><strong>分析</strong></p><ul><li>平稳分布（玻尔兹曼）：$P(x) ∝ e^{\frac {E(x)} T}$</li><li>如果T下降的足够慢，就会收敛到最优状态</li><li>考虑两个相邻状态x,y，$E(y) &lt; E(x)$</li><li>假设x→y和y→x且出度D(x)&#x3D;D(y)&#x3D;D</li><li>设P(x),P(y)为T点的均衡占有概率，P(x→y)是状态x跃迁到状态y的概率</li><li>为了避开局部最优，需要的爬坡步数越多，越不可能连续爬坡</li><li>“足够慢”也许意味着指数级的慢</li></ul><h5 id="模拟退火实现"><a href="#模拟退火实现" class="headerlink" title="模拟退火实现"></a>模拟退火实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.animation <span class="hljs-keyword">as</span> animation<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br><br><span class="hljs-comment"># sample: 求解一元函数y=x+10sin(5x)+7cos(4x)的最大值</span><br><br><span class="hljs-comment"># 判断函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Judge</span>(<span class="hljs-params">deltaE,T</span>):<br>    <span class="hljs-keyword">if</span> deltaE &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># probability会变大</span><br>        probability = math.exp(deltaE/T)<br>        <span class="hljs-comment"># random.random() 用于生成一个0到1的随机浮点数</span><br>        <span class="hljs-keyword">if</span> probability &gt; random.random():<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 为当前解添加随机扰动</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Disturbance</span>(<span class="hljs-params">low,high,x_old</span>):<br>    <span class="hljs-keyword">if</span> random.random() &gt; <span class="hljs-number">0.5</span>:<br>        x_new = x_old + (high-x_old)*random.random()<br>    <span class="hljs-keyword">else</span>:<br>        x_new = x_old - (x_old-low)*random.random()<br>    <span class="hljs-keyword">return</span> x_new<br><br><span class="hljs-comment"># 优化目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Func</span>(<span class="hljs-params">x</span>):<br>    y = x+<span class="hljs-number">10</span>*math.sin(<span class="hljs-number">5</span>*x)+<span class="hljs-number">7</span>*math.cos(<span class="hljs-number">4</span>*x)<br>    <span class="hljs-keyword">return</span> y<br><br><span class="hljs-comment"># 退火过程</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SA</span>(<span class="hljs-params">low,high,T,T_min,alpha,counter</span>):<br>    c = <span class="hljs-number">0</span><br>    x_old = low+(high-low)*random.random()<br>    x_new = x_old<br>    value_old = Func(x_old)<br>    value_new = Func(x_new)<br>    record_x = []<br>    record_y = []<br>    <span class="hljs-keyword">while</span> T &gt; T_min <span class="hljs-keyword">and</span> c &lt; counter:<br>        x_new = Disturbance(low, high, x_old)<br>        value_new = Func(x_new)<br>        deltaE = value_new - value_old<br>        <span class="hljs-comment"># 求最大值：deltaE&gt;0更优 deltaE&lt;0更劣 </span><br>        <span class="hljs-keyword">if</span> Judge(deltaE,T) == <span class="hljs-number">1</span>:<br>            value_old = value_new<br>            record_x.append(x_new)<br>            record_y.append(value_new)<br>            x_old = x_new<br>        <span class="hljs-keyword">if</span> deltaE &gt; <span class="hljs-number">0</span>:<br>            T = T*alpha<br>        <span class="hljs-keyword">else</span>:<br>            counter += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 可视化</span><br>    <span class="hljs-comment"># 第一个图：显示x,y各自的取值</span><br>    length = <span class="hljs-built_in">len</span>(record_x)<br>    index = [i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length)]<br>    plt.plot(index,record_y)<br>    plt.plot(index,record_x)<br>    <br>    <span class="hljs-comment"># 第二个图：显示x,y曲线</span><br>    x = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10000</span>)<br>    y = x+<span class="hljs-number">10</span>*np.sin(<span class="hljs-number">5</span>*x)+<span class="hljs-number">7</span>*np.cos(<span class="hljs-number">4</span>*x)<br>    plt.plot(x,y)<br><br>    <span class="hljs-comment"># 绘制动画</span><br>    fig, ax = plt.subplots()<br>    l = ax.plot(x,y)<br>    dot, = ax.plot([],[],<span class="hljs-string">&#x27;ro&#x27;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>        ax.set_xlim(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>        ax.set_ylim(-<span class="hljs-number">16</span>,<span class="hljs-number">25</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_dot</span>():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> index:<br>            newdot = [record_x[i-<span class="hljs-number">1</span>],record_y[i-<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">yield</span> newdot<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_dot</span>(<span class="hljs-params">newd</span>):<br>        dot.set_data(newd[<span class="hljs-number">0</span>],newd[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dot,<br><br>    ani = animation.FuncAnimation(<br>        fig, update_dot, frames = gen_dot, repeat = <span class="hljs-literal">False</span>, <br>        interval = <span class="hljs-number">10</span>, init_func = init)<br><br>    plt.show()<br><br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    SA(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1e5</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">0.98</span>,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p><strong>练习</strong></p><ul><li>函数形式：$f(x)&#x3D;x^3-60x^2+900x+100$</li><li>编码x：5位二进制整数</li><li>邻域：随机反转某一位的值</li><li>初始值：$x_0&#x3D;0x10101,T_0&#x3D;800$</li><li>冷却方案：$T_k&#x3D;0.9T_{k-1}$</li></ul><h3 id="10、分治算法回顾-x2F-矩阵运算-x2F-流算法-x2F-在线算法"><a href="#10、分治算法回顾-x2F-矩阵运算-x2F-流算法-x2F-在线算法" class="headerlink" title="10、分治算法回顾&#x2F;矩阵运算&#x2F;流算法&#x2F;在线算法"></a>10、分治算法回顾&#x2F;矩阵运算&#x2F;流算法&#x2F;在线算法</h3><h4 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h4><p>8min PPT：问题的定义、算法、分析、实现及举例</p><p> 时间空间复杂度 不足及改进的思路</p><p>周六实验课演示</p><p>可选主题：寻找最近邻点问题、寻找凸包问题、最长公共子序列问题、最优二叉搜索树、人员分配问题、旅行商问题(TSP)、A*算法、素数检验问题、子集和问题近似求解、顶点覆盖问题</p><h4 id="分治算法回顾"><a href="#分治算法回顾" class="headerlink" title="分治算法回顾"></a>分治算法回顾</h4><p>矩阵运算</p><h5 id="Strassen算法"><a href="#Strassen算法" class="headerlink" title="Strassen算法"></a>Strassen算法</h5><h4 id="流算法"><a href="#流算法" class="headerlink" title="流算法"></a>流算法</h4><h3 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h3><h3 id="12、实验课（pre）"><a href="#12、实验课（pre）" class="headerlink" title="12、实验课（pre）"></a>12、实验课（pre）</h3><h4 id="x3D-x3D-寻找最近邻点问题-x3D-x3D"><a href="#x3D-x3D-寻找最近邻点问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;寻找最近邻点问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;寻找最近邻点问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-寻找凸包问题-x3D-x3D"><a href="#x3D-x3D-寻找凸包问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;寻找凸包问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;寻找凸包问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-最长公共子序列问题-x3D-x3D"><a href="#x3D-x3D-最长公共子序列问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;最长公共子序列问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;最长公共子序列问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-最优二叉搜索树-x3D-x3D"><a href="#x3D-x3D-最优二叉搜索树-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;"></a>&#x3D;&#x3D;最优二叉搜索树&#x3D;&#x3D;</h4><h4 id="x3D-x3D-人员分配问题-x3D-x3D"><a href="#x3D-x3D-人员分配问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;人员分配问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;人员分配问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-旅行商问题（TSP）-x3D-x3D"><a href="#x3D-x3D-旅行商问题（TSP）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;旅行商问题（TSP）&#x3D;&#x3D;"></a>&#x3D;&#x3D;旅行商问题（TSP）&#x3D;&#x3D;</h4><h4 id="x3D-x3D-A-算法-x3D-x3D"><a href="#x3D-x3D-A-算法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;A*算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;A*算法&#x3D;&#x3D;</h4><h4 id="x3D-x3D-素数检验问题-x3D-x3D"><a href="#x3D-x3D-素数检验问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;素数检验问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;素数检验问题&#x3D;&#x3D;</h4><h4 id="x3D-x3D-子集和问题近似求解-x3D-x3D"><a href="#x3D-x3D-子集和问题近似求解-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;子集和问题近似求解&#x3D;&#x3D;"></a>&#x3D;&#x3D;子集和问题近似求解&#x3D;&#x3D;</h4><h4 id="x3D-x3D-顶点覆盖问题-x3D-x3D"><a href="#x3D-x3D-顶点覆盖问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;"></a>&#x3D;&#x3D;顶点覆盖问题&#x3D;&#x3D;</h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>随机化算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react</title>
    <link href="/blog/2022/08/12/react/"/>
    <url>/blog/2022/08/12/react/</url>
    
    <content type="html"><![CDATA[<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><p>常看常新</p><h3 id="1-npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间"><a href="#1-npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间" class="headerlink" title="1. npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间"></a>1. npx可以不用管node版本的限制，先下载，之后删掉，不占电脑空间</h3><p>快速新建一个react项目：<code>npx create-react-app demo</code></p><h3 id="2-组件名称要大写"><a href="#2-组件名称要大写" class="headerlink" title="2. 组件名称要大写"></a>2. 组件名称要大写</h3><h3 id="3-最简易的react实例"><a href="#3-最简易的react实例" class="headerlink" title="3. 最简易的react实例"></a>3. 最简易的react实例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>开始进行提取：对值和方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatName</span>(<span class="hljs-params">user</span>) &#123;<br>  <span class="hljs-keyword">return</span> user.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + user.<span class="hljs-property">lastName</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Harper&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Perez&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> element = (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    Hello, &#123;formatName(user)&#125;!</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>);<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  element,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="4-JS中出现-代表其中想要写html，html中出现-代表其中想要写js"><a href="#4-JS中出现-代表其中想要写html，html中出现-代表其中想要写js" class="headerlink" title="4. JS中出现()代表其中想要写html，html中出现{}代表其中想要写js"></a>4. JS中出现()代表其中想要写html，html中出现{}代表其中想要写js</h3><h3 id="5-语法🍬："><a href="#5-语法🍬：" class="headerlink" title="5. 语法🍬："></a>5. 语法🍬：</h3><p>在vs code中配置jsx的语法：在设置中搜素include languages，添加”javascript”: “javascriptreact“，将Trigger Expansion On Tab设置为启用</p><p>安装es7插件，rcc+tab或rfc+tab改变人生（类组件和函数式组件</p><p>在settings.json中添加    “editor.formatOnSave”: true,  可以在保存时自动格式化代码</p><h3 id="6-普通变量的值变化不会触发视图更新，可以使用setState来更新视图"><a href="#6-普通变量的值变化不会触发视图更新，可以使用setState来更新视图" class="headerlink" title="6. 普通变量的值变化不会触发视图更新，可以使用setState来更新视图"></a>6. 普通变量的值变化不会触发视图更新，可以使用setState来更新视图</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> num = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">num</span>: <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">addNum</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">addNum</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;this.state.num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">                &#123;/* 改变值且刷新页面的四种写法 */&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.setState(&#123; num: this.state.num + 1 &#125;)&#125;&gt;累加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addNum.bind(this)&#125;</span>&gt;</span>累加2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.addNum()&#125;&gt;累加3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addNum&#125;</span>&gt;</span>累加3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    <span class="hljs-title function_">addNum</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">num</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">num</span> + <span class="hljs-number">1</span> &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-给自定义的方法传递参数："><a href="#7-给自定义的方法传递参数：" class="headerlink" title="7. 给自定义的方法传递参数："></a>7. 给自定义的方法传递参数：</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">btnClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-number">1</span>)&#125;&gt;按钮<span class="hljs-number">1</span>&lt;/button&gt;<br><span class="hljs-title function_">btnClick</span>(<span class="hljs-params">num</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="8-函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook-x2F-开发人员自定义的hook"><a href="#8-函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook-x2F-开发人员自定义的hook" class="headerlink" title="8. 函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook&#x2F;开发人员自定义的hook"></a>8. 函数式组件没有生命周期，没有this，函数式组件没有state状态，主要用Hook：React官方提供的hook&#x2F;开发人员自定义的hook</h3><h3 id="9-hook-只能用在组件函数的最顶层"><a href="#9-hook-只能用在组件函数的最顶层" class="headerlink" title="9. hook: 只能用在组件函数的最顶层"></a>9. hook: 只能用在组件函数的最顶层</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 最简单的hook：useState</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;good&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App5</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [msg, setMsg] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// const fn = () =&gt; &#123;</span><br>    <span class="hljs-comment">//     setMsg(&#x27;changed&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setMsg</span>(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;fn&#125;</span>&gt;</span>修改1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setMsg(0)&#125;&gt;修改2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setMsg(msg + 1)&#125;&gt;累加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-数据请求、检测数据更新、垃圾回收的实现：useEffect"><a href="#10-数据请求、检测数据更新、垃圾回收的实现：useEffect" class="headerlink" title="10. 数据请求、检测数据更新、垃圾回收的实现：useEffect"></a>10. 数据请求、检测数据更新、垃圾回收的实现：useEffect</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App6</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">const</span> [num1, setNum1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">const</span> [num2, setNum2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">// 模拟mounted，一般在这个位置写ajax：数据请求，也可以检测数据更新</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 检测特定数据更新，写在数组中，不写的话默认检测所有变量更新</span><br>    <span class="hljs-comment">// 不想检测可以给空数组</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;num1更新了&#x27;</span>)<br>    &#125;, [num1])<br><br>    <span class="hljs-comment">// 模拟beforeDestory，一般在这个阶段处理脏数据和垃圾回收</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;destory&#x27;</span>)<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字1为：&#123;num1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum1(num1 + 1)&#125;&gt;累加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字2为：&#123;num2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum2(num2 + 1)&#125;&gt;累加2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-组件间传参"><a href="#11-组件间传参" class="headerlink" title="11. 组件间传参"></a>11. 组件间传参</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 父传子：使用props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子组件 - &#123;props.num&#125; - <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> props.setNum(333)&#125;&gt;修改值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">num</span>=<span class="hljs-string">&#123;props.num&#125;</span> <span class="hljs-attr">setNum</span>=<span class="hljs-string">&#123;props.setNum&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 顶级组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App7</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-comment">// 提供给子组件用来修改num的函数</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Father</span> <span class="hljs-attr">num</span>=<span class="hljs-string">&#123;num&#125;</span> <span class="hljs-attr">setNum</span>=<span class="hljs-string">&#123;setNum&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 子传父，真正在干活的是父组件: 提供用于修改的函数</span><br></code></pre></td></tr></table></figure><h3 id="12-多级组件的传值一般会使用上下文空间"><a href="#12-多级组件的传值一般会使用上下文空间" class="headerlink" title="12. 多级组件的传值一般会使用上下文空间"></a>12. 多级组件的传值一般会使用上下文空间</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, createContext, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 创建上下文空间（提供者、消费者）（provider, consumer）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">NumContext</span> = <span class="hljs-title function_">createContext</span>()<br><br><span class="hljs-comment">// 父传子：使用props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; num, setNum &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">NumContext</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum(876)&#125;&gt;修改num<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-comment">//父组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Father</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><br><span class="hljs-comment">// 顶级组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App9</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-comment">// 提供给子组件用来修改num的函数</span><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">NumContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">num</span>, <span class="hljs-attr">setNum</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">NumContext.Provider</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义"><a href="#13-受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义" class="headerlink" title="13. 受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义"></a>13. 受控组件和不受控组件，只存在于表单元素，受控组件就是表单元素的value需要state（或useSate）定义</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App10</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;asd&#x27;</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">inputChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>        <span class="hljs-title function_">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">clickFn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChange&#125;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;clickFn&#125;</span>&gt;</span>获取输入框的值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125; <br><br><span class="hljs-comment">// 不受控组件：值不会被value和onChange影响</span><br><span class="hljs-comment">// 意味着表单元素的value无法通过state获取，只能使用ref（或useRef）获取</span><br></code></pre></td></tr></table></figure><h3 id="14-使用memo使父组件更新不影响子组件"><a href="#14-使用memo使父组件更新不影响子组件" class="headerlink" title="14. 使用memo使父组件更新不影响子组件"></a>14. 使用memo使父组件更新不影响子组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, memo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>child<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App11</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum(num + 1)&#125;&gt;</span><br><span class="language-xml">                累加</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>但是memo只有在子组件是纯静态的时候才有效，<br>不是纯静态时，可以使用useCallBack<br>memo可以配合useCallback使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, memo, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> props.doSth()&#125;&gt;累加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App11</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// setNum(newValue) 使用新值强行覆盖初始值</span><br>    <span class="hljs-comment">// serNum(num =&gt; num+1) 不断使用新值覆盖旧值</span><br>    <span class="hljs-keyword">const</span> doSth = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setNum</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num + <span class="hljs-number">1</span>)<br>    &#125;, [])<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">doSth</span>=<span class="hljs-string">&#123;doSth&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><br>也可以使用useMemo<br>    <span class="hljs-comment">// 函数中返回函数：高阶函数</span><br>    <span class="hljs-keyword">const</span> doSth = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setNum</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num + <span class="hljs-number">1</span>)<br>    &#125;, [])<br></code></pre></td></tr></table></figure><h3 id="15-React-Redux：javascript状态容器，提供可预测化的状态管理"><a href="#15-React-Redux：javascript状态容器，提供可预测化的状态管理" class="headerlink" title="15. React Redux：javascript状态容器，提供可预测化的状态管理"></a>15. React Redux：javascript状态容器，提供可预测化的状态管理</h3><p>在src下创建index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 仓库的入口文件，写好后基本不变</span><br><br><span class="hljs-comment">// 引入reducer</span><br><br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer)<br><br><span class="hljs-comment">// 导出仓库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>再创建reducer.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建初始状态，并导出一个函数</span><br><br><span class="hljs-keyword">const</span> defaultSate = &#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducerState</span> = (<span class="hljs-params">state = defaultSate, action</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 不能直接对state进行修改，加一层深拷贝</span><br>    <span class="hljs-keyword">let</span> newState = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))<br>    <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;addNum&quot;</span>:<br>            newState.<span class="hljs-property">num</span> += action.<span class="hljs-property">value</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newState;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> reducerState<br></code></pre></td></tr></table></figure><p>新建组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App13</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>数字为：&#123;props.num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> props.addN()&#125;&gt;累加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-comment">// 状态映射：将reducer中的state映射成props</span><br><span class="hljs-comment">// 让开发者可以在组件中使用props.num去调用state中的num</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">num</span>: state.<span class="hljs-property">num</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">addN</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> action = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;addNum&quot;</span>, value : <span class="hljs-number">2</span> &#125;<br>            <span class="hljs-title function_">dispatch</span>(action)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 事件派发映射：将reducer中的事件映射成props，让开发者可以在组件中使用方法</span><br><span class="hljs-comment">// export default connect(state映射, dispatch映射)(当前组件名称)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="hljs-title class_">App13</span>)<br></code></pre></td></tr></table></figure><h3 id="16-路由"><a href="#16-路由" class="headerlink" title="16. 路由"></a>16. 路由</h3><p>入口文件：src&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// door file</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span> /&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">App14.jsx</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>jsx<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Outlet</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App14</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>App14<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Outlet</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>路由文件：新建src&#x2F;router&#x2F;index.jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 基本思路：App &gt; Home + List + Detail</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../App14&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Home&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/List&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Detail&#x27;</span><br><br><span class="hljs-comment">// BrowserRouter（history模式）不带#需要配置，HashRouter（Hash模式）带#打包后即可</span><br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span>, <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-comment">// 定义一个路由</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BaseRouter</span> = (<span class="hljs-params"></span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">App</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/list&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">List</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Detail</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">BaseRouter</span>;<br></code></pre></td></tr></table></figure><p>点击跳转：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Outlet</span>, <span class="hljs-title class_">Link</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App14</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list&quot;</span>&gt;</span>列表页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/detail&quot;</span>&gt;</span>详情页<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Outlet</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以写成方法给button使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">goDetail</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 跳转详情页</span><br>    <span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/detail&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>携带参数：<br>斜杠也可以传参<br>在List.jsx中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; useParams &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">List</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; id &#125; = <span class="hljs-title function_">useParams</span>()<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>列表页 - &#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>路由文件中：<code>&lt;Route path=&quot;/list/:id&quot; element=&#123;&lt;List /&gt;&#125;&gt;&lt;/Route&gt;</code><br>传参时：<code>&lt;li&gt;&lt;Link to=&quot;/list/123&quot;&gt;列表页&lt;/Link&gt;&lt;/li&gt;</code></p><p>另一种：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [searchParams, setSearchParams] = <span class="hljs-title function_">useSearchParams</span>()<br>    <span class="hljs-keyword">let</span> id = searchParams.<span class="hljs-title function_">getAll</span>(<span class="hljs-string">&#x27;id&#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> (<br><br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>主页 - &#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>传参时：<code>&lt;li&gt;&lt;Link to=&quot;/home?id=456&quot;&gt;首页&lt;/Link&gt; &lt;/li&gt;</code></p><p>以上携带的数据有限，当想要携带大量数据时，比较麻烦，可以↓</p><pre><code class="hljs">const goDetail = () =&gt; &#123;    // 跳转详情页    navigate(&#39;/detail&#39;, &#123;        state: &#123; username: &#39;azure&#39; &#125;    &#125;)&#125;&lt;button onClick=&#123;goDetail&#125;&gt;跳转详情页&lt;/button&gt;</code></pre><p>在子组件定义<code>let location = useLocation()</code>来接收<br>展示：<code>&lt;div&gt;&lt;h2&gt;详情页 -- &#123;location.state ? location.state.username : &#39;&#39;&#125;&lt;/h2&gt;&lt;/div&gt;</code></p><h3 id="17-给404"><a href="#17-给404" class="headerlink" title="17. 给404"></a>17. 给404</h3><p>界面写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ErrorImg</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../assets/404.jpg&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Error</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/Users/azure/Desktop/ABC/react/&#123;ErrorImg&#125;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;404&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>路由页：<br><code>&lt;Route path=&quot;*&quot; element=&#123;&lt;Error /&gt;&#125;&gt;&lt;/Route&gt;</code></p><blockquote><p>Ref: </p><p>react 官方网站：<a href="https://react.docschina.org/">https://react.docschina.org</a></p><p>私人教程：<a href="http://codesohigh.com/subject/reactnew/">http://codesohigh.com/subject/reactnew/</a></p><p>react-redux：<a href="https://react-redux.js.org/">https://react-redux.js.org/</a></p><p>reactrouter：<a href="https://reactrouter.com/en/main">https://reactrouter.com/en/main</a></p></blockquote><h3 id="18-元素渲染"><a href="#18-元素渲染" class="headerlink" title="18. 元素渲染"></a>18. 元素渲染</h3><p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>ReactDOM.render()</code></p><p>考虑一个计时器实时更新的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> element = (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(element, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><blockquote><p>这个例子会在 <code>setInterval()</code>回调函数，每秒都调用<code>ReactDOM.render()</code>，在实践中，大多数 React 应用只会调用一次<code>ReactDOM.render()</code>，我们可以将这些代码封装到有状态组件中。</p></blockquote><p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，考虑 UI 在任意给定时刻的状态，而不是随时间变化的过程，能够消灭一整类的 bug。</p><h3 id="19-组件"><a href="#19-组件" class="headerlink" title="19. 组件"></a>19. 组件</h3><p>组件允许你将 UI 拆分为独立可复用的代码片段，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p><p><strong>函数组件</strong>：接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> hello, &#123; props.name &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class组件</strong>：与函数组件等效</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p><p>例如，这段代码会在页面上渲染 “Hello, Sara”：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span>;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  element,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>提取组件</strong>：将组件拆分为更小的组件</p><p>以如下组件为例：描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.author.avatarUrl&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.author.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;props.author.name&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.text&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;formatDate(props.date)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>提取<code>Avatar</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>建议从组件自身的角度命名<code>props</code>，而不是依赖于调用组件的上下文命名。</p><p>继续提取<code>UserInfo</code>组件，该组件在用户名旁渲染<code>Avatar</code>组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.user.name&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>简化后的<code>Comment</code>组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.text&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;formatDate(props.date)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 UI 中有一部分被多次使用（<code>Button</code>，<code>Panel</code>，<code>Avatar</code>），或者组件本身就足够复杂（<code>App</code>，<code>FeedStory</code>，<code>Comment</code>），那么它就是一个可提取出独立组件的候选项。</p><p><strong>props的只读性</strong>：所有 React 组件都必须像纯函数一样保护它们的 props 不被更改， “state”在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p><h3 id="20-State-amp-生命周期"><a href="#20-State-amp-生命周期" class="headerlink" title="20.State&amp;生命周期"></a>20.State&amp;生命周期</h3><p>向 class 组件中添加局部的 state，但没有即时更新效果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>运用生命周期方法和<code>this.setState()</code>来时刻更新组件<code>state</code>，让时钟每秒刷新：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">//componentDidMount() 方法会在组件已经被渲染到 DOM 中后运行</span><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerID</span> = <span class="hljs-built_in">setInterval</span>(<br>      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">tick</span>(),<br>      <span class="hljs-number">1000</span><br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//componentWillUnmount() 方法会在组件从dom中被移除时调用</span><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerID</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;      <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()    &#125;);  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>正确使用<code>state</code></strong></p><ol><li><p>不要直接修改<code>state</code>，而应该使用<code>setState()</code>，构造函数是唯一可以给<code>this.state</code>赋值的地方。</p></li><li><p><code>state</code>的更新可能是异步的，出于性能考虑，react可能会把多个<code>setState()</code>调用合并成一个调用，因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p><p>例如，下例可能不会更新计时器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Wrong</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">increment</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + props.<span class="hljs-property">increment</span><br>&#125;));<br></code></pre></td></tr></table></figure></li><li><p><code>state</code>的更新会被合并，当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state。</p><p>例如，你的 state 包含几个独立的变量：</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">super</span>(props);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>    <span class="hljs-attr">posts</span>: [],      <span class="hljs-attr">comments</span>: []    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后你可以分别调用 <code>setState()</code> 来单独地更新它们：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fetchPosts</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">posts</span>: response.<span class="hljs-property">posts</span>      &#125;);<br>  &#125;);<br><br>  <span class="hljs-title function_">fetchComments</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">comments</span>: response.<span class="hljs-property">comments</span>      &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里的合并是浅合并，所以 <code>this.setState(&#123;comments&#125;)</code> 完整保留了 <code>this.state.posts</code>， 但是完全替换了 <code>this.state.comments</code>。</p><ol start="4"><li>数据是向下流动的</li></ol><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p><p>如下例，<code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FormattedDate</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br>&lt;<span class="hljs-title class_">FormattedDate</span> date=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">date</span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p><p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><p>每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。</p><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p><p><img src="https://cdn.jsdelivr.net/gh/Yoonalis/img@master/blog/1151667355557_.pic-20221102%2010:22:44.jpg" alt="1151667355557_.pic">挂载</p><p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#constructor"><strong><code>constructor()</code></strong></a></li><li><a href="https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></li><li><a href="https://react.docschina.org/docs/react-component.html#componentdidmount"><strong><code>componentDidMount()</code></strong></a></li></ul><p>更新</p><p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></li><li><a href="https://react.docschina.org/docs/react-component.html#getsnapshotbeforeupdate"><code>getSnapshotBeforeUpdate()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#componentdidupdate"><strong><code>componentDidUpdate()</code></strong></a></li></ul><p>卸载</p><p>当组件从 DOM 中移除时会调用如下方法：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#componentwillunmount"><strong><code>componentWillUnmount()</code></strong></a></li></ul><p>错误处理</p><p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#static-getderivedstatefromerror"><code>static getDerivedStateFromError()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#componentdidcatch"><code>componentDidCatch()</code></a></li></ul><p>组件还提供了一些额外的 API：</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#setstate"><code>setState()</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#forceupdate"><code>forceUpdate()</code></a></li></ul><p>class 属性</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#defaultprops"><code>defaultProps</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#displayname"><code>displayName</code></a></li></ul><p>实例属性</p><ul><li><a href="https://react.docschina.org/docs/react-component.html#props"><code>props</code></a></li><li><a href="https://react.docschina.org/docs/react-component.html#state"><code>state</code></a></li></ul><p><code>render()</code> 方法是 class 组件中唯一必须实现的方法。</p><p>当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：</p><ul><li><strong>React 元素</strong>。通常通过 JSX 创建。例如，<code>&lt;div /&gt;</code> 会被 React 渲染为 DOM 节点，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为自定义组件，无论是 <code>&lt;div /&gt;</code> 还是 <code>&lt;MyComponent /&gt;</code> 均为 React 元素。</li><li><strong>数组或 fragments</strong>。 使得 render 方法可以返回多个元素。欲了解更多详细信息，请参阅 <a href="https://react.docschina.org/docs/fragments.html">fragments</a> 文档。</li><li><strong>Portals</strong>。可以渲染子节点到不同的 DOM 子树中。欲了解更多详细信息，请参阅有关 <a href="https://react.docschina.org/docs/portals.html">portals</a> 的文档</li><li><strong>字符串或数值类型</strong>。它们在 DOM 中会被渲染为文本节点</li><li>**布尔类型或 <code>null</code>**。什么都不渲染。（主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式，其中 test 为布尔类型。)</li></ul><p><code>render()</code> 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。</p><p>如需与浏览器进行交互，请在 <code>componentDidMount()</code> 或其他生命周期方法中执行你的操作。保持 <code>render()</code> 为纯函数，可以使组件更容易思考。</p><p>更多细节参考：<a href="https://react.docschina.org/docs/react-component.html">生命周期</a></p><h3 id="21-事件处理"><a href="#21-事件处理" class="headerlink" title="21. 事件处理"></a>21. 事件处理</h3><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li><li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;activateLasers&#125;&gt;<br>  <span class="hljs-title class_">Activate</span> <span class="hljs-title class_">Lasers</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code> 。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ActionLink</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The link was clicked.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Click me</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>e</code> 是一个合成事件。</p><p>当你使用 ES6 class语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">isToggleOn</span>: <span class="hljs-literal">true</span>&#125;;<br><br>    <span class="hljs-comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123;<br>      <span class="hljs-attr">isToggleOn</span>: !state.<span class="hljs-property">isToggleOn</span><br>    &#125;));<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toggle</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>向事件处理函数传递参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteRow</span>(id, e)&#125;&gt;<span class="hljs-title class_">Delete</span> <span class="hljs-title class_">Row</span>&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteRow.bind(this,</span> <span class="hljs-attr">id</span>)&#125;&gt;</span>Delete Row<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p><p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p><h3 id="22-条件渲染"><a href="#22-条件渲染" class="headerlink" title="22. 条件渲染"></a>22. 条件渲染</h3><p>React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else"><code>if</code></a> 或者<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">条件运算符</a>去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLoginClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLoginClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLogoutClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleLogoutClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">false</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">handleLoginClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">true</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">handleLogoutClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">false</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLoggedIn</span>;<br>    <span class="hljs-keyword">let</span> button;<br>    <span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>      button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">isLoggedIn</span>=<span class="hljs-string">&#123;isLoggedIn&#125;</span> /&gt;</span></span><br><span class="language-xml">        &#123;button&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginControl</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>也可以借助运算符&amp;&amp;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Mailbox</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> unreadMessages = props.<span class="hljs-property">unreadMessages</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      &#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> messages = [<span class="hljs-string">&#x27;React&#x27;</span>, <span class="hljs-string">&#x27;Re: React&#x27;</span>, <span class="hljs-string">&#x27;Re:Re: React&#x27;</span>];<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Mailbox</span> <span class="hljs-attr">unreadMessages</span>=<span class="hljs-string">&#123;messages&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>也可以借助三目运算符</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLoggedIn</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;isLoggedIn</span><br><span class="language-xml">        ? <span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span><br><span class="language-xml">        : <span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>阻止组件渲染：在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">if</span> (!props.<span class="hljs-property">warn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="23-列表-amp-key"><a href="#23-列表-amp-key" class="headerlink" title="23. 列表 &amp; key"></a>23. 列表 &amp; key</h3><p>主要使用<code>map()</code>函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NumberList</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> numbers = props.<span class="hljs-property">numbers</span>;<br>  <span class="hljs-keyword">const</span> listItems = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;number&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此应当&#x3D;&#x3D;给数组中的每一个元素赋予一个确定的标识&#x3D;&#x3D;，如上例使用<code>number.toString()</code>，也可以使用<code>number.id</code>。当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：<code>index</code>，但不建议，因为会导致性能变差，还可能引起组件状态的问题。</p></li><li><p>元素的 key 只有放在就近的数组上下文中才有意义。比方说，如果提取出一个 <code>ListItem</code> 组件，应该把 key 保留在数组中的这个 <code>&lt;ListItem /&gt;</code> 元素上，而不是放在 <code>ListItem</code> 组件中的 <code>&lt;li&gt;</code> 元素上。一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p></li><li><p>key只是在兄弟节点之间必须唯一，不需要是全局唯一，当生成两个不同的数组时，可以使用相同的key值。</p></li><li><p>key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 <code>key</code> 属性的值，请用其他属性名显式传递这个值：</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> content = posts.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">post</span>) =&gt;</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Post</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;post.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;post.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;post.title&#125;</span> /&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>上面例子中，<code>Post</code> 组件可以读出 <code>props.id</code>，但是不能读出 <code>props.key</code>。</p><p>JSX 允许在大括号中嵌入任何表达式，所以我们可以内联 <code>map()</code> 返回的结果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NumberList</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> numbers = props.<span class="hljs-property">numbers</span>;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;numbers.map((number) =&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;number&#125;</span> /&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="24-表单"><a href="#24-表单" class="headerlink" title="24.表单"></a>24.表单</h3><p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;form&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    名字:</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>此表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用&#x3D;&#x3D;受控组件&#x3D;&#x3D;。</p><p><strong>受控组件</strong></p><p>使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><p>例如，如果我们想在提交时打印出名称，我们可以将表单写为受控组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;提交的名字: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          名字:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>handlechange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p><p>对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。</p><p><strong>textarea标签</strong></p><p>在 React 中，<code>&lt;textarea&gt;</code> 使用 <code>value</code> 属性代替。使得使用 <code>&lt;textarea&gt;</code> 的表单和使用单行 input 的表单非常类似：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EssayForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;请撰写一篇关于你喜欢的 DOM 元素的文章.&#x27;</span>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);  &#125;<br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;提交的文章: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          文章:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，<code>this.state.value</code> 初始化于构造函数中，因此文本区域默认有初值。</p><p><strong>select标签</strong></p><p>React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlavorForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;coconut&#x27;</span>&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);  &#125;<br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你喜欢的风味是: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          选择你喜欢的风味:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;coconut&quot;</span>&gt;</span>椰子<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mango&quot;</span>&gt;</span>芒果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，这使得 <code>&lt;input type=&quot;text&quot;&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 之类的标签都非常相似—它们都接受一个 <code>value</code> 属性，你可以使用它来实现受控组件。另外，<code>value</code>属性支持传入数组，可以在<code>select</code>标签中选择多个选项：<code>&lt;select multiple=&#123;true&#125; value=&#123;[&#39;B&#39;, &#39;C&#39;]&#125;&gt;</code>。</p><p><strong>文件input标签</strong></p><p><code>&lt;input type=&quot;file&quot;&gt;</code> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的File API进行控制。</p><p>因为它的 value 只读，所以它是 React 中的一个&#x3D;&#x3D;非受控组件&#x3D;&#x3D;。将与其他非受控组件在后续文档中一起讨论。</p><p><strong>处理多个输入</strong></p><p>当需要处理多个 <code>input</code> 元素时，我们可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reservation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">isGoing</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">numberOfGuests</span>: <span class="hljs-number">2</span><br>    &#125;;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleInputChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleInputChange</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span>;<br>    <span class="hljs-keyword">const</span> value = target.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;isGoing&#x27;</span> ? target.<span class="hljs-property">checked</span> : target.<span class="hljs-property">value</span>;<br>    <span class="hljs-keyword">const</span> name = target.<span class="hljs-property">name</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      [name]: value    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          参与:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;isGoing&quot;</span>            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;this.state.isGoing&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleInputChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          来宾人数:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;numberOfGuests&quot;</span>            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.numberOfGuests&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleInputChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了 ES6 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names">计算属性名称</a>的语法更新给定输入名称对应的 state 值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  [name]: value<br>&#125;);<br></code></pre></td></tr></table></figure><p>另外，由于 <code>setState()</code> 自动[将部分 state 合并到当前 state，只需调用它更改部分 state 即可。</p><p><strong>受控输入空值</strong></p><p>在<a href="https://react.docschina.org/docs/forms.html#controlled-components">受控组件</a>上指定 value 的 prop 会阻止用户更改输入。如果你指定了 <code>value</code>，但输入仍可编辑，则可能是你意外地将<code>value</code> 设置为 <code>undefined</code> 或 <code>null</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hi&quot;</span> /&gt;</span></span>, mountNode);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;null&#125;</span> /&gt;</span></span>, mountNode);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>受控组件的替代品</strong></p><p>有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用&#x3D;&#x3D;非受控组件&#x3D;&#x3D;，这是实现输入表单的另一种方式。</p><p><strong>成熟的解决方案</strong></p><p>如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 <a href="https://jaredpalmer.com/formik">Formik</a> 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。</p><p><strong>&#x3D;&#x3D;非受控组件&#x3D;&#x3D;</strong></p><p>在大多数情况下，我们推荐使用 <a href="https://react.docschina.org/docs/forms.html#controlled-components">受控组件</a> 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</p><p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 <a href="https://react.docschina.org/docs/refs-and-the-dom.html">使用 ref</a> 来从 DOM 节点中获取表单数据。</p><p>例如，下面的代码使用非受控组件接受一个表单的值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">input</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;A name was submitted: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">input</span>.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>);<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          Name:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.input&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p><p>如果你还是不清楚在某个特殊场景中应该使用哪种组件，那么 <a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">这篇关于受控和非受控输入组件的文章</a> 会很有帮助。</p><p><strong>默认值</strong></p><p>在 React 渲染生命周期时，表单元素上的 <code>value</code> 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 <code>defaultValue</code> 属性，而不是 <code>value</code>。</p><p>同样，<code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code> 支持 <code>defaultChecked</code>，<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 支持 <code>defaultValue</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        Name:</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;Bob&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.input&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在 React 中，<code>&lt;input type=&quot;file&quot; /&gt;</code> 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。</p><p>您应该使用 File API 与文件进行交互。下面的例子显示了如何创建一个 <a href="https://react.docschina.org/docs/refs-and-the-dom.html">DOM 节点的 ref</a> 从而在提交表单时获取文件的信息。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br>  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-title function_">alert</span>(<br>      <span class="hljs-string">`Selected file - <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.fileInput.current.files[<span class="hljs-number">0</span>].name&#125;</span>`</span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          Upload file:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.fileInput&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FileInput</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="25-状态提升"><a href="#25-状态提升" class="headerlink" title="25.状态提升"></a>25.状态提升</h3><p>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。</p><p>如下情况：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BoilingVerdict</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">celsius</span> &gt;= <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The water would boil.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The water would not boil.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> scaleNames = &#123;<br>  <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;Celsius&#x27;</span>,<br>  <span class="hljs-attr">f</span>: <span class="hljs-string">&#x27;Fahrenheit&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">temperature</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> temperature = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">temperature</span>;<br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">scale</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在可以修改 <code>Calculator</code> 组件让它渲染两个独立的温度输入框组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;c&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;f&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在有了两个输入框，但当你在其中一个输入温度时，另一个并不会更新。这与我们的要求相矛盾：我们希望让它们保持同步。</p><p>另外，我们也不能通过 <code>Calculator</code> 组件展示 <code>BoilingVerdict</code> 组件的渲染结果。因为 <code>Calculator</code> 组件并不知道隐藏在 <code>TemperatureInput</code> 组件中的当前温度是多少。</p><p>在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。接下来，我们将 <code>TemperatureInput</code> 组件中的 state 移动至 <code>Calculator</code> 组件中去。</p><p>如果 <code>Calculator</code> 组件拥有了共享的 state，它将成为两个温度输入框中当前温度的“数据源”。它能够使得两个温度输入框的数值彼此保持一致。由于两个 <code>TemperatureInput</code> 组件的 props 均来自共同的父组件 <code>Calculator</code>，因此两个输入框中的内容将始终保持一致。</p><p>修改后：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">onTemperatureChange</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> temperature = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">temperature</span>;<br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">scale</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleCelsiusChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleCelsiusChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleFahrenheitChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleFahrenheitChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;  &#125;<br><br>  <span class="hljs-title function_">handleCelsiusChange</span>(<span class="hljs-params">temperature</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>, temperature&#125;);  &#125;<br><br>  <span class="hljs-title function_">handleFahrenheitChange</span>(<span class="hljs-params">temperature</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;f&#x27;</span>, temperature&#125;);  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">scale</span>;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">temperature</span>;    <span class="hljs-keyword">const</span> celsius = scale === <span class="hljs-string">&#x27;f&#x27;</span> ? <span class="hljs-title function_">tryConvert</span>(temperature, toCelsius) : temperature;    <span class="hljs-keyword">const</span> fahrenheit = scale === <span class="hljs-string">&#x27;c&#x27;</span> ? <span class="hljs-title function_">tryConvert</span>(temperature, toFahrenheit) : temperature;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;c&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">temperature</span>=<span class="hljs-string">&#123;celsius&#125;</span>          <span class="hljs-attr">onTemperatureChange</span>=<span class="hljs-string">&#123;this.handleCelsiusChange&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;f&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">temperature</span>=<span class="hljs-string">&#123;fahrenheit&#125;</span>          <span class="hljs-attr">onTemperatureChange</span>=<span class="hljs-string">&#123;this.handleFahrenheitChange&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">BoilingVerdict</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">celsius</span>=<span class="hljs-string">&#123;parseFloat(celsius)&#125;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>附带一些转换函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toCelsius</span>(<span class="hljs-params">fahrenheit</span>) &#123;<br>  <span class="hljs-keyword">return</span> (fahrenheit - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toFahrenheit</span>(<span class="hljs-params">celsius</span>) &#123;<br>  <span class="hljs-keyword">return</span> (celsius * <span class="hljs-number">9</span> / <span class="hljs-number">5</span>) + <span class="hljs-number">32</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tryConvert</span>(<span class="hljs-params">temperature, convert</span>) &#123;<br>  <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">parseFloat</span>(temperature);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(input)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> output = <span class="hljs-title function_">convert</span>(input);<br>  <span class="hljs-keyword">const</span> rounded = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(output * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> rounded.<span class="hljs-title function_">toString</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠<a href="https://react.docschina.org/docs/state-and-lifecycle.html#the-data-flows-down">自上而下的数据流</a>，而不是尝试在不同组件间同步 state。</p><p>虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。</p><p>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。举个例子，本例中我们没有将 <code>celsiusValue</code> 和 <code>fahrenheitValue</code> 一起保存，而是仅保存了最后修改的 <code>temperature</code> 和它的 <code>scale</code>。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的 <code>render()</code> 方法获得。这使得我们能够清除输入框内容，亦或是，在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作。</p><p>当你在 UI 中发现错误时，可以使用 <a href="https://github.com/facebook/react/tree/master/packages/react-devtools">React 开发者工具</a> 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。这使得你能够追踪到产生 bug 的源头：</p><h3 id="26-React组合"><a href="#26-React组合" class="headerlink" title="26. React组合"></a>26. React组合</h3><p><strong>包含关系</strong></p><p>有些组件无法提前知晓它们子组件的具体内容。在 <code>Sidebar</code>（侧边栏）和 <code>Dialog</code>（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。</p><p>我们建议这些组件使用一个特殊的 <code>children</code> prop 来将他们的子组件传递到渲染结果中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyBorder</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">FancyBorder</span> <span class="hljs-attr">FancyBorder-</span>&#x27; + <span class="hljs-attr">props.color</span>&#125;&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">WelcomeDialog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;</span></span><br><span class="language-xml">          Welcome      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;</span></span><br><span class="language-xml">          Thank you for visiting our spacecraft!      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>   </span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;FancyBorder&gt;</code> JSX 标签中的所有内容都会作为一个 <code>children</code> prop 传递给 <code>FancyBorder</code> 组件。因为 <code>FancyBorder</code> 将 <code>&#123;props.children&#125;</code> 渲染在一个 <code>&lt;div&gt;</code> 中，被传递的这些子组件最终都会出现在输出结果中。</p><p>少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 <code>children</code>，而是自行约定：将所需内容传入 props，并使用相应的 prop。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SplitPane</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane-left&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.left&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane-right&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.right&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SplitPane</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">left</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &lt;<span class="hljs-attr">Contacts</span> /&gt;</span></span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">      right=&#123;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Chat</span> /&gt;</span></span><br><span class="language-xml">      &#125; /&gt;</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;Contacts /&gt;</code> 和 <code>&lt;Chat /&gt;</code> 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</p><p><strong>特例关系</strong></p><p>有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 <code>WelcomeDialog</code> 可以说是 <code>Dialog</code> 的特殊实例。</p><p>在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dialog</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.title&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.message&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">WelcomeDialog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Welcome&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;Thank you for visiting our spacecraft!&quot;</span> /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>组合也同样适用于以 class 形式定义的组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dialog</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.title&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.message&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SignUpDialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSignUp</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSignUp</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">login</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Mars Exploration Program&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;How should we refer to you?&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.login&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleSignUp&#125;</span>&gt;</span></span><br><span class="language-xml">          Sign Me Up!</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span></span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">login</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">handleSignUp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Welcome aboard, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.login&#125;</span>!`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="27-hook"><a href="#27-hook" class="headerlink" title="27. hook"></a>27. hook</h3><p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>这个例子用来显示一个计数器。当你点击按钮，计数器的值就会增加：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明一个新的叫做 “count” 的 state 变量</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以在一个组件中多次使用 State Hook：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleWithManyStates</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明多个 state 变量！</span><br>  <span class="hljs-keyword">const</span> [age, setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">42</span>);<br>  <span class="hljs-keyword">const</span> [fruit, setFruit] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;banana&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [todos, setTodos] = <span class="hljs-title function_">useState</span>([&#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn Hooks&#x27;</span> &#125;]);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用State Hook</strong></p><p>深入了解<code>useState</code></p><p><strong><code>useState</code> 需要哪些参数？</strong> <code>useState()</code> 方法里面唯一的参数就是初始 state。不同于 class 的是，我们可以按照需要使用数字或字符串对其进行赋值，而不一定是对象。在示例中，只需使用数字来记录用户点击次数，所以我们传了 <code>0</code> 作为变量的初始 state。（如果我们想要在 state 中存储两个不同的变量，只需调用 <code>useState()</code> 两次即可。）</p><p><strong><code>useState</code> 方法的返回值是什么？</strong> 返回值为：当前 state 以及更新 state 的函数。这就是我们写 <code>const [count, setCount] = useState()</code> 的原因。这与 class 里面 <code>this.state.count</code> 和 <code>this.setState</code> 类似，唯一区别就是你需要成对的获取它们。</p><p>以此了解下例：声明了一个叫 <code>count</code> 的 state 变量，然后把它设为 <code>0</code>。React 会在重复渲染时记住它当前的值，并且提供最新的值给函数。我们可以通过调用 <code>setCount</code> 来更新当前的 <code>count</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明一个叫 &quot;count&quot; 的 state 变量</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>读取State：在函数中，我们可以直接用 <code>count</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;p&gt;<span class="hljs-title class_">You</span> clicked &#123;count&#125; times&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>更新State：在函数中，我们已经有了 <code>setCount</code> 和 <code>count</code> 变量，所以我们不需要 <code>this</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>)&#125;&gt;<br>  <span class="hljs-title class_">Click</span> me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>使用多个state变量</p><p>将 state 变量声明为一对 <code>[something, setSomething]</code> 也很方便，因为如果我们想使用多个 state 变量，它允许我们给不同的 state 变量取不同的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx\">function ExampleWithManyStates() &#123;<br>  // 声明多个 state 变量<br>  const [age, setAge] = useState(42);<br>  const [fruit, setFruit] = useState(&#x27;banana&#x27;);<br>  const [todos, setTodos] = useState([&#123; text: &#x27;学习 Hook&#x27; &#125;]);<br></code></pre></td></tr></table></figure><p>在以上组件中，我们有局部变量 <code>age</code>，<code>fruit</code> 和 <code>todos</code>，并且我们可以单独更新它们：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleOrangeClick</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 和 this.setState(&#123; fruit: &#x27;orange&#x27; &#125;) 类似</span><br>  <span class="hljs-title function_">setFruit</span>(<span class="hljs-string">&#x27;orange&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你<strong>不必</strong>使用多个 state 变量。State 变量可以很好地存储对象和数组，因此，你仍然可以将相关数据分为一组。然而，不像 class 中的 <code>this.setState</code>，更新 state 变量总是<em>替换</em>它而不是合并它。</p><p><strong>使用Effect Hook：</strong></p><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。React 内置了一些像 <code>useState</code> 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。</p><p><code>useEffect</code> 是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API。</p><p>例如，下面这个组件在 React 更新 DOM 后会设置一个页面标题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 相当于 componentDidMount 和 componentDidUpdate:</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 使用浏览器的 API 更新页面标题</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>当你调用 <code>useEffect</code> 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— <strong>包括</strong>第一次渲染的时候。</p><p>副作用函数还可以通过返回一个函数来指定如何“清除”副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。</p><p>不需要清除的：</p><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p><p>在 React 的 class 组件中，<code>render</code> 函数是不应该有任何副作用的。一般来说，在这里执行操作太早了，我们基本上都希望在 React 更新 DOM 之后才执行我们的操作。这就是为什么在 React class 中，我们把副作用操作放到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 函数中。很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上说，我们希望它在每次渲染之后执行 —— 但 React 的 class 组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它。现在让我们来看看如何使用 <code>useEffect</code> 执行相同的操作。</p><p><strong><code>useEffect</code> 做了什么？</strong> 通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。</p><p><strong>为什么在组件内部调用 <code>useEffect</code>？</strong> 将 <code>useEffect</code> 放在组件内部让我们可以在 effect 中直接访问 <code>count</code> state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><p><strong><code>useEffect</code> 会在每次渲染后都执行吗？</strong> 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><p>需要清除的：</p><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p><p>你可能认为需要单独的 effect 来执行清除操作。但由于添加和删除订阅的代码的紧密性，所以 <code>useEffect</code> 的设计是在同一个地方执行。如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>      <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>    &#125;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    <span class="hljs-comment">// Specify how to clean up after this effect:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要在 effect 中返回一个函数？</strong> 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p><strong>React 何时清除 effect？</strong> React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React <em>会</em>在执行当前 effect 之前对上一个 effect 进行清除。</p><p>通过跳过 Effect 进行性能优化：在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>&#125;, [count]); <span class="hljs-comment">// 仅在 count 更改时更新</span><br></code></pre></td></tr></table></figure><p>对于有清除操作的 effect 同样适用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>  &#125;<br><br>  <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>  &#125;;<br>&#125;, [props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>]); <span class="hljs-comment">// 仅在 props.friend.id 发生变化时，重新订阅</span><br></code></pre></td></tr></table></figure><p><strong>hook规则</strong></p><ol><li><p>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p></li><li><p>只在 React 函数中调用 Hook</p></li></ol><h3 id="28-hook-api索引"><a href="#28-hook-api索引" class="headerlink" title="28. hook api索引"></a>28. hook api索引</h3><p><strong>基础hook：</strong></p><p>&#x3D;&#x3D;useState&#x3D;&#x3D;：返回一个 state，以及更新 state 的函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);<br><span class="hljs-title function_">setState</span>(newState);<br></code></pre></td></tr></table></figure><p>函数式更新：如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 <code>setState</code>。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 <code>setState</code> 的两种用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialCount);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 也可以使用 Object.assign</span><br>  <span class="hljs-keyword">return</span> &#123;...prevState, ...updatedValues&#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>惰性初始 state：<code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> initialState = <span class="hljs-title function_">someExpensiveComputation</span>(props);<br>  <span class="hljs-keyword">return</span> initialState;<br>&#125;);<br></code></pre></td></tr></table></figure><p>跳过 state 更新：调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><p>&#x3D;&#x3D;useEffect&#x3D;&#x3D;：接收一个包含命令式、且可能有副作用代码的函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(didUpdate);<br></code></pre></td></tr></table></figure><p>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p><p>使用 <code>useEffect</code> 完成副作用操作。赋值给 <code>useEffect</code> 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p><p>清除 effect：通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，<code>useEffect</code> 函数需返回一个清除函数。以下就是一个创建订阅的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> subscription = props.<span class="hljs-property">source</span>.<span class="hljs-title function_">subscribe</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 清除订阅</span><br>    subscription.<span class="hljs-title function_">unsubscribe</span>();<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则<strong>在执行下一个 effect 之前，上一个 effect 就已被清除</strong>。在上述示例中，意味着组件的每一次更新都会创建新的订阅。</p><p>effect的执行时机：与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数会延迟调用。虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p><p>effect的条件执行：默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 <code>source</code> prop 改变时重新创建。要实现这一点，可以给 <code>useEffect</code> 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> subscription = props.<span class="hljs-property">source</span>.<span class="hljs-title function_">subscribe</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      subscription.<span class="hljs-title function_">unsubscribe</span>();<br>    &#125;;<br>  &#125;,<br>  [props.<span class="hljs-property">source</span>],<br>);<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;useContext&#x3D;&#x3D;：接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>);<br></code></pre></td></tr></table></figure><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <a href="https://react.docschina.org/docs/react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="https://react.docschina.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，也会在组件本身使用 <code>useContext</code> 时重新渲染。别忘记 <code>useContext</code> 的参数必须是 context 对象本身：<code>useContext(MyContext)</code></p><p>调用了 <code>useContext</code> 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以通过使用 memoization 来优化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> themes = &#123;<br>  <span class="hljs-attr">light</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;#eeeeee&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">dark</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;#222222&quot;</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(themes.<span class="hljs-property">light</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;themes.dark&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Toolbar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemedButton</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">theme.background</span>, <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.foreground</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      I am styled by theme context!</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>以下介绍的 Hook，有些是上一节中基础 Hook 的变体，有些则仅在特殊情况下会用到。不用特意预先学习它们。</p><p>&#x3D;&#x3D;useReducer&#x3D;&#x3D;：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialArg, init);<br></code></pre></td></tr></table></figure><p><a href="https://react.docschina.org/docs/hooks-reference.html#usestate"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数。</p><p>以下是用 reducer 重写<code>useState</code> 一节的计数器示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> initialState = &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>React 会确保 <code>dispatch</code> 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code>。</p><p>指定初始 state：有两种不同初始化 <code>useReducer</code> state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 <code>useReducer</code> 是最简单的方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(<br>  reducer,<br>  &#123;<span class="hljs-attr">count</span>: initialCount&#125;  );<br></code></pre></td></tr></table></figure><p>惰性初始化：你可以选择惰性地创建初始 state。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被设置为 <code>init(initialArg)</code>。这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">initialCount</span>) &#123;  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: initialCount&#125;;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">init</span>(action.<span class="hljs-property">payload</span>);    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialCount, init);  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;        Reset</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>跳过 dispatch：如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><p>&#x3D;&#x3D;useCallback&#x3D;&#x3D;：返回一个memoized回调函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">doSomething</span>(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><p>&#x3D;&#x3D;useMemo&#x3D;&#x3D;：返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b]);<br></code></pre></td></tr></table></figure><p>把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p><strong>你可以把 <code>useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。</strong>将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 <code>useMemo</code> 的情况下也可以执行的代码 —— 之后再在你的代码中添加 <code>useMemo</code>，以达到优化性能的目的。</p><p>&#x3D;&#x3D;useRef&#x3D;&#x3D;：返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx\">const refContainer = useRef(initialValue);<br></code></pre></td></tr></table></figure><p>一个常见的用例便是命令式地访问子组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputEl = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onButtonClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span><br>    inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputEl&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。你应该熟悉 ref 这一种访问 DOM的主要方式。如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p><p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。这是因为它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象。请记住，当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用<a href="https://react.docschina.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node">回调 ref</a> 来实现。</p><p>&#x3D;&#x3D;useImperativeHandle&#x3D;&#x3D;：在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <a href="https://react.docschina.org/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyInput</span>(<span class="hljs-params">props, ref</span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">...</span> /&gt;</span></span>;<br>&#125;<br><span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">FancyInput</span>);<br></code></pre></td></tr></table></figure><p>在本例中，渲染 <code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 <code>inputRef.current.focus()</code>。</p><p>&#x3D;&#x3D;useLayoutEffect&#x3D;&#x3D;：其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p><p>&#x3D;&#x3D;useDebugValue&#x3D;&#x3D;： 可用于在 React 开发者工具中显示自定义 hook 的标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useDebugValue</span>(value)<br></code></pre></td></tr></table></figure><h3 id="29-基于路由的代码分割"><a href="#29-基于路由的代码分割" class="headerlink" title="29. 基于路由的代码分割"></a>29. 基于路由的代码分割</h3><p>如何在你的应用中使用 <code>React.lazy</code> 和 <a href="https://react-router.docschina.org/">React Router</a> 这类的第三方库，来配置基于路由的代码分割。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Suspense</span>, lazy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Switch</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./routes/Home&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./routes/About&#x27;</span>));<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;/</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><h3 id="30-Context：在组件树间进行数据传递的方法"><a href="#30-Context：在组件树间进行数据传递的方法" class="headerlink" title="30.Context：在组件树间进行数据传递的方法"></a>30.Context：在组件树间进行数据传递的方法</h3><p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p><p><strong><code>React.createContext</code></strong></p><p>创建一个Context对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p><p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue);<br></code></pre></td></tr></table></figure><p><strong><code>Context.Provider</code></strong></p><p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p><p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span> value=&#123;<span class="hljs-comment">/* 某个值 */</span>&#125;&gt;<br></code></pre></td></tr></table></figure><p><strong><code>Context.Consumer</code></strong></p><p>这里，React 组件也可以订阅到 context 变更。这能让你在<a href="https://react.docschina.org/docs/components-and-props.html#function-and-class-components">函数式组件</a>中完成订阅 context。</p><p>这需要<a href="https://react.docschina.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child）</a>这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 <code>value</code> 值等同于往上组件树离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Consumer</span>&gt;<br>  &#123;<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-comment">/* 基于 context 值进行渲染*/</span>&#125;<br>&lt;/<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Consumer</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>在嵌套组件中更新 Context</strong></p><p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context：</p><p>theme-context.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(&#123;<br>  <span class="hljs-attr">theme</span>: themes.<span class="hljs-property">dark</span>,<br>  <span class="hljs-attr">toggleTheme</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>theme-toggler-button.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ThemeContext</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./theme-context&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeTogglerButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>          <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleTheme&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;backgroundColor:</span> <span class="hljs-attr">theme.background</span>&#125;&#125;&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">          Toggle Theme</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ThemeTogglerButton</span>;<br></code></pre></td></tr></table></figure><p>app.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ThemeContext</span>, themes&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./theme-context&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ThemeTogglerButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./theme-toggler-button&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toggleTheme</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123;<br>        <span class="hljs-attr">theme</span>:<br>          state.<span class="hljs-property">theme</span> === themes.<span class="hljs-property">dark</span><br>            ? themes.<span class="hljs-property">light</span><br>            : themes.<span class="hljs-property">dark</span>,<br>      &#125;));<br>    &#125;;<br><br>    <span class="hljs-comment">// State 也包含了更新函数，因此它会被传递进 context provider。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">theme</span>: themes.<span class="hljs-property">light</span>,<br>      <span class="hljs-attr">toggleTheme</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">toggleTheme</span>,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 整个 state 都被传递进 provider</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeTogglerButton</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">root</span>);<br><br></code></pre></td></tr></table></figure><p><strong>消费多个 Context</strong></p><p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Theme context，默认的 theme 是 “light” 值</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-comment">// 用户登录 context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Guest&#x27;</span>,<br>&#125;);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;signedInUser, theme&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br><br>    <span class="hljs-comment">// 提供初始 context 值的 App 组件</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;signedInUser&#125;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Sidebar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 一个组件可能会消费多个 context</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Content</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      &#123;theme =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">          &#123;user =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ProfilePage</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;user&#125;</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span><br><span class="language-xml">          )&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</p><p>注意事项：因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 <code>value</code> 属性总是被赋值为新的对象。</p><p>为了防止这种情况，将 value 状态提升到父节点的 state 里：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">value</span>: &#123;<span class="hljs-attr">something</span>: <span class="hljs-string">&#x27;something&#x27;</span>&#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
